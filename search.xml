<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Effectivate Modern Cpp</title>
      <link href="/posts/ccc0d0ac.html"/>
      <url>/posts/ccc0d0ac.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>转载：<a href="https://joytsing.cn/posts/46568/">https://joytsing.cn/posts/46568/</a></p><p>结合自己的学习内容进行补充</p><h2 id="第一章：类型推导">第一章：类型推导</h2><h3 id="条款-1：理解模板类型推导">条款 1：理解模板类型推导</h3><hr><p>重点：</p><blockquote><p><strong>模板类型推导</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure><p>在编译的时候，编译器通过 expr 来进行推导出两个类型：</p><ul><li>T</li><li>ParamType</li></ul><p>形式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr); <span class="comment">// 用一些表达式来调用f</span></span><br></pre></td></tr></table></figure><p><strong>对于 T 的类型推导不仅取决于 <code>expr</code> 的类型，还取决于 <code>ParamType</code> 的形式</strong>。</p><p>有三种情况：</p><ul><li><code>ParamType</code> 是指针或引用，但不是通用引用（通用引用在条款24中介绍）。</li><li><code>ParamType</code> 是通用引用。</li><li><code>ParamType</code> 既不是指针也不是引用。<ul><li>按pass-by-value处理：<ul><li>如果 expr 的类型是个引用，将会忽略引用的部分。</li><li>如果expr 是 const 的，也要忽略掉 const 。如果是 volatile的，也要忽略掉。</li></ul></li></ul></li></ul><blockquote><p><strong>数组参数</strong></p></blockquote><p><strong>虽然通常情况下，一个数组会被退化成一个指向其第一个元素的指针，数组类型和指针类型是不一样的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// name的类型是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * ptrToName = name; <span class="comment">// 数组被退化成指针</span></span><br></pre></td></tr></table></figure><p>case1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(<span class="type">int</span> param[])</span>;   </span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(<span class="type">int</span>* param)</span>;    <span class="comment">// 和上面的函数是一样的</span></span><br><span class="line">f(name); <span class="comment">// name是个数组，但是T被推导成const char*</span></span><br></pre></td></tr></table></figure><p>case2:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// 引用参数的模板</span></span><br><span class="line"><span class="built_in">f</span>(name); <span class="comment">// 传递数组给f</span></span><br></pre></td></tr></table></figure><p><strong>T 被推导成了 const char [13] ，函数 f 的参数（数组的引用）被推导成了 const char(&amp;)[13]</strong></p><blockquote><p><strong>函数参数</strong></p></blockquote><p>函数类型可以被退化成函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>， <span class="type">double</span>)</span></span>; <span class="comment">// someFunc是一个函数，类型是void(int, double)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>; <span class="comment">// 在f1中 参数直接按值传递</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// 在f2中 参数是按照传递</span></span><br><span class="line"><span class="built_in">f1</span>(someFunc); <span class="comment">// param被推导成函数指针，类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc); <span class="comment">// param被推导成函数引用，类型是void(&amp;)(int, double)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要点</p><ul><li><p>在模板类型推导期间，引用实参被视为非引用，即忽略其引用性质。</p></li><li><p>在推导通用引用形参的类型时，左值实参会得到特殊处理。</p></li><li><p>在推导按值传递的形参类型时，const 和/或 volatile 参数被视为非 const 和非volatile的。</p></li><li><p>在模板类型推导期间，数组或函数实参会退化为相应的指针，除非它们用于初始化引用。</p></li></ul><hr><p>函数模板大致形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure><p>在编译期，编译器会通过表达式推导出两个类型：一个是<code>T</code>的类型，另一个是<code>ParamType</code>的类型，这两个类型往往不一样，<code>ParamType</code>常包含一些饰词，如<code>const</code>或引用符号等限定词。</p><p><strong>情况 1：ParamType 是个指针或引用，但不是个万能引用</strong></p><ol><li>若表达式具有引用类型，则先将引用部分忽略。</li><li>对表达式的类型和<code>ParamType</code>进行匹配来决定<code>T</code>的类型。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 的类型为 int, paramType 为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 的类型为 const int, paramType 为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 的类型为 const int, paramType 为 const int&amp;</span></span><br></pre></td></tr></table></figure><p>若我们假定<code>param</code>具有常引用类型，则<code>T</code>的类型推导结果中也就没必要包含<code>const</code>了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 的类型为 int, paramType 为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 的类型为 int, paramType 为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 的类型为 int, paramType 为 const int&amp;</span></span><br></pre></td></tr></table></figure><p>如果<code>param</code>是个指针（或指向 const 对象的指针）而非引用，运作方式本质上并无不同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);   <span class="comment">// T 的类型为 int, paramType 为 int*</span></span><br><span class="line"><span class="built_in">f</span>(px);   <span class="comment">// T 的类型为 const int, paramType 为 const int*</span></span><br></pre></td></tr></table></figure><p><strong>情况 2：ParamType 是个万能引用</strong></p><blockquote><p>详细说明请参考<strong>条款 24</strong>。</p></blockquote><ol><li>如果表达式是个左值，则<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</li><li>如果表达式是个右值，则遵循情况 1 中的规则。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值的情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 的类型为 int&amp;, paramType 为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值的情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>)    <span class="comment">// T 的类型为 int, paramType 为 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p><strong>情况 3：ParamType 既非指针也非引用</strong></p><p>这种情况即为按值传递，无论传入的是什么，<code>param</code>都会是它的一个副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 和 param 的类型均为 int</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 和 param 的类型均为 int</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 和 param 的类型均为 int</span></span><br></pre></td></tr></table></figure><p>需要注意的是对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr = <span class="string">&quot;Fun with pointers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(ptr);    <span class="comment">// T 和 param 的类型均为 const char*</span></span><br></pre></td></tr></table></figure><p><strong>数组实参：</strong></p><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);   <span class="comment">// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]</span></span><br></pre></td></tr></table></figure><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数实参：</strong></p><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);   <span class="comment">// param 被推导为函数指针，具体类型为 void (*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);   <span class="comment">// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure><h3 id="条款-2：理解-auto-类型推导">条款 2：理解 auto 类型推导</h3><hr><p>重点：</p><p>auto类型推导几乎模板类型推导【因此，也分为3种情况】，除了特例。</p><p>case：对待花括号初始化的行为，是 auto 唯一和模板类型推导不一样的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;; <span class="comment">// x的类型是 std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 和x的声明等价的模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); <span class="comment">// 错误！没办法推导T的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); <span class="comment">// T被推导成int，initList的类型是std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>auto 和模板类型推导的<strong>本质区别</strong>就是 auto 假设花括号初始化代表的是std::initializer_list，但模板类型推导不是</p><p><strong>要点</strong></p><ul><li>auto类型推导通常与模板类型推导相同，但auto类型推导假定带花括号的初始化列表的类型表示为 std::initializer_list，而模板类型推导则不会这样假设。</li><li><strong>在函数返回类型或 lambda 参数中使用 auto 意味着模板类型推导，而不是auto类型推导。</strong></li></ul><hr><p><code>auto</code>类型推导除了在一个例外情况下，和模板类型推导的规则一模一样，同样可以分为三种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;        <span class="comment">// 类型为 int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;  <span class="comment">// 类型为 const int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x; <span class="comment">// 类型为 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;   <span class="comment">// 类型为 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx;  <span class="comment">// 类型为 const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;  <span class="comment">// 类型为 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>数组和函数实参的非引用退化规则也同样适用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// 类型为 const char[13]</span></span><br><span class="line"><span class="keyword">auto</span> arr1 = name;                   <span class="comment">// 类型为 const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name;                  <span class="comment">// 类型为 const char (&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">// 类型为 void(int, double)</span></span><br><span class="line"><span class="keyword">auto</span> func1= someFunc;               <span class="comment">// 类型为 void (*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2= someFunc;              <span class="comment">// 类型为 void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure><p>下面我们将讨论例外情况：<code>auto</code>会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>，但模板类型推导不会。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;   <span class="comment">// 类型为 std::initializer_list&lt;int&gt;，值为 &#123; 27 &#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;      <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;    <span class="comment">// 错误，类型不一致</span></span><br><span class="line">                            <span class="comment">// 无法推导出 std::initializer_list&lt;T&gt; 中的 T</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="built_in">f1</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);   <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(std::initializer_list&lt;T&gt; param)</span></span>;</span><br><span class="line"><span class="built_in">f2</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);   <span class="comment">// 正确，ParamType 为 std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要特别注意的是，2014 年 C++ 标准委员会通过了 <a href="https://link.zhihu.com/?target=https%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html">N3922 提案</a>，修改了<code>auto</code>对于大括号初始化的类型推断规则。上面所提及的<code>auto x4&#123; 27 &#125;</code>这行代码中，<code>x4</code>推导出的的类型已经不再是<code>std::initializer_list&lt;int&gt;</code>，而是<code>int</code>。</p></blockquote><p>在 C++14 中，允许使用<code>auto</code>来说明函数返回值需要推导，而且 lambda 表达式也会在形参声明中用到<code>auto</code>。然而这些<code>auto</code>用法使用的是模板类型推导而非<code>auto</code>类型推导，因此也不能使用大括号括起的初始化表达式。</p><h3 id="条款-3：理解-decltype">条款 3：理解 decltype</h3><hr><p>重点：鹦鹉学舌</p><p><strong>要点</strong></p><ul><li>decltype 几乎总是返回变量或表达式的类型，而不会进行任何修改。</li><li><strong>对于类型为 T 的左值表达式（不是名称），decltype 总是报告 T&amp;类型。</strong></li><li>C++14 支持decltype(auto)，它像 auto 一样从初始化表达式中推断类型，但使用的是 decltype 规则</li></ul><hr><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的类型而不作任何修改。对于类型为<code>T</code>的左值表达式，除非该表达式仅有一个名字，否则<code>decltype</code>总是得出类型<code>T&amp;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x);    <span class="comment">// 推导结果为 int</span></span><br><span class="line"><span class="keyword">decltype</span>((x));  <span class="comment">// 推导结果为 int&amp;</span></span><br></pre></td></tr></table></figure><p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到<strong>返回值类型尾置语法（trailing return type syntax）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(c[i])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。</p><p>但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;            <span class="comment">// auto 推导出类型为 Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;  <span class="comment">// decltype 推导出类型为 const Widget&amp;</span></span><br></pre></td></tr></table></figure><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考<strong>条款 25</strong>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-4：掌握查看类型推导结果的方法">条款 4：掌握查看类型推导结果的方法</h3><p><strong>1. IDE 编辑器</strong></p><p><strong>2. 编译器诊断信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 只声明 TD 而不定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;               <span class="comment">// TD 是 “类型显示类”（Type Displayer）的缩写</span></span><br><span class="line"></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;  <span class="comment">// 诱发包括 x 和 y 的类型的错误信息</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(y)&gt; yType;</span><br></pre></td></tr></table></figure><p><strong>3. 运行时输出</strong></p><p>针对某个对象调用<code>typeid</code>，可以得到一个<code>std::type_info</code>对象，其拥有一个成员函数<code>name</code>，该函数产生一个代表类型的 C-style 的字符串。</p><p>但遗憾的是，不同编译器对于<code>std::type_info::name</code>的实现各不相同，无法保证完全可靠。并且按照标准，<code>std::type_info::name</code>中处理类型的方式和向函数模板按值传参一样，因此类型的引用性以及<code>const</code>和<code>volatile</code>限定符也将被忽略。</p><p>原书中介绍了 Boost.TypeIndex 第三方库用于代替<code>typeid</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示 T 的类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T =          &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示 param 的类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param =          &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二章：auto">第二章：auto</h2><h3 id="条款-5：优先选用-auto，而非显式类型声明">条款 5：优先选用 auto，而非显式类型声明</h3><hr><p>速记：</p><p>auto好处：</p><ul><li>auto必须初始化</li><li>简化代码</li><li>std::function 方法通常体积比 auto 大，并且慢，还有可能导致内存不足的异常</li><li>在32位 Windows 系统上， unsigned 和 size_type 有同样的大小，但是在64位的 Windows 上， unsigned 是32bit的，而 size_type 是64bit的。</li><li>避免error</li></ul><p>问题代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="type">int</span>&gt;&amp; p : m)&#123;</span><br><span class="line">    ... <span class="comment">// 使用p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器的元素类型应该是：std::pair&lt;const std::sting, int&gt;</p><p>正确写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m)&#123;</span><br><span class="line">    ... <span class="comment">// 和以前一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>auto</code>变量要求必须初始化，基本上可以避免会导致兼容性和效率问题的类型不匹配现象，还可以简化重构流程，通常也比显式指定类型要少打一些字，但在使用时需要注意<strong>条款 2</strong> 和<strong>条款 6</strong> 中提到的问题。</p><p>使用<code>auto</code>和<code>std::function</code>都可以存储闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14 允许在 lambda 表达式的形参中使用 auto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> derefLess = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1, <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)</span><br><span class="line">                  &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;,</span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt;</span><br><span class="line">    derefUPLess = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1,</span><br><span class="line">                     <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)</span><br><span class="line">                   &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure><p>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同；而使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。再有，编译器的细节一般都会限制内联，并会产生间接函数调用。</p><p>综上所述，<code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。</p><p>考虑以下代码的隐患：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : m) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::unordered_map</code>的键值部分是 const 的，所以哈希表中的<code>std::pair</code>类型应为<code>std::pair&lt;const std::string, int&gt;</code>而非<code>std::pair&lt;std::string, int&gt;</code>，类型的不匹配会导致额外的临时对象被复制出来，降低了运行效率。</p><p>使用<code>auto</code>就可以轻松避免这种问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法">条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法</h3><hr><p>auto坏处：</p><p>当auto推导的类型不符合要求时，使用显式类型初始化语法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; <span class="title function_">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span>;</span><br><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="type">bool</span> highPriority = features(w)[<span class="number">5</span>]; <span class="comment">// 假设容器的第5位（bit）表示 Widget 是否具有高优先级</span></span><br><span class="line">processWidget(w, highPriority); <span class="comment">// 能正常工作，根据优先级进行处理</span></span><br><span class="line"><span class="keyword">auto</span> highPriority = features(w)[<span class="number">5</span>];<span class="comment">// 返回类型为 std::vector&lt;bool&gt;::referenceprocessWidget(w, highPriority); // 未定义的行为!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>std::vector::operator[] 通常返回元素的引用，bool元素类型除外</strong></p><ul><li>std::vector&lt; bool&gt; 被指定每个 bool 值占一个位</li><li>std::vector&lt; T&gt; 的 operator[] 应该返回一个 T&amp;，但 C++ 禁止对位的引用</li><li>std::vector&lt; bool&gt;::reference用于使其用起来像是bool&amp;，可以进行赋值、比较、条件等</li><li>为了让上述的设计能够正常工作，std::vector<bool>::reference 进行了一种隐式的转换，将其转换为 bool 类型</li><li>std::vector&lt; bool&gt;::reference 的一种可能实现方式是：包含一个指针（指向一个包含结果值的一个数据结构），和偏移量（结果值在数据结构中的位置）</li></ul><p>总结：auto推导没错，只需要显示声明or类型转化</p><hr><p>“隐形” 的代理类型可以导致<code>auto</code>根据初始化表达式推导出 “错误的” 类型，应该防止写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> someVar = <span class="string">&quot; 隐形 &quot;</span> 代理类型表达式;</span><br></pre></td></tr></table></figure><p>一个隐形代理类的典型例子是<code>std::vector&lt;bool&gt;</code>，它经过了特化，与一般的<code>std::vector</code>的行为不同，和<code>std::bitset</code>的行为相似，使用一种压缩形式表示其持有的<code>bool</code>元素，每个<code>bool</code>元素用一个比特来表示。因此，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>并不会直接返回一个<code>bool&amp;</code>，而是会返回一个具有类似行为的<code>std::vector&lt;bool&gt;::reference</code>类型的对象，并可以隐式转换为<code>bool</code>类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> highPriority1 = <span class="built_in">features</span>(w)[<span class="number">5</span>];    <span class="comment">// 得到正确的 bool 变量</span></span><br><span class="line"><span class="keyword">auto</span> highPriority2 = <span class="built_in">features</span>(w)[<span class="number">5</span>];    <span class="comment">// 错误地得到了 std::vector&lt;bool&gt;::reference 对象</span></span><br></pre></td></tr></table></figure><p>除了<code>std::vector&lt;bool&gt;</code>以外，标准库中的智能指针和另外一些 C++ 库中的类也使用了代理类的设计模式，例如为了提高数值计算代码效率的<strong>表达式模板</strong>技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix sum = m1 + m2 + m3 + m4; <span class="comment">// 通过使 operator+ 返回结果的代理来提高效率</span></span><br></pre></td></tr></table></figure><blockquote><p>在实际编写代码时，记得通过查看文档或头文件中的函数原型来确认手头上的类是否为代理类。</p></blockquote><p>解决代理类问题的做法是：使用带显式类型的初始值设定项来强制<code>auto</code>推导出你想要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>这种用法并不仅限于会产生代理类型的初始值设定项，它同样可以应用于你想要强调创建一个类型不同于初始化表达式类型的场合，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">calcEpsilon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ep1 = <span class="built_in">calcEpsilon</span>();                      <span class="comment">// 进行从 double 到 float 的隐式类型转换</span></span><br><span class="line"><span class="keyword">auto</span> ep2 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">calcEpsilon</span>());   <span class="comment">// 强调了类型转换的存在</span></span><br></pre></td></tr></table></figure><h2 id="第三章：转向现代-C">第三章：转向现代 C++</h2><h3 id="条款-7：在创建对象时注意区分-和">条款 7：在创建对象时注意区分 () 和 {}</h3><hr><p>重点：：</p><p>内置类型</p><p>可以使用（）、= 或 { } 来指定初始化值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">x</span><span class="params">(<span class="number">0</span>)</span>; </span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> z&#123; <span class="number">0</span> &#125;; </span><br><span class="line"><span class="type">int</span> z = &#123; <span class="number">0</span> &#125;; <span class="comment">// 等价于 int z&#123; 0 &#125;; </span></span><br></pre></td></tr></table></figure><p>用户定义类型</p><ul><li>对非静态数据成员进行初始化<ul><li>可以使用{ }, = 对非静态数据成员进行初始化，但( ) 不行</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    private:</span><br><span class="line">    <span class="type">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// 正确, x的默认值为0</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">// 同样正确</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">z</span><span class="params">(<span class="number">0</span>)</span>; <span class="comment">// 错误!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>不可复制的对象（例如，std::atomics）</p><ul><li>不可复制的对象（例如，std::atomics）可以使用{ }或（）进行初始化，但不能使用 =</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; ai1&#123; <span class="number">0</span> &#125;; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">ai2</span><span class="params">(<span class="number">0</span>)</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">// 错误!</span></span><br></pre></td></tr></table></figure></li><li><p>{ }初始化禁止内置类型之间的隐式窄化转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line">…</span><br><span class="line"><span class="type">int</span> sum1&#123; x + y + z &#125;; <span class="comment">// 错误! 双精度数的和可能无法表示为整数int sum2(x + y + z); // 可以 (表达式的值被截断为整数)</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z; <span class="comment">// 同上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>{ } 初始化不受 C++中令人烦恼的解析问题（任何可以被解析为声明的东西都必须被解释为声明）的影响</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget <span class="title function_">w1</span><span class="params">(<span class="number">10</span>)</span>; <span class="comment">// 调用 Widget 类的构造函数，并传入参数10</span></span><br><span class="line">Widget <span class="title function_">w2</span><span class="params">()</span>; <span class="comment">// 令人烦恼的解析！声明了名为 w2 的函数，它返回一个 Widget！</span></span><br><span class="line">Widget w3&#123;&#125;; <span class="comment">// 无参数，调用构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p>构造函数声明类型为std::initializer_list的参数</p></blockquote><p><strong>如果存在构造函数声明了类型为 std::initializer_list 的参数，那么使用{ }初始化语法的调用强烈倾向于采用接受 std::initializer_list 的重载。非常强烈！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// 和以前一样</span></span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// 和以前一样</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">long</span> <span class="type">double</span>&gt; il); <span class="comment">// 新加入</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget <span class="title function_">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span>; <span class="comment">// 调用第一个ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// 调用initializer_list ctor(10和true转换为long double)</span></span><br><span class="line">Widget <span class="title function_">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span>; <span class="comment">// 调用第二个ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// 调用initializer_list ctor(10和5.0转换为long double)</span></span><br></pre></td></tr></table></figure><p>报错情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// 和以前一样</span></span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// 和以前一样</span></span><br><span class="line">    <span class="comment">//元素类型现在为bool</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">bool</span>&gt; il); </span><br><span class="line">&#125;; </span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// 错误! 需要窄化转换</span></span><br></pre></td></tr></table></figure><p>Widget想转换，但是{}不能支持窄转换~</p><hr><p>为了着手解除众多的初始化语法带来的困惑，也为了解决这些语法不能覆盖所有初始化场景的问题，C++11 引入了统一初始化，以<strong>大括号初始化（braced initialize）</strong> 的形式存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种写法等价</span></span><br><span class="line"><span class="type">int</span> x&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> y = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号可以用于指定容器的初始内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号和等号可以用于为非静态成员指定默认初始化值，而小括号不行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// 可行</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">// 可行</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;   <span class="comment">// 不可行！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不可复制的对象可以采用大括号和小括号进行初始化，而不能使用等号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123; <span class="number">0</span> &#125;;  <span class="comment">// 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>;    <span class="comment">// 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>;   <span class="comment">// 不可行！</span></span><br></pre></td></tr></table></figure><p>大括号初始化禁止内建类型之间进行<strong>隐式窄化类型转换（narrowing conversion）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum1&#123; x + y + z &#125;;  <span class="comment">// 错误！double 之和可能无法用 int 表达</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(x + y + z)</span></span>;    <span class="comment">// 正确，表达式的值被截断为 int</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z;   <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>大括号初始化可以避免<strong>最令人烦恼的解析语法（most vexing parse）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 调用 Widget 构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;    <span class="comment">// 声明了一个名为 w2，返回值为 Widget 对象的函数</span></span><br><span class="line">Widget w3&#123;&#125;;    <span class="comment">// 调用没有形参的 Widget 构造函数</span></span><br></pre></td></tr></table></figure><p>大括号初始化也有一些缺点，其中一个是<strong>条款 2</strong> 中提到的 auto 推导问题，另一个则产生于对带有<code>std::initializer_list</code>类型形参的重载版本的强烈偏向性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">int</span>&gt; f);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;        <span class="comment">// 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123; <span class="number">10</span>, <span class="literal">true</span> &#125;;      <span class="comment">// 调用带有 std::initializer_list 形参的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;         <span class="comment">// 调用第二个构造函数</span></span><br><span class="line">Widget w4&#123; <span class="number">10</span>, <span class="number">5.0</span> &#125;;       <span class="comment">// 错误！禁止窄化类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>;              <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Widget w6&#123; w4 &#125;;            <span class="comment">// 将 w4 强制转换为 int 后，调用带有 std::initializer_list 形参的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(std::move(w4))</span></span>;   <span class="comment">// 调用移动构造函数</span></span><br><span class="line">Widget w8&#123; std::<span class="built_in">move</span>(w4) &#125;; <span class="comment">// 情况和 w6 相同</span></span><br></pre></td></tr></table></figure><p>只有在找不到任何办法把大括号初始值设定项中的实参转换为<code>std::initializer_list</code>模板中的类型时，编译器才会退而检查普通的重载决议。</p><p>值得注意的是，一对空大括号代表的意义是 “没有实参”，而非 “空的<code>std::initializer_list</code>”，后者可以用套娃的括号来表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;      <span class="comment">// 调用默认构造函数</span></span><br><span class="line">Widget w2&#123;&#125;;    <span class="comment">// 仍然调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>;    <span class="comment">// 变成了函数声明语句</span></span><br><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">// 调用带有 std::initializer_list 形参的构造函数</span></span><br><span class="line">                <span class="comment">// 并传入空的 std::initializer_list</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>在使用模板进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。举例来说，如果你想以任意数量的实参来创建一个任意类型的对象，那么，一个可变参数模板将会是不错的选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用 params 创建 T 类型的局部对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>然而此时，在模板内部创建局部对象时，对小括号和大括号的选择将会影响实际创建出的内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个包含 10 个元素的 std::vector</span></span><br><span class="line"><span class="function">T <span class="title">localObject</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个包含 2 个元素的 std::vector</span></span><br><span class="line">T localObject&#123; std::forward&lt;Ts&gt;(params)... &#125;;</span><br></pre></td></tr></table></figure><p>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</p><h3 id="条款-8：优先选用-nullptr，而非-0-或-NULL">条款 8：优先选用 nullptr，而非 0 或 NULL</h3><hr><p>重点：</p><p>在C++11中，nullptr是一个更好的选择，虽然它也不是指针类型，但好在它也不是整数类型。<br>nullptr的类型为std::nullptr_t，它可以隐式地转换为所有内置的指针类型。</p><hr><p><code>nullptr</code>的实际类型是<code>std::nullptr_t</code>，该类型可以隐式转换到所有的裸指针类型，因此<code>nullptr</code>可以扮演所有类型的指针。与<code>0</code>和<code>NULL</code>不同，<code>nullptr</code>不具备整数类型，因此不具有多义性。</p><p><code>0</code>和<code>NULL</code>导致的重载问题提醒我们应当尽量避免在整型和指针类型之间进行重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;  <span class="comment">// f 的三个重载版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);           <span class="comment">// 调用 f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);        <span class="comment">// 可能无法通过编译，但一般会调用 f(int)，绝不会调用 f(void*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);     <span class="comment">// 调用 f(void*)</span></span><br></pre></td></tr></table></figure><p><code>nullptr</code>在有模板的前提下表现最亮眼：模板类型推导会将<code>0</code>和<code>NULL</code>推导成 “错误” 类型（即它们的真实类型，而非空指针这个含义），而使用<code>nullptr</code>的话，模板就不会带来特殊的麻烦。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(std::unique_ptr&lt;Widget&gt; upw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> MuxType, <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">lockAndCall</span><span class="params">(FuncType func, MuxType&amp; mutex, PtrType ptr)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">std::mutex f1m, f2m, f3m;</span><br><span class="line"><span class="keyword">auto</span> result1 = <span class="built_in">lockAndCall</span>(f1, f1m, <span class="number">0</span>);         <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">lockAndCall</span>(f2, f2m, <span class="literal">NULL</span>);      <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result3 = <span class="built_in">lockAndCall</span>(f3, f3m, <span class="literal">nullptr</span>);   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="条款-9：优先选用别名声明，而非-typedef">条款 9：优先选用别名声明，而非 typedef</h3><hr><p>重点：</p><p><strong>别名声明可以模板化(别名模板)，而typedef不能。</strong></p><p>要点：</p><ul><li>typedef不支持模板化，但别名声明支持。</li><li>别名模板避免使用“::type”后缀，以及在模板中的“typename”前缀（typedef所需要的）。</li><li>C++ 14为所有的C++ 11类型特征转换提供了别名模板。</li></ul><hr><p>很多人发现别名声明在处理涉及函数指针的类型时，比<code>typedef</code>更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> std::string&amp;)</span></span></span><br></pre></td></tr></table></figure><p>代替为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FP = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> std::string&amp;);</span><br></pre></td></tr></table></figure><p>但别名声明的压倒性优势在于<strong>别名模板（alias template）</strong>，它给予了 C++11 程序员一种直截了当的表达机制，用以表达 C++98 程序员不得不用嵌套在模板化的<code>struct</code>里面的<code>typedef</code>才能硬搞出来的东西。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用别名模板，就可以让整个写法更简洁，并且可以摆脱类型前的<code>typename</code>限定符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyAllocList&lt;T&gt; list;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++11 中，标准库的<code>&lt;type_traits&gt;</code>给出了一整套用于进行值类别转换的模板，它们是使用<code>typedef</code>实现的，对于给定待变换类型 T，其结果类型需要通过<code>std::transformation&lt;T&gt;::type</code>的方式获得。而在 C++14 中，所有的值类别转换都加上了对应的别名模板，通过<code>std::transformation_t&lt;T&gt;</code>的方式使用，这显然比<code>typedef</code>实现的版本更加好用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type          <span class="comment">// C++11: const T -&gt; T</span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;              <span class="comment">// C++14 中的等价物</span></span><br><span class="line"></span><br><span class="line">std::remove_reference&lt;T&gt;::type      <span class="comment">// C++11: T&amp;/T&amp;&amp; -&gt; T</span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt;          <span class="comment">// C++14 中的等价物</span></span><br><span class="line"></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type  <span class="comment">// C++11: T -&gt; T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt;      <span class="comment">// C++14 中的等价物</span></span><br></pre></td></tr></table></figure><h3 id="条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型">条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><hr><p>重点：</p><p>C++11引入的限定作用域枚举是强类型枚举，使得枚举类型更加类型安全。</p><p>要点</p><ul><li>C++98 风格的枚举现在被称为不限作用域的枚举。</li><li>限定作用域的枚举值仅在枚举内部可见。它们只能通过强制类型转换转换为其他类型。</li><li>限定作用域的枚举和不限定作用域的枚举都支持指定基础类型。限定作用的枚举的默认基础类型是 int。不限定作用域的枚举没有默认基础类型。</li><li>限定作用域是枚举总是可以进行前置声明。不限定作用域的枚举只有在其声明指定了基础类型时才能进行前置声明。</li></ul><hr><p>C++98 中的枚举类型被称为不限作用域的枚举类型，与之相对的即是 C++11 中引入的限定作用域的枚举类型，即枚举类<code>enum class</code>，它的优点很明显：不会产生名称污染。</p><p>除此以外，枚举类还是强类型的，而不限范围的枚举类型中的枚举量可以隐式转换到整型（并由此更进一步转换到浮点型）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::<span class="type">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(std::<span class="type">size_t</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">Color c = red;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要用<code>enum class</code>代替<code>enum</code>，对其施以强制类型转换即可，但是无法确保转换的合法性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::<span class="type">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(std::<span class="type">size_t</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">Color c = Color::red;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(c));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不限范围的枚举类型，编译器为了节约使用内存，通常会为枚举类型选用足够表示枚举量取值的最小底层类型。即使在某些情况下，编译器会采取空间换时间的策略，导致放弃选择尺寸最小的类型，然而它仍然需要保留优化空间的能力。因此，在 C++98 中，<code>enum</code>只允许在声明处定义，没有提供对前置声明的支持。</p><p>而在 C++11 中，无论是<code>enum class</code>还是<code>enum</code>都可以进行前置声明，<code>enum class</code>的默认底层类型是<code>int</code>，而<code>enum</code>不具备默认底层类型，只有在指定了的前提下才可以进行前置声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>;                  <span class="comment">// 底层类型是 int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> : std::<span class="type">uint32_t</span>;  <span class="comment">// 底层类型是 std::uint32_t</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> : std::<span class="type">uint8_t</span>;          <span class="comment">// 底层类型是 std::uint8_t</span></span><br></pre></td></tr></table></figure><p>底层类型指定同样也可以在定义时进行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> : std::<span class="type">uint32_t</span> &#123;</span><br><span class="line">    good = <span class="number">0</span>,</span><br><span class="line">    failed = <span class="number">1</span>,</span><br><span class="line">    incomplete = <span class="number">100</span>,</span><br><span class="line">    corrupt = <span class="number">200</span>,</span><br><span class="line">    audited = <span class="number">500</span>,</span><br><span class="line">    indetermine = <span class="number">0xFFFFFFFF</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不限范围的枚举类型在你需要更便捷地为数字和名称建立联系时，还是比较好用的，例如在访问元组的元素时，你可以使用枚举量而非直接使用难懂的数字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = std::tuple&lt;std::string, std::string, std::<span class="type">size_t</span>&gt;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line"></span><br><span class="line">UserInfo uInfo;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo);</span><br></pre></td></tr></table></figure><p>而使用<code>enum class</code>就要啰嗦得多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><p>如果你实在无法忍受名称污染，执意打算使用<code>enum class</code>，那么可以考虑使用以下辅助类来简化书写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;    <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><h3 id="条款-11：优先选用删除函数，而非-private-未定义函数">条款 11：优先选用删除函数，而非 private 未定义函数</h3><hr><p>重点：</p><p>已删除函数的一个重要优势是任何函数都可以被删除</p><p><strong>要点</strong></p><ul><li>优先选择已删除函数而不是私有未定义的函数。</li><li>任何函数都可以被删除，包括非成员函数和模板实例化。</li></ul><hr><p>删除函数和将函数声明为 private 看起来只是风格不同的选择，但其实有更多值得思考的微妙之处，例如：被删除的函数无法通过任何方法调用，对于成员和友元函数中的代码也是如此。</p><p>习惯上，删除函数会被声明为 public，而非 private，这样做的理由是：C++ 会先校验可访问性，后校验删除状态，当我们尝试调用某个 private 删除函数时，编译器可能只会提醒函数无法访问，而非更应关心的函数是否被删除。</p><p>以下是 C++11 中<code>std::basic_ios</code>阻止被复制的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>任何函数都能被删除，藉此我们可以过滤掉不想要的函数重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;       <span class="comment">// 原始版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">// 拒绝 char 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">// 拒绝 bool 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;  <span class="comment">// 拒绝 double 和 float 类型</span></span><br></pre></td></tr></table></figure><p><code>float</code>类型的参数会优先转换到<code>double</code>类型，因此传入<code>float</code>时会调用<code>double</code>类型的重载版本，但由于这个重载版本被删除了，所以编译会被阻止。</p><p>删除函数还可以阻止那些不应该进行的模板具现。举例来说，假设你需要一个和内建指针协作的模板，却不想要它对<code>void*</code>和<code>char*</code>指针进行处理，那么可以写出以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删去其它版本，如 volatile void* 和 volatile char*</span></span><br><span class="line"><span class="comment">// 与其它标准字符类型，如 std::wchar_t, std::char16_t 和 std::char32_t</span></span><br></pre></td></tr></table></figure><p>成员函数模板可以在类外被删除：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Widget::<span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="条款-12：为意在改写的函数添加-override-声明">条款 12：为意在改写的函数添加 override 声明</h3><hr><blockquote><p><strong>引用限定符</strong></p></blockquote><p>引用限定符可以将成员函数的使用限制为只左值或只右值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    …</span><br><span class="line">    <span class="type">void</span> <span class="title function_">doWork</span><span class="params">()</span> &amp;; <span class="comment">// 只有当*this是左值时，这个版本的doWork才适用</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">doWork</span><span class="params">()</span> &amp;&amp; ; <span class="comment">// 只有当*this是右值时，这个版本的doWork才适用</span></span><br><span class="line">&#125;; </span><br><span class="line">…</span><br><span class="line">Widget <span class="title function_">makeWidget</span><span class="params">()</span>; <span class="comment">// 工厂函数(返回右值)</span></span><br><span class="line">Widget w; <span class="comment">// 普通对象(一个左值)</span></span><br><span class="line">…</span><br><span class="line">w.doWork(); <span class="comment">// 调用左值版本的 Widget::doWork (i.e., Widget::doWork &amp;)</span></span><br><span class="line">makeWidget().doWork(); <span class="comment">// 调用右值版本的 Widget::doWork (i.e., Widget::doWork &amp;&amp;)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>case</strong></p></blockquote><p>为什么这些派生类的函数不重写基类的同名函数?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf1</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf2</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf3</span><span class="params">()</span> &amp;;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mf4</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf1</span><span class="params">()</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf3</span><span class="params">()</span> &amp;&amp; ;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mf4</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>mf1在Base中声明为const，但在Derived中没有。</li><li>mf2在Base中接受一个int类型参数，但在Derived中接受一个unsigned int类型参数。</li><li>mf3在Base中是左值限定的，但在Derived中是右值限定的。</li><li>在Base中没有将f4声明为virtual。</li></ul><p>C++11中，可以将成员函数声明为override，<strong>编译器会抱怨所有与重写相关的问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf1</span><span class="params">()</span> override;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> override;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf3</span><span class="params">()</span> &amp;&amp; override;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf4</span><span class="params">()</span> <span class="type">const</span> override;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要点</p><ul><li>将重写函数声明为override。</li><li>成员函数引用限定符使得可以区别对待左值和右值对象(*this)。</li></ul><hr><p>如果要使虚函数重写发生，有一系列要求需要满足：</p><ol><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的<strong>函数名称</strong>必须完全相同（析构函数除外）。</li><li>基类和派生类中的<strong>函数形参类型</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数常量性</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数返回值</strong>和<strong>异常规格</strong>必须兼容。</li><li>基类和派生类的<strong>函数引用限定符</strong>必须完全相同。</li></ol><p>由于对声明派生类中的重写，保证正确性很重要，而出错又很容易，C++11 提供了<code>override</code>声明来显式地标明派生类中的函数是为了重写基类版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 加个 &quot;virtual&quot; 没问题，但也没必要</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样做的好处不仅在于让编译器提醒你想要重写的函数实际上并未重写，还可以让你在打算更改基类中虚函数的签名时，衡量一下其所造成的影响。</p><blockquote><p><code>override</code>和<code>final</code>是 C++11 中加入的<strong>语境关键字（contextual keyword）</strong>，它们的特点是仅会在特定语境下才发挥被保留的意义，因此如果你有一些遗留代码，其中已经用过<code>override</code>和<code>final</code>作为名称的话，并不需要为它们改名。</p></blockquote><p><strong>函数引用限定符（reference qualifier）：</strong> 限制成员函数仅用于左值对象或右值对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;    <span class="comment">// 仅在 *this 是左值时调用</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;   <span class="comment">// 仅在 *this 是右值时调用</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">doWork</span>();            <span class="comment">// 以左值调用 Widget::doWork &amp;</span></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>(); <span class="comment">// 以右值调用 Widget::doWork &amp;&amp;</span></span><br></pre></td></tr></table></figure><p>带引用限定符的成员函数并不常见，但有时也是需要的。举例来说，假设我们的<code>Widget</code>类中有个<code>std::vector</code>类型的数据成员，我们提供一个函数让用户能对这个数据成员直接访问，但对于左值对象和右值对象有不同的行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp;              <span class="comment">// 对于左值 Widget 类型，返回左值</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp;              <span class="comment">// 对于右值 Widget 类型，返回右值</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>();              <span class="comment">// 调用 Widget::data 的左值重载版本</span></span><br><span class="line">                                    <span class="comment">// vals1 采用拷贝构造完成初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();   <span class="comment">// 调用 Widget::data 的右值重载版本</span></span><br><span class="line">                                    <span class="comment">// vals2 采用移动构造完成初始化</span></span><br></pre></td></tr></table></figure><h3 id="条款-13：优先选用-const-iterator，而非-iterator">条款 13：优先选用 const_iterator，而非 iterator</h3><hr><p>要点</p><ul><li>优先选用const_iterator,而非iterator。</li><li>在最泛型的代码中，优先使用begin、end、rbegin等的非成员版本，而不是对应的成员函数。</li></ul><hr><p><code>const_iterator</code>是 STL 中提供的与指向 const 的指针含义相同之物，它们指向不可被修改的值。任何时候只要你需要一个迭代器而其所指向的内容没有修改的必要，那就应该使用 const_iterator。</p><p>但在 C++98 中，<code>const_iterator</code>得到的支持不够全面，想要获取它们就很不容易，而获取到了以后使用它们的方法也很受限。例如在 C++98 中，我们会被迫写出以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::iterator IterT;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::const_iterator ConstIterT;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ConstIterT ci = </span><br><span class="line">    std::<span class="built_in">find</span>(<span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">begin</span>()),</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">end</span>()),</span><br><span class="line">              <span class="number">1983</span>);                            <span class="comment">// const_iterator 作为参数，返回 const_iterator</span></span><br><span class="line"></span><br><span class="line">values.<span class="built_in">insert</span>(<span class="built_in">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>);    <span class="comment">// C++98 中 insert 只能接受 iterator</span></span><br><span class="line">                                                <span class="comment">// 从 const_iterator 到 iterator 不存在可移植的类型转换</span></span><br><span class="line">                                                <span class="comment">// 可能无法通过编译</span></span><br></pre></td></tr></table></figure><p>而在 C++11 中，这些现象得到了彻底的改变，获取和使用<code>const_iterator</code>都变得容易了。要把原始的、使用<code>iterator</code>的 C++98 代码修改成使用<code>const_iterator</code>的 C++11 代码也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(values.<span class="built_in">cbegin</span>(), values.<span class="built_in">cend</span>(), <span class="number">1983</span>);</span><br><span class="line"></span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure><p>C++11 对于<code>const_iterator</code>支持的唯一缺陷是只为<code>begin</code>和<code>end</code>提供了对应的非成员函数版本，而没有为<code>cbegin</code>、<code>cend</code>、<code>rbegin</code>、<code>cend</code>、<code>crbegin</code>和<code>crend</code>这些返回<code>const_iterator</code>的函数提供对应的非成员函数版本，这个问题在 C++14 中得到了解决。想要自己实现它们也很简单，如下就是非成员函数版本的<code>cbegin</code>的一个实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span> -&gt; <span class="title">decltype</span><span class="params">(std::begin(container))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该模板在传入一个内建数组时也管用，此时<code>container</code>会成为一个 const 数组的引用。</p><blockquote><p>C++11 的非成员函数版本的<code>begin</code>为内建数组提供了一个特化版本，它返回一个指向数组首元素的指针。由于 const 数组的元素都为 const，所以若给<code>begin</code>传入一个 const 数组，则返回的指针是个指向 const 的指针，即数组意义下的 const_iterator。</p></blockquote><p>由于内建数组和第三方库的存在，最通用化的代码往往不会假定成员函数的存在，而是更多地采用非成员函数版本，例如以下<code>findAndInsert</code>模板的通用形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container, <span class="type">const</span> V&amp; targetVal, <span class="type">const</span> V&amp; insertVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cbegin;</span><br><span class="line">    <span class="keyword">using</span> std::cend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container), <span class="built_in">cend</span>(container), targetVal);</span><br><span class="line"></span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明">条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明</h3><hr><p>noexcept含义：一个函数 f，它向调用者承诺永远不会抛出异常。noexcept使得编译器可以根据这个声明进行更深入的优化，避免不必要栈展开操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// C++98 风格</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// C++11 风格</span></span><br></pre></td></tr></table></figure><p>如果f 违反了异常规范。<br>C++98 风格：调用栈会展开，退回到 f 的调用者，进行一些操作后，程序执行就会终止<br>C++11 风格：程序终止之前，栈只是可能会被展开（就算异常被抛出，大不了终止程序，无需处理异常）</p><p>潜在问题：</p><p>假设你想通过移动来优化性能，但与拷贝不同，移动过程中如果发生异常，将很难回滚到之前的状态。这是一个严重的问题，因为遗留代码的行为可能依赖于push_back的强异常安全保证。因此移动操作必须做出noexcept保证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">…</span><br><span class="line">Widget w;</span><br><span class="line">… </span><br><span class="line">vw.<span class="built_in">push_back</span>(w); </span><br><span class="line">…</span><br></pre></td></tr></table></figure><hr><p>在 C++11 中，C++98 风格的异常规范已经被弃用，而转为为不会抛出异常的函数提供<code>noexcept</code>声明，函数是否要加上这个声明，事关接口声明。</p><p>调用方可以查询函数的<code>noexcept</code>状态，而查询结果可能会影响调用代码的异常安全性和运行效率。这么一来，函数是否带有<code>noexcept</code>声明就是和成员函数是否带有 const 声明同等重要的信息。当你明明知道一个函数不会抛出异常却未给它加上<code>noexcept</code>声明的话，就属于接口规格设计缺陷。</p><p>相当于不带<code>noexcept</code>声明的函数，带有<code>noexcept</code>声明的函数有更多机会得到优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 最优化</span></span><br><span class="line"></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">// 优化不足</span></span><br><span class="line"></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;           <span class="comment">// 优化不足</span></span><br></pre></td></tr></table></figure><p>在带有<code>noexcept</code>声明的函数中，优化器不需要在异常传出函数的前提下，将运行时栈保持在可展开状态；也不需要在异常逸出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以<code>throw()</code>异常规格声明的函数就享受不到这样的优化灵活性，和那些没有加上异常规格的函数一样。</p><p><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略，但这必须保证在使用移动操作代替复制操作后，函数依旧具备强异常安全性。为了得知移动操作会不会产生异常，就需要校验这个操作是否带有<code>noexcept</code>声明。</p><p><code>swap</code>函数是许多 STL 算法实现的核心组件，它的广泛使用昭示着针对其实施<code>noexcept</code>声明带来的收益是可观的。标准库中的<code>swap</code>是否带有<code>noexcept</code>声明，取决于用户定义的<code>swap</code>自身。例如，标准库为数组和<code>std::pair</code>准备的<code>swap</code>函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T (&amp;a)[N],</span></span></span><br><span class="line"><span class="params"><span class="function">          T (&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些函数带有条件式<code>noexcept</code>声明，它们到底是否具备<code>noexcept</code>属性，取决于它的<code>noexcept</code>分句中的表达式是否结果为<code>noexcept</code>。在此处，数组和<code>std::pair</code>的<code>swap</code>具备<code>noexcept</code>属性的前提是，其每一个元素的<code>swap</code>都具备<code>noexcept</code>属性。</p><p>对于某些函数来说，具备<code>noexcept</code>属性是如此之重要，所以它们默认就是如此。在 C++11 中，内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性。析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code>，即可能抛出异常。</p><blockquote><p>不具备<code>noexcept</code>属性的析构函数很少见，标准库里一个都没有，而如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</p></blockquote><p>大多数函数都是<strong>异常中立（exception-neutral）</strong> 的，不具备<code>noexcept</code>属性。此类函数自身并不抛出异常，但它们调用的函数可能会抛出异常，这些异常会经由异常中立函数传至调用栈的更深一层。</p><p>C++ 允许带有<code>noexcept</code>声明的函数依赖于缺乏<code>noexcept</code>保证的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，有些库的接口设计者会把函数区分为带有<strong>宽松规约（wide constract）</strong> 和带有<strong>狭隘规约（narrow constract）</strong> 的不同种类。带有宽松规约的函数是没有前置条件的，要调用这样的函数也无须关心程序状态；而对于带有狭隘规约的函数，如果前置条件被违反，则结果将成为未定义的。一般而言，我们只会把<code>noexcept</code>声明保留给那些带有宽松规约的函数。</p><h3 id="条款-15：只要有可能使用-constexpr，就使用它">条款 15：只要有可能使用 constexpr，就使用它</h3><hr><p>constexpr本质上是const的增强形式。</p><p>从概念上讲，constexpr 表示不仅是常量，而且在编译时就已知的值。</p><p><strong>当用编译时常量调用constexpr函数时，会产生编译时常量。如果用运行时才知道的值来调用，则会产生运行时值。这意味着不需要两个函数来执行相同的操作，一个用于编译时常量，一个用于所有其他值。</strong></p><p>要点</p><ul><li>constexpr 对象是常量，并且使用在编译时已知的值进行初始化。</li><li>当使用编译时已知值作为参数调用时，constexpr 函数可以在编译时产生结果。</li><li>constexpr 对象和函数可能比非 constexpr 对象和函数在更广泛的上下文中使用。</li><li>constexpr 是对象或函数接口的一部分。</li></ul><hr><p><strong><code>constexpr</code>对象：</strong> 具备 const 属性，并由编译期已知的值完成初始化。</p><p>在编译阶段就已知的值拥有许多特权，它们可能被放置在只读内存里（对于嵌入式开发尤为重要）；在编译阶段就已知的常量整型值可以用在 C++ 要求整型常量表达式的语境中，包括数组的尺寸规格、整型模板实参、枚举量的值、对齐规格等，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;                             <span class="comment">// 非 constexpr 变量</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> arraySize = sz;          <span class="comment">// 正确，arraySize 是 sz 的一个 const 副本</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize&gt; data;    <span class="comment">// 错误！arraySize 的值非编译期可知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">// 错误！sz 的值在编译期未知</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, sz&gt; data1;          <span class="comment">// 错误！问题同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">// 正确，10 是编译期常量</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize2&gt; data2;  <span class="comment">// 正确，arraySize2 是编译期常量</span></span><br></pre></td></tr></table></figure><p><strong><code>constexpr</code>函数：</strong></p><ul><li><code>constexpr</code>函数可以用在要求编译期常量的语境中。在这种情况下，若传给一个<code>constexpr</code>函数的实参值是在编译期已知的，则结果也会在编译期计算出来；如果任何一个实参值在编译期未知，则代码将无法通过编译。</li><li><code>constexpr</code>函数也可以运用在非编译期常量的语境中，此时传入的值可以有一个或多个在编译期未知。它的运作方式和普通函数无异，同样在运行期完成结果的计算。</li><li>在 C++11 中，<code>constexpr</code>函数不得包含多于一个可执行语句，即一条<code>return</code>语句；而到了 C++14，就没有了这种限制。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span> </span>&#123;     <span class="comment">// C++11</span></span><br><span class="line">    <span class="keyword">return</span> (exp == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span> </span>&#123;     <span class="comment">// C++14</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp; ++i) result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numConds = <span class="number">5</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, pow(3, numConds)&gt; results;</span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数仅限于传入和返回<strong>字面类型（literal type）</strong>，这些类型能够持有编译期可以决议的值。在 C++11 中，除了<code>void</code>的所有内建类型都是字面类型；此外，我们也可以自定义字面类型，这需要将其构造函数和部分成员函数声明为<code>constexpr</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> :</span></span><br><span class="line"><span class="function">        x(xVal), y(yVal) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;  <span class="comment">// 在编译期执行 constexpr 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;  <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.<span class="built_in">xValue</span>() + p2.<span class="built_in">xValue</span>()) / <span class="number">2</span>,</span><br><span class="line">             (p1.<span class="built_in">yValue</span>() + p2.<span class="built_in">yValue</span>()) / <span class="number">2</span> &#125;; <span class="comment">// 调用 constexpr 成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);  <span class="comment">// 使用 constexpr 函数的返回值来初始化 constexpr 对象</span></span><br></pre></td></tr></table></figure><p>在 C++14 中，就连返回值类型为<code>void</code>的 setter 函数也可以声明为<code>constexpr</code>函数，这就使以下代码变为可能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    Point result;</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">setX</span>(-p.<span class="built_in">xValue</span>());</span><br><span class="line">    result.<span class="built_in">setY</span>(-p.<span class="built_in">yValue</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectionMid = <span class="built_in">reflection</span>(mid);</span><br></pre></td></tr></table></figure><p>需要注意的是，一旦你把一个对象或函数声明成了<code>constexpr</code>，而后来你又感觉对<code>constexpr</code>运用不当，然后进行了移除，那么这会导致非常多客户代码无法通过编译。因此，“只要有可能使用<code>constexpr</code>，就使用它” 这句话中的 “只要有可能” 的含义就是你是否有一个长期的承诺，将由<code>constexpr</code>带来的种种限制施加于相关的函数和对象上。</p><h3 id="条款-16：保证-const-成员函数的线程安全性">条款 16：保证 const 成员函数的线程安全性</h3><hr><p>要点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    using RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    RootsType <span class="title function_">roots</span><span class="params">()</span> <span class="type">const</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">g</span><span class="params">(m)</span>; <span class="comment">// 锁定mutex</span></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123; <span class="comment">// 如果缓存无效</span></span><br><span class="line">            … <span class="comment">// 计算/存储 rootVals</span></span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125; <span class="comment">// 解锁mutex</span></span><br><span class="line">private:</span><br><span class="line">    mutable <span class="built_in">std</span>::mutex m;</span><br><span class="line">    mutable <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    mutable RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点1</strong>：业务逻辑认为可改，加mutable关键字。mutable关键字用于允许在常量函数（如roots）中修改类的某些成员变量。</p><p><strong>重点2</strong>：由于std::mutex是一种仅可移动类型，将m添加到Polynomial，将导致Polynomial失去了被复制的能力。【与std::mutex一样，std::atomic也是仅可移动类型，因此Point中存在callCount意味着Point也是仅可移动的。】</p><hr><p>对于 const 成员函数，我们通常认为它代表的是读操作，而多个线程在没有同步的情况下执行读操作应该是安全的。因此，我们需要保证 const 成员函数的线程安全性，除非可以确信它们不会在并发语境中被使用。</p><p>考虑如下情形，我们将计算出的多项式的根存入缓存中，以避免代价高昂的重复计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;       <span class="comment">// 如果缓存无效</span></span><br><span class="line">            ...</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;   <span class="comment">// 则计算根，并将其存入 rootVals</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 mutable 成员变量的存在，可能有不同的多个线程通过<code>roots</code>成员函数在没有同步的情况下读写同一块内存，造成<strong>数据竞争（data race）</strong>，这会导致未定义行为的出现。</p><p>有两种方法可以解决这个问题，最简单的方法也是最常见的，引入一个 mutex 互斥量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;   <span class="comment">// 互斥量加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;       <span class="comment">// 如果缓存无效</span></span><br><span class="line">            ...</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;   <span class="comment">// 则计算根，并将其存入 rootVals</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;                                       <span class="comment">// 互斥量解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;                   <span class="comment">// 添加 mutable 的互斥量</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种方法是使用<code>std::atomic</code>类型的变量，这会比使用互斥量提供更好的性能，但更适用于对单个变量或内存区域的操作。以下情况更适合使用<code>std::atomic</code>来确保线程安全性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ++callCount;                                <span class="comment">// 带原子性的自增操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;   <span class="comment">// 存储调用次数</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无论是<code>std::mutex</code>还是<code>std::atomic</code>都是只移类型，无法进行复制，因此加入它们都会使类失去可复制性，但仍然可以移动。</p><h3 id="条款-17：理解特殊成员函数的生成机制">条款 17：理解特殊成员函数的生成机制</h3><hr><p><strong>要点</strong></p><ul><li>特殊成员函数是编译器可以自己生成的函数：默认构造函数、析构函数、拷贝操作和移动操作。</li><li>只有没有显式声明移动操作、拷贝操作和析构函数的类才会生成移动操作。</li><li>只有没有显式声明拷贝构造函数的类才会生成拷贝构造函数，如果声明了移动操作，就会删除拷贝构造函数。</li><li>只有没有显式声明拷贝赋值操作符的类才会生成拷贝赋值操作符，如果声明了移动操作符，就会删除它。不赞</li><li>成在显式声明析构函数的类中生成拷贝操作。</li><li>成员函数模板永远不会抑制特殊成员函数的生成。</li></ul><hr><p>在 C++11 中，支配特殊成员函数的机制如下（所有生成的默认特殊函数都是 inline 的，且具有 public 访问权限）：</p><ul><li><strong>默认构造函数：</strong> 与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。</li><li><strong>析构函数：</strong> 与 C++98 的机制基本相同，唯一的区别在于析构函数默认为 noexcept（参考<strong>条款 14</strong>）。仅当基类的析构函数为虚时，派生类的析构函数才为虚。</li><li><strong>拷贝构造函数：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝构造。仅当类中不包含用户声明的拷贝构造函数时才生成。如果该类声明了移动操作，则拷贝构造函数将被删除。在已经存在拷贝赋值运算符或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li><li><strong>拷贝赋值运算符：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝赋值。仅当类中不包含用户声明的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符将被删除。在已经存在拷贝构造函数或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li></ul><blockquote><p><strong>三者法则（Rule of Three）：</strong> 如果你声明了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，你就得同时声明所有这三个。<br>三者法则根植于这样的思想：如果有改写拷贝操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：<br>\1. 在一种拷贝操作中进行的任何资源管理，也极有可能在另一种拷贝操作中也需要进行。<br>\2. 该类的析构函数也会参与到该资源的管理中（通常是对资源进行释放）。<br>三者法则对移动操作也同样成立。</p></blockquote><ul><li><strong>移动构造函数和移动赋值运算符：</strong> 都<strong>按成员</strong>进行<strong>非静态</strong>数据成员的移动操作。仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成。声明一个移动构造函数会阻止编译器生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器生成移动构造函数。</li></ul><blockquote><p>声明拷贝操作（无论是拷贝构造还是拷贝赋值）的行为表明了对象的常规拷贝方式（按成员拷贝）对于该类并不适用，那么编译器就会认为按成员移动极有可能也不适用于移动操作。因此，一旦显式声明了拷贝操作，编译器就不再会为其生成移动操作，反之亦然。</p></blockquote><p>如果你有一些代码依赖于编译器自动生成的特殊函数，并且你确信这些函数会正确执行，那么可以用<code>=default</code>显式指定让它们生成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;              <span class="comment">// 使析构函数成为虚的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(Base&amp;&amp;) = <span class="keyword">default</span>;                 <span class="comment">// 提供移动操作的支持</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;            <span class="comment">// 提供拷贝操作的支持</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员函数模板在任何情况下都不会抑制特殊成员函数的生成，例如下面这个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Widget</span><span class="params">(<span class="type">const</span> T&amp; rhs)</span></span>;               <span class="comment">// 以任意类型构造 Widget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);    <span class="comment">// 以任意类型对 Widget 赋值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器会始终生成<code>Widget</code>的拷贝和移动操作，即使这些模板的具现化生成了拷贝构造函数和拷贝赋值运算符的函数签名。</p><h2 id="第四章：智能指针">第四章：智能指针</h2><p>以下理由使得裸指针不受欢迎：</p><ol><li>裸指针没有在声明中指出，其指向的内容是单个对象还是数组。</li><li>裸指针没有在声明中指出，是否该在其指向的对象使用完后进行析构。</li><li>无法得知怎样析构裸指针才是适当的，是使用<code>delete</code>运算符，还是有专门用于析构的函数。</li><li>在已知使用<code>delete</code>的情况下，难以确定该用<code>delete</code>还是<code>delete[]</code>。</li><li>很难保证对指针所指向对象的析构，在所有代码路径上只执行一次。</li><li>没有正规的方式来检测指针是否空悬（dangle）。</li></ol><p>因此，在大多数时候，应该优先选用智能指针。<code>std::auto_ptr</code>是从 C++98 中残留下来的弃用特性，应该被 C++11 中的 <code>std::unique_ptr</code>所替代。</p><h3 id="条款-18：使用-std-unique-ptr-管理具备专属所有权的资源">条款 18：使用 std::unique_ptr 管理具备专属所有权的资源</h3><hr><p>指针只能指向一个地方，并且指向的地方可以更改【通过移动操作】，对比auto_ptr.</p><p><strong>要点</strong>：</p><ul><li>默认情况下，std::unique_ptr与原始指针具有相同的大小，并且对于大多数操作（包括解引用），它们执行完全相同的指令。</li><li>std::unique_ptr 体现了独占所有权语义，总是拥有它所指向的对象</li><li>移动std::unique_ptr会将所有权从源指针转移到目标指针（源指针被设置为 null）</li><li>不允许拷贝std::unique_ptr，因此它是一种只移动类型</li><li>销毁时，非空std::unique_ptr会销毁其资源。默认通过对内部的原始指针应用delete来完成</li></ul><p>使用默认删除器（即delete）使用时，std::unique_ptr 对象与原始指针大小相同。</p><ul><li><strong>当使用自定义删除器时，函数指针类型的删除器通常会使 std::unique_ptr 的大小从一个字增长到两个字</strong></li><li><strong>对于函数对象类型的删除器，大小的变化取决于函数对象中存储的状态的数量</strong>。无状态的函数对象（例如，没有捕获的 lambda 表达式）没有而外的负担</li></ul><p>简单例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A *a = new A;</span></span><br><span class="line">    <span class="keyword">auto</span> fun = [](A *a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, <span class="title">decltype</span><span class="params">(fun)</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A, fun)</span></span>;<span class="comment">// 自定义删除器</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;A, void (*)(A *)&gt; p(new A, fun);</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>std::unique_ptr</code>是小巧、高速的、具备只移类型的智能指针，对于托管的指针实施专属所有权语义。它和裸指针所占大小相同，并且不允许被拷贝，在执行析构操作时，同时析构其所管理的资源。</p><p><code>std::unique_ptr</code>的一个常见用法是在继承体系中，作为工厂函数的返回值类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Investment</span>();  <span class="comment">// 必备的虚析构函数！</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> : <span class="keyword">public</span> Investment &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bond</span> : <span class="keyword">public</span> Investment &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealEstate</span> : <span class="keyword">public</span> Investment &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span>; <span class="comment">// 返回 std::unique_ptr</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">auto</span> pInvestment = <span class="built_in">makeInvestment</span>( arguments );</span><br><span class="line">    ...</span><br><span class="line">&#125;   <span class="comment">// *pInvestment 在此处析构</span></span><br></pre></td></tr></table></figure><p>默认地，资源析构采用<code>delete</code>运算符来完成，但也可以指定自定义删除器，并且删除器将会被视作<code>std::unique_ptr</code>类型的一部分。下面的例子中使用了 lambda 表达式作为自定义删除器，并在删除时写入一条日志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span>; <span class="comment">// 改进后的返回值类型</span></span><br></pre></td></tr></table></figure><p>在 C++14 中，由于有了函数返回值类型推导（参考<strong>条款 3</strong>），<code>makeInvestment</code>可以用更加简单的、封装性更好的方法实现，自定义删除器也可以放在函数内部，完整的代码演示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 现在自定义删除器位于函数内部</span></span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;</span><br><span class="line">        <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">        <span class="keyword">delete</span> pInvestment;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;    <span class="comment">// 待返回的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reset 来让 pInv 获取 new 产生的对象的所有权</span></span><br><span class="line">    <span class="comment">// 对每一次 new 的调用结果，都使用 std::forward 对实参进行完美转发（参考条款 25）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* 应创建一个 Stock 类型的对象 */</span> ) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* 应创建一个 Bond 类型的对象 */</span> ) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* 应创建一个 RealEstate 类型的对象 */</span> ) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用自定义删除器后，<code>std::unique_ptr</code>的大小可能不再和裸指针相同：有状态的删除器和采用函数指针的删除器会增加<code>std::unique_ptr</code>类型的对象尺寸大小。无状态的函数对象（例如无捕获的 lambda 表达式）不会浪费任何内存空间，而函数指针通常会使<code>std::unique_ptr</code>的大小增加一到两个字长（word），这意味着无捕获的 lambda 表达式往往是用作删除器的最佳选择。</p><p><code>std::unique_ptr</code>提供了两种形式，一种是单个对象（<code>std::unique_ptr&lt;T&gt;</code>），另一种是数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。为了避免二义性，单个对象形式不提供索引运算符（<code>operator[]</code>），而数组形式不提供解引用运算符（<code>operator*</code>和<code>operator-&gt;</code>）。但实际上，数组形式用到的场合非常少，唯一的应用场合大概是在使用 C 风格 API 时，它返回了存放在堆上的裸指针；大部分时候我们会优先考虑<code>std::array</code>、<code>std::vector</code>和<code>std::string</code>这些数据结构。</p><p><code>std::unique_ptr</code>可以方便高效地转换为<code>std::shared_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Investment&gt; sp = <span class="built_in">makeInvestment</span>( arguments );</span><br></pre></td></tr></table></figure><h3 id="条款-19：使用-std-shared-ptr-管理具备共享所有权的资源">条款 19：使用 std::shared_ptr 管理具备共享所有权的资源</h3><hr><p>要点：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/1.png" alt=""></p><p>引用计数的存在对性能的影响：</p><ul><li><strong>std::shared_ptr 的大小是原始指针的两倍</strong>：因为内部包含一个指向资源的<strong>原始指针</strong>，以及一个指向资源<strong>引用计数的原始指针</strong>【我的理解是控制块指针】</li><li><strong>引用计数的内存必须动态分配</strong>：所指向的对象对引用计数一无所知，对象没有存储引用计数的地方</li><li><strong>引用计数的增加和减少必须是原子操作</strong>：例如，在一个线程中指向资源的 std::shared_ptr 可能正在执行其析构函数，而在另一个线程中，指向同一对象的 std::shared_ptr 可能正在被拷贝</li></ul><p>简单例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A *a = new A;</span></span><br><span class="line">    <span class="keyword">auto</span> fun = [](A *a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, <span class="title">decltype</span><span class="params">(fun)</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A, fun)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>不能从单个原始指针构造多个std::shared_ptr</strong>，否则指向的对象将有多个控制块，导致未定义的行为。</p><p><strong>std::shared_ptr的另一个局限性是无法处理数组</strong>。与std::unique_ptr不同，std::shared_ptr的 API 仅设计用于指向单个对象。没有std::shared_ptr&lt;T[]&gt;， 也没有提供operator[]。<strong>C++11 中有多种内置数组的替代方案</strong>（例如，std::array、std::vector、std::string），声明一个智能指针来指向愚蠢的数组几乎总是糟糕设计的标志。</p><hr><p><code>std::shared_ptr</code>提供了方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>所占大小通常是裸指针的两倍，它还会带来控制块的开销，并且要求成本高昂的原子化的引用计数操作。</p><p>默认的资源析构通过<code>delete</code>运算符来完成，但同时也支持自定义删除器。与<code>std::unique_ptr</code>不同的是，删除器的类型对<code>std::shared_ptr</code>的类型没有影响，也不会影响<code>std::shared_ptr</code>的尺寸大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget* pw) &#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pw);</span><br><span class="line">    <span class="keyword">delete</span> pw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(loggingDel)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt;                       <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure><p>这使得<code>std::shared_ptr</code>的设计更具弹性，拥有不同类型自定义删除器的<code>std::shared_ptr</code>也可以被放在同一个容器中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> customDeleter1 = [](Widget* pw) &#123;&#125;;    <span class="comment">// 自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> customDeleter2 = [](Widget* pw) &#123;&#125;;    <span class="comment">// 各有不同的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter1)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter2)</span></span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;</span><br></pre></td></tr></table></figure><p><strong>控制块（control block）：</strong> 每一个由<code>std::shared_ptr</code>管理的对象都拥有一个控制块，它的内存被动态分配在堆上，除了包含引用计数以外，还包含作用于<code>std::weak_ptr</code>的弱计数（参考<strong>条款 20</strong>），自定义删除器和分配器等内容。</p><p>一个对象的控制块应该在创建首个指向该对象的<code>std::shared_ptr</code>时确定，因此，控制块的创建遵循以下规则：</p><ol><li>使用<code>std::make_shared</code>（参考<strong>条款 21</strong>）总是会创建一个控制块。</li><li>从具备专属所有权的指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）出发构造一个<code>std::shared_ptr</code>时，会创建一个控制块。</li><li>用裸指针作为实参调用<code>std::shared_ptr</code>的构造函数时，会创建一个控制块。</li></ol><p>由以上规则我们可以得出，应该避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>。用同一个裸指针构造出不止一个<code>std::shared_ptr</code>将会使对象拥有多重的控制块，这会导致对资源的多次析构，从而产生未定义行为，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget; <span class="comment">// pw 是个裸指针</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, loggingDel)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(spw1)</span></span>;</span><br></pre></td></tr></table></figure><p>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全地由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，应该使该类继承自<code>std::enable_shared_from_this</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::enable_shared_from_this</code>定义了一个成员函数<code>std::shared_from_this</code>，它会创建一个<code>std::shared_ptr</code>指向当前对象，但不会重复创建控制块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidget;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理对象本身</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指向当前对象的 std::shared_ptr 加入 processedWidget</span></span><br><span class="line">    processedWidget.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免用户在<code>std::shared_ptr</code>指向该对象前就调用了<code>std::shared_from_this</code>（这会导致其无法查询到对象拥有的控制块，产生未定义行为），继承自<code>std::enable_shared_from_this</code>的类通常会将其构造函数声明为 private，并且只允许通过调用返回<code>std::shared_ptr</code>的工厂函数来创建对象。例如，以下是<code>Widget</code>类的一个可能实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将实参完美转发给 private 构造函数的工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::shared_ptr&lt;Widget&gt; <span class="title">create</span><span class="params">(Ts&amp;&amp;... params)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( ... );  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code>可以轻易转换为<code>std::shared_ptr</code>，反之却并不成立，一旦资源的生存期被托管给了<code>std::shared_ptr</code>，就不能回收该资源的所有权，并让一个<code>std::unique_ptr</code>来托管它。并且和<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>直到 C++17 才拥有处理数组的能力（<code>std::shared_ptr&lt;T[]&gt;</code>），在 C++11/14 中，它的 API 仅被设计用来处理指向单个对象的指针。</p><h3 id="条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr">条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h3><hr><p>weak_ptr观察者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();  <span class="comment">// 引用计数=1</span></span><br><span class="line">…</span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;         <span class="comment">// 引用计数=1</span></span><br><span class="line">…</span><br><span class="line">spw = <span class="literal">nullptr</span>;                          <span class="comment">// 引用计数=0，spw变为空悬</span></span><br><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>()) …                    <span class="comment">// 如果 wpw 没有指向任何对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但通常你希望检查 std::weak_ptr是否有效，如果它不是悬挂的，则访问它指向的对象。</p><ul><li>因为 std::weak_ptr缺乏解引用操作，所以无法编写这样的代码。</li><li>需要原子操作，检查 std::weak_ptr是否有效， 有效则从 std::weak_ptr创建一个 std::shared_ptr来进行访问</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock(); <span class="comment">// 如果 wpw 无效, spw1 将会是空</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.lock(); <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>std::shared_ptr可以使用std::weak_ptr作为参数进行构造，如果std::weak_ptr已经无效，就会抛出一个异常:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title function_">spw3</span><span class="params">(wpw)</span>; <span class="comment">// 无果 wpw 无效, 则抛出 std::bad_weak_ptr</span></span><br></pre></td></tr></table></figure><p><strong>要点速记</strong></p><ul><li>对于类似std::shared_ptr的可能会悬挂的指针，请使用std::weak_ptr。</li><li>std::weak_ptr的潜在用例包括缓存、观察者列表以及防止std::shared_ptr循环。【Modern Cpp中已经讲述详细了的】</li></ul><hr><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充。它一般是通过<code>std::shared_ptr</code>来创建的，两者会指向相同位置，但<code>std::weak_ptr</code>并不影响所指向对象的引用计数，而是会影响控制块中的弱计数。</p><p>使用<code>expired</code>函数来检测<code>std::weak_ptr</code>的空悬：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">spw = <span class="literal">nullptr</span>;      <span class="comment">// Widget 对象被析构，wpw 空悬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>())  <span class="comment">// 若 wpw 不再指向任何对象</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>，可以在未失效情况下提供对资源的访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lock 函数时，若 wpw 失效，则 spw1 和 spw2 为空</span></span><br><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接构造时，若 wpw 失效，则抛出 std::bad_weak_ptr 类型的异常</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::weak_ptr</code>有以下可能的用武之地：</p><ul><li>创建带缓存的工厂函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="type">const</span> Widget&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>(); <span class="comment">// 如果对象不在缓存中，则返回空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;                  <span class="comment">// 加载并缓存对象</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);</span><br><span class="line">        cache[id] = objPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>观察者设计模式（Observer design pattern）：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li><li>避免<code>std::shared_ptr</code>循环引用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;B&gt; pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;A&gt; pa;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pa = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> pb = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">pa-&gt;pb = pb;</span><br><span class="line">pb-&gt;pa = pa;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>A</code>和<code>B</code>互相保存着指向对方的<code>std::shared_ptr</code>，产生了循环引用，两者会永久保持彼此的引用计数至少为一，这会阻止<code>A</code>和<code>B</code>被析构，实际上产生了内存泄漏。</p><p>将其中一者改为<code>std::weak_ptr</code>可以避免循环的产生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;B&gt; pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::weak_ptr&lt;A&gt; pa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new">条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h3><hr><blockquote><p><strong>好处1.原子性</strong></p></blockquote><p>1.原子性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">computePriority</span><span class="params">()</span>;</span><br><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(new Widget), computePriority()); <span class="comment">// 可能资源泄漏</span></span><br></pre></td></tr></table></figure><p>在运行时，函数的参数必须在调用函数之前进行求值：</p><ul><li>计算 new Widget 表达式，即必须在堆上创建一个 Widget</li><li>执行负责管理 new产生的指针的 std::shared_ptr&lt; Widget &gt;的构造函数</li><li>运行computePriority必须</li></ul><p><strong>编译器不需要生成按照这个顺序执行的代码</strong>。【编译器进行优化】new Widget必须在 std::shared_ptr`构造函数被调用之前执行即可。</p><p>编译器可能会生成按照以下顺序执行操作的代码：</p><p>1、执行 new Widget；</p><p>2、执行 computePriority；</p><p>3、运行 std::shared_ptr 构造函数。如果运行时，computePriority 产生异常，那么步骤 1 中动态分配的 Widget 将泄漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::make_shared&lt;Widget&gt;(), computePriority()); <span class="comment">// 不会发生内存泄露</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>好处2.内存分配次数</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure><p>这段代码执行了两次内存分配。直接使用 new，需要一次为 Widget 分配内存，第二次为控制块分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared&lt;Widget&gt;();</span><br></pre></td></tr></table></figure><p>std::make_shared分配了一个单独的内存块来容纳 Widget 对象和控制块，这种优化减少了程序的静态大小，因为代码中只包含一个内存分配调用，并且它提高了可执行代码的速度，因为只分配了一次内存。</p><blockquote><p><strong>坏处：不能自定义删除器</strong></p></blockquote><p>但没有任何make函数允许指定自定义删除器，而是 std::unique_ptr 和 std::shared_ptr 都有构造函数可以这样做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget, <span class="title function_">decltype</span><span class="params">(widgetDeleter)</span>&gt; <span class="title function_">upw</span><span class="params">(new Widget, widgetDeleter)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title function_">spw</span><span class="params">(new Widget, widgetDeleter)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>不建议使用make的情况</strong></p></blockquote><p>1、当类有自己的 operator new 和 operator delete 实现时，与 std::shared_ptr 的自定义分配和释放支持可能不兼容，因此使用 make 函数创建这些类的对象可能不合适。这可能会导致内存管理方面的问题。</p><p>2、std::shared_ptr 的控制块与管理对象放在同一块内存中。当该对象的引用计数为零时，该对象将被销毁（即，调用其析构函数）。但是，在控制块也被销毁之前，它所占用的内存不能被释放</p><ul><li>由 std::shared_ptr make 函数分配的内存只有在最后一个 std::shared_ptr 和最后一个引用它的 std::weak_ptr 被销毁后才能被释放。对象销毁和它占用的内存被释放之间可能会出现滞后</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReallyBigType</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">auto</span> pBigObj = <span class="built_in">std</span>::make_shared&lt;ReallyBigType&gt;(); <span class="comment">// 通过std::make_shared创建非常大的对象</span></span><br><span class="line">... <span class="comment">// 创建 std::shared_ptrs 和 std::weak_ptrs 到大对象，使用它们与之合作</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::shared_ptr，但对它的 std::weak_ptr 仍然存在</span></span><br><span class="line">... <span class="comment">// 在这段时间内，以前被大对象占用的内存仍然被分配</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::weak_ptr;</span></span><br><span class="line"><span class="comment">// 控制块和对象的内存被释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过直接使用 new，ReallyBigType 对象的内存可以在最后一个对它的 std::shared_ptr 被销毁后立即释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReallyBigType</span>&#123;</span>...&#125;; <span class="comment">// 与之前一样</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ReallyBigType&gt; <span class="title function_">pBigObj</span><span class="params">(new ReallyBigType)</span>;</span><br><span class="line"><span class="comment">// 通过 new 创建非常大的对象</span></span><br><span class="line">... <span class="comment">// 与之前一样，创建对象的 std::shared_ptrs 和 std::weak_ptrs，与之一起使用</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::shared_ptr，但对它的 std::weak_ptrs 仍然存在;</span></span><br><span class="line"><span class="comment">// 对象的内存已被释放</span></span><br><span class="line">... <span class="comment">// 在这段时间内，只有控制块的内存仍然有效</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::weak_ptr;</span></span><br><span class="line"><span class="comment">// 控制块的内存被释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果不适合使用 std::make_shared ，又希望免受异常安全问题的影响。最好的方法是确保当直接使用 new 时，立即将结果传递给智能指针构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="type">int</span> priority)</span>;<span class="comment">// 像以前一样void cusDel(Widget *ptr); // 自定义删除器</span></span><br><span class="line"><span class="comment">// 潜在的资源泄漏processWidget( std::shared_ptr&lt;Widget&gt;(new Widget, cusDel), computePriority() );</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title function_">spw</span><span class="params">(new Widget, cusDel)</span>;</span><br><span class="line">processWidget(spw, computePriority()); <span class="comment">// 正确，但不是最佳的，参数变为了左值</span></span><br><span class="line">processWidget(<span class="built_in">std</span>::move(spw), computePriority());<span class="comment">// 既高效又异常安全</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li>与使用 new 相比，make 函数消除了源代码重复，提高了异常安全性，并且对于 std::make_shared 和 std::allocate_shared，生成的代码更小、更快。</li><li>不适合使用 make 函数的情况包括，需要指定自定义删除器和希望传递花括号初始化器。</li><li>对于 std::shared_ptr，不建议使用 make 函数的其他情况包括（1）具有自定义内存管理的类；（2）注重内存效率的系统，具有非常大的对象以及比相应的 std::shared_ptr 存活时间更长的 std::weak_ptr</li></ul><hr><p><code>std::make_shared</code>是 C++11 的一部分，但<code>std::make_unique</code>到了 C++14 才被加入标准库，不过要写出一个基础版本的<code>std::make_unique</code>非常容易：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于直接使用<code>new</code>运算符，make 函数有以下优势：</p><ul><li>消除重复代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;      <span class="comment">// 使用 make 函数</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// 不使用 make 函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;      <span class="comment">// 使用 make 函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// 不使用 make 函数</span></span><br></pre></td></tr></table></figure><ul><li>改进了异常安全性：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>());  <span class="comment">// 有潜在的内存泄漏风险</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), <span class="built_in">computePriority</span>());           <span class="comment">// 不具有潜在的内存泄漏风险</span></span><br></pre></td></tr></table></figure><p>在直接使用<code>new</code>运算符的情况下，由于分配<code>Widget</code>对象、执行<code>std::shared_ptr</code>构造函数、执行<code>computePriority</code>函数三者并不存在固定顺序，<code>computePriority</code>函数可能会晚于<code>Widget</code>对象的分配，先于<code>std::shared_ptr</code>的构造函数执行，此时若<code>computePriority</code>产生异常，那么分配的<code>Widget</code>内存就会发生泄漏。使用<code>std::make_shared</code>则不会产生这个问题。</p><ul><li>使用<code>std::make_shared</code>和<code>std::allocate_shared</code>有助于生成的尺寸更小、速度更快的目标代码。</li></ul><blockquote><p><code>std::make_shared</code>会将指向的对象和与其相关联的控制块分配在单块内存中，这种优化减少了程序的静态尺寸，并且因为只进行一次内存分配，还可以加块代码的运行速度。使用<code>std::make_shared</code>还可以减少对控制块一些簿记信息（bookkeeping information）的需要，潜在地减少了程序的内存占用量（memory footprint）。<code>std::allocate_shared</code>也是同理。</p></blockquote><p>虽然有着如此多的优势，但还是有一些情形下，不能或者不应该使用 make 函数：</p><ul><li>使用 make 函数无法自定义删除器，以及直接传递大括号内的初始值设定项：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想要自定义删除器，就只能使用 new 运算符</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(widgetDeleter)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt;                          <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能间接传递初始化列表给 make 函数</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure><ul><li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。因此，使用 make 函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象，通常并不是个好主意。</li><li>当处于特别关注内存的系统中时，若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数：这会导致对象的析构和内存的释放之间产生延迟，而若直接使用<code>new</code>运算符，内存的释放就不必等待<code>std::weak_ptr</code>的析构。</li></ul><p>如果你发现自己处于不应该使用<code>std::make_shared</code>的情形下，又不想受到之前所述异常安全问题的影响。最好的方法是确保在直接使用<code>new</code>时，立即将结果传递给智能指针的构造函数，并且在这条语句中不做其它任何事：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">move</span>(spw), <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure><h3 id="条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中">条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h3><p>Pimpl 惯用法的第一部分，是声明一个指针类型的数据成员，指向一个非完整类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    Impl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二部分是动态分配和回收持有原始类中数据成员的对象，而分配和回收的代码被放在实现文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;                   <span class="comment">// Widget::Impl 的实现</span></span><br><span class="line">    std::string name;                   <span class="comment">// 包含在原始 Widget 类中的数据成员</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(<span class="keyword">new</span> Impl) &#123;&#125;   <span class="comment">// 为 Widget 对象分配数据成员所需内存</span></span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123; <span class="keyword">delete</span> pImpl; &#125;     <span class="comment">// 为 Widget 对象析构数据成员</span></span><br></pre></td></tr></table></figure><p>上面展示的是 C++98 的写法，使用了裸指针、裸<code>new</code>运算符和裸<code>delete</code>运算符。而到了 C++11，使用<code>std::unique_ptr</code>替代指向<code>Impl</code>的裸指针成为了首选：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;   <span class="comment">// 同前</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>遗憾的是，这段代码本身能通过编译，但在创建对象时却会报错。因为编译器自动生成的析构函数默认是<code>inline</code>的，而<code>std::unique_ptr</code>的默认删除器要求其指向完整类型，所以即使默认特殊函数的实现有着正确行为，我们仍必须将其声明和实现分离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123;&#125;    <span class="comment">// 写成 Widget::~Widget() = default; 效果相同</span></span><br></pre></td></tr></table></figure><p>在<strong>条款 17</strong> 中我们提到，声明析构函数会阻止编译器生成移动操作，所以假如你需要支持移动操作，也必须采用声明和实现分离的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><p>编译器不会为带有<code>std::unique_ptr</code>这种只移类型的类生成拷贝操作，假如你需要支持拷贝操作，则需要自行编写执行深拷贝的函数实现，并且同样需要遵守前面所说的规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;(*rhs.pImpl)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    *pImpl = *rhs.pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述建议仅仅适用于<code>std::unique_ptr</code>，而不适用于<code>std::shared_ptr</code>。对于<code>std::shared_ptr</code>而言，删除器类型并非智能指针类型的一部分，这就会导致更大的运行时数据结构以及更慢的目标代码，但在使用编译器生成的特殊函数时，并不要求其指向完整类型。以下代码并不会产生问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ...         <span class="comment">// 不再需要析构函数或移动操作的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::shared_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就 Pimpl 惯用法而言，并不需要在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间作出权衡，因为<code>Widget</code>和<code>Impl</code>之间的关系是专属所有权，所以在此处<code>std::unique_ptr</code>就是完成任务的合适工具。</p><h2 id="第五章：右值引用、移动语义和完美转发">第五章：右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，需要铭记一点：形参总是左值，即使其类型是右值引用。例如给定函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; w)</span></span>;</span><br></pre></td></tr></table></figure><p>尽管形参<code>w</code>的类型是指向<code>Widget</code>对象的右值引用，可以传入绑定到右值的实参，但它仍然是个左值。</p><h3 id="条款-23：理解-std-move-和-std-forward">条款 23：理解 std::move 和 std::forward</h3><hr><p>重点：</p><p><strong>std::move 和 std::forward 仅仅是执行类型转换的函数（实际上是函数模板）</strong></p><p>std::move 无条件地将其参数转换为右值，而 std::forward 只有在满足特定条件时才执行此转换。</p><p>右值只是移动的候选者。</p><blockquote><p>来看个case:</p></blockquote><p>结论：如果希望进行移动操作，不要声明对象为const。对常量对象的移动请求会默默地转换为拷贝操作。</p><p>string构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="built_in">string</span>&amp; rhs);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);       <span class="comment">// 移动构造函数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    explicit <span class="title function_">Annotation</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span>:<span class="title function_">value</span><span class="params">(<span class="built_in">std</span>::move(text))</span><span class="comment">//并不像看上去这样！</span></span><br><span class="line">    &#123;... &#125;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>text 是一个左值 const std::string，转换的结果是一个右值 const std::string，但始终保持常量性</strong>。</p><p>结果就是，text 没有被移动到 value 中，而是被拷贝了。</p><p><strong>简单来说</strong>：一个右值引用，编译器先找有没有匹配的fun(A &amp;&amp;)，如果没有，则找fun(const A&amp;a)</p><blockquote><p><strong>std::move 和 std::forward</strong></p></blockquote><p>既然 std::move 和 std::forward 都归结为转换，唯一的区别是 std::move 总是进行转换，而 std::forward 只是有时进行转换</p><p><strong>要点</strong></p><ul><li>std::move执行无条件转换为右值。就其本身而言，它不会移动任何东西</li><li>只有当参数绑定到右值时，std::forward 才会将其参数转换为右值</li><li>std::move 和 std::forward 在运行时都不会做任何事情</li></ul><hr><p><code>std::move</code>执行的是向右值的无条件强制类型转换，就其自身而言，它不会移动任何东西。它的基本实现大致是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::move</code>并不改变常量性，也不保证经过其强制类型转换后的对象可被移动，针对常量对象执行的移动操作可能会悄无声息地转化为拷贝操作，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span></span></span><br><span class="line"><span class="function">        : value(std::move(text)) &#123;</span> ... &#125;    <span class="comment">// 想要将 text “移动入” value</span></span><br><span class="line">    ...                                     <span class="comment">// 但实际上执行了 std::string 的拷贝构造函数</span></span><br><span class="line">                                            <span class="comment">// 而非移动构造函数 string(string&amp;&amp;)</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量。</p><p>与<code>std::move</code>不同，<code>std::forward</code>是有条件的。仅当传入的实参被绑定到右值时，<code>std::forward</code>才会针对该实参执行向右值的强制类型转换，它同样不会转发任何东西。</p><p><code>std::forward</code>的一个典型应用场景，是某个函数模板使用万能引用作为形参，随后将其传递给另一个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;    <span class="comment">// 处理左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;         <span class="comment">// 处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;         <span class="comment">// 使用万能引用作为实参</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若在调用<code>logAndProcess</code>时传入左值，那么该左值自然会传递给处理左值版本的<code>process</code>函数；若在调用<code>logAndProcess</code>时传入右值，由于函数形参皆为左值，必须要通过<code>std::forward</code>将<code>param</code>强制转换为右值类型，才能得以正确调用处理右值版本的<code>process</code>函数。<code>std::forward</code>会通过模板类型<code>T</code>来判断是否该对<code>param</code>进行强制类型转换，具体的原理细节参考<strong>条款 28</strong>。</p><p>尽管<code>std::move</code>和<code>std::forward</code>归根结底都是强制类型转换，但两者的行为具有本质上的不同：前者用于为移动操作进行铺垫，而后者仅仅用于转发一个对象到另一个函数，在此过程中该对象仍保持原来的左值性或右值性。</p><blockquote><p>需要注意的是，在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p></blockquote><h3 id="条款-24：区分万能引用和右值引用">条款 24：区分万能引用和右值引用</h3><hr><p><strong>通用引用2个条件：</strong></p><p>1：T&amp;&amp; / auto &amp;&amp;</p><p>2.存在类型推导</p><p><strong>右值引用</strong>，不是通用引用就是右值引用。</p><hr><p>如果函数模板形参的类型为<code>T&amp;&amp;</code>，并且 T 的类型需要推导得到，或一个对象使用<code>auto&amp;&amp;</code>声明其类型，则此处的<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>表示<strong>万能引用（universal reference）</strong>；如果类型声明不是标准的<code>type&amp;&amp;</code>形式，或者并未发生类型推导，则此处的<code>type&amp;&amp;</code>表示右值引用。</p><p>符合万能引用的情形如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> timeFuncInvocation = [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params) &#123;   <span class="comment">// C++14</span></span><br><span class="line">    std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(                         <span class="comment">// 调用 func</span></span><br><span class="line">        std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...               <span class="comment">// 取用 params</span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类型声明不是标准<code>type&amp;&amp;</code>的情形如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// param 是右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;        <span class="comment">// param 是右值引用</span></span><br></pre></td></tr></table></figure><p>类型是<code>T&amp;&amp;</code>，但并未发生类型推导的情形如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);  <span class="comment">// x 是右值引用</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若使用右值来初始化万能引用，就会得到一个右值引用；同理，若使用左值来初始化万能引用，就会得到一个左值引用。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">// param 是万能引用</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="built_in">f</span>(w);               <span class="comment">// 左值被传递给 f，param 的类型为 Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(w));    <span class="comment">// 右值被传递给 f，param 的类型为 Widget&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward">条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward</h3><hr><p>右值引用 std::move，万能引用 std::forward。</p><blockquote><p><strong>ex1</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="comment">// 按值返回</span></span><br><span class="line">operator+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::move(lhs); <span class="comment">// 将 lhs 移动到返回值中</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过在返回语句中（通过 std::move）将 lhs 强制转换为右值，lhs 将被移动到函数的返回值位置</p><p>如果省略了对 std::move 的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix </span><br><span class="line">operator+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> lhs; <span class="comment">// 将 lhs 拷贝到返回值</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事实上，lhs是一个左值，这会迫使编译器将它拷贝到返回值的位置</p><blockquote><p><strong>ex2</strong></p></blockquote><p>RVO 只能在返回的是局部对象的情况下执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::move(w);<span class="comment">//返回的不是局部对象 w，而是 w 的引用</span></span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li>对于右值引用使用 std::move，对于通用引用使用 std::forward，且都在最后一次使用时进行</li><li>对于按值返回的函数，返回的右值引用和通用引用，也执行相同的操作</li><li>如果局部对象本来可以进行返回值优化，就不要对它们应用 std::move 或 std::forward</li></ul><hr><p>右值引用一定会被绑定到右值，因此当转发右值引用给其他函数时，应当通过<code>std::move</code>对其实施向右值的无条件强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)),</span><br><span class="line">          <span class="built_in">p</span>(std::<span class="built_in">move</span>(rhs.p)) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而万能引用不一定会被绑定到右值，因此当转发万能引用时，应当通过<code>std::forward</code>对其实施向右值的有条件强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然针对右值引用实施<code>std::forward</code>也能硬弄出正确行为，但代码啰嗦、易错，且不符合习惯用法；而针对万能引用实施<code>std::move</code>会造成更加严重的后果，这会导致某些左值遭受意外的改动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;    <span class="comment">// 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>();</span><br><span class="line">w.<span class="built_in">setName</span>(n);               <span class="comment">// 将 n 移入 w</span></span><br><span class="line">...                         <span class="comment">// n 的值变为未知</span></span><br></pre></td></tr></table></figure><p>一种手法是将万能引用的版本改成对左值和右值分别进行重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种手法虽然看似可以解决问题，但是拥有更大的缺点：第一，需要编写和维护更多源码；第二，效率会大打折扣（产生额外的临时对象）；第三，可扩展性太差。因此，正确地使用万能引用才是问题的唯一解决之道。</p><p>在有些情况下，你可能想在函数内将某个对象不止一次地绑定到右值引用或万能引用，并且想保证在完成对该对象地其它所有操作之前，其值不会发生移动，那么就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; text)</span> </span>&#123;</span><br><span class="line">    sign.<span class="built_in">setText</span>(text);                         <span class="comment">// 使用 text，但不修改其值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    signHistory.<span class="built_in">add</span>(now, std::forward&lt;T&gt;(now)); <span class="comment">// 有条件地将 text 强制转换为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在极少数的情况下，你需要用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。</p><blockquote><p><code>std::move_if_noexcept</code>是<code>std::move</code>的一个变体，它是否会将对象强制转换为右值，取决于其类型的移动构造函数是否带有 noexcept 声明。</p></blockquote><p>在按值返回的函数中，如果返回的是绑定到右值引用或万能引用的对象，则当你返回该引用时，应当对其实施<code>std::move</code>或<code>std::forward</code>，这样可以避免编译器将其视作左值，从而消除拷贝左值进入返回值存储位置的额外开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值返回右值引用形参</span></span><br><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(lhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值返回万能引用形参</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduceAndCopy</span><span class="params">(T&amp;&amp; frac)</span> </span>&#123;</span><br><span class="line">    frac.<span class="built_in">reduce</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;T&gt;(frac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是若局部对象可能适用于<strong>返回值优化（return value optimization，RVO）</strong>，则请勿对其实施<code>std::move</code>或<code>std::forward</code>。这是因为当 RVO 的前提条件得到满足时，要么发生<strong>拷贝省略（copy elision）</strong>，要么<code>std::move</code>会隐式地被实施于返回的局部对象上；而人为地添加<code>std::move</code>或<code>std::forward</code>，会导致编译器失去执行 RVO 的能力。</p><p>下面的<code>makeWidget</code>函数满足 RVO 的两个前提条件：局部对象类型和函数返回值类型相同，且返回的就是局部对象本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于函数形参不适合实施拷贝省略，所以编译器必须处理以上代码，使其与以下代码等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-26：避免对万能引用类型进行重载">条款 26：避免对万能引用类型进行重载</h3><hr><p>重点：</p><p>**接受通用引用的函数是 C++ 中最贪婪的函数。**它们实例化以创建几乎任何类型的参数的精确匹配，结合重载和通用引用几乎总是一个坏主意。</p><p><strong>要点</strong></p><ul><li>对通用引用进行重载，几乎总是导致它的过度使用</li><li>完美转发构造函数尤其成问题，因为对于非const 左值，它们通常比拷贝构造函数更匹配，并且它们可以劫持</li><li>派生类对基类拷贝和移动构造函数的调用</li></ul><hr><p>形参为万能引用的函数是 C++ 中最贪婪的，它们会在具现过程中和几乎所有实参类型产生精确匹配（极少的不适用实参将在<strong>条款 30</strong> 中介绍），这就是为何把重载和万能引用两者结合通常不会达到预期效果。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> nameIdx;      <span class="comment">// 用 short 类型持有索引值</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(nameIdx); <span class="comment">// 调用的却是万能引用版本</span></span><br></pre></td></tr></table></figure><p><code>logAndAdd</code>有两个重载版本，形参类型为万能引用的版本可以将<code>T</code>推导为<code>short</code>，从而产生精确匹配；而形参类型为<code>int</code>的版本却只能在类型提升后才可以匹配到<code>short</code>类型的实参。因此，形参类型为万能引用的版本才是被优先调用的版本。</p><p>当完美转发出现在类的构造函数中时，情况会变得更加复杂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">// 完美转发构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span></span></span><br><span class="line"><span class="function">        : name(std::forward&lt;T&gt;(n)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span></span>;   <span class="comment">// 形参为 int 的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);  <span class="comment">// 拷贝构造函数（由编译器生成）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; rhs);       <span class="comment">// 移动构造函数（由编译器生成）</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于非常量的左值类型，完美转发构造函数一般都会优先于拷贝构造函数形成匹配；而对于常量左值类型，完美转发构造函数和拷贝构造函数具有相等的匹配程度，此时由于非函数模板会优先于函数模板被匹配，编译器才会转向调用拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;           <span class="comment">// 调用完美转发构造函数，无法通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Person <span class="title">cp</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;   <span class="comment">// 对象成为了常量</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfCp</span><span class="params">(cp)</span></span>;         <span class="comment">// 会正确调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>完美转发构造函数还会劫持派生类中对基类的拷贝和移动构造函数的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        : <span class="built_in">Person</span>(rhs) &#123;&#125;                    <span class="comment">// 调用的是基类的完美转发构造函数！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs)      <span class="comment">// 移动构造函数</span></span><br><span class="line">        : <span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs)) &#123;&#125;         <span class="comment">// 调用的是基类的完美转发构造函数！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-27：熟悉对万能引用类型进行重载的替代方案">条款 27：熟悉对万能引用类型进行重载的替代方案</h3><p><strong>1. 放弃重载</strong></p><p><strong>2. 传递<code>const T&amp;</code>类型的形参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法可以避免重载万能引用带来的不良影响，但会舍弃一些性能。</p><p><strong>3. 传值</strong></p><p>把传递的形参从引用类型换成值类型，是一种经常能够提升性能，却不会增加任何复杂性的方法，尽管这有些反直觉。这种设计遵循了<strong>条款 41</strong> 的建议——当你知道肯定需要复制形参时，考虑按值传递对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string n)</span>  <span class="comment">// 替换掉 T&amp;&amp; 类型的构造函数</span></span></span><br><span class="line"><span class="function">        : name(std::move(n)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span>        <span class="comment">// 同前</span></span></span><br><span class="line"><span class="function">        : name(nameFromIdx(idx)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4. 使用标签分派（tag dispatch）</strong></p><p>在这个方案中，我们将实际重载和实现功能的函数改为<code>logAndAddImpl</code>，而<code>logAndAdd</code>仅仅用于执行完美转发和标签分派：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name),</span><br><span class="line">        std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;());    <span class="comment">// C++14 可以使用 std::remove_reference_t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对<code>std::is_integral</code>产生的布尔值，我们可以写出两个<code>logAndAddImpl</code>重载版本，用于区分它们的类型<code>std::false_type</code>和<code>std::true_type</code>就是所谓 “标签”。具体实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span> </span>&#123; <span class="comment">// 非整型实参</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span> </span>&#123;   <span class="comment">// 整型实参</span></span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 对接受万能引用的模板施加限制</strong></p><p>通过 SFINAE 技术和<code>std::enable_if</code>，我们可以让一些模板在满足了指定条件的情况下才被启用，它的使用方式大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">             <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;condition&gt;::type&gt;    <span class="comment">// C++14 可以使用 std::enable_if_t</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处我们想要<code>T</code>是<code>Person</code>以外的类型时，才启用该模板构造函数，则我们可以写下面这样的条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!std::is_same&lt;Person, <span class="keyword">typename</span> std::decay&lt;T&gt;::type&gt;::value  <span class="comment">// C++17 可以使用 std::is_same_v</span></span><br></pre></td></tr></table></figure><p><code>std::decay</code>用于使类型完全退化，在此处用来移除<code>T</code>的引用和 cv 限定符（即<code>const</code>或<code>volatile</code>限定符），使我们可以更加纯粹地关注类型本身。<code>std::decay</code>还可以用于把数组和函数类型强制转换为指针类型（参考<strong>条款 1</strong>），它当然也拥有更易用的 C++14 版本，即<code>std::decay_t</code>。</p><p>写出这个条件并不意味着完成，<strong>条款 26</strong> 中还提到了在派生类中调用基类的拷贝和移动构造函数时，错误调用完美转发构造函数的问题。因此，我们想要的是为<code>Person</code>和继承自<code>Person</code>的类型都不一样的实参类型启用模板构造函数。标准库中的<code>std::is_base_of</code>用于判断一个类型是否由另一个类型派生而来，用它代替<code>std::is_same</code>就可以得到我们想要的东西（C++17 可以使用<code>std::is_base_of_v</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                       !std::is_base_of&lt;Person, </span><br><span class="line">                                        <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                                       &gt;::value</span><br><span class="line">                   &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再加上处理整型实参的构造函数重载版本，并进一步限制模板构造函数，禁止其接受整型实参，我们得到的完美的<code>Person</code>类代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">            !std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n)              <span class="comment">// 接受 std::string 类型以及可以强制转换为 </span></span><br><span class="line">    : <span class="built_in">name</span>(std::forward&lt;T&gt;(n)) &#123; ... &#125;  <span class="comment">// std::string 类型的实参的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(<span class="type">int</span> idx)            <span class="comment">// 接受整型实参的构造函数</span></span><br><span class="line">    : <span class="built_in">name</span>(<span class="built_in">nameFromIdx</span>(idx)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    ...                                 <span class="comment">// 拷贝和移动构造函数等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>权衡</strong></p><p>本条款讨论的前三种方案（舍弃重载，传递<code>const T&amp;</code>类型的形参和传值）都需要对待调用的函数形参逐一指定类型，而后两种方案（使用标签分派和对接受万能引用的模板施加限制）则使用了完美转发，因此无需指定形参类型。</p><p>按照常理，完美转发的效率更高，因为它将类型保持和形参声明时完全一致，所以会避免创建临时对象。但完美转发也有一些不足：首先是针对某些类型无法实现完美转发（参考<strong>条款 30</strong>），其次是完美转发会使得在传递非法形参时，出现更难理解的错误信息。</p><p><code>std::is_constructible</code>这个类型特征（type trait）可以在编译期判断某个类型的对象是否可以用另一类型的对象（或不同类型的多个对象）来构造，我们可以用它来验证转发函数的万能引用形参是否合法。下面是增加了<code>static_assert</code>后的<code>Person</code>类，它可以产生更明确的报错信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;...&gt;&gt;  <span class="comment">// 同前</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n)</span><br><span class="line">        : <span class="built_in">name</span>(std::forward&lt;T&gt;(n)) &#123;</span><br><span class="line">        <span class="comment">// 断言可以用 T 类型的对象构造 std::string</span></span><br><span class="line">        <span class="built_in">static_assert</span>(</span><br><span class="line">            std::is_constructible&lt;std::string, T&gt;::value,   <span class="comment">// C++17 可以使用 std::is_constructible_v</span></span><br><span class="line">            <span class="string">&quot;Parameter n can&#x27;t be used to construct a std::string&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 构造函数通常要完成的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-28：理解引用折叠">条款 28：理解引用折叠</h3><hr><p>根据以下规则将引用折叠为单个引用：</p><ul><li>如果两个都是右值引用，结果是一个右值引用（右值-右值）</li><li>否则结果为左值引用（左值-左值、左值-右值、右值-左值）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget <span class="title function_">widgetFactory</span><span class="params">()</span>; <span class="comment">// 返回右值的函数</span></span><br><span class="line">Widget w; <span class="comment">// 变量（左值）</span></span><br><span class="line">func(w); <span class="comment">// 用左值调用 func; T 推导为 Widget&amp;</span></span><br><span class="line">func(widgetFactory()); <span class="comment">// 用右值调用 func; T 推导为 Widget</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用折叠是 std::forward 工作的关键</p><p><strong>std::forward原理</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 在命名空间std</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li>引用折叠发生在四个上下文中：模板实例化、auto类型生成、typedef别名声明的创建和使用以及decltype</li><li>当编译器在引用折叠上下文中生成对引用的引用时，结果变成单个引用。如果原始引用中的任何一个是左值引用，则结果是左值引用。否则，它是右值引用</li><li>通用引用是在类型推导区分左值和右值以及发生引用折叠的上下文中的右值引用</li></ul><hr><p>在<strong>条款 24</strong> 中我们了解了万能引用和右值引用的区别，但实际上万能引用并非一种新的引用类型，其实它就是在满足下面两个条件的语境中的右值引用：</p><ol><li>类型推导的过程中会区分左值和右值；</li><li>会发生<strong>引用折叠（reference collapsing）</strong>。</li></ol><p>C++ 标准禁止直接声明 “引用的引用” ，但引用折叠不受此限制。当左值被传递给接受万能引用的函数模板时，会发生下面这样的状况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(w);    <span class="comment">// 调用 func 并传入左值，T 推导出的类型为 Widget&amp;</span></span><br></pre></td></tr></table></figure><p>代入<code>T</code>的推导类型，我们可以得到下面这样的具现化模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; &amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>出现了引用的引用！然而这并不违规，引用折叠的规则会把双重引用折叠成单个引用，规则如下：</p><blockquote><p>如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用。</p></blockquote><p>所以实际上的函数签名为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>引用折叠是使<code>std::forward</code>得以运作的关键，也是将左值或右值信息编码到万能引用形参<code>T</code>中的实现途径。<code>std::forward</code>的任务是，当且仅当编码在<code>T</code>中的信息表明传递的实参是右值，即<code>T</code>推导出的类型是个非引用类型时，对左值形参实施到右值的强制类型转换。它的基本实现大致是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设传递给函数<code>forward</code>的实参类型是左值<code>Widget</code>，则模板的具现化结果可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&amp;&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发生引用折叠后，生成的最终结果如下，可以看出左值类型并不会发生改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设传递给函数<code>forward</code>的实参类型是右值<code>Widget</code>，则模板的具现化结果可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发生引用折叠后，生成的最终结果如下，显然左值类型的形参会被强制转换为右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用折叠会在四种语境中出现：模板具现化，<code>auto</code>类型推断，创建和使用<code>typedef</code>和别名声明，以及<code>decltype</code>。</p><p><code>auto</code>类型推断中发生的引用折叠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;                       <span class="comment">// 变量（左值）</span></span><br><span class="line"><span class="function">Widget <span class="title">widgetFunction</span><span class="params">()</span></span>;        <span class="comment">// 返回右值的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;                  <span class="comment">// 推导出 Widget&amp; &amp;&amp; w1，引用折叠后为 Widget&amp; w1</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">widgetFunction</span>();   <span class="comment">// 推导出 Widget&amp;&amp; w1，不会发生引用折叠</span></span><br></pre></td></tr></table></figure><p>创建和使用<code>typedef</code>中发生的引用折叠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&lt;<span class="type">int</span>&amp;&gt; w; <span class="comment">// 用左值引用类型来具现化 Widget 模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具现化后得到 typedef int&amp; &amp;&amp; RvalueRefToT</span></span><br><span class="line"><span class="comment">// 引用折叠后为 typedef int&amp; RvalueRefToT</span></span><br></pre></td></tr></table></figure><p>最后一种会发生引用折叠的语境在<code>decltype</code>的运用中：如果在分析一个涉及<code>decltype</code>的类型时出现了引用的引用，则引用折叠会介入并将其消灭。</p><h3 id="条款-29：假定移动操作不存在、成本高、未被使用">条款 29：假定移动操作不存在、成本高、未被使用</h3><p>在下面几个情形下，C++11 的移动语义不会给你带来什么好处：</p><ul><li><strong>没有移动操作：</strong> 待移动的对象未能提供移动操作。因此，移动请求就变成了拷贝请求。</li><li><strong>移动未能更快：</strong> 待移动的对象虽然有移动操作，但并不比其拷贝操作更快。</li></ul><blockquote><p>移动操作不比拷贝操作更快的例子：<code>std::array</code>将数据直接存储在对象内，移动<code>std::array</code>需要逐个移动容器内的每个元素；开启了<strong>短字符串优化（small string optimization，SSO）</strong> 的<code>std::string</code>，它会将字符串存储在<code>std::string</code>对象的某个缓冲区内，而非使用堆上的内存。</p></blockquote><ul><li><strong>移动不可用：</strong> 移动本可以发生的情况下，要求移动操作不会抛出异常，但该操作未加上<code>noexcept</code>声明。</li><li><strong>源对象是左值：</strong> 只有右值可以作为移动操作的源。</li></ul><p>因此，我们应该为通用的代码假定移动操作不存在、成本高且未被使用。然而，对于已知的类型或支持移动语义的代码中，就不需要作上述假定，在你知道移动操作成本低廉的情况下，可以放心大胆地将拷贝操作替换为相对不那么昂贵的移动操作。</p><h3 id="条款-30：熟悉完美转发的失败情形">条款 30：熟悉完美转发的失败情形</h3><p>完美转发的含义是我们不仅转发对象，还转发其特征：类型，是左值还是右值，以及是否带有<code>const</code>和<code>volatile</code>限定符。出于此目的，我们会运用万能引用来将左、右值信息编码到类型中，而用于转发的函数自然也该是泛型的，它的标准形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使转发函数能接受任意数量的形参，使用可变参数模板也在我们的考虑范围内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;Ts&gt;(param)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若用相同实参调用<code>f</code>和<code>fwd</code>会执行不同的操作，则称<code>fwd</code>将实参完美转发到<code>f</code>失败。完美转发的失败情形源于模板类型推导失败，或推导出错误的类型。下面我们将了解会造成完美转发失败的典型例子。</p><p><strong>大括号初始值设定项（Braced initializers）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);         <span class="comment">// “&#123; 1, 2, 3 &#125;” 会隐式转换为 std::vector&lt;int&gt;</span></span><br><span class="line"><span class="built_in">fwd</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);       <span class="comment">// 无法通过编译！</span></span><br></pre></td></tr></table></figure><p>由于<code>fwd</code>的形参为被声明为<code>std::initializer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>&#123; 1, 2, 3 &#125;</code>出发来推导类型。既然无法推导出形参的类型，那么编译器也只能拒绝对<code>fwd</code>的调用。</p><p>我们可以通过先用<code>auto</code>声明一个局部变量，再传递给<code>fwd</code>来避免这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// il 的类型被推导为 std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">fwd</span>(il);                <span class="comment">// 没问题，将 il 完美转发给 f</span></span><br></pre></td></tr></table></figure><p><strong>0 和 NULL 作空指针</strong></p><p><strong>条款 8</strong> 中曾经说明过，当你试图将<code>0</code>或<code>NULL</code>作为空指针传递给模板时，类型推导就会发生错误，将实参推导为一个整型而非指针类型，结果不管是<code>0</code>还是<code>NULL</code>都不会作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或<code>NULL</code>。</p><p><strong>仅有声明的整型<code>static const</code>成员变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;  <span class="comment">// 仅提供 MinVals 的声明</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;                                          <span class="comment">// 未给出 MinVals 的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Widget::MinVals);                         <span class="comment">// 没问题，当作 “f(28)” 处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals);                       <span class="comment">// 可能无法通过链接</span></span><br></pre></td></tr></table></figure><p>一般而言，编译器会绕过<code>MinVals</code>缺少定义的事实，并用其值替换所有涉及到<code>MinVals</code>的地方，但并不会为其实际分配存储空间。这就导致如果我们尝试对<code>MinVals</code>实施取地址或对它进行引用，就会导致链接无法通过，这也就是为何不能将<code>Widget::MinVals</code>作为实参传递给<code>fwd</code>。</p><p>按照标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义。然而并不是所有实现都遵循了这个规定，对于一些编译器和链接器，你会发现将<code>MinVals</code>用于完美转发并不会产生错误，甚至对它取地址也不会。但为了代码的可移植性，还是应当重视此处所讲的规则，为<code>static const</code>成员变量提供定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::<span class="type">size_t</span> Widget::MinVals;  <span class="comment">// 在 Widget 的 .cpp 文件中</span></span><br></pre></td></tr></table></figure><p><strong>重载函数的名称和模板名称</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">// 或者 void f(int pf(int))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(processVal);          <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(processVal);        <span class="comment">// 错误！无法确定是哪个重载版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">workOnVal</span><span class="params">(T param)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(workOnVal);         <span class="comment">// 错误！无法确定是 workOnVal 的哪个实例</span></span><br></pre></td></tr></table></figure><p>当我们将<code>processVal</code>传递给<code>f</code>时，由于<code>f</code>的形参类型是已知的，编译器自然也知道它需要的是<code>processVal</code>的哪个重载版本；但纯粹的函数名称<code>processVal</code>并不包含类型信息，类型推导更是无从谈起，将它传递给<code>fwd</code>只会造成完美转发失败而已。</p><p>要让<code>fwd</code>接受重载函数的名称或模板名称，只能手动指定需要转发的哪个重载版本或模板实例。例如下面的做法就是合理的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ProcessFuncType = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line">ProcessFuncType processValPtr = processVal;     <span class="comment">// 指定了需要的 processVal 签名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(processValPtr);                             <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(<span class="built_in">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));   <span class="comment">// 也没问题</span></span><br></pre></td></tr></table></figure><p><strong>位域</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPv4Header</span> &#123;                 <span class="comment">// 用于表示 IPv4 头部的模型</span></span><br><span class="line">    std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">                  IHL:<span class="number">4</span>,</span><br><span class="line">                  DSCP:<span class="number">6</span>,</span><br><span class="line">                  ECN:<span class="number">2</span>,</span><br><span class="line">                  totalLength:<span class="number">16</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line">IPv4Header h;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength);                   <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength);                 <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure><p>C++ 标准规定：非常引用不得绑定到位域。位域是由机器字的若干任意部分组成的，但这样的实体是无法对其直接取地址的，无法将指针指向它，因此也无法对其进行引用。</p><blockquote><p>实际上常引用也不可能绑定到位域，它们绑定到的是 “常规” 对象（某种标准整型，例如<code>int</code>），其中拷贝了位域的值。</p></blockquote><p>将位域传递给转发函数的可能途径是制作一个副本，并以该副本调用转发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝位域值，使用的初始化形式参考条款 6</span></span><br><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(length);    <span class="comment">// 转发该副本</span></span><br></pre></td></tr></table></figure><h2 id="第六章：lambda-表达式">第六章：lambda 表达式</h2><hr><p>重点</p><p>**闭包：**能够访问其他·函数内部变量的函数</p><p><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数【operator()】中的可执行指令。</p><p>闭包可以拷贝</p><hr><p>在开始本章之前，需要理解几个基本的概念：</p><ul><li><strong>lambda 表达式（lambda expression）：</strong> 表达式的一种，它的基本写法如下所示：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> val)&#123; <span class="keyword">return</span> <span class="number">0</span> &lt; val &amp;&amp; val &lt; <span class="number">10</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>闭包（closure）：</strong> lambda 所创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。</li><li><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数中的可执行指令。</li></ul><blockquote><p><strong>lambda 表达式和闭包类存在于编译期，而闭包存在于运行期。</strong></p></blockquote><h3 id="条款-31：避免默认捕获模式">条款 31：避免默认捕获模式</h3><hr><p>按引用：可能导致空悬指针</p><p>按值：捕获指针也会导致相同的情况</p><p>静态对象，可以在lamdba表达式中使用，不能捕获。</p><p>捕获只能针对在创建 lambda 表达式的作用域内可见的非静态局部变量（包括形参）。</p><p><strong>要点</strong></p><ul><li>默认的按引用捕获可能导致悬空引用</li><li>默认的按值捕获也可能出现悬空指针（尤其是this指针的情况），并且它会产生误导，让人以为 lambda 是独立的</li></ul><hr><p><strong>C++11 中有两种默认捕获模式：按引用或按值。按引用捕获会导致闭包内包含指向局部变量的引用，或指向定义 lambda 的作用域内形参的引用，一旦由 lambda 所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会发生空悬：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;                                <span class="comment">// 元素为筛选函数的容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [&amp;](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; <span class="comment">// 危险！指向 divisor 的引用可能空悬</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换作用显式方式按引用捕获<code>divisor</code>，问题依旧会发生，但更容易看出 lambda 依赖于<code>divisor</code>的生命周期这一问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">    [&amp;divisor](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一种权宜之计是不使用容器来存放筛选函数，转而使用 C++11 的<code>std::all_of</code>对每个元素逐一进行判断。但如果将该 lambda 拷贝到其它闭包比<code>divisor</code>生命周期更长的语境中，则空悬引用的问题仍会发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithContainer</span><span class="params">(<span class="type">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ContElemT = <span class="keyword">typename</span> C::value_type;           <span class="comment">// 取得容器中的元素类型（参考条款 13）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> std::begin;</span><br><span class="line">    <span class="keyword">using</span> std::end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),   <span class="comment">// 判断是否所有元素都是 divisor 的倍数</span></span><br><span class="line">        [&amp;](<span class="type">const</span> ContElemT&amp; value)                     <span class="comment">// C++14 可以直接写成 const auto&amp; value</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，使用默认的按值捕获模式就足以解决问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">    [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但是默认的按值捕获模式也有其问题：默认的按值捕获极易受到空悬指针的影响（尤其是<code>this</code>指针），并且会误导人们认为 lambda 是独立的。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> divisor;    <span class="comment">// 用于 Widget 的 filters</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此处的 lambda 而言，<code>divisor</code>既不是局部变量，也不是形参，按理来讲是压根无法被捕获的。事实也确实如此，被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是<code>divisor</code>。对于编译器来说，<code>addFilter</code>的代码相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> currentObjectPtr = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [currentObjectPtr](<span class="type">int</span> value)</span><br><span class="line">        &#123; <span class="keyword">return</span> value % currentObjectPtr-&gt;divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了这一点，也就能理解 lambda 闭包的存活依赖于它含有的<code>this</code>指针副本所指向的<code>Widget</code>对象的生命周期。假如面临以下代码，空悬指针的问题将出现在我们的眼前：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;                    <span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();   <span class="comment">// 创建 Widget，std::make_unique 的使用参考条款 21</span></span><br><span class="line"></span><br><span class="line">    pw-&gt;<span class="built_in">addFilter</span>();                        <span class="comment">// 添加使用了 Widget::divisor 的筛选函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;                                           <span class="comment">// Widget 被销毁，filters 现在持有空悬指针！</span></span><br></pre></td></tr></table></figure><p>一种解决方法是将你想捕获的成员变量拷贝至局部变量中，之后再捕获该副本局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [divisorCopy](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++14 中，捕获成员变量的一种更好的方法是使用<strong>广义 lambda 捕获（generalized lambda capture，参考条款 32）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [divisor = divisor](<span class="type">int</span> value)  <span class="comment">// C++14: 将 divisor 拷贝入闭包并使用副本</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的按值捕获模式的另一个缺点是，它会使人们误认为闭包是独立的，与闭包外的数据变化相隔绝。但实际上并非如此，lambda 可能不仅依赖于局部变量和形参，还会依赖于<strong>静态存储期（static storage duration）对象</strong>，这样的对象可以在 lambda 中使用，但却无法被捕获。下面这个例子足以体现这一点会造成的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value)                      <span class="comment">// 未捕获任何东西！</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;    <span class="comment">// 引用上面的 static 对象</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ++divisor;                              <span class="comment">// 意外修改了 divisor</span></span><br><span class="line">                                            <span class="comment">// 导致每个 lambda 都出现新的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-32：使用初始化捕获将对象移入闭包">条款 32：使用初始化捕获将对象移入闭包</h3><hr><p>要点</p><ul><li>可以使用 C++14 的初始化捕获将对象移动到闭包中</li><li>在 C++11 中，可以通过自定义类或 std::bind 来模拟初始化捕获。</li></ul><hr><p>C++14 中新增的<strong>初始化捕获（init capture，又称广义 lambda 捕获）</strong>，可以让你指定：</p><ol><li>由 lambda 生成的闭包类中成员变量的名字。</li><li>一个用于初始化该成员变量的表达式。</li></ol><p>下面演示了如何使用初始化捕获将<code>std::unique_ptr</code>移入闭包内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidated</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isProcessed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isArchived</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();   <span class="comment">// 创建 Widget，std::make_unique 的使用参考条款 21</span></span><br><span class="line"></span><br><span class="line">...                                     <span class="comment">// 配置 *pw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">move</span>(pw)]        <span class="comment">// 使用 std::move(pw) 初始化闭包类的数据成员</span></span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;;</span><br></pre></td></tr></table></figure><p>如果经由<code>std::make_unique</code>创建的对象已具备被 lambda 捕获的合适状态，则闭包类成原对象可以直接由<code>std::make_unique</code>完成初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]</span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;;</span><br></pre></td></tr></table></figure><p>在初始化捕获的代码中，位于<code>=</code>左侧的是所指定的闭包类成员变量的名称，右侧的则是其初始化表达式。值得一提的是，<code>=</code>的左右两侧位于不同的作用域，左侧作用域就是闭包的作用域，而右侧作用域则与 lambda 定义所在的作用域相同。</p><p>在 C++11 中，我们虽然无法使用初始化捕获，但是可以依靠原理相同的手写类达到目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsValAndArch</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::unique_ptr&lt;Widget&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IsValAndArch</span><span class="params">(DataType&amp;&amp; ptr)</span>   <span class="comment">// std::move 的使用参考条款 25</span></span></span><br><span class="line"><span class="function">        : pw(std::move(ptr)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;               <span class="comment">// 编写仿函数</span></span><br><span class="line">        <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType pw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">IsValAndArch</span>(std::<span class="built_in">make_unique</span>&lt;Widget&gt;());</span><br></pre></td></tr></table></figure><p>如果你非要使用 lambda，按移动捕获也可以通过以下方法模拟：</p><ol><li>将需要捕获的对象移至<code>std::bind</code>所产生的函数对象中。</li><li>给予 lambda 一个指向想要 “捕获” 的对象的引用。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func =</span><br><span class="line">    std::<span class="built_in">bind</span>([](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data)   <span class="comment">// C++11 模拟初始化捕获</span></span><br><span class="line">              &#123; <span class="comment">/* 使用 data */</span> &#125;,</span><br><span class="line">              std::<span class="built_in">move</span>(data));</span><br></pre></td></tr></table></figure><p><code>std::bind</code>的第一个实参是个可调用对象，接下来的所有实参表示传给该对象的值。和 lambda 表达式类似，<code>std::bind</code>也会生成函数对象（原书中称其为<strong>绑定对象，bind object</strong>），其中含有传递给<code>std::bind</code>的所有实参的副本，其中左值实参执行的是拷贝构造，而右值实参执行的则是移动构造。因此，在此处用<code>std::move(data)</code>作为实参可以让<code>data</code>被移入绑定对象中，被 lambda 的左值引用形参所接受。</p><p>默认情况下，lambda 生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>限定符，它会导致是闭包类里的所有成员变量在 lambda 的函数体内都会带有<code>const</code>限定符。但是，绑定对象里通过移动构造得到的<code>data</code>副本却并不带有<code>const</code>限定符。因此，为了防止该<code>data</code>副本在 lambda 中被意外修改，我们会将其形参声明为常引用。但如果 lambda 在声明时带有<code>mutable</code>限定符，则闭包里的<code>operator()</code>就不再会带有<code>const</code>限定符，也不必再将形参声明为常引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func =</span><br><span class="line">    std::<span class="built_in">bind</span>([](std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="keyword">mutable</span></span><br><span class="line">              &#123; <span class="comment">/* 使用 data */</span> &#125;,</span><br><span class="line">              std::<span class="built_in">move</span>(data));</span><br></pre></td></tr></table></figure><p>回到之前的例子，使用 C++14 在闭包内创建<code>std::unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]</span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;;</span><br></pre></td></tr></table></figure><p>它在 C++11 中的模拟代码可以这样编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>([](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; pw)</span><br><span class="line">                      &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;,</span><br><span class="line">                      std::<span class="built_in">make_unique</span>&lt;Widget&gt;());</span><br></pre></td></tr></table></figure><h3 id="条款-33：对-auto-类型的形参使用-decltype-以对其实施-std-forward">条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</h3><hr><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">auto</span> f =[](auto&amp;&amp; param)&#123;returnfunc(normalize(std::forward&lt;decl<span class="keyword">type</span>(param)&gt;(param)));&#125;;</span><br></pre></td></tr></table></figure><p><strong>要点</strong><br>对 auto&amp;&amp; 参数使用 decltype 来进行 std::forward</p><hr><p>C++14 支持<strong>泛型 lambda（generic lambda）</strong>，可以在声明形参时使用<code>auto</code>，即闭包类中的<code>operator()</code>可以用模板实现。例如，给定以下 lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x)); &#125;;</span><br></pre></td></tr></table></figure><p>则闭包类的<code>operator()</code>实现大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCompilerGeneratedClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="type">const</span> </span>&#123;    <span class="comment">// auto 类型的返回值，参考条款 3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此处，lambda 总会传递左值给<code>normalize</code>，这对于一个会区别对待左、右值的<code>normalize</code>显然是不行的。如果想要保留实参的左、右值性，就需要将形参声明为万能引用（参考<strong>条款 24</strong>），并使用<code>std::forward</code>将其转发给<code>normalize</code>（参考<strong>条款 25</strong>）。这样的改造十分简单，唯一的问题是在 lambda 中，我们并没有可用的模板形参<code>T</code>，只能对要转发的形参使用<code>decltype</code>，以取得其类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; param) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>条款 28</strong> 说明了，使用<code>std::forward</code>的惯例是：用左值引用类型的模板形参来表明想要返回左值，用非引用类型的模板形参来表明想要返回右值。而在此处，如果<code>param</code>是左值，则<code>decltype(param)</code>会产生左值引用类型，这符合惯例；但如果<code>param</code>是右值，则<code>decltype(param)</code>会产生右值引用类型，不符合惯例的非引用，在这种情况下，<code>std::forward</code>将被具现化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&amp;&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于引用折叠的存在，<code>Widget&amp;&amp; &amp;&amp;</code>将被折叠为<code>Widget&amp;&amp;</code>，所以实际上生成的代码和使用非引用类型作为模板形参生成的版本并没有什么区别。综上所述，在此处使用<code>decltype(param)</code>并不会产生任何问题，这是个非常不错的结果。</p><p>C++14 的 lambda 也支持可变参数，只需稍加改动，就可以得到能接受多个参数的完美转发 lambda 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-34：优先选用-lambda，而非-std-bind">条款 34：优先选用 lambda，而非 std::bind</h3><p>之所以优先选用 lambda 而非 std::bind，最主要的原因是 lambda 具有更高的可读性。举个例子，假设我们有个函数用来设置警报声：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示时刻的类型</span></span><br><span class="line"><span class="keyword">using</span> Time = std::chrono::steady_clock::time_point;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Sound</span> &#123; Beep, Siren, Whistle &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示时长的类型</span></span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::steady_clock::duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在时刻 t，发出声音 s，持续时长 d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以编写一个 lambda，设置在一小时后发出警报并持续 30 秒，同时提供接口，以指定发出的声音：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;              <span class="comment">// 引入 C++14 中的字面量后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, s, <span class="number">30</span>s); <span class="comment">// C++11 需要用 hours 和 seconds 代替后缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们将尝试使用<code>std::bind</code>来编写相应的代码。下面的这段代码并不正确，但足以让我们发现<code>std::bind</code>的难用之处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;  <span class="comment">// 引入占位符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>占位符<code>_1</code>表示它在<code>std::bind</code>形参列表中的映射位置，在此处表示调用<code>setSoundB</code>时传入的第一个实参，会作为第二个实参传递给<code>setAlarm</code>。这显然已经不如 lambda 直观。</p><p>更重要的是上述代码所隐含的问题：调用时间的错误。在<code>std::bind</code>的调用中，<code>steady_clock::now() + 1h</code>作为实参被传递给了<code>std::bind</code>，而非<code>setAlarm</code>，这意味着该表达式会在调用<code>std::bind</code>的时刻计算出具体值，而非调用<code>setAlarm</code>的时刻，这与我们的意图显然不符。想要解决这个问题，就要嵌套第二层<code>std::bind</code>的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), <span class="comment">// C++11 无法省略 std::plus&lt;steady_clock::time_point&gt;()</span></span><br><span class="line">                                     steady_clock::<span class="built_in">now</span>(),</span><br><span class="line">                                     <span class="number">1</span>h),</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>另一个<code>std::bind</code>不如 lambda 的例子是重载。假如有个重载版本会接受第四个形参，用于指定警报的音量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Volume</span> &#123; Normal, Loud, LoudPlusPlus &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d, Volume v)</span></span>;</span><br></pre></td></tr></table></figure><p>原来的 lambda 仍会正常运作，而<code>std::bind</code>会立刻发生错误，因为它只有函数名，并不知道要调用哪个重载版本的函数。为使得<code>std::bind</code>的调用能通过编译，必须将<code>setAlarm</code>强制转换到适当的函数指针类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SetAlarm3ParamType = <span class="built_in">void</span> (*)(Time t, Sound s, Duration d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(<span class="built_in">static_cast</span>&lt;SetAlarm3ParamType&gt;(setAlarm),</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>下面是一个更极端的例子，演示了<code>std::bind</code>到底有多晦涩：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 版本（C++14）</span></span><br><span class="line"><span class="keyword">auto</span> betweenL = [lowVal, highVal](<span class="type">const</span> <span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">    <span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::bind 版本（C++14）</span></span><br><span class="line"><span class="keyword">auto</span> betweenB = std::<span class="built_in">bind</span>(std::logical_and&lt;&gt;(),</span><br><span class="line">                          std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), lowVal, std::placeholders::_1),</span><br><span class="line">                          std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), std::placeholders::_1, highVal),)</span><br></pre></td></tr></table></figure><p><code>std::bind</code>总是拷贝其实参，调用时需要借助<code>std::ref</code>来达到按引用存储实参的目的，这一点同样也不如 lambda 来得明确：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compressRateL = [&amp;w](CompLevel lev) &#123; <span class="keyword">return</span> <span class="built_in">compress</span>(w, lev); &#125;;</span><br><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, std::<span class="built_in">ref</span>(w), std::placeholders::_1);</span><br></pre></td></tr></table></figure><p>除了可读性以外，编译器通常能更好地以内联优化 lambda 所调用的函数，而对于使用函数指针的<code>std::bind</code>则很难做到，这会导致使用 lambda 有可能会生成比使用<code>std::bind</code>运行得更快的代码。</p><p>在 C++11 中，<code>std::bind</code>仅在两个受限的场合还有使用的理由：</p><ol><li>移动捕获（参考<strong>条款 32</strong>）；</li><li>多态函数对象（这在 C++14 中可以被泛型 lambda 轻易实现）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PolyWidget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PolyWidget pw;</span><br><span class="line"><span class="keyword">auto</span> boundPW = std::<span class="built_in">bind</span>(pw, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用不同类型的实参调用 PolyWidget::operator()</span></span><br><span class="line"><span class="built_in">boundPW</span>(<span class="number">1930</span>);</span><br><span class="line"><span class="built_in">boundPW</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">boundPW</span>(<span class="string">&quot;Rosebud&quot;</span>); <span class="comment">// 原书作者玩的《公民凯恩》梗（应该是吧）</span></span><br></pre></td></tr></table></figure><h2 id="第七章：并发-API">第七章：并发 API</h2><h3 id="条款-35：优先选用基于任务而非基于线程的程序设计">条款 35：优先选用基于任务而非基于线程的程序设计</h3><p>如果你想以异步方式执行函数<code>doAsyncWork</code>，你可以选择<strong>基于线程（thread-based）</strong> 的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;</span><br></pre></td></tr></table></figure><p>也可以将<code>doAsyncWork</code>传递给<code>std::async</code>，这是<strong>基于任务（task-based）</strong> 的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork); <span class="comment">// 需要 #include &lt;future&gt;</span></span><br></pre></td></tr></table></figure><p>“线程” 在带有并发的 C++ 软件中有三重含义：</p><ul><li><strong>硬件线程（hardware threads）</strong> 是实际执行计算的线程。现代计算机架构会为每个 CPU 内核提供一个或多个硬件线程。</li><li><strong>软件线程（software threads，也称系统线程）</strong> 是操作系统（或嵌入式系统）用于实现跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程比硬件线程要多，因为当一个软件线程被阻塞时，运行其它未阻塞线程能够提高吞吐率。</li><li><strong><code>std::thread</code></strong> 是 C++ 进程中的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表现为 “null” 句柄，表示其无软件线程，可能的原因有：处于默认构造状态（没有要执行的函数），被移动了（被移动的目标对象成为了该软件线程的句柄），被联结（join）了（函数已执行结束），被分离（detach）了（与其软件线程的连接被切断）。</li></ul><p>软件线程和硬件线程都是有限的。如果你试图创建多于系统能提供的数量的线程，就会抛出<code>std::system_error</code>异常，即使待执行的函数带有<code>noexcept</code>限定符也一样。如果非阻塞的软件线程数量超过了硬件线程数量，就会产生<strong>资源超额（oversubscription）</strong> 问题，此时线程调度器会将软件线程的 CPU 时间切片，分配到硬件线程之上。当一个软件线程的时间片执行结束，就会让给另一个软件线程，并产生上下文切换。在这种情况下，新的软件线程几乎不能命中 CPU 缓存，同时还会污染为旧线程所准备的数据（旧线程很可能还会再被调度到同一内核上运行），这会造成高昂的线程管理开销。</p><blockquote><p>避免资源超额很困难，因为软件线程和硬件线程的最佳比例取决于软件线程的执行频率，那是动态改变的，例如一个程序从 IO 密集型变成计算密集型，会使执行频率发生改变。而且该比例还依赖于上下文切换的开销以及软件线程对于 CPU 缓存的使用效率。计算机本身的架构也会对其具体细节产生很大的影响。</p></blockquote><p>比起基于线程，基于任务的设计能够减轻手动管理线程的艰难，而且它提供了一种很自然的方式（藉由<code>get</code>函数），让你检查异步执行函数的结果（即返回值或异常）。</p><p>虽然说了这么多，但仍有以下几种情况，直接使用线程会更合适：</p><ul><li><strong>你需要访问非常底层的线程 API。</strong> C++ 并发 API 通常会采用特定平台的低级 API 来实现，例如 pthread 和 Windows 线程库，它们提高的 API 比 C++ 更丰富。为了访问底层的线程 API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::async</code>的返回值<code>std::future</code>则没有该功能。</li><li><strong>你需要且有能力为你的应用优化线程的使用。</strong> 例如在完成性能分析的情况下为专一硬件平台开发应用。</li><li><strong>你需要实现实现超越 C++ 并发 API 的线程技术。</strong> 例如为 C++ 未提供线程池的平台实现线程池。</li></ul><h3 id="条款-36：如果异步是必要的，则指定-std-launch-async">条款 36：如果异步是必要的，则指定 std::launch::async</h3><p>在调用<code>std::async</code>时，有以下两种启动策略可以选择：</p><ul><li><code>std::launch::async</code>启动策略意味着函数必须以异步方式在另一条线程上执行。</li><li><code>std::launch::deferred</code>启动策略意味着函数会被推迟到<code>std::async</code>所返回的<code>std::future</code>的<code>get</code>或<code>wait</code>函数得到调用时才执行（这是个简化说法，关键点其实是<code>std::future</code>引用的共享状态，参考<strong>条款 38</strong>）。在那之后，调用<code>get</code>或<code>wait</code>的线程将会被阻塞，直至函数执行结束为止。如果<code>get</code>或<code>wait</code>都没得到调用，则函数将不会被执行。</li></ul><p><code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行，即下面两个调用是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut2 = std::<span class="built_in">async</span>(std::launch::async | std::launch::deferred,</span><br><span class="line">                       f);</span><br></pre></td></tr></table></figure><p>这种弹性使得<code>std::async</code>和标准库的线程管理组件能够承担起线程的创建和销毁，避免资源超额，以及负载均衡的责任。但也会带来一些意料之外的问题：</p><ul><li>无法预知<code>f</code>是否会与调用<code>std::async</code>的线程并发执行，它也可能会被推迟执行。</li><li>无法预知<code>f</code>是否会在与调用<code>get</code>和<code>wait</code>函数的线程不同的线程上执行。</li><li>无法预知<code>f</code>在读或写此<strong>线程本地存储（thread-local，TLS）</strong> 时，会在哪个线程的本地存储上完成操作，这会影响到<code>thread_local</code>变量的使用。</li><li>就连<code>f</code>是否会被执行这种基本的事情都无法预知。</li></ul><p>延迟启动策略还会影响以超时为条件的基于 wait 的循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready) &#123;  <span class="comment">// 循环至 f 完成执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 若 f 被推迟执行，则 fut.wait_for 返回 std::future_status::deferred</span></span><br><span class="line">    <span class="comment">// 循环永远不会被终止！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这个问题的方法很简单，只需要确认任务是否被推迟，可以通过调用一个基于超时的函数（例如<code>wait_for</code>）并检查其返回值来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fut.<span class="built_in">wait_for</span>(<span class="number">0</span>s) == std::future_status::deferred) &#123; <span class="comment">// 如果任务被推迟了</span></span><br><span class="line">    ... <span class="comment">// 调用 fut 的 wait 或 get，以同步方式执行 f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                                  <span class="comment">// 如果任务未被推迟</span></span><br><span class="line">    <span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready) &#123;</span><br><span class="line">        ... <span class="comment">// 不断去做并发任务，直至 f 完成执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// fut 已经就绪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，如果需要执行的任务满足以下条件，就可以使用<code>std::async</code>的默认启动策略：</p><ol><li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li><li>读或写哪个线程的<code>thread_local</code>变量并无影响。</li><li>保证在<code>std::async</code>返回的<code>std::future</code>对象上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li><li>使用<code>wait_for</code>或<code>wait_until</code>的代码会考虑到任务被推迟的可能性。</li></ol><p>如果其中任何一个条件不满足，就需要确保任务以异步方式执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, f);</span><br></pre></td></tr></table></figure><p>也可以编写一个辅助函数来自动执行<code>std::async</code>的异步启动策略：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span> std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Ts...)&gt;::type&gt; <span class="comment">// C++14 可以直接用 auto 推导返回值类型</span></span><br><span class="line"><span class="built_in">reallyAsync</span>(F&amp;&amp; f, Ts&amp;&amp;... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                      std::forward&lt;F&gt;(f),</span><br><span class="line">                      std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用于获取可调用对象返回值类型的<code>std::result_of</code>在 C++17 后被弃用，其替代品为<code>std::invoke_result</code>。</p></blockquote><h3 id="条款-37：使-std-thread-对象在所有路径皆不可联结">条款 37：使 std::thread 对象在所有路径皆不可联结</h3><p>当<code>std::thread</code>处于可联结的状态时，它对应于正在运行或可能将要运行的底层执行线程，这包括正在等待调度的或者被阻塞的线程，以及运行结束的线程。</p><p>以下几种<code>std::thread</code>对象处于不可联结的状态：</p><ul><li>默认构造的<code>std::thread</code>。</li><li>已移动的<code>std::thread</code>。</li><li>已联结（join）的<code>std::thread</code>。</li><li>已分离（detach）的<code>std::thread</code>。</li></ul><p>当<code>std::thread</code>执行析构时，若其处于可联结状态，就会导致程序终止运行（通常会调用<code>std::abort</code>）。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10&#x27;000&#x27;000</span>;             <span class="comment">// C++14 的单引号数字分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter, <span class="type">int</span> maxVal = tenMillion)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;filter, maxVal, &amp;goodVals] &#123;    <span class="comment">// 遍历 goodVals</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">                      &#123; <span class="keyword">if</span> (filter(i)) goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">native_handle</span>();                    <span class="comment">// 使用 t 的原生句柄来设定线程的优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">conditionAreSatisfied</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();                                   <span class="comment">// 让 t 结束运行</span></span><br><span class="line">        <span class="built_in">performComputation</span>(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                                <span class="comment">// 计算已实施</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                                   <span class="comment">// 计算未实施</span></span><br><span class="line">&#125;                                                   <span class="comment">// 此处析构 std::thread 会导致程序终止</span></span><br></pre></td></tr></table></figure><p>标准委员会并没有选择让<code>std::thread</code>在销毁时，隐式执行<code>join</code>或<code>detach</code>，因为这带来的问题会比直接让程序终止运行还要严重：</p><ul><li><strong>隐式<code>join</code></strong> 会使<code>std::thread</code>的析构函数等待底层异步线程执行完毕。这听上去很合理，但却可能导致难以追踪的性能异常。例如，即使<code>conditionAreSatisfied</code>已经返回<code>false</code>了，<code>doWork</code>仍然会继续执行遍历操作，这是违反直觉的。</li><li><strong>隐式<code>detach</code></strong> 会使<code>std::thread</code>的析构函数分离<code>std::thread</code>对象和底层执行线程之间的连接，而该底层执行线程会继续运行。这会导致更要命的调试问题。假如<code>conditionAreSatisfied</code>返回了<code>false</code>，则<code>doWork</code>也会直接返回，同时销毁局部变量并弹出栈帧。但线程仍然在<code>doWork</code>的调用点继续运行，并导致栈帧上的内存被意外修改，</li></ul><p>我们可以编写一个 RAII 类，并让调用者自行选择在销毁时为<code>std::thread</code>调用<code>join</code>还是<code>detach</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">DtorAction</span> &#123; join, detach &#125;;     <span class="comment">// 关于枚举类，参考条款 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a)   <span class="comment">// 对 t 执行操作 a</span></span><br><span class="line">        : <span class="built_in">action</span>(action), <span class="built_in">t</span>(std::<span class="built_in">move</span>(t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>() &#123;</span><br><span class="line">        <span class="comment">// 先校验 t 是否处于可联结状态</span></span><br><span class="line">        <span class="comment">// 对不可联结的 std::thread 调用 join 或 detach 是未定义行为</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">                t.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;         <span class="comment">// 支持移动操作</span></span><br><span class="line">    ThreadRAII&amp; <span class="keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;            <span class="comment">// 返回底层的 std::thread 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DtorAction action;</span><br><span class="line">    std::thread t;                              <span class="comment">// 使 t 最后被初始化，确保它可以安全访问其它成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>不需要担心在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，有另一个线程会让<code>t</code>变得不可联结。因为<code>std::thread</code>对象只能通过调用成员函数来从可联结状态转换为不可联结状态，而当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其它线程调用该对象的成员函数。一般地，若要在一个对象上同时调用两个成员函数，只有当所有这些函数都带有<code>const</code>限定符时才安全（参考<strong>条款 16</strong>）。</p></blockquote><p>在<code>doWork</code>函数的代码中，可以这样使用<code>ThreadRAII</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter, <span class="type">int</span> maxVal = tenMillion)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t</span><span class="params">(std::thread([&amp;filter, maxVal, &amp;goodVals] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">                                 &#123; <span class="keyword">if</span> (filter(i)) goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                             &#125;),</span></span></span><br><span class="line"><span class="params"><span class="function">                 ThreadRAII::DtorAction::join)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">get</span>().<span class="built_in">native_handle</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">conditionAreSatisfied</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">get</span>().<span class="built_in">join</span>();</span><br><span class="line">        <span class="built_in">performComputation</span>(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-38：注意不同线程句柄的析构行为">条款 38：注意不同线程句柄的析构行为</h3><p>future 位于通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常以异步方式运行）将其计算所得的结果写入信道（通常经过<code>std::promise</code>对象），而调用者则使用 future 来读取该结果。</p><p>但被调用者的结果要存储在哪里呢？既不能存储在被调用者的<code>std::promise</code>对象中，因为它是个局部对象，在被调用者执行结束后会被销毁；也不能存储在调用者的 future 中，因为<code>std::future</code>可能会被用来创建<code>std::shared_future</code>，而后者会导致原始<code>std::future</code>析构之后被多次拷贝，但被调用者的结果并不能保证一定可以被拷贝，很难做到使它与最后一个指向它的 future 生命周期一样长。</p><p>因此该结果会被存储在位于两者外部的某个位置，这个位置称为<strong>共享状态（shared state）</strong>，通常用堆上的对象来表示，但是其类型、接口和实现皆未在标准中指定。我们可以把调用者，被调用者以及共享状态之间的关系用下图来表示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/2.png" alt=""></p><p>共享状态的存在非常重要，因为 future 对象的析构行为取决于与其关联的共享状态。具体来说就是：</p><ul><li>常规的 future 对象在析构时仅会析构该 future 的成员变量。这相当于对底层执行线程执行了隐式<code>detach</code>。</li><li>引用了共享状态（使用<code>std::async</code>启动未延迟任务时创建的）的最后一个 future 对象的析构函数将会被阻塞住，直至该任务结束。这相当于对正在运行<code>std::async</code>所创建任务的线程执行了隐式<code>join</code>。</li></ul><p>也就是说，只有在满足下列条件时，future 的非常规析构行为才会被触发：</p><ol><li>future 所引用的共享状态是在调用<code>std::async</code>时创建的；</li><li>该任务执行异步启动策略，即<code>std::launch::async</code>（参考<strong>条款 36</strong>）；</li><li>该 future 是最后一个引用了该共享状态的 future。</li></ol><p>future 的 API 没有提供任何办法判断它引用的共享状态是否诞生于<code>std::async</code>的调用，因此任意给定一个 future 对象，我们没有办法判断它是否会在析构函数中阻塞。这可能会导致一些意外的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该容器的析构函数可能会发生阻塞</span></span><br><span class="line"><span class="comment">// 因为它持有 future 可能会有一个或多个</span></span><br><span class="line"><span class="comment">// 满足触发非常规析构行为的条件</span></span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futs;    <span class="comment">// 关于 std::future&lt;void&gt;，参考条款 39</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                          <span class="comment">// Widget 对象的析构函数可能会发生阻塞</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_future&lt;<span class="type">double</span>&gt; fut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>std::packaged_task</code>也能创建出共享对象，但是其衍生的 future 都会执行常规的析构行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in">int</span>()&gt;       <span class="comment">// 给 calcValue 加上包装</span></span><br><span class="line">    <span class="built_in">pt</span>(calcValue);                  <span class="comment">// 使之能以异步方式执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>();     <span class="comment">// 取得 pt 的 future</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>;   <span class="comment">// std::packaged_task 是只移类型</span></span><br><span class="line"></span><br><span class="line">    ...                             <span class="comment">// 析构 std::thread（参考条款 37）</span></span><br><span class="line">&#125;                                   <span class="comment">// 以常规方式析构 future 对象 fut</span></span><br></pre></td></tr></table></figure><h3 id="条款-39：考虑对一次性事件通信使用-void-的-futures">条款 39：考虑对一次性事件通信使用 void 的 futures</h3><p>有的时候，让一个任务能够在发生了特定事件后，通知另一个异步运行的任务，会是很有用的。为了实现这种简单的事件通信，使用条件变量会是一个显而易见的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;             <span class="comment">// 事件的条件变量</span></span><br><span class="line">std::mutex m;                           <span class="comment">// 配合 cv 使用的互斥量</span></span><br><span class="line"></span><br><span class="line">...                                     <span class="comment">// 检测事件</span></span><br><span class="line">cv.<span class="built_in">notify_one</span>();                        <span class="comment">// 通知反应任务，对多个任务使用 notify_all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                                     <span class="comment">// 准备作出反应</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// 为互斥量加锁</span></span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk);                        <span class="comment">// 等待通知到来</span></span><br><span class="line">    ...                                 <span class="comment">// 针对事件作出反应</span></span><br><span class="line">&#125;                                       <span class="comment">// 通过 lk 的析构函数为 m 解锁</span></span><br><span class="line">...                                     <span class="comment">// 继续等待反应</span></span><br></pre></td></tr></table></figure><p>这种途径会导致以下几个问题：</p><ul><li><strong>代码异味（code smell）：</strong> 虽然代码能够运行，但总感觉哪里不太对劲。此处对互斥量的使用似乎有些多余，互斥量是用于控制共享数据访问的，但检测和反应任务之间大可以根本不需要这种介质。</li><li>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量，则反应任务将会失去响应。</li><li>反应任务的<code>wait</code>语句无法应对<strong>虚假唤醒（spurious wakeups）</strong>，即使条件变量没有得到通知，针对该条件变量等待的代码也有可能被唤醒。如果反应线程可以确认它所等待的事件是否已经发生，那么我们可以通过将 lambda 传递给<code>wait</code>来处理这种情况：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.<span class="built_in">wait</span>(lk, [] &#123; <span class="keyword">return</span> 事件是否真的已经发生; &#125;);</span><br></pre></td></tr></table></figure><p>基于 flag 的设计可以避免上述问题，但这一设计基于轮询而非阻塞，会对 CPU 核心产生额外的性能消耗：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">// 共享的 bool flag</span></span><br><span class="line">                                <span class="comment">// 关于 std::atomic，参考条款 40</span></span><br><span class="line">...                             <span class="comment">// 检测事件</span></span><br><span class="line">flag = <span class="literal">true</span>;                    <span class="comment">// 通知反应任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                             <span class="comment">// 准备作出反应</span></span><br><span class="line"><span class="keyword">while</span> (!flag);                  <span class="comment">// 等待事件</span></span><br><span class="line">...                             <span class="comment">// 针对事件作出反应</span></span><br></pre></td></tr></table></figure><p>条件变量可以和 flag 一起使用，但这样的通信机制设计看起来不太自然：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;                 <span class="comment">// 同前</span></span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;                           <span class="comment">// 非 std::atomic 对象</span></span><br><span class="line"></span><br><span class="line">...                                         <span class="comment">// 检测事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;       <span class="comment">// 为 m 加锁</span></span><br><span class="line">    flag = <span class="literal">true</span>;                            <span class="comment">// 通知反应任务（第一部分）</span></span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();                            <span class="comment">// 通知反应任务（第二部分）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                                         <span class="comment">// 准备作出反应</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;     <span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, [&amp;flag] &#123; <span class="keyword">return</span> flag; &#125;);  <span class="comment">// 使用 lambda 应对虚假唤醒</span></span><br><span class="line">    ...                                     <span class="comment">// 针对事件作出反应</span></span><br><span class="line">&#125;</span><br><span class="line">...                                         <span class="comment">// 继续等待反应</span></span><br></pre></td></tr></table></figure><p>另外一种方法是摆脱条件变量，互斥量和 flag，让反应任务去等待检测任务设置的 future。这种设计简单易行，检测任务有一个<code>std::promise</code>对象，反应任务有对应的 future。当检测任务发现它查找的事件已经发生时，它会设置<code>std::promise</code>对象；与此同时，反应任务调用<code>wait</code>以等待它的 future。由于在此处我们并不会真正向信道发送任何数据，所以对于<code>std::promise</code>、<code>std::future</code>和<code>std::shared_future</code>的模板类型形参，都只需使用<code>void</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line">...                     <span class="comment">// 检测事件</span></span><br><span class="line">p.<span class="built_in">set_value</span>();          <span class="comment">// 通知反应任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                     <span class="comment">// 准备作出反应</span></span><br><span class="line">p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();  <span class="comment">// 等待 p 对应的 future</span></span><br><span class="line">...                     <span class="comment">// 针对事件作出反应</span></span><br></pre></td></tr></table></figure><p>这种手法有两个最大的局限性：</p><ul><li><code>std::promise</code>和 future 之间依赖共享状态，而共享状态会带来在堆上分配和回收空间的成本。</li><li><code>std::promise</code>对象只能设置一次，这意味着该手法只能应用于一次性通信的情况。</li></ul><p>假如你想创建多个能暂停一次的线程，使用<code>void</code> future 手法就是合理的选择。代码演示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sf = p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();                   <span class="comment">// sf 的类型是 std::shared_future&lt;void&gt;</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; vt;                        <span class="comment">// 反应任务的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadsToRun; ++i) &#123;</span><br><span class="line">        vt.<span class="built_in">emplace_back</span>([sf] &#123; sf.<span class="built_in">wait</span>(); <span class="built_in">react</span>(); &#125;);  <span class="comment">// sf 局部副本之上的 wait</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...                                                 <span class="comment">// 若在此处抛出异常，则 detect 会失去响应！</span></span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">set_value</span>();                                      <span class="comment">// 让所有线程取消暂停</span></span><br><span class="line"></span><br><span class="line">    ...                                                 <span class="comment">// 完成其它工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;                                <span class="comment">// 把所有线程设为不可联结的状态</span></span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-40：对并发使用-std-atomic，对特殊内存使用-volatile">条款 40：对并发使用 std::atomic，对特殊内存使用 volatile</h3><p><code>std::atomic</code>可以保证它提供的操作被其它线程视为具有原子性，它产生的效果和受到互斥锁保护的操作类似，但是通常<code>std::atomic</code>的原子操作是通过特定的机器指令实现的，这比锁的实现更高效。考虑以下应用了<code>std::atomic</code>的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 将 ai 初始化为 0</span></span><br><span class="line">ai = <span class="number">10</span>;                <span class="comment">// 原子地将 ai 设为 10</span></span><br><span class="line">std::cout &lt;&lt; ai;        <span class="comment">// 原子地读取 ai 地值</span></span><br><span class="line">++ai;                   <span class="comment">// 原子地将 ai 自增为 11</span></span><br><span class="line">--ai;                   <span class="comment">// 原子地将 ai 自减为 10</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在<code>std::cout &lt;&lt; ai</code>语句中，<code>std::atomic</code>仅能保证对于<code>ai</code>的读取操作具有原子性，而不能保证整条语句都具有原子性，在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>之间，可能会有别的线程修改了<code>ai</code>的值，但这对使用按值传参的<code>operator&lt;&lt;</code>并没有什么影响。</p><p><code>ai</code>的自增和自减操作是<strong>读取-修改-写入（read-modify-write，RWM）</strong> 操作，<code>std::atomic</code>能确保它们整体以原子方式执行。这是<code>std::atomic</code>最重要的特性之一：<code>std::atomic</code>对象之上的所有成员函数都能被其它线程视为原子性的。</p><p><code>std::atomic</code>在 RWM 上具有的优势与<code>volatile</code>相比十分明显：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ac</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// atomic counter</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">vc</span><span class="params">(<span class="number">0</span>)</span></span>;     <span class="comment">// volatile counter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在两个同时运行的线程中各自执行自增操作 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 1</span></span><br><span class="line">++ac;</span><br><span class="line">++vc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line">++ac;</span><br><span class="line">++vc;</span><br></pre></td></tr></table></figure><p>在两个执行结束后，<code>ac</code>的值一定为 2，而<code>vc</code>却不一定，数据竞争导致它的最终结果实际上是无法预测的，下面是一种可能的情况：</p><ol><li>线程 1 读取<code>vc</code>的值为 0；</li><li>线程 2 读取<code>vc</code>的值仍为 0；</li><li>线程 1 将读取的值 0 自增为 1，写入<code>vc</code>；</li><li>线程 2 也将读取的值 0 自增为 1，写入<code>vc</code>；</li><li><code>vc</code>最终的值为 1。</li></ol><p>除了 RWM 以外，<code>std::atomic</code>还在确保<strong>顺序一致性（sequential consistency）</strong> 上具有优势，这种一致性是它默认采用的（尽管 C++ 还支持其它的一致性模型，但它们的安全性无法得到保证），它规定：在源代码中，<strong>任何位于<code>std::atomic</code>变量的写入操作之前的代码不得发生于写入操作之后</strong>。使用<code>std::atomic</code>可以保证以下代码中的赋值语句不会进行重新排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();   <span class="comment">// 计算出值</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;                        <span class="comment">// 通知其它任务，值已可用</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>std::atomic</code>，语句的顺序可能会被编译器或底层硬件重新排列，以使得代码运行得更快：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新排序后的结果</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();</span><br></pre></td></tr></table></figure><p><code>std::atomic</code>是只移类型，因此以下代码无法通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line">y = x;</span><br></pre></td></tr></table></figure><p>正确的方式是调用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>来以原子方式读取和写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">y</span><span class="params">(x.load())</span></span>;</span><br><span class="line">y.<span class="built_in">store</span>(x.<span class="built_in">load</span>());</span><br></pre></td></tr></table></figure><p>尽管在很多时候<code>load</code>和<code>store</code>并不是必要的，但是有些开发者还是很喜欢使用它们，因为这样做可以在代码中明确强调所使用的变量并非常规。这在很大程度上是一个代码风格的问题。</p><p><code>volatile</code>是用来处理特殊内存的工具，它会被用在读写操作不应该被优化的内存上。一般来讲，编译器会为常规内存的冗余读取和写入自动执行优化，例如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 读取 x</span></span><br><span class="line">y = x;      <span class="comment">// 再次读取 x</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;     <span class="comment">// 写入 x</span></span><br><span class="line">x = <span class="number">20</span>;     <span class="comment">// 再次写入 x</span></span><br></pre></td></tr></table></figure><p>在经过优化后就能变成十分精简的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 读取 x</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;     <span class="comment">// 写入 x</span></span><br></pre></td></tr></table></figure><p>但对于特殊内存，我们可能不想要编译器去执行这种优化。例如用于内存映射 I/O 的内存，这种内存的位置实际上会被用于与外部设备通信，而非用于读取或写入常规内存。这时，<code>volatile</code>就能派上用场：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x; <span class="comment">// 以 volatile 声明 x</span></span><br><span class="line">...             <span class="comment">// 初始化 x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">// 读取 x</span></span><br><span class="line">y = x;          <span class="comment">// 再次读取 x（不会被优化掉）</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;         <span class="comment">// 写入 x（不会被优化掉）</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">// 再次写入 x</span></span><br></pre></td></tr></table></figure><p><code>std::atomic</code>和<code>volatile</code>用于不同的目的，它们甚至可以一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> std::atomic&lt;<span class="type">int</span>&gt; vai;  <span class="comment">// 针对 vai 的操作具有原子性</span></span><br><span class="line">                                <span class="comment">// 并且不会被优化掉</span></span><br></pre></td></tr></table></figure><h2 id="第八章：微调">第八章：微调</h2><h3 id="条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递">条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</h3><p>为了实现对传入函数的左值实参执行拷贝，对右值实参执行移动，我们一共有以下三种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">// 对左值和右值分别重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">// 使用万能引用</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">// 方法三：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">// 按值传递参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++98 中，按值传递的形参总会通过拷贝构造函数创建，但在 C++11 后，形参仅在传入左值时才会被拷贝构造，而如果传入的是个右值，它会被移动构造。</p><p>对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码。</p><p>对于不可拷贝的形参，由于它的拷贝构造函数已被禁用，我们也不需要为其左值类型的实参提供支持，只需要编写一个接受右值引用的版本就行了。考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和对应的 setter，而<code>std::unique_ptr</code>是个只移类型，所以我们只需要编写单个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPtr</span><span class="params">(std::unique_ptr&lt;std::string&gt;&amp;&amp; ptr)</span> </span>&#123;</span><br><span class="line">        p = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;std::string&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w.<span class="built_in">setPtr</span>(std::<span class="built_in">make_unique</span>&lt;std::string&gt;(<span class="string">&quot;Modern C++&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用按值传参的前提是形参移动的成本足够低廉，因为按值传参会比按引用传参多一次额外的移动操作，如果这个前提不成立，那么执行不必要的移动就与执行不必要的拷贝没有什么区别。另外，你应当只对一定会被拷贝的形参考虑使用按值传参，以下代码就是一个反例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newName.<span class="built_in">length</span>() &gt;= minLen) &amp;&amp;</span><br><span class="line">            (newName.<span class="built_in">length</span>() &lt;= maxLen)) &#123;</span><br><span class="line">            names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即使没有向<code>names</code>添加任何内容，该函数也会造成构造和析构<code>newName</code>的开销，而如果使用按引用传参，就可以避免这笔开销。</p><p>通过构造拷贝形参的开销可能会比通过赋值拷贝形参要大得多。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Password</span><span class="params">(std::string pwd)</span>  <span class="comment">// 按值传参</span></span></span><br><span class="line"><span class="function">        : text(std::move(pwd)) &#123;</span>&#125;       <span class="comment">// 对 text 进行构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string newPwd)</span> </span>&#123; <span class="comment">// 按值传参</span></span><br><span class="line">        text = std::<span class="built_in">move</span>(newPwd);       <span class="comment">// 对 text 进行赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;                   <span class="comment">// 表示密码</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">initPwd</span><span class="params">(<span class="string">&quot;Supercalifragilisticexpialidocious&quot;</span>)</span></span>;  <span class="comment">// 旧密码</span></span><br><span class="line"><span class="function">Password <span class="title">p</span><span class="params">(initPwd)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">std::string newPassword = <span class="string">&quot;Beware the Jabberwock&quot;</span>;          <span class="comment">// 新密码</span></span><br><span class="line">p.<span class="built_in">changeTo</span>(newPassword);</span><br></pre></td></tr></table></figure><p>在此处，旧密码比新密码更长，因此不需要进行任何内存分配和回收。如果采用重载的方式，可能就不会发生任何动态内存管理操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string&amp; newPwd)</span> </span>&#123;    <span class="comment">// 对左值的重载</span></span><br><span class="line">        text = newPwd;                      <span class="comment">// 若 text.capacity() &gt;= newPwd.size()</span></span><br><span class="line">                                            <span class="comment">// 则可以复用 text 的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此情形下，使用按值传参就会造成额外的内存分配和回收的开销，这可能会比移动<code>std::string</code>的开销高出几个数量级。</p><p>综上所述，通过赋值拷贝一个形参进行按值传参所造成的额外开销，取决于传参的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标所占的内存是否至少和赋值源所占的内存一样大。对于<code>std::string</code>来说，开销还取决于实现是否使用了 SSO（参考<strong>条款 29</strong>），如果是，那么要赋的值是否匹配 SSO 缓冲区。</p><p>最后要注意的一点是，按值传参肯定会导致<strong>对象切片（object slicing）</strong> 的问题，所以基类类型不适合用于按值传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;                           <span class="comment">//基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span> : <span class="keyword">public</span> Widget &#123; ... &#125;;    <span class="comment">//派生类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(Widget w)</span></span>;                   <span class="comment">// 针对任意类型的 Widget 的函数</span></span><br><span class="line">                                                <span class="comment">// 包括派生类型</span></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">SpecialWidget sw;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(sw);                              <span class="comment">// 发生对象切片，processWidget 只能看到 Widget</span></span><br><span class="line">                                                <span class="comment">// 而非 SpecialWidget</span></span><br></pre></td></tr></table></figure><h3 id="条款-42：考虑置入而非插入">条款 42：考虑置入而非插入</h3><p>假如你想向 STL 容器中添加新元素，<strong>插入函数（insertion function）</strong> 通常是合乎逻辑的选择，但对于性能狂人而言，其背后所隐含的临时对象带来的开销是难以忍受的。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;    <span class="comment">// 持有 std::string 对象的容器</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);          <span class="comment">// 添加字符串字面量</span></span><br></pre></td></tr></table></figure><p>此处添加的字符串字面量和<code>std::string</code>类型并不匹配，因此需要先创建一个<code>std::string</code>类型的临时对象，然后再将其绑定到<code>push_back</code>函数的右值引用形参。换句话说，你可以把这句调用看作下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyzzy&quot;</span>));</span><br></pre></td></tr></table></figure><p>在这之后，<code>push_back</code>会在<code>std::vector</code>中构造出一个形参的副本，这个过程是通过调用移动构造函数来完成的（这已经是第二次调用构造函数了）。在<code>push_back</code>返回后，临时对象将立刻被销毁，这又调用了<code>std::string</code>的析构函数。</p><p>从原理上来说，<strong>置入函数（emplacement function）</strong> 在大部分时候应该比插入函数更高效，而且不会有更低效的可能性。<code>emplace_back</code>函数使用了完美转发，因此调用它不会带来任何的临时对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure><p>但令人遗憾的是，插入函数还是有可能比置入函数更快的，这取决于传递的实参类型，使用的容器种类，置入或插入到容器中的位置，容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>和<code>set::unordered_map</code>）而言，要添加的值是否已经在容器中。不过在以下这些情况，置入函数很有可能会运行得更快：</p><ul><li>待添加的值是通过构造而非赋值方式加入容器。一个反例是向<code>std::vector</code>中已经被占据的位置置入对象：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line">...                                 <span class="comment">// 向 vs 中添加元素</span></span><br><span class="line"></span><br><span class="line">vs.<span class="built_in">emplace</span>(vs.<span class="built_in">begin</span>(), <span class="string">&quot;xyzzy&quot;</span>);    <span class="comment">// 向 vs 的开头添加元素，该位置已经存在对象</span></span><br><span class="line">                                    <span class="comment">// 使用的是赋值而非构造方式</span></span><br></pre></td></tr></table></figure><blockquote><p>基于节点的容器一般都使用构造来添加新元素，而大多数标准库容器都是基于节点的，除了<code>std::vector</code>，<code>std::deque</code>和<code>std::string</code>等（<code>std::array</code>也不是基于节点的，但是它不支持置入和插入，所以和我们的讨论无关）。在不是基于节点的容器中，你可以确信<code>emplace_back</code>是使用构造来向容器添加元素的，这对于<code>std::deque</code>的<code>emplace_front</code>也同样成立。</p></blockquote><ul><li>传递的实参类型和容器所持有的类型不同。</li><li>容器不会因为存在重复值而拒绝待添加的值。</li></ul><p>在面对<code>new Widget</code>这样的表达式时，置入函数也没有什么优势。考虑以下两种向<code>std::shared_ptr</code>容器中添加新元素的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">killWidget</span><span class="params">(Widget* pWidget)</span></span>;   <span class="comment">// 自定义删除器</span></span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, killWidget));</span><br><span class="line"><span class="comment">// 和 ptrs.push_back(&#123; new Widget, killWidget &#125;) 等价</span></span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> Widget, killWidget);</span><br></pre></td></tr></table></figure><p>此处使用<code>push_back</code>仍然会创建出<code>std::shared_ptr</code>类型的临时对象，但该临时对象却拥有了正面意义，如果在为链表节点分配内存时抛出了内存不足的异常，那么该<code>std::shared_ptr</code>临时对象可以自动调用<code>killWidget</code>来释放<code>Widget</code>的内存；但在使用<code>emplace_back</code>的情况下，起到保障作用的<code>std::shared_ptr</code>临时对象将不再存在，如果发生同样的异常，那么<code>Widget</code>的内存将不可避免地被泄漏。</p><p>如果你参考<strong>条款 21</strong> 所述，使用独立语句将<code>new Widget</code>产生的指针转交给资源管理对象，那么使用置入函数和插入函数的效果也是差不多的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(spw));</span><br><span class="line"><span class="comment">// 或 ptrs.emplace_back(std::move(spw))</span></span><br></pre></td></tr></table></figure><p>最后需要注意的一点是，置入函数可能会执行在插入函数中会被拒绝的类型转换。这是因为置入函数使用的是直接初始化，而插入函数使用的是拷贝初始化，只有直接初始化会将带有<code>explicit</code>限定符的构造函数纳入考虑范围。因此在使用置入函数时，要特别关注是否传递了正确的实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt; regexes;    <span class="comment">// C++11 提供了对正则表达式的支持</span></span><br><span class="line"></span><br><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);         <span class="comment">// 无法通过编译！</span></span><br><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);      <span class="comment">// 能通过编译，但会产生未定义行为</span></span><br><span class="line">                                    <span class="comment">// 相当于执行 std::regex(nullptr)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Cpp</title>
      <link href="/posts/bf4dced7.html"/>
      <url>/posts/bf4dced7.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>《Effectivate C++》，非常好的一本进一步理解C++的书。</p><p>转载自：<a href="https://joytsing.cn/posts/22113/">https://joytsing.cn/posts/22113/</a></p><p>并在其中添加了自己学习的内容。</p><h2 id="第一章：让自己习惯-C">第一章：让自己习惯 C++</h2><h3 id="条款-1：视-C-为一个语言联邦">条款 1：视 C++ 为一个语言联邦</h3><p>C++ 拥有多种不同的编程范式，而这些范式集成在一个语言中，使得 C++ 是一门即灵活又复杂的语言：</p><ol><li>传统的面向过程 C：区块，语句，预处理器，内置数据类型，数组，指针。</li><li>面向对象的 C with Classes：类，封装，继承，多态，动态绑定。</li><li>模板编程 Template C++ 和堪称黑魔法的模板元编程（TMP）。</li><li>C++ 标准库 STL。</li></ol><p>C++ 高效编程守则视情况而变化，程序设计没有银弹。</p><h3 id="条款-2：尽量以-const-enum-inline-替换-define">条款 2：尽量以 const, enum, inline 替换 #define</h3><p>通俗来说，#define在预处理展开直接替换到代码中，不好排查错误~</p><p>在原书写成时 C++11 中的<code>constexpr</code>还未诞生，现在一般认为应当用<code>constexpr</code>定义编译期常量来替代大部分的<code>#define</code>宏常量定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><p>我们也可以将编译期常量定义为类的静态成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> numTurns = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>enum</code>可以用于替代整型的常量，并且在模板元编程中应用广泛（见条款 48）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; numTurns = <span class="number">5</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大部分<code>#define</code>宏常量应当用内联模板函数替代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CallWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，宏和函数的行为本身并不完全一致，宏只是简单的替换，并不涉及传参和复制。</p><h3 id="条款-3：尽可能使用-const">条款 3：尽可能使用 const</h3><p><strong>const</strong></p><p>const 修饰的变量不能够再作为左值！！初始化完成后，值不能被修改！！</p><p><strong>C和C++中const的区别？</strong></p><p>C中，const就是当作一个变量来编译生成指令的。</p><p>C++中，所有出现const常量名字的地方，都被常量的初始化替换了！！！</p><p><strong>C++中的const必须初始化</strong></p><hr><p><strong>const和一级、多级指针的结合</strong><br>const修饰的量常出现的错误是：</p><p>常量不能再作为左值 = 直接修改常量的值</p><p>不能把常量的地址泄露给—个普通的指针或者普通的引用变量 = 间接修改常量的</p><p>const和一级指针的结合</p><p>c++的语言规范：<strong>const修饰的是离它最近的类型</strong></p><p>const int *p = &amp;a; *p = 20 p = &amp;b<br>可以任意指向不同的int类型的内存，但是不能通过指针间接修改指向的内存的值</p><hr><p>若你想让一个常量只读，那你应该明确说出它是const常量，对于指针来说，更是如此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting;                <span class="comment">// 指针可修改，数据可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;          <span class="comment">// 指针可修改，数据不可修改</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span>* p = greeting;          <span class="comment">// 指针可修改，数据不可修改</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;          <span class="comment">// 指针不可修改，数据可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;    <span class="comment">// 指针不可修改，数据不可修改</span></span><br></pre></td></tr></table></figure><p>对于 STL 迭代器，分清使用<code>const</code>还是<code>const_iterator</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// 迭代器不可修改，数据可修改</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// 迭代器可修改，数据不可修改</span></span><br></pre></td></tr></table></figure><p>面对函数声明时，如果你不想让一个函数的结果被无意义地当作左值，请使用const返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><p><strong>const成员函数：</strong></p><p>const成员函数允许我们操控const对象，这在传递常引用时显得尤为重要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;    <span class="comment">// const对象使用的重载</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;                <span class="comment">// non-const对象使用的重载</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，const和non-const对象都有其各自的重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Textblock&amp; ctb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ctb[<span class="number">0</span>];            <span class="comment">// 调用 const TextBlock::operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器对待const对象的态度通常是 bitwise constness，而我们在编写程序时通常采用 logical constness，这就意味着，在确保客户端不会察觉的情况下，我们认为const对象中的某些成员变量应当是允许被改变的，使用关键字<code>mutable</code>来标记这些成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">Length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="type">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">CTextBlock::Length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = std::<span class="built_in">strlen</span>(pText);    <span class="comment">// 可以修改mutable成员变量</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;               <span class="comment">// 可以修改mutable成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重载const和non-const成员函数时，需要尽可能避免书写重复的内容，这促使我们去进行常量性转除。在大部分情况下，我们应当避免转型的出现，但在此处为了减少重复代码，转型是适当的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设这里有非常多的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，反向做法：令const版本调用non-const版本以避免重复——并不被建议，一般而言const版本的限制比non-const版本的限制更多，因此这样做会带来风险。</p><h3 id="条款-4：确定对象在使用前已被初始化">条款 4：确定对象在使用前已被初始化</h3><p>无初值对象在 C/C++ 中广泛存在，因此这一条款就尤为重要。在定义完一个对象后需要尽快为它赋初值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;A C-style string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">std::cin &gt;&gt; d;</span><br></pre></td></tr></table></figure><p>对于类中的成员变量而言，我们有两种建议的方法完成初始化工作，一种是直接在定义处赋初值（since C++11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> textLength&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">bool</span> lengthIsValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种是使用构造函数成员初始化列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">                 <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : <span class="built_in">theName</span>(name),</span><br><span class="line">      <span class="built_in">theAddress</span>(address),</span><br><span class="line">      <span class="built_in">thePhones</span>(phones),</span><br><span class="line">      <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>成员初始化列表也可以留空用来执行默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>()</span><br><span class="line">    : <span class="built_in">theName</span>(),</span><br><span class="line">      <span class="built_in">theAddress</span>(),</span><br><span class="line">      <span class="built_in">thePhones</span>(),</span><br><span class="line">      <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类中成员的初始化具有次序性，而这次序与成员变量的声明次序一致，与成员初始化列表的次序无关。</p><blockquote><p>类中成员的初始化是可选的，但是引用类型必须初始化。</p></blockquote><p><strong>静态对象的初始化：</strong></p><p>C++ 对于定义于不同编译单元内的全局静态对象的初始化相对次序并无明确定义，因此，以下代码可能会出现使用未初始化静态对象的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File 1</span></span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>() &#123;</span><br><span class="line">        FileSystem disk = tfs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Directory tempDir;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，你无法确保位于不同编译单元内的<code>tfs</code>一定在<code>tempDir</code>之前初始化完成。</p><p>这个问题的一个有效解决方案是采用 <strong>Meyers’ singleton</strong>，将全局静态对象转化为局部静态对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个手法的基础在于：C++ 保证，函数内的局部静态对象会在<strong>该函数被调用期间</strong>和<strong>首次遇上该对象之定义式</strong>时被初始化。</p><p>当然，这种做法对于多线程来说并不具有优势，最好还是在单线程启动阶段手动调用函数完成初始化。</p><h2 id="第二章：构造-析构-赋值运算">第二章：构造/析构/赋值运算</h2><h3 id="条款-5：了解-C-默默编写并调用哪些函数">条款 5：了解 C++ 默默编写并调用哪些函数</h3><p>这个条款我将会在对象模型中详细解释。</p><p>C++ 中的空类并不是真正意义上的空类，编译器会为它预留以下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>() &#123; ... &#125;                           <span class="comment">// 默认构造函数（没有任何构造函数时）</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;) &#123; ... &#125;               <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(Empty&amp;&amp;) &#123; ... &#125;                    <span class="comment">// 移动构造函数 (since C++11)</span></span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123; ... &#125;                          <span class="comment">// 析构函数</span></span><br><span class="line">    </span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;) &#123; ... &#125;    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(Empty&amp;&amp;) &#123; ... &#125;         <span class="comment">// 移动赋值运算符 (since C++11)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>唯有当这些函数被调用时，它们才会真正被编译器创建出来，下面代码将造成上述每一个函数被创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Empty e1;                   <span class="comment">// 默认构造函数 &amp; 析构函数</span></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;               <span class="comment">// 拷贝构造函数</span></span><br><span class="line">Empty e3 = std::<span class="built_in">move</span>(e2);   <span class="comment">// 移动构造函数 (since C++11)</span></span><br><span class="line">e2 = e1;                    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">e3 = std::<span class="built_in">move</span>(e1);         <span class="comment">// 移动赋值运算符 (since C++11)</span></span><br></pre></td></tr></table></figure><p>需要注意的是，拷贝赋值运算符只有在允许存在时才会自动创建，比如以下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string&amp; nameValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在该类中，我们有一个string引用类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p><p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p><ol><li>类中含有const成员。</li><li>基类中含有private的拷贝赋值运算符。</li></ol><h3 id="条款-6：若不想使用编译器自动生成的函数，就该明确拒绝">条款 6：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>muduo网络库中noncopyable类的设计，可以学习。</p><p>原书中使用的做法是将不想使用的函数声明为private，但在 C++11 后我们有了更好的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-7：为多态基类声明虚析构函数">条款 7：为多态基类声明虚析构函数</h3><p><strong>重点</strong>：基类指针指向堆上new出来的派生类对象的时候,delete pb基类指针，它调用析构函数的时候，必须发生动态绑定，要不然子类的析构无法调用。</p><p>当派生类对象经由一个基类指针被删除，而该基类指针带着一个非虚析构函数，其结果是未定义的，可能会无法完全销毁派生类的成员，造成内存泄漏。消除这个问题的方法就是对基类使用虚析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你不想让一个类成为基类，那么在类中声明虚函数是是一个坏主意，因为额外存储的虚表指针会使类的体积变大。</p><blockquote><p>只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数。</p></blockquote><p>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。</p><p>如果你想将基类作为抽象类使用，但手头上又没有别的虚函数，那么将它的析构函数设为纯虚函数是一个不错的想法。考虑以下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但若此时从该基类中派生出新的类，会发生报错，这是因为编译器无法找到基类的析构函数的实现。因此，即使是纯虚析构函数，也需要一个函数体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base::~<span class="built_in">Base</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者以下写法也被允许：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-8：别让异常逃离析构函数">条款 8：别让异常逃离析构函数</h3><p>在析构函数中吐出异常并不被禁止，但为了程序的可靠性，应当极力避免这种行为。</p><p>为了实现 RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        db.<span class="built_in">close</span>();    <span class="comment">// 该函数可能会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p><p>第一种：杀死程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 记录运行日志，以便调试</span></span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p><p>第三种：重新设计接口，将异常的处理交给客户端完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个新设计的接口中，我们提供了<code>close</code>函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用<code>close</code>函数。</p><p>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</p><h3 id="条款-9：绝不在构造和析构过程中调用虚函数">条款 9：绝不在构造和析构过程中调用虚函数</h3><p><strong>重点</strong>：</p><p>1.构造调用：</p><p>构造调用虚函数，静态调用（从所在类往根类回溯，找到虚函数，就调用哪一个）【问题：父调用子出问题，因为子还没构造出来】</p><p>非构造调用虚函数，通过虚表</p><p>2.析构调用</p><p>析构的顺序：子到父</p><p>在父类中的析构调用虚函数，那么子类可能销毁~</p><hr><p>在创建派生类对象时，基类的构造函数永远会早于派生类的构造函数被调用，而基类的析构函数永远会晚于派生类的析构函数被调用。</p><p>在派生类对象的基类构造和析构期间，对象的类型是基类而非派生类，因此此时调用虚函数会被编译器解析至基类的虚函数版本，通常不会得到我们想要的结果。</p><p>间接调用虚函数是一个比较难以发现的危险行为，需要尽量避免：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>() &#123; <span class="built_in">Init</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">LogTransaction</span>();      <span class="comment">// 此处间接调用了虚函数！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LogTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo) &#123;</span><br><span class="line">    <span class="built_in">LogTransaction</span>(logInfo);                           <span class="comment">// 更改为了非虚函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span> : <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(...)</span><br><span class="line">        : <span class="built_in">Transaction</span>(<span class="built_in">CreateLogString</span>(...)) &#123; ... &#125;    <span class="comment">// 将信息传递给基类构造函数</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">CreateLogString</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此处的<code>CreateLogString</code>是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p><h3 id="条款-10：令-operator-返回一个指向-this-的引用">条款 10：令 operator= 返回一个指向 *this 的引用</h3><p>重点：</p><p>a=b=c</p><p>this是地址，*this是对象，解引用。</p><hr><blockquote><p>引用知识</p></blockquote><p>引用和指针区别</p><ul><li><p>引用是一种更安全的指针。</p></li><li><p>引用是必须初始化的，而指针可以不初始化</p></li><li><p>引用只有一级引用，没有多级引用；指针可以一级指针，也可以多级指针</p></li><li><p>定义一个引用变量和定义一个指针变量，其汇编指令是一模一样的；通过引用变量修改所引用内存的值，和过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的</p></li><li><p>右值引用</p></li><li><p>int &amp;&amp;c = 20; 专门用来引用右值类型，指令上，可以自动产生临时量然后直接引用临时量 c = 40;</p></li><li><p>右值引用变量本身是一个左值，只能用左值引用来引用它</p></li><li><p>不能用一个右值引用变量来引用一个左值。</p></li></ul><hr><p>虽然并不强制执行此条款，但为了实现连锁赋值，大部分时候应该这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs) &#123;    <span class="comment">// 这个条款适用于</span></span><br><span class="line">        ...                                    <span class="comment">// +=, -=, *= 等等运算符</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs) &#123;               <span class="comment">// 即使参数类型不是 Widget&amp; 也适用</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-11：在-operator-中处理“自我赋值”">条款 11：在 operator= 中处理“自我赋值”</h3><p>重点：特判，减小开销</p><hr><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pRes;                          <span class="comment">// 删除当前持有的资源</span></span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);       <span class="comment">// 复制传入的资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但若<code>rhs</code>和<code>*this</code>指向的是相同的对象，就会导致访问到已删除的数据。</p><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">// 若是自我赋值，则不做任何事</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pRes;</span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Resource* pOrigin = pRes;             <span class="comment">// 先记住原来的pRes指针</span></span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);       <span class="comment">// 复制传入的资源</span></span><br><span class="line">    <span class="keyword">delete</span> pOrigin;                       <span class="comment">// 删除原来的资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p><p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(Widget rhs) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-12：复制对象时勿忘其每一个成分">条款 12：复制对象时勿忘其每一个成分</h3><p>这个条款正如其字面意思，当你决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><p>当使用继承时，继承自基类的成员往往容易忘记在派生类中完成复制，如果你的基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span> : <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),                <span class="comment">// 调用基类的拷贝构造函数</span></span><br><span class="line">      <span class="built_in">priority</span>(rhs.priority) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);       <span class="comment">// 调用基类的拷贝赋值运算符</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不要尝试在拷贝构造函数中调用拷贝赋值运算符，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><h2 id="第三章：资源管理">第三章：资源管理</h2><h3 id="条款-13：以对象管理资源">条款 13：以对象管理资源</h3><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄露。因此，我们应尽可能以对象管理资源，并采用RAII（Resource Acquisition Is Initialize，资源取得时机便是初始化时机），让析构函数负责资源的释放。</p><p>原书此处关于智能指针的内容已经过时，在 C++11 中，通过专一所有权来管理RAII对象可以使用<code>std::unique_ptr</code>，通过引用计数来管理RAII对象可以使用<code>std::shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Investment* CreateInvestment();</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pUniqueInv1</span><span class="params">(CreateInvestment())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pUniqueInv2</span><span class="params">(std::move(pUniqueInv1))</span></span>;    <span class="comment">// 转移资源所有权</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv1</span><span class="params">(CreateInvestment())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv2</span><span class="params">(pSharedInv1)</span></span>;               <span class="comment">// 引用计数+1</span></span><br></pre></td></tr></table></figure><p>智能指针默认会自动delete所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void GetRidOfInvestment(Investment*) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(GetRidOfInvestment)</span>*&gt; <span class="title">pUniqueInv</span><span class="params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv</span><span class="params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条款-14：在资源管理类中小心拷贝行为">条款 14：在资源管理类中小心拷贝行为</h3><p>我们应该永远保持这样的思考：当一个RAII对象被复制，会发生什么事？</p><p><strong>选择一：禁止复制</strong></p><p>许多时候允许RAII对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款 6 已经阐述了怎么做这件事。</p><p><strong>选择二：对底层资源祭出“引用计数法”</strong></p><p>正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><p><strong>选择三：复制底层资源</strong></p><p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p><p><strong>选择四：转移底层资源的所有权</strong></p><p>和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p><h3 id="条款-15：在资源管理类中提供对原始资源的访问">条款 15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL 中的智能指针也提供了对原始资源的隐式访问和显式访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Investment* pRaw = pSharedInv.<span class="built_in">get</span>();    <span class="comment">// 显式访问原始资源</span></span><br><span class="line">Investment raw = *pSharedInv;           <span class="comment">// 隐式访问原始资源</span></span><br></pre></td></tr></table></figure><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FontHandle <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> handle; &#125;       <span class="comment">// 显式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> handle; &#125;  <span class="comment">// 隐式转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式">条款 16：成对使用 new 和 delete 时要采用相同形式</h3><blockquote><p>new和delete</p></blockquote><p>malloc 和 free，称作 c 的库函数</p><p>new 和 delete，称作运算符</p><p>new不仅可以做内存开辟，还可以做内存初始化操作</p><p>malloc开辟内存失败，是通过返回值和nullptr做比较：而new开辟内存失败，是通过抛出bad_alloc类型的异常来判断的。</p><p>new 可以认为是 malloc + 构造函数， delete 可以认为是 free + 析构函数</p><hr><p><strong>重点</strong>：不成对出现是针对对象来说，内置类型没有问题。</p><p>因为[]的时候，内存会多开辟一段空间保存对象信息，比如个数</p><p>new和delete[]的例子：会导致内存多delete</p><p>new[]和delete的例子：delete只删除掉第一对象，即调用第一个对象的构造函数，但是对象有多个，因此会存在问题。</p><hr><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>* object = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"><span class="keyword">delete</span> object;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>typedef</code>定义数组类型会带来额外的风险：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;    <span class="comment">// pal 是一个对象数组，而非单一对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;                             <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;                           <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="条款-17：以独立语句将-newed-对象置入智能指针">条款 17：以独立语句将 newed 对象置入智能指针</h3><p><strong>重点</strong>:这个条款结合effectivae modern c++学习</p><p>原书此处所讲已过时，现在更好的做法是使用<code>std::make_unique</code>和<code>std::make_shared</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pUniqueInv = std::<span class="built_in">make_unique</span>&lt;Investment&gt;();    <span class="comment">// since C++14</span></span><br><span class="line"><span class="keyword">auto</span> pSharedInv = std::<span class="built_in">make_shared</span>&lt;Investment&gt;();    <span class="comment">// since C++11</span></span><br></pre></td></tr></table></figure><h2 id="第四章：设计与声明">第四章：设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用">条款 18：让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不易被误用。你应在在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个参数类型相同的函数容易造成误用</span></span><br><span class="line">Data::<span class="built_in">Data</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过适当定义新的类型加以限制，降低误用的可能性</span></span><br><span class="line">Data::<span class="built_in">Data</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol><li>尽量使用智能指针，避免跨DLL的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</li></ol><h3 id="条款-19：设计-class-犹如设计-type">条款 19：设计 class 犹如设计 type</h3><p>几乎在设计每一个 class 时，都要面对如下问题：</p><p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p><p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p><p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p><p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p><p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为<code>final</code>）。</p><p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p><p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为<code>= delete</code>。</p><p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p><p><strong>什么是新 type 的“未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p><p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p><h3 id="条款-20：宁以按常引用传参替换按值传参">条款 20：宁以按常引用传参替换按值传参</h3><p>当使用按值传参时，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销可能会较为昂贵。对于任何用户自定义类型，使用按常引用传参是较为推荐的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ValidateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure><p>因为没有任何新对象被创建，这种传参方式不会调用任何构造函数或析构函数，所以效率比按值传参高得多。</p><p>使用按引用传参也可以避免<strong>对象切片（Object slicing）</strong> 的问题，参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处一个<code>WindowWithScrollBars</code>类继承自<code>Window</code>基类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintNameAndDisplay</span><span class="params">(Window w)</span> </span>&#123;    <span class="comment">// 按值传参，会发生对象切片</span></span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">GetName</span>();</span><br><span class="line">    w.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处在传参时，调用了基类<code>Window</code>的拷贝构造函数而非派生类的拷贝构造函数，因此在函数种使用的是一个<code>Window</code>对象，调用虚函数时也只能调用到基类的虚函数<code>Window::Display</code>。</p><p>由于按引用传递不会创建新对象，这个问题就能得到避免：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span> </span>&#123; <span class="comment">// 参数不会被切片</span></span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">GetName</span>();</span><br><span class="line">    w.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也并非永远都使用按引用传参，对于内置类型、STL的迭代器和函数对象，我们认为使用按值传参是比较合适的。</p><h3 id="条款-21：必须返回对象时，别妄想返回其引用">条款 21：必须返回对象时，别妄想返回其引用</h3><p><strong>返回一个指向函数内部局部变量的引用是严重的错误，因为局部变量在离开函数时就被销毁了，除此之外，返回一个指向局部静态变量的引用也是不被推荐的</strong>。</p><p>尽管返回对象会调用拷贝构造函数产生开销，但这开销比起出错而言微不足道。</p><h3 id="条款-22：将成员变量声明为-private">条款 22：将成员变量声明为 private</h3><p>出于对封装性的考虑，应该尽可能地隐藏类中的成员变量，并通过对外暴露函数接口来实现对成员变量的访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetReadOnly</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; readWrite = value; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetReadWrite</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetWriteOnly</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; writeOnly = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> noAccess;</span><br><span class="line">    <span class="type">int</span> readOnly;</span><br><span class="line">    <span class="type">int</span> readWrite;</span><br><span class="line">    <span class="type">int</span> writeOnly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过为成员变量提供 getter 和 setter 函数，我们就能避免客户做出写入只读变量或读取只写变量这样不被允许的操作。</p><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可使得在成员变量被读或写时轻松通知其它对象，可以验证类的约束条件以及函数的提前和事后状态，可以在多线程环境中执行同步控制……</p><p><code>protected</code>和<code>public</code>一样，都不该被优先考虑。假设我们有一个public成员变量，最终取消了它，那么所有使用它的客户代码都将被破坏；假设我们有一个protected成员变量，最终取消了它，那么所有使用它的派生类都将被破坏。</p><p>综合以上讨论，在类中应当将成员变量优先声明为 private。</p><h3 id="条款-23：宁以非成员、非友元函数替换成员函数">条款 23：宁以非成员、非友元函数替换成员函数</h3><p>假设有这样一个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要一次性调用这三个函数，那么需要额外提供一个新的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearEverything</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">    wb.<span class="built_in">ClearCache</span>();</span><br><span class="line">    wb.<span class="built_in">ClearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">RemoveCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，虽然成员函数和非成员函数都可以完成我们的目标，但此处更建议使用非成员函数，这是为了遵守一个原则：<strong>越少的代码可以访问数据，数据的封装性就越强</strong>。此处的<code>ClearEverything</code>函数仅仅是调用了<code>WebBrowser</code>的三个public成员函数，而并没有使用到<code>WebBrowser</code>内部的private成员，因此没有必要让其也拥有访问类中private成员的能力。</p><p>这个原则对于友元函数也是相同的，因为友元函数和成员函数拥有相同的权力，所以在能使用非成员函数完成任务的情况下，就不要使用友元函数和成员函数。</p><p>如果你觉得一个全局函数并不自然，也可以考虑将<code>ClearEverything</code>函数放在工具类中充当静态成员函数，或与<code>WebBrowser</code>放在同一个命名空间中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearEverything</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数">条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><p>现在我们手头上拥有一个<code>Rational</code>类，并且它可以和<code>int</code>隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们需要重载乘法运算符来实现<code>Rational</code>对象之间的乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将运算符重载放在类中是行得通的，至少对于<code>Rational</code>对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf / oneEight;</span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>;    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>在调用<code>operator*</code>时，<code>int</code>类型的变量会隐式转换为<code>Rational</code>对象，因此用<code>Rational</code>对象乘以<code>int</code>对象是合法的，但反过来则不是如此。</p><p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><h3 id="条款-25：考虑写出一个不抛异常的swap函数">条款 25：考虑写出一个不抛异常的swap函数</h3><p>由于<code>std::swap</code>函数在 C++11 后改为了用<code>std::move</code>实现，因此几乎已经没有性能的缺陷，也不再有像原书中所说的为自定义类型去自己实现的必要。不过原书中透露的思想还是值得一学的。</p><p>如果想为自定义类型实现自己的swap方法，可以考虑使用模板全特化，并且这种做法是被 STL 允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，由于外部函数并不能直接访问<code>Widget</code>的private成员变量，因此我们先是在类中定义了一个 public 成员函数，再由<code>std::swap</code>去调用这个成员函数。</p><p>然而若<code>Widget</code>和<code>WidgetImpl</code>是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的swap函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="number">3</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望在对自定义对象进行操作时找到正确的swap函数重载版本，这时候如果再写成<code>std::swap</code>，就会强制使用 STL 中的swap函数，无法满足我们的需求，因此需要改写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="built_in">swap</span>(obj1, obj2);</span><br></pre></td></tr></table></figure><p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的swap函数而非 STL 中的swap函数。</p><blockquote><p>C++ 名称查找法则：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。 函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p></blockquote><h2 id="第五章：实现">第五章：实现</h2><h3 id="条款-26：尽可能延后变量定义式出现的时间">条款 26：尽可能延后变量定义式出现的时间</h3><p><strong>重点</strong>： 对象优化部分</p><p>当变量定义出现时，程序需要承受其构造成本；当变量离开其作用域时，程序需要承受其析构成本。因此，避免不必要的变量定义，以及延后变量定义式直到你确实需要它。</p><p>延后变量定义式还有一个意义，即“默认构造+赋值”效率低于“直接构造”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 效率低</span></span><br><span class="line">std::string encrypted;</span><br><span class="line">encrypted = password;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效率高</span></span><br><span class="line"><span class="function">std::string <span class="title">encrypted</span><span class="params">(password)</span></span>;</span><br></pre></td></tr></table></figure><p>对于循环中变量的定义，我们一般有两种做法：</p><p>A. 定义于循环外，在循环中赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于 i 的某个值;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法产生的开销：1 个构造函数 + 1 个析构函数 + n 个赋值操作</p><p>B. 定义于循环内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于 i 的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法产生的开销：n 个构造函数 + n 个析构函数</p><p>由于做法A会将变量的作用域扩大，因此除非知道该变量的赋值成本比“构造+析构”成本低，或者对这段程序的效率要求非常高，否则建议使用做法B。</p><h3 id="条款-27：少做转型动作">条款 27：少做转型动作</h3><p>C 式转型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span></span></span><br></pre></td></tr></table></figure><p>C++ 式转型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><code>const_cast</code>用于常量性转除，这也是唯一一个有这个能力的 C++ 式转型。</li><li><code>dynamic_cast</code>用于安全地向下转型，这也是唯一一个 C 式转型无法代替的转型操作，它会执行对继承体系的检查，因此会带来额外的开销。只有拥有虚函数的基类指针能进行<code>dynamic_cast</code>。</li><li><code>reinterpret_cast</code>用于在任意两个类型间进行低级转型，执行该转型可能会带来风险，也可能不具备移植性。</li><li><code>static_cast</code>用于进行强制隐式转换，也是最常用的转型操作，可以将内置数据类型互相转换，也可以将<code>void*</code>和typed指针，基类指针和派生类指针互相转换。</li></ul><p>尽量在 C++ 程序中使用 C++ 式转型，因为 C++ 式转型操作功能更明确，可以避免不必要的错误。</p><p>唯一使用 C 式转型的时机可能是在调用 explicit 构造函数时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">DoSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="comment">// 等价于 DoSomeWork(static_cast&lt;Widget&gt;(15));</span></span><br></pre></td></tr></table></figure><p>需要注意的是，转型并非什么都没有做，而是可能会更改数据的底层表述，或者为指针附加偏移值，这和具体平台有关，因此不要妄图去揣测转型后对象的具体布局方式。</p><p>避免对<code>*this</code>进行转型，参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">OnResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码试图通过转型<code>*this</code>来调用基类的虚函数，然而这是严重错误的，这样做会得到一个新的<code>Window</code>副本并在该副本上调用函数，而非在原本的对象上调用函数。</p><p>正确的做法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Window::<span class="built_in">OnResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你想知道一个基类指针是否指向一个派生类对象时，你需要用到<code>dynamic_cast</code>，如果不满足，则会产生报错。但是对于继承体系的检查可能是非常慢的，所以在注重效率的程序中应当避免使用<code>dynamic_cast</code>，改用<code>static_cast</code>或别的代替方法。</p><h3 id="条款-28：避免返回-handles-指向对象的内部成分">条款 28：避免返回 handles 指向对象的内部成分</h3><p>考虑以下<code>Rectangle</code>类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;</span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point&amp; <span class="title">UpperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">LowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码看起来没有任何问题，但其实是在做自我矛盾的事情：我们通过const成员函数返回了一个指向成员变量的引用，这使得成员变量可以在外部被修改，而这是违反 logical constness 的原则的。换句话说，你<strong>绝对不应该令成员函数返回一个指针指向“访问级别较低”的成员函数</strong>。</p><p>改成返回常引用可以避免对成员变量的修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">UpperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">LowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br></pre></td></tr></table></figure><p>但是这样依然会带来一个称作 <strong>dangling handles（空悬句柄）</strong> 的问题，当对象不复存在时，你将无法通过引用获取到返回的数据。</p><p>采用最保守的做法，返回一个成员变量的副本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">UpperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function">Point <span class="title">LowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br></pre></td></tr></table></figure><p>避免返回 handles（包括引用、指针、迭代器）指向对象内部。遵循这个条款可增加封装性，使得const成员函数的行为符合常量性，并将发生 “空悬句柄” 的可能性降到最低。</p><h3 id="条款-29：为“异常安全”而努力是值得的">条款 29：为“异常安全”而努力是值得的</h3><p>异常安全函数提供以下三个保证之一：</p><p><strong>基本承诺：</strong> 如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构会因此败坏，所有对象都处于一种内部前后一致的状态，然而程序的真实状态是不可知的，也就是说客户需要额外检查程序处于哪种状态并作出对应的处理。</p><p><strong>强烈保证：</strong> 如果异常被抛出，程序状态完全不改变，换句话说，程序会回复到“调用函数之前”的状态。</p><p><strong>不抛掷（nothrow）保证：</strong> 承诺绝不抛出异常，因为程序总是能完成原先承诺的功能。作用于内置类型身上的所有操作都提供 nothrow 保证。</p><p>原书中实现 nothrow 的方法是<code>throw()</code>，不过这套异常规范在 C++11 中已经被弃用，取而代之的是<code>noexcept</code>关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>注意，使用<code>noexcept</code>并不代表函数绝对不会抛出异常，而是在抛出异常时，将代表出现严重错误，会有意想不到的函数被调用（可以通过<code>set_unexpected</code>设置），接着程序会直接崩溃。</p><p>当异常被抛出时，带有异常安全性的函数会：</p><ol><li>不泄漏任何资源。</li><li>不允许数据败坏。</li></ol><p>考虑以下<code>PrettyMenu</code>的<code>ChangeBackground</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;        <span class="comment">// 互斥锁</span></span><br><span class="line">    Image* bgImage;     <span class="comment">// 目前的背景图像</span></span><br><span class="line">    <span class="type">int</span> imageChanges;   <span class="comment">// 背景图像被改变的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这个函数不满足我们所说的具有异常安全性的任何一个条件，若在函数中抛出异常，<code>mutex</code>会发生资源泄漏，<code>bgImage</code>和<code>imageChanges</code>也会发生数据败坏。</p><p>通过以对象管理资源，使用智能指针和调换代码顺序，我们能将其变成一个具有强烈保证的异常安全函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(std::<span class="built_in">make_shared</span>&lt;Image&gt;(imgSrc));</span><br><span class="line"></span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个常用于提供强烈保证的方法是我们所提到过的 copy and swap，为你打算修改的对象做出一份副本，对副本执行修改，并在所有修改都成功执行后，用一个不会抛出异常的swap方法将原件和副本交换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pNew = std::<span class="built_in">make_shared</span>&lt;PMImpl&gt;(*pImpl);    <span class="comment">// 获取副本</span></span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(std::<span class="built_in">make_shared</span>&lt;Image&gt;(imgSrc));</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">swap</span>(pImpl, pNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个函数调用其它函数时，函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p><p>强烈保证并非永远都是可实现的，特别是当函数在操控非局部对象时，这时就只能退而求其次选择不那么美好的基本承诺，并将该决定写入文档，让其他人维护时不至于毫无心理准备。</p><h3 id="条款-30：透彻了解-inlining-的里里外外">条款 30：透彻了解 inlining 的里里外外</h3><p><strong>重点</strong>：</p><p>inline函数没有函数调用开销，直接把函数的代码进行展开</p><p>inline函数不再生成相应的函数符号</p><p>递归的函数inline不会展开</p><p>谷歌风格中介绍到最好控制在10行inline函数</p><hr><p>将函数声明为内联一共有两种方法，一种是为其显式指定<code>inline</code>关键字，另一种是直接将成员函数的定义式写在类中，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125;  <span class="comment">// 隐式声明为 inline</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>inline</code>诞生之初，它被当作是一种对编译器的优化建议，即将“对此函数的每一个调用”都以函数本体替换之。但在编译器的具体实现中，该行为完全被优化等级所控制，与函数是否内联无关。</p><p>在现在的 C++ 标准中，<code>inline</code>作为优化建议的含义已经被完全抛弃，取而代之的是“允许函数在不同编译单元中多重定义”，使得可以在头文件中直接给出函数的实现。</p><p>在 C++17 中，引入了一个新的<code>inline</code>用法，使静态成员变量可以在类中直接定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> theAge = <span class="number">0</span>;  <span class="comment">// since C++17</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-31：将文件间的编译依存关系降至最低">条款 31：将文件间的编译依存关系降至最低</h3><p>C++ 坚持将类的实现细节放置于类的定义式中，这就意味着，即使你只改变类的实现而不改变类的接口，在构建程序时依然需要重新编译。这个问题的根源出在编译器必须在编译期间知道对象的大小，如果看不到类的定义式，就没有办法为对象分配内存。也就是说，C++ 并没有把“将接口从实现中分离”这件事做得很好。</p><p><strong>用“声明的依存性”替换“定义的依存性”：</strong></p><p>我们可以玩一个“将对象实现细目隐藏于一个指针背后”的游戏，称作 <strong>pimpl idiom（pimpl 是 pointer to implemention 的缩写）</strong>：将原来的一个类分割为两个类，一个只提供接口，另一个负责实现该接口，称作<strong>句柄类（handle class）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.hpp 负责声明类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.cpp 负责实现类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>() &#123;</span><br><span class="line">    pImpl = std::<span class="built_in">make_shared</span>&lt;PersonImpl&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; pImpl-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，假如我们要修改<code>Person</code>的private成员，就只需要修改<code>PersonImpl</code>中的内容，而<code>PersonImpl</code>的具体实现是被隐藏起来的，对它的任何修改都不会使得<code>Person</code>客户端重新编译，真正实现了“类的接口和实现分离”。</p><p><strong>如果使用对象引用或对象指针可以完成任务，就不要使用对象本身：</strong></p><p>你可以只靠一个类型声明式就定义出指向该类型的引用和指针；但如果定义某类型的对象，就需要用到该类型的定义式。</p><p><strong>如果能够，尽量以类声明式替换类定义式：</strong></p><p>当你在声明一个函数而它用到某个类时，你不需要该类的定义；但当你触及到该函数的定义式后，就必须也知道类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                     <span class="comment">// 类的声明式</span></span><br><span class="line"><span class="function">Date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(Date d)</span></span>; <span class="comment">// 此处并不需要得知类的定义</span></span><br></pre></td></tr></table></figure><p><strong>为声明式和定义式提供不同的头文件：</strong></p><p>为了避免频繁地添加声明，我们应该为所有要用的类声明提供一个头文件，这种做法对 template 也适用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span>            <span class="comment">// 这个头文件内声明 class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure><p>此处的头文件命名方式<code>&quot;datefwd.h&quot;</code>取自标准库中的<code>&lt;iosfwd&gt;</code>。</p><p>上面我们讲述了接口与实现分离的其中一个方法——提供句柄类，另一个方法就是将句柄类定义为抽象基类，称作<strong>接口类（interface class）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了将<code>Person</code>对象实际创建出来，我们一般采用工厂模式。可以尝试在类中塞入一个静态成员函数<code>Create</code>用于创建对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但此时<code>Create</code>函数还无法使用，需要在派生类中给出<code>Person</code>类中的函数的具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(...) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成<code>Create</code>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;RealPerson&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问的是，句柄类和接口类都需要额外的开销：句柄类需要通过 pimpl 取得对象数据，增加一层间接访问、指针大小和动态分配内存带来的开销；而接口类会增加存储虚表指针和实现虚函数跳转带来的开销。</p><p>而当这些开销过于重大以至于类之间的耦合度在相形之下不成为关键时，就以具象类（concrete class）替换句柄类和接口类。</p><h2 id="第六章：继承与面向对象设计">第六章：继承与面向对象设计</h2><h3 id="条款-32：确定你的public继承塑模出-is-a-关系">条款 32：确定你的public继承塑模出 is-a 关系</h3><p>“public继承”意味着 is-a，所谓 is-a，就是指适用于基类身上的每一件事情一定也适用于继承类身上，因为我们可以认为每一个派生类对象也都是一个基类对象。</p><p>这看似很自然，但在面对自然语言的表述时，往往会产生歧义。</p><p>考虑<code>Bird</code>类和<code>Penguin</code>类的继承关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Penguin</code>类会获得来自<code>Bird</code>类的飞行方法，这就造成了误解，因为企鹅恰恰是不会飞的鸟类。一种解决方法是当调用<code>Penguin</code>类中的<code>Fly</code>函数时，抛出一个运行期错误，但这种做法通常不够直观；另一个解决方法是使用双继承，区分会飞和不会飞的鸟类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> FlyingBird &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但若要处理鸟类的多钟不同属性时，双继承模式就不太管用了，因此我们总是说程序设计没有银弹。</p><p>另一个常见的例子是用<code>Square</code>类继承自<code>Rectangle</code>类，从几何学的角度来讲这很自然，然而正方形的长宽是相等的，矩形却不是如此，因此<code>Square</code>类和<code>Rectangle</code>类也无法满足严格的 is-a 关系。</p><h3 id="条款-33：避免遮掩继承而来的名称">条款 33：避免遮掩继承而来的名称</h3><p><strong>重点</strong>：简单来说，父类方法就会被隐藏</p><p>在继承结构中，派生类的同名成员把基类的同名成员给隐藏了，也就是调用的时候调用的是派生类的成员函数。要调用基类那就加作用域，（比如 Base::show）</p><hr><p>之前我们了解过 C++ 名称查找法则，这在继承体系中也是类似的，当我们在派生类中使用到一个名字时，编译器会优先查找派生类覆盖的作用域，如果没找到，再去查找基类的作用域，最后再查找全局作用域。</p><p>考虑以下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样会导致派生类无法使用来自基类的重载函数，因为派生类中的名称<code>mf</code>掩盖了来自基类的名称<code>mf</code>。</p><p>对于名称掩盖问题的一种方法是使用<code>using</code>关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>using</code>关键字会将基类中所有使用到名称<code>mf</code>的函数全部包含在派生类中，包括其重载版本。</p><p>若有时我们不想要一个函数的全部版本，只想要单一版本（特别是在private继承时），可以考虑使用<strong>转发函数（forwarding function）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">mf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-34：区分接口继承和实现继承">条款 34：区分接口继承和实现继承</h3><ol><li>接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。</li><li>声明一个纯虚函数的目的，是为了让派生类只继承函数接口。</li><li>声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。</li><li>声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。</li></ol><p>通常而言，我们不会为纯虚函数提供具体实现，然而这样做是被允许的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p><p>用非纯虚函数提供缺省的默认实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p><p>使用纯虚函数并提供默认实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DefaultFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DefaultFly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述写法可以替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::Fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Airplane::<span class="built_in">Fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-35：考虑虚函数以外的其它选择">条款 35：考虑虚函数以外的其它选择</h3><p><strong>藉由非虚接口手法实现 template method：</strong></p><p><strong>非虚接口（non-virtual interface，NVI）</strong> 设计手法的核心就是用一个非虚函数作为 wrapper，将虚函数隐藏在封装之下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...    <span class="comment">// 做一些前置工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">DoHealthValue</span>();</span><br><span class="line">        ...    <span class="comment">// 做一些后置工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">DoHealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...    <span class="comment">// 缺省算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NVI手法的一个优点就是在 wrapper 中做一些前置和后置工作，确保得以在一个虚函数被调用之前设定好适当场景，并在调用结束之后清理场景。如果你让客户直接调用虚函数，就没有任何好办法可以做这些事。</p><p>NVI手法允许派生类重新定义虚函数，从而赋予它们“如何实现机能”的控制能力，但基类保留诉说“函数何时被调用”的权利。</p><p>在NVI手法中虚函数除了可以是private，也可以是protected，例如要求在派生类的虚函数实现内调用其基类的对应虚函数时，就必须得这么做。</p><p><strong>藉由函数指针实现 Strategy 模式：</strong></p><p>参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DefaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;        <span class="comment">// 缺省算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> HealthCalcFunc = <span class="built_in">int</span>(*)(<span class="type">const</span> GameCharacter&amp;);    <span class="comment">// 定义函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = DefaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同一个人物类型的不同实体可以有不同的健康计算函数，并且该计算函数可以在运行期变更。</p><p>这间接表明健康计算函数不再是<code>GameCharacter</code>继承体系内的成员函数，它也无权使用非public成员。为了填补这个缺陷，我们唯一的做法是弱化类的封装，引入友元或提供public访问函数。</p><p><strong>藉由 std::function 完成 Strategy 模式</strong></p><p><code>std::function</code>是 C++11 中引入的函数包装器，使用它能提供比函数指针更强的灵活度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DefaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;        <span class="comment">// 缺省算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> HealthCalcFunc = std::function&lt;<span class="built_in">int</span>(<span class="type">const</span> GameCharacter&amp;)&gt;;    <span class="comment">// 定义函数包装器类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = DefaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来并没有很大的改变，但当我们需要时，<code>std::function</code>就能展现出惊人的弹性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用返回值不同的函数</span></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">CalcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">chara1</span><span class="params">(CalcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数对象（仿函数）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">chara2</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用某个成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line"><span class="function">GameCharacter <span class="title">chara2</span><span class="params">(std::bind(&amp;GameLevel::Health, currentLevel, std::placeholders::_1))</span></span>;</span><br></pre></td></tr></table></figure><p><strong>古典的 Strategy 模式：</strong></p><p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自<code>HealthCalcFunc</code>继承体系的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">Calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为<code>HealthCalcFunc</code>基类添加一个派生类即可。</p><h3 id="条款-36：绝不重新定义继承而来的非虚函数">条款 36：绝不重新定义继承而来的非虚函数</h3><p>非虚函数和虚函数具有本质上的不同：非虚函数执行的是静态绑定（statically bound，又称前期绑定，early binding），由对象类型本身（称之静态类型）决定要调用的函数；而虚函数执行的是动态绑定（dynamically bound，又称后期绑定，late binding），决定因素不在对象本身，而在于“指向该对象之指针”当初的声明类型（称之动态类型）。</p><p>前面我们已经说过，public继承意味着 is-a 关系，而在基类中声明一个非虚函数将会为该类建立起一种不变性（invariant），凌驾其特异性（specialization）。而若在派生类中重新定义该非虚函数，则会使人开始质疑是否该使用public继承的形式；如果必须使用，则又打破了基类“不变性凌驾特异性”的性质，就此产生了设计上的矛盾。</p><p>综上所述，在任何情况下都不该重新定义一个继承而来的非虚函数。</p><h3 id="条款-37：绝不重新定义继承而来的缺省参数值">条款 37：绝不重新定义继承而来的缺省参数值</h3><p>重点：<strong>缺省参数值却是静态绑定</strong></p><p><strong>什么是多态？</strong></p><p>静态：编译时期的多态。（多种多样的形态）。如 函数重载</p><p>动态：运行时期的多态</p><hr><p>在条款 36 中我们已经否定了重新定义非虚函数的可能性，因此此处我们只讨论带有缺省参数值的虚函数。</p><p>虚函数是动态绑定而来，意思是调用一个虚函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。但与之不同的是，<strong>缺省参数值却是静态绑定</strong>，意思是你可能会在“调用一个定义于派生类的虚函数”的同时，却使用基类为它所指定的缺省参数值。考虑以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时若对派生类对象调用<code>Draw</code>函数，则会发现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">pr-&gt;<span class="built_in">Draw</span>(Shape::ShapeColor::Green);    <span class="comment">// 调用 Rectangle::Draw(Shape::Green)</span></span><br><span class="line">pr-&gt;<span class="built_in">Draw</span>();                            <span class="comment">// 调用 Rectangle::Draw(Shape::Red)</span></span><br><span class="line">pc-&gt;<span class="built_in">Draw</span>();                            <span class="comment">// 调用 Rectangle::Draw(Shape::Red)</span></span><br></pre></td></tr></table></figure><p>这就迫使我们在指定虚函数时使用相同的缺省参数值，为了避免不必要的麻烦和错误，可以考虑条款 35 中列出的虚函数的替代设计，例如NVI手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="type">const</span> </span>&#123; <span class="built_in">DoDraw</span>(color); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-38：通过复合塑模出-has-a-或“根据某物实现出”">条款 38：通过复合塑模出 has-a 或“根据某物实现出”</h3><p>所谓<strong>复合（composition）</strong>，指的是某种类型的对象内含它种类型的对象。复合通常意味着 <strong>has-a</strong> 或<strong>根据某物实现出（is-implemented-in-terms-of）</strong> 的关系，当复合发生于应用域（application domain）内的对象之间，表现出 has-a 的关系；当它发生于实现域（implementation domain）内则是表现出“根据某物实现出”的关系。</p><p>下面是一个 has-a 关系的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;           <span class="comment">// 合成成分物（composed object）</span></span><br><span class="line">    Address address;            <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber voiceNumber;    <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber faxNumber;      <span class="comment">// 同上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个“根据某物实现出”关系的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 list 应用于 Set</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;           <span class="comment">// 用来表述 Set 的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-39：明智而审慎地使用private继承">条款 39：明智而审慎地使用private继承</h3><p>private继承的特点：</p><ol><li>如果类之间是private继承关系，那么编译器不会自动将一个派生类对象转换为一个基类对象。</li><li>由private继承来的所有成员，在派生类中都会变为private属性，换句话说，private继承只继承实现，不继承接口。</li></ol><p>private继承的意义是“根据某物实现出”，如果你读过条款 38，就会发现private继承和复合具有相同的意义，事实上也确实如此，绝大部分private继承的使用场合都可以被“public继承+复合”完美解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span> : <span class="keyword">public</span> Timer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用后者比前者好的原因有以下几点：</p><ol><li>private继承无法阻止派生类重新定义虚函数，但若使用public继承定义<code>WidgetTimer</code>类并复合在<code>Widget</code>类中，就能防止在<code>Widget</code>类中重新定义虚函数。</li><li>可以仅提供<code>WidgetTimer</code>类的声明，并将<code>WidgetTimer</code>类的具体定义移至实现文件中，从而降低<code>Widget</code>的编译依存性。</li></ol><p>然而private继承并非完全一无是处，一个适用于它的极端情况是<strong>空白基类最优化（empty base optimization，EBO）</strong>，参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个没有非静态成员变量、虚函数的类，看似不需要任何存储空间，但实际上 C++ 规定凡是独立对象都必须有非零大小，因此此处<code>sizeof(HoldsAnInt)</code>必然大于<code>sizeof(int)</code>，通常会多出一字节大小，但有时考虑到内存对齐之类的要求，可能会多出更多的空间。</p><p>使用private继承可以避免产生额外存储空间，将上面的代码替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span> : <span class="keyword">private</span> Empty &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-40：明智而审慎地使用多重继承">条款 40：明智而审慎地使用多重继承</h3><p>多重继承是一个可能会造成很多歧义和误解的设计，因此反对它的声音此起彼伏，下面我们来接触几个使用多重继承的场景。</p><p>最先需要认清的一件事是，程序有可能从一个以上的基类继承相同名称，那会导致较多的歧义机会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheckOut</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheckOut</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span> : <span class="keyword">public</span> BorrowableItem, <span class="keyword">public</span> ElectronicGadget &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">CheckOut</span>();          <span class="comment">// MP3Player::CheckOut 不明确！</span></span><br></pre></td></tr></table></figure><p>如果真遇到这种情况，必须明确地指出要调用哪一个基类中的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.BorrowableItem::<span class="built_in">CheckOut</span>();      <span class="comment">// 使用 BorrowableItem::CheckOut</span></span><br></pre></td></tr></table></figure><p>在使用多重继承时，我们可能会遇到要命的“钻石型继承（菱形继承）”：</p><p><img src="https://pic3.zhimg.com/80/v2-882fec69eb599914ab430741992742ca_720w.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span> : <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这时候必须面对这样一个问题：是否打算让基类内的成员变量经由每一条路径被复制？如果不想要这样，应当使用虚继承，指出其愿意共享基类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span> : <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>然而由于虚继承会在派生类中额外存储信息来确认成员来自于哪个基类，虚继承通常会付出更多空间和速度的代价，并且由于虚基类的初始化责任是由继承体系中最底层的派生类负责，就导致了虚基类必须认知其虚基类并且承担虚基类的初始化责任。因此我们应当遵循以下两个建议：</p><ol><li>非必要不使用虚继承。</li><li>如果必须使用虚继承，尽可能避免在虚基类中放置数据。</li></ol><p>多重继承可用于结合public继承和private继承，public继承用于提供接口，private继承用于提供实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPerson 类指出要实现的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">BirthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseID</span> &#123;  ...  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PersonInfo 类有若干已实现的函数</span></span><br><span class="line"><span class="comment">// 可用以实现 IPerson 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">TheName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">TheBirthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimOpen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPerson 类使用多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPerson</span>: <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CPerson</span><span class="params">(DatabaseID pid)</span>: PersonInfo(pid) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;       <span class="comment">// 实现必要的 IPerson 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">TheName</span>();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">BirthDate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 实现必要的 IPerson 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">TheBirthDate</span>();  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重新定义继承而来的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimOpen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimClose</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第七章：模板与泛型编程">第七章：模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态">条款 41：了解隐式接口和编译期多态</h3><p>类与模板都支持接口和多态。对于类而言接口是显式的，以函数签名为中心，多态则是通过虚函数发生于运行期；而对模板参数而言，接口是隐式的，奠基于有效表达式，多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</p><p>考虑以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>以上代码中，<code>T</code>类型的隐式接口要求：</p><ol><li>提供一个名为<code>size</code>的成员函数，该函数的返回值可与<code>int</code>（10 的类型）执行<code>operator&gt;</code>，或经过隐式转换后可执行<code>operator&gt;</code>。</li><li>必须支持一个<code>operator!=</code>函数，接受<code>T</code>类型和<code>someNastyWidget</code>的类型，或其隐式转换后得到的类型。</li></ol><blockquote><p>此处没有考虑<code>operator&amp;&amp;</code>被重载的可能性。</p></blockquote><p>加诸于模板参数身上的隐式接口，就像加诸于类对象身上的显式接口“一样真实”，两者都在编译期完成检查，你无法在模板中使用“不支持模板所要求之隐式接口”的对象（代码无法通过编译）。</p><h3 id="条款-42：了解-typename-的双重含义">条款 42：了解 typename 的双重含义</h3><p>在模板声明式中，使用<code>class</code>和<code>typename</code>关键字并没有什么不同，但在模板内部，<code>typename</code>拥有更多的一重含义。</p><p>理解：为了方便解释，我们首先需要引入一个模板相关的概念：模板内出现的名称如果相依于某个模板参数，我们称之为<strong>从属名称（dependent names）</strong>；如果从属名称在类内呈嵌套状，我们称之为<strong>嵌套从属名称（nested dependent name）</strong>；如果一个名称并不倚赖任何模板参数的名称，我们称之为<strong>非从属名称（non-dependent names）</strong>。</p><p>考虑以下模板代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="type">int</span> value = *iter;</span><br><span class="line">        std::cout &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来没有任何问题，但实际编译时却会报错，这一切的罪魁祸首便是<code>C::const_iterator</code>。此处的<code>C::const_iterator</code>是一个指向某类型的<strong>嵌套从属类型名称（nested dependent type name）</strong>，而嵌套从属名称可能会导致解析困难，因为在编译器知道<code>C</code>是什么之前，没有任何办法知道<code>C::const_iterator</code>是否为一个类型，这就导致出现了歧义状态，而 C++ 默认假设嵌套从属名称不是类型名称。</p><p>显式指明嵌套从属类型名称的方法就是将<code>typename</code>关键字作为其前缀词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br></pre></td></tr></table></figure><p>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2nd</span><span class="params">(<span class="type">const</span> C&amp; container, <span class="type">const</span> <span class="keyword">typename</span> C::iterator iter)</span></span>;</span><br></pre></td></tr></table></figure><p>这一规则的例外是，<code>typename</code>不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;    <span class="comment">// 基类列表中不允许使用 typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x) &#123;</span>                 <span class="comment">// 成员初始化列表中不允许使用 typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类型名称过于复杂时，可以使用<code>using</code>或<code>typedef</code>来进行简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> value_type = <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type;</span><br></pre></td></tr></table></figure><h3 id="条款-43：学习处理模板化基类内的名称">条款 43：学习处理模板化基类内的名称</h3><p>在模板编程中，模板类的继承并不像普通类那么自然，考虑以下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SendClear</span>(info);        <span class="comment">// 调用基类函数，这段代码无法通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显，由于直到模板类被真正实例化之前，编译器并不知道<code>MsgSender&lt;Company&gt;</code>具体长什么样，有可能它是一个全特化的版本，而在这个版本中不存在<code>SendClear</code>函数。由于 C++ 的设计策略是宁愿较早进行诊断，所以编译器会拒绝承认在基类中存在一个<code>SendClear</code>函数。</p><p>为了解决这个问题，我们需要令 C++“进入模板基类观察”的行为生效，有三种办法达成这个目标：</p><p>第一种：在基类函数调用动作之前加上<code>this-&gt;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">SendClear</span>(info);</span><br></pre></td></tr></table></figure><p>第二种：使用<code>using</code>声明式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MsgSender&lt;Company&gt;::SendClear;</span><br><span class="line"><span class="built_in">SendClear</span>(info);</span><br></pre></td></tr></table></figure><p>第三种：明白指出被调用的函数位于基类内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MsgSender&lt;Company&gt;::<span class="built_in">SendClear</span>(info);</span><br></pre></td></tr></table></figure><p>第三种做法是最不令人满意的，如果被调用的是虚函数，上述的明确资格修饰（explicit qualification）会使“虚函数绑定行为”失效。</p><h3 id="条款-44：将与参数无关的代码抽离模板">条款 44：将与参数无关的代码抽离模板</h3><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（code bloat），生成浮夸的二进制目标码。</p><p>基于<strong>共性和变性分析（commonality and variability analysis）</strong> 的方法，我们需要分析模板中重复使用的部分，将其抽离出模板，以减轻模板具现化带来的代码量。</p><ul><li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li><li>因类型模板参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的具现类型共享实现代码。</li></ul><p>参考以下矩阵类的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;  <span class="comment">// private 继承实现，见条款 39</span></span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::Invert;              <span class="comment">// 避免掩盖基类函数，见条款 33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">Invert</span>(n); &#125;              <span class="comment">// 调用模板基类函数，见条款 43</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Invert</code>并不是我们唯一要使用的矩阵操作函数，而且每次都往基类传递矩阵尺寸显得太过繁琐，我们可以考虑将数据放在派生类中，在基类中储存指针和矩阵尺寸。修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T* pMem)</span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data.<span class="built_in">data</span>()) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而这种做法并非永远能取得优势，硬是绑着矩阵尺寸的那个版本，有可能生成比共享版本更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化；而在共享版本中，不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小，也就因此降低程序的 working set（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（locality of reference），这些都可能使程序执行得更快速。究竟哪个版本更佳，只能经由具体的测试后决定。</p><p>同样地，上面的代码也使用到了牺牲封装性的<code>protected</code>，可能会导致资源管理上的混乱和复杂，考虑到这些，也许一点点模板代码的重复并非不可接受。</p><h3 id="条款-45：运用成员函数模板接受所有兼容类型">条款 45：运用成员函数模板接受所有兼容类型</h3><p>C++ 视模板类的不同具现体为完全不同的的类型，但在泛型编程中，我们可能需要一个模板类的不同具现体能够相互类型转换。</p><p>考虑设计一个智能指针类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。很显然，我们需要的是模板拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">        : heldPtr(other.get()) &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(U* p)</span></span></span><br><span class="line"><span class="function">        : heldPtr(p) &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>get</code>获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</p><p>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r);                <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;             <span class="comment">// 泛化拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r);     <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);  <span class="comment">// 泛化拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-46：需要类型转换时请为模板定义非成员函数">条款 46：需要类型转换时请为模板定义非成员函数</h3><p>该条款与条款 24 一脉相承，还是使用原先的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;     <span class="comment">// 无法通过编译！</span></span><br></pre></td></tr></table></figure><p>上述失败启示我们：模板实参在推导过程中，从不将隐式类型转换纳入考虑。虽然以<code>oneHalf</code>推导出<code>Rational&lt;int&gt;</code>类型是可行的，但是试图将<code>int</code>类型隐式转换为<code>Rational&lt;T&gt;</code>是绝对会失败的。</p><p>由于模板类并不依赖模板实参推导，所以编译器总能够在<code>Rational&lt;T&gt;</code>具现化时得知<code>T</code>，因此我们可以使用友元声明式在模板类内指涉特定函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在模板类内，模板名称可被用来作为“模板及其参数”的简略表达形式，因此下面的写法也是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>时，<code>Rational&lt;int&gt;</code>类于是被具现化出来，而作为过程的一部分，友元函数<code>operator*</code>也就被自动声明出来，其为一个普通函数而非模板函数，因此在接受参数时可以正常执行隐式转换。</p><p>为了使程序能正常链接，我们需要为其提供对应的定义式，最简单有效的方法就是直接合并至声明式处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使<code>operator*</code>调用类外的辅助模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">DoMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DoMultiply</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-47：请使用-traits-classes-表现类型信息">条款 47：请使用 traits classes 表现类型信息</h3><p>traits classes 可以使我们在编译期就能获取某些类型信息，它被广泛运用于 C++ 标准库中。traits 并不是 C++ 关键字或一个预先定义好的构件：它们是一种技术，也是 C++ 程序员所共同遵守的协议，并要求对用户自定义类型和内置类型表现得一样好。</p><p>设计并实现一个 trait class 的步骤如下：</p><ol><li>确认若干你希望将来可取得的类型相关信息。</li><li>为该类型选择一个名称。</li><li>提供一个模板和一组特化版本，内含你希望支持的类型相关信息。</li></ol><p>以迭代器为例，标准库中拥有多种不同的迭代器种类，它们各自拥有不同的功用和限制：</p><ol><li><code>input_iterator_tag</code>：单向输入迭代器，只能向前移动，一次一步，客户只可读取它所指的东西。</li><li><code>output_iterator_tag</code>：单向输出迭代器，只能向前移动，一次一步，客户只可写入它所指的东西。</li><li><code>forward_iterator_tag</code>：单向访问迭代器，只能向前移动，一次一步，读写均允许。</li><li><code>bidirectional_iterator_tag</code>：双向访问迭代器，去除了只能向前移动的限制。</li><li><code>random_access_iterator_tag</code>：随机访问迭代器，没有一次一步的限制，允许随意移动，可以执行“迭代器算术”。</li></ol><p>标准库为这些迭代器种类提供的卷标结构体（tag struct）的继承关系如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : input_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : forward_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>将<code>iterator_category</code>作为迭代器种类的名称，嵌入容器的迭代器中，并且确认使用适当的卷标结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = random_access_iterator;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = bidirectional_iterator;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了做到类型的 traits 信息可以在类型自身之外获得，标准技术是把它放进一个模板及其一个或多个特化版本中。这样的模板在标准库中有若干个，其中针对迭代器的是<code>iterator_traits</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">IterT</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = IterT::iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了支持指针迭代器，<code>iterator_traits</code>特别针对指针类型提供一个偏特化版本，而指针的类型和随机访问迭代器类似，所以可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">IterT</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们需要为不同的迭代器种类应用不同的代码时，traits classes 就派上用场了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DisT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(std::iterator_traits&lt;IterT&gt;::iterator_category)</span><br><span class="line">        == <span class="built_in">typeid</span>(std::random_access_iterator_tag)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这些代码实际上是错误的，我们希望类型的判断能在编译期完成。<code>iterator_category</code>是在编译期决定的，然而<code>if</code>却是在运行期运作的，无法达成我们的目标。</p><p>在 C++17 之前，解决这个问题的主流做法是利用函数重载（也是原书中介绍的做法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DisT d, std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DisT d, std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DisT d, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);       <span class="comment">// 单向迭代器不允许负距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DisT d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++17 之后，我们有了更简单有效的做法——使用<code>if constexpr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Advance</span><span class="params">(IterT&amp; iter, DisT d)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">typeid</span>(std::iterator_traits&lt;IterT&gt;::iterator_category)</span></span></span><br><span class="line"><span class="params"><span class="function">        == <span class="keyword">typeid</span>(std::random_access_iterator_tag))</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-48：认识模板元编程">条款 48：认识模板元编程</h3><p>模板元编程（Template metaprogramming，TMP）是编写基于模板的 C++ 程序并执行于编译期的过程，它并不是刻意被设计出来的，而是当初 C++ 引入模板带来的副产品，事实证明模板元编程具有强大的作用，并且现在已经成为 C++ 标准的一部分。实际上，在条款 47 中编写 traits classes 时，我们就已经在进行模板元编程了。</p><p>由于模板元程序执行于 C++ 编译期，因此可以将一些工作从运行期转移至编译期，这可以帮助我们在编译期时发现一些原本要在运行期时才能察觉的错误，以及得到较小的可执行文件、较短的运行期、较少的内存需求。当然，副作用就是会使编译时间变长。</p><p>模板元编程已被证明是“图灵完备”的，并且以“函数式语言”的形式发挥作用，因此在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由 <strong>“递归模板具现化（recursive template instantiation）”</strong> 实现的。</p><p>常用于引入模板元编程的例子是在编译期计算阶乘：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;            <span class="comment">// Factorial&lt;n&gt; = n * Factorial&lt;n-1&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;           <span class="comment">// 处理特殊情况：Factorial&lt;0&gt; = 1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;</span><br></pre></td></tr></table></figure><p>模板元编程很酷，但对其进行调试可能是灾难性的，因此在实际应用中并不常见。我们可能会在下面几种情形中见到它的出场：</p><ol><li>确保量度单位正确。</li><li>优化矩阵计算。</li><li>可以生成客户定制之设计模式（custom design pattern）实现品。</li></ol><h2 id="第八章：定制-new-和-delete">第八章：定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为">条款 49：了解 new-handler 的行为</h3><p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的 <strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">using</span> new_handler = <span class="built_in">void</span>(*)();</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="keyword">noexcept</span></span>;    <span class="comment">// 返回值为原来持有的 new-handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个设计良好的 new-handler 函数必须做以下事情之一：</p><p><strong>让更多的内存可被使用：</strong> 可以让程序一开始执行就分配一大块内存，而后当 new-handler 第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p><p><strong>安装另一个 new-handler：</strong> 如果目前这个 new-handler 无法取得更多内存，可以调换为另一个可以完成目标的 new-handler（令 new-handler 修改“会影响 new-handler 行为”的静态或全局数据）。</p><p><strong>卸除 new-handler：</strong> 将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p><p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong> 这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p><p><strong>不返回：</strong> 通常调用<code>std::abort</code>或<code>std::exit</code>。</p><p>有的时候我们或许会希望在为不同的类分配对象时，使用不同的方式处理内存分配失败情况。这时候使用静态成员是不错的选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做和 std::set_new_handler 相同的事情</span></span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> globalHandler = std::<span class="built_in">set_new_handler</span>(currentHandler);  <span class="comment">// 切换至 Widget 的专属 new-handler</span></span><br><span class="line">    <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);                           <span class="comment">// 分配内存或抛出异常</span></span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(globalHandler);                        <span class="comment">// 切换回全局的 new-handler</span></span><br><span class="line">    <span class="keyword">return</span> globalHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutOfMem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(OutOfMem);</span><br><span class="line"><span class="keyword">auto</span> pw1 = <span class="keyword">new</span> Widget;              <span class="comment">// 若分配失败，则调用 OutOfMem</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> pw2 = <span class="keyword">new</span> Widget;              <span class="comment">// 若分配失败，则抛出异常</span></span><br></pre></td></tr></table></figure><p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;       <span class="comment">// “mixin”风格的基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    ...                         <span class="comment">// 其它的 operator new 版本，见条款 52</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> globalHandler = std::<span class="built_in">set_new_handler</span>(currentHandler);</span><br><span class="line">    <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line">    <span class="keyword">return</span> globalHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...                         <span class="comment">// 不必再声明 set_new_handler 和 operator new</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的<code>currentHandler</code>。</p><p>这个做法用到了所谓的 <strong>CRTP（curious recurring template pattern，奇异递归模板模式）</strong> ，除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Implementation</span>();      <span class="comment">// 在基类中暴露接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Implementation</span><span class="params">()</span></span>;                                  <span class="comment">// 在派生类中提供实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了会调用 new-handler 的<code>operator new</code>以外，C++ 还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为 nothrow new，通过<code>std::nothrow</code>对象来使用它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;                   <span class="comment">// 如果分配失败，抛出 bad_alloc</span></span><br><span class="line"><span class="keyword">if</span> (pw1 == <span class="literal">nullptr</span>) ...                     <span class="comment">// 这个测试一定失败</span></span><br><span class="line"></span><br><span class="line">Widget* pw2 = <span class="built_in">new</span> (std::nothrow) Widget;    <span class="comment">// 如果分配失败，返回空指针</span></span><br><span class="line"><span class="keyword">if</span> (pw2 == <span class="literal">nullptr</span>) ...                     <span class="comment">// 这个测试可能成功</span></span><br></pre></td></tr></table></figure><p>nothrow new 对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此实际上并没有使用 nothrow new 的必要。</p><h3 id="条款-50：了解-new-和-delete-的合理替换时机">条款 50：了解 new 和 delete 的合理替换时机</h3><p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p><p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete 掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete 则会导致未定义行为。如果令<code>operator new</code>持有一串动态分配所得地址，而<code>operator delete</code>将地址从中移除，就很容易检测出上述错误用法。此外各式各样的编程错误可能导致 <strong>“overruns”（写入点在分配区块尾端之后）</strong> 和 <strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的 byte pattern 签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> signature = <span class="number">0xDEADBEEF</span>;              <span class="comment">// 调试“魔数”</span></span><br><span class="line"><span class="keyword">using</span> Byte = <span class="type">unsigned</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">size_t</span> realSize = size + <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>);         <span class="comment">// 分配额外空间以塞入两个签名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* pMem = <span class="built_in">malloc</span>(realSize);                    <span class="comment">// 调用 malloc 取得内存</span></span><br><span class="line">    <span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将签名写入内存的起点和尾端</span></span><br><span class="line">    *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">    *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="built_in">sizeof</span>(<span class="type">int</span>))) = signature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="built_in">sizeof</span>(<span class="type">int</span>);    <span class="comment">// 返回指针指向第一个签名后的内存位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这段代码不能保证内存对齐，并且有许多地方不遵守 C++ 规范，我们将在条款 51 中进行详细讨论。</p><p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete 动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p><p><strong>为了增加分配和归还的速度：</strong> 泛用型分配器往往（虽然并非总是）比定制型分配器慢，特别是当定制型分配器专门针对某特定类型之对象设计时。类专属的分配器可以做到“区块尺寸固定”，例如 Boost 提供的 Pool 程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p><p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong> 泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上招引某些额外开销。针对小型对象而开发的分配器（例如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p><p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimal alignment）：</strong> 许多计算机体系架构要求特定的类型必须放在特定的内存地址上，如果没有奉行这个约束条件，可能导致运行期硬件异常，或者访问速度变低。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。</p><p>在 C++11 中，提供了以下内存对齐相关方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alignas 用于指定栈上数据的内存对齐要求</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) testStruct &#123; <span class="type">double</span> data; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(std::<span class="type">max_align_t</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::alignment_of&lt;std::<span class="type">max_align_t</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span></span><br><span class="line"><span class="type">char</span> buffer[] = <span class="string">&quot;memory alignment&quot;</span>;</span><br><span class="line"><span class="type">void</span>* ptr = buffer;</span><br><span class="line">std::<span class="type">size_t</span> space = <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">align</span>(<span class="built_in">alignof</span>(<span class="type">int</span>), <span class="built_in">sizeof</span>(<span class="type">char</span>), ptr, space);</span><br></pre></td></tr></table></figure><p>在 C++17 后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> count, std::<span class="type">align_val_t</span> al)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>为了将相关对象成簇集中：</strong> 如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（page faults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用 placement new 达成这个目标（见条款 52）。</p><p><strong>为了获得非传统的行为：</strong> 有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（shared memory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++ 的外壳里，写在定制的 new 和 delete 中。</p><h3 id="条款-51：编写-new-和-delete-时需固守常规">条款 51：编写 new 和 delete 时需固守常规</h3><p>我们在条款 49 中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用 new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++ 还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p><p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)      <span class="comment">// 处理0字节申请</span></span><br><span class="line">        size = <span class="number">1</span>;       <span class="comment">// 将其视为1字节申请</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...)        <span class="comment">// 如果分配成功</span></span><br><span class="line">            <span class="keyword">return</span> ...; <span class="comment">// 返回指针指向分配得到的内存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果分配失败，调用目前的 new-handler</span></span><br><span class="line">        <span class="keyword">auto</span> globalHandler = <span class="built_in">get_new_handler</span>(); <span class="comment">// since C++11</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类可以使用其基类的 new 分配方式，但派生类和基类的大小很多时候是不同的。</p><p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);    <span class="comment">// 转交给标准的 operator new 进行处理</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款 39 中我们提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p><p>如果你打算实现<code>operator new[]</code>，即所谓的 array new，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对 array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个 array 将含有多少元素对象。</p><p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是 C++ 保证 <strong>“删除空指针永远安全”</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还 rawMemory 所指的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;    <span class="comment">// 转交给标准的 operator delete 进行处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还 rawMemory 所指的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么 C++ 传给<code>operator delete</code>的<code>size</code>大小可能不正确，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款 7 的补充。</p><h3 id="条款-52：写了-placement-new-也要写-placement-delete">条款 52：写了 placement new 也要写 placement delete</h3><p>placement new 最初的含义指的是“接受一个指针指向对象该被构造之处”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在 vector 的未使用空间上创建对象，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* pMemory)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>我们此处要讨论的是广义上的 placement new，即带有附加参数的<code>operator new</code>，例如下面这种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, std::ostream&amp; logStream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pw = <span class="built_in">new</span> (std::cerr) Widget;</span><br></pre></td></tr></table></figure><p>当我们在使用 new 表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由 C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p><p>这一切的前提是 C++ runtime 能够找到<code>operator new</code>对应的<code>operator delete</code>，如果我们使用的是自定义的 placement new，而没有为其准备对应的 placement delete 的话，就无法避免发生内存泄漏。因此，合格的代码应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span>;   <span class="comment">// placement new</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span></span>;                             <span class="comment">// delete 时调用的正常 operator delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, std::ostream&amp; logStream)</span></span>;    <span class="comment">// placement delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款 33），所以提供 placement new 会导致无法使用正常版本的<code>operator new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pb = <span class="keyword">new</span> Base;             <span class="comment">// 无法通过编译！</span></span><br><span class="line"><span class="keyword">auto</span> pb = <span class="built_in">new</span> (std::cerr) Base; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pd = <span class="built_in">new</span> (std::clog) Derived;  <span class="comment">// 无法通过编译！</span></span><br><span class="line"><span class="keyword">auto</span> pd = <span class="keyword">new</span> Derived;              <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用，除非你的意图就是阻止客户使用它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">operator</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;           <span class="comment">// normal new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">operator</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>*)</span> <span class="keyword">noexcept</span></span>;                 <span class="comment">// placement new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">operator</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// nothrow new</span></span><br></pre></td></tr></table></figure><p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和 delete：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StadardNewDeleteForms</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// placement new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory, ptr)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; nt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size,nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款 33）取得标准形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> StandardNewDeleteForms&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">detele</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第九章：杂项讨论">第九章：杂项讨论</h2><h3 id="条款-53：不要轻忽编译器的警告">条款 53：不要轻忽编译器的警告</h3><ol><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li><li>不要过度依赖编译器的警告能力，因为不同的编译器对待事情的态度不同。一旦移植到另一个编译器上，你原本依赖的警告信息可能会消失。</li></ol><h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库">条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><p>如今 TR1 草案已完全融入 C++ 标准当中，没有再过多了解 TR1 标准库的必要。</p><h3 id="条款-55：让自己熟悉-Boost">条款 55：让自己熟悉 Boost</h3><p>Boost 是若干个程序库的集合，并且当中的许多库已经被 C++ 吸纳为标准库的一部分。不过在现在的 Modern C++ 时代，是否该在项目中使用 Boost 仍然有一定的争议，一些 Boost 组件并无法做到像 C++ 标准库那样高性能，零开销抽象，但毫无疑问的是，Boost 的参考价值是无法忽视的，你可以在 Boost 中找到许多非常值得学习和借鉴的实现。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morden Cpp</title>
      <link href="/posts/af408df9.html"/>
      <url>/posts/af408df9.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>链接地址：<a href="https://changkun.de/modern-cpp/">https://changkun.de/modern-cpp/</a></p><p>一本非常好上手的现代cpp教材，早在去年的时候在参加OceanBase比赛的时候室友推荐的学习资料。</p><h1>第 1 章 迈向现代 C++</h1><p><strong>编译环境</strong>：本书将使用 <code>clang++</code> 作为唯一使用的编译器，同时总是在代码中使用 <code>-std=c++2a</code> 编译标志。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&gt;</span> <span class="string">clang++ -v</span></span><br><span class="line"><span class="attribute">Apple LLVM version 10.0.1 (clang-1001.0.46.4)</span></span><br><span class="line"><span class="attribute">Target</span><span class="punctuation">:</span> <span class="string">x86_64-apple-darwin18.6.0</span></span><br><span class="line"><span class="attribute">Thread model</span><span class="punctuation">:</span> <span class="string">posix</span></span><br><span class="line"><span class="attribute">InstalledDir</span><span class="punctuation">:</span> <span class="string">/Library/Developer/CommandLineTools/usr/bin</span></span><br></pre></td></tr></table></figure><h2 id="1-1-被弃用的特性">1.1 被弃用的特性</h2><p>在学习现代 C++ 之前，我们先了解一下从 C++11 开始，被弃用的主要特性：</p><blockquote><p><strong>注意</strong>：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。</p></blockquote><ul><li><p><strong>不再允许字符串字面值常量赋值给一个 <code>char \*</code>。如果需要用字符串字面值常量赋值和初始化一个 <code>char \*</code>，应该使用 <code>const char \*</code> 或者 <code>auto</code>。</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> *<span class="built_in">str</span> = <span class="string">&quot;hello world!&quot;</span>; <span class="comment">// 将出现弃用警告</span></span><br></pre></td></tr></table></figure></li><li><p><strong>C++98 异常说明、 <code>unexpected_handler</code>、<code>set_unexpected()</code> 等相关特性被弃用，应该使用 <code>noexcept</code>。</strong></p></li><li><p><strong><code>auto_ptr</code> 被弃用，应使用 <code>unique_ptr</code>。</strong></p></li><li><p><strong><code>register</code> 关键字被弃用，可以使用但不再具备任何实际含义。</strong></p></li><li><p><strong><code>bool</code> 类型的 <code>++</code> 操作被弃用。</strong></p></li><li><p><strong>如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。</strong></p></li><li><p><strong>C 语言风格的类型转换被弃用（即在变量前使用 <code>(convert_type)</code>），应该使用 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 来进行类型转换。</strong></p></li><li><p><strong>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>、<code>&lt;cstdalign&gt;</code>、<code>&lt;cstdbool&gt;</code> 与 <code>&lt;ctgmath&gt;</code> 等</strong></p></li><li><p>……等等</p></li></ul><p>还有一些其他诸如参数绑定（C++11 提供了 <code>std::bind</code> 和 <code>std::function</code>）、<code>export</code> 等特性也均被弃用。前面提到的这些特性<strong>如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠拢</strong>，直接学习新特性。毕竟，技术是向前发展的。</p><h2 id="1-2-与-C-的兼容性">1.2 与 C 的兼容性</h2><p>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码（甚至古老的 C 语言代码），例如 Linux 系统调用。在现代 C++ 出现之前，大部分人当谈及『C 与 C++ 的区别是什么』时，普遍除了回答面向对象的类特性、泛型编程的模板特性外，就没有其他的看法了，甚至直接回答『差不多』，也是大有人在。图 1.2 中的韦恩图大致上回答了 C 和 C++ 相关的兼容情况。</p><p><img src="https://changkun.de/modern-cpp/assets/figures/comparison.png" alt="图 1.2: C 和 C++ 互相兼容情况"></p><p>和 C++ 互相兼容情况</p><p>从现在开始，你的脑子里应该树立『<strong>C++ 不是 C 的一个超集</strong>』这个观念（而且从一开始就不是，后面的<a href="https://changkun.de/modern-cpp/zh-cn/01-intro/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB%E7%9A%84%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">进一步阅读的参考文献</a>中给出了 C++98 和 C99 之间的区别）。在编写 C++ 时，也应该尽可能的避免使用诸如 <code>void*</code> 之类的程序风格。而在不得不使用 C 时，应该注意使用 <code>extern &quot;C&quot;</code> 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    [out = std::<span class="built_in">ref</span>(std::cout &lt;&lt; <span class="string">&quot;Result from C code: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>))]()&#123;</span><br><span class="line">        out.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应先使用 <code>gcc</code> 编译 C 语言的代码：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> foo.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>编译出 <code>foo.o</code> 文件，再使用 <code>clang++</code> 将 C++ 代码和 <code>.o</code> 文件链接起来（或者都编译为 <code>.o</code> 再统一链接）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clang</span>++ <span class="number">1</span>.<span class="number">1</span>.cpp foo.o -std=c++<span class="number">2</span>a -o <span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>当然，你可以使用 <code>Makefile</code> 来编译上面的代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C = gcc</span><br><span class="line">CXX = clang++</span><br><span class="line"></span><br><span class="line">SOURCE_C = foo.c</span><br><span class="line">OBJECTS_C = foo.o</span><br><span class="line"></span><br><span class="line">SOURCE_CXX = 1.1.cpp</span><br><span class="line"></span><br><span class="line">TARGET = 1.1</span><br><span class="line">LDFLAGS_COMMON = -std=c++2a</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="variable">$(C)</span> -c <span class="variable">$(SOURCE_C)</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(SOURCE_CXX)</span> <span class="variable">$(OBJECTS_C)</span> <span class="variable">$(LDFLAGS_COMMON)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Makefile</code> 中的缩进是制表符而不是空格符，如果你直接复制这段代码到你的编辑器中，制表符可能会被自动替换掉，请自行确保在 <code>Makefile</code> 中的缩进是由制表符完成的。</p><p>如果你还不知道 <code>Makefile</code> 的使用也没有关系，本教程中不会构建过于复杂的代码，简单的在命令行中使用 <code>clang++ -std=c++2a</code> 也可以阅读本书。</p></blockquote><p>如果你是首次接触现代 C++，那么你很可能还看不懂上面的那一小段代码，即：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">out</span> = <span class="keyword">std</span>::ref(<span class="keyword">std</span>::cout &lt;&lt; <span class="string">&quot;Result from C code: &quot;</span> &lt;&lt; <span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>))]()&#123;</span><br><span class="line">    <span class="keyword">out</span>.get() &lt;&lt; <span class="string">&quot;.\n&quot;</span><span class="comment">;</span></span><br><span class="line">&#125;()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>不必担心，本书的后续章节将为你介绍这一切。</p><h1>第 2 章 语言可用性的强化</h1><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及<strong>语言可用性</strong>，是指那些发生在运行时之前的语言行为。</p><h2 id="2-1-常量">2.1 常量</h2><h3 id="nullptr">nullptr</h3><p><code>nullptr</code> 出现的目的是为了替代 <code>NULL</code>。在某种意义上来说，传统 C++ 会把 <code>NULL</code>、<code>0</code> 视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将 <code>NULL</code> 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 <code>0</code>。</p><p>C++ <strong>不允许</strong>直接将 <code>void *</code> 隐式转换到其他类型。但如果编译器尝试把 <code>NULL</code> 定义为 <code>((void*)0)</code>，那么在下面这句代码中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *ch <span class="operator">=</span> NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>没有了 <code>void *</code> 隐式转换的 C++ 只好将 <code>NULL</code> 定义为 <code>0</code>。而这依然会产生新的问题，将 <code>NULL</code> 定义成 <code>0</code> 将导致 <code>C++</code> 中重载特性发生混乱。考虑下面这两个 <code>foo</code> 函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直觉。</p><p>为了解决这个问题，C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。而 <code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>你可以尝试使用 <code>clang++</code> 编译下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="type">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), std::<span class="type">nullptr_t</span>&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>);          <span class="comment">// 调用 foo(int)</span></span><br><span class="line">    <span class="comment">// foo(NULL);    // 该行不能通过编译</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);    <span class="comment">// 调用 foo(char*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(char*) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="type">int</span>) <span class="keyword">is</span> <span class="keyword">called</span></span><br><span class="line">foo(<span class="type">char</span>*) <span class="keyword">is</span> <span class="keyword">called</span></span><br></pre></td></tr></table></figure><p>从输出中我们可以看出，<code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p><p>此外，在上面的代码中，我们使用了 <code>decltype</code> 和 <code>std::is_same</code> 这两个属于现代 C++ 的语法，简单来说，<code>decltype</code> 用于类型推导，而 <code>std::is_same</code> 用于比较两个类型是否相同，我们会在后面 <a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#decltype">decltype</a> 一节中详细讨论。</p><h3 id="constexpr">constexpr</h3><p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr_1[<span class="number">10</span>];                      <span class="comment">// 合法</span></span><br><span class="line">    <span class="type">char</span> arr_2[LEN];                     <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// char arr_3[len];                  // 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// char arr_4[len_2];                // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_4[len_2_constexpr];         <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char arr_5[len_foo()+5];          // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_6[<span class="built_in">len_foo_constexpr</span>() + <span class="number">1</span>]; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p><blockquote><p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p></blockquote><p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p><p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="built_in">int</span> fibonacci(const <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">    return <span class="built_in">n</span> == <span class="number">1</span> || <span class="built_in">n</span> == <span class="number">2</span> ? <span class="number">1</span> <span class="symbol">:</span> fibonacci(<span class="built_in">n</span>-<span class="number">1</span>)+fibonacci(<span class="built_in">n</span>-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 C++14 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr int <span class="built_in">fibonacci</span>(const int n) &#123;</span><br><span class="line">    <span class="built_in">if</span>(n == <span class="number">1</span>) return <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span>(n == <span class="number">2</span>) return <span class="number">1</span>;</span><br><span class="line">    return <span class="built_in">fibonacci</span>(n-<span class="number">1</span>) + <span class="built_in">fibonacci</span>(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="built_in">int</span> fibonacci(const <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">    return <span class="built_in">n</span> == <span class="number">1</span> || <span class="built_in">n</span> == <span class="number">2</span> ? <span class="number">1</span> <span class="symbol">:</span> fibonacci(<span class="built_in">n</span>-<span class="number">1</span>) + fibonacci(<span class="built_in">n</span>-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-变量及其初始化">2.2 变量及其初始化</h2><h3 id="if-switch-变量声明强化">if/switch 变量声明强化</h3><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 <code>for</code> 语句内能够声明一个临时变量 <code>int</code>，但始终没有办法在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 c++17 之前</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要重新定义一个新的变量</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr2 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr2 != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出 1, 4, 3, 4</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator element = vec.<span class="built_in">begin</span>(); element != vec.<span class="built_in">end</span>(); </span><br><span class="line">        ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们可以看到 <code>itr</code> 这一变量是定义在整个 <code>main()</code> 的作用域内的，这导致当我们需要再次遍历整个 <code>std::vector</code> 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可以在 <code>if</code>（或 <code>switch</code>）中完成这一操作：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="symbol">if</span> (const std::vector&lt;int&gt;::iterator <span class="keyword">itr</span> = std::find(vec.begin(), vec<span class="meta">.end</span>(), <span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">itr</span> != vec<span class="meta">.end</span>()) &#123;</span><br><span class="line">    *<span class="keyword">itr</span> = <span class="number">4</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，是不是和 Go 语言很像？</p><h3 id="初始化列表">初始化列表</h3><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。 在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 <code>&#123;&#125;</code> 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。 这些不同方法都针对各自对象，不能通用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value_a;</span><br><span class="line">    <span class="type">int</span> value_b;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">value_a</span>(a), <span class="built_in">value_b</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before C++11</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0]: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo:&quot;</span> &lt;&lt; foo.value_a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; foo.value_b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">             it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after C++11</span></span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = magicFoo.vec.<span class="built_in">begin</span>(); </span><br><span class="line">        it != magicFoo.vec.<span class="built_in">end</span>(); ++it) </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p><p>初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">            it != list.<span class="built_in">end</span>(); ++it) vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.<span class="built_in">foo</span>(&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure><p>其次，C++11 还提供了统一的语法来初始化任意的对象，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Foo</span> foo2 &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构化绑定">结构化绑定</h3><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>auto</code> 类型推导会在 <a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#auto">auto 类型推导</a>一节中进行介绍。</p><h2 id="2-3-类型推导">2.3 类型推导</h2><p>在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长。</p><p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h3 id="auto">auto</h3><p><code>auto</code> 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 <code>register</code> 并存。在传统 C++ 中，如果一个变量没有声明为 <code>register</code> 变量，将自动被视为一个 <code>auto</code> 变量。而随着 <code>register</code> 被弃用（在 C++17 中作为保留关键字，以后使用，目前不具备实际意义），对 <code>auto</code> 的语义变更也就非常自然了。</p><p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到了传统 C++ 中冗长的迭代写法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 之前</span></span><br><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// 所以 it 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;int&gt;::const_iterator it = <span class="built_in">vec</span>.<span class="built_in">cbegin</span>(); it != <span class="built_in">vec</span>.<span class="built_in">cend</span>(); ++it)</span><br></pre></td></tr></table></figure><p>而有了 <code>auto</code> 之后可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="comment">// 从 C++11 起, 使用 auto 关键字进行类型推导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些其他的常见用法：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;              <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">10</span>); <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure><p>从 C++ 20 起，<code>auto</code> 甚至能用于函数传参，考虑下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto auto_arr2[10] = &#123;arr&#125;; // 错误, 无法推导数组元素类型</span><br><span class="line"></span><br><span class="line">2.6.auto.cpp:30:19: error: &#x27;auto_arr2&#x27; declared as<span class="built_in"> array </span>of &#x27;auto&#x27;</span><br><span class="line"> auto auto_arr2[10] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="decltype">decltype</h3><p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(表达式)</span></span></span><br></pre></td></tr></table></figure><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure><p>你已经在前面的例子中看到 <code>decltype</code> 用于推断类型的用法，下面这个例子就是判断上面的变量 <code>x, y, z</code> 是否是同一类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="variable constant_">is_same</span>&lt;<span class="title function_ invoke__">decltype</span>(x), <span class="keyword">int</span>&gt;::<span class="variable constant_">value</span>)</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="variable constant_">is_same</span>&lt;<span class="title function_ invoke__">decltype</span>(x), <span class="keyword">float</span>&gt;::<span class="variable constant_">value</span>)</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;type x == float&quot;</span> &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="variable constant_">is_same</span>&lt;<span class="title function_ invoke__">decltype</span>(x), <span class="title function_ invoke__">decltype</span>(z)&gt;::<span class="variable constant_">value</span>)</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;type z == type x&quot;</span> &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>std::is_same&lt;T, U&gt;</code> 用于判断 <code>T</code> 和 <code>U</code> 这两个类型是否相等。输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">x </span>== int</span><br><span class="line"><span class="keyword">type</span> <span class="type">z </span>== <span class="keyword">type</span> <span class="type">x</span></span><br></pre></td></tr></table></figure><h3 id="尾返回类型推导">尾返回类型推导</h3><p>你可能会思考，在介绍 <code>auto</code> 时，我们已经提过 <code>auto</code> 不能用于函数形参进行类型推导，那么 <code>auto</code> 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有<a href="https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names">嵌套依赖类型</a>的变量时，需要用 typename 消除歧义</p></blockquote><p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 <code>add()</code> 这个函数会做什么样的操作，以及获得一个什么样的返回类型。</p><p>在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 <code>decltype</code> 推导 <code>x+y</code> 的类型，写出这样的代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，<code>x</code> 和 <code>y</code> 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 <code>auto</code> 关键字将返回类型后置：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">template</span>&lt;typename <span class="type">T</span>, typename <span class="type">U</span>&gt;</span><br><span class="line"><span class="title">auto</span> add2(<span class="type">T</span> x, <span class="type">U</span> y) -&gt; decl<span class="keyword">type</span>(x+y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以检查一下类型推导是否正确：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after c++11</span></span><br><span class="line"><span class="keyword">auto</span> w = <span class="built_in">add2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(w), <span class="type">double</span>&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w is double: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after c++14</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">add3</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="decltype-auto">decltype(auto)</h3><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。</p><blockquote><p>要理解它你需要知道 C++ 中参数转发的概念，我们会在<a href="https://changkun.de/modern-cpp/zh-cn/03-runtime/index.html">语言运行时强化</a>一章中详细介绍，你可以到时再回来看这一小节的内容。</p></blockquote><p>简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string  <span class="built_in">lookup1</span>();</span><br><span class="line">std::string&amp; <span class="built_in">lookup2</span>();</span><br></pre></td></tr></table></figure><p>在 C++11 中，封装实现是如下形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">look_up_a_string_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">std</span>::<span class="built_in">string</span>&amp; <span class="title function_">look_up_a_string_2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decltype</span>(auto) <span class="built_in">look_up_a_string_1</span>() &#123;</span><br><span class="line">    return <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">decltype</span>(auto) <span class="built_in">look_up_a_string_2</span>() &#123;</span><br><span class="line">    return <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-控制流">2.4 控制流</h2><h3 id="if-constexpr">if constexpr</h3><p>正如本章开头出，我们知道了 C++11 引入了 <code>constexpr</code> 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 <code>constexpr</code> 这个关键字引入到 <code>if</code> 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，实际代码就会表现为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间-for-迭代">区间 for 迭代</h3><p>终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>); itr != vec.<span class="built_in">end</span>()) *itr = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-模板">2.5 模板</h2><p>C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p><h3 id="外部模板">外部模板</h3><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">bool</span>&gt;;          <span class="comment">// 强行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">double</span>&gt;; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure><h3 id="尖括号-“-”">尖括号 “&gt;”</h3><p>在传统 C++ 的编译器中，<code>&gt;&gt;</code>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br></pre></td></tr></table></figure><p>这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。甚至于像下面这种写法都能够通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line">    <span class="type">bool</span> magic = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main function:</span></span><br><span class="line">std::vector&lt;MagicType&lt;(1&gt;<span class="number">2</span>)&gt;&gt; magic; <span class="comment">// 合法, 但不建议写出这样的代码</span></span><br></pre></td></tr></table></figure><h3 id="类型别名模板">类型别名模板</h3><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：**模板是用来产生类型的。**在传统 C++ 中，<code>typedef</code> 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T dark;</span><br><span class="line">    U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure><p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：</p><blockquote><p>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</p></blockquote><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int <span class="comment">(*process)(void *)</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">using</span> NewProcess = int<span class="comment">(*)(void *)</span><span class="punctuation">;</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;<span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">int main() <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    TrueDarkMagic&lt;bool&gt; you;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="变长参数模板">变长参数模板</h3><p>模板一直是 C++ 所独有的<strong>黑魔法</strong>（一起念：<strong>Dark Magic</strong>）之一。 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure><p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span>&lt;<span class="type">int</span>,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">            std::map&lt;std::string,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; darkMagic;</span><br></pre></td></tr></table></figure><p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。</p><p>如果不希望产生的模板参数个数为 <code>0</code>，可以手动的定义至少一个模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure><p>变长参数模板也能被直接调整到到模板函数上。传统 C 中的 <code>printf</code> 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 <code>printf</code> 的函数能自然地处理非自带类别的对象。 除了在模板参数中能使用 <code>...</code> 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> std::string &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure><p>那么我们定义了变长的模板参数，如何对参数进行解包呢？</p><p>首先，我们可以使用 <code>sizeof...</code> 来计算参数的个数，：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以传递任意个参数给 <code>magic</code> 函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">magic</span>(); <span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>); <span class="comment">// 输出1</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>, &quot;&quot;); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p><p><strong>1. 递归模板函数</strong></p><p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 变参模板展开</strong></p><p>你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 <code>printf</code> 的编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t0 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 <code>std::bind</code> 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</p></blockquote><p><strong>3. 初始化列表展开</strong></p><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p><p>这里介绍一种使用初始化列表展开的黑魔法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    (<span class="type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">        std::cout &lt;&lt; args &lt;&lt; std::endl;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到）。</p><p>通过初始化列表，<code>(lambda 表达式, value)...</code> 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。 为了避免编译器警告，我们可以将 <code>std::initializer_list</code> 显式的转为 <code>void</code>。</p><h3 id="折叠表达式">折叠表达式</h3><p>C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数推导">非类型模板参数推导</h3><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中模板的参数 <code>T</code> 和 <code>U</code> 为具体的类型。 但还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> BufSize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buffer_t</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">buffer_t</span>&lt;<span class="type">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br></pre></td></tr></table></figure><p>在这种模板参数形式下，我们可以将 <code>100</code> 作为模板的参数进行传递。 在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 <code>auto</code> 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 <code>auto</code> 关键字，让编译器辅助完成具体类型的推导， 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="number">10</span>&gt;();  <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-面向对象">2.6 面向对象</h2><h3 id="委托构造">委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承构造">继承构造</h3><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 <code>using</code> 引入了继承构造函数的概念：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式虚函数重载">显式虚函数重载</h3><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span>()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> SubClass: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span>()</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p><h4 id="override">override</h4><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的其函数签名一致的虚函数，否则将无法通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="final">final</h4><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass1</span> <span class="keyword">final</span>: Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass2</span> : SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass3</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="显式禁用默认函数">显式禁用默认函数</h3><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。 当程序员有需要时，可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。 例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 <code>private</code>。 尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Magic</span>() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">    Magic&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">    <span class="built_in">Magic</span>(<span class="type">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强类型枚举">强类型枚举</h3><p>在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 <code>enum class</code> 的语法进行声明：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="symbol">new_enum</span> : <span class="symbol">unsigned</span> <span class="symbol">int</span> &#123;</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    value3 = <span class="number">100</span>,</span><br><span class="line">    value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (new_enum<span class="number">::</span>value3 == new_enum<span class="number">::</span>value4) &#123;</span><br><span class="line">    // 会输出</span><br><span class="line">    st<span class="number">d::</span>cout &lt;&lt; &quot;new_enum<span class="number">::</span>value3 == new_enum<span class="number">::</span>value4&quot; &lt;&lt; st<span class="number">d::</span>endl<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 <code>int</code>）。</p><p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出，可以收藏下面这个代码段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">        std::ostream&gt;::type&amp; stream, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，下面的代码将能够被编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都需要了解并熟练使用的：</p><ol><li><code>auto</code> 类型推导</li><li>范围 <code>for</code> 迭代</li><li>初始化列表</li><li>变参模板</li></ol><h2 id="习题">习题</h2><ol><li><p>使用结构化绑定，仅用一行函数内代码实现如下函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(std::map&lt;Key, Value&gt;&amp; m, F foo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt; m &#123;</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;c&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">update</span>(m, [](std::string key) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::hash&lt;std::string&gt;&#123;&#125;(key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [key, value] : m)</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尝试用<a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F">折叠表达式</a>实现用于计算均值的函数，传入允许任意参数</p></li></ol><h1>第 3 章 语言运行期的强化</h1><h2 id="3-1-Lambda-表达式">3.1 Lambda 表达式</h2><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p><h3 id="基础">基础</h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[捕获列表]</span>(参数列表) <span class="built_in">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h4 id="1-值捕获">1. 值捕获</h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用捕获">2. 引用捕获</h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-隐式捕获">3. 隐式捕获</h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;] 引用捕获, 让编译器自行推导引用列表</li><li>[=] 值捕获, 让编译器自行推导值捕获列表</li></ul><h4 id="4-表达式捕获">4. 表达式捕获</h4><blockquote><p>这部分内容需要了解后面马上要提到的右值引用以及智能指针</p></blockquote><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p><h3 id="泛型-Lambda">泛型 Lambda</h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto <span class="built_in">add</span> = [](auto x, auto y) &#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(1, 2);</span><br><span class="line"><span class="built_in">add</span>(1.1, 2.2);</span><br></pre></td></tr></table></figure><h2 id="3-2-函数对象包装器">3.2 函数对象包装器</h2><p>这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力， 这部分内容也相当重要，所以放到这里来进行介绍。</p><h3 id="std-function"><code>std::function</code></h3><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>); <span class="comment">// 定义函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p><p>C++11 <code>std::function</code> 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = [&amp;](<span class="type">int</span> value) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-bind-和-std-placeholder"><code>std::bind</code> 和 <code>std::placeholder</code></h3><p>而 <code>std::bind</code> 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数1,2绑定到函数 foo 上，</span></span><br><span class="line">    <span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**提示：**注意 <code>auto</code> 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 <code>auto</code> 的使用来规避这一问题的出现。</p></blockquote><h2 id="3-3-右值引用">3.3 右值引用</h2><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题， 消除了诸如 <code>std::vector</code>、<code>std::string</code> 之类的额外开销， 也才使得函数对象容器 <code>std::function</code> 成为了可能。</p><h3 id="左值、右值的纯右值、将亡值、右值">左值、右值的纯右值、将亡值、右值</h3><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p><p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p><p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p><p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 <code>10</code>, <code>true</code>； 要么是求值结果相当于字面量或匿名临时对象，例如 <code>1+2</code>。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。</p><p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 <code>const char</code> 数组。例如：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;type_traits&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    // 正确，<span class="string">&quot;01234&quot;</span> 类型为 <span class="keyword">const</span> <span class="type">char</span> [<span class="number">6</span>]，因此是左值</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> (&amp;left)[<span class="number">6</span>] = <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    // 断言正确，确实是 <span class="keyword">const</span> <span class="type">char</span> [<span class="number">6</span>] 类型，注意 decltype(<span class="type">expr</span>) 在 <span class="type">expr</span> 是左值</span><br><span class="line">    // 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span><br><span class="line">    static_assert(std::is_same&lt;decltype(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="type">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    // 错误，<span class="string">&quot;01234&quot;</span> 是左值，不可被右值引用</span><br><span class="line">    // <span class="keyword">const</span> <span class="type">char</span> (&amp;&amp;right)[<span class="number">6</span>] = <span class="string">&quot;01234&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）。例如：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span>*   p   = <span class="string">&quot;01234&quot;</span>;  // 正确，<span class="string">&quot;01234&quot;</span> 被隐式转换为 <span class="keyword">const</span> <span class="type">char</span>*</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span>*&amp;&amp; pr  = <span class="string">&quot;01234&quot;</span>;  // 正确，<span class="string">&quot;01234&quot;</span> 被隐式转换为 <span class="keyword">const</span> <span class="type">char</span>*，该转换的结果是纯右值</span><br><span class="line">// <span class="keyword">const</span> <span class="type">char</span>*&amp; pl = <span class="string">&quot;01234&quot;</span>; // 错误，此处不存在 <span class="keyword">const</span> <span class="type">char</span>* 类型的左值</span><br></pre></td></tr></table></figure><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><p>将亡值可能稍有些难以理解，我们来看这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure><p>在这样的代码中，就传统的理解而言，函数 <code>foo</code> 的返回值 <code>temp</code> 在内部创建然后被赋值给 <code>v</code>， 然而 <code>v</code> 获得这个对象时，会将整个 <code>temp</code> 拷贝一份，然后把 <code>temp</code> 销毁，如果这个 <code>temp</code> 非常大， 这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，<code>v</code> 是左值、 <code>foo()</code> 返回的值就是右值（也是纯右值）。但是，<code>v</code> 可以被别的变量捕获到， 而 <code>foo()</code> 产生的那个返回值作为一个临时值，一旦被 <code>v</code> 复制后，将立即被销毁，无法获取、也不能修改。 而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。</p><p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 <code>temp</code> 会被进行此隐式右值转换， 等价于 <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>，进而此处的 <code>v</code> 会将 <code>foo</code> 局部返回的值进行移动。 也就是后面我们将会提到的移动语义。</p><h3 id="右值引用和左值引用">右值引用和左值引用</h3><p>要拿到一个将亡值，就需要用到右值引用：<code>T &amp;&amp;</code>，其中 <code>T</code> 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// 合法, std::move可以将左值转移为右值</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl; <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl; <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">    rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rv2</code> 虽然引用了一个右值，但由于它是一个引用，所以 <code>rv2</code> 依然是一个左值。</p><p>注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int &amp;a = std::move(1);    // 不合法，非常量左引用无法引用右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// 合法, 常量左引用允许引用右值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span>(<span class="params"><span class="built_in">int</span> &amp; v</span>)</span> &#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">double</span> s = <span class="number">1</span>;</span><br><span class="line">    increase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>int&amp;</code> 不能引用 <code>double</code> 类型的参数，因此必须产生一个临时值来保存 <code>s</code> 的值， 从而当 <code>increase()</code> 修改这个临时值时，调用完成后 <code>s</code> 本身并没有被修改。</p><p>第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要。</p><h3 id="移动语义">移动语义</h3><p>传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</p><p>传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *pointer;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.pointer)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123;</span><br><span class="line">        a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="type">bool</span> test)</span> </span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    <span class="keyword">if</span>(test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;     <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ol><li>首先会在 <code>return_rvalue</code> 内部构造两个 <code>A</code> 对象，于是获得两个构造函数的输出；</li><li>函数返回后，产生一个将亡值，被 <code>A</code> 的移动构造（<code>A(A&amp;&amp;)</code>）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 <code>obj</code> 中，而将亡值的指针被设置为 <code>nullptr</code>，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span></span><br><span class="line">    <span class="comment">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span></span><br><span class="line">    <span class="comment">// 这步操作后, str 中的值会变为空</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: &quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美转发">完美转发</h3><p>前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通传参:&quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>); <span class="comment">// 1是右值, 但输出是左值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>pass(1)</code> 来说，虽然传递的是右值，但由于 <code>v</code> 是一个引用，所以同时也是左值。 因此 <code>reference(v)</code> 会调用 <code>reference(int&amp;)</code>，输出『左值』。 而对于<code>pass(l)</code>而言，<code>l</code>是一个左值，为什么会成功传递给 <code>pass(T&amp;&amp;)</code> 呢？</p><p>这是基于<strong>引用坍缩规则</strong>的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：</p><table><thead><tr><th style="text-align:left">函数形参类型</th><th style="text-align:left">实参参数类型</th><th style="text-align:left">推导后函数形参类型</th></tr></thead><tbody><tr><td style="text-align:left">T&amp;</td><td style="text-align:left">左引用</td><td style="text-align:left">T&amp;</td></tr><tr><td style="text-align:left">T&amp;</td><td style="text-align:left">右引用</td><td style="text-align:left">T&amp;</td></tr><tr><td style="text-align:left">T&amp;&amp;</td><td style="text-align:left">左引用</td><td style="text-align:left">T&amp;</td></tr><tr><td style="text-align:left">T&amp;&amp;</td><td style="text-align:left">右引用</td><td style="text-align:left">T&amp;&amp;</td></tr></tbody></table><p>因此，模板函数中使用 <code>T&amp;&amp;</code> 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。 更准确的讲，<strong>无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型</strong>。 这才使得 <code>v</code> 作为左值的成功传递。</p><p>完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 <code>std::forward</code> 来进行参数的转发（传递）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;              普通传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;       std::move 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;    std::forward 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传递右值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 右值引用</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt; 传参: 右值引用</span><br><span class="line">传递左值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 左值引用</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt; 传参: 左值引用</span><br></pre></td></tr></table></figure><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，<code>std::move</code> 总会接受到一个左值，从而转发调用了<code>reference(int&amp;&amp;)</code> 输出右值引用。</p><p>唯独 <code>std::forward</code> 即没有造成任何多余的拷贝，同时<strong>完美转发</strong>(传递)了函数的实参给了内部调用的其他函数。</p><p><code>std::forward</code> 和 <code>std::move</code> 一样，没有做任何事情，<code>std::move</code> 单纯的将左值转化为右值， <code>std::forward</code> 也只是单纯的将参数做了一个类型的转换，从现象上来看， <code>std::forward&lt;T&gt;(v)</code> 和 <code>static_cast&lt;T&amp;&amp;&gt;(v)</code> 是完全一样的。</p><p>读者可能会好奇，为何一条语句能够针对两种类型的返回对应的值， 我们再简单看一看 <code>std::forward</code> 的具体实现机制，<code>std::forward</code> 包含两个重载：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_Tp</span>&gt;</span><br><span class="line">constexpr <span class="variable">_Tp</span>&amp;&amp; forward(<span class="built_in">typename</span> std::remove_reference&lt;<span class="variable">_Tp</span>&gt;::<span class="built_in">type</span>&amp; <span class="variable">__t</span>) noexcept</span><br><span class="line">&#123; return static_cast&lt;<span class="variable">_Tp</span>&amp;&amp;&gt;(<span class="variable">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_Tp</span>&gt;</span><br><span class="line">constexpr <span class="variable">_Tp</span>&amp;&amp; forward(<span class="built_in">typename</span> std::remove_reference&lt;<span class="variable">_Tp</span>&gt;::<span class="built_in">type</span>&amp;&amp; <span class="variable">__t</span>) noexcept</span><br><span class="line">&#123;</span><br><span class="line">    static_assert(!std::is_lvalue_reference&lt;<span class="variable">_Tp</span>&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    return static_cast&lt;<span class="variable">_Tp</span>&amp;&amp;&gt;(<span class="variable">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份实现中，<code>std::remove_reference</code> 的功能是消除类型中的引用， <code>std::is_lvalue_reference</code> 则用于检查类型推导是否正确，在 <code>std::forward</code> 的第二个实现中 检查了接收到的值确实是一个左值，进而体现了坍缩规则。</p><p>当 <code>std::forward</code> 接受左值时，<code>_Tp</code> 被推导为左值，所以返回值为左值；而当其接受右值时， <code>_Tp</code> 被推导为 右值引用，则基于坍缩规则，返回值便成为了 <code>&amp;&amp; + &amp;&amp;</code> 的右值。 可见 <code>std::forward</code> 的原理在于巧妙的利用了模板类型推导中产生的差异。</p><p>这时我们能回答这样一个问题：为什么在使用循环语句的过程中，<code>auto&amp;&amp;</code> 是最安全的方式？ 因为当 <code>auto</code> 被推导为不同的左右引用时，与 <code>&amp;&amp;</code> 的坍缩组合是完美转发。</p><h2 id="总结-2">总结</h2><p>本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性都是值得掌握的：</p><ol><li>Lambda 表达式</li><li>函数对象容器 std::function</li><li>右值引用</li></ol><h1>第 4 章 容器</h1><h2 id="4-1-线性容器">4.1 线性容器</h2><h3 id="std-array"><code>std::array</code></h3><p>看到这个容器的时候肯定会出现这样的问题：</p><ol><li>为什么要引入 <code>std::array</code> 而不是直接使用 <code>std::vector</code>？</li><li>已经有了传统数组，为什么要用 <code>std::array</code>?</li></ol><p>先回答第一个问题，与 <code>std::vector</code> 不同，<code>std::array</code> 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 <code>std::array</code> 容器。 另外由于 <code>std::vector</code> 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 <code>shrink_to_fit()</code> 释放这部分内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下可看出 std::vector 的存储是自动管理的，按需自动扩张</span></span><br><span class="line"><span class="comment">// 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的自动扩张逻辑与 Golang 的 slice 很像</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还</span></span><br><span class="line">v.<span class="built_in">clear</span>();                                             </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外内存可通过 shrink_to_fit() 调用返回给系统</span></span><br><span class="line">v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure><p>而第二个问题就更加简单，使用 <code>std::array</code> 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 <code>std::sort</code>。</p><p>使用 <code>std::array</code> 很简单，只需指定其类型和大小即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="built_in">empty</span>(); <span class="comment">// 检查容器是否为空</span></span><br><span class="line">arr.<span class="built_in">size</span>();  <span class="comment">// 返回容纳的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 lambda 表达式排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组大小参数必须是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法,不同于 C 风格数组，std::array 不会自动退化成 T*</span></span><br><span class="line"><span class="comment">// int *arr_p = arr;</span></span><br></pre></td></tr></table></figure><p>当我们开始用上了 <code>std::array</code> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">foo</span>(int *p, int len) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;int, <span class="number">4</span>&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 风格接口传参</span></span><br><span class="line"><span class="comment">// foo(arr, arr.size()); // 非法, 无法隐式转换</span></span><br><span class="line"><span class="built_in">foo</span>(&amp;arr[<span class="number">0</span>], arr.size());</span><br><span class="line"><span class="built_in">foo</span>(arr.data(), arr<span class="selector-class">.size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `std::sort`</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="std-forward-list"><code>std::forward_list</code></h3><p><code>std::forward_list</code> 是一个列表容器，使用方法和 <code>std::list</code> 基本类似，因此我们就不花费篇幅进行介绍了。</p><p>需要知道的是，和 <code>std::list</code> 的双向链表的实现不同，<code>std::forward_list</code> 使用单向链表进行实现， 提供了 <code>O(1)</code> 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 <code>size()</code> 方法的容器。当不需要双向迭代时，具有比 <code>std::list</code> 更高的空间利用率。</p><h2 id="4-2-无序容器">4.2 无序容器</h2><p>我们已经熟知了传统 C++ 中的有序容器 <code>std::map</code>/<code>std::set</code>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 <code>O(log(size))</code>。在插入元素时候，会根据 <code>&lt;</code> 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 <code>&lt;</code> 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>， 在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：<code>std::unordered_map</code>/<code>std::unordered_multimap</code> 和 <code>std::unordered_set</code>/<code>std::unordered_multiset</code>。</p><p>它们的用法和原有的 <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code> 基本类似， 由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下<code>std::map</code>和<code>std::unordered_map</code>：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两组结构按同样的顺序初始化</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; u = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; v = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别对两组结构进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unordered_map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> <span class="keyword">auto</span> &amp; n : u)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> <span class="keyword">auto</span> &amp; n : v)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">std</span>::unordered_map</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">2</span>] Value:[<span class="number">2</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">3</span>] Value:[<span class="number">3</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">1</span>] Value:[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="attribute">std</span>::map</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">1</span>] Value:[<span class="number">1</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">2</span>] Value:[<span class="number">2</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">3</span>] Value:[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="4-3-元组">4.3 元组</h2><p>了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 <code>std::pair</code> 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 <code>std::pair</code> 的缺陷是显而易见的，只能保存两个元素。</p><h3 id="元组基本操作">元组基本操作</h3><p>关于元组的使用有三个核心的函数：</p><ol><li><code>std::make_tuple</code>: 构造元组</li><li><code>std::get</code>: 获得元组某个位置的值</li><li><code>std::tie</code>: 元组拆包</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">3.8</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">2.9</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1.7</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0.0</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> student = <span class="built_in">get_student</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(student) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> gpa;</span><br><span class="line">    <span class="type">char</span> grade;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组进行拆包</span></span><br><span class="line">    std::<span class="built_in">tie</span>(gpa, grade, name) = <span class="built_in">get_student</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::get</code> 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">double</span>, <span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;123&quot;</span>, <span class="number">4.5</span>, <span class="number">6.7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(t) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(t) &lt;&lt; std::endl; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(t) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="运行期索引">运行期索引</h3><p>如果你仔细思考一下可能就会发现上面代码的问题，<code>std::get&lt;&gt;</code> 依赖一个编译期的常量，所以下面的方式是不合法的：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">index</span> = <span class="number">1</span>;</span><br><span class="line">s<span class="symbol">td:</span><span class="symbol">:ge</span><span class="built_in">t</span>&lt;<span class="built_in">index</span>&gt;(<span class="built_in">t</span>);</span><br></pre></td></tr></table></figure><p>那么要怎么处理？答案是，使用 <code>std::variant&lt;&gt;</code>（C++ 17 引入），提供给 <code>variant&lt;&gt;</code> 的类型模板参数 可以让一个 <code>variant&lt;&gt;</code> 从而容纳提供的几种类型的变量（在其他语言，例如 Python/JavaScript 等，表现为动态类型）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> n, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; _tuple_index(<span class="type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(n &gt;= <span class="keyword">sizeof</span>...(T))</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throw</span> <span class="title">std::out_of_range</span><span class="params">(<span class="string">&quot;越界.&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> std::variant&lt;T...&gt;&#123; std::in_place_index&lt;n&gt;, std::<span class="built_in">get</span>&lt;n&gt;(tpl) &#125;;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;(n &lt; <span class="keyword">sizeof</span>...(T)<span class="number">-1</span> ? n+<span class="number">1</span> : <span class="number">0</span>)&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; <span class="title">tuple_index</span><span class="params">(<span class="type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;<span class="number">0</span>&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream &amp; s, std::variant&lt;T0, Ts...&gt; <span class="type">const</span> &amp; v) &#123; </span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span> &amp;&amp; x)&#123; s &lt;&lt; x;&#125;, v); </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">tuple_index</span>(t, i) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="元组合并与遍历">元组合并与遍历</h3><p>还有一个常见的需求就是合并两个元组，这可以通过 <code>std::tuple_cat</code> 来实现：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">auto</span> new_tuple = <span class="title function_">std::tuple_cat</span>(get_student(<span class="number">1</span>), <span class="title function_">std::move</span>(t))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 <code>tuple</code> 那么遍历就变得简单了， 首先我们需要知道一个元组的长度，可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tuple_size&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能够对元组进行迭代了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i != tuple_len(<span class="keyword">new</span><span class="type">_tuple</span>); ++i)</span><br><span class="line">    <span class="comment">// 运行期索引</span></span><br><span class="line">    std:<span class="type"></span>:cout &lt;&lt; tuple_index(<span class="keyword">new</span><span class="type">_tuple</span>, i) &lt;&lt; std:<span class="type"></span>:endl;</span><br></pre></td></tr></table></figure><h2 id="总结-3">总结</h2><p>本章简单介绍了现代 C++ 中新增的容器，它们的用法和传统 C++ 中已有的容器类似，相对简单，可以根据实际场景丰富的选择需要使用的容器，从而获得更好的性能。</p><p><code>std::tuple</code> 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他的方法可以自行实现。</p><h1>第 5 章 智能指针与内存管理</h1><h2 id="5-1-RAII-与引用计数">5.1 RAII 与引用计数</h2><p>了解 <code>Objective-C</code>/<code>Swift</code> 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。</p><p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。</p><p>凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p><blockquote><p>注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。</p></blockquote><h2 id="5-2-std-shared-ptr">5.2 <code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p><p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。</p><p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">    (*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line">    <span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    <span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">foo</span>(pointer);</span><br><span class="line">    std::cout &lt;&lt; *pointer &lt;&lt; std::endl; <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数， 并通过<code>use_count()</code>来查看一个对象的引用计数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="type">int</span> *p = pointer.<span class="built_in">get</span>();  <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">pointer2.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer2 已 reset; 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">pointer3.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer3:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer3 已 reset; 0</span></span><br></pre></td></tr></table></figure><h2 id="5-3-std-unique-ptr">5.3 <code>std::unique_ptr</code></h2><p><code>std::unique_ptr</code> 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; pointer = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><blockquote><p><code>make_unique</code> 并不复杂，C++11 没有提供 <code>std::make_unique</code>，可以自行实现：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename <span class="params">...</span>Args&gt;</span><br><span class="line">std<span class="type">::unique_ptr</span>&lt;T&gt; make_unique( Args&amp;&amp; <span class="params">...</span>args ) &#123;</span><br><span class="line"><span class="keyword">return</span> std<span class="type">::unique_ptr</span>&lt;T&gt;( <span class="literal">new</span> T( std<span class="type">::forward</span>&lt;Args&gt;(args)<span class="params">...</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的<a href="https://herbsutter.com/gotw/_102/">博客</a>中提到原因是因为『被他们忘记了』。</p></blockquote><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code>，例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::~Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Foo::foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Foo &amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f(const Foo&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p1</span><span class="params">(std::make_unique&lt;Foo&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="built_in">f</span>(*p2);</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        <span class="comment">// p1 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        p1 = std::<span class="built_in">move</span>(p2);</span><br><span class="line">        <span class="comment">// p2 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p2 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">// Foo 的实例会在离开作用域时被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-std-weak-ptr">5.4 <code>std::weak_ptr</code></h2><p>如果你仔细思考 <code>std::shared_ptr</code> 就会发现依然存在着资源无法释放的问题。看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;pointer = b;</span><br><span class="line">    b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露，如图 5.1：</p><p><img src="https://changkun.de/modern-cpp/assets/figures/pointers1.png" alt="图 5.1">图 5.1</p><p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图 5.2 所示：</p><p><img src="https://changkun.de/modern-cpp/assets/figures/pointers2.png" alt="图 5.2">图 5.2</p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。</p><p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</p><h2 id="总结-4">总结</h2><p>智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在一定程度上消除了 <code>new</code>/<code>delete</code> 的滥用，是一种更加成熟的编程范式。</p><h1>第 6 章 正则表达式</h1><h2 id="6-1-正则表达式简介">6.1 正则表达式简介</h2><p>正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。</p><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ol><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换；</li><li>从某个串中取出符合条件的子串。</li></ol><p>正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><h3 id="普通字符">普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><h3 id="特殊字符">特殊字符</h3><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">匹配输入字符串的结尾位置。</td></tr><tr><td style="text-align:left"><code>(</code>,<code>)</code></td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式零次或多次。</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式一次或多次。</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符。</td></tr><tr><td style="text-align:left"><code>[</code></td><td style="text-align:left">标记一个中括号表达式的开始。</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td style="text-align:left"><code>\</code></td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>'\'</code> 字符，而 <code>\(</code> 则匹配 <code>'('</code> 字符。</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td></tr><tr><td style="text-align:left"><code>&#123;</code></td><td style="text-align:left">标记限定符表达式的开始。</td></tr><tr><td style="text-align:left">`</td><td style="text-align:left">`</td></tr></tbody></table><h3 id="限定符">限定符</h3><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，<code>foo*</code> 能匹配 <code>fo</code> 以及 <code>foooo</code>。<code>*</code> 等价于<code>&#123;0,&#125;</code>。</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，<code>foo+</code> 能匹配 <code>foo</code> 以及 <code>foooo</code>，但不能匹配 <code>fo</code>。<code>+</code> 等价于 <code>&#123;1,&#125;</code>。</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，<code>Your(s)?</code> 可以匹配 <code>Your</code> 或 <code>Yours</code> 中的<code>Your</code> 。<code>?</code> 等价于 <code>&#123;0,1&#125;</code>。</td></tr><tr><td style="text-align:left"><code>&#123;n&#125;</code></td><td style="text-align:left"><code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。例如，<code>o&#123;2&#125;</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但是能匹配 <code>foo</code> 中的两个 <code>o</code>。</td></tr><tr><td style="text-align:left"><code>&#123;n,&#125;</code></td><td style="text-align:left"><code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但能匹配 <code>foooooo</code> 中的所有 <code>o</code>。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td></tr><tr><td style="text-align:left"><code>&#123;n,m&#125;</code></td><td style="text-align:left"><code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n</code> 小于等于 <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。例如，<code>o&#123;1,3&#125;</code> 将匹配 <code>foooooo</code> 中的前三个 <code>o</code>。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。注意，在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>有了这两张表，我们通常就能够读懂几乎所有的正则表达式了。</p><h2 id="6-2-std-regex-及其相关">6.2 std::regex 及其相关</h2><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。 可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库， 而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时， 使用正则表达式也是工业界最为成熟的普遍做法。</p><p>一般的解决方案就是使用 <code>boost</code> 的正则表达式库。 而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持， 不再依赖第三方。</p><p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象， 模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化， 通过 <code>std::regex_match</code> 进行匹配， 从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）。</p><p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式:</p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, <code>[a-z]</code> 表示匹配一个小写字母, <code>+</code> 可以使前面的表达式匹配多次， 因此 <code>[a-z]+</code> 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 <code>.</code> 表示匹配任意字符，而 <code>\.</code> 则表示匹配字符 <code>.</code>， 最后的 <code>txt</code> 表示严格匹配 <code>txt</code> 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。</li></ul><p><code>std::regex_match</code> 用于匹配字符串和正则表达式，有很多不同的重载形式。 最简单的一个形式就是传入 <code>std::string</code> 以及一个 <code>std::regex</code> 进行匹配， 当匹配成功时，会返回 <code>true</code>，否则返回 <code>false</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line">    <span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line">    <span class="function">std::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line">        std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">regex_match</span>(fname, txt_regex) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种常用的形式就是依次传入 <code>std::string</code>/<code>std::smatch</code>/<code>std::regex</code> 三个参数， 其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。 故而在标准库的实现中， <code>std::smatch</code> 被定义为了 <code>std::match_results&lt;std::string::const_iterator&gt;</code>， 也就是一个子串迭代器类型的 <code>match_results</code>。 使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::regex <span class="built_in">base_regex</span>(<span class="string">&quot;([a-z]+)\\.txt&quot;</span>);</span><br><span class="line">std::smatch base_match;</span><br><span class="line">for(const auto &amp;fname: fnames) &#123;</span><br><span class="line">    if (std::<span class="built_in">regex_match</span>(fname, base_match, base_regex)) &#123;</span><br><span class="line">        // std::smatch 的第一个元素匹配整个字符串</span><br><span class="line">        // std::smatch 的第二个元素匹配了第一个括号表达式</span><br><span class="line">        if (base_match.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            std::string base = base_match[<span class="number">1</span>].<span class="built_in">str</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;sub-match[0]: &quot;</span> &lt;&lt; base_match[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot; sub-match[1]: &quot;</span> &lt;&lt; base &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个代码段的输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo<span class="selector-class">.txt</span>: <span class="number">1</span></span><br><span class="line">bar<span class="selector-class">.txt</span>: <span class="number">1</span></span><br><span class="line">test: <span class="number">0</span></span><br><span class="line">a0<span class="selector-class">.txt</span>: <span class="number">0</span></span><br><span class="line">AAA<span class="selector-class">.txt</span>: <span class="number">0</span></span><br><span class="line">sub-match<span class="selector-attr">[0]</span>: foo<span class="selector-class">.txt</span></span><br><span class="line">foo<span class="selector-class">.txt</span> sub-match<span class="selector-attr">[1]</span>: foo</span><br><span class="line">sub-match<span class="selector-attr">[0]</span>: bar<span class="selector-class">.txt</span></span><br><span class="line">bar<span class="selector-class">.txt</span> sub-match<span class="selector-attr">[1]</span>: bar</span><br></pre></td></tr></table></figure><h2 id="总结-5">总结</h2><p>本节简单介绍了正则表达式本身，然后根据使用正则表达式的主要需求，通过一个实际的例子介绍了正则表达式库的使用。</p><h1>第 7 章 并行与并发</h1><h2 id="7-1-并行基础">7.1 并行基础</h2><p><code>std::thread</code> 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 <code>&lt;thread&gt;</code> 头文件， 它提供了很多基本的线程操作，例如 <code>get_id()</code> 来获取所创建线程的线程 ID，使用 <code>join()</code> 来等待一个线程结束（与该线程汇合）等等，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;hello world.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-互斥量与临界区">7.2 互斥量与临界区</h2><p>我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，<code>mutex</code> 就是其中的核心之一。 C++11 引入了 <code>mutex</code> 相关的类，其所有相关的函数都放在 <code>&lt;mutex&gt;</code> 头文件中。</p><p><code>std::mutex</code> 是 C++11 中最基本的 <code>mutex</code> 类，通过实例化 <code>std::mutex</code> 可以创建互斥量， 而通过其成员函数 <code>lock()</code> 可以进行上锁，<code>unlock()</code> 可以进行解锁。 但是在实际编写代码的过程中，最好不去直接调用成员函数， 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code>，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>。 RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。</p><p>在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> change_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行竞争操作</span></span><br><span class="line">    v = change_v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开此作用域后 mtx 会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。 无论 <code>critical_section()</code> 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 <code>unlock()</code>。</p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的，<code>std::unique_lock</code> 更加灵活， <code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权） 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 <code>std::unique_lock</code>。</p><p><code>std::lock_guard</code> 不能显式的调用 <code>lock</code> 和 <code>unlock</code>， 而 <code>std::unique_lock</code> 可以在声明后的任意位置调用， 可以缩小锁的作用范围，提供更高的并发度。</p><p>如果你用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> change_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 执行竞争操作</span></span><br><span class="line">    v = change_v;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 将锁进行释放</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此期间，任何人都可以抢夺 v 的持有权</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始另一组竞争操作，再次加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    v += <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-期物">7.3 期物</h2><p>期物（Future）表现为 <code>std::future</code>，它提供了一个访问异步操作结果的途径，这句话很不好理解。 为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。</p><p>试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。 而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果， 所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。</p><p>在 C++11 的 <code>std::future</code> 被引入之前，通常的做法是： 创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。 而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程，可以用来获取异步任务的结果。 自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。</p><p>为了看一个例子，我们这里额外使用 <code>std::packaged_task</code>，它可以用来封装任何可以调用的目标，从而用于实现异步的调用。 举例来说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个返回值为7的 lambda 表达式封装到 task 中</span></span><br><span class="line">    <span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 获得 task 的期物</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">    result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障，阻塞到期物的完成</span></span><br><span class="line">    <span class="comment">// 输出执行结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span></span><br><span class="line">              &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装好要调用的目标后，可以使用 <code>get_future()</code> 来获得一个 <code>std::future</code> 对象，以便之后实施线程同步。</p><h2 id="7-4-条件变量">7.4 条件变量</h2><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。 所以，<code>condition_variable</code> 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。 <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程。下面是一个生产者和消费者模型的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; produced_nums;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    <span class="type">bool</span> notified = <span class="literal">false</span>;  <span class="comment">// 通知信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">auto</span> producer = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">900</span>));</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;producing &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            produced_nums.<span class="built_in">push</span>(i);</span><br><span class="line">            notified = <span class="literal">true</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>(); <span class="comment">// 此处也可以使用 notify_one</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">auto</span> consumer = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">            <span class="keyword">while</span> (!notified) &#123;  <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// 消费者慢于生产者</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">            lock.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">while</span> (!produced_nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;consuming &quot;</span> &lt;&lt; produced_nums.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">                produced_nums.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            notified = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别在不同的线程中运行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">p</span><span class="params">(producer)</span></span>;</span><br><span class="line">    std::thread cs[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        cs[i] = std::<span class="built_in">thread</span>(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        cs[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，在生产者中我们虽然可以使用 <code>notify_one()</code>，但实际上并不建议在此处使用， 因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者 争夺此锁，从而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 <code>std::mutex</code> 的排他性， 我们根本无法期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。</p><h2 id="7-5-原子操作与内存模型">7.5 原子操作与内存模型</h2><p>细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况产生疑惑。 例如，布尔值 <code>notified</code> 没有被 <code>volatile</code> 修饰，编译器可能对此变量存在优化，例如将其作为一个寄存器的值， 从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚这个问题，我们需要进一步讨论 从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面这段代码输出结果是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag != <span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> b = a;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        a = <span class="number">5</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        flag = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从直观上看，<code>t2</code> 中 <code>a = 5;</code> 这一条语句似乎总在 <code>flag = 1;</code> 之前得到执行，而 <code>t1</code> 中 <code>while (flag != 1)</code> 似乎保证了 <code>std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;</code> 不会再标记被改变前执行。从逻辑上看，似乎 <code>b</code> 的值应该等于 5。 但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 <code>a</code> 和 <code>flag</code> 而言，他们在两个并行的线程中被读写， 出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响， 导致 <code>a = 5</code> 发生在 <code>flag = 1</code> 之后。从而 <code>b</code> 可能输出 0。</p><h3 id="原子操作">原子操作</h3><p><code>std::mutex</code> 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能， 这是因为一个互斥锁的实现通常包含两条基本原理：</p><ol><li>提供线程间自动的状态转换，即『锁住』这个状态</li><li>保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离</li></ol><p>这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令（我们之后再来看如何实现一个简单的互斥锁）。 这对于一个仅需原子级操作（没有中间态）的变量，似乎太苛刻了。</p><p>关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，现代 CPU 体系结构提供了 CPU 指令级的原子操作， 因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 <code>std::atomic</code> 模板，使得我们实例化一个原子类型，将一个 原子类型读写操作从一组指令，最小化到单个 CPU 指令。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter;</span><br></pre></td></tr></table></figure><p>并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说， 包括 <code>fetch_add</code>, <code>fetch_sub</code> 等，同时通过重载方便的提供了对应的 <code>+</code>，<code>-</code> 版本。 比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        count.fetch_add(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        count++;        <span class="comment">// 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">        count += <span class="number">1</span>;     <span class="comment">// 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐 条件的要求，因而我们总是可以通过 <code>std::atomic&lt;T&gt;::is_lock_free</code> 来检查该原子类型是否需支持原子操作，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;A&gt; a;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; a.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性模型">一致性模型</h3><p>并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。 在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。</p><p>如果我们强行将一个变量 <code>v</code> 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 <code>v</code> 后， 其他线程均能<strong>同步</strong>感知到 <code>v</code> 的变化，则对于变量 <code>v</code> 而言，表现为顺序执行的程序，它并没有由于引入多线程 而得到任何效率上的收益。对此有什么办法能够适当的加速呢？答案便是削弱原子操作的在进程间的同步条件。</p><p>从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。 削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型：</p><ol><li><p>线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">1</span>)      <span class="keyword">x</span>.<span class="keyword">load</span>()</span><br><span class="line">T<span class="number">1</span> ---------+----------------+------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T<span class="number">2</span> -------------------+-------------&gt;</span><br><span class="line">                <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在这种情况下线程 <code>T1</code>, <code>T2</code> 对 <code>x</code> 的两次写操作是原子的，且 <code>x.store(1)</code> 是严格的发生在 <code>x.store(2)</code> 之前，<code>x.store(2)</code> 严格的发生在 <code>x.load()</code> 之前。 值得一提的是，线性一致性对全局时钟的要求是难以实现的，这也是人们不断研究比这个一致性更弱条件下其他一致性的算法的原因。</p></li><li><p>顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">1</span>)  <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">3</span>)   <span class="keyword">x</span>.<span class="keyword">load</span>()</span><br><span class="line">T<span class="number">1</span> ---------+-----------+----------+-----&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T<span class="number">2</span> ---------------+----------------------&gt;</span><br><span class="line">              <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">        <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">1</span>)  <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">3</span>)   <span class="keyword">x</span>.<span class="keyword">load</span>()</span><br><span class="line">T<span class="number">1</span> ---------+-----------+----------+-----&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T<span class="number">2</span> ------+-------------------------------&gt;</span><br><span class="line">      <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在顺序一致性的要求下，<code>x.load()</code> 必须读到最近一次写入的数据，因此 <code>x.store(2)</code> 与 <code>x.store(1)</code> 并无任何先后保障，即 只要 <code>T2</code> 的 <code>x.store(2)</code> 发生在 <code>x.store(3)</code> 之前即可。</p></li><li><p>因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      a = <span class="number">1</span>      b = <span class="number">2</span></span><br><span class="line"><span class="type">T1</span> ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ------+--------------------+--------+--------&gt;</span><br><span class="line">      x.store(<span class="number">3</span>)         c = a + b    y.load()</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">      a = <span class="number">1</span>      b = <span class="number">2</span></span><br><span class="line"><span class="type">T1</span> ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ------+--------------------+--------+--------&gt;</span><br><span class="line">      x.store(<span class="number">3</span>)          y.load()   c = a + b</span><br><span class="line"></span><br><span class="line">亦或者</span><br><span class="line"></span><br><span class="line">     b = <span class="number">2</span>       a = <span class="number">1</span></span><br><span class="line"><span class="type">T1</span> ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ------+--------------------+--------+--------&gt;</span><br><span class="line">      y.load()            c = a + b  x.store(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 <code>c</code> 对 <code>a</code> 和 <code>b</code> 产生依赖，而 <code>x</code> 和 <code>y</code> 在此例子中表现为没有关系（但实际情况中我们需要更详细的信息才能确定 <code>x</code> 与 <code>y</code> 确实无关）</p></li><li><p>最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。当然这已经不在我们的讨论范围之内了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    x.store(<span class="number">3</span>)  x.store(<span class="number">4</span>)</span><br><span class="line"><span class="type">T1</span> ----+-----------+--------------------------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ---------+------------+--------------------+--------+--------&gt;</span><br><span class="line">         x.read      x.read()           x.read()   x.read()</span><br></pre></td></tr></table></figure><p>在上面的情况中，如果我们假设 x 的初始值为 0，则 <code>T2</code> 中四次 <code>x.read()</code> 结果可能但不限于以下情况：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3<span class="number"> 4 </span>4<span class="number"> 4 </span>// x 的写操作被很快观察到</span><br><span class="line">0<span class="number"> 3 </span>3<span class="number"> 4 </span>// x 的写操作被观察到的时间存在一定延迟</span><br><span class="line">0<span class="number"> 0 </span>0<span class="number"> 4 </span>// 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到</span><br><span class="line">0<span class="number"> 0 </span>0<span class="number"> 0 </span>// 在当前时间段内 x 的写操作均未被观察到，</span><br><span class="line">        // 但未来某个时间点上一定能观察到 x 为<span class="number"> 4 </span>的情况</span><br></pre></td></tr></table></figure></li></ol><h3 id="内存顺序">内存顺序</h3><p>为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 <code>std::memory_order</code> 的选项，表达了四种多线程间的同步模型：</p><ol><li><p>宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过 <code>std::memory_order_relaxed</code> 指定。我们来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;std::thread&gt; vt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    vt.<span class="built_in">emplace_back</span>([&amp;]()&#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;current counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li><p>释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 <code>x</code> 的写操作，线程 <code>B</code> 仅依赖其中第三次 <code>x</code> 的写操作，与 <code>x</code> 的前两次写行为无关，则当 <code>A</code> 主动 <code>x.release()</code> 时候（即使用 <code>std::memory_order_release</code>），选项 <code>std::memory_order_consume</code> 能够确保 <code>B</code> 在调用 <code>x.load()</code> 时候观察到 <code>A</code> 中第三次对 <code>x</code> 的写操作。我们来看一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化为 nullptr 防止 consumer 线程从野指针进行读取</span></span><br><span class="line">std::<span class="variable constant_">atomic</span>&lt;<span class="keyword">int</span>*&gt; <span class="title function_ invoke__">ptr</span>(nullptr);</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line">std::<span class="variable constant_">thread</span> <span class="title function_ invoke__">producer</span>([&amp;]() &#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</span><br><span class="line">    v = <span class="number">1024</span>;</span><br><span class="line">    ptr.<span class="title function_ invoke__">store</span>(p, std::<span class="variable constant_">memory_order_release</span>);</span><br><span class="line">&#125;);</span><br><span class="line">std::<span class="variable constant_">thread</span> <span class="title function_ invoke__">consumer</span>([&amp;]() &#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">while</span>(!(p = ptr.<span class="title function_ invoke__">load</span>(std::<span class="variable constant_">memory_order_consume</span>)));</span><br><span class="line"></span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line">&#125;);</span><br><span class="line">producer.<span class="title function_ invoke__">join</span>();</span><br><span class="line">consumer.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure></li><li><p>释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 <code>std::memory_order_release</code> 和获取 <code>std::memory_order_acquire</code> 之间规定时序，即发生在释放（release）操作之前的<strong>所有</strong>写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。</p><p>可以看到，<code>std::memory_order_release</code> 确保了它之前的写操作不会发生在释放操作之后，是一个向后的屏障（backward），而 <code>std::memory_order_acquire</code> 确保了它之前的写行为不会发生在该获取操作之后，是一个向前的屏障（forward）。对于选项 <code>std::memory_order_acq_rel</code> 而言，则结合了这两者的特点，唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排并越过此操作的前后：</p><p>我们来看一个例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::thread <span class="title">release</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    v.push_back(<span class="number">42</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    flag.store(<span class="number">1</span>, std::memory_order_release);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">acqrel</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> expected = <span class="number">1</span>; <span class="comment">// must before compare_exchange_strong</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_acq_rel))</span></span></span><br><span class="line"><span class="params"><span class="function">        expected = <span class="number">1</span>; <span class="comment">// must after compare_exchange_strong</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// flag has changed to 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">acquire</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; v.at(<span class="number">0</span>) &lt;&lt; std::endl; <span class="comment">// must be 42</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">release.<span class="built_in">join</span>();</span><br><span class="line">acqrel.<span class="built_in">join</span>();</span><br><span class="line">acquire.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>在此例中我们使用了 <code>compare_exchange_strong</code> 比较交换原语（Compare-and-swap primitive），它有一个更弱的版本，即 <code>compare_exchange_weak</code>，它允许即便交换成功，也仍然返回 <code>false</code> 失败。其原因是因为在某些平台上虚假故障导致的，具体而言，当 CPU 进行上下文切换时，另一线程加载同一地址产生的不一致。除此之外，<code>compare_exchange_strong</code> 的性能可能稍差于 <code>compare_exchange_weak</code>，但大部分情况下，鉴于其使用的复杂度而言，<code>compare_exchange_weak</code> 应该被有限考虑。</p></li><li><p>顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 <code>std::memory_order_seq_cst</code> 进行指定。最后来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;std::thread&gt; vt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    vt.<span class="built_in">emplace_back</span>([&amp;]()&#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;current counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这个例子与第一个宽松模型的例子本质上没有区别，仅仅只是将原子操作的内存顺序修改为了 <code>memory_order_seq_cst</code>，有兴趣的读者可以自行编写程序测量这两种不同内存顺序导致的性能差异。</p></li></ol><h2 id="总结-6">总结</h2><p>C++11 语言层提供了并发编程的相关支持，本节简单的介绍了 <code>std::thread</code>, <code>std::mutex</code>, <code>std::future</code> 这些并发编程中不可回避的重要工具。 除此之外，我们还介绍了 C++11 最重要的几个特性之一的『内存模型』， 它们为 C++ 在标准化高性能计算中提供了重要的基础。</p><ol><li><p>请编写一个简单的线程池，提供如下功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadPool <span class="title">p</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 指定四个工作线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务在池中入队，并返回一个 std::future</span></span><br><span class="line"><span class="keyword">auto</span> f = pool.<span class="built_in">enqueue</span>([](<span class="type">int</span> life) &#123;</span><br><span class="line">    <span class="keyword">return</span> meaning;</span><br><span class="line">&#125;, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 future 中获得执行结果</span></span><br><span class="line">std::cout &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li><p>请使用 <code>std::atomic&lt;bool&gt;</code> 实现一个互斥锁。</p></li></ol><h1>第 8 章 文件系统</h1><p>文件系统库提供了文件系统、路径、常规文件、目录等等相关组件进行操作的相关功能。和正则表达式库类似，他也是最先由 boost 发起，并最终被合并为 C++ 标准的众多库之一。</p><h1>第 9 章 其他杂项</h1><h2 id="9-1-新类型">9.1 新类型</h2><h3 id="long-long-int"><code>long long int</code></h3><p><code>long long int</code> 并不是 C++11 最先引入的，其实早在 C99， <code>long long int</code> 就已经被纳入 C 标准中，所以大部分的编译器早已支持。 C++11 的工作则是正式把它纳入标准库， 规定了一个 <code>long long int</code> 类型至少具备 64 位的比特数。</p><h2 id="9-2-noexcept-的修饰和操作">9.2 noexcept 的修饰和操作</h2><p>C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。 然而在 C++11 之前，几乎没有人去使用在函数名后书写异常声明表达式， 从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用， 你更不应该主动去了解它。</p><p>C++11 将异常的声明简化为以下两种情况：</p><ol><li>函数可能抛出任何异常</li><li>函数不能抛出任何异常</li></ol><p>并使用 <code>noexcept</code> 对这两种行为进行限制，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">may_throw</span>()</span>; <span class="comment">// 可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_throw</span>() noexcept</span>; <span class="comment">// 不可能抛出异常</span></span><br></pre></td></tr></table></figure><p>使用 <code>noexcept</code> 修饰过的函数如果抛出异常，编译器会使用 <code>std::terminate()</code> 来立即终止程序运行。</p><p><code>noexcept</code> 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> non_block_throw = []&#123;</span><br><span class="line">    <span class="built_in">may_throw</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> block_throw = []() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">no_throw</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha</span><br><span class="line">        &lt;&lt; <span class="string">&quot;may_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">may_throw</span>()) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;no_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">no_throw</span>()) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;lmay_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">non_block_throw</span>()) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;lno_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">block_throw</span>()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>noexcept</code> 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。例如：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    may_throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;捕获异常, 来自 may_throw()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    non_block_throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;捕获异常, 来自 non_block_throw()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    block_throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;捕获异常, 来自 block_throw()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获异常, 来自 <span class="built_in">may_throw</span>()</span><br><span class="line">捕获异常, 来自 <span class="built_in">non_block_throw</span>()</span><br></pre></td></tr></table></figure><h2 id="9-3-字面量">9.3 字面量</h2><h3 id="原始字符串字面量">原始字符串字面量</h3><p>传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情， 比如一个包含 HTML 本体的字符串需要添加大量的转义符， 例如一个Windows 上的文件路径经常会：<code>C:\\File\\To\\Path</code>。</p><p>C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 <code>R</code> 来修饰这个字符串， 同时，将原始字符串使用括号包裹，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    std::string <span class="built_in">str</span> = <span class="string">R&quot;(C:\File\To\Path)&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">str</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义字面量">自定义字面量</h3><p>C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 字符串字面量自定义必须设置如下的参数列表</span><br><span class="line">std::string operato<span class="string">r&quot;&quot;</span> _wow1(const char *wow1, size_t <span class="built_in">len</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::string(wow1)+<span class="string">&quot;woooooooooow, amazing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string operato<span class="string">r&quot;&quot;</span> _wow2 (unsigned long long i) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::to_string(i)+<span class="string">&quot;woooooooooow, amazing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    auto <span class="built_in">str</span> = <span class="string">&quot;abc&quot;</span>_wow1;</span><br><span class="line">    auto num = 1_wow2;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">str</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义字面量支持四种字面量：</p><ol><li>整型字面量：重载时必须使用 <code>unsigned long long</code>、<code>const char *</code>、模板字面量算符参数，在上面的代码中使用的是前者；</li><li>浮点型字面量：重载时必须使用 <code>long double</code>、<code>const char *</code>、模板字面量算符；</li><li>字符串字面量：必须使用 <code>(const char *, size_t)</code> 形式的参数表；</li><li>字符字面量：参数只能是 <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code> 这几种类型。</li></ol><h2 id="9-4-内存对齐">9.4 内存对齐</h2><p>C++ 11 引入了两个新的关键字 <code>alignof</code> 和 <code>alignas</code> 来支持对内存对齐进行控制。 <code>alignof</code> 关键字能够获得一个与平台相关的 <code>std::size_t</code> 类型的值，用于查询该平台的对齐方式。 当然我们有时候并不满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 <code>alignas</code> 来重新修饰某个结构的对齐方式。我们来看两个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="type">char</span>      a;</span><br><span class="line">    <span class="type">int</span>       b;</span><br><span class="line">    <span class="type">double</span>    c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(std::<span class="type">max_align_t</span>) AlignasStorage &#123;</span><br><span class="line">    <span class="type">char</span>      a;</span><br><span class="line">    <span class="type">int</span>       b;</span><br><span class="line">    <span class="type">double</span>    c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(Storage) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(AlignasStorage) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>std::max_align_t</code> 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 <code>long double</code>，因此我们这里得到的 <code>AlignasStorage</code> 的对齐要求是 8 或 16。</p><h2 id="总结-7">总结</h2><p>本节介绍的几个特性是从仍未介绍的现代 C++ 新特性里使用频次较靠前的特性了，<code>noexcept</code> 是最为重要的特性，它的一个功能在于能够阻止异常的扩散传播，有效的让编译器最大限度的优化我们的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hellow World</title>
      <link href="/posts/659c4f50.html"/>
      <url>/posts/659c4f50.html</url>
      
        <content type="html"><![CDATA[<h1>Hello World</h1><p>这是我第二次使用<a href="https://hexo.io/">Hexo</a>框架使用github搭建博客，PS：之前的Hexo有点搞，被我狠狠的删除了</p><p>当前采用的主题是<a href="https://github.com/jerryc127/hexo-theme-butterfly">ButterFly</a></p><p>参考<a href="https://github.com/fomalhaut1998/hexo-theme-Fomalhaut">hexo-theme-Fomalhaut</a>在上面添加了属于自己的小样式</p><p>之后会将这阶段看过的书籍以及知识以随笔的形式记录在博客中，方便之后复习（ 以前也有写博客的习惯，不过是在CSDN和博客园）</p><p>【PicGo+阿里云OSS】图床设置参考：<a href="https://zhuanlan.zhihu.com/p/688458825">https://zhuanlan.zhihu.com/p/688458825</a></p><p>如果想联系我的话，我的QQ是1280032578</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
