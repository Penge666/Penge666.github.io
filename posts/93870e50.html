<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>EXT文件系统 | Penge666</title><meta name="keywords" content="操作系统"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="动手实现文件系统">
<meta property="og:type" content="article">
<meta property="og:title" content="EXT文件系统">
<meta property="og:url" content="https://penge666.github.io/posts/93870e50.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="动手实现文件系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_1.webp">
<meta property="article:published_time" content="2024-04-26T06:26:10.000Z">
<meta property="article:modified_time" content="2024-04-26T06:29:51.448Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_1.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/93870e50"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'EXT文件系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-26 14:29:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">EXT文件系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-04-26T06:26:10.000Z" title="发表于 2024-04-26 14:26:10">2024-04-26</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-26T06:29:51.448Z" title="更新于 2024-04-26 14:29:51">2024-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">1.8w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="EXT文件系统"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="EXT文件系统">EXT文件系统</h2>
<h3 id="前言">前言</h3>
<p>强烈推荐看完这篇Blog，自己动手亲自实现一个min的文件系统，成就感满满~</p>
<p>课程信息：CSE.30341.FA17: Project 06：Simple File System</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www3.nd.edu/~pbui/teaching/cse.30341.fa17/project06.html">https://www3.nd.edu/~pbui/teaching/cse.30341.fa17/project06.html</a></p>
<p>由于实验要求，这里不放仓库链接🔗。有需要参考的小伙伴可私我。</p>
<h3 id="0-预备知识">0.预备知识</h3>
<p>在学习知识前，最好要有个整体的认知，再去学习细节。要不然容易陷入细节迷失方向。</p>
<p>先来个整体的认知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133829332.png" alt="image-20240426133829332"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ce4y1R7et/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d6efee335659a376be8deb6c0654e9f7">一文彻底搞懂文件系统。文件系统，跪下！23计算机考研操作系统复盘之文件系统</a></li>
</ul>
<p>文件系统的类型有很多种</p>
<ul>
<li>CentOS 5和CentOS 6上默认使用的ext2/ext3/ext4</li>
<li>CentOS 7上默认使用的xfs</li>
<li>windows上的NTFS</li>
<li>光盘类的文件系统ISO9660</li>
<li>MAC上的混合文件系统HFS</li>
<li>网络文件系统NFS</li>
<li>Oracle研发的btrfs</li>
<li>还有老式的FAT/FAT32等。</li>
</ul>
<h3 id="1-文件系统的组成部分">1.文件系统的组成部分</h3>
<h4 id="1-1-block的出现">1.1 block的出现</h4>
<p>硬盘最底层的读写IO一次是一个扇区512字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为LBA【(Logical Block Addressing)逻辑块寻址模式】。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。</p>
<p>到了Linux操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为1024bytes(1K)或2048bytes(2K)或4096bytes(4K)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的IO管理器知道如何将它的数据块翻译成磁盘维护的数据块地址LBA。</p>
<p>对于使用文件系统的IO操作来说，比如读写文件，这些IO的基本单元是文件系统上的数据块，一次读写一个文件系统数据块。比如需要读一个或多个块时，<strong>文件系统的IO管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去</strong>。</p>
<p>正如标题所示，本文重点是在文件系统而不是在磁盘，所以<strong>后文出现的block均表示的是文件系统的数据块</strong>而不是磁盘维护的逻辑块。</p>
<p>文件系统block的出现使得在文件系统层面上读写性能大大提高，也大量减少了碎片。但是它的副作用是可能造成空间浪费。由于文件系统以block为读写单元，即使存储的文件只有1K大小也将占用一个block，剩余的空间完全是浪费的。</p>
<h4 id="1-2-inode的出现">1.2 inode的出现</h4>
<p>问题1：如果一个文件系统占用大量的block读取时会如何？</p>
<p>假如block大小为1KB，仅仅存储一个10M的文件就需要10240个block，而且这些blocks很可能在位置上是不连续在一起的(不相邻)，读取该文件时难道要从前向后扫描整个文件系统的块，然后找出属于该文件的块吗?显然是不应该这么做的，因为太慢太傻瓜式了。</p>
<p>问题2：如果一个文件系统占用少量的block读取时会如何？</p>
<p>假设读取一个只占用1个block的文件，难道只读取一个block就结束了吗?并不是，仍然是扫描整个文件系统的所有block，因为它不知道什么时候扫描到，扫描到了它也不知道这个文件是不是已经完整而不需要再扫描其他的block。</p>
<p>问题3：文件名的元数据存储在哪里呢？</p>
<p>…</p>
<p>对于类似问题，我们是使用索引，因为通过扫描索引找到对应的数据，而且索引可以存储部分数据。</p>
<p>在文件系统上索引技术具体化为索引节点(index node)，在索引节点上存储的部分数据即为文件的属性元数据及其他少量信息。一般来说索引占用的空间相比其索引的文件数据而言占用的空间就小得多，扫描它比扫描整个数据要快得多，否则索引就没有存在的意义。这样一来就解决了前面所有的问题。</p>
<p>在文件系统上的术语中，索引节点称为inode。在inode中存储了inode号、文件类型、权限、文件所有者、大小、时间戳等元数据信息，最重要的是还存储了指向属于该文件block的指针，这样<strong>读取inode就可以找到属于该文件的block</strong>，进而读取这些block并获得该文件的数据。为了方便称呼和区分，暂且将这个inode记录中指向文件data block的指针称之为block指针。</p>
<p>以下是ext2文件系统中inode包含的信息示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Inode: 12 Type: regular Mode: 0644 Flags: 0x0 </span><br><span class="line">Generation: 1454951771 Version: 0x00000000:00000001 </span><br><span class="line">User: 0 Group: 0 Size: 5 </span><br><span class="line">File ACL: 0 Directory ACL: 0 </span><br><span class="line">Links: 1 Blockcount: 8 </span><br><span class="line">Fragment: Address: 0 Number: 0 Size: 0 </span><br><span class="line"> ctime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line"> atime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line"> mtime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line">crtime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line">Size of extra inode fields: 28 </span><br><span class="line">BLOCKS: </span><br><span class="line">(0):1024 </span><br><span class="line">TOTAL: 1 </span><br></pre></td></tr></table></figure>
<p>一般inode大小为128字节或256字节，相比那些MB或GB计算的文件数据而言小得多的多，但也要知道可能一个文件大小小于inode大小，例如只占用1个字节的文件。</p>
<h4 id="1-3-bmap出现">1.3 bmap出现</h4>
<p>在向硬盘存储数据时，文件系统需要知道哪些块是空闲的，哪些块是已经占用了的。最笨的方法当然是从前向后扫描，遇到空闲块就存储一部分，继续扫描直到存储完所有数据。</p>
<blockquote>
<p>解释：空闲的含义</p>
</blockquote>
<p>在文件系统中，“空闲块” 指的是尚未被任何文件或数据占用的磁盘块。文件系统需要维护一个列表或者位图来记录哪些磁盘块是空闲的，以及哪些磁盘块已经被文件或者数据占用了。这样的信息可以帮助文件系统有效地管理磁盘空间，确保数据的存储和检索操作能够正常进行。</p>
<p>当文件系统需要为新文件或者数据分配存储空间时，它会查找空闲块列表或者位图，找到一个或者多个空闲的磁盘块，并将它们标记为已经被占用。相反，当文件或者数据被删除时，文件系统会将对应的磁盘块标记为空闲，以便后续被重用。</p>
<p>通过维护空闲块列表或者位图，文件系统可以实现对磁盘空间的动态管理，确保磁盘空间的高效利用。</p>
<hr>
<p>优化的方法当然也可以考虑使用索引，但是仅仅1G的文件系统就有1KB的block共1024*1024=1048576个【1G/1K】，这仅仅只是1G，如果是100G、500G甚至更大呢，仅仅使用索引索引的数量和空间占用也将极大，这时就出现更高一级的优化方法：使用块位图(bitmap简称bmap)。</p>
<p>位图只使用0和1标识对应block是空闲还是被占用，0和1在位图中的位置和block的位置一一对应，第一位标识第一个块，第二个位标识第二个块，依次下去直到标记完所有的block。</p>
<p>思考：为什么块位图更优化？</p>
<p>在位图中1个字节8个位，可以标识8个block。对于一个block大小为1KB、容量为1G的文件系统而言，block数量有1024 * 1024个，所以在位图中使用1024 * 1024个位共1024 * 1024/8=131072字节=128K，即1G的文件只需要128个block做位图就能完成一一对应。通过扫描这100多个block就能知道哪些block是空闲的，速度提高了非常多。</p>
<p>但是要注意，<strong>bmap的优化针对的是写优化</strong>，因为只有写才需要找到空闲block并分配空闲block。对于读而言，只要通过inode找到了block的位置，cpu就能迅速计算出block在物理磁盘上的地址，cpu的计算速度是极快的，计算block地址的时间几乎可以忽略，那么读速度基本认为是受硬盘本身性能的影响而与文件系统无关。大多数稍大一点的文件可能都会存储在不连续的block上，而且使用了一段时间的文件系统可能会有不少碎片，这时硬盘的随机读取性能直接决定读数据的速度，这也是机械硬盘速度相比固态硬盘慢的多的多的原因之一，而且固态硬盘的随机读和连续读取速度几乎是一致的，对它来说，文件系统碎片的多少并不会影响读取速度。</p>
<p>虽然bmap已经极大的优化了扫描，但是仍有其瓶颈：如果文件系统是100G呢?</p>
<p>100G的文件系统要使用128*100=12800个1KB大小的block，这就占用了12.5M的空间了。试想完全扫描12800个很可能不连续的block这也是需要占用一些时间的，虽然快但是扛不住每次存储文件都要扫描带来的巨大开销。</p>
<p>所以需要再次优化，如何优化?简而言之就是将文件系统划分开形成块组，至于块组的介绍放在后文。</p>
<h4 id="1-4-inode表的出现">1.4 inode表的出现</h4>
<p>回顾下inode相关信息：inode存储了inode号、文件属性元数据、指向文件占用的block的指针;<strong>每一个inode占用128字节或256字节。</strong></p>
<p>现在又出现问题了，一个文件系统中可以说有无数多个文件，每一个文件都对应一个inode，难道每一个仅128字节的inode都要单独占用一个block进行存储吗?这太浪费空间了。</p>
<p>所以更优的方法是将多个inode合并存储在block中，对于128字节的inode，一个block存储8【1K/128B】个inode，对于256字节的inode，一个block存储4个inode。这就使得每个存储inode的块都不浪费。</p>
<p>在ext文件系统上，将这些物理上存储inode的block组合起来，在逻辑上形成一张inode表(inode table)来记录所有的inode。</p>
<p>举个例子，每一个家庭都要向派出所登记户口信息，通过户口本可以知道家庭住址，而每个镇或街道的派出所将本镇或本街道的所有户口整合在一起，要查找某一户地址时，在派出所就能快速查找到。inode table就是这里的派出所。它的内容如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425201144640.png" alt=""></p>
<p>实际上，在文件系统创建完成后所有的inode号都已经分配好并记录到inode table中了，只不过被使用的inode号所在的行还有文件属性的元数据信息和block位置信息，而未被使用的inode号只有一个inode号而已而没有其他信息而已。</p>
<p>再细细一思考，就能发现一个大的文件系统仍将占用大量的块来存储inode，想要找到其中的一个inode记录也需要不小的开销，尽管它们已经形成了一张逻辑上的表，但扛不住表太大记录太多。那么如何快速找到inode，这同样是需要优化的，优化的方法是将文件系统的block进行分组划分，每个组中都存有本组inode table范围、bmap等。</p>
<h4 id="1-5-imap的出现">1.5 imap的出现</h4>
<p>前面说bmap是块位图，用于标识文件系统中哪些block是空闲哪些block是占用的。</p>
<p>对于inode也一样，在存储文件(Linux中一切皆文件)时需要为其分配一个inode号。但是在格式化创建文件系统后所有的inode号都是被事先设定好存放在inode table中的，因此产生了问题：要为文件分配哪一个inode号呢?又如何知道某一个inode号是否已经被分配了呢?</p>
<p>既然是&quot;是否被占用&quot;的问题，使用位图是最佳方案，像bmap记录block的占用情况一样。标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。</p>
<p>imap存在着和bmap和inode table一样需要解决的问题：如果文件系统比较大，imap本身就会很大，每次存储文件都要进行扫描，会导致效率不够高。同样，优化的方式是将文件系统占用的block划分成块组，每个块组有自己的imap范围。</p>
<h4 id="1-6-块组的出现">1.6 块组的出现</h4>
<p>前面一直提到的优化方法是将文件系统占用的block划分成块组(block group)，解决bmap、inode table和imap太大的问题。</p>
<p>在物理层面上的划分是将磁盘按柱面划分为多个分区，即多个文件系统。在逻辑层面上的划分是将文件系统划分成块组。<strong>每个文件系统包含多个块组，每个块组包含多个元数据区和数据区</strong>【看下节的图】：</p>
<ul>
<li>元数据区就是存储bmap、inode table、imap等的数据;</li>
<li>数据区就是存储文件数据的区域。</li>
</ul>
<p>注意块组是逻辑层面的概念，所以并不会真的在磁盘上按柱面、按扇区、按磁道等概念进行划分。</p>
<h4 id="1-7-块组的划分">1.7 块组的划分</h4>
<p>块组在文件系统创建完成后就已经划分完成了，也就是说元数据区bmap、inode table和imap等信息占用的block以及数据区占用的block都已经划分好了。那么文件系统如何知道一个块组元数据区包含多少个block，数据区又包含多少block呢?</p>
<p>它只需确定一个数据——每个block的大小，再根据bmap至多只能占用一个完整的block的标准就能计算出块组如何划分。如果文件系统非常小，所有的bmap总共都不能占用完一个block，那么也只能空闲bmap的block了。</p>
<p>每个block的大小在创建文件系统时可以人为指定，不指定也有默认值。</p>
<p>假如现在block的大小是1KB，一个bmap完整占用一个block能标识1024*8= 8192个block(当然这8192个block是数据区和元数据区共8192个，因为元数据区分配的block也需要通过bmap来标识)。每个block是1K，每个块组是8192K即8M，创建1G的文件系统需要划分1024/8=128个块组，如果是1.1G的文件系统呢?128+12.8=128+13=141个块组。【给出block的大小，就可以从文件大小计算出快组的个数】</p>
<p>每个组的block数目是划分好了，但是每个组设定多少个inode号呢?inode table占用多少block呢?这需要由系统决定了，因为描述&quot;每多少个数据区的block就为其分配一个inode号&quot;的指标默认是我们不知道的，当然创建文件系统时也可以人为指定这个指标或者百分比例。见后文&quot;inode深入&quot;。</p>
<p>使用dumpe2fs可以将ext类的文件系统信息全部显示出来，当然bmap是每个块组固定一个block的不用显示，imap比bmap更小所以也只占用1个block不用显示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215539679.png" alt="image-20240425215539679"></p>
<p>从这张表中能计算出文件系统的大小，该文件系统共4667136个blocks，每个block大小为4K，所以文件系统大小为4667136*4/1024/1024=17.8GB。</p>
<p>也能计算出分了多少个块组，因为每一个块组的block数量为32768，所以块组的数量为4667136/32768=142.4即143个块组。由于块组从0开始编号，所以最后一个块组编号为Group 142。如下图所示是最后一个块组的信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215816389.png" alt="image-20240425215816389"></p>
<h3 id="2-文件系统的完整结构">2. 文件系统的完整结构</h3>
<p>将上文描述的bmap、inode table、imap、数据区的blocks和块组的概念组合起来就形成了一个文件系统，当然这还不是完整的文件系统。完整的文件系统如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215902069.png" alt="image-20240425215902069"></p>
<p>首先，该图中多了Boot Block、Super Block、GDT、Reserver GDT这几个概念。下面会分别介绍它们。</p>
<p>然后，图中指明了块组中每个部分占用的block数量，除了superblock、bmap、imap能确定占用1个block，其他的部分都不能确定占用几个block。</p>
<p>最后，图中指明了Superblock、GDT和Reserved GDT是同时出现且不一定存在于每一个块组中的，也指明了bmap、imap、inode table和data blocks是每个块组都有的。</p>
<h4 id="2-1-引导块">2.1 引导块</h4>
<p>即上图中的Boot Block部分，也称为boot sector。它位于分区上的第一个块，占用1024字节，并非所有分区都有这个boot sector，只有装了操作系统的主分区和装了操作系统的逻辑分区才有。里面存放的也是boot loader，这段boot loader称为VBR(主分区装操作系统时)或EBR(扩展分区装操作系统时)，这里的Boot loader和mbr上的boot loader是存在交错关系的。开机启动的时候，首先加载mbr中的bootloader，然后定位到操作系统所在分区的boot serctor上加载此处的boot loader。如果是多系统，加载mbr中的bootloader后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的boot sector上。它们之间的关系如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425220833137.png" alt="image-20240425220833137"></p>
<p>但是，这种方式的操作系统菜单早已经弃之不用了，而是使用grub来管理启动菜单。尽管如此，在安装操作系统时，仍然有一步是选择boot loader安装位置的步骤。</p>
<h4 id="2-2-超级块-superblock">2.2 超级块(superblock)</h4>
<p>既然一个文件系统会分多个块组，<strong>那么文件系统怎么知道分了多少个块组呢?每个块组又有多少block多少inode号等等信息呢?还有，文件系统本身的属性信息如各种时间戳、block总数量和空闲数量、inode总数量和空闲数量、当前文件系统是否正常、什么时候需要自检等等，它们又存储在哪里呢?</strong></p>
<p>毫无疑问，这些信息必须要存储在block中。存储这些信息占用1024字节，所以也要一个block，<strong>这个block称为超级块(superblock)</strong>，它的block号可能为0也可能为1。如果block大小为1K，则引导块正好占用一个block，这个block号为0，所以superblock的号为1;如果block大小大于1K，则引导块和超级块同置在一个block中，这个block号为0。总之superblock的起止位置是第二个1024(1024-2047)字节。</p>
<p>使用df命令读取的就是每个文件系统的superblock，所以它的统计速度非常快。相反，用du命令查看一个较大目录的已用空间就非常慢，因为不可避免地要遍历整个目录的所有文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT </span><br><span class="line">Filesystem     Type      Size  Used Avail Use% Mounted on</span><br><span class="line">udev           devtmpfs  1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs          tmpfs     388M  2.0M  386M   1% /run</span><br><span class="line">/dev/sda5      ext4       59G   43G   14G  77% /</span><br><span class="line">tmpfs          tmpfs     1.9G     0  1.9G   0% /dev/shm</span><br><span class="line">tmpfs          tmpfs     5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs          tmpfs     1.9G     0  1.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0     squashfs  128K  128K     0 100% /snap/bare/5</span><br><span class="line">/dev/loop2     squashfs   75M   75M     0 100% /snap/core22/1122</span><br><span class="line">/dev/loop1     squashfs   64M   64M     0 100% /snap/core20/2264</span><br></pre></td></tr></table></figure>
<p>superblock对于文件系统而言是至关重要的，超级块丢失或损坏必将导致文件系统的损坏。所以旧式的文件系统将超级块备份到每一个块组中，但是这又有所空间浪费，所以ext2文件系统只在块组0、1和3、5、7幂次方的块组中保存超级块的信息，如Group9、Group25等。尽管保存了这么多的superblock，但是文件系统只使用第一个块组即Group0中超级块信息来获取文件系统属性，只有当Group0上的superblock损坏或丢失才会找下一个备份超级块复制到Group0中来恢复文件系统。</p>
<p>下图是一个ext4文件系统的superblock的信息，ext家族的文件系统都能使用dumpe2fs -h获取。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425221706736.png" alt="image-20240425221706736"></p>
<h4 id="2-3-块组描述符表-GDT">2.3 块组描述符表(GDT)</h4>
<p>既然文件系统划分了块组，那么每个块组的信息和属性元数据又保存在哪里呢?</p>
<p><strong>ext文件系统每一个块组信息使用32字节描述，这32个字节称为块组描述符</strong>，所有块组的块组描述符组成块组描述符表GDT(group descriptor table)。</p>
<p>虽然每个块组都需要块组描述符来记录块组的信息和属性元数据，但是不是每个块组中都存放了块组描述符。<strong>ext文件系统的存储方式是：将它们组成一个GDT，并将该GDT存放于某些块组中，存放GDT的块组和存放superblock和备份superblock的块相同，也就是说它们是同时出现在某一个块组中的。读取时也总是读取Group0中的块组描述符表信息。</strong></p>
<p>假如block大小为4KB的文件系统划分了143个块组，每个块组描述符32字节，那么GDT就需要143*32=4576字节即两个block来存放。这两个GDT block中记录了所有块组的块组信息，且存放GDT的块组中的GDT都是完全相同的。</p>
<p>下图是一个块组描述符的信息(通过dumpe2fs获取)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425222725852.png" alt="image-20240425222725852"></p>
<h4 id="2-4-Reserved-GDT">2.4 Reserved GDT</h4>
<p>保留GDT：Reserved GDT</p>
<p>保留GDT用于以后扩容文件系统使用，防止扩容后块组太多，使得块组描述符超出当前存储GDT的blocks。保留GDT和GDT总是同时出现，当然也就和superblock同时出现了。</p>
<p>例如前面143个块组使用了2个block来存放GDT，但是此时第二个block还空余很多空间，当扩容到一定程度时2个block已经无法再记录块组描述符了，这时就需要分配一个或多个Reserved GDT的block来存放超出的块组描述符。</p>
<p>由于新增加了GDT block，所以应该让每一个保存GDT的块组都同时增加这一个GDT block，所以将保留GDT和GDT存放在同一个块组中可以直接将保留GDT变换为GDT而无需使用低效的复制手段备份到每个存放GDT的块组。</p>
<p>同理，新增加了GDT需要修改每个块组中superblock中的文件系统属性，所以将superblock和Reserved GDT/GDT放在一起又能提升效率。</p>
<h3 id="3-Data-Block">3.Data Block</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215902069.png" alt=""></p>
<p>如上图，除了Data Blocks其他的部分都解释过了。data block是直接存储数据的block，但事实上并非如此简单。</p>
<p>数据所占用的block由文件对应inode记录中的block指针找到，不同的文件类型，数据block中存储的内容是不一样的。以下是Linux中不同类型文件的存储方式。</p>
<ul>
<li>对于常规文件，文件的数据正常存储在数据块中。</li>
<li>对于目录，该目录下的所有文件和一级子目录的目录名存储在数据块中。</li>
<li>文件名不是存储在其自身的inode中，而是存储在其所在目录的data block中。</li>
<li>对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。</li>
<li>设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。</li>
</ul>
<h4 id="3-1-目录文件的data-block">3.1 目录文件的data block</h4>
<p>对于目录文件，其inode记录中存储的是目录的inode号、目录的属性元数据和目录文件的block指针，这里面没有存储目录自身文件名的信息。</p>
<p>而其data block的存储方式则如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425223235705.png" alt="image-20240425223235705"></p>
<p>由图可知，在目录文件的数据块中存储了其下的文件名、目录名、目录本身的相对名称&quot;.“和上级目录的相对名称”…“，还存储了指向inode table中这些文件名对应的inode号的指针(并非直接存储inode号码)、目录项长度rec_len、文件名长度name_len和文件类型file_type。注意到除了文件本身的inode记录了文件类型，其所在的目录的数据块也记录了文件类型。由于rec_len只能是4的倍数，所以需要使用”\0&quot;来填充name_len不够凑满4倍数的部分。至于rec_len具体是什么，只需知道它是一种偏移即可。</p>
<p>目录的data block中并没有直接存储目录中文件的inode号，它存储的是指向inode table中对应文件inode号的指针，暂且称之为inode指针(至此，已经知道了两种指针：一种是inode table中每个inode记录指向其对应data block的block指针，一个此处的inode指针。题外话：实际上inode指针应该称之为存储在目录data blcok中的链接link，这个link和inode num一一映射，所以删除文件的函数称为unlink()，表示在目录的data block中删除这个链接)。一个很有说服力的例子，在目录只有读而没有执行权限的时候，使用&quot;ls -l&quot;是无法获取到其内文件inode号的，这就表明没有直接存储inode号。实际上，因为在创建文件系统的时候，inode号就已经全部划分好并在每个块组的inode table中存放好，inode table在块组中是有具体位置的，如果使用dumpe2fs查看文件系统，会发现每个块组的inode table占用的block数量是完全相同的，如下图是某分区上其中两个块组的信息，它们都占用249个block。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425223747136.png" alt="image-20240425223747136"></p>
<p>除了inode指针，目录的data block中还使用数字格式记录了文件类型，数字格式和文件类型的对应关系如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425223811142.png" alt="image-20240425223811142"></p>
<p>注意到目录的data block中前两行存储的是目录本身的相对名称&quot;.“和上级目录的相对名称”…&quot;，它们实际上是目录本身的硬链接和上级目录的硬链接。硬链接的本质后面说明。</p>
<p>由此也就容易理解目录权限的特殊之处了。目录文件的读权限®和写权限(w)，都是针对目录文件的数据块本身。由于目录文件内只有文件名、文件类型和inode指针，所以如果只有读权限，只能获取文件名和文件类型信息，无法获取其他信息，尽管目录的data block中也记录着文件的inode指针，但定位指针是需要x权限的，因为其它信息都储存在文件自身对应的inode中，而要读取文件inode信息需要有目录文件的执行权限通过inode指针定位到文件对应的inode记录上。以下是没有目录x权限时的查询状态，可以看到除了文件名和文件类型，其余的全是&quot;?&quot;。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lisi4@xuexi tmp]$ ll -i d </span><br><span class="line"><span class="built_in">ls</span>: cannot access d/hehe: Permission denied </span><br><span class="line"><span class="built_in">ls</span>: cannot access d/haha: Permission denied </span><br><span class="line">total 0 </span><br><span class="line">? d????????? ? ? ? ? ? haha </span><br><span class="line">? -????????? ? ? ? ? ? hehe </span><br></pre></td></tr></table></figure>
<p>注意，xfs文件系统和ext文件系统不一样，它连文件类型都无法获取。</p>
<h4 id="3-2-符号链接存储方式">3.2 符号链接存储方式</h4>
<p>符号链接即为软链接，类似于Windows操作系统中的快捷方式，它的作用是指向原文件或目录。</p>
<p>软链接之所以也被称为特殊文件的原因是：它一般情况下不占用data block，仅仅通过它对应的inode记录就能将其信息描述完成;符号链接的大小是其指向目标路径占用的字符个数，例如某个符号链接的指向方式为&quot;rmt --&gt; …/sbin/rmt&quot;，则其文件大小为11字节;只有当符号链接指向的目标的路径名较长(60个字节)时文件系统才会划分一个data block给它;它的权限如何也不重要，因它只是一个指向原文件的&quot;工具&quot;，最终决定是否能读写执行的权限由原文件决定，所以很可能ls -l查看到的符号链接权限为777。</p>
<p>注意，软链接的block指针存储的是目标文件名。也就是说，链接文件的一切都依赖于其目标文件名。这就解释了为什么/mnt的软链接/tmp/mnt在/mnt挂载文件系统后，通过软链接就能进入/mnt所挂载的文件系统。究其原因，还是因为其目标文件名&quot;/mnt&quot;并没有改变。</p>
<p>例如以下筛选出了/etc/下的符号链接，注意观察它们的权限和它们占用的空间大小。</p>
<h4 id="3-3-设备文件、FIFO、套接字文件">3.3 设备文件、FIFO、套接字文件</h4>
<p>关于这3种文件类型的文件只需要通过inode就能完全保存它们的信息，它们不占用任何数据块，所以它们是特殊文件。</p>
<p>设备文件的主设备号和次设备号也保存在inode中。以下是/dev/下的部分设备信息。注意到它们的第5列和第6列信息，它们分别是主设备号和次设备号，主设备号标识每一种设备的类型，次设备号标识同种设备类型的不同编号;也注意到这些信息中没有大小的信息，因为设备文件不占用数据块所以没有大小的概念。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># ll /dev | tail </span></span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 129 Oct 7 21:26 vcsa1 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 130 Oct 7 21:27 vcsa2 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 131 Oct 7 21:27 vcsa3 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 132 Oct 7 21:27 vcsa4 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 133 Oct 7 21:27 vcsa5 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 134 Oct 7 21:27 vcsa6 </span><br><span class="line">crw-rw---- 1 root root 10, 63 Oct 7 21:26 vga_arbiter </span><br><span class="line">crw------- 1 root root 10, 57 Oct 7 21:26 vmci </span><br><span class="line">crw-rw-rw- 1 root root 10, 56 Oct 7 21:27 vsock </span><br><span class="line">crw-rw-rw- 1 root root 1, 5 Oct 7 21:26 zero </span><br></pre></td></tr></table></figure>
<h3 id="4-inode基础知识">4.inode基础知识</h3>
<p>每个文件都有一个inode，在将inode关联到文件后系统将通过inode号来识别文件，而不是文件名。并且访问文件时将先找到inode，通过inode中记录的block位置找到该文件。</p>
<p>Q：为什么要要链接？</p>
<p>A：为了方便用户访问文件，可以将一个文件或目录与另一个文件或目录建立关联，从而实现多个路径指向同一个文件或目录的效果。</p>
<p>Q：为什么需要硬和软两种链接呢？</p>
<p>A：</p>
<ul>
<li><strong>硬链接</strong>是指在<strong>同一个文件系统中</strong>，将一个文件名关联到一个已经存在的文件上，使得该文件名也可以访问该文件。</li>
<li><strong>软链接</strong>（也称符号链接）是指在<strong>不同的文件系统之间</strong>，将一个文件名关联到另一个文件上，使得该文件名也可以访问该文件。</li>
</ul>
<h4 id="4-1-硬链接">4.1 硬链接</h4>
<p><strong>本质：硬链接就是多个文件名指向同一个文件的数据块。</strong></p>
<p>虽然每个文件都有一个inode，但是存在一种可能：多个文件的inode相同，也就即inode号、元数据、block位置都相同，这是一种什么样的情况呢?</p>
<p>能够想象这些inode相同的文件使用的都是同一条inode记录，所以代表的都是同一个文件，这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。这种inode相同的文件在Linux中被称为&quot;硬链接&quot;。</p>
<p>硬链接文件的inode都相同，每个文件都有一个&quot;硬链接数&quot;的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  <span class="built_in">ls</span> -l</span><br><span class="line">total 40</span><br><span class="line">-rwxrwxr-x 1 penge penge 18264 4月  17 13:32 a.out</span><br><span class="line">-rw-rw-r-- 1 penge penge   196 4月  25 17:11 example.c</span><br><span class="line">-rw-rw-r-- 1 penge penge  4240 4月  17 13:31 example.o</span><br><span class="line">-rw-rw-r-- 1 penge penge    56 4月  17 13:31 external.c</span><br><span class="line">-rw-rw-r-- 1 penge penge  2952 4月  17 13:32 external.o</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">ls</span> -i file1</span><br><span class="line">1055165 file1</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">ls</span> -i file2</span><br><span class="line">1055165 file2</span><br></pre></td></tr></table></figure>
<p>例如下图描述的是dir1目录中的文件name1及其硬链接dir2/name2，右边分别是它们的inode和datablock。这里也看出了硬链接文件之间唯一不同的就是其所在目录中的记录不同。注意下图中有一列Link Count就是标记硬链接数的属性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426105519520.png" alt="image-20240426105519520"></p>
<p>每创建一个文件的硬链接，实质上是多一个指向该inode记录的inode指针，并且硬链接数加1。</p>
<p>删除文件的实质是删除该文件所在目录data block中的对应的inode指针，所以也是减少硬链接次数，由于block指针是存储在inode中的，所以不是真的删除数据，如果仍有其他指针指向该inode，那么该文件的block指针仍然是可用的。当硬链接次数为1时再删除文件就是真的删除文件了，此时inode记录中block指针也将被删除。</p>
<p>不能跨分区创建硬链接，因为不同文件系统的inode号可能会相同，如果允许创建硬链接，复制到另一个分区时inode可能会和此分区已使用的inode号冲突。</p>
<p>硬链接只能对文件创建，无法对目录创建硬链接。【这里我的理解是可能会导致循环引用的情况】之所以无法对目录创建硬链接，是因为文件系统已经把每个目录的硬链接创建好了，它们就是相对路径中的&quot;.“和”…&quot;，分别标识当前目录的硬链接和上级目录的硬链接。每一个目录中都会包含这两个硬链接，它包含了两个信息：</p>
<p>(1) 一个没有子目录的目录文件的硬链接数是2，其一是目录本身，即该目录datablock中的&quot;.&quot;，其二是其父目录datablock中该目录的记录，这两者都指向同一个inode号;</p>
<p>(2) 一个包含子目录的目录文件，其硬链接数是2+子目录数，因为每个子目录都关联一个父目录的硬链接&quot;…“。很多人在计算目录的硬链接数时认为由于包含了”.“和”…“，所以空目录的硬链接数是2，这是错误的，因为”…“不是本目录的硬链接。另外，还有一个特殊的目录应该纳入考虑，即”/“目录，它自身是一个文件系统的入口，是自引用(下文中会解释自引用)的，所以”/“目录下的”.“和”…“的inode号相同，它自身不占用硬链接，因为其datablock中只记录inode号相同的”.“和”…“，不再像其他目录一样还记录一个名为”/“的目录，所以”/“的硬链接数也是2+子目录数，但这个2是”.“和”…&quot;的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># ln /tmp /mydata </span></span><br><span class="line"><span class="built_in">ln</span>: `/tmp<span class="string">&#x27;: hard link not allowed for directory </span></span><br></pre></td></tr></table></figure>
<p>为什么文件系统自己创建好了目录的硬链接就不允许人为创建呢?从&quot;.“和”…“的用法上考虑，如果当前目录为/usr，我们可以使用”./local&quot;来表示/usr/local，但是如果我们人为创建了/usr目录的硬链接/tmp/husr，难道我们也要使用&quot;/tmp/husr/local&quot;来表示/usr/local吗?这其实已经是软链接的作用了。若要将其认为是硬链接的功能，这必将导致硬链接维护的混乱。【这个解释也很好】</p>
<p>不过，通过mount工具的&quot;–bind&quot;选项，可以将一个目录挂载到另一个目录下，实现伪&quot;硬链接&quot;，它们的内容和inode号是完全相同的。</p>
<p>硬链接的创建方法： ln file_target link_name 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426140728344.png" alt="image-20240426140728344"></p>
<h4 id="4-2-软链接">4.2 软链接</h4>
<p><strong>软链接的本质是一个包含目标文件或目录路径的小文件，而不是像硬链接一样直接指向数据块。当你访问软链接时，文件系统会根据该链接中包含的路径找到目标文件或目录，并将操作重定向到目标。</strong></p>
<p>软链接就是字符链接，<strong>链接文件默认指的就是字符链接文件(注意不是字符设备)，使用&quot;l&quot;表示其类型。</strong></p>
<p>硬链接不能跨文件系统创建，否则inode号可能会冲突。于是实现了软链接以便跨文件系统建立链接。既然是跨文件系统，那么软链接必须得有自己的inode号。</p>
<p>软链接在功能上等价与Windows系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。可以认为软链接inode记录中的指针内容是目标路径的字符串。</p>
<p>创建方式： ln –s source_file softlink_name ，记住是source_file&lt;–link_name的指向关系(反箭头)，以前我老搞错位置。</p>
<p>查看软链接的值： readlink softlink_name</p>
<p>在设置软链接的时候，<strong>source_file虽然不要求是绝对路径，但建议给绝对路径</strong>。是否还记得软链接文件的大小?它是根据软链接所指向路径的字符数计算的，例如某个符号链接的指向方式为&quot;rmt --&gt; …/sbin/rmt&quot;，它的文件大小为11字节，也就是说只要建立了软链接后，软链接的指向路径是不会改变的，仍然是&quot;…/sbin/rmt&quot;。如果此时移动软链接文件本身，它的指向是不会改变的，仍然是11个字符的&quot;…/sbin/rmt&quot;，但此时该软链接父目录下可能根本就不存在/sbin/rmt，也就是说此时该软链接是一个被破坏的软链接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426140716839.png" alt="image-20240426140716839"></p>
<h4 id="4-3-实操">4.3 实操</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/641716217">【Linux】硬链接 和 软链接</a></li>
</ul>
<blockquote>
<p><strong>硬链接</strong></p>
</blockquote>
<p>如果A文件和B文件的关系是硬连接的关系。当用户修改了A文件的内容，那么B文件的内容也会发生更改。如果修改的B文件，那么A文件的内容也会发生更改。</p>
<p>特点:<br>
1、硬连接不限于两个文件之间，可以在多个文件之间进行。ls -l命令中显示了文件的硬连接数</p>
<p>2、不能对目录做硬件连接</p>
<p>3、不能在不同的文件系统之间做硬链接〔Linux的文件系统: ext4。xfs等等)</p>
<p>4、所有的硬连接，具备相同的iNode节点号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">touch</span> file1</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">ln</span> file1 file2</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  ll            </span><br><span class="line">total 88K</span><br><span class="line">-rwxrwxr-x 1 penge penge  38K 3月  10 15:14 a.out</span><br><span class="line">-rw-rw-r-- 2 penge penge    0 4月  26 14:00 file1</span><br><span class="line">-rw-rw-r-- 2 penge penge    0 4月  26 14:00 file2</span><br><span class="line">-rw-rw-r-- 1 penge penge 1.6K 3月  10 15:14 http_conn.cpp</span><br><span class="line">-rw-rw-r-- 1 penge penge  779 3月  13 11:18 http_conn.h</span><br><span class="line">-rw-rw-r-- 1 penge penge 2.7K 3月  10 10:52 locker.h</span><br><span class="line">-rwxrwxr-x 1 penge penge  21K 4月  12 10:39 main</span><br><span class="line">-rw-rw-r-- 1 penge penge    0 4月  17 13:30 main.cpp</span><br><span class="line">-rw-rw-r-- 1 penge penge 3.6K 3月  10 10:52 threadpool.h</span><br><span class="line">drwxrwxr-x 2 penge penge 4.0K 4月  16 14:25 tmp</span><br><span class="line">drwxrwxr-x 2 penge penge 4.0K 4月  25 16:05 tmp1</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">echo</span> <span class="string">&#x27;aaa&#x27;</span>&gt;file1                                                  </span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file1                                                         </span><br><span class="line">aaa</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file2</span><br><span class="line">aaa</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">echo</span> <span class="string">&#x27;bbb&#x27;</span>&gt;file2</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file2       </span><br><span class="line">bbb</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file2       </span><br><span class="line">bbb</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file1</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>软链接</strong></p>
</blockquote>
<p>类似Windows中的快捷方式。为一个源文件创建一个快捷方式。</p>
<p>1、如果源文件被删除了，也没有办法使用该快捷方式。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据</p>
<p>2、在ls-l中，软链接作为一种特殊的文件类型显示出来，其第一个字母是l。</p>
<p>3、软链接的大小是其链接文件的路径名中的字符数。</p>
<p>pwd -P显示文件的实际路径,而不是软连接的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  /bin  <span class="built_in">pwd</span> -P</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>
<h3 id="5-inode深入">5.inode深入</h3>
<h4 id="5-1-inode大小和划分">5.1 inode大小和划分</h4>
<p>inode大小为128字节的倍数，最小为128字节。它有默认值大小，它的默认值由/etc/mke2fs.conf文件中指定。不同的文件系统默认值可能不同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># cat /etc/mke2fs.conf </span></span><br><span class="line">[defaults] </span><br><span class="line"> base_features = sparse_super,filetype,resize_inode,dir_index,ext_attr </span><br><span class="line"> enable_periodic_fsck = 1 </span><br><span class="line"> blocksize = 4096 </span><br><span class="line"> inode_size = 256 </span><br><span class="line"> inode_ratio = 16384 </span><br><span class="line">[fs_types] </span><br><span class="line"> ext3 = &#123; </span><br><span class="line"> features = has_journal </span><br><span class="line"> &#125; </span><br><span class="line"> ext4 = &#123; </span><br><span class="line"> features = has_journal,extent,huge_file,flex_bg,uninit_bg,dir_nlink,extra_isize </span><br><span class="line"> inode_size = 256 </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>同样观察到这个文件中还记录了blocksize的默认值和inode分配比率inode_ratio。inode_ratio=16384表示每16384个字节即16KB就分配一个inode号，由于默认blocksize=4KB，所以每4个block就分配一个inode号。当然分配的这些inode号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个inode号。但是分配的inode自身会占用block，而且其自身大小256字节还不算小，所以inode号的浪费代表着空间的浪费。</p>
<p>既然知道了inode分配比率，就能计算出每个块组分配多少个inode号，也就能计算出inode table占用多少个block。</p>
<p>如果文件系统中大量存储电影等大文件，inode号就浪费很多，inode占用的空间也浪费很多。但是没办法，文件系统又不知道你这个文件系统是用来存什么样的数据，多大的数据，多少数据。</p>
<p>当然inodesize、inode分配比例、blocksize都可以在创建文件系统的时候人为指定。</p>
<h4 id="5-2-ext文件系统预留的inode号">5.2 ext文件系统预留的inode号</h4>
<p>Ext预留了一些inode做特殊特性使用，如下：某些可能并非总是准确，具体的inode号对应什么文件可以使用&quot;find / -inum NUM&quot;查看。</p>
<ul>
<li>Ext4的特殊inode</li>
<li>Inode号 用途</li>
<li>0 不存在0号inode</li>
<li>1 虚拟文件系统，如/proc和/sys</li>
<li>2 根目录</li>
<li>3 ACL索引</li>
<li>4 ACL数据</li>
<li>5 Boot loader</li>
<li>6 未删除的目录</li>
<li>7 预留的块组描述符inode</li>
<li>8 日志inode</li>
<li>11 第一个非预留的inode，通常是lost+found目录</li>
</ul>
<p>所以在ext4文件系统的dumpe2fs信息中，能观察到fisrt inode号可能为11也可能为12。</p>
<p>并且注意到&quot;/&quot;的inode号为2，这个特性在文件访问时会用上。</p>
<p>需要注意的是，每个文件系统都会分配自己的inode号，不同文件系统之间是可能会出现使用相同inode号文件的。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># find / -ignore_readdir_race -inum 2 -ls </span></span><br><span class="line"> 2 4 dr-xr-xr-x 22 root root 4096 Jun 9 09:56 / </span><br><span class="line"> 2 2 dr-xr-xr-x 5 root root 1024 Feb 25 11:53 /boot </span><br><span class="line"> 2 0 c--------- 1 root root Jun 7 02:13 /dev/pts/ptmx </span><br><span class="line"> 2 0 -rw-r--r-- 1 root root 0 Jun 6 18:13 /proc/sys/fs/binfmt_misc/status </span><br><span class="line"> 2 0 drwxr-xr-x 3 root root 0 Jun 6 18:13 /sys/fs </span><br></pre></td></tr></table></figure>
<p>从结果中可见，除了根的Inode号为2，还有几个文件的inode号也是 2，它们都属于独立的文件系统，有些是虚拟文件系统，如/proc和/sys。</p>
<h4 id="5-3-ext2-3的inode直接、间接寻址">5.3 ext2/3的inode直接、间接寻址</h4>
<p>前文说过，inode中保存了blocks指针，但是一条inode记录中能保存的指针数量是有限的，否则就会超出inode大小(128字节或256字节)。</p>
<p>在ext2和ext3文件系统中，一个inode中最多只能有15个指针，每个指针使用i_block[n]表示。</p>
<p>前12个指针i_block[0]到i_block[11]是直接寻址指针，每个指针指向一个数据区的block。如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426112610456.png" alt="image-20240426112610456"></p>
<p>第13个指针i_block[12]是一级间接寻址指针，它指向一个仍然存储了指针的block即i_block[12] --&gt; Pointerblock --&gt; datablock。</p>
<p>第14个指针i_block[13]是二级间接寻址指针，它指向一个仍然存储了指针的block，但是这个block中的指针还继续指向其他存储指针的block，即i_block[13] --&gt; Pointerblock1 --&gt; PointerBlock2 --&gt; datablock。</p>
<p>第15个指针i_block[14]是三级间接寻址指针，它指向一个任然存储了指针的block，这个指针block下还有两次指针指向。即i_block[13] --&gt; Pointerblock1 --&gt; PointerBlock2 --&gt; PointerBlock3 --&gt; datablock。</p>
<p>其中由于每个指针大小为4字节，所以每个指针block能存放的指针数量为BlockSize/4byte。例如blocksize为4KB，那么一个Block可以存放4096/4=1024个指针。</p>
<p>如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426112704312.png" alt="image-20240426112704312"></p>
<p>为什么要分间接和直接指针呢?如果一个inode中15个指针全是直接指针，假如每个block的大小为1KB，那么15个指针只能指向15个block即15KB的大小，由于每个文件对应一个inode号，所以就限制了每个文件最大为15*1=15KB，这显然是不合理的。</p>
<p>如果存储大于15KB的文件而又不太大的时候，就占用一级间接指针i_block[12]，这时可以存放指针数量为1024/4+12=268，所以能存放268KB的文件。</p>
<p>如果存储大于268K 的文件而又不太大的时候，就继续占用二级指针i_block[13]，这时可以存放指针数量为[1024/4]^2+1024/4+12=65804，所以能存放65804KB=64M左右的文件。</p>
<p>如果存放的文件大于64M，那么就继续使用三级间接指针i_block[14]，存放的指针数量为[1024/4]^3+[1024/4]^2+[1024/4]+12=16843020个指针，所以能存放16843020KB=16GB左右的文件。</p>
<p>如果blocksize=4KB呢?那么最大能存放的文件大小为([4096/4]^3+[4096/4]^2+[4096/4]+12)*4/1024/1024/1024=4T左右。</p>
<p>当然这样计算出来的不一定就是最大能存放的文件大小，它还受到另一个条件的限制。这里的计算只是表明一个大文件是如何寻址和分配的。</p>
<p>其实看到这里的计算数值，就知道ext2和ext3对超大文件的存取效率是低下的，它要核对太多的指针，特别是4KB大小的blocksize时。而ext4针对这一点就进行了优化，ext4使用extent的管理方式取代ext2和ext3的块映射，大大提高了效率也降低了碎片。</p>
<h3 id="6-单文件系统中文件操作的原理">6.单文件系统中文件操作的原理</h3>
<p>在Linux上执行删除、复制、重命名、移动等操作时，它们是怎么进行的呢?还有访问文件时是如何找到它的呢?其实只要理解了前文中介绍的几个术语以及它们的作用就很容易知道文件操作的原理了。</p>
<p>注：在这一小节所解释的都是在单个文件系统下的行为，在多个文件系统中如何请看下一个小节：多文件系统关联。</p>
<h4 id="6-1-读取文件"><strong>6.1 读取文件</strong></h4>
<p>当执行&quot;<strong>cat /var/log/messages</strong>&quot;命令在系统内部进行了什么样的步骤呢?该命令能被成功执行涉及了cat命令的寻找、权限判断以及messages文件的寻找和权限判断等等复杂的过程。这里只解释和本节内容相关的如何寻找到被cat的/var/log/messages文件。</p>
<ul>
<li>找到根文件系统的块组描述符表所在的blocks，读取GDT(已在内存中)找到inode table的block号。</li>
</ul>
<p>因为GDT总是和superblock在同一个块组，而superblock总是在分区的第1024-2047个字节，所以很容易就知道第一个GDT所在的块组以及GDT在这个块组中占用了哪些block。</p>
<p>其实GDT早已经在内存中了，在系统开机的时候会挂载根文件系统，挂载的时候就已经将所有的GDT放进内存中。</p>
<ul>
<li>在inode table的block中定位到根&quot;/“的inode，找出”/&quot;指向的data block。</li>
</ul>
<p>前文说过，ext文件系统预留了一些inode号，其中&quot;/&quot;的inode号为2，所以可以根据inode号直接定位根目录文件的data block。</p>
<ul>
<li>在&quot;/&quot;的datablock中记录了var目录名和指向var目录文件inode的指针，并找到该inode记录，inode记录中存储了指向var的block指针，所以也就找到了var目录文件的data block。</li>
</ul>
<p>通过var目录的inode指针，可以寻找到var目录的inode记录，但是指针定位的过程中，还需要知道该inode记录所在的块组以及所在的inode table，所以需要读取GDT，同样，GDT已经缓存到了内存中。</p>
<ul>
<li>在var的data block中记录了log目录名和其inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到log的data block。</li>
<li>在log目录文件的data block中记录了messages文件名和对应的inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到messages的data block。</li>
<li>最后读取messages对应的datablock。</li>
</ul>
<p>将上述步骤中GDT部分的步骤简化后比较容易理解。如下:<strong>找到GDT–&gt;找到&quot;/&quot;的inode–&gt;找到/的数据块读取var的inode–&gt;找到var的数据块读取log的inode–&gt;找到log的数据块读取messages的inode–&gt;找到messages的数据块并读取它们。</strong></p>
<h4 id="6-2-删除、重命名和移动文件">6.2 删除、重命名和移动文件</h4>
<p>注意这里是不跨越文件系统的操作行为。</p>
<ul>
<li><strong>删除文件分为普通文件和目录文件</strong>，知道了这两种类型的文件的删除原理，就知道了其他类型特殊文件的删除方法。</li>
</ul>
<p>对于删除普通文件：</p>
<p>(1) 找到文件的inode和data block(根据前一个小节中的方法寻找);</p>
<p>(2) 将inode table中该inode记录中的data block指针删除;</p>
<p>(3) 在imap中将该文件的inode号标记为未使用;</p>
<p>(4) 在其所在目录的data block中将该文件名所在的记录行删除，删除了记录就丢失了指向inode的指针;</p>
<p>(5) 将bmap中data block对应的block号标记为未使用。</p>
<p>对于删除目录文件：找到目录和目录下所有文件、子目录、子文件的inode和data block;在imap中将这些inode号标记为未使用;将bmap中将这些文件占用的 block号标记为未使用;在该目录的父目录的data block中将该目录名所在的记录行删除。需要注意的是，删除父目录data block中的记录是最后一步，如果该步骤提前，将报目录非空的错误，因为在该目录中还有文件占用。</p>
<p>关于上面的(2)-(5)：当(2)中删除data block指针后，将无法再找到这个文件的数据;当(3)标记inode号未使用，表示该inode号可以被后续的文件重用;当(4)删除目录data block中关于该文件的记录，真正的删除文件，外界再也定位也无法看到这个文件了;当(5)标记data block为未使用后，表示开始释放空间，这些data block可以被其他文件重用。</p>
<p>注意，在第(5)步之前，由于data block还未被标记为未使用，在superblock中仍然认为这些data block是正在使用中的。这表示尽管文件已经被删除了，但空间却还没有释放，df也会将其统计到已用空间中(df是读取superblock中的数据块数量，并计算转换为空间大小)。</p>
<p>什么时候会发生这种情况呢?当一个进程正在引用文件时将该文件删除，就会出现文件已删除但空间未释放的情况。这时步骤已经进行到(4)，外界无法再找到该文件，但由于进程在加载该文件时已经获取到了该文件所有的data block指针，该进程可以获取到该文件的所有数据，但却暂时不会释放该文件空间。直到该进程结束，文件系统才将未执行的步骤(5)继续完成。这也是为什么有时候du的统计结果比df小的原因，关于du和df统计结果的差别，详细内容见：详细分析du和df的统计结果为什么不一样。</p>
<ul>
<li>重命名文件分为同目录内重命名和非同目录内重命名。非同目录内重命名实际上是移动文件的过程，见下文。</li>
</ul>
<p>同目录内重命名文件的动作仅仅只是修改所在目录data block中该文件记录的文件名部分，不是删除再重建的过程。</p>
<p>如果重命名时有文件名冲突(该目录内已经存在该文件名)，则提示是否覆盖。覆盖的过程是覆盖目录data block中冲突文件的记录。例如/tmp/下有a.txt和a.log，若将a.txt重命名为a.log，则提示覆盖，若选择覆盖，则/tmp的data block中关于a.log的记录被覆盖，此时它的指针是指向a.txt的inode。</p>
<ul>
<li>移动文件</li>
</ul>
<p>同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针，如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除(如果多个硬链接数，则另当别论)。</p>
<p>所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p>
<p>对于不同文件系统内的移动，相当于先复制再删除的动作。见后文。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426113825639.png" alt="image-20240426113825639"></p>
<p>关于文件移动，在Linux环境下有一个非常经典网上却又没任何解释的问题：/tmp/a/a能覆盖为/tmp/a吗?答案是不能，但windows能。为什么不能?见mv的一个经典问题(mv的本质)。</p>
<h4 id="6-3-存储和复制文件">6.3 存储和复制文件</h4>
<ul>
<li>对于文件存储</li>
<li>(1).读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号;</li>
<li>(2).在inode table中完善该inode号所在行的记录;</li>
<li>(3).在目录的data block中添加一条该文件的相关记录;</li>
<li>(4).将数据填充到data block中。</li>
<li>注意，填充到data block中的时候会调用block分配器：一次分配4KB大小的block数量，当填充完4KB的data block后会继续调用block分配器分配4KB的block，然后循环直到填充完所有数据。也就是说，如果存储一个100M的文件需要调用block分配器100*1024/4=25600次。</li>
<li>另一方面，在block分配器分配block时，block分配器并不知道真正有多少block要分配，只是每次需要分配时就分配，在每存储一个data block前，就去bmap中标记一次该block已使用，它无法实现一次标记多个bmap位。这一点在ext4中进行了优化。</li>
<li>(5)填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针。</li>
<li>对于复制，完全就是另一种方式的存储文件。步骤和存储文件的步骤一样。</li>
</ul>
<h3 id="7-多文件系统关联">7.多文件系统关联</h3>
<p>在单个文件系统中的文件操作和多文件系统中的操作有所不同。本文将对此做出非常详细的说明。</p>
<h4 id="7-1-根文件系统的特殊性">7.1 根文件系统的特殊性</h4>
<p>这里要明确的是，任何一个文件系统要在Linux上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如/dev/cdrom挂载在/mnt上，/mnt目录本身是在&quot;/“文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有”/&quot;是自引用的。这里要说明挂载点的级别和自引用的概念。</p>
<p>假如/dev/sdb1挂载在/mydata上，/dev/cdrom挂载在/mydata/cdrom上，那么/mydata就是一级挂载点，此时/mydata已经是文件系统/dev/sdb1的入口了，而/dev/cdrom所挂载的目录/mydata/cdrom是文件系统/dev/sdb1中的某个目录，那么/mydata/cdrom就是二级挂载点。一级挂载点必须在根文件系统下，所以可简述为：文件系统2挂载在文件系统1中的某个目录下，而文件系统1又挂载在根文件系统中的某个目录下。</p>
<p>再解释自引用。首先要说的是，自引用的只能是文件系统，而文件系统表现形式是一个目录，所以自引用是指该目录的data block中，&quot;.“和”…&quot;的记录中的inode指针都指向inode table中同一个inode记录，所以它们inode号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi /]<span class="comment"># ll -ai / </span></span><br><span class="line">total 102 </span><br><span class="line"> 2 dr-xr-xr-x. 22 root root 4096 Jun 6 18:13 . </span><br><span class="line"> 2 dr-xr-xr-x. 22 root root 4096 Jun 6 18:13 ..  </span><br></pre></td></tr></table></figure>
<p>由此也能解释cd /.和cd /…的结果都还是在根下，这是自引用最直接的表现形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]<span class="comment"># cd /. </span></span><br><span class="line">[root@xuexi /]<span class="comment"># </span></span><br><span class="line">[root@xuexi tmp]<span class="comment"># cd /.. </span></span><br><span class="line">[root@xuexi /]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>注意，根目录下的&quot;.“和”…“都是”/“目录的硬链接，且其datablock中不记录名为”/&quot;的条目，因此除去根目录下子目录数后的硬链接数为2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># a=$(ls -ld / | awk &#x27;&#123;print $2&#125;&#x27;) </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># b=$(ls -l / | grep &quot;^d&quot; |wc -l) </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># echo $((a - b)) </span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h4 id="7-2-挂载文件系统的细节">7.2 挂载文件系统的细节</h4>
<p>挂载文件系统到某个目录下，例如&quot;mount /dev/cdrom /mnt&quot;，挂载成功后/mnt目录中的文件全都暂时不可见了，且挂载后权限和所有者(如果指定允许普通用户挂载)等的都改变了，知道为什么吗?</p>
<p>下面就以通过&quot;mount /dev/cdrom /mnt&quot;为例，详细说明挂载过程中涉及的细节。</p>
<p>在将文件系统/dev/cdrom(此处暂且认为它是文件系统)挂载到挂载点/mnt之前，挂载点/mnt是根文件系统中的一个目录，&quot;/&quot;的data block中记录了/mnt的一些信息，其中包括inode指针inode_n，而在inode table中，/mnt对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426131810028.png" alt="image-20240426131810028"></p>
<p>当文件系统/dev/cdrom挂载到/mnt上后，/mnt此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。但是如何连接呢？如下图。【好图】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426131959318.png" alt="image-20240426131959318"></p>
<p>在根文件系统的inode table中，为/mnt重新分配一个inode记录m，该记录的block指针block_m指向文件系统/dev/cdrom中的data block。既然为/mnt分配了新的inode记录m，那么在&quot;/&quot;目录的data block中，也需要修改其inode指针为inode_m以指向m记录。同时，原来inode table中的inode记录n就被标记为暂时不可用。</p>
<p>block_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。</p>
<p>挂载完成后，将在/proc/self/{mounts,mountstats,mountinfo}这三个文件中写入挂载记录和相关的挂载信息，并会将/proc/self/mounts中的信息同步到/etc/mtab文件中，当然，如果挂载时加了-n参数，将不会同步到/etc/mtab。</p>
<p>而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。由于卸载只是移除inode记录，所以使用挂载点和文件系统都可以实现卸载，因为它们是联系在一起的。</p>
<p>下面是分析或结论</p>
<p>(1).挂载点挂载时的inode记录是新分配的。</p>
<p># 挂载前挂载点/mnt的inode号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># ll -id /mnt </span></span><br><span class="line">100663447 drwxr-xr-x. 2 root root 6 Aug 12 2015 /mnt </span><br><span class="line">[root@server2 tmp]<span class="comment"># mount /dev/cdrom /mnt </span></span><br><span class="line"><span class="comment"># 挂载后挂载点的inode号 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll -id /mnt  </span></span><br><span class="line">1856 dr-xr-xr-x 8 root root 2048 Dec 10 2015 mnt </span><br></pre></td></tr></table></figure>
<p>由此可以验证，inode号确实是重新分配的。</p>
<p>(2).挂载后，挂载点的内容将暂时不可见、不可用，卸载后文件又再次可见、可用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在挂载前，向挂载点中创建几个文件 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># touch /mnt/a.txt </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># mkdir /mnt/abcdir </span></span><br><span class="line"><span class="comment"># 挂载 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># mount /dev/cdrom /mnt </span></span><br><span class="line"><span class="comment"># 挂载后，挂载点中将找不到刚创建的文件 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll /mnt </span></span><br><span class="line">total 636 </span><br><span class="line">-r--r--r-- 1 root root 14 Dec 10 2015 CentOS_BuildTag </span><br><span class="line">dr-xr-xr-x 3 root root 2048 Dec 10 2015 EFI </span><br><span class="line">-r--r--r-- 1 root root 215 Dec 10 2015 EULA </span><br><span class="line">-r--r--r-- 1 root root 18009 Dec 10 2015 GPL </span><br><span class="line">dr-xr-xr-x 3 root root 2048 Dec 10 2015 images </span><br><span class="line">dr-xr-xr-x 2 root root 2048 Dec 10 2015 isolinux </span><br><span class="line">dr-xr-xr-x 2 root root 2048 Dec 10 2015 LiveOS </span><br><span class="line">dr-xr-xr-x 2 root root 612352 Dec 10 2015 Packages </span><br><span class="line">dr-xr-xr-x 2 root root 4096 Dec 10 2015 repodata </span><br><span class="line">-r--r--r-- 1 root root 1690 Dec 10 2015 RPM-GPG-KEY-CentOS-7 </span><br><span class="line">-r--r--r-- 1 root root 1690 Dec 10 2015 RPM-GPG-KEY-CentOS-Testing-7 </span><br><span class="line">-r--r--r-- 1 root root 2883 Dec 10 2015 TRANS.TBL </span><br><span class="line"><span class="comment"># 卸载后，挂载点/mnt中的文件将再次可见 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># umount /mnt </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll /mnt </span></span><br><span class="line">total 0 </span><br><span class="line">drwxr-xr-x 2 root root 6 Jun 9 08:18 abcdir </span><br><span class="line">-rw-r--r-- 1 root root 0 Jun 9 08:18 a.txt </span><br></pre></td></tr></table></figure>
<p>之所以会这样，是因为挂载文件系统后，挂载点原来的inode记录暂时被标记为不可用，关键是没有指向该inode记录的inode指针了。在卸载文件系统后，又重新启用挂载点原来的inode记录，&quot;/&quot;目录下的mnt的inode指针又重新指向该inode记录。</p>
<p>(3).挂载后，挂载点的元数据和data block是分别存放在不同文件系统上的。</p>
<p>(4).挂载点即使在挂载后，也还是属于源文件系统的文件。</p>
<h4 id="7-3-多文件系统操作关联">7.3 多文件系统操作关联</h4>
<p>假如下图中的圆代表一块硬盘，其中划分了3个区即3个文件系统。其中根是根文件系统，/mnt是另一个文件系统A的入口，A文件系统挂载在/mnt上，/mnt/cdrom也是一个文件系统B的入口，B文件系统挂载在/mnt/cdrom上。每个文件系统都维护了一些inode table，这里假设图中的inode table是每个文件系统所有块组中的inode table的集合表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426132902871.png" alt="image-20240426132902871"></p>
<p>如何读取/var/log/messages呢?这是和&quot;/&quot;在同一个文件系统的文件读取，在前面单文件系统中已经详细说明了。</p>
<p>但如何读取A文件系统中的/mnt/a.log呢?首先，从根文件系统找到/mnt的inode记录，这是单文件系统内的查找;然后根据此inode记录的block指针，定位到/mnt的data block中，这些block是A文件系统的data block;然后从/mnt的data block中读取a.log记录，并根据a.log的inode指针定位到A文件系统的inode table中对应a.log的inode记录;最后从此inode记录的block指针找到a.log的data block。至此，就能读取到/mnt/a.log文件的内容。</p>
<p>下图能更完整的描述上述过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133033004.png" alt="image-20240426133033004"></p>
<p>那么又如何读取/mnt/cdrom中的/mnt/cdrom/a.rpm呢?这里cdrom代表的文件系统B挂载点位于/mnt下，所以又多了一个步骤。先找到&quot;/&quot;，再找到根中的mnt，进入到mnt文件系统中，找到cdrom的data block，再进入到cdrom找到a.rpm。也就是说，mnt目录文件存放位置是根，cdrom目录文件存放位置是mnt，最后a.rpm存放的位置才是cdrom。</p>
<p>继续完善上图。如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133050365.png" alt="image-20240426133050365"></p>
<h3 id="8-ext3文件系统的日志功能">8.ext3文件系统的日志功能</h3>
<p>相比ext2文件系统，ext3多了一个日志功能。</p>
<p>在ext2文件系统中，只有两个区：数据区和元数据区。如果正在向data block中填充数据时突然断电，那么下一次启动时就会检查文件系统中数据和状态的一致性，这段检查和修复可能会消耗大量时间，甚至检查后无法修复。之所以会这样是因为文件系统在突然断电后，它不知道上次正在存储的文件的block从哪里开始、哪里结束，所以它会扫描整个文件系统进行排除(也许是这样检查的吧)。</p>
<p>而在创建ext3文件系统时会划分三个区：数据区、日志区和元数据区。每次存储数据时，先在日志区中进行ext2中元数据区的活动，直到文件存储完成后标记上commit才将日志区中的数据转存到元数据区。当存储文件时突然断电，下一次检查修复文件系统时，只需要检查日志区的记录，将bmap对应的data block标记为未使用，并把inode号标记未使用，这样就不需要扫描整个文件系统而耗费大量时间。</p>
<p>虽说ext3相比ext2多了一个日志区转写元数据区的动作而导致ext3相比ext2性能要差一点，特别是写众多小文件时。但是由于ext3其他方面的优化使得ext3和ext2性能几乎没有差距。</p>
<h3 id="9-ext4文件系统">9.ext4文件系统</h3>
<p>回顾前面关于ext2和ext3文件系统的存储格式，它使用block为存储单元，每个block使用bmap中的位来标记是否空闲，尽管使用划分块组的方法优化提高了效率，但是一个块组内部仍然使用bmap来标记该块组内的block。对于一个巨大的文件，扫描整个bmap都将是一件浩大的工程。另外在inode寻址方面，ext2/3使用直接和间接的寻址方式，对于三级间接指针，可能要遍历的指针数量是非常非常巨大的。</p>
<p>ext4文件系统的最大特点是在ext3的基础上使用区(extent，或称为段)的概念来管理。一个extent尽可能的包含物理上连续的一堆block。inode寻址方面也一样使用区段树的方式进行了改进。</p>
<p>默认情况下，EXT4不再使用EXT3的block mapping分配方式 ，而改为Extent方式分配。</p>
<p>以下是ext4文件系统中一个文件的inode属性示例，注意最后两行的EXTENTS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Inode: 12 Type: regular Mode: 0644 Flags: 0x80000 </span><br><span class="line">Generation: 476513974 Version: 0x00000000:00000001 </span><br><span class="line">User: 0 Group: 0 Size: 11 </span><br><span class="line">File ACL: 0 Directory ACL: 0 </span><br><span class="line">Links: 1 Blockcount: 8 </span><br><span class="line">Fragment: Address: 0 Number: 0 Size: 0 </span><br><span class="line"> ctime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line"> atime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line"> mtime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line">crtime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line">Size of extra inode fields: 28 </span><br><span class="line">EXTENTS: </span><br><span class="line">(0):33409 </span><br></pre></td></tr></table></figure>
<p>(1). 关于EXT4的结构特征</p>
<p>EXT4在总体结构上与EXT3相似，大的分配方向都是基于相同大小的块组，每个块组内分配固定数量的inode、可能的superblock(或备份)及GDT。</p>
<p>EXT4的inode 结构做了重大改变，为增加新的信息，大小由EXT3的128字节增加到默认的256字节，同时inode寻址索引不再使用EXT3的&quot;12个直接寻址块+1个一级间接寻址块+1个二级间接寻址块+1个三级间接寻址块&quot;的索引模式，而改为4个Extent片断流，每个片断流设定片断的起始block号及连续的block数量(有可能直接指向数据区，也有可能指向索引块区)。</p>
<p>片段流即下图中索引节点(inde node block)部分的绿色区域，每个15字节，共60字节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133212168.png" alt="image-20240426133212168"></p>
<p>(2). EXT4删除数据的结构更改。</p>
<p>EXT4删除数据后，会依次释放文件系统bitmap空间位、更新目录结构、释放inode空间位。</p>
<p>(3). ext4使用多block分配方式。</p>
<p>在存储数据时，ext3中的block分配器一次只能分配4KB大小的Block数量，而且每存储一个block前就标记一次bmap。假如存储1G的文件，blocksize是4KB，那么每存储完一个Block就将调用一次block分配器，即调用的次数为1024 * 1024 / 4KB=262144次，标记bmap的次数也为1024 * 1024/4=262144次。</p>
<p>而在ext4中根据区段来分配，可以实现调用一次block分配器就分配一堆连续的block，并在存储这一堆block前一次性标记对应的bmap。这对于大文件来说极大的提升了存储效率。</p>
<h3 id="10-ext类的文件系统的缺点">10.ext类的文件系统的缺点</h3>
<p>最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢极慢的。例如将一个几十T的磁盘阵列格式化为ext4文件系统，可能你会因此而失去一切耐心。</p>
<p>除了格式化速度超慢以外，ext4文件系统还是非常可取的。当然，不同公司开发的文件系统都各有特色，最主要的还是根据需求选择合适的文件系统类型。</p>
<h3 id="11-虚拟文件系统VFS">11.虚拟文件系统VFS</h3>
<p>每一个分区格式化后都可以建立一个文件系统，Linux上可以识别很多种文件系统，那么它是如何识别的呢?另外，在我们操作分区中的文件时，并没有指定过它是哪个文件系统的，各种不同的文件系统如何被我们用户以无差别的方式操作呢?这就是虚拟文件系统的作用。</p>
<p>虚拟文件系统为用户操作各种文件系统提供了通用接口，使得用户执行程序时不需要考虑文件是在哪种类型的文件系统上，应该使用什么样的系统调用来操作该文件。有了虚拟文件系统，只要将所有需要执行的程序调用VFS的系统调用就可以了，剩下的动作由VFS来帮忙完成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133132195.png" alt="image-20240426133132195"></p>
<h3 id="参考资料">参考资料</h3>
<p>本文章摘自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.51cto.com/article/603104.html">EXT文件系统机制原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/yukun-srnyg/gxz6gg/hovdfg">操作系统-哈工大李治军老师</a></li>
</ul>
<h3 id=""></h3>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>EXT文件系统</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/93870e50.html">https://penge666.github.io/posts/93870e50.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-04-26</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-04-26</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>操作系统</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/54462149.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_1.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">页中断</div></div></a></div><div class="next-post pull-right"><a href="/posts/3e3da89f.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_7.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">malloc原理实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3e3da89f.html" title="malloc原理实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-25</div><div class="title">malloc原理实现</div></div></a></div><div><a href="/posts/54462149.html" title="页中断"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-26</div><div class="title">页中断</div></div></a></div><div><a href="/posts/80c635db.html" title="零拷贝-高效的传输文件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_19.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-26</div><div class="title">零拷贝-高效的传输文件</div></div></a></div><div><a href="/posts/e5c92e8d.html" title="Linux惊群效应"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-30</div><div class="title">Linux惊群效应</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EXT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">EXT文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">0.预备知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">1.文件系统的组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-block%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">1.1 block的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-inode%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">1.2 inode的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-bmap%E5%87%BA%E7%8E%B0"><span class="toc-text">1.3 bmap出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-inode%E8%A1%A8%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">1.4 inode表的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-imap%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">1.5 imap的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%9D%97%E7%BB%84%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">1.6 块组的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-%E5%9D%97%E7%BB%84%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-text">1.7 块组的划分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-text">2. 文件系统的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-text">2.1 引导块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B6%85%E7%BA%A7%E5%9D%97-superblock"><span class="toc-text">2.2 超级块(superblock)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%9D%97%E7%BB%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8-GDT"><span class="toc-text">2.3 块组描述符表(GDT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Reserved-GDT"><span class="toc-text">2.4 Reserved GDT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Data-Block"><span class="toc-text">3.Data Block</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84data-block"><span class="toc-text">3.1 目录文件的data block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2 符号链接存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E3%80%81FIFO%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E6%96%87%E4%BB%B6"><span class="toc-text">3.3 设备文件、FIFO、套接字文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-inode%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">4.inode基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-text">4.1 硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-text">4.2 软链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%AE%9E%E6%93%8D"><span class="toc-text">4.3 实操</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-inode%E6%B7%B1%E5%85%A5"><span class="toc-text">5.inode深入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-inode%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%88%92%E5%88%86"><span class="toc-text">5.1 inode大小和划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%A2%84%E7%95%99%E7%9A%84inode%E5%8F%B7"><span class="toc-text">5.2 ext文件系统预留的inode号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-ext2-3%E7%9A%84inode%E7%9B%B4%E6%8E%A5%E3%80%81%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-text">5.3 ext2&#x2F;3的inode直接、间接寻址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">6.单文件系统中文件操作的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">6.1 读取文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%88%A0%E9%99%A4%E3%80%81%E9%87%8D%E5%91%BD%E5%90%8D%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-text">6.2 删除、重命名和移动文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">6.3 存储和复制文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%85%B3%E8%81%94"><span class="toc-text">7.多文件系统关联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-text">7.1 根文件系统的特殊性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">7.2 挂载文件系统的细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E5%85%B3%E8%81%94"><span class="toc-text">7.3 多文件系统操作关联</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ext3%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD"><span class="toc-text">8.ext3文件系统的日志功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">9.ext4文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-ext%E7%B1%BB%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">10.ext类的文件系统的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FVFS"><span class="toc-text">11.虚拟文件系统VFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>