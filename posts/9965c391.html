<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Boost.Asio C++网络编程 | Penge666</title><meta name="keywords" content="Cpp,网络编程"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Boost.Asio C++网络编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Boost.Asio C++网络编程">
<meta property="og:url" content="https://penge666.github.io/posts/9965c391.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="Boost.Asio C++网络编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_2.webp">
<meta property="article:published_time" content="2024-05-08T12:20:00.000Z">
<meta property="article:modified_time" content="2024-05-08T12:48:36.489Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_2.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/9965c391"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Boost.Asio C++网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-08 20:48:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Boost.Asio C++网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-05-08T12:20:00.000Z" title="发表于 2024-05-08 20:20:00">2024-05-08</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-08T12:48:36.489Z" title="更新于 2024-05-08 20:48:36">2024-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a><i class="fas fa-angle-right post-meta-separator"></i><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Cpp/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">3.7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>142分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Boost.Asio C++网络编程"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言">前言</h2>
<p>网络编程由来已久，并且极富挑战性。Boost.Asio 对网络编程做了一个极好的抽象，从而保证只需要少量的代码就可以实现一个优雅的客户端/服务端软件。在实现的过程中，它能让你体会到极大的乐趣。而且更为有益的是：Boost.Asio 还包含了一些非网络的特性，用 Boost.Asio 写出来的代码紧凑、易读，而且如果按照我在书中所说的来做，你的代码将无懈可击。</p>
<p>这本书讲了什么？</p>
<p><em>第一章：Boost.Asio入门</em>将告诉你什么是 Boost.Asio？怎么编译它？然后还有一些例子。通过本章你会发现 Boost.Asio 不仅仅是一个网络库。另外你还会接触到 Boost.Asio 中最核心的类 io_service。</p>
<p><em>第二章：Boost.Asio基本原理</em>包含了你必须了解的内容：什么时候用Boost.Asio？我们将深入了解异步编程——一种比同步更需要技巧，且更有乐趣的编程方式。这一章也是在开发你自己的网络应用时做为参考的一章。</p>
<p><em>第三章：回显服务端/客户端</em>将告诉你如何实现一个小的客户端/服务端应用；也许这会是你写过的最简单的客户端/服务端应用。回显应用就是把客户端发过来的消息发送回去然后关闭客户端连接的服务。我们会先实现一个同步的版本，然后再实现一个异步的版本，这样就可以非常容易地看到它们之间的不同。</p>
<p><em>第四章：客户端和服务端</em>会深入讨论如何用 Boost.Asio 创建一个简单的客户端/服务端应用。我们将讨论如何避免内存泄漏和死锁等问题。为了让你能更方便地对它们进行扩展以满足自己的需求，所有的程序都只实现一个简单的框架。</p>
<p><em>第五章：同步VS异步</em>会带你了解在同步和异步方式之间做选择时需要考虑的事情。首要的事情就是不要混淆它们。在这一章，我们会发现：实现、测试和调试每个类型应用都是非常容易的。</p>
<p><em>第六章：Boost.Asio 的其他特性</em>将带你了解 Boost.Asio 一些不为人知的特性。你会发现，虽然 std streams 和 streambufs 有一点点难用，但是却表现出了它们得天独厚的优势。最后，是姗姗来迟的 Boost.Asio 协程，它可以让你用一种更容易读懂的方式来写异步代码。（就好像写同步代码一样）</p>
<p><em>第七章：Boost.Asio 进阶</em>包含了对 Boost.Asio 进阶问题的处理。虽然不需要在日常编程中深入研究它们，但是了解它们对你有益无害（Boost.Asio 高级调试，SSL，Windows 特性，POSIX 特性等）。</p>
<h2 id="Boost-Asio入门">Boost.Asio入门</h2>
<p>首先，让我们先来了解一下什么是Boost.Asio？怎么编译它？了解的过程中我们会给出一些例子。然后在发现Boost.Asio不仅仅是一个网络库的同时你也会接触到Boost.Asio中最核心的类——<em>io_service</em>。</p>
<h3 id="什么是Boost-Asio">什么是Boost.Asio</h3>
<p>简单来说，Boost.Asio是一个跨平台的、主要用于网络和其他一些底层输入/输出编程的C++库。</p>
<p>计算机网络的设计方式有很多种，但是Boost.Asio的的方式远远优于其它的设计方式。它在2005年就被包含进Boost，然后被大量Boost的用户测试并在很多项目中使用，比如Remobo(<a target="_blank" rel="noopener" href="http://www.remobo.com/">http://www.remobo.com</a>)，可以让你创建你自己的**即时私有网络(IPN)**的应用，libtorrent(<a target="_blank" rel="noopener" href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/%5Bhttp:/www.rasterbar.com/products/libtorrent%5D(http:/www.rasterbar.com/products/libtorrent)">http://www.rasterbar.com/products/libtorrent</a>)一个实现了比特流客户端的库，PokerTH (<a target="_blank" rel="noopener" href="http://www.pokerth.net/">http://www.pokerth.net</a>)一个支持LAN和互联网对战的纸牌游戏。</p>
<p>Boost.Asio在网络通信、COM串行端口和文件上成功地抽象了输入输出的概念。你可以基于这些进行同步或者异步的输入输出编程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(stream, buffer [, extra options])</span><br><span class="line"><span class="built_in">async_read</span>(stream, buffer [, extra options], handler)</span><br><span class="line"><span class="built_in">write</span>(stream, buffer [, extra options])</span><br><span class="line"><span class="built_in">async_write</span>(stream, buffer [, extra options], handler)</span><br></pre></td></tr></table></figure>
<p>从前面的代码片段可以看出，这些函数支持传入包含任意内容（不仅仅是一个socket，我们可以对它进行读写）的流实例。</p>
<p>作为一个跨平台的库，Boost.Asio可以在大多数操作系统上使用。能同时支持数千个并发的连接。其网络部分的灵感来源于<strong>伯克利软件分发(BSD)socket</strong>，它提供了一套可以支持**传输控制协议(TCP)**socket、**用户数据报协议(UDP)<strong>socket和</strong>Internet控制消息协议(IMCP)**socket的API，而且如果有需要，你可以对其进行扩展以支持你自己的协议。</p>
<h3 id="历史">历史</h3>
<p>Boost.Asio在2003被开发出来，然后于2005年的12月引入到Boost 1.35版本中。原作者是Christopher M. Kohlhoff，你可以通过<a target="_blank" rel="noopener" href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/chris@kohlhoff.com">chris@kohlhoff.com</a>联系他。</p>
<p>这个库在以下的平台和编译器上测试通过：</p>
<ul>
<li>32-bit和64-bit Windows，使用Visual C++ 7.1及以上</li>
<li>Windows下使用MinGW</li>
<li>Windows下使用Cygwin(确保已经定义 __USE_232_SOCKETS)</li>
<li>基于2.4和2.6内核的Linux，使用g++ 3.3及以上</li>
<li>Solaris下使用g++ 3.3及以上</li>
<li>MAC OS X 10.4以上下使用g++ 3.3及以上</li>
</ul>
<p>它也可能能在诸如AIX 5.3，HP-UX 11i v3，QNX Neutrino 6.3，Solaris下使用Sun Studio 11以上，True64 v5.1，Windows下使用Borland C++ 5.9.2以上等平台上使用。（更多细节请咨询<a target="_blank" rel="noopener" href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/www.boost.org">www.boost.org</a>）</p>
<h3 id="依赖">依赖</h3>
<p>Boost.Asio依赖于如下的库：</p>
<ul>
<li><strong>Boost.System</strong>：这个库为Boost库提供操作系统支持(<a target="_blank" rel="noopener" href="http://www.boost.org/doc/libs/1_51_0/doc/html/boost_system/index.html">http://www.boost.org/doc/libs/1_51_0/doc/html/boost_system/index.html</a>)</li>
<li><strong>Boost.Regex</strong>：使用这个库（可选的）以便你重载<em>read_until()<em>或者</em>async_read_until()<em>时使用</em>boost::regex</em>参数。</li>
<li><strong>Boost.DateTime</strong>：使用这个库（可选的）以便你使用Boost.Asio中的计时器</li>
<li><strong>OpenSSL</strong>：使用这个库（可选的）以便你使用Boost.Asio提供的SSL支持。</li>
</ul>
<h3 id="编译Boost-Asio">编译Boost.Asio</h3>
<p>Boost.Asio是一个只需要引入头文件就可以使用的库。然而，考虑到你的编译器和程序的大小，你可以选择用源文件的方式来编译Boost.Asio。如果你想要这么做以减少编译时间，有如下几种方式：</p>
<p>在某个源文件中，添加*#include “boost/asio/impl/src.hpp”<em>（如果你在使用SSL，添加</em>#include “boost/asio/ssl/impl/src.hpp”<em>） 在所有的源文件中，添加</em>#define BOOST_ASIO_SEPARATE_COMPILATION*</p>
<p>注意Boost.Asio依赖于Boost.System，必要的时候还依赖于Boost.Regex，所以你需要用如下的指令先编译Boost：</p>
<p><em>bjam –with-system –with-regex stage</em></p>
<p>如果你还想同时编译tests，你需要使用如下的指令：</p>
<p><em>bjam –with-system –with-thread –with-date_time –with-regex –with-serialization stage</em></p>
<p>这个库有大量的例子，你可以连同本书中的例子一块看看。</p>
<h3 id="重要的宏">重要的宏</h3>
<p>如果设置了<em>BOOST_ASIO_DISABLE_THREADS</em>；不管你是否在编译Boost的过程中使用了线程支持，Boost.Asio中的线程支持都会失效。</p>
<h3 id="同步VS异步">同步VS异步</h3>
<p>首先，异步编程和同步编程是非常不同的。在同步编程中，所有的操作都是顺序执行的，比如从socket中读取（请求），然后写入（回应）到socket中。每一个操作都是阻塞的。因为操作是阻塞的，所以为了不影响主程序，当在socket上读写时，通常会创建一个或多个线程来处理socket的输入/输出。因此，同步的服务端/客户端通常是多线程的。</p>
<p>相反的，异步编程是事件驱动的。虽然启动了一个操作，但是你不知道它何时会结束；它只是提供一个回调给你，当操作结束时，它会调用这个API，并返回操作结果。对于有着丰富经验的QT（诺基亚用来创建跨平台图形用户界面应用程序的库）程序员来说，这就是他们的第二天性。因此，在异步编程中，你只需要一个线程。</p>
<p>因为中途做改变会非常困难而且容易出错，所以你在项目初期（最好是一开始）就得决定用同步还是异步的方式实现网络通信。不仅API有极大的不同，你程序的语意也会完全改变（异步网络通信通常比同步网络通信更加难以测试和调试）。你需要考虑是采用阻塞调用和多线程的方式（同步，通常比较简单），或者是更少的线程和事件驱动（异步，通常更复杂）。</p>
<p>下面是一个基础的同步客户端例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">2001</span>)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">connect</span>(ep);</span><br></pre></td></tr></table></figure>
<p>首先，你的程序至少需要一个<em>io_service</em>实例。Boost.Asio使用<em>io_service</em>同操作系统的输入/输出服务进行交互。通常一个<em>io_service</em>的实例就足够了。然后，创建你想要连接的地址和端口，再建立socket。把socket连接到你创建的地址和端口。</p>
<p>下面是一个简单的使用Boost.Asio的服务端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;ip::tcp::socket&gt; socket_ptr;</span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::tcp::v4(), <span class="number">2001</span>)</span>)</span>; <span class="comment">// listen on 2001</span></span><br><span class="line">ip::<span class="function">tcp::acceptor <span class="title">acc</span><span class="params">(service, ep)</span></span>;</span><br><span class="line"><span class="keyword">while</span> ( <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> ip::tcp::socket(service))</span></span>;</span><br><span class="line">    acc.<span class="built_in">accept</span>(*sock);</span><br><span class="line">    boost::<span class="built_in">thread</span>( boost::<span class="built_in">bind</span>(client_session, sock));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_session</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line">        <span class="type">size_t</span> len = sock-&gt;<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(data));</span><br><span class="line">        <span class="keyword">if</span> ( len &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">write</span>(*sock, <span class="built_in">buffer</span>(<span class="string">&quot;ok&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，同样是至少需要一个<em>io_service</em>实例。然后你指定你想要监听的端口，再创建一个接收器——一个用来接收客户端连接的对象。 在接下来的循环中，你创建一个虚拟的socket来等待客户端的连接。然后当一个连接被建立时，你创建一个线程来处理这个连接。</p>
<p><em>在client_session</em>线程中来读取一个客户端的请求，进行解析，然后返回结果。</p>
<p>而创建一个异步的客户端，你需要做如下的事情：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">2001</span>)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">async_connect</span>(ep, connect_handler);</span><br><span class="line">service.<span class="built_in">run</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; ec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果ec返回成功我们就可以知道连接成功了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中你需要创建至少一个<em>io_service</em>实例。你需要指定连接的地址以及创建socket。</p>
<p>当连接完成时（其完成处理程序）你就异步地连接到了指定的地址和端口，也就是说，<em>connect_handler</em>被调用了。</p>
<p>当<em>connect_handler</em>被调用时，检查错误代码（<em>ec</em>），如果成功，你就可以向服务端进行异步的写入。</p>
<p>注意：只要还有待处理的异步操作，<em>servece.run()<em>循环就会一直运行。在上述例子中，只执行了一个这样的操作，就是socket的</em>async_connect</em>。在这之后，*service.run()*就退出了。</p>
<p>每一个异步操作都有一个完成处理程序——一个操作完成之后被调用的函数。 下面的代码是一个基本的异步服务端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::asio;</span><br><span class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;ip::tcp::socket&gt; socket_ptr;</span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::tcp::v4(), <span class="number">2001</span>)</span>)</span>; <span class="comment">// 监听端口2001</span></span><br><span class="line">ip::<span class="function">tcp::acceptor <span class="title">acc</span><span class="params">(service, ep)</span></span>;</span><br><span class="line"><span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> ip::tcp::socket(service))</span></span>;</span><br><span class="line"><span class="built_in">start_accept</span>(sock);</span><br><span class="line">service.<span class="built_in">run</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line">    acc.<span class="built_in">async_accept</span>(*sock, boost::<span class="built_in">bind</span>( handle_accept, sock, _1) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(socket_ptr sock, <span class="type">const</span> boost::system::error_code &amp;</span></span></span><br><span class="line"><span class="params"><span class="function">err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从这里开始, 你可以从socket读取或者写入</span></span><br><span class="line">    <span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> ip::tcp::socket(service))</span></span>;</span><br><span class="line">    <span class="built_in">start_accept</span>(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码片段中，首先，你创建一个<em>io_service</em>实例，指定监听的端口。然后，你创建接收器acc——一个接受客户端连接，创建虚拟的socket，异步等待客户端连接的对象。</p>
<p>最后，运行异步<em>service.run()<em>循环。当接收到客户端连接时，<em>handle_accept</em>被调用（调用</em>async_accept</em>的完成处理程序）。如果没有错误，这个socket就可以用来做读写操作。</p>
<p>在使用这个socket之后，你创建了一个新的socket，然后再次调用<em>start_accept()</em>，用来创建另外一个“等待客户端连接”的异步操作，从而使*service.run()*循环一直保持忙碌状态。</p>
<h3 id="异常处理VS错误代码">异常处理VS错误代码</h3>
<p>Boost.Asio允许同时使用异常处理或者错误代码，所有的异步函数都有抛出错误和返回错误码两种方式的重载。当函数抛出错误时，它通常抛出<em>boost::system::system_error</em>的错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::asio;</span><br><span class="line">ip::tcp::endpoint ep;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">connect</span>(ep); <span class="comment">// 第一行</span></span><br><span class="line">boost::system::error_code err;</span><br><span class="line">sock.<span class="built_in">connect</span>(ep, err); <span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure>
<p>在前面的代码中，*sock.connect(ep)*会抛出错误，*sock.connect(ep, err)*则会返回一个错误码。</p>
<p>看一下下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">&#125; <span class="built_in">catch</span>(boost::system::system_error e) &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码片段和前面的是一样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boost::system::error_code err;</span><br><span class="line">sock.<span class="built_in">connect</span>(ep, err);</span><br><span class="line"><span class="keyword">if</span> ( err)</span><br><span class="line">    std::cout &lt;&lt; err &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>当使用异步函数时，你可以在你的回调函数里面检查其返回的错误码。异步函数从来不抛出异常，因为这样做毫无意义。那谁会捕获到它呢？</p>
<p>在你的异步函数中，你可以使用异常处理或者错误码（随心所欲），但要保持一致性。同时使用这两种方式会导致问题，大部分时候是崩溃（当你不小心出错，忘记去处理一个抛出来的异常时）。如果你的代码很复杂（调用很多socket读写函数），你最好选择异常处理的方式，把你的读写包含在一个函数<em>try {} catch</em>块里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_session</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="built_in">catch</span> ( boost::system::system_error e) &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用错误码，你可以使用下面的代码片段很好地检测连接是何时关闭的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line">boost::system::error_code error;</span><br><span class="line"><span class="type">size_t</span> length = sock.<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(data), error);</span><br><span class="line"><span class="keyword">if</span> (error == error::eof)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 连接关闭</span></span><br></pre></td></tr></table></figure>
<p>Boost.Asio的所有错误码都包含在ˆ的命名空间中（以便你创造一个大型的switch来检查错误的原因）。如果想要了解更多的细节，请参照<em>boost/asio/error.hpp</em>头文件</p>
<h3 id="Boost-Asio中的线程">Boost.Asio中的线程</h3>
<p>当说到Boost.Asio的线程时，我们经常在讨论：</p>
<ul>
<li><em>io_service</em>:<em>io_service</em>是线程安全的。几个线程可以同时调用<em>io_service::run()</em>。大多数情况下你可能在一个单线程函数中调用<em>io_service::run()</em>，这个函数必须等待所有异步操作完成之后才能继续执行。然而，事实上你可以在多个线程中调用<em>io_service::run()</em>。这会阻塞所有调用<em>io_service::run()<em>的线程。只要当中任何一个线程调用了</em>io_service::run()</em>，所有的回调都会同时被调用；这也就意味着，当你在一个线程中调用*io_service::run()*时，所有的回调都被调用了。</li>
<li><em>socket</em>:<em>socket</em>类不是线程安全的。所以，你要避免在某个线程里读一个socket时，同时在另外一个线程里面对其进行写入操作。（通常来说这种操作都是不推荐的，更别说Boost.Asio）。</li>
<li><em>utility</em>:就<em>utility</em>来说，因为它不是线程安全的，所以通常也不提倡在多个线程里面同时使用。里面的方法经常只是在很短的时间里面使用一下，然后就释放了。</li>
</ul>
<p>除了你自己创建的线程，Boost.Asio本身也包含几个线程。但是可以保证的是那些线程不会调用你的代码。这也意味着，只有调用了*io_service::run()*方法的线程才会调用回调函数。</p>
<h3 id="不仅仅是网络通信">不仅仅是网络通信</h3>
<p>除了网络通信，Boost.Asio还包含了其他的I/O功能。</p>
<p>Boost.Asio支持信号量，比如<em>SIGTERM</em>（软件终止）、<em>SIGINT</em>（中断信号）、<em>SIGSEGV</em>（段错误）等等。 你可以创建一个<em>signal_set</em>实例，指定异步等待的信号量，然后当这些信号量产生时，就会调用你的异步处理程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; err, <span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 纪录日志，然后退出应用</span></span><br><span class="line">&#125;</span><br><span class="line">boost::<span class="function">asio::signal_set <span class="title">sig</span><span class="params">(service, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">sig.<span class="built_in">async_wait</span>(signal_handler);</span><br></pre></td></tr></table></figure>
<p>如果<em>SIGINT</em>产生，你就能在你的<em>signal_handler</em>回调中捕获到它。</p>
<p>你可以使用Boost.Asio轻松地连接到一个串行端口。在Windows上端口名称是<em>COM7</em>，在POSIX平台上是*/dev/ttyS0*。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line"><span class="function">serial_port <span class="title">sp</span><span class="params">(service, <span class="string">&quot;COM7&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>打开端口后，你就可以使用下面的代码设置一些端口选项，比如端口的波特率、奇偶校验和停止位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">serial_port::baud_rate <span class="title">rate</span><span class="params">(<span class="number">9600</span>)</span></span>;</span><br><span class="line">sp.<span class="built_in">set_option</span>(rate);</span><br></pre></td></tr></table></figure>
<p>打开端口后，你可以把这个串行端口看做一个流，然后基于它使用自由函数对串行端口进行读/写操作。比如<em>async_read(), write, async_write(),</em> 就像下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">read</span>(sp, <span class="built_in">buffer</span>(data, <span class="number">512</span>));</span><br></pre></td></tr></table></figure>
<p>Boost.Asio也可以连接到Windows的文件，然后同样使用自由函数，比如*read(), asyn_read()*等等，就像下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = ::<span class="built_in">OpenFile</span>(...);</span><br><span class="line"><span class="function">windows::stream_handle <span class="title">sh</span><span class="params">(service, h)</span></span>;</span><br><span class="line"><span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">read</span>(h, <span class="built_in">buffer</span>(data, <span class="number">512</span>));</span><br></pre></td></tr></table></figure>
<p>对于POXIS文件描述符，比如管道，标准I/O和各种设备（但不包括普通文件）你也可以这样做，就像下面的代码所做的一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">posix::stream_descriptor <span class="title">sd_in</span><span class="params">(service, ::dup(STDIN_FILENO))</span></span>;</span><br><span class="line"><span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">read</span>(sd_in, <span class="built_in">buffer</span>(data, <span class="number">512</span>));</span><br></pre></td></tr></table></figure>
<h3 id="计时器">计时器</h3>
<p>一些I/O操作需要一个超时时间。这只能应用在异步操作上（同步意味着阻塞，因此没有超时时间）。例如，下一条信息必须在100毫秒内从你的同伴那传递给你。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> read = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deadline_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; (read ? <span class="string">&quot;read successfully&quot;</span> : <span class="string">&quot;read failed&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;)</span> </span>&#123;</span><br><span class="line">    read = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">…</span><br><span class="line">read = <span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line">sock.<span class="built_in">async_read_some</span>(<span class="built_in">buffer</span>(data, <span class="number">512</span>));</span><br><span class="line"><span class="function">deadline_timer <span class="title">t</span><span class="params">(service, boost::posix_time::milliseconds(<span class="number">100</span>))</span></span>;</span><br><span class="line">t.<span class="built_in">async_wait</span>(&amp;deadline_handler);</span><br><span class="line">service.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>
<p>在上述代码片段中，如果你在超时之前读完了数据，<em>read</em>则被设置成true，这样我们的伙伴就及时地通知了我们。否则，当<em>deadline_handler</em>被调用时，<em>read</em>还是false，也就意味着我们的操作超时了。</p>
<p>Boost.Asio也支持同步计时器，但是它们通常和一个简单的sleep操作是一样的。*boost::this_thread::sleep(500);*这段代码和下面的代码片段完成了同一件事情：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">deadline_timer</span> <span class="selector-tag">t</span>(service, <span class="attribute">boost</span>::<span class="attribute">posix_time</span>::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"><span class="selector-tag">t</span><span class="selector-class">.wait</span>();</span><br></pre></td></tr></table></figure>
<h3 id="io-service类">io_service类</h3>
<p>你应该已经发现大部分使用Boost.Asio编写的代码都会使用几个<em>io_service</em>的实例。<em>io_service</em>是这个库里面最重要的类；它负责和操作系统打交道，等待所有异步操作的结束，然后为每一个异步操作调用其完成处理程序。</p>
<p>如果你选择用同步的方式来创建你的应用，你则不需要考虑我将在这一节向你展示的东西。 你有多种不同的方式来使用<em>io_service</em>。在下面的例子中，我们有3个异步操作，2个socket连接操作和一个计时器等待操作：</p>
<ul>
<li>
<p>有一个</p>
<p>io_service</p>
<p>实例和一个处理线程的单线程例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io_service service; <span class="comment">// 所有socket操作都由service来处理 </span></span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock1</span><span class="params">(service)</span></span>; <span class="comment">// all the socket operations are handled by service </span></span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock2</span><span class="params">(service)</span></span>; sock1.<span class="built_in">asyncconnect</span>( ep, connect_handler); </span><br><span class="line">sock2.<span class="built_in">async_connect</span>( ep, connect_handler); </span><br><span class="line"><span class="function">deadline_timer <span class="title">t</span><span class="params">(service, boost::posixtime::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line">t.<span class="built_in">async_wait</span>(timeout_handler); </span><br><span class="line">service.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有一个io_service实例和多个处理线程的多线程例子：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock1</span><span class="params">(service)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock2</span><span class="params">(service)</span></span>;</span><br><span class="line">sock1.<span class="built_in">asyncconnect</span>( ep, connect_handler);</span><br><span class="line">sock2.<span class="built_in">async_connect</span>( ep, connect_handler);</span><br><span class="line"><span class="function">deadline_timer <span class="title">t</span><span class="params">(service, boost::posixtime::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line">t.<span class="built_in">async_wait</span>(timeout_handler);</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    boost::<span class="built_in">thread</span>( run_service);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_service</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有多个<em>io_service</em>实例和多个处理线程的多线程例子：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">io_service service[<span class="number">2</span>];</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock1</span><span class="params">(service[<span class="number">0</span>])</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock2</span><span class="params">(service[<span class="number">1</span>])</span></span>;</span><br><span class="line">sock1.<span class="built_in">asyncconnect</span>( ep, connect_handler);</span><br><span class="line">sock2.<span class="built_in">async_connect</span>( ep, connect_handler);</span><br><span class="line"><span class="function">deadline_timer <span class="title">t</span><span class="params">(service[<span class="number">0</span>], boost::posixtime::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line">t.<span class="built_in">async_wait</span>(timeout_handler);</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    boost::<span class="built_in">thread</span>( boost::<span class="built_in">bind</span>(run_service, i));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_service</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    service[idx].<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，要注意你不能拥有多个<em>io_service</em>实例却只有一个线程。下面的代码片段没有任何意义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    service[i].<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>
<p>上面的代码片段没有意义是因为*service[1].run()<em>需要</em>service[0].run()<em>先结束。因此，所有由</em>service[1]*处理的异步操作都需要等待，这显然不是一个好主意。</p>
<p>在前面的3个方案中，我们在等待3个异步操作结束。为了解释它们之间的不同点，我们假设：过一会操作1完成，然后接着操作2完成。同时我们假设每一个完成处理程序需要1秒钟来完成执行。</p>
<p>在第一个例子中，我们在一个线程中等待三个操作全部完成，第1个操作一完成，我们就调用它的完成处理程序。尽管操作2紧接着完成了，但是操作2的完成处理程序需要在1秒钟后，也就是操作1的完成处理程序完成时才会被调用。</p>
<p>第二个例子，我们在两个线程中等待3个异步操作结束。当操作1完成时，我们在第1个线程中调用它的完成处理程序。当操作2完成时，紧接着，我们就在第2个线程中调用它的完成处理程序（当线程1在忙着响应操作1的处理程序时，线程2空闲着并且可以回应任何新进来的操作）。</p>
<p>在第三个例子中，因为操作1是<em>sock1</em>的<em>connect</em>，操作2是<em>sock2</em>的<em>connect</em>，所以应用程序会表现得像第二个例子一样。线程1会处理<em>sock1</em> <em>connect</em>操作的完成处理程序，线程2会处理<em>sock2</em>的<em>connect</em>操作的完成处理程序。然而，如果<em>sock1</em>的<em>connect</em>操作是操作1，<em>deadline_timer t</em>的超时操作是操作2，线程1会结束正在处理的<em>sock1</em> <em>connect</em>操作的完成处理程序。因而，<em>deadline_timer t</em>的超时操作必须等<em>sock1</em> <em>connect</em>操作的完成处理程序结束（等待1秒钟），因为线程1要处理<em>sock1</em>的连接处理程序和<em>t</em>的超时处理程序。</p>
<p>下面是你需要从前面的例子中学到的：</p>
<ul>
<li>第一种情况是非常基础的应用程序。因为是串行的方式，所以当几个处理程序需要被同时调用时，你通常会遇到瓶颈。如果一个处理程序需要花费很长的时间来执行，所有随后的处理程序都不得不等待。</li>
<li>第二种情况是比较适用的应用程序。他是非常强壮的——如果几个处理程序被同时调用了（这是有可能的），它们会在各自的线程里面被调用。唯一的瓶颈就是所有的处理线程都很忙的同时又有新的处理程序被调用。然而，这是有快速的解决方式的，增加处理线程的数目即可。</li>
<li>第三种情况是最复杂和最难理解的。你只有在第二种情况不能满足需求时才使用它。这种情况一般就是当你有成千上万实时（socket）连接时。你可以认为每一个处理线程（运行<em>io_service::run()<em>的线程）有它自己的</em>select/epoll</em>循环；它等待任意一个socket连接，然后等待一个读写操作，当它发现这种操作时，就执行。大部分情况下，你不需要担心什么，唯一你需要担心的就是当你监控的socket数目以指数级的方式增长时（超过1000个的socket）。在那种情况下，有多个select/epoll循环会增加应用的响应时间。</li>
</ul>
<p>如果你觉得你的应用程序可能需要转换到第三种模式，请确保监听操作的这段代码（调用*io_service::run()*的代码）和应用程序其他部分是隔离的，这样你就可以很轻松地对其进行更改。</p>
<p>最后，需要一直记住的是如果没有其他需要监控的操作，*.run()*就会结束，就像下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io_service service; </span><br><span class="line"><span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>; </span><br><span class="line">sock.<span class="built_in">async_connect</span>( ep, connect_handler); </span><br><span class="line">service.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，只要sock建立了一个连接，<em>connect_handler</em>就会被调用，然后接着*service.run()*就会完成执行。</p>
<p>如果你想要<em>service.run()<em>接着执行，你需要分配更多的工作给它。这里有两个方式来完成这个目标。一种方式是在</em>connect_handler</em>中启动另外一个异步操作来分配更多的工作。 另一种方式会模拟一些工作给它，用下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::shared_ptr work_ptr;</span><br><span class="line"><span class="function">work_ptr <span class="title">dummy_work</span><span class="params">(<span class="keyword">new</span> io_service::work(service))</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以保证*service.run()<em>一直运行直到你调用</em>useservice.stop()*或者 <em>dummy_work.reset(0);</em>// 销毁 dummy_work.</p>
<h3 id="总结">总结</h3>
<p>做为一个复杂的库，Boost.Asio让网络编程变得异常简单。构建起来也简单。而且在避免使用宏这一点上也做得很好；它虽然定义了少部分的宏来做选项开关，但是你需要关心的很少。</p>
<p>Boost.Asio支持同步和异步编程。他们有很大不同；你需要在项目早期就选择其中的一种来实现，因为它们之间的转换是非常复杂而且易错的。</p>
<p>如果你选择同步，你可以选择异常处理或者错误码，从异常处理转到错误码；只需要在call函数中增加一个参数即可（错误码）。</p>
<p>Boost.Asio不仅仅可以用来做网络编程。它还有其他更多的特性，这让它显得更有价值，比如信号量，计时器等等。</p>
<h2 id="Boost-Asio基本原理">Boost.Asio基本原理</h2>
<p>这一章涵盖了使用Boost.Asio时必须知道的一些事情。我们也将深入研究比同步编程更复杂、更有乐趣的异步编程。</p>
<h3 id="网络API">网络API</h3>
<p>这一部分包含了当使用Boost.Asio编写网络应用程序时必须知道的事情。</p>
<h3 id="Boost-Asio命名空间">Boost.Asio命名空间</h3>
<p>Boost.Asio的所有内容都包含在boost::asio命名空间或者其子命名空间内。</p>
<ul>
<li><em>boost::asio</em>：这是核心类和函数所在的地方。重要的类有io_service和streambuf。类似<em>read, read_at, read_until</em>方法，它们的异步方法，它们的写方法和异步写方法等自由函数也在这里。</li>
<li><em>boost::asio::ip</em>：这是网络通信部分所在的地方。重要的类有<em>address, endpoint, tcp, udp和icmp</em>，重要的自由函数有<em>connect</em>和<em>async_connect</em>。要注意的是在<em>boost::asio::ip::tcp::socket</em>中间，<em>socket</em>只是<em>boost::asio::ip::tcp</em>类中间的一个<em>typedef</em>关键字。</li>
<li><em>boost::asio::error</em>：这个命名空间包含了调用I/O例程时返回的错误码</li>
<li><em>boost::asio::ssl</em>：包含了SSL处理类的命名空间</li>
<li><em>boost::asio::local</em>：这个命名空间包含了POSIX特性的类</li>
<li><em>boost::asio::windows</em>：这个命名空间包含了Windows特性的类</li>
</ul>
<h3 id="IP地址">IP地址</h3>
<p>对于IP地址的处理，Boost.Asio提供了<em>ip::address , ip::address_v4</em>和<em>ip::address_v6</em>类。 它们提供了相当多的函数。下面列出了最重要的几个：</p>
<ul>
<li><em>ip::address(v4_or_v6_address)</em>:这个函数把一个v4或者v6的地址转换成<em>ip::address</em></li>
<li><em>ip::address:from_string(str)</em>：这个函数根据一个IPv4地址（用.隔开的）或者一个IPv6地址（十六进制表示）创建一个地址。</li>
<li><em>ip::address::to_string()</em> ：这个函数返回这个地址的字符串。</li>
<li><em>ip::address_v4::broadcast([addr, mask])</em>:这个函数创建了一个广播地址 <em>ip::address_v4::any()</em>：这个函数返回一个能表示任意地址的地址。</li>
<li><em>ip::address_v4::loopback(), ip_address_v6::loopback()</em>：这个函数返回环路地址（为v4/v6协议）</li>
<li><em>ip::host_name()</em>：这个函数用string数据类型返回当前的主机名。</li>
</ul>
<p>大多数情况你会选择用<em>ip::address::from_string</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip::address addr = ip::address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果你想通过一个主机名进行连接，下面的代码片段是无用的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line">ip::address addr = ip::address::<span class="built_in">from_string</span>(<span class="string">&quot;www.yahoo.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="端点">端点</h3>
<p>端点是使用某个端口连接到的一个地址。不同类型的socket有它自己的<em>endpoint</em>类，比如<em>ip::tcp::endpoint、ip::udp::endpoint</em>和<em>ip::icmp::endpoint</em></p>
<p>如果想连接到本机的80端口，你可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">80</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有三种方式来让你建立一个端点：</p>
<ul>
<li><em>endpoint()</em>：这是默认构造函数，某些时候可以用来创建UDP/ICMP socket。</li>
<li><em>endpoint(protocol, port)</em>：这个方法通常用来创建可以接受新连接的服务器端socket。</li>
<li><em>endpoint(addr, port)</em>:这个方法创建了一个连接到某个地址和端口的端点。</li>
</ul>
<p>例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip::tcp::endpoint ep1;</span><br><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep2</span><span class="params">(ip::tcp::v4(), <span class="number">80</span>)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep3</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1), 80);</span></span></span></span><br></pre></td></tr></table></figure>
<p>如果你想连接到一个主机（不是IP地址），你需要这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 &quot;87.248.122.122&quot;</span></span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(service)</span></span>;</span><br><span class="line">ip::tcp::<span class="function">resolver::query <span class="title">query</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;80&quot;</span>)</span></span>;</span><br><span class="line">ip::tcp::resolver::iterator iter = resolver.<span class="built_in">resolve</span>( query);</span><br><span class="line">ip::tcp::endpoint ep = *iter;</span><br><span class="line">std::cout &lt;&lt; ep.<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>你可以用你需要的socket类型来替换tcp。首先，为你想要查询的名字创建一个查询器，然后用resolve()函数解析它。如果成功，它至少会返回一个入口。你可以利用返回的迭代器，使用第一个入口或者遍历整个列表来拿到全部的入口。</p>
<p>给定一个端点，可以获得他的地址，端口和IP协议（v4或者v6）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; ep.<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ep.<span class="built_in">port</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; ep.<span class="built_in">protocol</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="套接字">套接字</h3>
<p>Boost.Asio有三种类型的套接字类：<em>ip::tcp, ip::udp</em>和<em>ip::icmp</em>。当然它也是可扩展的，你可以创建自己的socket类，尽管这相当复杂。如果你选择这样做，参照一下<em>boost/asio/ip/tcp.hpp, boost/asio/ip/udp.hpp</em>和<em>boost/asio/ip/icmp.hpp</em>。它们都是含有内部typedef关键字的超小类。</p>
<p>你可以把<em>ip::tcp, ip::udp, ip::icmp</em>类当作占位符；它们可以让你便捷地访问其他类/函数，如下所示：</p>
<ul>
<li><em>ip::tcp::socket, ip::tcp::acceptor, ip::tcp::endpoint,ip::tcp::resolver, ip::tcp::iostream</em></li>
<li><em>ip::udp::socket, ip::udp::endpoint, ip::udp::resolver</em></li>
<li><em>ip::icmp::socket, ip::icmp::endpoint, ip::icmp::resolver</em></li>
</ul>
<p><em>socket</em>类创建一个相应的<em>socket</em>。而且总是在构造的时候传入io_service实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">udp::socket <span class="title">sock</span><span class="params">(service)</span></span></span><br><span class="line"><span class="function">sock.<span class="title">set_option</span><span class="params">(ip::udp::socket::reuse_address(<span class="literal">true</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>每一个socket的名字都是一个typedef关键字</p>
<ul>
<li><em>ip::tcp::socket = basic_stream_socket</em></li>
<li><em>ip::udp::socket = basic_datagram_socket</em></li>
<li><em>ip::icmp::socket = basic_raw_socket</em></li>
</ul>
<h3 id="同步错误码">同步错误码</h3>
<p>所有的同步函数都有抛出异常或者返回错误码的重载，比如下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sync_func</span>( arg1, arg2 ... argN); <span class="comment">// 抛出异常</span></span><br><span class="line">boost::system::error_code ec;</span><br><span class="line"><span class="built_in">sync_func</span>( arg1 arg2, ..., argN, ec); <span class="comment">// 返回错误码</span></span><br></pre></td></tr></table></figure>
<p>在这一章剩下的部分，你会见到大量的同步函数。简单起见，我省略了有返回错误码的重载，但是不可否认它们确实是存在的。</p>
<h3 id="socket成员方法">socket成员方法</h3>
<p>这些方法被分成了几组。并不是所有的方法都可以在各个类型的套接字里使用。这个部分的结尾将有一个列表来展示各个方法分别属于哪个socket类。</p>
<p>注意所有的异步方法都立刻返回，而它们相对的同步实现需要操作完成之后才能返回。</p>
<h3 id="连接相关的函数">连接相关的函数</h3>
<p>这些方法是用来连接或绑定socket、断开socket字连接以及查询连接是活动还是非活动的：</p>
<ul>
<li><em>assign(protocol,socket)</em>：这个函数分配了一个原生的socket给这个socket实例。当处理老（旧）程序时会使用它（也就是说，原生socket已经被建立了）</li>
<li><em>open(protocol)</em>：这个函数用给定的IP协议（v4或者v6）打开一个socket。你主要在UDP/ICMP socket，或者服务端socket上使用。</li>
<li><em>bind(endpoint)</em>：这个函数绑定到一个地址</li>
<li><em>connect(endpoint)</em>：这个函数用同步的方式连接到一个地址</li>
<li><em>async_connect(endpoint)</em>：这个函数用异步的方式连接到一个地址</li>
<li><em>is_open()</em>：如果套接字已经打开，这个函数返回true</li>
<li><em>close()</em>：这个函数用来关闭套接字。调用时这个套接字上任何的异步操作都会被立即关闭，同时返回<em>error::operation_aborted</em>错误码。</li>
<li><em>shutdown(type_of_shutdown)</em>：这个函数立即使send或者receive操作失效，或者两者都失效。</li>
<li><em>cancel()</em>：这个函数取消套接字上所有的异步操作。这个套接字上任何的异步操作都会立即结束，然后返回<em>error::operation_aborted</em>错误码。</li>
</ul>
<p>例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">80</span>)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">open</span>(ip::tcp::<span class="built_in">v4</span>()); n</span><br><span class="line">sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">sock.<span class="built_in">write_some</span>(<span class="built_in">buffer</span>(<span class="string">&quot;GET /index.html\r\n&quot;</span>));</span><br><span class="line"><span class="type">char</span> buff[<span class="number">1024</span>]; sock.<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(buff,<span class="number">1024</span>));</span><br><span class="line">sock.<span class="built_in">shutdown</span>(ip::tcp::socket::shutdown_receive);</span><br><span class="line">sock.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<h3 id="读写函数">读写函数</h3>
<p>这些是在套接字上执行I/O操作的函数。</p>
<p>对于异步函数来说，处理程序的格式*void handler(const boost::system::error_code&amp; e, size_t bytes)*都是一样的</p>
<ul>
<li><em>async_receive(buffer, [flags,] handler)</em>：这个函数启动从套接字异步接收数据的操作。</li>
<li><em>async_read_some(buffer,handler)</em>：这个函数和*async_receive(buffer, handler)*功能一样。</li>
<li><em>async_receive_from(buffer, endpoint[, flags], handler)</em>：这个函数启动从一个指定端点异步接收数据的操作。</li>
<li><em>async_send(buffer [, flags], handler)</em>：这个函数启动了一个异步发送缓冲区数据的操作。</li>
<li><em>async_write_some(buffer, handler)</em>：这个函数和a*sync_send(buffer, handler)*功能一致。</li>
<li><em>async_send_to(buffer, endpoint, handler)</em>：这个函数启动了一个异步send缓冲区数据到指定端点的操作。</li>
<li><em>receive(buffer [, flags])</em>：这个函数异步地从所给的缓冲区读取数据。在读完所有数据或者错误出现之前，这个函数都是阻塞的。</li>
<li><em>read_some(buffer)</em>：这个函数的功能和*receive(buffer)*是一致的。</li>
<li>
<ul>
<li>receive_from(buffer, endpoint [, flags])*：这个函数异步地从一个指定的端点获取数据并写入到给定的缓冲区。在读完所有数据或者错误出现之前，这个函数都是阻塞的。</li>
</ul>
</li>
<li><em>send(buffer [, flags])</em>：这个函数同步地发送缓冲区的数据。在所有数据发送成功或者出现错误之前，这个函数都是阻塞的。</li>
<li><em>write_some(buffer)</em>：这个函数和*send(buffer)*的功能一致。</li>
<li><em>send_to(buffer, endpoint [, flags])</em>：这个函数同步地把缓冲区数据发送到一个指定的端点。在所有数据发送成功或者出现错误之前，这个函数都是阻塞的。</li>
<li><em>available()</em>：这个函数返回有多少字节的数据可以无阻塞地进行同步读取。</li>
</ul>
<p>稍后我们将讨论缓冲区。让我们先来了解一下标记。标记的默认值是0，但是也可以是以下几种：</p>
<ul>
<li><em>ip::socket_type::socket::message_peek</em>：这个标记只监测并返回某个消息，但是下一次读消息的调用会重新读取这个消息。</li>
<li><em>ip::socket_type::socket::message_out_of_band</em>：这个标记处理带外（OOB）数据，OOB数据是被标记为比正常数据更重要的数据。关于OOB的讨论在这本书的内容之外。</li>
<li><em>ip::socket_type::socket::message_do_not_route</em>：这个标记指定数据不使用路由表来发送。</li>
<li><em>ip::socket_type::socket::message_end_of_record</em>：这个标记指定的数据标识了记录的结束。在Windows下不支持。</li>
</ul>
<p>你最常用的可能是<em>message_peek</em>，使用方法请参照下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">sock.<span class="built_in">receive</span>(<span class="built_in">buffer</span>(buff), ip::tcp::socket::message_peek );</span><br><span class="line"><span class="built_in">memset</span>(buff,<span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 重新读取之前已经读取过的内容</span></span><br><span class="line">sock.<span class="built_in">receive</span>(<span class="built_in">buffer</span>(buff) );</span><br></pre></td></tr></table></figure>
<p>下面的是一些教你如何同步或异步地从不同类型的套接字上读取数据的例子：</p>
<ul>
<li>
<p>例1是在一个TCP套接字上进行同步读写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">80</span>)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">sock.<span class="built_in">write_some</span>(<span class="built_in">buffer</span>(<span class="string">&quot;GET /index.html\r\n&quot;</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;bytes available &quot;</span> &lt;&lt; sock.<span class="built_in">available</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line"><span class="type">size_t</span> read = sock.<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(buff));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>例2是在一个UDP套接字上进行同步读写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip::<span class="function">udp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">open</span>(ip::udp::<span class="built_in">v4</span>());</span><br><span class="line">ip::<span class="function">udp::endpoint <span class="title">receiver_ep</span><span class="params">(<span class="string">&quot;87.248.112.181&quot;</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">sock.<span class="built_in">send_to</span>(<span class="built_in">buffer</span>(<span class="string">&quot;testing\n&quot;</span>), receiver_ep);</span><br><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line">ip::udp::endpoint sender_ep;</span><br><span class="line">sock.<span class="built_in">receive_from</span>(<span class="built_in">buffer</span>(buff), sender_ep);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>[？注意：就像上述代码片段所展示的那样，使用receive_from从一个UDP套接字读取数据时，你需要构造一个默认的端点]</em></p>
<ul>
<li>
<p>例3是从一个UDP服务套接字中异步读取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">udp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">boost::asio::ip::udp::endpoint sender_ep;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; err, std::<span class="type">size_t</span> read_bytes)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;read &quot;</span> &lt;&lt; read_bytes &lt;&lt; std::endl;</span><br><span class="line">  sock.<span class="built_in">async_receive_from</span>(<span class="built_in">buffer</span>(buff), sender_ep, on_read);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  ip::<span class="function">udp::endpoint <span class="title">ep</span><span class="params">(ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">8001</span>)</span></span>;</span><br><span class="line">  sock.<span class="built_in">open</span>(ep.<span class="built_in">protocol</span>());</span><br><span class="line">  sock.<span class="built_in">set_option</span>(boost::asio::ip::udp::socket::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">  sock.<span class="built_in">bind</span>(ep);</span><br><span class="line">  sock.<span class="built_in">async_receive_from</span>(<span class="built_in">buffer</span>(buff,<span class="number">512</span>), sender_ep, on_read);</span><br><span class="line">  service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="套接字控制：">套接字控制：</h3>
</li>
</ul>
<p>这些函数用来处理套接字的高级选项：</p>
<ul>
<li><em>get_io_service()</em>：这个函数返回构造函数中传入的io_service实例</li>
<li><em>get_option(option)</em>：这个函数返回一个套接字的属性</li>
<li><em>set_option(option)</em>：这个函数设置一个套接字的属性</li>
<li><em>io_control(cmd)</em>：这个函数在套接字上执行一个I/O指令</li>
</ul>
<p>这些是你可以获取/设置的套接字选项：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>broadcast</td>
<td>如果为true，允许广播消息</td>
<td>bool</td>
</tr>
<tr>
<td>debug</td>
<td>如果为true，启用套接字级别的调试</td>
<td>bool</td>
</tr>
<tr>
<td>do_not_route</td>
<td>如果为true，则阻止路由选择只使用本地接口</td>
<td>bool</td>
</tr>
<tr>
<td>enable_connection_aborted</td>
<td>如果为true，记录在accept()时中断的连接</td>
<td>bool</td>
</tr>
<tr>
<td>keep_alive</td>
<td>如果为true，会发送心跳</td>
<td>bool</td>
</tr>
<tr>
<td>linger</td>
<td>如果为true，套接字会在有未发送数据的情况下挂起close()</td>
<td>bool</td>
</tr>
<tr>
<td>receive_buffer_size</td>
<td>套接字接收缓冲区大小</td>
<td>int</td>
</tr>
<tr>
<td>receive_low_watemark</td>
<td>规定套接字输入处理的最小字节数</td>
<td>int</td>
</tr>
<tr>
<td>reuse_address</td>
<td>如果为true，套接字能绑定到一个已用的地址</td>
<td>bool</td>
</tr>
<tr>
<td>send_buffer_size</td>
<td>套接字发送缓冲区大小</td>
<td>int</td>
</tr>
<tr>
<td>send_low_watermark</td>
<td>规定套接字数据发送的最小字节数</td>
<td>int</td>
</tr>
<tr>
<td>ip::v6_only</td>
<td>如果为true，则只允许IPv6的连接</td>
<td>bool</td>
</tr>
</tbody>
</table>
<p>每个名字代表了一个内部套接字typedef或者类。下面是对它们的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">80</span>)</span></span>;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">sock.<span class="built_in">connect</span>(ep);</span><br><span class="line"><span class="comment">// TCP套接字可以重用地址</span></span><br><span class="line">ip::tcp::<span class="function">socket::reuse_address <span class="title">ra</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">sock.<span class="built_in">set_option</span>(ra);</span><br><span class="line"><span class="comment">// 获取套接字读取的数据</span></span><br><span class="line">ip::tcp::socket::receive_buffer_size rbs;</span><br><span class="line">sock.<span class="built_in">get_option</span>(rbs);</span><br><span class="line">std::cout &lt;&lt; rbs.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 把套接字的缓冲区大小设置为8192</span></span><br><span class="line">ip::tcp::<span class="function">socket::send_buffer_size <span class="title">sbs</span><span class="params">(<span class="number">8192</span>)</span></span>;</span><br><span class="line">sock.<span class="built_in">set_option</span>(sbs);</span><br></pre></td></tr></table></figure>
<p><em>[?在上述特性工作之前，套接字要被打开。否则，会抛出异常]</em></p>
<h3 id="TCP-VS-UDP-VS-ICMP">TCP VS UDP VS ICMP</h3>
<p>就像我之前所说，不是所有的成员方法在所有的套接字类中都可用。我做了一个包含成员函数不同点的列表。如果一个成员函数没有出现在这，说明它在所有的套接字类都是可用的。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>TCP</th>
<th>UDP</th>
<th>ICMP</th>
</tr>
</thead>
<tbody>
<tr>
<td>async_read_some</td>
<td>是</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>async_receive_from</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>async_write_some</td>
<td>是</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>async_send_to</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>read_some</td>
<td>是</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>receive_from</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>write_some</td>
<td>是</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>send_to</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="其他方法">其他方法</h3>
<p>其他与连接和I/O无关的函数如下：</p>
<ul>
<li><em>local_endpoint()</em>：这个方法返回套接字本地连接的地址。</li>
<li><em>remote_endpoint()</em>：这个方法返回套接字连接到的远程地址。</li>
<li><em>native_handle()</em>：这个方法返回原始套接字的处理程序。你只有在调用一个Boost.Asio不支持的原始方法时才需要用到它。</li>
<li><em>non_blocking()</em>：如果套接字是非阻塞的，这个方法返回true，否则false。</li>
<li><em>native_non_blocking()</em>：如果套接字是非阻塞的，这个方法返回true，否则返回false。但是，它是基于原生的套接字来调用本地的api。所以通常来说，你不需要调用这个方法（non_blocking()已经缓存了这个结果）；你只有在直接调用native_handle()这个方法的时候才需要用到这个方法。</li>
<li><em>at_mark()</em>：如果套接字要读的是一段OOB数据，这个方法返回true。这个方法你很少会用到。</li>
</ul>
<h3 id="其他需要考虑的事情">其他需要考虑的事情</h3>
<p>最后要注意的一点，套接字实例不能被拷贝，因为拷贝构造方法和＝操作符是不可访问的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip::<span class="function">tcp::socket <span class="title">s1</span><span class="params">(service)</span>, <span class="title">s2</span><span class="params">(service)</span></span>;</span><br><span class="line">s1 = s2; <span class="comment">// 编译时报错</span></span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">s3</span><span class="params">(s1)</span></span>; <span class="comment">// 编译时报错</span></span><br></pre></td></tr></table></figure>
<p>这是非常有意义的，因为每一个实例都拥有并管理着一个资源（原生套接字本身）。如果我们允许拷贝构造，结果是我们会有两个实例拥有同样的原生套接字；这样我们就需要去处理所有者的问题（让一个实例拥有所有权？或者使用引用计数？还是其他的方法）Boost.Asio选择不允许拷贝（如果你想要创建一个备份，请使用共享指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;ip::tcp::socket&gt; socket_ptr;</span><br><span class="line"><span class="function">socket_ptr <span class="title">sock1</span><span class="params">(<span class="keyword">new</span> ip::tcp::socket(service))</span></span>;</span><br><span class="line"><span class="function">socket_ptr <span class="title">sock2</span><span class="params">(sock1)</span></span>; <span class="comment">// ok</span></span><br><span class="line">socket_ptr sock3;            </span><br><span class="line">sock3 = sock1; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="套接字缓冲区">套接字缓冲区</h3>
<p>当从一个套接字读写内容时，你需要一个缓冲区，用来保存读取和写入的数据。缓冲区内存的有效时间必须比I/O操作的时间要长；你需要保证它们在I/O操作结束之前不被释放。 对于同步操作来说，这很容易；当然，这个缓冲区在receive和send时都存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line">...</span><br><span class="line">sock.<span class="built_in">receive</span>(<span class="built_in">buffer</span>(buff));</span><br><span class="line"><span class="built_in">strcpy</span>(buff, <span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">sock.<span class="built_in">send</span>(<span class="built_in">buffer</span>(buff));</span><br></pre></td></tr></table></figure>
<p>但是在异步操作时就没这么简单了，看下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非常差劲的代码 ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; err, std::<span class="type">size_t</span> read_bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line">    sock.<span class="built_in">async_receive</span>(<span class="built_in">buffer</span>(buff), on_read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们调用*async_receive()*之后，buff就已经超出有效范围，它的内存当然会被释放。当我们开始从套接字接收一些数据时，我们会把它们拷贝到一片已经不属于我们的内存中；它可能会被释放，或者被其他代码重新开辟来存入其他的数据，结果就是：内存冲突。</p>
<p>对于上面的问题有几个解决方案：</p>
<ul>
<li>使用全局缓冲区</li>
<li>创建一个缓冲区，然后在操作结束时释放它</li>
<li>使用一个集合对象管理这些套接字和其他的数据，比如缓冲区数组</li>
</ul>
<p>第一个方法显然不是很好，因为我们都知道全局变量非常不好。此外，如果两个实例使用同一个缓冲区怎么办？</p>
<p>下面是第二种方式的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">char</span> * ptr, <span class="type">const</span> boost::system::error_code &amp; err, std::<span class="type">size_t</span> read_bytes)</span> </span>&#123;                        </span><br><span class="line">    <span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="type">char</span> * buff = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">512</span>];</span><br><span class="line">sock.<span class="built_in">async_receive</span>(<span class="built_in">buffer</span>(buff, <span class="number">512</span>), boost::<span class="built_in">bind</span>(on_read,buff,_1,_2))</span><br></pre></td></tr></table></figure>
<p>或者，如果你想要缓冲区在操作结束后自动超出范围，使用共享指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">shared_buffer</span> &#123;</span><br><span class="line">    boost::shared_array&lt;<span class="type">char</span>&gt; buff;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">shared_buffer</span>(<span class="type">size_t</span> size) : <span class="built_in">buff</span>(<span class="keyword">new</span> <span class="type">char</span>[size]), <span class="built_in">size</span>(size) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mutable_buffers_1 <span class="title">asio_buff</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buffer</span>(buff.<span class="built_in">get</span>(), size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当on_read超出范围时, boost::bind对象被释放了,</span></span><br><span class="line"><span class="comment">// 同时也会释放共享指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(shared_buffer, <span class="type">const</span> boost::system::error_code &amp; err, std::<span class="type">size_t</span> read_bytes)</span> </span>&#123;&#125;</span><br><span class="line">sock.<span class="built_in">async_receive</span>(buff.<span class="built_in">asio_buff</span>(), boost::<span class="built_in">bind</span>(on_read,buff,_1,_2));</span><br></pre></td></tr></table></figure>
<p>shared_buffer类拥有实质的<em>shared_array&lt;&gt;</em>，<em>shared_array&lt;&gt;<em>存在的目的是用来保存</em>shared_buffer</em>实例的拷贝－当最后一个*share_array&lt;&gt;*元素超出范围时，*shared_array&lt;&gt;*就被自动销毁了，而这就是我们想要的结果。</p>
<p>因为Boost.Asio会给完成处理句柄保留一个拷贝，当操作完成时就会调用这个完成处理句柄，所以你的目的达到了。那个拷贝是一个boost::bind的仿函数，它拥有着实际的<em>shared_buffer</em>实例。这是非常优雅的！</p>
<p>第三个选择是使用一个连接对象来管理套接字和其他数据，比如缓冲区，通常来说这是正确的解决方案但是非常复杂。在这一章的末尾我们会对这种方法进行讨论。</p>
<h3 id="缓冲区封装函数">缓冲区封装函数</h3>
<p>纵观所有代码，你会发现：无论什么时候，当我们需要对一个buffer进行读写操作时，代码会把实际的缓冲区对象封装在一个buffer()方法中，然后再把它传递给方法调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line">sock.<span class="built_in">async_receive</span>(<span class="built_in">buffer</span>(buff), on_read);</span><br></pre></td></tr></table></figure>
<p>基本上我们都会把缓冲区包含在一个类中以便Boost.Asio的方法能遍历这个缓冲区，比方说，使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.<span class="built_in">async_receive</span>(some_buffer, on_read);</span><br></pre></td></tr></table></figure>
<p>实例<em>some_buffer</em>需要满足一些需求，叫做<em>ConstBufferSequence</em>或者<em>MutableBufferSequence</em>（你可以在Boost.Asio的文档中查看它们）。创建你自己的类去处理这些需求的细节是非常复杂的，但是Boost.Asio已经提供了一些类用来处理这些需求。所以你不用直接访问这些缓冲区，而可以使用*buffer()*方法。</p>
<p>自信地讲，你可以把下面列出来的类型都包装到一个buffer()方法中：</p>
<ul>
<li>一个char[] const 数组</li>
<li>一个字节大小的void *指针</li>
<li>一个std::string类型的字符串</li>
<li>一个POD const数组（POD代表纯数据，这意味着构造器和释放器不做任何操作）</li>
<li>一个pod数据的std::vector</li>
<li>一个包含pod数据的boost::array</li>
<li>一个包含pod数据的std::array</li>
</ul>
<p>下面的代码都是有效的：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct pod_sample &#123; int i<span class="comment">; long l; char c; &#125;;</span></span><br><span class="line">...</span><br><span class="line">char <span class="keyword">b1[512];</span></span><br><span class="line"><span class="keyword"></span>void * <span class="keyword">b2 </span>= new char[<span class="number">512</span>];</span><br><span class="line"><span class="symbol">std:</span>:string <span class="keyword">b3; </span><span class="keyword">b3.resize(128);</span></span><br><span class="line"><span class="keyword"></span>pod_sample <span class="keyword">b4[16];</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">std:</span>:vector&lt;pod_sample&gt; <span class="keyword">b5; </span><span class="keyword">b5.resize(16);</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">boost::array&lt;pod_sample,16&gt; </span><span class="keyword">b6;</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">std:</span>:array&lt;pod_sample,<span class="number">16</span>&gt; <span class="keyword">b7;</span></span><br><span class="line"><span class="keyword"></span>sock.async_send(<span class="keyword">buffer(b1), </span>on_read);</span><br><span class="line">sock.async_send(<span class="keyword">buffer(b2,512), </span>on_read);</span><br><span class="line">sock.async_send(<span class="keyword">buffer(b3), </span>on_read);</span><br><span class="line">sock.async_send(<span class="keyword">buffer(b4), </span>on_read);</span><br><span class="line">sock.async_send(<span class="keyword">buffer(b5), </span>on_read);</span><br><span class="line">sock.async_send(<span class="keyword">buffer(b6), </span>on_read);</span><br><span class="line">sock.async_send(<span class="keyword">buffer(b7), </span>on_read);</span><br></pre></td></tr></table></figure>
<p>总的来说就是：与其创建你自己的类来处理<em>ConstBufferSequence</em>或者<em>MutableBufferSequence</em>的需求，不如创建一个能在你需要的时候保留缓冲区，然后返回一个mutable_buffers_1实例的类，而我们早在shared_buffer类中就这样做了。</p>
<h3 id="read-write-connect自由函数">read/write/connect自由函数</h3>
<p>Boost.Asio提供了处理I/O的自由函数，我们分四组来分析它们。</p>
<h4 id="connect方法">connect方法</h4>
<p>这些方法把套接字连接到一个端点。</p>
<ul>
<li><em>connect(socket, begin [, end] [, condition])</em>：这个方法遍历队列中从start到end的端点来尝试同步连接。begin迭代器是调用<em>socket_type::resolver::query</em>的返回结果（你可能需要回顾一下端点这个章节）。特别提示end迭代器是可选的；你可以忽略它。你还可以提供一个condition的方法给每次连接尝试之后调用。用法是<em>Iterator connect_condition(const boost::system::error_code &amp; err,Iterator next);</em>。你可以选择返回一个不是<em>next</em>的迭代器，这样你就可以跳过一些端点。</li>
<li><em>async_connect(socket, begin [, end] [, condition], handler)</em>：这个方法异步地调用连接方法，在结束时，它会调用完成处理方法。用法是<em>void handler(constboost::system::error_code &amp; err, Iterator iterator);</em>。传递给处理方法的第二个参数是连接成功端点的迭代器（或者end迭代器）。</li>
</ul>
<p>它的例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(service)</span></span>;</span><br><span class="line">tcp::resolver::iterator iter = resolver.<span class="built_in">resolve</span>(tcp::resolver::<span class="built_in">query</span>(<span class="string">&quot;www.yahoo.com&quot;</span>,<span class="string">&quot;80&quot;</span>));</span><br><span class="line"><span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line"><span class="built_in">connect</span>(sock, iter);</span><br></pre></td></tr></table></figure>
<p>一个主机名可以被解析成多个地址，而<em>connect</em>和<em>async_connect</em>能很好地把你从尝试每个地址然后找到一个可用地址的繁重工作中解放出来，因为它们已经帮你做了这些。</p>
<h4 id="read-write方法">read/write方法</h4>
<p>这些方法对一个流进行读写操作（可以是套接字，或者其他表现得像流的类）：</p>
<ul>
<li>
<p><em>async_read(stream, buffer [, completion] ,handler)</em>：这个方法异步地从一个流读取。结束时其处理方法被调用。处理方法的格式是：<em>void handler(const boost::system::error_ code &amp; err, size_t bytes)</em>;。你可以选择指定一个完成处理方法。完成处理方法会在每个<em>read</em>操作调用成功之后调用，然后告诉Boost.Asio <em>async_read</em>操作是否完成（如果没有完成，它会继续读取）。它的格式是：<em>size_t completion(const boost::system::error_code&amp; err, size_t bytes_transfered)</em> 。当这个完成处理方法返回0时，我们认<em>为read</em>操作完成；如果它返回一个非0值，它表示了下一个<em>async_read_some</em>操作需要从流中读取的字节数。接下来会有一个例子来详细展示这些。</p>
</li>
<li>
<p><em>async_write(stream, buffer [, completion], handler)</em>：这个方法异步地向一个流写入数据。参数的意义和<em>async_read</em>是一样的。</p>
</li>
<li>
<p><em>read(stream, buffer [, completion])</em>：这个方法同步地从一个流中读取数据。参数的意义和<em>async_read</em>是一样的。</p>
</li>
<li>
<p>write(stream, buffer [, completion])</p>
<p>: 这个方法同步地向一个流写入数据。参数的意义和</p>
<p>async_read</p>
<p>是一样的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">async_read</span><span class="params">(stream, stream_buffer [, completion], handler)</span></span></span><br><span class="line"><span class="function"><span class="title">async_write</span><span class="params">(strean, stream_buffer [, completion], handler)</span></span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(stream, stream_buffer [, completion])</span></span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">(stream, stream_buffer [, completion])</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先，要注意第一个参数变成了流，而不单是socket。这个参数包含了socket但不仅仅是socket。比如，你可以用一个Windows的文件句柄来替代socket。 当下面情况出现时，所有read和write操作都会结束：</p>
<ul>
<li>可用的缓冲区满了（当读取时）或者所有的缓冲区已经被写入（当写入时）</li>
<li>完成处理方法返回0（如果你提供了这么一个方法）</li>
<li>错误发生时</li>
</ul>
<p>下面的代码会异步地从一个socket中间读取数据直到读取到’\n’：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">up_to_enter</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bytes; ++i)</span><br><span class="line">        <span class="keyword">if</span> ( buff[i + offset] == <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;, <span class="type">size_t</span>)</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">async_read</span>(sock, <span class="built_in">buffer</span>(buff), up_to_enter, on_read);</span><br></pre></td></tr></table></figure>
<p>Boost.Asio也提供了一些简单的完成处理仿函数：</p>
<ul>
<li>transfer_at_least(n)</li>
<li>transfer_exactly(n)</li>
<li>transfer_all()</li>
</ul>
<p>例子如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buff<span class="selector-attr">[512]</span>; </span><br><span class="line">void <span class="built_in">on_read</span>(const boost::system::error_code &amp;, size_t) &#123;&#125; </span><br><span class="line"><span class="comment">// 读取32个字节 </span></span><br><span class="line"><span class="built_in">async_read</span>(sock, buffer(buff), <span class="built_in">transfer_exactly</span>(<span class="number">32</span>), on_read);</span><br></pre></td></tr></table></figure>
<p>上述的4个方法，不使用普通的缓冲区，而使用由Boost.Asio的<em>std::streambuf</em>类继承来的<em>stream_buffer</em>方法。stl流和流缓冲区非常复杂；下面是例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io_service service;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(streambuf&amp; buf, <span class="type">const</span> boost::system::error_code &amp;, <span class="type">size_t</span>)</span> </span>&#123; </span><br><span class="line">    <span class="function">std::istream <span class="title">in</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first line: &quot;</span> &lt;&lt; line &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123; </span><br><span class="line">    HANDLE file = ::<span class="built_in">CreateFile</span>(<span class="string">&quot;readme.txt&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="number">0</span>);</span><br><span class="line">    <span class="function">windows::stream_handle <span class="title">h</span><span class="params">(service, file)</span></span>;</span><br><span class="line">    streambuf buf;</span><br><span class="line">    <span class="built_in">async_read</span>(h, buf, <span class="built_in">transfer_exactly</span>(<span class="number">256</span>), boost::<span class="built_in">bind</span>(on_read,boost::<span class="built_in">ref</span>(buf),_1,_2));</span><br><span class="line">    service.<span class="built_in">run</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我向你们展示了如何在一个Windows文件句柄上调用<em>async_read</em>。读取前256个字符，然后把它们保存到缓冲区中，当操作结束时。<em>on_read</em>被调用，再创建<em>std::istream</em>用来传递缓冲区，读取第一行（<em>std::getline</em>），最后把它输出到命令行中。</p>
<h4 id="read-until-async-read-until方法">read_until/async_read_until方法</h4>
<p>这些方法在条件满足之前会一直读取：</p>
<ul>
<li><em>async_read_until(stream, stream_buffer, delim, handler)</em>:这个方法启动一个异步<em>read</em>操作。<em>read</em>操作会在读取到某个分隔符时结束。分隔符可以是字符,<em>std::string</em>或者<em>boost::regex</em>。处理方法的格式为：<em>void handler(const boost::system::error_code &amp; err, size_t bytes);</em>。</li>
<li><em>async_read_until(strem, stream_buffer, completion, handler)</em>：这个方法和之前的方法是一样的，但是没有分隔符，而是一个完成处理方法。完成处理方法的格式为：<em>pair&lt; iterator,bool &gt; completion(iterator begin, iterator end);</em>，其中迭代器的类型为<em>buffers_iterator&lt; streambuf::const_buffers_type &gt;</em>。你需要记住的是这个迭代器是支持随机访问的。你扫描整个区间（begin，end），然后决定read操作是否应该结束。返回的结果是一个结果对，第一个成员是一个迭代器，它指向最后被这个方法访问的字符；第二个成员指定read操作是否需要结束，需要时返回true，否则返回false。</li>
<li><em>read_until(stream, stream_buffer, delim)</em>：这个方法执行一个同步的<em>read</em>操作，参数的意义和<em>async_read_until</em>一样。</li>
<li><em>read_until(stream, stream_buffer, completion)</em>：这个方法执行一个同步的read操作，参数的意义和<em>async_read_until</em>一样。</li>
</ul>
<p>下面这个例子在读到一个指定的标点符号之前会一直读取：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> buffers_iterator&lt;streambuf::const_buffers_type&gt; iterator;</span><br><span class="line"><span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">match_punct</span><span class="params">(iterator begin, iterator end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( begin != end)</span><br><span class="line">        <span class="keyword">if</span> ( std::<span class="built_in">ispunct</span>(*begin))</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(begin,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(end,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;, <span class="type">size_t</span>)</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line">streambuf buf;</span><br><span class="line"><span class="built_in">async_read_until</span>(sock, buf, match_punct, on_read);</span><br></pre></td></tr></table></figure>
<p>如果我们想读到一个空格时就结束，我们需要把最后一行修改为：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">async_read_until</span>(sock, buff, &#x27; &#x27;, on_read);</span><br></pre></td></tr></table></figure>
<h4 id="at方法">*_at方法</h4>
<p>这些方法用来在一个流上面做随机存取操作。由你来指定<em>read</em>和<em>write</em>操作从什么地方开始（<em>offset</em>）：</p>
<ul>
<li><em>async_read_at(stream, offset, buffer [, completion], handler)</em>：这个方法在指定的流的offset处开始执行一个异步的read操作，当操作结束时，它会调用handler。handler的格式为：<em>void handler(const boost::system::error_code&amp; err, size_t bytes);</em>。<em>buffer</em>可以是普通的<em>wrapper()<em>封装或者</em>streambuf</em>方法。如果你指定一个completion方法，它会在每次read操作成功之后调用，然后告诉Boost.Asio <em>async_read_at</em>操作已经完成（如果没有，则继续读取）。它的格式为：<em>size_t completion(const boost::system::error_code&amp; err, size_t bytes);</em>。当completion方法返回0时，我们认为<em>read</em>操作完成了；如果返回一个非零值，它代表了下一次调用流的<em>async_read_some_at</em>方法的最大读取字节数。</li>
<li><em>async_write_at(stream, offset, buffer [, completion], handler)</em>：这个方法执行一个异步的write操作。参数的意义和<em>async_read_at</em>是一样的</li>
<li><em>read_at(stream, offset, buffer [, completion])</em>：这个方法在一个执行的流上，指定的<em>offset</em>处开始read。参数的意义和<em>async_read_at</em>是一样的</li>
<li><em>write_at(stream, offset, buffer [, completion])</em>：这个方法在一个执行的流上，指定的<em>offset</em>处开始write。参数的意义和<em>async_read_at</em>是一样的</li>
</ul>
<p>这些方法不支持套接字。它们用来处理流的随机访问；也就是说，流是可以随机访问的。套接字显然不是这样（套接字是不可回溯的）。</p>
<p>下面这个例子告诉你怎么从一个文件偏移为256的位置读取128个字节：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    HANDLE file = ::<span class="built_in">CreateFile</span>(<span class="string">&quot;readme.txt&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="number">0</span>);</span><br><span class="line">    <span class="function">windows::random_access_handle <span class="title">h</span><span class="params">(service, file)</span></span>;</span><br><span class="line">    streambuf buf;</span><br><span class="line">    <span class="built_in">read_at</span>(h, <span class="number">256</span>, buf, <span class="built_in">transfer_exactly</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="function">std::istream <span class="title">in</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first line: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步编程">异步编程</h3>
<p>这部分对异步编程时可能碰到的一些问题进行了深入的探究。我建议你先读一遍，然后在接下来读这本书的过程中，再经常回过头来看看，从而增强你对这部分的理解。</p>
<h4 id="异步的需求">异步的需求</h4>
<p>就像我之前所说的，同步编程比异步编程简单很多。这是因为，线性的思考是很简单的（调用A，调用A结束，调用B，调用B结束，然后继续，这是以事件处理的方式来思考）。后面你会碰到这种情况，比如：五件事情，你不知道它们执行的顺序，也不知道他们是否会执行！</p>
<p>尽管异步编程更难，但是你会更倾向于选择使用它，比如：写一个需要处理很多并发访问的服务端。并发访问越多，异步编程就比同步编程越简单。</p>
<p>假设：你有一个需要处理1000个并发访问的应用，从客户端发给服务端的每个信息都会再返回给客户端，以‘\n’结尾。</p>
<p>同步方式的代码，1个线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    ip::tcp::socket sock;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>]; <span class="comment">// 每个信息最多这么大</span></span><br><span class="line">    <span class="type">int</span> already_read; <span class="comment">// 你已经读了多少</span></span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;client&gt; clients;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_clients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; clients.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">if</span> ( clients[i].sock.<span class="built_in">available</span>() ) <span class="built_in">on_read</span>(clients[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(client &amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> to_read = std::<span class="built_in">min</span>( <span class="number">1024</span> - c.already_read, c.sock.<span class="built_in">available</span>());</span><br><span class="line">    c.sock.<span class="built_in">read_some</span>( <span class="built_in">buffer</span>(c.buff + c.already_read, to_read));</span><br><span class="line">    c.already_read += to_read;</span><br><span class="line">    <span class="keyword">if</span> ( std::<span class="built_in">find</span>(c.buff, c.buff + c.already_read, <span class="string">&#x27;\n&#x27;</span>) &lt; c.buff + c.already_read) &#123;</span><br><span class="line">        <span class="type">int</span> pos = std::<span class="built_in">find</span>(c.buff, c.buff + c.already_read, <span class="string">&#x27;\n&#x27;</span>) - c.buff;</span><br><span class="line">        <span class="function">std::string <span class="title">msg</span><span class="params">(c.buff, c.buff + pos)</span></span>;</span><br><span class="line">        std::<span class="built_in">copy</span>(c.buff + pos, c.buff + <span class="number">1024</span>, c.buff);</span><br><span class="line">        c.already_read -= pos;</span><br><span class="line">        <span class="built_in">on_read_msg</span>(c, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read_msg</span><span class="params">(client &amp; c, <span class="type">const</span> std::string &amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分析消息，然后返回</span></span><br><span class="line">    <span class="keyword">if</span> ( msg == <span class="string">&quot;request_login&quot;</span>)</span><br><span class="line">        c.sock.<span class="built_in">write</span>( <span class="string">&quot;request_ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一种情况是在任何服务端（和任何基于网络的应用）都需要避免的，就是代码无响应的情况。在我们的例子里，我们需要*handle_clients()*方法尽可能少的阻塞。如果方法在某个点上阻塞，任何进来的信息都需要等待方法解除阻塞才能被处理。</p>
<p>为了保持响应，只在一个套接字有数据的时候我们才读，也就是说，<em>if ( clients[i].sock.available() ) on_read(clients[i])</em>。在<em>on_read</em>时，我们只读当前可用的；调用*read_until(c.sock, buffer(…), ‘\n’)*会是一个非常糟糕的选择，因为直到我们从一个指定的客户端读取了完整的消息之前，它都是阻塞的（我们永远不知道它什么时候会读取到完整的消息）</p>
<p>这里的瓶颈就是*on_read_msg()<em>方法；当它执行时，所有进来的消息都在等待。一个良好的</em>on_read_msg()*方法实现会保证这种情况基本不会发生，但是它还是会发生（有时候向一个套接字写入数据，缓冲区满了时，它会被阻塞） 同步方式的代码，10个线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client</span> &#123;</span><br><span class="line">　  <span class="comment">// ... 和之前一样</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">set_reading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boost::<span class="function">mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> ( is_reading_) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经在读取</span></span><br><span class="line">        <span class="keyword">else</span> &#123; is_reading_ = <span class="literal">true</span>; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unset_reading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boost::<span class="function">mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">        is_reading_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::mutex cs_;</span><br><span class="line">    <span class="type">bool</span> is_reading_;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;client&gt; clients;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_clients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        boost::<span class="built_in">thread</span>( handle_clients_thread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_clients_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; clients.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">if</span> ( clients[i].sock.<span class="built_in">available</span>() )</span><br><span class="line">                <span class="keyword">if</span> ( clients[i].<span class="built_in">set_reading</span>()) &#123;</span><br><span class="line">                    <span class="built_in">on_read</span>(clients[i]);</span><br><span class="line">                    clients[i].<span class="built_in">unset_reading</span>();</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(client &amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和之前一样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read_msg</span><span class="params">(client &amp; c, <span class="type">const</span> std::string &amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和之前一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用多线程，我们需要对线程进行同步，这就是*set_reading()<em>和</em>set_unreading()*所做的。<em>set_reading()<em>方法非常重要，比如你想要一步实现“判断是否在读取然后标记为读取中”。但这是有两步的（“判断是否在读取”和“标记为读取中”），你可能会有两个线程同时为一个客户端判断是否在读取，然后你会有两个线程同时为一个客户端调用</em>on_read</em>，结果就是数据冲突甚至导致应用崩溃。</p>
<p>你会发现代码变得极其复杂。</p>
<p>同步编程有第三个选择，就是为每个连接开辟一个线程。但是当并发的线程增加时，这就成了一种灾难性的情况。</p>
<p>然后，让我们来看异步编程。我们不断地异步读取。当一个客户端请求某些东西时，<em>on_read</em>被调用，然后回应，然后等待下一个请求（然后开始另外一个异步的read操作）。</p>
<p>异步方式的代码，10个线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    ip::tcp::socket sock;</span><br><span class="line">    streambuf buff; <span class="comment">// 从客户端取回结果</span></span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;client&gt; clients;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_clients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; clients.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">async_read_until</span>(clients[i].sock, clients[i].buff, <span class="string">&#x27;\n&#x27;</span>, boost::<span class="built_in">bind</span>(on_read, clients[i], _1, _2));</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        boost::<span class="built_in">thread</span>(handle_clients_thread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_clients_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(client &amp; c, <span class="type">const</span> error_code &amp; err, <span class="type">size_t</span> read_bytes)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::istream <span class="title">in</span><span class="params">(&amp;c.buff)</span></span>;</span><br><span class="line">    std::string msg;</span><br><span class="line">    std::<span class="built_in">getline</span>(in, msg);</span><br><span class="line">    <span class="keyword">if</span> ( msg == <span class="string">&quot;request_login&quot;</span>)</span><br><span class="line">        c.sock.<span class="built_in">async_write</span>( <span class="string">&quot;request_ok\n&quot;</span>, on_write);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 等待同一个客户端下一个读取操作</span></span><br><span class="line">    <span class="built_in">async_read_until</span>(c.sock, c.buff, <span class="string">&#x27;\n&#x27;</span>, boost::<span class="built_in">bind</span>(on_read, c, _1, _2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现代码变得有多简单了吧？client结构里面只有两个成员，<em>handle_clients()<em>仅仅调用了</em>async_read_until</em>，然后它创建了10个线程，每个线程都调用<em>service.run()</em>。这些线程会处理所有来自客户端的异步read操作，然后分发所有向客户端的异步write操作。另外需要注意的一件事情是：*on_read()*一直在为下一次异步read操作做准备（看最后一行代码）。</p>
<h4 id="异步run-runone-poll-poll-one">异步run(), run<em>one(), poll(), poll</em> one()</h4>
<p>为了实现监听循环，<em>io_service</em>类提供了4个方法，比如：<em>run(), run_one(), poll()<em>和</em>poll_one()</em>。虽然大多数时候使用*service.run()*就可以，但是你还是需要在这里学习其他方法实现的功能。</p>
<h5 id="持续运行">持续运行</h5>
<p>再一次说明，如果有等待执行的操作，<em>run()<em>会一直执行，直到你手动调用</em>io_service::stop()</em>。为了保证<em>io_service</em>一直执行，通常你添加一个或者多个异步操作，然后在它们被执行时，你继续一直不停地添加异步操作，比如下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line"><span class="type">char</span> buff_read[<span class="number">1024</span>], buff_write[<span class="number">1024</span>] = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;err, std::<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_write</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;err, std::<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(<span class="built_in">buffer</span>(buff_read), on_read);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;err, std::<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 处理读取操作 ...</span></span><br><span class="line">    sock.<span class="built_in">async_write_some</span>(<span class="built_in">buffer</span>(buff_write,<span class="number">3</span>), on_write);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_connect</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;err)</span> </span>&#123;</span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(<span class="built_in">buffer</span>(buff_read), on_read);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">2001</span>)</span></span>;</span><br><span class="line">    sock.<span class="built_in">async_connect</span>(ep, on_connect);</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当*service.run()*被调用时，有一个异步操作在等待。</li>
<li>当socket连接到服务端时，<em>on_connect</em>被调用了，它会添加一个异步操作。</li>
<li>当<em>on_connect</em>结束时，我们会留下一个等待的操作（<em>read</em>）。</li>
<li>当<em>on_read</em>被调用时，我们写入一个回应，这又添加了另外一个等待的操作。</li>
<li>当<em>on_read</em>结束时，我们会留下一个等待的操作*（write*）。</li>
<li>当<em>on_write</em>操作被调用时，我们从服务端读取另外一个消息，这也添加了另外一个等待的操作。</li>
<li>当<em>on_write</em>结束时，我们有一个等待的操作（read）。</li>
<li>然后一直继续循环下去，直到我们关闭这个应用。</li>
</ol>
<h5 id="run-one-poll-poll-one-方法">run_one(), poll(), poll_one() 方法</h5>
<p>我在之前说过异步方法的handler是在调用了<em>io_service::run</em>的线程里被调用的。因为在至少90%～95%的时候，这是你唯一要用到的方法，所以我就把它说得简单了。对于调用了*run_one(), poll()<em>或者</em>poll_one()*的线程这一点也是适用的。</p>
<p>*run_one()*方法最多执行和分发一个异步操作：</p>
<ul>
<li>如果没有等待的操作，方法立即返回0</li>
<li>如果有等待操作，方法在第一个操作执行之前处于阻塞状态，然后返回1</li>
</ul>
<p>你可以认为下面两段代码是等效的：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">service<span class="selector-class">.run</span>(); <span class="comment">// 或者</span></span><br><span class="line">while ( !service.stopped()) service<span class="selector-class">.run_once</span>();</span><br></pre></td></tr></table></figure>
<p>你可以使用*run_once()*启动一个异步操作，然后等待它执行完成。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">bool write_complete = <span class="literal">false</span>;</span><br><span class="line"><span class="literal">void</span> on_write(const boost<span class="type">::system</span><span class="type">::error_code</span> &amp; err, size_t <span class="built_in">bytes</span>)</span><br><span class="line">&#123; write_complete = <span class="literal">true</span>; &#125;</span><br><span class="line"> …</span><br><span class="line">std<span class="type">::string</span> <span class="built_in">data</span> = <span class="string">&quot;login ok”;</span></span><br><span class="line"><span class="string">write_complete = false;</span></span><br><span class="line"><span class="string">async_write(sock, buffer(data), on_write);</span></span><br><span class="line"><span class="string">do service.run_once() while (!write_complete);</span></span><br></pre></td></tr></table></figure>
<p>还有一些使用<em>run_one()<em>方法的例子，包含在Boost.Asio诸如</em>blocking_tcp_client.cpp</em>和<em>blocking_udp_client.cpp</em>的文件中。</p>
<p><em>poll_one</em>方法以非阻塞的方式最多运行一个准备好的等待操作：</p>
<ul>
<li>如果至少有一个等待的操作，而且准备好以非阻塞的方式运行，poll_one方法会运行它并且返回1</li>
<li>否则，方法立即返回0</li>
</ul>
<p>操作正在等待并准备以非阻塞方式运行，通常意味着如下的情况：</p>
<ul>
<li>一个计时器过期了，然后它的<em>async_wait</em>处理方法需要被调用</li>
<li>一个I/O操作完成了（比如<em>async_read</em>），然后它的hanlder需要被调用</li>
<li>之前被加入<em>io_services</em>实例队列中的自定义handler（这会在之后的章节中详解）</li>
</ul>
<p>你可以使用<em>poll_one</em>去保证所有I/O操作的handler完成运行，同时做一些其他的工作</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line"><span class="keyword">while</span> <span class="comment">( true)</span> &#123;</span><br><span class="line">    <span class="comment">// 运行所有完成了IO操作的handler</span></span><br><span class="line">    <span class="keyword">while</span> <span class="comment">( service.poll_one()</span>) ;</span><br><span class="line">    <span class="comment">// ... 在这里做其他的事情 …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*poll()*方法会以非阻塞的方式运行所有等待的操作。下面两段代码是等效的：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">service.poll<span class="comment">()</span>; <span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">while</span> <span class="comment">( service.poll_one()</span>) ;</span><br></pre></td></tr></table></figure>
<p>所有上述方法都会在失败的时候抛出<em>boost::system::system_error</em>异常。这是我们所不希望发生的事情；这里抛出的异常通常都是致命的，也许是资源耗尽，或者是你handler的其中一个抛出了异常。另外，每个方法都有一个不抛出异常，而是返回一个<em>boost::system::error_code</em>的重载：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io_service service<span class="comment">;</span></span><br><span class="line">boost::<span class="keyword">system</span>::error_code <span class="keyword">err</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">service.run(<span class="keyword">err</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">err</span>) std::cout &lt;&lt; <span class="string">&quot;Error &quot;</span> &lt;&lt; <span class="keyword">err</span> &lt;&lt; std::endl<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="异步工作">异步工作</h4>
<p>异步工作不仅仅指用异步地方式接受客户端到服务端的连接、异步地从一个socket读取或者写入到socket。它包含了所有可以异步执行的操作。</p>
<p>默认情况下，你是不知道每个异步handler的调用顺序的。除了通常的异步调用（来自异步socket的读取/写入/接收）。你可以使用*service.post()*来使你的自定义方法被异步地调用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func called, i= &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        service.<span class="built_in">post</span>(boost::<span class="built_in">bind</span>(func, i));</span><br><span class="line">    boost::thread_group threads;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        threads.<span class="built_in">create_thread</span>(worker_thread);</span><br><span class="line">    <span class="comment">// 等待所有线程被创建完</span></span><br><span class="line">    boost::this_thread::<span class="built_in">sleep</span>( boost::posix_time::<span class="built_in">millisec</span>(<span class="number">500</span>));</span><br><span class="line">    threads.<span class="built_in">join_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，*service.post(some_function)*添加了一个异步方法调用。</p>
<p>这个方法在某一个调用了<em>service.run()<em>的线程中请求</em>io_service</em>实例，然后调用给定的<em>some_funtion</em>之后立即返回。在我们的例子中，这个线程是我们之前创建的三个线程中的一个。你不能确定异步方法调用的顺序。你不要期待它们会以我们调用*post()*方法的顺序来调用。下面是运行之前代码可能得到的结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">func</span> called, i= <span class="number">0</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">2</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">1</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">4</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">3</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">6</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">7</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">8</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">5</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>有时候你会想让一些异步处理方法顺序执行。比如，你去一个餐馆（<em>go_to_restaurant</em>），下单（<em>order</em>），然后吃（<em>eat</em>）。你需要先去餐馆，然后下单，最后吃。这样的话，你需要用到<em>io_service::strand</em>，这个方法会让你的异步方法被顺序调用。看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func called, i= &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">io_service::strand <span class="title">strand_one</span><span class="params">(service)</span>, <span class="title">strand_two</span><span class="params">(service)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        service.<span class="built_in">post</span>( strand_one.<span class="built_in">wrap</span>( boost::<span class="built_in">bind</span>(func, i)));</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        service.<span class="built_in">post</span>( strand_two.<span class="built_in">wrap</span>( boost::<span class="built_in">bind</span>(func, i)));</span><br><span class="line">    boost::thread_group threads;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        threads.<span class="built_in">create_thread</span>(worker_thread);</span><br><span class="line">    <span class="comment">// 等待所有线程被创建完</span></span><br><span class="line">    boost::this_thread::<span class="built_in">sleep</span>( boost::posix_time::<span class="built_in">millisec</span>(<span class="number">500</span>));</span><br><span class="line">    threads.<span class="built_in">join_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们保证前面的5个线程和后面的5个线程是顺序执行的。<em>func called, i = 0</em>在<em>func called, i = 1</em>之前被调用，然后调用<em>func called, i = 2</em>……同样<em>func called, i = 5</em>在<em>func called, i = 6</em>之前，<em>func called, i = 6</em>在<em>func called, i = 7</em>被调用……你需要注意的是尽管方法是顺序调用的，但是不意味着它们都在同一个线程执行。运行这个程序可能得到的一个结果如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">func</span> called, i= <span class="number">0</span>/<span class="number">002</span>A60C8</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">5</span>/<span class="number">002</span>A6138</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">6</span>/<span class="number">002</span>A6530</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">1</span>/<span class="number">002</span>A6138</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">7</span>/<span class="number">002</span>A6530</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">2</span>/<span class="number">002</span>A6138</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">8</span>/<span class="number">002</span>A6530</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">3</span>/<span class="number">002</span>A6138</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">9</span>/<span class="number">002</span>A6530</span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">4</span>/<span class="number">002</span>A6138</span><br></pre></td></tr></table></figure>
<h4 id="异步post-VS-dispatch-VS-wrap">异步post() VS dispatch() VS wrap()</h4>
<p>Boost.Asio提供了三种让你把处理方法添加为异步调用的方式：</p>
<ul>
<li><em>service.post(handler)</em>：这个方法能确保其在请求<em>io_service</em>实例，然后调用指定的处理方法之后立即返回。handler稍后会在某个调用了*service.run()*的线程中被调用。</li>
<li><em>service.dispatch(handler)</em>：这个方法请求<em>io_service</em>实例去调用给定的处理方法，但是另外一点，如果当前的线程调用了<em>service.run()</em>，它可以在方法中直接调用handler。</li>
<li><em>service.wrap(handler)</em>：这个方法创建了一个封装方法，当被调用时它会调用<em>service.dispatch(handler)</em>，这个会让人有点困惑，接下来我会简单地解释它是什么意思。</li>
</ul>
<p>在之前的章节中你会看到关于*service.post()<em>的一个例子，以及运行这个例子可能得到的一种结果。我们对它做一些修改，然后看看</em>service.dispatch()*是怎么影响输出的结果的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func called, i= &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_dispatch_and_post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    service.<span class="built_in">dispatch</span>(boost::<span class="built_in">bind</span>(func, i));</span><br><span class="line">    service.<span class="built_in">post</span>(boost::<span class="built_in">bind</span>(func, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    service.<span class="built_in">post</span>(run_dispatch_and_post);</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解释发生了什么之前，我们先运行程序，观察结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">func</span> called, i= <span class="number">0</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">2</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">4</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">6</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">8</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">1</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">3</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">5</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">7</span></span><br><span class="line"><span class="attribute">func</span> called, i= <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>偶数先输出，然后是奇数。这是因为我用<em>dispatch()<em>输出偶数，然后用</em>post()<em>输出奇数。<em>dispatch()<em>会在返回之前调用hanlder，因为当前的线程调用了</em>service.run()</em>，而</em>post()<em>每次都立即返回了。 现在，让我们讲讲</em>service.wrap(handler)</em>。*wrap()*返回了一个仿函数，它可以用来做另外一个方法的参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatched_func_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dispatched 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatched_func_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dispatched 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(boost::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    service.<span class="built_in">dispatch</span>(dispatched_func_1);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">service_run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    service.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>( service.<span class="built_in">wrap</span>(dispatched_func_2));</span><br><span class="line">    <span class="function">boost::thread <span class="title">th</span><span class="params">(service_run)</span></span>;</span><br><span class="line">    boost::this_thread::<span class="built_in">sleep</span>( boost::posix_time::<span class="built_in">millisec</span>(<span class="number">500</span>));</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>test(service.wrap(dispatched_func_2));<em>会把</em>dispatched_ func_2</em>包装起来创建一个仿函数，然后传递给<em>test</em>当作一个参数。当<em>test()<em>被调用时，它会分发调用方法1，然后调用</em>func()</em>。这时，你会发现调用*func()<em>和</em>service.dispatch(dispatched_func_2)*是等价的，因为它们是连续调用的。程序的输出证明了这一点：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test</span></span><br><span class="line"><span class="keyword"></span>dispatched 1</span><br><span class="line">dispatched 2</span><br></pre></td></tr></table></figure>
<p><em>io_service::strand</em> 类（用来序列化异步调用）也包含了*poll(), dispatch()<em>和 <em>wrap()<em>等成员函数。它们的作用和</em>io_service</em>的</em>poll(), dispatch()<em>和</em>wrap()<em>是一样的。然而，大多数情况下你只需要把</em>io_service::strand::wrap()<em>方法做为</em>io_service::poll()<em>或者</em>io_service::dispatch()*方法的参数即可。</p>
<h3 id="保持活动">保持活动</h3>
<p>假设你需要做下面的操作：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">ip::tcp::socket <span class="built_in">sock</span>(service);</span><br><span class="line">char buff<span class="selector-attr">[512]</span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">read</span>(sock, buffer(buff));</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<em>sock</em>和<em>buff</em>的存在时间都必须比*read()<em>调用的时间要长。也就是说，在调用</em>read()*返回之前，它们都必须有效。这就是你所期望的；你传给一个方法的所有参数在方法内部都必须有效。当我们采用异步方式时，事情会变得比较复杂。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">512</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;, <span class="type">size_t</span>)</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">async_read</span>(sock, <span class="built_in">buffer</span>(buff), on_read);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<em>sock</em>和<em>buff</em>的存在时间都必须比*read()*操作本身时间要长，但是read操作持续的时间我们是不知道的，因为它是异步的。</p>
<p>当使用socket缓冲区的时候，你会有一个<em>buffer</em>实例在异步调用时一直存在（使用<em>boost::shared_array&lt;&gt;</em>）。在这里，我们可以使用同样的方式，通过创建一个类并在其内部管理socket和它的读写缓冲区。然后，对于所有的异步操作，传递一个包含智能指针的<em>boost::bind</em>仿函数给它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line">io_service service;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span> : boost::enable_shared_from_this&lt;connection&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::system::error_code error_code;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;connection&gt; ptr;</span><br><span class="line">    <span class="built_in">connection</span>() : <span class="built_in">sock_</span>(service), <span class="built_in">started_</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(ip::tcp::endpoint ep)</span> </span>&#123;</span><br><span class="line">        sock_.<span class="built_in">async_connect</span>(ep, boost::<span class="built_in">bind</span>(&amp;connection::on_connect, <span class="built_in">shared_from_this</span>(), _1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !started_) <span class="keyword">return</span>;</span><br><span class="line">        started_ = <span class="literal">false</span>;</span><br><span class="line">        sock_.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_connect</span><span class="params">(<span class="type">const</span> error_code &amp; err)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里你决定用这个连接做什么: 读取或者写入</span></span><br><span class="line">        <span class="keyword">if</span> ( !err) <span class="built_in">do_read</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(<span class="type">const</span> error_code &amp; err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">started</span>() ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="function">std::string <span class="title">msg</span><span class="params">(read_buffer_, bytes)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> ( msg == <span class="string">&quot;can_login&quot;</span>) <span class="built_in">do_write</span>(<span class="string">&quot;access_data&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="built_in">find</span>(<span class="string">&quot;data &quot;</span>) == <span class="number">0</span>) <span class="built_in">process_data</span>(msg);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( msg == <span class="string">&quot;login_fail&quot;</span>) <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_write</span><span class="params">(<span class="type">const</span> error_code &amp; err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">do_read</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sock_.<span class="built_in">async_read_some</span>(<span class="built_in">buffer</span>(read_buffer_), boost::<span class="built_in">bind</span>(&amp;connection::on_read, <span class="built_in">shared_from_this</span>(),   _1, _2)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_write</span><span class="params">(<span class="type">const</span> std::string &amp; msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">started</span>() ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 注意: 因为在做另外一个async_read操作之前你想要发送多个消息, </span></span><br><span class="line">        <span class="comment">// 所以你需要多个写入buffer</span></span><br><span class="line">        std::<span class="built_in">copy</span>(msg.<span class="built_in">begin</span>(), msg.<span class="built_in">end</span>(), write_buffer_);</span><br><span class="line">        sock_.<span class="built_in">async_write_some</span>(<span class="built_in">buffer</span>(write_buffer_, msg.<span class="built_in">size</span>()), boost::<span class="built_in">bind</span>(&amp;connection::on_write, <span class="built_in">shared_from_this</span>(), _1, _2)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">(<span class="type">const</span> std::string &amp; msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理服务端来的内容，然后启动另外一个写入操作</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> read_buffer_[max_msg];</span><br><span class="line">    <span class="type">char</span> write_buffer_[max_msg];</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8001</span>)</span></span>;</span><br><span class="line">    connection::<span class="built_in">ptr</span>(<span class="keyword">new</span> connection)-&gt;<span class="built_in">start</span>(ep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有异步调用中，我们传递一个<em>boost::bind</em>仿函数当作参数。这个仿函数内部包含了一个智能指针，指向<em>connection</em>实例。只要有一个异步操作等待时，Boost.Asio就会保存<em>boost::bind</em>仿函数的拷贝，这个拷贝保存了指向连接实例的一个智能指针，从而保证<em>connection</em>实例保持活动。问题解决！</p>
<p>当然，<em>connection</em>类仅仅是一个框架类；你需要根据你的需求对它进行调整（它看起来会和当前服务端例子的情况相当不同）。</p>
<p>你需要注意的是创建一个新的连接是相当简单的：<em>connection::ptr(new connection)- &gt;start(ep)</em>。这个方法启动了到服务端的（异步）连接。当你需要关闭这个连接时，调用<em>stop()</em>。</p>
<p>当实例被启动时（<em>start()</em>），它会等待客户端的连接。当连接发生时。*on_connect()<em>被调用。如果没有错误发生，它启动一个read操作（<em>do_read()</em>）。当read操作结束时，你就可以解析这个消息；当然你应用的</em>on_read()<em>看起来会各种各样。而当你写回一个消息时，你需要把它拷贝到缓冲区，然后像我在</em>do_write()*方法中所做的一样将其发送出去，因为这个缓冲区同样需要在这个异步写操作中一直存活。最后需要注意的一点——当写回时，你需要指定写入的数量，否则，整个缓冲区都会被发送出去。</p>
<h3 id="总结-2">总结</h3>
<p>网络api实际上要繁杂得多，这个章节只是做为一个参考，当你在实现自己的网络应用时可以回过头来看看。</p>
<p>Boost.Asio实现了端点的概念，你可以认为是IP和端口。如果你不知道准确的IP，你可以使用<em>resolver</em>对象将主机名，例如<em><a target="_blank" rel="noopener" href="http://www.yahoo.com">www.yahoo.com</a></em>转换为一个或多个IP地址。</p>
<p>我们也可以看到API的核心——socket类。Boost.Asio提供了<em>TCP、UDP</em>和 <em>ICMP</em>的实现。而且你还可以用你自己的协议来对它进行扩展；当然，这个工作不适合缺乏勇气的人。</p>
<p>异步编程是刚需。你应该已经明白为什么有时候需要用到它，尤其在写服务端的时候。调用<em>service.run()<em>来实现异步循环就已经可以让你很满足，但是有时候你需要更进一步，尝试使用</em>run_one()、poll()<em>或者</em>poll_one()</em>。</p>
<p>当实现异步时，你可以异步执行你自己的方法；使用<em>service.post()<em>或者</em>service.dispatch()</em>。</p>
<p>最后，为了使socket和缓冲区（read或者write）在整个异步操作的生命周期中一直活动，我们需要采取特殊的防护措施。你的连接类需要继承自<em>enabled_shared_from_this</em>，然后在内部保存它需要的缓冲区，而且每次异步调用都要传递一个智能指针给<em>this</em>操作。</p>
<h2 id="回显服务端-客户端">回显服务端/客户端</h2>
<p>在这一章，我们将会实现一个小的客户端/服务端应用，这可能会是你写过的最简单的客户端/服务端应用。回显应用就是一个把客户端发过来的任何内容回显给其本身，然后关闭连接的的服务端。这个服务端可以处理任何数量的客户端。每个客户端连接之后发送一个消息，服务端接收到完成消息后把它发送回去。在那之后，服务端关闭连接。</p>
<p>因此，每个回显客户端连接到服务端，发送一个消息，然后读取服务端返回的结果，确保这是它发送给服务端的消息就结束和服务端的会话。</p>
<p>我们首先实现一个同步应用，然后实现一个异步应用，以便你可以很容易对比他们：</p>
<p>为了节省空间，下面的代码有一些被裁剪掉了。你可以在附加在这本书的代码中看到全部的代码。</p>
<h3 id="TCP回显服务端-客户端">TCP回显服务端/客户端</h3>
<p>对于TCP而言，我们需要一个额外的保证；每一个消息以换行符结束(‘\n’)。编写一个同步回显服务端/客户端非常简单。</p>
<p>我们会展示编码内容，比如同步客户端，同步服务端，异步客户端和异步服务端。</p>
<h4 id="TCP同步客户端">TCP同步客户端</h4>
<p>在大多数有价值的例子中，客户端通常比服务端编码要简单（因为服务端需要处理多个客户端请求）。 下面的代码展示了不符合这条规则的一个例外：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">read_complete</span><span class="params">(<span class="type">char</span> * buf, <span class="type">const</span> error_code &amp; err, <span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">find</span>(buf, buf + bytes, <span class="string">&#x27;\n&#x27;</span>) &lt; buf + bytes;</span><br><span class="line">    <span class="comment">// 我们一个一个读取直到读到回车，不缓存</span></span><br><span class="line">    <span class="keyword">return</span> found ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync_echo</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    msg += <span class="string">&quot;\n”;</span></span><br><span class="line"><span class="string">    ip::tcp::socket sock(service);</span></span><br><span class="line"><span class="string">    sock.connect(ep);</span></span><br><span class="line"><span class="string">    sock.write_some(buffer(msg));</span></span><br><span class="line"><span class="string">    char buf[1024];</span></span><br><span class="line"><span class="string">    int bytes = read(sock, buffer(buf), boost::bind(read_complete,buf,_1,_2));</span></span><br><span class="line"><span class="string">    std::string copy(buf, bytes - 1);</span></span><br><span class="line"><span class="string">    msg = msg.substr(0, msg.size() - 1);</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; &quot;</span>server echoed our <span class="string">&quot; &lt;&lt; msg &lt;&lt; &quot;</span>: <span class="string">&quot;&lt;&lt; (copy == msg ? &quot;</span>OK<span class="string">&quot; : &quot;</span>FAI<span class="string">L&quot;) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    sock.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int main(int argc, char* argv[]) &#123;</span></span><br><span class="line"><span class="string">    char* messages[] = &#123; &quot;</span>John says hi<span class="string">&quot;, &quot;</span>so does James<span class="string">&quot;, &quot;</span>Lucy just got home<span class="string">&quot;, &quot;</span>Boost.Asio is Fun!<span class="string">&quot;, 0 &#125;;</span></span><br><span class="line"><span class="string">    boost::thread_group threads;</span></span><br><span class="line"><span class="string">    for ( char ** message = messages; *message; ++message) &#123;</span></span><br><span class="line"><span class="string">        threads.create_thread( boost::bind(sync_echo, *message));</span></span><br><span class="line"><span class="string">        boost::this_thread::sleep( boost::posix_time::millisec(100));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    threads.join_all();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>核心功能<em>sync_echo</em>。它包含了连接到服务端，发送信息然后等待回显的所有逻辑。</p>
<p>你会发现，在读取时，我使用了自由函数<em>read()</em>，因为我想要读’\n’之前的所有内容。*sock.read_some()*方法满足不了这个要求，因为它只会读可用的，而不是全部的消息。</p>
<p>*read()*方法的第三个参数是完成处理句柄。当读取到完整消息时，它返回0。否则，它会返回我下一步（直到读取结束）能都到的最大的缓冲区大小。在我们的例子中，返回结果始终是1，因为我永远不想读的消息比我们需要的更多。</p>
<p>在*main()*中，我们创建了几个线程；每个线程负责把消息发送到客户端，然后等待操作结束。如果你运行这个程序，你会看到下面的输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server echoed our John says hi: OK</span><br><span class="line">server echoed our so does James: OK</span><br><span class="line">server echoed our Lucy just got home: OK</span><br><span class="line">server echoed our Boost.Asio is Fun!: OK</span><br></pre></td></tr></table></figure>
<p>注意：因为我们是同步的，所以不需要调用<em>service.run()</em>。</p>
<h4 id="TCP同步服务端">TCP同步服务端</h4>
<p>回显同步服务端的编写非常容易，参考如下的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">read_complete</span><span class="params">(<span class="type">char</span> * buff, <span class="type">const</span> error_code &amp; err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">find</span>(buff, buff + bytes, <span class="string">&#x27;\n&#x27;</span>) &lt; buff + bytes;</span><br><span class="line">    <span class="comment">// 我们一个一个读取直到读到回车，不缓存</span></span><br><span class="line">    <span class="keyword">return</span> found ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_connections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(service, ip::tcp::endpoint(ip::tcp::v4(),<span class="number">8001</span>))</span></span>;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span>) &#123;</span><br><span class="line">        ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(service)</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(sock);</span><br><span class="line">        <span class="type">int</span> bytes = <span class="built_in">read</span>(sock, <span class="built_in">buffer</span>(buff), boost::<span class="built_in">bind</span>(read_complete,buff,_1,_2));</span><br><span class="line">        <span class="function">std::string <span class="title">msg</span><span class="params">(buff, bytes)</span></span>;</span><br><span class="line">        sock.<span class="built_in">write_some</span>(<span class="built_in">buffer</span>(msg));</span><br><span class="line">        sock.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">handle_connections</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端的逻辑主要在<em>handle_connections()</em>。因为是单线程，我们接受一个客户端请求，读取它发送给我们的消息，然后回显，然后等待下一个连接。可以确定，当两个客户端同时连接时，第二个客户端需要等待服务端处理完第一个客户端的请求。</p>
<p>还是要注意因为我们是同步的，所以不需要调用<em>service.run()</em>。</p>
<h4 id="TCP异步客户端">TCP异步客户端</h4>
<p>当我们开始异步时，编码会变得稍微有点复杂。我们会构建在<strong>第二章 保持活动</strong>中展示的<em>connection</em>类。</p>
<p>观察这个章节中接下来的代码，你会发现每个异步操作启动了新的异步操作，以保持*service.run()*一直工作。 首先，核心功能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_FN(x)       boost::bind(&amp;self_type::x, shared_from_this())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_FN1(x,y)    boost::bind(&amp;self_type::x, shared_from_this(),y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_FN2(x,y,z)  boost::bind(&amp;self_type::x, shared_from_this(),y,z)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">talk_to_svr</span> : <span class="keyword">public</span> boost::enable_shared_from_this&lt;talk_to_svr&gt; , boost::noncopyable &#123;</span><br><span class="line">    <span class="keyword">typedef</span> talk_to_svr self_type;</span><br><span class="line">    <span class="built_in">talk_to_svr</span>(<span class="type">const</span> std::string &amp; message) : <span class="built_in">sock_</span>(service), <span class="built_in">started_</span>(<span class="literal">true</span>), <span class="built_in">message_</span>(message) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(ip::tcp::endpoint ep)</span> </span>&#123;</span><br><span class="line">        sock_.<span class="built_in">async_connect</span>(ep, <span class="built_in">MEM_FN1</span>(on_connect,_1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::system::error_code error_code;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;talk_to_svr&gt; ptr;</span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">start</span><span class="params">(ip::tcp::endpoint ep, <span class="type">const</span> std::string &amp;message)</span> </span>&#123;</span><br><span class="line">        <span class="function">ptr <span class="title">new_</span><span class="params">(<span class="keyword">new</span> talk_to_svr(message))</span></span>;</span><br><span class="line">        new_-&gt;<span class="built_in">start</span>(ep);</span><br><span class="line">        <span class="keyword">return</span> new_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !started_) <span class="keyword">return</span>;</span><br><span class="line">        started_ = <span class="literal">false</span>;</span><br><span class="line">        sock_.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> read_buffer_[max_msg];</span><br><span class="line">    <span class="type">char</span> write_buffer_[max_msg];</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    std::string message_; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要一直使用指向<em>talk_to_svr</em>的智能指针，这样的话当在<em>tack_to_svr</em>的实例上有异步操作时，那个实例是一直活动的。为了避免错误，比如在栈上构建一个<em>talk_to_svr</em>对象的实例时，我把构造方法设置成了私有而且不允许拷贝构造（继承自<em>boost::noncopyable</em>）。</p>
<p>我们有了核心方法，比如<em>start(),stop()<em>和</em>started()</em>，它们所做的事情也正如它们名字表达的一样。如果需要建立连接，调用*talk_to_svr::start(endpoint, message)<em>即可。我们同时还有一个read缓冲区和一个write缓冲区。（<em>read*buufer**和</em>write*buffer</em>*）。</p>
<p><em>MEM_FN</em> <em>是一个方便使用的宏，它们通过</em>shared_ptr_from_this()<em>方法强制使用一个指向</em> <em>this</em> 的智能指针。</p>
<p>下面的几行代码和之前的解释非常不同：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等同于 &quot;sock_.async_connect(ep, MEM_FN1(on_connect,_1));&quot;</span></span><br><span class="line"><span class="selector-tag">sock_</span><span class="selector-class">.async_connect</span>(ep,<span class="attribute">boost</span>::<span class="built_in">bind</span>(&amp;<span class="attribute">talk_to_svr</span>::on_connect,<span class="built_in">shared_ptr_from_this</span>(),_1));</span><br><span class="line"><span class="selector-tag">sock_</span><span class="selector-class">.async_connect</span>(ep, <span class="attribute">boost</span>::<span class="built_in">bind</span>(&amp;<span class="attribute">talk_to_svr</span>::on_connect,this,_1));</span><br></pre></td></tr></table></figure>
<p>在上述例子中，我们正确的创建了<em>async_connect</em>的完成处理句柄；在调用完成处理句柄之前它会保留一个指向<em>talk_to_server</em>实例的智能指针，从而保证当其发生时<em>talk_to_server</em>实例还是保持活动的。</p>
<p>在接下来的例子中，我们错误地创建了完成处理句柄，当它被调用时，<em>talk_to_server</em>实例很可能已经被释放了。 从socket读取或写入时，你使用如下的代码片段：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">do_read</span>() &#123;</span><br><span class="line">    <span class="built_in">async_read</span>(sock_, buffer(read_buffer_), <span class="built_in">MEM_FN2</span>(read_complete,_1,_2), <span class="built_in">MEM_FN2</span>(on_read,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">do_write</span>(const std::string &amp; msg) &#123;</span><br><span class="line">    if ( !started() ) return;</span><br><span class="line">    std::<span class="built_in">copy</span>(msg.<span class="built_in">begin</span>(), msg.<span class="built_in">end</span>(), write_buffer_);</span><br><span class="line">    sock_<span class="selector-class">.async_write_some</span>( buffer(write_buffer_, msg.size()), <span class="built_in">MEM_FN2</span>(on_write,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line">size_t <span class="built_in">read_complete</span>(const boost::system::error_code &amp; err, size_t bytes) &#123;</span><br><span class="line">    <span class="comment">// 和TCP客户端中的类似</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*do_read()<em>方法会保证当</em>on_read()<em>被调用的时候，我们从服务端读取一行。<em>do_write()<em>方法会先把信息拷贝到缓冲区（考虑到当</em>async_write</em>发生时msg可能已经超出范围被释放），然后保证实际的写入操作发生时</em>on_write()*被调用。</p>
<p>然后是最重要的方法，这个方法包含了类的主要逻辑：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">on_connect</span>(const error_code &amp; err) &#123;</span><br><span class="line">    if ( !err)      <span class="built_in">do_write</span>(message_ + &quot;\n&quot;);</span><br><span class="line">    else            <span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">on_read</span>(const error_code &amp; err, size_t bytes) &#123;</span><br><span class="line">    if ( !err) &#123;</span><br><span class="line">        std::string <span class="built_in">copy</span>(read_buffer_, bytes - <span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server echoed our &quot;</span> &lt;&lt; message_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; (copy == message_ ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;FAIL&quot;</span>) &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stop</span>(); </span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">on_write</span>(const error_code &amp; err, size_t bytes) &#123;</span><br><span class="line">    <span class="built_in">do_read</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当连接成功之后，我们发送消息到服务端,<em>do_write()</em>。当write操作结束时，*on_write()<em>被调用，它初始化了一个</em>do_read()<em>方法，当</em>do_read()*完成时。*on_read()*被调用；这里，我们简单的检查一下返回的信息是否是服务端的回显，然后退出服务。 我们会发送三个消息到服务端让它变得更有趣一点：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    ip::tcp::endpoint ep( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8001</span>);</span><br><span class="line">    <span class="keyword">char</span>* messages[] = &#123; <span class="string">&quot;John says hi&quot;</span>, <span class="string">&quot;so does James&quot;</span>, <span class="string">&quot;Lucy got home&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">char</span> ** message = messages; *message; ++message) &#123;</span><br><span class="line">        talk_to_svr::start( ep, *message);</span><br><span class="line">        boost::this_thread::sleep( boost::posix_time::millisec(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    service.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码会生成如下的输出：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">server</span> echoed our John says hi: OK</span><br><span class="line"><span class="keyword">server</span> echoed our so does James: OK</span><br><span class="line"><span class="keyword">server</span> echoed our Lucy just got home: OK</span><br></pre></td></tr></table></figure>
<h4 id="TCP异步服务端">TCP异步服务端</h4>
<p>核心功能和同步服务端的功能类似，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">talk_to_client</span> : <span class="keyword">public</span> boost::enable_shared_from_this&lt;talk_to_</span><br><span class="line">   client&gt;, boost::noncopyable &#123;</span><br><span class="line">    <span class="keyword">typedef</span> talk_to_client self_type;</span><br><span class="line">    <span class="built_in">talk_to_client</span>() : <span class="built_in">sock_</span>(service), <span class="built_in">started_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::system::error_code error_code;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;talk_to_client&gt; ptr;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        started_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">do_read</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">new_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">ptr <span class="title">new_</span><span class="params">(<span class="keyword">new</span> talk_to_client)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> new_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !started_) <span class="keyword">return</span>;</span><br><span class="line">        started_ = <span class="literal">false</span>;</span><br><span class="line">        sock_.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ip::<span class="function">tcp::socket &amp; <span class="title">sock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sock_;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> read_buffer_[max_msg];</span><br><span class="line">    <span class="type">char</span> write_buffer_[max_msg];</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为我们是非常简单的回显服务，这里不需要*is_started()*方法。对每个客户端，仅仅读取它的消息，回显，然后关闭它。</p>
<p>*do_read()，do_write()<em>和</em>read_complete()<em>方法和TCP同步服务端的完全一致。 主要的逻辑同样是在</em>on_read()<em>和</em>on_write()*方法中：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">on_read</span>(const error_code &amp; err, size_t bytes) &#123;</span><br><span class="line">    if ( !err) &#123;</span><br><span class="line">        std::string <span class="built_in">msg</span>(read_buffer_, bytes);</span><br><span class="line">        <span class="built_in">do_write</span>(msg + &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stop</span>(); </span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">on_write</span>(const error_code &amp; err, size_t bytes) &#123;</span><br><span class="line">    <span class="built_in">do_read</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对客户端的处理如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ip::tcp::acceptor acceptor(service, ip::tcp::endpoint(ip::tcp::v4(),<span class="number">8001</span>));</span><br><span class="line">void handle_accept(talk_to_client::ptr client, <span class="keyword">const</span> error_code &amp; err)</span><br><span class="line">&#123;</span><br><span class="line">    client-&gt;start();</span><br><span class="line">    talk_to_client::ptr new_client = talk_to_client::new_();</span><br><span class="line">    acceptor.async_accept(new_client-&gt;sock(), boost::bind(handle_accept,new_client,_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    talk_to_client::ptr client = talk_to_client::new_();</span><br><span class="line">    acceptor.async_accept(client-&gt;sock(), boost::bind(handle_accept,client,_1));</span><br><span class="line">    service.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次客户端连接到服务时，<em>handle_accept</em>被调用，它会异步地从客户端读取，然后同样异步地等待一个新的客户端。</p>
<h4 id="代码">代码</h4>
<p>你会在这本书相应的代码中得到所有4个应用（TCP回显同步客户端，TCP回显同步服务端，TCP回显异步客户端，TCP回显异步服务端）。当测试时，你可以使用任意客户端/服务端组合（比如，一个异步客户端和一个同步服务端）。</p>
<h3 id="UDP回显服务端-客户端">UDP回显服务端/客户端</h3>
<p>因为UDP不能保证所有信息都抵达接收者，我们不能保证“信息以回车结尾”。 没收到消息，我们只是回显，但是没有socket去关闭（在服务端），因为我们是UDP。</p>
<h4 id="UDP同步回显客户端">UDP同步回显客户端</h4>
<p>UDP回显客户端比TCP回显客户端要简单：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ip::udp::endpoint ep( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8001</span>);</span><br><span class="line">void sync_echo(std::string msg) &#123;</span><br><span class="line">    ip::udp::socket sock(service, ip::udp::endpoint(ip::udp::v4(), <span class="number">0</span>));</span><br><span class="line">    sock.send_to(buffer(msg), ep);</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    ip::udp::endpoint sender_ep;</span><br><span class="line">    <span class="keyword">int</span> bytes = sock.receive_from(buffer(buff), sender_ep);</span><br><span class="line">    std::string copy(buff, bytes);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server echoed our &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; (copy == msg ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;FAIL&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    sock.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    <span class="keyword">char</span>* messages[] = &#123; <span class="string">&quot;John says hi&quot;</span>, <span class="string">&quot;so does James&quot;</span>, <span class="string">&quot;Lucy got home&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    boost::thread_group threads;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">char</span> ** message = messages; *message; ++message) &#123;</span><br><span class="line">        threads.create_thread( boost::bind(sync_echo, *message));</span><br><span class="line">        boost::this_thread::sleep( boost::posix_time::millisec(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    threads.join_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的逻辑都在*synch_echo()*中；连接到服务端，发送消息，接收服务端的回显，然后关闭连接。</p>
<h4 id="UDP同步回显服务端">UDP同步回显服务端</h4>
<p>UDP回显服务端会是你写过的最简单的服务端：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">void handle_connections() &#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    ip::udp::socket sock(service, ip::udp::endpoint(ip::udp::v4(), <span class="number">8001</span>));</span><br><span class="line">    <span class="keyword">while</span> ( <span class="keyword">true</span>) &#123;</span><br><span class="line">        ip::udp::endpoint sender_ep;</span><br><span class="line">        <span class="keyword">int</span> bytes = sock.receive_from(buffer(buff), sender_ep);</span><br><span class="line">        std::string msg(buff, bytes);</span><br><span class="line">        sock.send_to(buffer(msg), sender_ep);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    handle_connections();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它非常简单，而且能很好的自释。 我把异步UDP客户端和服务端留给读者当作一个练习。</p>
<h3 id="总结-3">总结</h3>
<p>我们已经写了完整的应用，最终让Boost.Asio得以工作。回显应用是开始学习一个库时非常好的工具。你可以经常学习和运行这个章节所展示的代码，这样你就可以非常容易地记住这个库的基础。 在下一章，我们会建立更复杂的客户端/服务端应用，我们要确保避免低级错误，比如内存泄漏，死锁等等。</p>
<h2 id="客户端和服务端">客户端和服务端</h2>
<p>在这一章节，我们会深入学习怎样使用Boost.Asio建立非凡的客户端和服务端应用。你可以运行并测试它们，而且在理解之后，你可以把它们做为框架来构造自己的应用。</p>
<p>在接下来的例子中：</p>
<ul>
<li>客户端使用一个用户名（无密码）登录到服务端</li>
<li>所有的连接由客户端建立，当客户端请求时服务端回应</li>
<li>所有的请求和回复都以换行符结尾（’\n’）</li>
<li>对于5秒钟没有ping操作的客户端，服务端会自动断开其连接</li>
</ul>
<p>客户端可以发送如下请求：</p>
<ul>
<li>获得所有已连接客户端的列表</li>
<li>客户端可以ping，当它ping时，服务端返回<em>ping ok</em>或者<em>ping client_list_chaned</em>（在接下来的例子中，客户端重新请求已连接的客户端列表）</li>
</ul>
<p>为了更有趣一点，我们增加了一些难度：</p>
<ul>
<li>每个客户端登录6个用户连接，比如Johon,James,Lucy,Tracy,Frank和Abby</li>
<li>每个客户端连接随机地ping服务端（随机7秒；这样的话，服务端会时不时关闭一个连接）</li>
</ul>
<h3 id="同步客户端-服务端">同步客户端/服务端</h3>
<p>首先，我们会实现同步应用。你会发现它的代码很直接而且易读的。而且因为所有的网络调用都是阻塞的，所以它不需要独立的线程。</p>
<h4 id="同步客户端">同步客户端</h4>
<p>同步客户端会以你所期望的串行方式运行；连接到服务端，登录服务器，然后执行连接循环，比如休眠一下，发起一个请求，读取服务端返回，然后再休眠一会，然后一直循环下去……</p>
<p>因为我们是同步的，所以我们让事情变得简单一点。首先，连接到服务器，然后再循环，如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip::tcp::endpoint ep( ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8001</span>);</span><br><span class="line">void run_client(<span class="keyword">const</span> std::string &amp; client_name) &#123;</span><br><span class="line">    talk_to_svr client(client_name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.connect(ep);</span><br><span class="line">        client.<span class="keyword">loop</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(boost::system::system_error &amp; err) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;client terminated &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码片段展示了talk_to_svr类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">talk_to_svr</span> &#123;</span><br><span class="line">    <span class="built_in">talk_to_svr</span>(<span class="type">const</span> std::string &amp; username) : <span class="built_in">sock_</span>(service), <span class="built_in">started_</span>(<span class="literal">true</span>), <span class="built_in">username_</span>(username) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(ip::tcp::endpoint ep)</span> </span>&#123;</span><br><span class="line">        sock_.<span class="built_in">connect</span>(ep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="string">&quot;login &quot;</span> + username_ + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">read_answer</span>();</span><br><span class="line">        <span class="keyword">while</span> ( started_) &#123;</span><br><span class="line">            <span class="built_in">write_request</span>();</span><br><span class="line">            <span class="built_in">read_answer</span>();</span><br><span class="line">            boost::this_thread::<span class="built_in">sleep</span>(<span class="built_in">millisec</span>(<span class="built_in">rand</span>() % <span class="number">7000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">username</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> username_; &#125;</span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">int</span> already_read_;</span><br><span class="line">    <span class="type">char</span> buff_[max_msg];</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    std::string username_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个循环中，我们仅仅填充1个比特，做一个ping操作之后就进入睡眠状态，之后再读取服务端的返回。我们的睡眠是随机的（有时候超过5秒），这样服务端就有可能在某个时间点断开我们的连接：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">write_request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">write</span>(<span class="string">&quot;ping\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">read_answer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    already_read_ = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">read</span>(sock_, <span class="title function_">buffer</span>(buff_), <span class="attr">boost</span>::<span class="title function_">bind</span>(&amp;<span class="attr">talk_to_svr</span>::read_complete, <span class="variable language_">this</span>, _1, _2));</span><br><span class="line">    <span class="title function_">process_msg</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">process_msg</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">msg</span>(buff_, already_read_);</span><br><span class="line">    <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;login &quot;</span>) == <span class="number">0</span>) <span class="title function_">on_login</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;ping&quot;</span>) == <span class="number">0</span>) <span class="title function_">on_ping</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;clients &quot;</span>) == <span class="number">0</span>) <span class="title function_">on_clients</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="attr">std</span>::cerr &lt;&lt; <span class="string">&quot;invalid msg &quot;</span> &lt;&lt; msg &lt;&lt; <span class="attr">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于读取结果，我们使用在之前章节就有说到的<em>read_complete</em>来保证我们能读到换行符（’\n’）。这段逻辑在*process_msg()*中，在这里我们读取服务端的返回，然后分发到正确的方法去处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">on_login</span>(<span class="params"></span>) &#123; <span class="title function_">do_ask_clients</span>(); &#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_ping</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::istringstream <span class="title function_">in</span>(msg);</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> answer;</span><br><span class="line">    <span class="keyword">in</span> &gt;&gt; answer &gt;&gt; answer;</span><br><span class="line">    <span class="keyword">if</span> ( answer == <span class="string">&quot;client_list_changed&quot;</span>)</span><br><span class="line">        <span class="title function_">do_ask_clients</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_clients</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> clients = msg.<span class="title function_">substr</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="attr">std</span>::cout &lt;&lt; username_ &lt;&lt; <span class="string">&quot;, new client list:&quot;</span> &lt;&lt; clients;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">do_ask_clients</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">write</span>(<span class="string">&quot;ask_clients\n&quot;</span>);</span><br><span class="line">    <span class="title function_">read_answer</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">write</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123; sock_.<span class="title function_">write_some</span>(<span class="title function_">buffer</span>(msg)); &#125;</span><br><span class="line">size_t <span class="title function_">read_complete</span>(<span class="params"><span class="keyword">const</span> boost::system::error_code &amp; err, size_t bytes</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 和之前一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读取服务端对我们ping操作的返回时，如果得到的消息是<em>client_list_changed</em>，我们就需要重新请求客户端列表。</p>
<h4 id="同步服务端">同步服务端</h4>
<p>同步服务端也是相当简单的。它只需要两个线程，一个负责接收新的客户端连接，另外一个负责处理已经存在的客户端请求。它不能使用单线程，因为等待新的客户端连接是一个阻塞操作，所以我们需要另外一个线程来处理已经存在的客户端请求。</p>
<p>正常来说服务端都比客户端要难实现。一方面，它要管理所有已经连接的客户端。因为我们是同步的，所以我们需要至少两个线程，一个负责接受新的客户端连接（因为accept()是阻塞的）而另一个负责回复已经存在的客户端。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void accept_thread() &#123;</span><br><span class="line">    ip::tcp::acceptor acceptor(service,ip::tcp::endpoint(ip::tcp::v4(), <span class="number">8001</span>));</span><br><span class="line">    <span class="keyword">while</span> ( <span class="keyword">true</span>) &#123;</span><br><span class="line">        client_ptr new_( <span class="keyword">new</span> talk_to_client);</span><br><span class="line">        acceptor.accept(new_-&gt;sock());</span><br><span class="line">        boost::recursive_mutex::scoped_lock lk(cs);</span><br><span class="line">        clients.push_back(new_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void handle_clients_thread() &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="keyword">true</span>) &#123;</span><br><span class="line">        boost::this_thread::sleep( millisec(<span class="number">1</span>));</span><br><span class="line">        boost::recursive_mutex::scoped_lock lk(cs);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">array</span>::iterator b = clients.begin(), e = clients.end(); b!= e; ++b)</span><br><span class="line">            (*b)-&gt;answer_to_client();</span><br><span class="line">        <span class="comment">// 删除已经超时的客户端</span></span><br><span class="line">        clients.erase(std::remove_if(clients.begin(), clients.end(), boost::bind(&amp;talk_to_client::timed_out,_1)), clients.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    boost::thread_group threads;</span><br><span class="line">    threads.create_thread(accept_thread);</span><br><span class="line">    threads.create_thread(handle_clients_thread);</span><br><span class="line">    threads.join_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了分辨客户端发送过来的请求我们需要保存一个客户端的列表。 每个<em>talk_to_client</em>实例都拥有一个socket，socket类是不支持拷贝构造的，所以如果你想要把它们保存在一个<em>std::vector</em>对象中，你需要一个指向它的智能指针。这里有两种实现的方式：在<em>talk_to_client</em>内部保存一个指向socket的智能指针然后创建一个<em>talk_to_client</em>实例的数组，或者让<em>talk_to_client</em>实例用变量的方式保存socket，然后创建一个指向<em>talk_to_client</em>智能指针的数组。我选择后者，但是你也可以选前面的方式：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type<span class="keyword">def</span> <span class="title function_">boost</span><span class="symbol">:</span><span class="symbol">:shared_ptr&lt;talk_to_client&gt;</span> client_ptr;</span><br><span class="line">type<span class="keyword">def</span> <span class="title function_">std</span><span class="symbol">:</span><span class="symbol">:vector&lt;client_ptr&gt;</span> array;</span><br><span class="line">array clients;</span><br><span class="line">boost::recursive_mutex cs; <span class="regexp">//</span> 用线程安全的方式访问客户端数组</span><br></pre></td></tr></table></figure>
<p><em>talk_to_client</em>的主要代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">talk_to_client</span> : boost::enable_shared_from_this&lt;talk_to_client&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">talk_to_client</span>() &#123; ... &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">username</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> username_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">answer_to_client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">read_request</span>();</span><br><span class="line">            <span class="built_in">process_request</span>();</span><br><span class="line">        &#125; <span class="built_in">catch</span> ( boost::system::system_error&amp;) &#123; <span class="built_in">stop</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">timed_out</span>())</span><br><span class="line">            <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_clients_changed</span><span class="params">()</span> </span>&#123; clients_changed_ = <span class="literal">true</span>; &#125;</span><br><span class="line">    ip::<span class="function">tcp::socket &amp; <span class="title">sock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sock_; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">timed_out</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ptime now = microsec_clock::<span class="built_in">local_time</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ms = (now - last_ping).<span class="built_in">total_milliseconds</span>();</span><br><span class="line">        <span class="keyword">return</span> ms &gt; <span class="number">5000</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boost::system::error_code err; sock_.<span class="built_in">close</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( sock_.<span class="built_in">available</span>())</span><br><span class="line">            already_read_ += sock_.<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(buff_ + already_read_, max_msg - already_read_));</span><br><span class="line">    &#125;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...  和同步客户端中的一样</span></span><br><span class="line">    <span class="type">bool</span> clients_changed_;</span><br><span class="line">    ptime last_ping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码拥有非常好的自释能力。其中最重要的方法是<em>read_request()</em>。它只在存在有效数据的情况才读取，这样的话，服务端永远都不会阻塞：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> found_enter = std::<span class="built_in">find</span>(buff_, buff_ + already_read_, <span class="string">&#x27;\n&#x27;</span>) &lt; buff_ + already_read_;</span><br><span class="line">    <span class="keyword">if</span> ( !found_enter)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 消息不完整</span></span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">    last_ping = microsec_clock::<span class="built_in">local_time</span>();</span><br><span class="line">    <span class="type">size_t</span> pos = std::<span class="built_in">find</span>(buff_, buff_ + already_read_, <span class="string">&#x27;\n&#x27;</span>) - buff_;</span><br><span class="line">    <span class="function">std::string <span class="title">msg</span><span class="params">(buff_, pos)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(buff_ + already_read_, buff_ + max_msg, buff_);</span><br><span class="line">    already_read_ -= pos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( msg.<span class="built_in">find</span>(<span class="string">&quot;login &quot;</span>) == <span class="number">0</span>) <span class="built_in">on_login</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="built_in">find</span>(<span class="string">&quot;ping&quot;</span>) == <span class="number">0</span>) <span class="built_in">on_ping</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="built_in">find</span>(<span class="string">&quot;ask_clients&quot;</span>) == <span class="number">0</span>) <span class="built_in">on_clients</span>();</span><br><span class="line">    <span class="keyword">else</span> std::cerr &lt;&lt; <span class="string">&quot;invalid msg &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_login</span><span class="params">(<span class="type">const</span> std::string &amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">in</span><span class="params">(msg)</span></span>;</span><br><span class="line">    in &gt;&gt; username_ &gt;&gt; username_;</span><br><span class="line">    <span class="built_in">write</span>(<span class="string">&quot;login ok\n&quot;</span>);</span><br><span class="line">    <span class="built_in">update_clients_changed</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_ping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(clients_changed_ ? <span class="string">&quot;ping client_list_changed\n&quot;</span> : <span class="string">&quot;ping ok\n&quot;</span>);</span><br><span class="line">    clients_changed_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_clients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string msg;</span><br><span class="line">    &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>( array::const_iterator b = clients.<span class="built_in">begin</span>(), e = clients.<span class="built_in">end</span>() ; b != e; ++b)</span><br><span class="line">            msg += (*b)-&gt;<span class="built_in">username</span>() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(<span class="string">&quot;clients &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp; msg)</span></span>&#123;sock_.<span class="built_in">write_some</span>(<span class="built_in">buffer</span>(msg)); &#125;</span><br></pre></td></tr></table></figure>
<p>观察<em>process_request()</em>。当我们读取到足够多有效的数据时，我们需要知道我们是否已经读取到整个消息(如果<em>found_enter</em>为真)。这样做的话，我们可以使我们避免一次读多个消息的可能（’\n’之后的消息也被保存到缓冲区中），然后我们解析读取到的整个消息。剩下的代码都是很容易读懂的。</p>
<h3 id="异步客户端-服务端">异步客户端/服务端</h3>
<p>现在，是比较有趣（也比较难）的异步实现！ 当查看示意图时，你需要知道Boost.Asio代表由Boost.Asio执行的一个异步调用。例如<em>do_read()</em>，Boost.Asio和*on_read()<em>代表了从</em>do_read()<em>到</em>on_read()<em>的逻辑流程，但是你永远不知道什么时候轮到</em>on_read()*被调用，你只是知道你最终会调用它。</p>
<h4 id="异步客户端">异步客户端</h4>
<p>到这里事情会变得有点复杂，但是仍然是可控的。当然你也会拥有一个不会阻塞的应用。</p>
<p>下面的代码你应该已经很熟悉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_FN(x)       boost::bind(&amp;self_type::x, shared_from_this())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_FN1(x,y)    boost::bind(&amp;self_type::x, shared_from_</span></span><br><span class="line"><span class="built_in">this</span>(),y)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_FN2(x,y,z)  boost::bind(&amp;self_type::x, shared_from_</span></span><br><span class="line"><span class="built_in">this</span>(),y,z)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">talk_to_svr</span> : <span class="keyword">public</span> boost::enable_shared_from_this&lt;talk_to_svr&gt;, boost::noncopyable &#123;</span><br><span class="line">    <span class="keyword">typedef</span> talk_to_svr self_type;</span><br><span class="line">    <span class="built_in">talk_to_svr</span>(<span class="type">const</span> std::string &amp; username) : <span class="built_in">sock_</span>(service), <span class="built_in">started_</span>(<span class="literal">true</span>), <span class="built_in">username_</span>(username), <span class="built_in">timer_</span></span><br><span class="line">(service) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(ip::tcp::endpoint ep)</span> </span>&#123;</span><br><span class="line">        sock_.<span class="built_in">async_connect</span>(ep, <span class="built_in">MEM_FN1</span>(on_connect,_1));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::system::error_code error_code;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;talk_to_svr&gt; ptr;</span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">start</span><span class="params">(ip::tcp::endpoint ep, <span class="type">const</span> std::string &amp; username)</span> </span>&#123;</span><br><span class="line">        <span class="function">ptr <span class="title">new_</span><span class="params">(<span class="keyword">new</span> talk_to_svr(username))</span></span>;</span><br><span class="line">        new_-&gt;<span class="built_in">start</span>(ep);</span><br><span class="line">        <span class="keyword">return</span> new_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !started_) <span class="keyword">return</span>;</span><br><span class="line">        started_ = <span class="literal">false</span>;</span><br><span class="line">        sock_.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">read_complete</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( err) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> found = std::<span class="built_in">find</span>(read_buffer_, read_buffer_ + bytes, <span class="string">&#x27;\n&#x27;</span>) &lt; read_buffer_ + bytes;</span><br><span class="line">        <span class="keyword">return</span> found ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> read_buffer_[max_msg];</span><br><span class="line">    <span class="type">char</span> write_buffer_[max_msg];</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    std::string username_;</span><br><span class="line">    deadline_timer timer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你会看到额外还有一个叫*deadline*timer timer**的方法用来ping服务端；而且ping操作同样是随机的。 下面是类的逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">on_connect</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> ( !err)      <span class="title function_">do_write</span>(<span class="string">&quot;login &quot;</span> + username_ + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span>            <span class="title function_">stop</span>();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_read</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="title function_">stop</span>();</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="title function_">started</span>() ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">msg</span>(read_buffer_, bytes);</span><br><span class="line">    <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;login &quot;</span>) == <span class="number">0</span>) <span class="title function_">on_login</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;ping&quot;</span>) == <span class="number">0</span>) <span class="title function_">on_ping</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;clients &quot;</span>) == <span class="number">0</span>) <span class="title function_">on_clients</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_login</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">do_ask_clients</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_ping</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::istringstream <span class="title function_">in</span>(msg);</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> answer;</span><br><span class="line">    <span class="keyword">in</span> &gt;&gt; answer &gt;&gt; answer;</span><br><span class="line">    <span class="keyword">if</span> ( answer == <span class="string">&quot;client_list_changed&quot;</span>) <span class="title function_">do_ask_clients</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">postpone_ping</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_clients</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> clients = msg.<span class="title function_">substr</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="attr">std</span>::cout &lt;&lt; username_ &lt;&lt; <span class="string">&quot;, new client list:&quot;</span> &lt;&lt; clients ;</span><br><span class="line">    <span class="title function_">postpone_ping</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在*on_read()*中，首先的两行代码是亮点。在第一行，如果出现错误，我们就停止。而第二行，如果我们已经停止了（之前就停止了或者刚好停止），我们就返回。反之如果所有都是OK，我们就对收到的消息进行处理。</p>
<p>最后是*do_**方法，实现如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">do_ping</span>() &#123; <span class="built_in">do_write</span>(&quot;ping\n&quot;); &#125;</span><br><span class="line">void <span class="built_in">postpone_ping</span>() &#123;</span><br><span class="line">    timer_<span class="selector-class">.expires_from_now</span>(boost::posix_time::millisec(rand() % <span class="number">7000</span>));</span><br><span class="line">    timer_<span class="selector-class">.async_wait</span>( MEM_FN(do_ping));</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">do_ask_clients</span>() &#123; <span class="built_in">do_write</span>(&quot;ask_clients\n&quot;); &#125;</span><br><span class="line">void <span class="built_in">on_write</span>(const error_code &amp; err, size_t bytes) &#123; <span class="built_in">do_read</span>(); &#125;</span><br><span class="line">void <span class="built_in">do_read</span>() &#123;</span><br><span class="line">    <span class="built_in">async_read</span>(sock_, buffer(read_buffer_), <span class="built_in">MEM_FN2</span>(read_complete,_1,_2), <span class="built_in">MEM_FN2</span>(on_read,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">do_write</span>(const std::string &amp; msg) &#123;</span><br><span class="line">    if ( !started() ) return;</span><br><span class="line">    std::<span class="built_in">copy</span>(msg.<span class="built_in">begin</span>(), msg.<span class="built_in">end</span>(), write_buffer_);</span><br><span class="line">    sock_<span class="selector-class">.async_write_some</span>( buffer(write_buffer_, msg.size()), <span class="built_in">MEM_FN2</span>(on_write,_1,_2));</span><br></pre></td></tr></table></figure>
<p>注意每一个<em>read</em>操作都会触发一个ping操作</p>
<ul>
<li>当<em>read</em>操作结束时，*on_read()*被调用</li>
<li><em>on_read()<em>调用</em>on_login()，on_ping()<em>或者</em>on_clients()</em></li>
<li>每一个方法要么发出一个ping，要么请求客户端列表</li>
<li>如果我们请求客户端列表，当<em>read</em>操作接收到它们时，它会发出一个ping操作。</li>
</ul>
<h4 id="异步服务端">异步服务端</h4>
<p>这个示意图是相当复杂的；从Boost.Asio出来你可以看到4个箭头指向<em>on_accept，on_read，on_write</em>和<em>on_check_ping</em>。这也就意味着你永远不知道哪个异步调用是下一个完成的调用，但是你可以确定的是它是这4个操作中的一个。</p>
<p>现在，我们是异步的了；我们可以继续保持单线程。接受客户端连接是最简单的部分，如下所示：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ip::tcp::acceptor acceptor(service, ip::tcp::endpoint(ip::tcp::v4(), <span class="number">8001</span>));</span><br><span class="line">void handle_accept(talk_to_client::ptr client, <span class="keyword">const</span> error_code &amp; err)</span><br><span class="line">&#123;</span><br><span class="line">    client-&gt;start();</span><br><span class="line">    talk_to_client::ptr new_client = talk_to_client::new_();</span><br><span class="line">    acceptor.async_accept(new_client-&gt;sock(), boost::bind(handle_accept,new_client,_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    talk_to_client::ptr client = talk_to_client::new_();</span><br><span class="line">    acceptor.async_accept(client-&gt;sock(),boost::bind(handle_accept,client,_1));</span><br><span class="line">    service.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会一直异步地等待一个新的客户端连接（每个新的客户端连接会触发另外一个异步等待操作）。 我们需要监控<em>client list changed</em>事件（一个新客户端连接或者一个客户端断开连接），然后当事件发生时通知所有的客户端。因此，我们需要保存一个客户端连接的数组，否则除非你不需要在某一时刻知道所有连接的客户端，你才不需要这样一个数组。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> talk_to_client; </span><br><span class="line">type<span class="keyword">def</span> <span class="title function_">boost</span><span class="symbol">:</span><span class="symbol">:shared_ptr&lt;talk_to_client&gt;client_ptr</span>;</span><br><span class="line">type<span class="keyword">def</span> <span class="title function_">std</span><span class="symbol">:</span><span class="symbol">:vector&lt;client_ptr&gt;</span> array;</span><br><span class="line">array clients;</span><br></pre></td></tr></table></figure>
<p>connection类的框架如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">talk_to_client</span> : <span class="keyword">public</span> boost::enable_shared_from_this&lt;talk_to_client&gt; , boost::noncopyable &#123;</span><br><span class="line">    <span class="built_in">talk_to_client</span>() &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::system::error_code error_code;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;talk_to_client&gt; ptr;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        started_ = <span class="literal">true</span>;</span><br><span class="line">        clients.<span class="built_in">push_back</span>( <span class="built_in">shared_from_this</span>());</span><br><span class="line">        last_ping = boost::posix_time::microsec_clock::<span class="built_in">local_time</span>();</span><br><span class="line">        <span class="built_in">do_read</span>(); <span class="comment">//首先，我们等待客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">new_</span><span class="params">()</span> </span>&#123; <span class="function">ptr <span class="title">new_</span><span class="params">(<span class="keyword">new</span> talk_to_client)</span></span>; <span class="keyword">return</span> new_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !started_) <span class="keyword">return</span>;</span><br><span class="line">        started_ = <span class="literal">false</span>;</span><br><span class="line">        sock_.<span class="built_in">close</span>();</span><br><span class="line">        ptr self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        array::iterator it = std::<span class="built_in">find</span>(clients.<span class="built_in">begin</span>(), clients.<span class="built_in">end</span>(), self);</span><br><span class="line">        clients.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="built_in">update_clients_changed</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    ip::<span class="function">tcp::socket &amp; <span class="title">sock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sock_;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">username</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> username_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_clients_changed</span><span class="params">()</span> </span>&#123; clients_changed_ = <span class="literal">true</span>; &#125;</span><br><span class="line">    … </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> read_buffer_[max_msg];</span><br><span class="line">    <span class="type">char</span> write_buffer_[max_msg];</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    std::string username_;</span><br><span class="line">    deadline_timer timer_;</span><br><span class="line">    boost::posix_time::ptime last_ping;</span><br><span class="line">    <span class="type">bool</span> clients_changed_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我会用<em>talk_to_client</em>或者<em>talk_to_server</em>来调用<em>connection</em>类，从而让你更明白我所说的内容。</p>
<p>现在你需要用到之前的代码了；它和我们在客户端应用中所用到的是一样的。我们还有另外一个*stop()*方法，这个方法用来从客户端数组中移除一个客户端连接。</p>
<p>服务端持续不断地等待异步的<em>read</em>操作：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">on_read</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="title function_">stop</span>();</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="title function_">started</span>() ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">msg</span>(read_buffer_, bytes);</span><br><span class="line">    <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;login &quot;</span>) == <span class="number">0</span>) <span class="title function_">on_login</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;ping&quot;</span>) == <span class="number">0</span>) <span class="title function_">on_ping</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;ask_clients&quot;</span>) == <span class="number">0</span>) <span class="title function_">on_clients</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_login</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::istringstream <span class="title function_">in</span>(msg);</span><br><span class="line">    <span class="keyword">in</span> &gt;&gt; username_ &gt;&gt; username_;</span><br><span class="line">    <span class="title function_">do_write</span>(<span class="string">&quot;login ok\n&quot;</span>);</span><br><span class="line">    <span class="title function_">update_clients_changed</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_ping</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">do_write</span>(clients_changed_ ? <span class="string">&quot;ping client_list_changed\n&quot;</span> : <span class="string">&quot;ping ok\n&quot;</span>);</span><br><span class="line">    clients_changed_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_clients</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> msg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="attr">array</span>::const_iterator b =clients.<span class="title function_">begin</span>(),e =clients.<span class="title function_">end</span>(); b != e; ++b)</span><br><span class="line">        msg += (*b)-&gt;<span class="title function_">username</span>() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="title function_">do_write</span>(<span class="string">&quot;clients &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是简单易懂的；需要注意的一点是：当一个新客户端登录，我们调用<em>update_clients_changed()</em>，这个方法为所有客户端将<em>clients*changed**标志为</em>true*。</p>
<p>服务端每收到一个请求就用相应的方式进行回复，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">do_ping</span>() &#123; <span class="built_in">do_write</span>(&quot;ping\n&quot;); &#125;</span><br><span class="line">void <span class="built_in">do_ask_clients</span>() &#123; <span class="built_in">do_write</span>(&quot;ask_clients\n&quot;); &#125;</span><br><span class="line">void <span class="built_in">on_write</span>(const error_code &amp; err, size_t bytes) &#123; <span class="built_in">do_read</span>(); &#125;</span><br><span class="line">void <span class="built_in">do_read</span>() &#123;</span><br><span class="line">    <span class="built_in">async_read</span>(sock_, buffer(read_buffer_), <span class="built_in">MEM_FN2</span>(read_complete,_1,_2), <span class="built_in">MEM_FN2</span>(on_read,_1,_2));</span><br><span class="line">    <span class="built_in">post_check_ping</span>();</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">do_write</span>(const std::string &amp; msg) &#123;</span><br><span class="line">    if ( !started() ) return;</span><br><span class="line">    std::<span class="built_in">copy</span>(msg.<span class="built_in">begin</span>(), msg.<span class="built_in">end</span>(), write_buffer_);</span><br><span class="line">    sock_<span class="selector-class">.async_write_some</span>( buffer(write_buffer_, msg.size()), <span class="built_in">MEM_FN2</span>(on_write,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line">size_t <span class="built_in">read_complete</span>(const boost::system::error_code &amp; err, size_t bytes) &#123;</span><br><span class="line">    <span class="comment">// ... 就像之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每个<em>write</em>操作的末尾，*on_write()*方法被调用，这个方法会触发另外一个异步读操作，这样的话“等待请求－回复请求”这个循环就会一直执行，直到客户端断开连接或者超时。</p>
<p>在每次读操作开始之前，我们异步等待5秒钟来观察客户端是否超时。如果超时，我们关闭它的连接：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="function"><span class="title">on_check_ping</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">ptime</span> <span class="variable">now</span> = <span class="variable">microsec_clock</span>::<span class="title">local_time</span>();</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> ( (<span class="variable">now</span> - <span class="variable">last_ping</span>).total_milliseconds() &gt; <span class="number">5000</span>)</span></span><br><span class="line">        <span class="function"><span class="title">stop</span>();</span></span><br><span class="line"><span class="function">    <span class="variable">last_ping</span> = <span class="variable">boost</span>::<span class="variable">posix_time</span>::<span class="variable">microsec_clock</span>::<span class="title">local_time</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="variable">void</span> <span class="title">post_check_ping</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">timer_.expires_from_now</span>(<span class="variable">boost</span>::<span class="variable">posix_time</span>::<span class="title">millisec</span>(<span class="number">5000</span>));</span></span><br><span class="line"><span class="function">    <span class="variable">timer_.async_wait</span>( <span class="title">MEM_FN</span>(<span class="variable">on_check_ping</span>));</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这就是整个服务端的实现。你可以运行并让它工作起来！</p>
<p>在代码中，我向你们展示了这一章我们学到的东西，为了更容易理解，我把代码稍微精简了下；比如，大部分的控制台输出我都没有展示，尽管在这本书附赠的代码中它们是存在的。我建议你自己运行这些例子，因为从头到尾读一次代码能加强你对本章展示应用的理解。</p>
<h3 id="总结-4">总结</h3>
<p>我们已经学到了怎么写一些基础的客户端/服务端应用。我们已经避免了一些诸如内存泄漏和死锁的低级错误。所有的编码都是框架式的，这样你就可以根据你自己的需求对它们进行扩展。</p>
<h2 id="同步VS异步-2">同步VS异步</h2>
<p>Boost.Asio的作者做了一个很惊艳的工作：它可以让你在同步和异步中自由选择，从而更好地适应你的应用。</p>
<p>在之前的章节中，我们已经学习了各种类型应用的框架，比如同步客户端，同步服务端，异步客户端，异步服务端。它们中的每一个都可以作为你应用的基础。如果要更加深入地学习各种类型应用的细节，请继续。</p>
<h3 id="混合同步异步编程">混合同步异步编程</h3>
<p>Boost.Asio库允许你进行同步和异步的混合编程。我个人认为这是一个坏主意，但是Boost.Asio（就像C++一样）在你需要的时候允许你深入底层。</p>
<p>通常来说，当你写一个异步应用时，你会很容易掉入这个陷阱。比如在响应一个异步<em>write</em>操作时，你做了一个同步<em>read</em>操作：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io_service service;</span><br><span class="line">ip::tcp::socket <span class="built_in">sock</span>(service);</span><br><span class="line">ip::tcp::endpoint <span class="built_in">ep</span>( ip::address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8001</span>);</span><br><span class="line">void <span class="built_in">on_write</span>(boost::system::error_code err, size_t bytes) &#123;</span><br><span class="line">    char read_buff<span class="selector-attr">[512]</span>;</span><br><span class="line">    <span class="built_in">read</span>(sock, buffer(read_buff));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">async_write</span>(sock, buffer(&quot;echo&quot;), on_write);</span><br></pre></td></tr></table></figure>
<p>毫无疑问，同步<em>read</em>操作会阻塞当前的线程，从而导致其他任何正在等待的异步操作变成挂起状态（对这个线程）。这是一段糟糕的代码，因为它会导致整个应用变得无响应或者整个被阻塞掉（所有异步运行的端点都必须避免阻塞，而执行一个同步的操作违反了这个原则）。</p>
<p>当你写一个同步应用时，你不大可能执行异步的<em>read</em>或者<em>write</em>操作，因为同步地思考已经意味着用一种线性的方式思考（执行A，然后执行B，再执行C，等等）。</p>
<p>我唯一能想到的同步和异步同时工作的场景就是同步操作和异步操作是完全隔离的，比如，同步和异步从一个数据库进行读写。</p>
<h3 id="从客户端传递信息到服务端VS从服务端传递信息到客户端">从客户端传递信息到服务端VS从服务端传递信息到客户端</h3>
<p>成功的客户端/服务端应用一个很重要的部分就是来回传递消息（服务端到客户端和客户端到服务端）。你需要指定用什么来标记一个消息。换句话说，当读取一个输入的消息时，你怎么判断它被完整读取了？</p>
<p>标记消息结尾的方式完全取决于你（标记消息的开始很简单，因为它就是前一个消息之后传递过来的第一个字节），但是要保证消息是简单且连续的。</p>
<p>你可以：</p>
<ul>
<li>消息大小固定（这不是一个很好的主意，如果我们需要发送更多的数据怎么办？）</li>
<li>通过一个特殊的字符标记消息的结尾，比如’\n’或者’\0’</li>
<li>在消息的头部指定消息的大小</li>
</ul>
<p>我在整本书中间采用的方式都是“使用’\n’标记消息的结尾”。所以，每次读取一条消息都会如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buff_[<span class="number">512</span>];</span><br><span class="line"><span class="comment">// 同步读取</span></span><br><span class="line"><span class="built_in">read</span>(sock_, <span class="built_in">buffer</span>(buff_), boost::<span class="built_in">bind</span>(&amp;read_complete, <span class="keyword">this</span>, _1, _2));</span><br><span class="line"><span class="comment">// 异步读取</span></span><br><span class="line"><span class="built_in">async_read</span>(sock_, <span class="built_in">buffer</span>(buff_),<span class="built_in">MEM_FN2</span>(read_complete,_1,_2), <span class="built_in">MEM_FN2</span>(on_read,_1,_2));</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">read_complete</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    already_read_ = bytes;</span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">find</span>(buff_, buff_ + bytes, <span class="string">&#x27;\n&#x27;</span>) &lt; buff_ + bytes;</span><br><span class="line">    <span class="comment">// 一个一个读，直到读到回车，无缓存</span></span><br><span class="line">    <span class="keyword">return</span> found ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把在消息头部指定消息长度这种方式作为一个练习留给读者；这非常简单。</p>
<h3 id="客户端应用中的同步I-O">客户端应用中的同步I/O</h3>
<p>同步客户端一般都能归类到如下两种情况中的一种：</p>
<ul>
<li>它向服务端请求一些东西，读取结果，然后处理它们。然后请求一些其他的东西，然后一直持续下去。事实上，这很像之前章节里说到的同步客户端。</li>
<li>从服务端读取消息，处理它，然后写回结果。然后读取另外一条消息，然后一直持续下去。</li>
</ul>
<p>两种情况都使用“发送请求－读取结果”的策略。换句话说，一个部分发送一个请求到另外一个部分然后另外一个部分返回结果。这是实现客户端/服务端应用非常简单的一种方式，同时这也是我非常推荐的一种方式。</p>
<p>你可以创建一个<em>Mambo Jambo</em>类型的客户端服务端应用，你可以随心所欲地写它们中间的任何一个部分，但是这会导致一场灾难。（你怎么知道当客户端或者服务端阻塞的时候会发生什么？）。</p>
<p>上面的情况看上去会比较相似，但是它们非常不同：</p>
<ul>
<li>前者，服务端响应请求（服务端等待来自客户端的请求然后回应）。这是一个请求式连接，客户端从服务端拉取它需要的东西。</li>
<li>后者，服务端发送事件到客户端然后由客户端响应。这是一个推式连接，服务端推送通知/事件到客户端。</li>
</ul>
<p>你大部分时间都在做请求式客户端/服务端应用，这也是比较简单，同时也是比较常见的。</p>
<p>你可以把拉取请求（客户端到服务端）和推送请求（服务端到客户端）结合起来，但是，这是非常复杂的，所以你最好避免这种情况 。把这两种方式结合的问题在于：如果你使用“发送请求－读取结果”策略。就会发生下面一系列事情：</p>
<ul>
<li>客户端写入（发送请求）</li>
<li>服务端写入（发送通知到客户端）</li>
<li>客户端读取服务端写入的内容，然后将其作为请求的结果进行解析</li>
<li>服务端阻塞以等待客户端的返回的结果，这会在客户端发送新请求的时候发生</li>
<li>服务端把发送过来的请求当作它等待的结果进行解析</li>
<li>客户端会阻塞（服务端不会返回任何结果，因为它把客户端的请求当作它通知返回的结果）</li>
</ul>
<p>在一个请求式客户端/服务端应用中，避免上面的情况是非常简单的。你可以通过实现一个ping操作的方式来模拟一个推送式请求，我们假设每5秒钟客户端ping一次服务端。如果没有事情需要通知，服务端返回一个类似<em>ping ok</em>的结果，如果有事情需要通知，服务端返回一个<em>ping [event_name]</em>。然后客户端就可以初始化一个新的请求去处理这个事件。</p>
<p>复习一下，第一种情况就是之前章节中的同步客户端应用，它的主循环如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">loop</span>() &#123;</span><br><span class="line">    <span class="comment">// 对于我们登录操作的结果</span></span><br><span class="line">    <span class="built_in">write</span>(&quot;login &quot; + username_ + &quot;\n&quot;);</span><br><span class="line">    <span class="built_in">read_answer</span>();</span><br><span class="line">    while ( started_) &#123;</span><br><span class="line">        <span class="built_in">write_request</span>();</span><br><span class="line">        <span class="built_in">read_answer</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对其进行修改以适应第二种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( started_) &#123;</span><br><span class="line">        <span class="title function_">read_notification</span>();</span><br><span class="line">        <span class="title function_">write_answer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read_notification</span>(<span class="params"></span>) &#123;</span><br><span class="line">    already_read_ = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">read</span>(sock_, <span class="title function_">buffer</span>(buff_), <span class="attr">boost</span>::<span class="title function_">bind</span>(&amp;<span class="attr">talk_to_svr</span>::read_complete, <span class="variable language_">this</span>, _1, _2));</span><br><span class="line">    <span class="title function_">process_notification</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process_notification</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ... 看通知是什么，然后准备回复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端应用中的同步I-O">服务端应用中的同步I/O</h3>
<p>类似客户端，服务端也被分为两种情况用来匹配之前章节中的情况1和情况2。同样，两种情况都采用“发送请求－读取结果”的策略。</p>
<p>第一种情况是我们在之前章节实现过的同步服务端。当你是同步时读取一个完整的请求不是很简单，因为你需要避免阻塞（通常来说是能读多少就读多少）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_request</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sock_.available())</span><br><span class="line">&#125;</span><br><span class="line">already_read_ += sock_.read_some(buffer(buff_ + already_read_, max_msg - already_read_));</span><br></pre></td></tr></table></figure>
<p>只要一个消息被完整读到，就对它进行处理然后回复给客户端：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> process_request() &#123;</span><br><span class="line">    bool found_enter = std<span class="type">::find</span>(buff_, buff_ + already_read_, <span class="string">&#x27;\n&#x27;</span>) &lt; buff_ + already_read_;</span><br><span class="line">    <span class="keyword">if</span> ( !found_enter)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 消息不完整</span></span><br><span class="line">    size_t pos = std<span class="type">::find</span>(buff_, buff_ + already_read_, <span class="string">&#x27;\n&#x27;</span>) - buff_;</span><br><span class="line">    std<span class="type">::string</span> msg(buff_, pos);</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    <span class="keyword">if</span> ( msg.find(<span class="string">&quot;login &quot;</span>) == <span class="number">0</span>) on_login(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.find(<span class="string">&quot;ping&quot;</span>) == <span class="number">0</span>) on_ping();</span><br><span class="line">    <span class="keyword">else</span> <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想让服务端变成一个推送服务端，我们通过如下的方式修改：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef std::vector&lt;client_ptr&gt; array;<span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>clients;<span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>notify;</span><br><span class="line">std::string notify_msg;</span><br><span class="line">void on_new_client() &#123;</span><br><span class="line">    // 新客户端连接时，我们通知所有客户端这个事件</span><br><span class="line">    notify = clients;</span><br><span class="line">    std::ostringstream msg;</span><br><span class="line">    msg &lt;&lt; <span class="string">&quot;client count &quot;</span> &lt;&lt; clients.size();</span><br><span class="line">    notify_msg = msg.str();</span><br><span class="line">    notify_clients();</span><br><span class="line">&#125;</span><br><span class="line">void notify_clients() &#123;</span><br><span class="line">    for ( array::const_iterator b = notify.begin(), e = notify.end(); b != e; ++b) &#123;</span><br><span class="line">        (*b)-&gt;sock_.write_some(notify_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*on_new_client()*方法是事件之一，这个事件我们需要通知所有的客户端。<em>notify_clients</em>是通知所有对一个事件感兴趣客户端的方法。它发送消息但是不等待每个客户端返回的结果，因为那样的话就会导致阻塞。当客户端返回一个结果时，客户端会告诉我们它为什么回复（然后我们就可以正确地处理它）。</p>
<h4 id="同步服务端中的线程">同步服务端中的线程</h4>
<p>这是一个非常重要的关注点：我们开辟多少线程去处理服务端请求？ 对于一个同步服务端，我们至少需要一个处理新连接的线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(service, ip::tcp::endpoint(ip::tcp::v4(),<span class="number">8001</span>))</span></span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">client_ptr <span class="title">new_</span><span class="params">( <span class="keyword">new</span> talk_to_client)</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(new_-&gt;<span class="built_in">sock</span>());</span><br><span class="line">        boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs)</span></span>;</span><br><span class="line">        clients.<span class="built_in">push_back</span>(new_);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于已经存在的客户端：</p>
<ul>
<li>我们可以是单线程。这是最简单的，同时也是我在<strong>第四章 同步服务端</strong>中采用的实现方式。它可以很轻松地处理100-200并发的客户端而且有时候会更多，对于大多数情况来说这已经足够用了。</li>
<li>我们可以对每个客户端开一个线程。这不是一个很好的选择；他会浪费很多线程而且有时候会导致调试困难，而且当它需要处理200以上并发的客户端的时候，它可能马上会到达它的瓶颈。</li>
<li>我们可以用一些固定数量的线程去处理已经存在的客户端</li>
</ul>
<p>第三种选择是同步服务端中最难实现的；整个<em>talk_to_client</em>类需要是线程安全的。然后，你需要一个机制来确定哪个线程处理哪个客户端。对于这个问题，你有两个选择：</p>
<ul>
<li>将特定的客户端分配给特定的线程；比如，线程1处理前面20个客户端，线程2处理21到40个线程，等等。当一个线程在使用时（我们在等待被客户端阻塞的一些东西），我们从已存在客户端列表中将其取出来。等我们处理完之后，再把它放回到列表中。每个线程都会循环遍历已经存在的客户端列表，然后把拥有完整请求的第一个客户端提出来（我们已经从客户端读取了一条完整的消息），然后回复它。</li>
<li>服务端可能会变得无响应
<ul>
<li>第一种情况，被同一个线程处理的几个客户端同时发送请求，因为一个线程在同一时刻只能处理一个请求。所以这种情况我们什么也不能做。</li>
<li>第二种情况，如果我们发现并发请求大于当前线程个数的时候。我们可以简单地创建新线程来处理当前的压力。</li>
</ul>
</li>
</ul>
<p>下面的代码片段有点类似之前的<em>answer_to_client</em>方法，它向我们展示了第二种方法的实现方式：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct talk_to_client : boost::enable_shared_from_this&lt;talk_to_client&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    void <span class="built_in">answer_to_client</span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">read_request</span>();</span><br><span class="line">            <span class="built_in">process_request</span>();</span><br><span class="line">        &#125; catch ( boost::system::system_error&amp;) &#123; <span class="built_in">stop</span>(); &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要对它进行修改使它变成下面代码片段的样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">talk_to_client</span> : boost::enable_shared_from_this&lt;talk_to_client&gt;</span><br><span class="line">&#123;</span><br><span class="line">    boost::recursive_mutex cs;</span><br><span class="line">    boost::recursive_mutex cs_ask;</span><br><span class="line">    <span class="type">bool</span> in_process;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">answer_to_client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_ask)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ( in_process)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            in_process = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs)</span></span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">read_request</span>();</span><br><span class="line">                <span class="built_in">process_request</span>();</span><br><span class="line">            &#125;<span class="built_in">catch</span> ( boost::system::system_error&amp;) &#123;</span><br><span class="line">                <span class="built_in">stop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_ask)</span></span>;</span><br><span class="line">            in_process = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们在处理一个客户端请求的时候，它的<em>in_process</em>变量被设置成<em>true</em>，其他的线程就会忽略这个客户端。额外的福利就是*handle_clients_thread()<em>方法不需要做任何修改；你可以随心所欲地创建你想要数量的</em>handle_clients_thread()*方法。</p>
<h3 id="客户端应用中的异步I-O">客户端应用中的异步I/O</h3>
<p>主流程和同步客户端应用有点类似，不同的是Boost.Asio每次都位于async_read和async_write请求中间。</p>
<p>第一种情况是我在<strong>第四章 客户端和服务端</strong> 中实现过的。你应该还记得在每个异步操作结束的时候，我都启动另外一个异步操作，这样*service.run()*方法才不会结束。</p>
<p>为了适应第二种情况，你需要使用下面的代码片段：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">on_connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">do_read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">do_read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">async_read</span>(sock_, <span class="title function_">buffer</span>(read_buffer_), <span class="title function_">MEM_FN2</span>(read_complete,_1,_2), <span class="title function_">MEM_FN2</span>(on_read,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_read</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( err) <span class="title function_">stop</span>();</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="title function_">started</span>() ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">msg</span>(read_buffer_, bytes);</span><br><span class="line">    <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;clients&quot;</span>) == <span class="number">0</span>) <span class="title function_">on_clients</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_clients</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> clients = msg.<span class="title function_">substr</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="attr">std</span>::cout &lt;&lt; username_ &lt;&lt; <span class="string">&quot;, new client list:&quot;</span> &lt;&lt; clients ;</span><br><span class="line">    <span class="title function_">do_write</span>(<span class="string">&quot;clients ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意只要我们成功连接上，我们就开始从服务端读取。每个*on_[event]*方法都会通过写一个回复给服务端的方式来结束我们。</p>
<p>使用异步的美好在于你可以使用Boost.Asio进行管理，从而把I/O网络操作和其他异步操作结合起来。尽管它的流程不像同步的流程那么清晰，你仍然可以用同步的方式来想象它。</p>
<p>假设，你从一个web服务器读取文件然后把它们保存到一个数据库中（异步地）。你可以把这个过程想象成下面的流程图：</p>
<h3 id="服务端应用的异步I-O">服务端应用的异步I/O</h3>
<p>现在要展示的是两个普遍的情况，情况1（拉取）和情况2（推送）</p>
<p>第一种情况同样是我在<strong>第4章 客户端和服务端</strong> 中实现的异步服务端。在每一个异步操作最后，我都会启动另外一个异步操作，这样的话service.run()就不会结束。 现在要展示的是被剪裁过的框架代码。下面是talk_to_client类所有的成员：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_">do_read</span>(); <span class="comment">// first, we wait for client to login</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_read</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">msg</span>(read_buffer_, bytes);</span><br><span class="line">    <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;login &quot;</span>) == <span class="number">0</span>) <span class="title function_">on_login</span>(msg);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( msg.<span class="title function_">find</span>(<span class="string">&quot;ping&quot;</span>) == <span class="number">0</span>) <span class="title function_">on_ping</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_login</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::istringstream <span class="title function_">in</span>(msg);</span><br><span class="line">    <span class="keyword">in</span> &gt;&gt; username_ &gt;&gt; username_;</span><br><span class="line">    <span class="title function_">do_write</span>(<span class="string">&quot;login ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">do_write</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="title function_">copy</span>(msg.<span class="title function_">begin</span>(), msg.<span class="title function_">end</span>(), write_buffer_);</span><br><span class="line">    sock_.<span class="title function_">async_write_some</span>( <span class="title function_">buffer</span>(write_buffer_, msg.<span class="title function_">size</span>()), <span class="title function_">MEM_FN2</span>(on_write,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_write</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123; <span class="title function_">do_read</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，我们始终等待一个<em>read</em>操作，而且只要一发生，我们就处理然后将结果返回给客户端。</p>
<p>我们把上述代码进行修改就可以完成一个推送服务端</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_">on_new_client_event</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_new_client_event</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::ostringstream msg;</span><br><span class="line">    msg &lt;&lt; <span class="string">&quot;client count &quot;</span> &lt;&lt; clients.<span class="title function_">size</span>();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="attr">array</span>::const_iterator b = clients.<span class="title function_">begin</span>(), e = clients.<span class="title function_">end</span>(); (*b)-&gt;<span class="title function_">do_write</span>(msg.<span class="title function_">str</span>());</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_read</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">msg</span>(read_buffer_, bytes);</span><br><span class="line">    <span class="comment">// 在这里我们基本上只知道我们的客户端接收到我们的通知</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">do_write</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span> &amp; msg</span>) &#123;</span><br><span class="line">    <span class="attr">std</span>::<span class="title function_">copy</span>(msg.<span class="title function_">begin</span>(), msg.<span class="title function_">end</span>(), write_buffer_);</span><br><span class="line">    sock_.<span class="title function_">async_write_some</span>( <span class="title function_">buffer</span>(write_buffer_, msg.<span class="title function_">size</span>()), <span class="title function_">MEM_FN2</span>(on_write,_1,_2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">on_write</span>(<span class="params"><span class="keyword">const</span> error_code &amp; err, size_t bytes</span>) &#123; <span class="title function_">do_read</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>只要有一个事件发生，我们假设<em>是on_new_client_event</em>，所有需要被通知到的客户端就都收到一条信息。当它们回复时，我们简单认为他们已经确认收到事件。注意我们永远不会把正在等待的异步操作用尽（所以，*service.run()*不会结束），因为我们一直在等待一个新的客户端：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip::tcp::acceptor <span class="title function_ invoke__">acc</span>(service, ip::tcp::<span class="title function_ invoke__">endpoint</span>(ip::tcp::<span class="title function_ invoke__">v4</span>(), <span class="number">8001</span>));</span><br><span class="line">void <span class="title function_ invoke__">handle_accept</span>(talk_to_client::ptr client, <span class="keyword">const</span> error_code &amp; err)</span><br><span class="line">&#123;</span><br><span class="line">    client<span class="punctuation">-&gt;</span><span class="title function_ invoke__">start</span>();</span><br><span class="line">    talk_to_client::ptr new_client = talk_to_client::<span class="title function_ invoke__">new_</span>();</span><br><span class="line">    acc.<span class="title function_ invoke__">async_accept</span>(new_client<span class="punctuation">-&gt;</span><span class="title function_ invoke__">sock</span>(), <span class="title function_ invoke__">bind</span>(handle_accept,new_client,_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步服务端中的多线程">异步服务端中的多线程</h4>
<p>我在<strong>第4章 客户端和服务端</strong> 展示的异步服务端是单线程的，所有的事情都发生在main()中：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    talk_to_client::ptr client = talk_to_client::<span class="built_in">new_</span>();</span><br><span class="line">    acc<span class="selector-class">.async_accept</span>(client-&gt;sock(), boost::<span class="built_in">bind</span>(handle_</span><br><span class="line">accept,client,_1));</span><br><span class="line">    service<span class="selector-class">.run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的美妙之处就在于可以非常简单地把单线程变为多线程。你可以一直保持单线程直到你的并发客户端超过200。然后，你可以使用如下的代码片段把单线程变成100个线程：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boost::thread_group threads;</span><br><span class="line">void <span class="built_in">listen_thread</span>() &#123;</span><br><span class="line">    service<span class="selector-class">.run</span>();</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">start_listen</span>(int thread_count) &#123;</span><br><span class="line">    for ( int i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">        threads<span class="selector-class">.create_thread</span>( listen_thread);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="selector-tag">main</span>(int argc, char* argv[]) &#123;</span><br><span class="line">    talk_to_client::ptr client = talk_to_client::<span class="built_in">new_</span>();</span><br><span class="line">    acc<span class="selector-class">.async_accept</span>(client-&gt;sock(), boost::<span class="built_in">bind</span>(handle_accept,client,_1));</span><br><span class="line">    <span class="built_in">start_listen</span>(<span class="number">100</span>);</span><br><span class="line">    threads<span class="selector-class">.join_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，一旦你选择了多线程，你需要考虑线程安全。尽管你在线程A中调用了<em>async_**，但是它的完成处理流程可以在线程B中被调用（因为线程B也调用了</em>service.run()<em>）。对于它本身而言这不是问题。只要你遵循逻辑流程，也就是从</em>async_read()<em>到</em>on_read()<em>，从</em>on_read()<em>到p</em>rocess_request*，从<em>process_request</em>到<em>async_write()</em>，从<em>async_write()<em>到</em>on_write()</em>，从<em>on_write()<em>到a</em>sync_read()</em>，然后在你的<em>talk_to_client</em>类中也没有被调用的公有方法，这样的话尽管不同的方法可以在不同的线程中被调用，它们还是会被有序地调用。从而不需要互斥量。</p>
<p>这也意味着对于一个客户端，只会有一个异步操作在等待。假如在某些情况，一个客户端有两个异步方法在等待，你就需要互斥量了。这是因为两个等待的操作可能正好在同一个时间完成，然后我们就会在两个不同的线程中间同时调用他们的完成处理函数。所以，这里需要线程安全，也就是需要使用互斥量。 在我们的异步服务端中，我们确实同时有两个等待的操作：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">do_read</span>() &#123;</span><br><span class="line">    <span class="built_in">async_read</span>(sock_, buffer(read_buffer_),<span class="built_in">MEM_FN2</span>(read_complete,_1,_2), <span class="built_in">MEM_FN2</span>(on_read,_1,_2));</span><br><span class="line">    <span class="built_in">post_check_ping</span>();</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">post_check_ping</span>() &#123;</span><br><span class="line">    timer_<span class="selector-class">.expires_from_now</span>(boost::posix_time::millisec(<span class="number">5000</span>));</span><br><span class="line">    timer_<span class="selector-class">.async_wait</span>( MEM_FN(on_check_ping));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在做一个<em>read</em>操作时，我们会异步等待<em>read</em>操作完成和超时。所以，这里需要线程安全。</p>
<p>我的建议是，如果你准备使用多线程，从开始就保证你的类是线程安全的。通常这不会影响它的性能（当然你也可以在配置中设置开关）。同时，如果你准备使用多线程，从一个开始就使用。这样的话你能尽早地发现可能存在的问题。一旦你发现一个问题，你首先需要检查的事情就是：单线程运行的时候是否会发生？如果是，它很简单；只要调试它就可以了。否则，你可能忘了对一些方法加锁（互斥量）。</p>
<p>因为我们的例子需要是线程安全的，我已经把<em>talk_to_client</em>修改成使用互斥量的了。同时，我们也有一个客户端连接的列表，它也需要自己的互斥量，因为我们有时需要访问它。</p>
<p>避免死锁和内存冲突不是那么容易。下面是我需要对*update_client_changed()*方法进行修改的地方：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void update_clients_changed() &#123;</span><br><span class="line">   <span class="built_in"> array </span>copy;</span><br><span class="line">    &#123; boost::recursive_mutex::scoped_lock lk(clients_cs); copy = clients; &#125;</span><br><span class="line">    for( array::iterator b = copy.begin(), e = copy.end(); b != e; ++b)</span><br><span class="line">        (*b)-&gt;set_clients_changed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你需要避免的是同时有两个互斥量被锁定（这会导致死锁）。在我们的例子中，我们不想<em>clients_cs</em>和一个客户端的*cs_*互斥量同时被锁住</p>
<h3 id="异步操作">异步操作</h3>
<p>Boost.Asio同样允许你异步地运行你任何一个方法。仅仅需要使用下面的代码片段：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span>()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">service.post(my_func);</span><br></pre></td></tr></table></figure>
<p>这样就可以保证<em>my_func</em>在调用了*service.run()*方法的某个线程中间被调用。你同样可以异步地调用一个有完成处理handler的方法，方法的handler会在方法结束的时候通知你。伪代码如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">on_complete</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">my_func</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    service<span class="selector-class">.post</span>(on_complete);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">async_call</span>(my_func);</span><br></pre></td></tr></table></figure>
<p>没有现成的<em>async_call</em>方法，因此，你需要自己创建。幸运的是，它不是很复杂，参考下面的代码片段：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">async_op</span> : boost::enable_shared_from_this&lt;async_op&gt;, ... &#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(boost::system::error_code)&gt;completion_func;</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;boost::system::error_code ()&gt; op_func;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">operation</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ( started_) <span class="keyword">return</span>; started_ = <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="function">boost::thread <span class="title">t</span><span class="params">(boost::bind(&amp;async_op::run,<span class="keyword">this</span>))</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(op_func op, completion_func completion, io_service &amp;service)</span> </span>&#123;</span><br><span class="line">        self_ = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">        ops_.<span class="built_in">push_back</span>( <span class="built_in">operation</span>(service, op, completion));</span><br><span class="line">        <span class="keyword">if</span> ( !started_) <span class="built_in">start</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">        started_ = <span class="literal">false</span>; ops_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::recursive_mutex cs_;</span><br><span class="line">    std::vector&lt;operation&gt; ops_;</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    ptr self_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>async_op</em>方法创建了一个后台线程，这个线程会运行（<em>run()</em>）你添加（<em>add()</em>）到它里面的所有的异步操作。为了让事情简单一些，每个操作都包含下面的内容：</p>
<ul>
<li>一个异步调用的方法</li>
<li>当第一个方法结束时被调用的一个完成处理handler</li>
<li>会运行完成处理handler的io_service实例。这也是完成时通知你的地方。参考下面的代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">async_op</span> : boost::enable_shared_from_this&lt;async_op&gt;, <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">        <span class="built_in">operation</span>(io_service &amp; service, op_func op, completion_func completion) : <span class="built_in">service</span>(&amp;service), <span class="built_in">op</span>(op), <span class="built_in">completion</span>(completion) , <span class="built_in">work</span>(<span class="keyword">new</span> io_service::<span class="built_in">work</span>(service)) &#123;&#125;</span><br><span class="line">        <span class="built_in">operation</span>() : <span class="built_in">service</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        io_service * service;</span><br><span class="line">        op_func op;</span><br><span class="line">        completion_func completion;</span><br><span class="line">        <span class="keyword">typedef</span> boost::shared_ptr&lt;io_service::work&gt; work_ptr;</span><br><span class="line">        work_ptr work;</span><br><span class="line">    &#125;;</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它们被<em>operation</em>结构体包含在内部。注意当有一个操作在等待时，我们在操作的构造方法中构造一个<em>io_service::work</em>实例，从而保证直到我们完成异步调用之前<em>service.run()<em>都不会结束（当</em>io_service::work</em>实例保持活动时，*service.run()*就会认为它有工作需要做）。参考下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">async_op</span> : ... &#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;async_op&gt; ptr;</span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">new_</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(<span class="keyword">new</span> async_op); &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="literal">true</span>) &#123;</span><br><span class="line">            &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">                <span class="keyword">if</span> ( !started_) <span class="keyword">break</span>; &#125;</span><br><span class="line">            boost::this_thread::<span class="built_in">sleep</span>(boost::posix_time::<span class="built_in">millisec</span>(<span class="number">10</span>));</span><br><span class="line">            operation cur;</span><br><span class="line">            &#123; boost::<span class="function">recursive_mutex::scoped_lock <span class="title">lk</span><span class="params">(cs_)</span></span>;</span><br><span class="line">                <span class="keyword">if</span> ( !ops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    cur = ops_[<span class="number">0</span>]; </span><br><span class="line">                    ops_.<span class="built_in">erase</span>(ops_.<span class="built_in">begin</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( cur.service)</span><br><span class="line">                cur.service-&gt;<span class="built_in">post</span>(boost::<span class="built_in">bind</span>(cur.completion, cur.<span class="built_in">op</span>()));        </span><br><span class="line">        &#125;</span><br><span class="line">        self_.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>*run()*方法就是后台线程；它仅仅观察是否有工作需要做，如果有，就一个一个地运行这些异步方法。在每个调用结束的时候，它会调用相关的完成处理方法。</p>
<p>为了测试，我们创建一个会被异步执行的<em>compute_file-checksum</em>方法</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">size_t checksum = <span class="number">0</span>;</span><br><span class="line">boost::system::error_code compute_file_checksum(std::string file_name)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE file = ::CreateFile(file_name.c_str(),GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>,OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="number">0</span>);</span><br><span class="line">    windows::random_access_handle h(service, file);</span><br><span class="line">    <span class="keyword">long</span> buff[<span class="number">1024</span>];</span><br><span class="line">    checksum = <span class="number">0</span>;</span><br><span class="line">    size_t bytes = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="keyword">while</span> ( (bytes = read_at(h, at, buffer(buff), ec)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        at += bytes; bytes /= sizeof(<span class="keyword">long</span>);</span><br><span class="line">        <span class="keyword">for</span> ( size_t i = <span class="number">0</span>; i &lt; bytes; ++i)</span><br><span class="line">            checksum += buff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boost::system::error_code(<span class="number">0</span>,boost::system::generic_category());</span><br><span class="line">&#125;</span><br><span class="line">void on_checksum(std::string file_name, boost::system::error_code) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;checksum for &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; checksum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    std::string <span class="function"><span class="keyword">fn</span> = &quot;<span class="title">readme</span>.<span class="title">txt</span>&quot;</span>;</span><br><span class="line">    async_op::new_()-&gt;add( service, boost::bind(compute_file_checksum,<span class="function"><span class="keyword">fn</span>),<span class="title">boost</span>::<span class="title">bind</span><span class="params">(on_checksum,fn,_1)</span>)</span>;</span><br><span class="line">    service.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我展示给你的只是实现异步调用一个方法的一种可能。除了像我这样实现一个后台线程，你可以使用一个内部<em>io_service</em>实例，然后推送（<em>post()</em>）异步方法给这个实例调用。这个作为一个练习留给读者。</p>
<p>你也可以扩展这个类让其可以展示一个异步操作的进度（比如，使用百分比）。这样做你就可以在主线程通过一个进度条来显示进度。</p>
<h3 id="代理实现">代理实现</h3>
<p>代理一般位于客户端和服务端之间。它接受客户端的请求，可能会对请求进行修改，然后接着把请求发送到服务端。然后从服务端取回结果，可能也会对结果进行修改，然后接着把结果发送到客户端。</p>
<p>代理有什么特别的？我们讲述它的目的在于：对每个连接，你都需要两个sokect，一个给客户端，另外一个给服务端。这些都给实现一个代理增加了不小的难度。</p>
<p>实现一个同步的代理应用比异步的方式更加复杂；数据可能同时从两个端过来（客户端和服务端），也可能同时发往两个端。这也就意味着如果我们选择同步，我们就可能在一端向另一端<em>read()<em>或者</em>write()</em>，同时另一端向这一端*read()<em>或者</em>write()*时阻塞，这也就意味着最终我们会变得无响应。</p>
<p>根据下面几条实现一个异步代理的简单例子：</p>
<ul>
<li>在我们的方案中，我们在构造函数中能拿到两个连接。但不是所有的情况都这样，比如对于一个web代理来说，客户端只告诉我们服务端的地址。</li>
<li>因为比较简单，所以不是线程安全的。参考如下的代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">proxy</span>  : <span class="keyword">public</span> boost::enable_shared_from_this&lt;proxy&gt; &#123;</span><br><span class="line">    <span class="built_in">proxy</span>(ip::tcp::endpoint ep_client, ip::tcp::endpoint ep_server) : ... &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">start</span><span class="params">(ip::tcp::endpoint ep_client,</span></span></span><br><span class="line"><span class="params"><span class="function">ip::tcp::endpoint ep_svr)</span> </span>&#123;</span><br><span class="line">        <span class="function">ptr <span class="title">new_</span><span class="params">(<span class="keyword">new</span> proxy(ep_client, ep_svr))</span></span>;</span><br><span class="line">        <span class="comment">// … 连接到两个端</span></span><br><span class="line">        <span class="keyword">return</span> new_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 关闭两个连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> started_ == <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_connect</span><span class="params">(<span class="type">const</span> error_code &amp; err)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !err)      &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ++started_ == <span class="number">2</span>) <span class="built_in">on_start</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">do_read</span>(client_, buff_client_);</span><br><span class="line">        <span class="built_in">do_read</span>(server_, buff_server_);</span><br><span class="line">    &#125;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket client_, server_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_msg = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> buff_client_[max_msg], buff_server_[max_msg]; </span><br><span class="line">    <span class="type">int</span> started_; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是个非常简单的代理。当我们两个端都连接时，它开始从两个端读取（*on_start()*方法）：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">proxy</span>  : <span class="keyword">public</span> boost::enable_shared_from_this&lt;proxy&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_read</span><span class="params">(ip::tcp::socket &amp; sock, <span class="type">const</span> error_code&amp; err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> * buff = &amp;sock == &amp;client_ ? buff_client_ : buff_server_;</span><br><span class="line">        <span class="built_in">do_write</span>(&amp;sock == &amp;client_ ? server_ : client_, buff, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_write</span><span class="params">(ip::tcp::socket &amp; sock, <span class="type">const</span> error_code &amp;err, <span class="type">size_t</span> bytes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( &amp;sock == &amp;client_) <span class="built_in">do_read</span>(server_, buff_server_);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">do_read</span>(client_, buff_client_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">(ip::tcp::socket &amp; sock, <span class="type">char</span>* buff)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">async_read</span>(sock, <span class="built_in">buffer</span>(buff, max_msg), <span class="built_in">MEM_FN3</span>(read_complete,<span class="built_in">ref</span>(sock),_1,_2), <span class="built_in">MEM_FN3</span>(on_read,<span class="built_in">ref</span>(sock),_1,_2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_write</span><span class="params">(ip::tcp::socket &amp; sock, <span class="type">char</span> * buff, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        sock.<span class="built_in">async_write_some</span>(<span class="built_in">buffer</span>(buff,size), <span class="built_in">MEM_FN3</span>(on_write,<span class="built_in">ref</span>(sock),_1,_2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">read_complete</span><span class="params">(ip::tcp::socket &amp; sock, <span class="type">const</span> error_code &amp; err, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( sock.<span class="built_in">available</span>() &gt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        sock.<span class="built_in">available</span>();</span><br><span class="line">        <span class="keyword">return</span> bytes &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对每一个成功的读取操作（<em>on_read</em>），它都会发送消息到另外一个部分。只要消息一发送成功（<em>on_write</em>），我们就从来源那部分再次读取。</p>
<p>使用下面的代码片段让这个流程运转起来：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    ip::tcp::endpoint ep_c(ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">8001</span>);</span><br><span class="line">    ip::tcp::endpoint ep_s(ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">8002</span>);</span><br><span class="line">    proxy::start(ep_c, ep_s);</span><br><span class="line">    service.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会注意到我在读和写中重用了buffer。这个重用是ok的，因为从客户端读取到的消息在新消息被读取之前就已经写入到服务端，反之亦然。这也意味着这种特别的实现方式会碰到响应性的问题。当我们正在处理到B部分的写入时，我们不会从A读取（我们会在写入到B部分完成时重新从A部分读取）。你可以通过下面的方式重写实现来克服这个问题：</p>
<ul>
<li>使用多个读取buffer</li>
<li>对每个成功的<em>read</em>操作，除了异步写回到另外一个部分，还需要做额外的一个<em>read</em>（读取到一个新的buffer）</li>
<li>对每个成功的<em>write</em>操作，销毁（或者重用）这个buffer</li>
</ul>
<p>我会把这个当作练习留给你们。</p>
<h3 id="小结">小结</h3>
<p>在选择同步或者异步时需要考虑很多事情。最先需要考虑的就是避免混淆它们。</p>
<p>在这一章中，我们已经看到：</p>
<ul>
<li>实现，测试，调试各个类型的应用是多么简单</li>
<li>线程是如何影响你的应用的</li>
<li>应用的行为是怎么影响它的实现的（拉取或者推送类型）</li>
<li>选择异步时怎样去嵌入自己的异步操作</li>
</ul>
<h2 id="Boost-Asio－其他特性">Boost.Asio－其他特性</h2>
<p>这章我们讲了解一些Boost.Asio不那么为人所知的特性。标准的stream和streambuf对象有时候会更难用一些，但正如你所见，它们也有它们的益处。最后，你会看到姗姗来迟的Boost.Asio协程的入口，它可以让你的异步代码变得非常易读。这是非常惊人的一个特性。</p>
<h3 id="标准stream和标准I-O-buffer">标准stream和标准I/O buffer</h3>
<p>读这一章节之前你需要对STL stream和STL streambuf对象有所了解。</p>
<p>Boost.Asio在处理I/O操作时支持两种类型的buffer：</p>
<ul>
<li><em>boost::asio::buffer()</em>：这种buffer关联着一个Boost.Asio的操作（我们使用的buffer被传递给一个Boost.Asio的操作）</li>
<li><em>boost::asio::streambuf</em>：这个buffer继承自<em>std::streambuf</em>，在网络编程中可以和STL stream一起使用</li>
</ul>
<p>纵观全书，之前的例子中最常见的例子如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t <span class="built_in">read_complete</span>(boost::system::error_code, size_t bytes)&#123; ... &#125;</span><br><span class="line">char buff<span class="selector-attr">[1024]</span>;</span><br><span class="line"><span class="built_in">read</span>(sock, buffer(buff), read_complete);</span><br><span class="line"><span class="built_in">write</span>(sock, buffer(&quot;echo\n&quot;));</span><br></pre></td></tr></table></figure>
<p>通常来说使用这个就能满足你的需要，如果你想要更复杂，你可以使用<em>streambuf</em>来实现。</p>
<p>这个就是你可以用<em>streambuf</em>对象做的最简单也是最坏的事情：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf;</span><br><span class="line"><span class="built_in">read</span>(sock, buf);</span><br></pre></td></tr></table></figure>
<p>这个会一直读到<em>streambuf</em>对象满了，然后因为<em>streambuf</em>对象可以通过自己重新开辟空间从而获取更多的空间，它基本会读到连接被关闭。</p>
<p>你可以使用<em>read_until</em>一直读到一个特定的字符串：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">streambuf <span class="keyword">buf;</span></span><br><span class="line"><span class="keyword"></span>read_until(sock, <span class="keyword">buf, </span><span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子会一直读到一个“\n”为止，把它添加到<em>buffer</em>的末尾，然后退出<em>read</em>方法。</p>
<p>向一个<em>streambuf</em>对象写一些东西，你需要做一些类似下面的事情：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf<span class="comment">;</span></span><br><span class="line"><span class="symbol">std:</span>:ostream <span class="keyword">out</span>(&amp;buf)<span class="comment">;</span></span><br><span class="line"><span class="keyword">out</span> &lt;&lt; <span class="string">&quot;echo&quot;</span> &lt;&lt; <span class="keyword">std</span>::endl<span class="comment">;</span></span><br><span class="line">write(sock, buf)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这是非常直观的；你在构造函数中传递你的<em>streambuf</em>对象来构建一个STL stream，将其写入到你想要发送的消息中，然后使用<em>write</em>来发送buffer的内容。</p>
<h3 id="Boost-Asio和STL-stream">Boost.Asio和STL stream</h3>
<p>Boost.Asio在集成STL stream和网络方面做了很棒的工作。也就是说，如果你已经在使用STL扩展，你肯定就已经拥有了大量重载了操作符&lt;&lt;和&gt;&gt;的类。从socket读或者写入它们就好像在公园漫步一样简单。</p>
<p>假设你有下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> &#123;</span><br><span class="line">    std::string first_name, last_name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; out, <span class="type">const</span> person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; p.first_name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.last_name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age;</span><br><span class="line">&#125;</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream &amp; in, person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">return</span> in &gt;&gt; p.first_name &gt;&gt; p.last_name &gt;&gt; p.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过网络发送这个<em>person</em>就像下面的代码片段这么简单：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf;</span><br><span class="line">std::ostream <span class="built_in">out</span>(&amp;buf);</span><br><span class="line">person <span class="selector-tag">p</span>;</span><br><span class="line">// … 初始化<span class="selector-tag">p</span></span><br><span class="line">out &lt;&lt; <span class="selector-tag">p</span> &lt;&lt; std::endl;</span><br><span class="line">write(sock, buf);</span><br></pre></td></tr></table></figure>
<p>另外一个部分也可以非常简单的读取：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_until(sock, buf, &quot;\n&quot;);</span><br><span class="line">std::istream <span class="built_in">in</span>(&amp;buf);</span><br><span class="line">person <span class="selector-tag">p</span>;</span><br><span class="line">in &gt;&gt; <span class="selector-tag">p</span>;</span><br></pre></td></tr></table></figure>
<p>使用<em>streambuf</em>对象（当然，也包括它用来写入的<em>std::ostream</em>和用来读取的<em>std::istream</em>）时最棒的部分就是你最终的编码会很自然：</p>
<ul>
<li>当通过网络写入一些要发送的东西时，很有可能你会有多个片段的数据。所以，你需要把数据添加到一个buffer里面。如果那个数据不是一个字符串，你需要先把它转换成一个字符串。当使用&lt;&lt;操作符时这些操作默认都已经做了。</li>
<li>同样，在另外一个部分，当读取一个消息时，你需要解析它，也就是说，读取到一个片段的数据时，如果这个数据不是字符串，你需要将它转换为字符串。当你使用&gt;&gt;操作符读取一些东西时这些也是默认就做了的。</li>
</ul>
<p>最后要给出的是一个非常著名，非常酷的诀窍，使用下面的代码片段把<em>streambuf</em>的内容输出到console中</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf;</span><br><span class="line"><span class="params">...</span></span><br><span class="line">std<span class="type">::cout</span> &lt;&lt; &amp;buf &lt;&lt; std<span class="type">::endl</span>; <span class="comment">//把所有内容输出到console中</span></span><br></pre></td></tr></table></figure>
<p>同样的，使用下面的代码片段来把它的内容转换为一个<em>string</em></p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string to_string(streambuf <span class="variable">&amp;buf</span>) &#123;</span><br><span class="line">    std::ostringstream <span class="keyword">out</span>;</span><br><span class="line">    <span class="keyword">out</span> &lt;&lt; <span class="variable">&amp;buf</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">out</span>.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="streambuf类">streambuf类</h3>
<p>我之前说过，<em>streambuf</em>继承自<em>std::streambuf</em>。就像<em>std::streambuf</em>本身，它不能拷贝构造。</p>
<p>另外，它有一些额外的方法，如下：</p>
<ul>
<li><em>streambuf([max_size,][allocator])</em>：这个方法构造了一个<em>streambuf</em>对象。你可以选择指定一个最大的buffer大小和一个分配器，分配器用来在需要的时候分配/释放内存。</li>
<li><em>prepare(n)</em>：这个方法返回一个子buffer，用来容纳连续的n个字符。它可以用来读取或者写入。方法返回的结果可以在任何Boost.Asio处理<em>read/write</em>的自由函数中使用，而不仅仅是那些用来处理<em>streambuf</em>对象的方法。</li>
<li><em>data()</em>：这个方法以连续的字符串形式返回整个buffer然后用来写入。方法返回的结果可以在任何Boost.Asio处理写入的自由函数中使用，而不仅仅是那些用来处理streambuf对象的方法。</li>
<li><em>comsume(n)</em>：在这个方法中，数据从输入队列中被移除（从read操作）</li>
<li><em>commit(n)</em>：在这个方法中，数据从输出队列中被移除(从write操作)然后加入到输入队列中（为read操作准备）。</li>
<li><em>size()</em>：这个方法以字节为单位返回整个streambuf对象的大小。</li>
<li><em>max_size()</em>：这个方法返回最多能保存的字节数。</li>
</ul>
<p>除了最后的两个方法，其他的方法不是那么容易理解。首先，大部分时间你会把<em>streambuf</em>以参数的方式传递给<em>read/write</em>自由函数，就像下面的代码片段展示的一样：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_until</span>(sock, buf, &quot;\n&quot;); <span class="comment">// 读取到buf中</span></span><br><span class="line"><span class="built_in">write</span>(sock, buf); <span class="comment">// 从buf写入</span></span><br></pre></td></tr></table></figure>
<p>如果你想之前的代码片段展示的一样把整个buffer都传递到一个自由函数中，方法会保证把buffer的输入输出指针指向的位置进行增加。也就是说，如果有数据需要读，你就能读到它。比如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_until</span>(sock, buf, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; &amp;buf &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>上述代码会把你刚从socket写入的东西输出。而下面的代码不会输出任何东西：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(sock, buf.prepare(<span class="number">16</span>), <span class="built_in">transfer_exactly</span>(<span class="number">16</span>) );</span><br><span class="line">std::cout &lt;&lt; &amp;buf &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>字节被读取了，但是输入指针没有移动，你需要自己移动它，就像下面的代码片段所展示的：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(sock, buf.prepare(<span class="number">16</span>), <span class="built_in">transfer_exactly</span>(<span class="number">16</span>) );</span><br><span class="line">buf<span class="selector-class">.commit</span>(<span class="number">16</span>);</span><br><span class="line">std::cout &lt;&lt; &amp;buf &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>同样的，假设你需要从<em>streambuf</em>对象中写入，如果你使用了<em>write</em>自由函数，则需要像下面一样：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf<span class="comment">;</span></span><br><span class="line"><span class="symbol">std:</span>:ostream <span class="keyword">out</span>(&amp;buf)<span class="comment">;</span></span><br><span class="line"><span class="keyword">out</span> &lt;&lt; <span class="string">&quot;hi there&quot;</span> &lt;&lt; <span class="keyword">std</span>::endl<span class="comment">;</span></span><br><span class="line">write(sock, buf)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>下面的代码会把hi there发送三次：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf<span class="comment">;</span></span><br><span class="line"><span class="symbol">std:</span>:ostream <span class="keyword">out</span>(&amp;buf)<span class="comment">;</span></span><br><span class="line"><span class="keyword">out</span> &lt;&lt; <span class="string">&quot;hi there&quot;</span> &lt;&lt; <span class="keyword">std</span>::endl<span class="comment">;</span></span><br><span class="line">for ( int i = <span class="number">0</span><span class="comment">; i &lt; 3; ++i)</span></span><br><span class="line">    write(sock, buf.data())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>发生的原因是因为buffer从来没有被消耗过，因为数据还在。如果你想消耗它，使用下面的代码片段：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf<span class="comment">;</span></span><br><span class="line"><span class="symbol">std:</span>:ostream <span class="keyword">out</span>(&amp;buf)<span class="comment">;</span></span><br><span class="line"><span class="keyword">out</span> &lt;&lt; <span class="string">&quot;hi there&quot;</span> &lt;&lt; <span class="keyword">std</span>::endl<span class="comment">;</span></span><br><span class="line">write(sock, buf.data())<span class="comment">;</span></span><br><span class="line">buf.consume(<span class="number">9</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>总的来说，你最好选择一次处理整个<em>streambuf</em>实例。如果需要调整则使用上述的方法。</p>
<p>尽管你可以在读和写操作时使用同一个<em>streambuf</em>，你仍然建议你分开使用两个，一个读另外一个写，它会让事情变的简单，清晰，同时你也会减少很多导致bug的可能。</p>
<h3 id="处理streambuf对象的自由函数">处理streambuf对象的自由函数</h3>
<p>下面列出了Boost.Asio中处理streambuf对象的自由函数：</p>
<ul>
<li><em>read(sock, buf[, completion_function])</em>：这个方法把内容从socket读取到<em>streambuf</em>对象中。<em>completion</em>方法是可选的。如果有，它会在每次<em>read</em>操作成功之后被调用，然后告诉Boost.Asio这个操作是否完成（如果没有，它继续读取）。它的格式是：<em>size_t completion(const boost::system::error_code &amp; err, size_t bytes_transfered);</em>，如果<em>completion</em>方法返回0，我们认为<em>read</em>操作完成了，如果非0，它表示下一次调用stream的<em>read_some</em>方法需要读取的最大的字节数。</li>
<li><em>read_at(random_stream, offset, buf [, completion_function])</em>: 这个方法从一个支持随机读取的stream中读取。注意它没有被应用到socket中（因为他们没有随机读取的模型，它们是单向的，一直向前）。</li>
<li><em>read_until(sock, buf, char | string | regex | match_condition)</em>: 这个方法一直读到满足一个特性的条件为止。或者是一个char类型的数据被读到，或者是一个字符串被读到，或者是一个目前读到的字符串能匹配的正则表达式，或者<em>match_condition</em>方法告诉我们需要结束这个方法。<em>match_condition</em>方法的格式是：<em>pair match(iterator begin, iterator end);</em> ，<em>iterator</em>代表 <em>buffers_ iterator</em>。如果匹配到，你需要返回一个<em>pair</em>（<em>passed_end_of_match</em>被设置成true）。如果没有匹配到，你需要返回<em>pair</em>（begin被设置为false）。</li>
<li><em>write(sock, buf [, completion_function])</em>: 这个方法写入<em>streambuf</em>对象所有的内容。<em>completion</em>方法是可选的，它的表现和<em>read()<em>的</em>completion</em>方法类似：当write操作完成时返回0，或者返回一个非0数代表下一次调用stream的<em>write_some</em>方法需要写入的最大的字节数。</li>
<li><em>write_at(random_stream,offset, buf [, completion_function])</em>: 这个方法用来向一个支持随机存储的stream写入。同样，它没有被应用到socket中。</li>
<li><em>async_read(sock, buf [, competion_function], handler)</em>: 这个方法是*read()*的异步实现，handler的格式为：<em>void handler(const boost::system::error_code, size_t bytes)</em>。</li>
<li><em>async_read_at(radom_stream, offset, buf [, completion_function] , handler)</em>: 这个方法是*read_at()*的异步实现。</li>
<li><em>async*read_until (sock, buf, char | string | regex | match* condition, handler)</em>: 这个方法是*read_until()*的异步实现。</li>
<li><em>async_write(sock, buf [, completion_function] , handler)</em>: 这个方法是*write()*的异步实现。</li>
<li><em>async_write_at(random_stream,offset, buf [, completion_function] , handler)</em>: 这个方法是*write_at()*的异步实现。</li>
</ul>
<p>我们假设你需要一直读取直到读到一个元音字母：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_vowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">read_complete</span><span class="params">(boost::system::error_code, <span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * begin = <span class="built_in">buffer_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;( buf.<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">if</span> ( bytes == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( bytes &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">is_vowel</span>(*begin++)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> --bytes;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">read</span>(sock, buf, read_complete);</span><br></pre></td></tr></table></figure>
<p>这里需要注意的事情是对<em>read_complete()<em>中buffer的访问，也就是</em>buffer_cast&lt;&gt;<em>和</em>buf.data</em>。</p>
<p>如果你使用正则，上面的例子会更简单：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_until(<span class="name">sock</span>, buf, boost:<span class="symbol">:regex</span>(<span class="string">&quot;^[aeiou]+&quot;</span>) )<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>或者我们修改例子来让<em>match_condition</em>方法工作起来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">streambuf buf;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_vowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> buffers_iterator&lt;streambuf::const_buffers_type&gt; iterator;</span><br><span class="line"><span class="function">std::pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">match_vowel</span><span class="params">(iterator b, iterator e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( b != e)</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">is_vowel</span>(*b++)) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(b, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(e, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">size_t</span> bytes = <span class="built_in">read_until</span>(sock, buf, match_vowel);</span><br></pre></td></tr></table></figure>
<p>当使用<em>read_until</em>时会有个难点：你需要记住你已经读取的字节数，因为下层的buffer可能多读取了一些字节（不像使用*read()*时）。比如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &amp;buf &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>上述代码输出的字节可能比<em>read_until</em>读取到的多。</p>
<h3 id="协程">协程</h3>
<p>Boost.Asio的作者在2009-2010年间实现了非常酷的一个部分，协程，它能让你更简单地设计你的异步应用。</p>
<p>它们可以让你同时享受同步和异步两个世界中最好的部分，也就是：异步编程但是很简单就能遵循流程控制，就好像应用是按流程实现的。</p>
<p>正常的流程已经在情形1种展示了，如果使用协程，你会尽可能的接近情形2。</p>
<p>简单来说，就是协程允许在方法中的指定位置开辟一个入口来暂停和恢复运行。</p>
<p>如果要使用协程，你需要在<em>boost/libs/asio/example/http/server4</em>目录下的两个头文件：<em>yield.hpp</em>和<em>coroutine.hpp</em>。在这里，Boost.Asio定义了两个虚拟的关键词（宏）和一个类：</p>
<ul>
<li><em>coroutine</em>：这个类在实现协程时被你的连接类继承或者使用。</li>
<li><em>reenter(entry)</em>：这个是协程的主体。参数<em>entry</em>是一个指向<em>coroutine</em>实例的指针，它被当作一个代码块在整个方法中使用。</li>
<li><em>yield code</em>：它把一个声明当作协程的一部分来运行。当下一次进入方法时，操作会在这段代码之后执行。</li>
</ul>
<p>为了更好的理解，我们来看一个例子。我们会重新实现 <strong>第四章 异步客户端</strong> 中的应用，这是一个可以登录，ping，然后能告诉你其他已登录客户端的简单客户端应用。 核心代码和下面的代码片段类似：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">talk_to_svr</span> : <span class="symbol">public</span> <span class="symbol">boost::<span class="symbol">enable_shared_from_this</span></span>&lt;<span class="symbol">talk_to_svr</span>&gt;, <span class="symbol">public</span> <span class="symbol">coroutine, <span class="symbol">boost</span>::<span class="symbol">noncopyable</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">void</span> step(<span class="keyword">const</span> error_code &amp; err = error_code(), size_t bytes = <span class="number">0</span>) &#123;</span><br><span class="line">        reenter(<span class="keyword">this</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                yield async_write(sock_, write_buffer_, MEM_FN2(step,_1,_2) );</span><br><span class="line">                yield async_read_until( sock_, read_buffer_,<span class="string">&quot;\n&quot;</span>, MEM_FN2(step,_1,_2));</span><br><span class="line">                yield service.post( MEM_FN(on_answer_from_server));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先改变的事就是：我们只有一个叫做*step()<em>的方法，而没有大量类似</em>connect()，on_connect()，on_read()，do_read()，on_write()，do_write()*等等的成员方法。</p>
<p>方法的主体在<em>reenter(this) { for (;;) { }}</em> 内。你可以把*reenter(this)*当作我们上次运行的代码，所以这次我们执行的是下一次的代码。</p>
<p>在<em>reenter</em>代码块中，你会发现几个<em>yield</em>声明。你第一次进入方法时，<em>async_write</em>方法被执行，第二次<em>async_read_until</em>方法被执行，第三次<em>service.post</em>方法被执行，然后第四次<em>async_write</em>方法被执行，然后一直循环下去。</p>
<p>你需要一直记住*for(;;){}*实例。参考下面的代码片段：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">step</span><span class="params">(<span class="type">const</span> error_code &amp; err = error_code(), <span class="type">size_t</span> bytes = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reenter</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="function">yield <span class="title">async_write</span><span class="params">(sock_, write_buffer_, MEM_FN2(step,_1,_2) )</span></span>;</span><br><span class="line">        <span class="function">yield <span class="title">async_read_until</span><span class="params">( sock_, read_buffer_, <span class="string">&quot;\n&quot;</span>,MEM_FN2(step,_1,_2))</span></span>;</span><br><span class="line">        yield service.<span class="built_in">post</span>(<span class="built_in">MEM_FN</span>(on_answer_from_server));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们第三次使用上述的代码片段，我们会进入方法然后执行<em>service.post</em>。当我们第四次进入方法时，我们跳过<em>service.post</em>，不执行任何东西。当执行第五次时仍然不执行任何东西，然后一直这样下去：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">talk_to_svr</span> : <span class="keyword">public</span> boost::enable_shared_from_this&lt;talk_to_svr&gt;, <span class="keyword">public</span> coroutine, boost::noncopyable &#123;</span><br><span class="line">    <span class="built_in">talk_to_svr</span>(<span class="type">const</span> std::string &amp; username) : ... &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(ip::tcp::endpoint ep)</span> </span>&#123;</span><br><span class="line">        sock_.<span class="built_in">async_connect</span>(ep, <span class="built_in">MEM_FN2</span>(step,_1,<span class="number">0</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ptr <span class="title">start</span><span class="params">(ip::tcp::endpoint ep, <span class="type">const</span> std::string &amp;username)</span> </span>&#123;</span><br><span class="line">        <span class="function">ptr <span class="title">new_</span><span class="params">(<span class="keyword">new</span> talk_to_svr(username))</span></span>;</span><br><span class="line">        new_-&gt;<span class="built_in">start</span>(ep); </span><br><span class="line">        <span class="keyword">return</span> new_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step</span><span class="params">(<span class="type">const</span> error_code &amp; err = error_code(), <span class="type">size_t</span> bytes = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">reenter</span>(<span class="keyword">this</span>) &#123; </span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( !started_) &#123;</span><br><span class="line">                    started_ = <span class="literal">true</span>;</span><br><span class="line">                    <span class="function">std::ostream <span class="title">out</span><span class="params">(&amp;write_buf_)</span></span>;</span><br><span class="line">                    out &lt;&lt; <span class="string">&quot;login &quot;</span> &lt;&lt; username_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">yield <span class="title">async_write</span><span class="params">(sock_, write_buf_,MEM_FN2(step,_1,_2))</span></span>;</span><br><span class="line">                <span class="function">yield <span class="title">async_read_until</span><span class="params">( sock_,read_buf_,<span class="string">&quot;\n&quot;</span>,MEM_FN2(step,_1,_2))</span></span>;</span><br><span class="line">                yield service.<span class="built_in">post</span>(<span class="built_in">MEM_FN</span>(on_answer_from_server));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_answer_from_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::istream <span class="title">in</span><span class="params">(&amp;read_buf_)</span></span>;</span><br><span class="line">        std::string <span class="type">word</span>;</span><br><span class="line">        in &gt;&gt; <span class="type">word</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="type">word</span> == <span class="string">&quot;login&quot;</span>) <span class="built_in">on_login</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="type">word</span> == <span class="string">&quot;ping&quot;</span>) <span class="built_in">on_ping</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="type">word</span> == <span class="string">&quot;clients&quot;</span>) <span class="built_in">on_clients</span>();</span><br><span class="line">        read_buf_.<span class="built_in">consume</span>( read_buf_.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span> (write_buf_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) service.<span class="built_in">post</span>(<span class="built_in">MEM_FN2</span>(step,<span class="built_in">error_code</span>(),<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ip::tcp::socket sock_;</span><br><span class="line">    streambuf read_buf_, write_buf_;</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    std::string username_;</span><br><span class="line">    deadline_timer timer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们启动连接时，<em>start()<em>被调用，然后它会异步地连接到服务端。当连接完成时，我们第一次进入</em>step()</em>。也就是我们发送我们登录信息的时候。</p>
<p>在那之后，我们调用<em>async_write</em>，然后调用<em>async_read_until</em>，再处理消息（<em>on_answer_from_server</em>）。</p>
<p>我们在<em>on_answer_from_server</em>处理接收到的消息；我们读取第一个字符，然后把它分发到相应的方法。剩下的消息（如果还有一些消息没读完）我们都忽略掉：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class talk_to_svr : ... &#123;</span><br><span class="line">    ...</span><br><span class="line">    void <span class="built_in">on_login</span>() &#123; <span class="built_in">do_ask_clients</span>(); &#125;</span><br><span class="line">    void <span class="built_in">on_ping</span>() &#123;</span><br><span class="line">        std::istream <span class="built_in">in</span>(&amp;read_buf_);</span><br><span class="line">        std::string answer; in &gt;&gt; answer;</span><br><span class="line">        if ( answer == &quot;client_list_changed&quot;)</span><br><span class="line">            <span class="built_in">do_ask_clients</span>();</span><br><span class="line">        else <span class="built_in">postpone_ping</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="built_in">on_clients</span>() &#123;</span><br><span class="line">        std::ostringstream clients; clients &lt;&lt; &amp;read_buf_;</span><br><span class="line">        std::cout &lt;&lt; username_ &lt;&lt; <span class="string">&quot;, new client list:&quot;</span> &lt;&lt; clients.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">postpone_ping</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="built_in">do_ping</span>() &#123;</span><br><span class="line">        std::ostream <span class="built_in">out</span>(&amp;write_buf_); out &lt;&lt; &quot;ping\n&quot;;</span><br><span class="line">        service<span class="selector-class">.post</span>( MEM_FN2(step,error_code(),<span class="number">0</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    void <span class="built_in">postpone_ping</span>() &#123;</span><br><span class="line">        timer_<span class="selector-class">.expires_from_now</span>(boost::posix_time::millisec(rand() % <span class="number">7000</span>));</span><br><span class="line">        timer_<span class="selector-class">.async_wait</span>( MEM_FN(do_ping));</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="built_in">do_ask_clients</span>() &#123;</span><br><span class="line">        std::ostream <span class="built_in">out</span>(&amp;write_buf_);</span><br><span class="line">        out &lt;&lt; &quot;ask_clients\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完整的例子还会更复杂一点，因为我们需要随机地ping服务端。实现这个功能我们需要在第一次请求客户端列表完成之后做一个ping操作。然后，在每个从服务端返回的ping操作的结果中，我们做另外一个ping操作。</p>
<p>使用下面的代码片段来执行整个过程：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">    ip::tcp::endpoint ep(ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">8001</span>);</span><br><span class="line">    talk_to_svr::start(ep, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">    service.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用协程，我们节约了15行代码，而且代码也变的更加易读。</p>
<p>学习自：<a target="_blank" rel="noopener" href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/">Boost.Asio C++ 网络编程</a></p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Boost.Asio C++网络编程</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/9965c391.html">https://penge666.github.io/posts/9965c391.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-05-08</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-05-08</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Cpp</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>网络编程</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/9131331a.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_12.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">无锁队列</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d0543761.html" title="muduo网络库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_22.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-04</div><div class="title">muduo网络库</div></div></a></div><div><a href="/posts/af408df9.html" title="Modern Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_17.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-11</div><div class="title">Modern Cpp</div></div></a></div><div><a href="/posts/e584d079.html" title="More Effective Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-12</div><div class="title">More Effective Cpp</div></div></a></div><div><a href="/posts/bf4dced7.html" title="Effective Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_24.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-11</div><div class="title">Effective Cpp</div></div></a></div><div><a href="/posts/4772239d.html" title="Cpp基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-04</div><div class="title">Cpp基础知识</div></div></a></div><div><a href="/posts/a5a0c60f.html" title="内存屏障"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-24</div><div class="title">内存屏障</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost-Asio%E5%85%A5%E9%97%A8"><span class="toc-text">Boost.Asio入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBoost-Asio"><span class="toc-text">什么是Boost.Asio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-text">历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91Boost-Asio"><span class="toc-text">编译Boost.Asio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%8F"><span class="toc-text">重要的宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5"><span class="toc-text">同步VS异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86VS%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">异常处理VS错误代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boost-Asio%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">Boost.Asio中的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">不仅仅是网络通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">计时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-service%E7%B1%BB"><span class="toc-text">io_service类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost-Asio%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">Boost.Asio基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9CAPI"><span class="toc-text">网络API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boost-Asio%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">Boost.Asio命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E7%82%B9"><span class="toc-text">端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF%E7%A0%81"><span class="toc-text">同步错误码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">socket成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">连接相关的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text">读写函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A7%E5%88%B6%EF%BC%9A"><span class="toc-text">套接字控制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-VS-UDP-VS-ICMP"><span class="toc-text">TCP VS UDP VS ICMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-text">其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-text">其他需要考虑的事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">套接字缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-text">缓冲区封装函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-write-connect%E8%87%AA%E7%94%B1%E5%87%BD%E6%95%B0"><span class="toc-text">read&#x2F;write&#x2F;connect自由函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#connect%E6%96%B9%E6%B3%95"><span class="toc-text">connect方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-write%E6%96%B9%E6%B3%95"><span class="toc-text">read&#x2F;write方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-until-async-read-until%E6%96%B9%E6%B3%95"><span class="toc-text">read_until&#x2F;async_read_until方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#at%E6%96%B9%E6%B3%95"><span class="toc-text">*_at方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-text">异步的需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5run-runone-poll-poll-one"><span class="toc-text">异步run(), runone(), poll(), poll one()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E8%BF%90%E8%A1%8C"><span class="toc-text">持续运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#run-one-poll-poll-one-%E6%96%B9%E6%B3%95"><span class="toc-text">run_one(), poll(), poll_one() 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C"><span class="toc-text">异步工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5post-VS-dispatch-VS-wrap"><span class="toc-text">异步post() VS dispatch() VS wrap()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E6%B4%BB%E5%8A%A8"><span class="toc-text">保持活动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">回显服务端&#x2F;客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">TCP回显服务端&#x2F;客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%90%8C%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">TCP同步客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">TCP同步服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%BC%82%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">TCP异步客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">TCP异步服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">UDP回显服务端&#x2F;客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%90%8C%E6%AD%A5%E5%9B%9E%E6%98%BE%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">UDP同步回显客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%90%8C%E6%AD%A5%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">UDP同步回显服务端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">客户端和服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">同步客户端&#x2F;服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">同步客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">同步服务端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">异步客户端&#x2F;服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">异步客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">异步服务端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5-2"><span class="toc-text">同步VS异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">混合同步异步编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AFVS%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">从客户端传递信息到服务端VS从服务端传递信息到客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5I-O"><span class="toc-text">客户端应用中的同步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5I-O"><span class="toc-text">服务端应用中的同步I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">同步服务端中的线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5I-O"><span class="toc-text">客户端应用中的异步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5I-O"><span class="toc-text">服务端应用的异步I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">异步服务端中的多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">异步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">代理实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost-Asio%EF%BC%8D%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-text">Boost.Asio－其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86stream%E5%92%8C%E6%A0%87%E5%87%86I-O-buffer"><span class="toc-text">标准stream和标准I&#x2F;O buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boost-Asio%E5%92%8CSTL-stream"><span class="toc-text">Boost.Asio和STL stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#streambuf%E7%B1%BB"><span class="toc-text">streambuf类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86streambuf%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%87%AA%E7%94%B1%E5%87%BD%E6%95%B0"><span class="toc-text">处理streambuf对象的自由函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-text">协程</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>