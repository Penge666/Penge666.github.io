<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>页面加载过程细说 | Penge666</title><meta name="keywords" content="计算机网络"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="在浏览器输入URL回车之后发生了什么？">
<meta property="og:type" content="article">
<meta property="og:title" content="页面加载过程细说">
<meta property="og:url" content="https://penge666.github.io/posts/d312cb1f.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="在浏览器输入URL回车之后发生了什么？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_24.webp">
<meta property="article:published_time" content="2024-06-15T07:36:23.000Z">
<meta property="article:modified_time" content="2024-06-17T08:55:35.523Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_24.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/d312cb1f"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '页面加载过程细说',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-17 16:55:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">页面加载过程细说</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-06-15T07:36:23.000Z" title="发表于 2024-06-15 15:36:23">2024-06-15</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-17T08:55:35.523Z" title="更新于 2024-06-17 16:55:35">2024-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">1.7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="页面加载过程细说"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="大纲">大纲</h2>
<ul>
<li>对知识体系进行一次预评级</li>
<li>为什么说知识体系如此重要？</li>
<li>梳理主干流程</li>
<li>从浏览器接收url到开启网络请求线程
<ul>
<li>多进程的浏览器</li>
<li>多线程的浏览器内核</li>
<li>解析URL</li>
<li>网络请求都是单独的线程</li>
<li>更多</li>
</ul>
</li>
<li>开启网络线程到发出一个完整的http请求
<ul>
<li>DNS查询得到IP</li>
<li>tcp/ip请求</li>
<li>五层因特网协议栈</li>
</ul>
</li>
<li>从服务器接收到请求到对应后台接收到请求
<ul>
<li>负载均衡</li>
<li>后台的处理</li>
</ul>
</li>
<li>后台和前台的http交互
<ul>
<li>http报文结构</li>
<li>cookie以及优化</li>
<li>gzip压缩</li>
<li>长连接与短连接</li>
<li>http 2.0</li>
<li>https</li>
</ul>
</li>
<li>单独拎出来的缓存问题，http的缓存
<ul>
<li>强缓存与弱缓存</li>
<li>缓存头部简述</li>
<li>头部的区别</li>
</ul>
</li>
<li>解析页面流程
<ul>
<li>流程简述</li>
<li>HTML解析，构建DOM</li>
<li>生成CSS规则</li>
<li>构建渲染树</li>
<li>渲染</li>
<li>简单层与复合层</li>
<li>Chrome中的调试</li>
<li>资源外链的下载</li>
<li>loaded和domcontentloaded</li>
</ul>
</li>
<li>CSS的可视化格式模型
<ul>
<li>包含块（Containing Block）</li>
<li>控制框（Controlling Box）</li>
<li>BFC（Block Formatting Context）</li>
<li>IFC（Inline Formatting Context）</li>
<li>其它</li>
</ul>
</li>
<li>JS引擎解析过程
<ul>
<li>JS的解释阶段</li>
<li>JS的预处理阶段</li>
<li>JS的执行阶段</li>
<li>回收机制</li>
</ul>
</li>
<li>其它</li>
<li>总结</li>
</ul>
<h2 id="梳理主干流程">梳理主干流程</h2>
<p>回到这道题上，如何回答呢？先梳理一个骨架：</p>
<p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。</p>
<p>所以，先梳理下<strong>主干流程</strong>：</p>
<ol>
<li>
<p>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</p>
</li>
<li>
<p>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</p>
</li>
<li>
<p>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</p>
</li>
<li>
<p>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</p>
</li>
<li>
<p>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</p>
</li>
<li>
<p>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</p>
</li>
<li>
<p>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</p>
</li>
<li>
<p>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p>
</li>
<li>
<p>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</p>
</li>
</ol>
<p>梳理出主干骨架，然后就需要往骨架上填充细节内容。</p>
<h2 id="从浏览器接收url到开启网络请求线程">从浏览器接收url到开启网络请求线程</h2>
<p>这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制</p>
<h3 id="多进程的浏览器">多进程的浏览器</h3>
<p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p>
<p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p>
<ul>
<li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制</li>
<li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>
</ul>
<h3 id="多线程的浏览器内核">多线程的浏览器内核</h3>
<p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p>
<ul>
<li>GUI线程</li>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时器线程</li>
<li>网络请求线程</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617155831182.png" alt="image-20240617155831182"></p>
<p>可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的</p>
<p>JS引擎，也被称为JavaScript引擎，是浏览器中用来解析和执行JavaScript代码的一个组件。它的主要任务是将开发人员编写的JavaScript代码转换（或者说&quot;解释&quot;）为可以被计算机硬件执行的低级机器代码。</p>
<h3 id="解析URL">解析URL</h3>
<p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p>
<p>URL一般包括几大部分：</p>
<ul>
<li><code>protocol</code>，协议头，譬如有http，ftp等</li>
<li><code>host</code>，主机域名或IP地址</li>
<li><code>port</code>，端口号</li>
<li><code>path</code>，目录路径</li>
<li><code>query</code>，即查询参数</li>
<li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li>
</ul>
<h3 id="网络请求都是单独的线程">网络请求都是单独的线程</h3>
<p><strong>每次网络请求时都需要开辟单独的线程进行</strong>，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p>
<p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p>
<h2 id="开启网络线程到发出一个完整的http请求">开启网络线程到发出一个完整的http请求</h2>
<p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等</p>
<p>仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）</p>
<h3 id="DNS查询得到IP">DNS查询得到IP</h3>
<p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p>
<ul>
<li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li>
<li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li>
</ul>
<p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p>
<p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化。</p>
<p><strong><code>dns-prefetch</code>优化</strong></p>
<p><code>dns-prefetch</code> 是一种 DNS 预解析技术，它是浏览器用来优化页面加载速度的一种方式。</p>
<p>当你在网页中使用 <code>dns-prefetch</code>，浏览器会在用户点击链接或者页面开始加载前就去解析这个链接的 DNS。这样当用户真正需要访问这个链接时，DNS 的解析时间就已经被节省下来了，从而可以加速页面的加载。</p>
<p>在 HTML 中，你可以通过在 <code>&lt;link&gt;</code> 标签中设置 <code>rel=&quot;dns-prefetch&quot;</code> 来使用这个功能，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码会告诉浏览器预先解析 <code>example.com</code> 这个域名的 DNS。这在你的网页中有大量来自 <code>example.com</code> 的资源需要加载，或者预计用户会点击一个指向 <code>example.com</code> 的链接时，可以显著提升页面的加载速度。</p>
<p>但是，需要注意的是，<code>dns-prefetch</code> 并不是所有的浏览器都支持。在使用时，你应该检查你的目标浏览器是否支持这个功能。</p>
<p>简单来说：<strong>dns-prefetch可以理解成提前加载浏览器中链接要请求的DNS服务器地址</strong>。</p>
<p><strong>补充：DNS</strong></p>
<p>DNS，全称为域名系统（Domain Name System），它是一个用于将域名转换为 IP 地址的分布式数据库系统。在互联网上，每个连接到网络的设备都有一个独一无二的 IP 地址，就像我们的家庭地址一样。但是，记住一串数字并不方便，所以我们使用更易记忆的域名，比如 <a target="_blank" rel="noopener" href="https://www.coze.com/">www.coze.com</a>。</p>
<p>当你在浏览器中输入一个域名并按下 Enter 键时，浏览器并不知道这个域名对应哪个服务器的 IP 地址。这时，它就需要向 DNS 服务器发送一个查询请求，DNS 服务器会查找它的数据库，找到这个域名对应的 IP 地址，并将它返回给浏览器。然后浏览器就可以通过这个 IP 地址连接到对应的服务器。</p>
<p>因此，我们可以将 DNS 看作是互联网的“电话簿”，它负责将易于人类理解的域名转化为机器可以理解的 IP 地址。</p>
<h3 id="tcp-ip请求">tcp/ip请求</h3>
<p>http的本质就是<code>tcp/ip</code>请求</p>
<p>需要了解3次握手规则建立连接以及断开连接时的四次挥手</p>
<p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输</p>
<p><strong>三次握手的步骤：（抽象派）</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是<span class="keyword">server</span>么？</span><br><span class="line">服务端：hello，我是<span class="keyword">server</span>，你是<span class="keyword">client</span>么</span><br><span class="line">客户端：yes，我是<span class="keyword">client</span></span><br></pre></td></tr></table></figure>
<p>建立连接成功后，接下来就正式传输数据</p>
<p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p>
<p><strong>四次挥手的步骤：（抽象派）</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure>
<p><strong>tcp/ip的并发限制</strong></p>
<p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）</p>
<p>而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p>
<p>所以针对这个瓶颈，又出现了很多的资源优化方案</p>
<p><strong>get和post的区别</strong></p>
<p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p>
<p><strong>get会产生一个tcp数据包，post两个</strong></p>
<p>具体就是：</p>
<ul>
<li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li>
<li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应200（返回数据）。</li>
</ul>
<p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p>
<p><strong>解释</strong>：</p>
<p><strong>这种设计主要是基于HTTP/1.1协议中的&quot;Expect: 100-continue&quot;头信息。这是一种优化机制</strong>，<strong>它允许客户端询问服务器是否愿意接收其请求（基于请求头信息），在服务器响应100 Continue后，客户端才会发送请求体内容。</strong></p>
<p>这种设计的主要优点有两个：</p>
<ol>
<li><strong>节省带宽</strong>：在发送大量数据到服务器之前，客户端可以先检查服务器是否会接受这个请求（比如，检查认证是否成功，或者内容类型是否正确）。如果服务器拒绝了请求，那么就可以在发送大量数据并浪费带宽之前就终止这个请求。</li>
<li><strong>减少服务器负担</strong>：通过这种方式，服务器可以在接收到大量数据之前就拒绝请求，这样可以防止恶意或者错误的请求浪费服务器的资源。</li>
</ol>
<p>然而，需要注意的是，并非所有的POST请求都会这样处理，这取决于客户端是否发送了&quot;Expect: 100-continue&quot;头信息。而在某些情况下，例如小数据量的POST请求，或者在低延迟的网络环境下，使用&quot;Expect: 100-continue&quot;可能会导致性能下降，因为它需要等待服务器的100 Continue响应。所以这个特性应该根据具体情况来使用。</p>
<h3 id="五层因特网协议栈">五层因特网协议栈</h3>
<p>其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念</p>
<p>其实就是一个概念： <strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p>
<p>简括就是：</p>
<p><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p>
<p>当然，服务端的接收就是反过来的步骤</p>
<p>五层因特网协议栈其实就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line"></span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line"></span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line"></span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line"></span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure>
<p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。</p>
<p>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line"></span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure>
<h2 id="从服务器接收到请求到对应后台接收到请求">从服务器接收到请求到对应后台接收到请求</h2>
<p>服务端在接收到请求时，内部会进行很多的处理</p>
<p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入</p>
<h2 id="负载均衡">负载均衡</h2>
<p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</p>
<p>当然了，负载均衡不止这一种实现方式，这里不深入…</p>
<p>简单的说：</p>
<p><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong></p>
<h2 id="后台的处理">后台的处理</h2>
<p>一般后台都是部署到容器中的，所以一般为：</p>
<ul>
<li>先是容器接受到请求（如tomcat容器）</li>
<li>然后对应容器中的后台程序接收到请求（如java程序）</li>
<li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li>
</ul>
<p>概括下：</p>
<ul>
<li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li>
<li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li>
<li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li>
<li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li>
<li>然后就是将这个包从后端发送到前端，完成交互</li>
</ul>
<h2 id="后台和前台的http交互">后台和前台的http交互</h2>
<p>前后端交互时，http报文作为信息的载体</p>
<p>所以http是一块很重要的内容，这一部分重点介绍它</p>
<h3 id="http报文结构">http报文结构</h3>
<p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p>
<p><strong>通用头部</strong></p>
<p>这也是开发人员见过的最多的信息，包括如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line"></span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line"></span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line"></span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure>
<p>譬如，在跨域拒绝时，可能是method为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p>
<p>其中，Method的话一般分为两批次：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP1<span class="number">.0</span>定义了三种请求方法： <span class="keyword">GET</span>, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、<span class="keyword">DELETE</span>、LINK、UNLINK</span><br><span class="line"></span><br><span class="line">HTTP1<span class="number">.1</span>定义了八种请求方法：<span class="keyword">GET</span>、POST、HEAD、<span class="keyword">OPTIONS</span>, PUT, <span class="keyword">DELETE</span>, TRACE 和 <span class="keyword">CONNECT</span> 方法。</span><br></pre></td></tr></table></figure>
<p><code>HTTP 1.0</code>定义参考：<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1945">https://tools.ietf.org/html/rfc1945</a></p>
<p><code>HTTP 1.1</code>定义参考：<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a></p>
<p>这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再列举下大致不同范围状态的意义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617161636603.png" alt="image-20240617161636603"></p>
<p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索</p>
<p><strong>请求/响应头部</strong></p>
<p>请求和响应头部也是分析时常用到的</p>
<p>常用的请求头部（部分）：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Accept</span><span class="operator">:</span> 接收类型，表示浏览器支持的<span class="variable">MIME</span>类型</span><br><span class="line">（对标服务端返回的<span class="variable">Content</span><span class="operator">-</span><span class="variable">Type</span>）</span><br><span class="line"><span class="variable">Accept</span><span class="operator">-</span><span class="variable">Encoding</span>：浏览器支持的压缩类型<span class="operator">,</span>如<span class="variable">gzip</span>等<span class="operator">,</span>超出类型不能接收</span><br><span class="line"><span class="variable">Content</span><span class="operator">-</span><span class="variable">Type</span>：客户端发送出去实体内容的类型</span><br><span class="line"><span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">:</span> 指定请求和响应遵循的缓存机制，如<span class="variable">no</span><span class="operator">-</span><span class="variable">cache</span></span><br><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="variable">Modified</span><span class="operator">-</span><span class="variable">Since</span>：对应服务端的<span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span>，用来匹配看文件是否变动，只能精确到<span class="number">1</span><span class="variable">s</span>之内，<span class="variable">http1</span><span class="number">.0</span>中</span><br><span class="line"><span class="variable">Expires</span>：缓存控制，在这个时间内不会请求，直接使用缓存，<span class="variable">http1</span><span class="number">.0</span>，而且是服务端时间</span><br><span class="line"><span class="built_in">Max</span><span class="operator">-</span><span class="variable">age</span>：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，<span class="variable">http1</span><span class="number">.1</span>中</span><br><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span>：对应服务端的<span class="variable">ETag</span>，用来匹配文件内容是否改变（非常精确），<span class="variable">http1</span><span class="number">.1</span>中</span><br><span class="line"><span class="variable">Cookie</span><span class="operator">:</span> 有<span class="variable">cookie</span>并且同域访问时会自动带上</span><br><span class="line"><span class="variable">Connection</span><span class="operator">:</span> 当浏览器与服务器通信时对于长连接如何进行处理<span class="operator">,</span>如<span class="variable">keep</span><span class="operator">-</span><span class="variable">alive</span></span><br><span class="line"><span class="variable">Host</span>：请求的服务器<span class="built_in">URL</span></span><br><span class="line"><span class="variable">Origin</span>：最初的请求是从哪里发起的（只会精确到端口）<span class="operator">,</span><span class="variable">Origin</span>比<span class="variable">Referer</span>更尊重隐私</span><br><span class="line"><span class="variable">Referer</span>：该页面的来源<span class="built_in">URL</span><span class="punctuation">(</span>适用于所有类型的请求，会精确到详细页面地址，<span class="variable">csrf</span>拦截常用到这个字段<span class="punctuation">)</span></span><br><span class="line"><span class="variable">User</span><span class="operator">-</span><span class="variable">Agent</span>：用户客户端的一些必要信息，如<span class="variable">UA</span>头部等</span><br></pre></td></tr></table></figure>
<p>常用的响应头部（部分）：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Access</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">-</span><span class="variable">Allow</span><span class="operator">-</span><span class="built_in">Headers</span><span class="operator">:</span> 服务器端允许的请求<span class="built_in">Headers</span></span><br><span class="line"><span class="variable">Access</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">-</span><span class="variable">Allow</span><span class="operator">-</span><span class="variable">Methods</span><span class="operator">:</span> 服务器端允许的请求方法</span><br><span class="line"><span class="variable">Access</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">-</span><span class="variable">Allow</span><span class="operator">-</span><span class="variable">Origin</span><span class="operator">:</span> 服务器端允许的请求<span class="variable">Origin</span>头部（譬如为<span class="operator">*</span>）</span><br><span class="line"><span class="variable">Content</span><span class="operator">-</span><span class="variable">Type</span>：服务端返回的实体内容的类型</span><br><span class="line"><span class="built_in">Date</span>：数据从服务器发送的时间</span><br><span class="line"><span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span>：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line"><span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span>：请求资源的最后修改时间</span><br><span class="line"><span class="variable">Expires</span>：应该在什么时候认为文档已经过期<span class="operator">,</span>从而不再缓存它</span><br><span class="line"><span class="built_in">Max</span><span class="operator">-</span><span class="variable">age</span>：客户端的本地资源应该缓存多少秒，开启了<span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span>后有效</span><br><span class="line"><span class="variable">ETag</span>：请求变量的实体标签的当前值</span><br><span class="line"><span class="built_in">Set</span><span class="operator">-</span><span class="variable">Cookie</span>：设置和页面关联的<span class="variable">cookie</span>，服务器通过这个头部把<span class="variable">cookie</span>传给客户端</span><br><span class="line"><span class="variable">Keep</span><span class="operator">-</span><span class="variable">Alive</span>：如果客户端有<span class="variable">keep</span><span class="operator">-</span><span class="variable">alive</span>，服务端也会有响应（如<span class="variable">timeout</span><span class="operator">=</span><span class="number">38</span>）</span><br><span class="line"><span class="variable">Server</span>：服务器的一些相关信息</span><br></pre></td></tr></table></figure>
<p>一般来说，请求头部和响应头部是匹配分析的。</p>
<p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p>
<p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p>
<p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应</p>
<p>还有很多的分析方法，这里不一一赘述</p>
<p><strong>请求/响应实体</strong></p>
<p>http请求时，除了头部，还有消息实体，一般来说</p>
<p>请求实体中会将一些需要的参数都放入进入（用于post请求）。</p>
<p>譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等</p>
<p>而一般响应实体中，就是放服务端需要传给客户端的内容</p>
<p>一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。</p>
<p><strong>CRLF</strong></p>
<p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在</p>
<p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p>
<p>一般来说（分隔符类别）：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CRLF</span>-&gt;Windows-style</span><br><span class="line"><span class="keyword">LF</span>-&gt;Unix Style</span><br><span class="line"><span class="keyword">CR</span>-&gt;Mac Style</span><br></pre></td></tr></table></figure>
<p>如下图是对某请求的http报文结构的简要分析</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617161749694.png" alt="image-20240617161749694"></p>
<h3 id="cookie以及优化">cookie以及优化</h3>
<p>cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。</p>
<p>场景如下（简述）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line"></span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line"></span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line"></span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line"></span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure>
<p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）</p>
<p>一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）</p>
<p>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p>
<p>譬如以下场景：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名<span class="selector-tag">A</span>下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line"></span><br><span class="line">然后在域名<span class="selector-tag">A</span>下有一个页面，页面中有很多依赖的静态资源（都是域名<span class="selector-tag">A</span>的，譬如有<span class="number">20</span>个静态资源）</span><br><span class="line"></span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line"></span><br><span class="line">也就是说，这<span class="number">20</span>个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line"></span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure>
<p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p>
<ul>
<li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li>
<li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li>
</ul>
<p>说到了多域名拆分，这里再提一个问题，那就是：</p>
<ul>
<li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li>
<li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li>
</ul>
<h3 id="gzip压缩">gzip压缩</h3>
<p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且gzip压缩效率很好（高达70%左右）</p>
<p>然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启</p>
<p>当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）</p>
<p>所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的， 非常方便。</p>
<h3 id="长连接与短连接">长连接与短连接</h3>
<p>首先看<code>tcp/ip</code>层面的定义：</p>
<ul>
<li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
<p>然后在http层面：</p>
<ul>
<li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p>
<h3 id="http-2-0">http 2.0</h3>
<p>http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）</p>
<p>然后简述下http2.0与http1.1的显著不同点：</p>
<ul>
<li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p>
<p>然后简述下http2.0的一些特性：</p>
<ul>
<li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>
<li>首部压缩（http头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<p>✳<strong>详细解释</strong>：</p>
<p>HTTP/2.0引入了一种被称为“多路复用”的技术。在HTTP/1.x中，每个资源请求都需要一个单独的TCP连接，这意味着如果一个网页有多个资源（图片、CSS、JavaScript等），那么浏览器就需要建立多个TCP连接，这会消耗更多时间和网络带宽。</p>
<p>而在HTTP/2.0中，所有的资源请求都通过一个单一的TCP连接发送，这个连接可以同时处理多个请求和响应，这就是所谓的“多路复用”。</p>
<p>举个例子，假设有一个网页，这个网页有1个HTML文件，3个CSS文件，5个JavaScript文件和10个图片。在HTTP/1.x中，浏览器需要建立19个TCP连接，每个连接处理一个资源请求。而在HTTP/2.0中，所有的19个资源请求都通过一个TCP连接发送，大大提高了加载速度。</p>
<p>这就像是你去购物，HTTP/1.x的方式就像是你每买一样商品都要排一次队付款，而HTTP/2.0的方式就像是你把所有的商品都放在购物车里，然后一次性排队付款。显然，后者更加高效。</p>
<p>再举一个例子，如果你在看一部在线视频，视频被切割成了许多小段。在HTTP/1.x中，每一小段视频都需要一个TCP连接去请求，而在HTTP/2.0中，所有的小段视频都通过一个TCP连接请求，这样可以减少网络延迟，提高视频的加载速度。</p>
<h3 id="https">https</h3>
<p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。</p>
<p>简单来看，https与http的区别就是： <strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p>
<p>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）</p>
<p>一般来说，主要关注的就是SSL/TLS的握手流程，如下（简述）：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client <span class="built_in">random</span>和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 服务端从中选出一组加密算法与<span class="built_in">Hash</span>算法，回复一个随机数–Server <span class="built_in">random</span>，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 浏览器收到服务端的证书后</span><br><span class="line">    </span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line">    </span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<span class="string">`Premaster secret`</span>，发送给服务器。</span><br><span class="line">    </span><br><span class="line">    - 利用Client <span class="built_in">random</span>、Server <span class="built_in">random</span>和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-<span class="string">`session key`</span></span><br><span class="line">    </span><br><span class="line">    - 使用约定好的<span class="built_in">HASH</span>算法计算握手消息，并使用生成的<span class="string">`session key`</span>对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span> 服务端收到浏览器的回复</span><br><span class="line"></span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取<span class="string">`Premaster secret`</span></span><br><span class="line">    </span><br><span class="line">    - 和浏览器相同规则生成<span class="string">`session key`</span></span><br><span class="line">    </span><br><span class="line">    - 使用<span class="string">`session key`</span>解密浏览器发来的握手消息，并验证<span class="built_in">Hash</span>是否与浏览器发来的一致</span><br><span class="line">    </span><br><span class="line">    - 使用<span class="string">`session key`</span>加密一段握手消息，发送给浏览器</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 浏览器解密并计算握手消息的<span class="built_in">HASH</span>，如果与服务端发来的<span class="built_in">HASH</span>一致，此时握手过程结束，</span><br></pre></td></tr></table></figure>
<p><strong>之后所有的https通信数据将由之前浏览器生成的<code>session key</code>并利用对称加密算法进行加密</strong></p>
<p>这里放一张图（来源：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰-图解SSL/TLS协议</a>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617162617015.png" alt="image-20240617162617015"></p>
<h2 id="http的缓存">http的缓存</h2>
<p>前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的。</p>
<h3 id="强缓存与弱缓存">强缓存与弱缓存</h3>
<p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）</p>
<p>区别简述如下：</p>
<ul>
<li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li>
<li>协商缓存（<code>304</code>）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li>
</ul>
<p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效</p>
<p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p>
<h3 id="缓存头部简述">缓存头部简述</h3>
<p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？</p>
<p>答案是通过不同的http头部控制</p>
<p>先看下这几个头部：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span><span class="operator">/</span><span class="built_in">E</span><span class="operator">-</span><span class="variable">tag</span>、<span class="built_in">If</span><span class="operator">-</span><span class="variable">Modified</span><span class="operator">-</span><span class="variable">Since</span><span class="operator">/</span><span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span>、<span class="variable">Cache</span><span class="operator">-</span><span class="built_in">Control</span><span class="operator">/</span><span class="built_in">Max</span><span class="operator">-</span><span class="variable">Age</span>、<span class="variable">Pragma</span><span class="operator">/</span><span class="variable">Expires</span></span><br></pre></td></tr></table></figure>
<p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。</p>
<p>属于强缓存控制的：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1<span class="number">.1</span>）<span class="keyword">Cache</span><span class="params">-Control</span>/<span class="keyword">Max</span><span class="params">-Age</span></span><br><span class="line">（http1<span class="number">.0</span>）Pragma/Expires</span><br></pre></td></tr></table></figure>
<p>注意：<strong><code>Max-Age</code>不是一个头部，它是<code>Cache-Control</code>头部的值</strong></p>
<p>属于协商缓存控制的：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="variable">http1</span><span class="number">.1</span>）<span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span><span class="operator">/</span><span class="built_in">E</span><span class="operator">-</span><span class="variable">tag</span></span><br><span class="line">（<span class="variable">http1</span><span class="number">.0</span>）<span class="built_in">If</span><span class="operator">-</span><span class="variable">Modified</span><span class="operator">-</span><span class="variable">Since</span><span class="operator">/</span><span class="built_in">Last</span><span class="operator">-</span><span class="variable">Modified</span></span><br></pre></td></tr></table></figure>
<p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同http时期的</p>
<p>再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META <span class="attribute">HTTP-EQUIV</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attribute">CONTENT</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐</p>
<h3 id="头部的区别">头部的区别</h3>
<p>首先明确，http的发展是从http1.0到http1.1</p>
<p>而在http1.1中，出了一些新内容，弥补了http1.0的不足。</p>
<p><strong>http1.0中的缓存控制：</strong></p>
<ul>
<li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li>
<li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li>
<li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li>
</ul>
<p><strong>http1.1中的缓存控制：</strong></p>
<ul>
<li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li>
<li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li>
<li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li>
</ul>
<p><strong>Max-Age相比Expires？</strong></p>
<p><code>Expires</code>使用的是服务器端的时间</p>
<p>但是有时候会有这样一种情况-客户端时间和服务端不同步</p>
<p>那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期</p>
<p>所以一般http1.1后不推荐使用<code>Expires</code></p>
<p>而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题</p>
<p>因此推荐使用<code>Max-Age</code>。</p>
<p>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p>
<p><strong>E-tag相比Last-Modified？</strong></p>
<p><code>Last-Modified</code>：</p>
<ul>
<li>表明服务端的文件最后何时改变的</li>
<li>它有一个缺陷就是只能精确到1s，</li>
<li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li>
</ul>
<p>而<code>E-tag</code>：</p>
<ul>
<li>是一种指纹机制，代表文件相关指纹</li>
<li>只有文件变才会变，也只要文件变就会变，</li>
<li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li>
</ul>
<p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code></p>
<p>各大缓存头部的整体关系如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163035634.png" alt="image-20240617163035634"></p>
<h2 id="解析页面流程">解析页面流程</h2>
<p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染</p>
<h3 id="流程简述">流程简述</h3>
<p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 解析HTML，构建DOM树</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 解析CSS，生成CSS规则树</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 合并DOM树和CSS规则，生成render树</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 绘制render树（paint），绘制页面像素信息</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163118510.png" alt="image-20240617163118510"></p>
<h3 id="HTML解析，构建DOM">HTML解析，构建DOM</h3>
<p>整个渲染步骤中，HTML解析是第一步。</p>
<p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p>
<p>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。</p>
<p>解析HTML到构建出DOM当然过程可以简述如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → <span class="built_in">characters</span> → tokens → nodes → DOM</span><br></pre></td></tr></table></figure>
<p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;awesome-photo.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器的处理如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163136854.png" alt="image-20240617163136854"></p>
<p>列举其中的一些重点过程：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Conversion</span>转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure>
<p>最后的DOM树如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163154312.png" alt="image-20240617163154312"></p>
<h3 id="生成CSS规则">生成CSS规则</h3>
<p>同理，CSS规则树的生成也是类似。简述为：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → <span class="built_in">characters</span> → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure>
<p>譬如<code>style.css</code>内容如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure>
<p>那么最终的CSSOM树就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163213869.png" alt="image-20240617163213869"></p>
<h3 id="构建渲染树">构建渲染树</h3>
<p>当DOM树和CSSOM都有了后，就要开始构建渲染树了</p>
<p>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应</p>
<p>因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等</p>
<p>整体来说可以看图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163239352.png" alt="image-20240617163239352"></p>
<h3 id="渲染">渲染</h3>
<p>有了render树，接下来就是开始渲染，基本流程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163307907.png" alt="image-20240617163307907"></p>
<p>图中重要的四个步骤就是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 计算CSS样式</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 构建渲染树</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure>
<p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）</p>
<p>这里Layout和Repaint的概念是有区别的：</p>
<ul>
<li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li>
<li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li>
</ul>
<p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。</p>
<p><strong>什么会引起回流？</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.页面渲染初始化</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="selector-class">.DOM</span>结构改变，比如删除了某个节点</span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="selector-class">.render</span>树变化，比如减少了<span class="attribute">padding</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.窗口<span class="attribute">resize</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （<span class="number">1</span>）offset(<span class="attribute">Top</span>/<span class="attribute">Left</span>/<span class="attribute">Width</span>/<span class="attribute">Height</span>)</span><br><span class="line">     (<span class="number">2</span>) scroll(<span class="attribute">Top</span>/<span class="attribute">Left</span>/<span class="attribute">Width</span>/<span class="attribute">Height</span>)</span><br><span class="line">     (<span class="number">3</span>) cilent(<span class="attribute">Top</span>/<span class="attribute">Left</span>/<span class="attribute">Width</span>/<span class="attribute">Height</span>)</span><br><span class="line">     (<span class="number">4</span>) <span class="attribute">width</span>,<span class="attribute">height</span></span><br><span class="line">     (<span class="number">5</span>) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure>
<p>回流一定伴随着重绘，重绘却可以单独出现</p>
<p>所以一般会有一些优化方案，如：</p>
<ul>
<li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li>
<li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li>
<li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li>
<li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li>
</ul>
<p><strong>注意：改变字体大小会引发回流</strong></p>
<p>再来看一个示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = <span class="string">&quot;2px&quot;</span>; <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">&quot;1px solid red&quot;</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">&quot;blue&quot;</span>; <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">&quot;#ccc&quot;</span>; <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">&quot;14px&quot;</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;abc!&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="简单层与复合层">简单层与复合层</h3>
<p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。</p>
<p>这里不展开，进简单介绍下：</p>
<ul>
<li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li>
<li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li>
<li>复合图层之间的绘制互不干扰，由GPU直接控制</li>
<li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li>
</ul>
<p>更多参考：</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012925872#articleHeader16">普通图层和复合图层</a></p>
<h3 id="Chrome中的调试">Chrome中的调试</h3>
<p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617163457951.png" alt="image-20240617163457951"></p>
<h3 id="资源外链的下载">资源外链的下载</h3>
<p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p>
<p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p>
<ul>
<li>CSS样式资源</li>
<li>JS脚本资源</li>
<li>img图片类资源</li>
</ul>
<p><strong>遇到外链时的处理</strong></p>
<p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p>
<p><strong>遇到CSS样式资源</strong></p>
<p>CSS资源的处理有几个特点：</p>
<ul>
<li>CSS下载时异步，不会阻塞浏览器构建DOM树</li>
<li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li>
<li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li>
</ul>
<p><strong>遇到JS脚本资源</strong></p>
<p>JS脚本资源的处理有几个特点：</p>
<ul>
<li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li>
<li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li>
<li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li>
</ul>
<p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p>
<p>简单的说（不展开）：</p>
<ul>
<li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li>
<li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li>
</ul>
<p><strong>遇到img图片类资源</strong></p>
<p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p>
<h3 id="loaded和domcontentloaded">loaded和domcontentloaded</h3>
<p>简单的对比：</p>
<ul>
<li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li>
<li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li>
</ul>
<h2 id="CSS的可视化格式模型">CSS的可视化格式模型</h2>
<p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong></p>
<p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong></p>
<p>先了解：</p>
<ul>
<li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li>
<li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li>
<li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li>
</ul>
<p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p>
<p>关键字：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（<span class="built_in">Containing</span> <span class="built_in">Block</span>）</span><br><span class="line">控制框（<span class="variable">Controlling</span> <span class="built_in">Box</span>）</span><br><span class="line"><span class="variable">BFC</span>（<span class="built_in">Block</span> <span class="variable">Formatting</span> <span class="built_in">Context</span>）</span><br><span class="line"><span class="variable">IFC</span>（<span class="variable">Inline</span> <span class="variable">Formatting</span> <span class="built_in">Context</span>）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p>
<h3 id="包含块（Containing-Block）">包含块（Containing Block）</h3>
<p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。</p>
<p>元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</p>
<p>譬如：</p>
<ul>
<li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li>
<li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li>
<li>fixed的包含块是当前可视窗口</li>
<li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建
<ul>
<li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li>
<li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li>
</ul>
</li>
</ul>
<h3 id="控制框（Controlling-Box）">控制框（Controlling Box）</h3>
<p>块级元素和块框以及行内元素和行框的相关概念</p>
<p><strong>块框:</strong></p>
<ul>
<li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li>
<li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li>
</ul>
<p>关于<strong>匿名块框</strong>的生成，示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;DIV&gt;</span></span><br><span class="line"><span class="attribute">Some</span> text</span><br><span class="line"><span class="section">&lt;P&gt;</span><span class="attribute">More</span> text</span><br><span class="line"><span class="section">&lt;/DIV&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p>
<p>换句话说:</p>
<p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p>
<p><strong>行内框：</strong></p>
<ul>
<li>一个行内元素生成一个行内框</li>
<li>行内元素能排在一行，允许左右有其它元素</li>
</ul>
<p>关于<strong>匿名行内框</strong>的生成，示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>Some <span class="tag">&lt;<span class="name">EM</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="name">EM</span>&gt;</span> text<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some </code>，<code> text</code>，此时会专门为这些文本生成匿名行内框</p>
<p><strong>display属性的影响</strong></p>
<p><code>display</code>的几个属性也可以影响不同框的生成：</p>
<ul>
<li><code>block</code>，元素生成一个块框</li>
<li><code>inline</code>，元素产生一个或多个的行内框</li>
<li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li>
<li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li>
</ul>
<p>总结：</p>
<ul>
<li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li>
<li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li>
</ul>
<h3 id="BFC（Block-Formatting-Context）">BFC（Block Formatting Context）</h3>
<p>FC（格式上下文）？</p>
<p>FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FC</span>像是一个大箱子，里面装有很多元素</span><br><span class="line"></span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响<span class="built_in">FC</span>内部的渲染）</span><br><span class="line"></span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure>
<p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC</p>
<p><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong></p>
<p><strong>BFC规则：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line"></span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line"></span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line"></span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure>
<p>总结几点BFC特点：</p>
<ol>
<li>内部<code>box</code>在垂直方向，一个接一个的放置</li>
<li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li>
<li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>
<li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li>
</ol>
<p>如何触发BFC？</p>
<ol>
<li>根元素</li>
<li><code>float</code>属性不为<code>none</code></li>
<li><code>position</code>为<code>absolute</code>或<code>fixed</code></li>
<li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li>
<li><code>overflow</code>不为<code>visible</code></li>
</ol>
<p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC</p>
<p>更多请自行网上搜索</p>
<h3 id="IFC（Inline-Formatting-Context）">IFC（Inline Formatting Context）</h3>
<p>IFC即行内框产生的格式上下文</p>
<p><strong>IFC规则</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line"></span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line"></span><br><span class="line">水平方向上的 <span class="attribute">margin</span>，<span class="attribute">border</span> 和 <span class="attribute">padding</span> 在框之间得到保留</span><br><span class="line"></span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure>
<p><strong>行框</strong></p>
<p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p>
<p>行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定</p>
<p>行框的规则：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line"></span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line"></span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line"></span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure>
<p><strong>结合补充下IFC规则：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line"></span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line"></span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line"></span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `<span class="attribute">text-align</span>` 特性</span><br><span class="line"></span><br><span class="line">空的行内框应该被忽略</span><br><span class="line"></span><br><span class="line">即不包含文本，保留空白符，<span class="attribute">margin</span>/<span class="attribute">padding</span>/<span class="attribute">border</span>非<span class="number">0</span>的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>行内元素总是会应用IFC渲染规则</li>
<li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li>
<li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li>
<li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li>
<li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li>
</ul>
<p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）</p>
<p>但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解</p>
<h3 id="其它">其它</h3>
<p>当然还有有一些其它内容：</p>
<ul>
<li>譬如常规流，浮动，绝对定位等区别</li>
<li>譬如浮动元素不包含在常规流中</li>
<li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li>
<li>譬如<code>z-index</code>的分层显示机制等</li>
</ul>
<p>这里不一一展开，更多请参考：</p>
<p><a target="_blank" rel="noopener" href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a></p>
<h2 id="JS引擎解析过程">JS引擎解析过程</h2>
<p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）</p>
<h3 id="JS的解释阶段">JS的解释阶段</h3>
<p>首先得明确： <strong>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</strong></p>
<p>补充：</p>
<p><strong>编译型语言</strong>：<br>
在编译型语言中，<strong>代码在执行前需要通过编译器转换为机器语言</strong>。这个转换过程被称为编译，它通常在代码运行前完成。一旦代码被编译，就可以直接在机器上运行，无需再次编译。编译型语言的优点是运行速度快，因为它直接运行机器代码。而缺点是跨平台性较差，不同的操作系统或硬件平台需要单独编译。C和C++是典型的编译型语言。</p>
<p><strong>解释型语言</strong>：<br>
在解释型语言中，<strong>代码不是在运行前编译的，而是通过解释器在运行时逐行解释和执行</strong>。解释型语言的优点是跨平台性好，同一份代码可以在不同的平台上运行，只要这个平台上有对应的解释器。而缺点是运行速度相对较慢，因为需要逐行解释执行。Python和JavaScript是典型的解释型语言。</p>
<p><strong>Version1：</strong></p>
<p>引擎对JS的处理过程可以简述如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure>
<p><strong>Version2：</strong></p>
<p>JavaScript引擎的工作流程大致如下：</p>
<ol>
<li><strong>解析阶段</strong>：JS引擎首先会解析JavaScript代码，将其转化为一个叫做抽象语法树（AST）的数据结构。这个AST会包含所有的变量、函数、操作符以及它们之间的关系。</li>
<li><strong>编译阶段</strong>：然后，JS引擎会将AST编译为字节码或者直接编译为机器代码。这一步使得代码可以被计算机硬件执行。</li>
<li><strong>执行阶段</strong>：最后，JS引擎执行编译后的代码。</li>
</ol>
<p>值得一提的是，现代的JS引擎，比如V8（被Chrome和Node.js使用）或SpiderMonkey（被Firefox使用），使用了一种叫做即时编译（JIT）的技术，可以在JavaScript代码执行的同时进行编译，大大提高了代码的执行效率。</p>
<hr>
<p>最终计算机执行的就是机器码。</p>
<p>为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）</p>
<p>即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）</p>
<p>这样整个程序的运行速度能得到显著提升。</p>
<p>而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）</p>
<p>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行</strong></p>
<h3 id="JS的预处理阶段">JS的预处理阶段</h3>
<p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等）</p>
<p>预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：</p>
<p><strong>分号补全</strong></p>
<p>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>原因就是JS解释器有一个<a target="_blank" rel="noopener" href="http://inimino.org/~inimino/blog/javascript_semicolons">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号</p>
<p>譬如列举几条自动加分号的规则：</p>
<ul>
<li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li>
<li>当有<code>&#125;</code>时，如果缺少分号，会补分号。</li>
<li>程序源代码结束时，如果缺少分号，会补分号。</li>
</ul>
<p>于是，上述的代码就变成了</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>所以可以正常运行</p>
<p>当然了，这里有一个经典的例子：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">b</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="type">&#123;</span></span><br><span class="line">        a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于分号补全机制，所以它变成了：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以运行后是<code>undefined</code></p>
<p><strong>变量提升</strong></p>
<p>一般包括函数提升和变量提升</p>
<p>譬如：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<p>经过变量提升后，就变成：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
<p>这里没有展开，其实展开也可以牵涉到很多内容的</p>
<p>譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等</p>
<h3 id="JS的执行阶段">JS的执行阶段</h3>
<p>此阶段的内容中的图片来源：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a></p>
<p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p>
<ul>
<li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li>
<li>VO（变量对象）和AO（活动对象）</li>
<li>作用域链</li>
<li>this机制等</li>
</ul>
<p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p>
<p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p>
<p><strong>执行上下文简单解释</strong></p>
<ul>
<li>JS有<code>执行上下文</code>）</li>
<li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li>
<li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li>
<li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li>
<li>这样依次执行（最终都会回到全局执行上下文）</li>
</ul>
<p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617164435479.png" alt="image-20240617164435479"></p>
<p>然后执行上下文与VO，作用域链，this的关系是：</p>
<p>每一个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(<code>Variable object，VO</code>)</li>
<li>作用域链(<code>Scope chain</code>)</li>
<li><code>this</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617164445984.png" alt="image-20240617164445984"></p>
<p><strong>VO与AO</strong></p>
<p>VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong></p>
<p>AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了</p>
<p>可以理解为：</p>
<ul>
<li>在函数上下文中：<code>VO === AO</code></li>
<li>在全局上下文中：<code>VO === this === global</code></li>
</ul>
<p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）</p>
<p><strong>作用域链</strong></p>
<p>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。</p>
<p>譬如流程简述：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line"></span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line"></span><br><span class="line">否则去它的父级作用域链中（<span class="emphasis">__parent__</span>）找</span><br><span class="line"></span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line"></span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240617164504825.png" alt="image-20240617164504825"></p>
<p><strong>this指针</strong></p>
<p>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分</p>
<p>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong></p>
<p>因此:</p>
<ul>
<li>this是没有一个类似搜寻变量的过程</li>
<li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li>
<li>this的值只取决中进入上下文时的情况</li>
</ul>
<p>所以经典的例子：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    <span class="attr">baz</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.<span class="built_in">log</span>(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = bar.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入环境：global</span></span><br><span class="line">foo(); <span class="comment">// 200，严格模式中会报错，Cannot read property &#x27;baz&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入环境：global bar</span></span><br><span class="line">bar.foo(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>就要明白了上面this的介绍，上述例子很好理解</p>
<p>更多参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html">深入理解JavaScript系列（13）：This? Yes,this!</a></p>
<h3 id="回收机制">回收机制</h3>
<p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。</p>
<p>一般来说，垃圾处理器有自己的回收策略。</p>
<p>譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）</p>
<p>常用的两种垃圾回收规则是：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p>
<ol>
<li>遍历所有可访问的对象。</li>
<li>回收已不可访问的对象。</li>
</ol>
<p>譬如：（出自javascript高程）</p>
<blockquote>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</p>
</blockquote>
<blockquote>
<p>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p>
</blockquote>
<blockquote>
<p>而当变量离开环境时，则将其标记为“离开环境”。</p>
</blockquote>
<blockquote>
<p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</p>
</blockquote>
<blockquote>
<p>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。</p>
</blockquote>
<blockquote>
<p>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</p>
</blockquote>
<blockquote>
<p>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
</blockquote>
<p>关于引用计数，简单点理解：</p>
<p><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数<code>+1</code>，减持时<code>-1</code>，下次垃圾回收器会回收次数为<code>0</code>的值的内存（当然了，容易出循环引用的bug）</strong></p>
<p><strong>GC的缺陷</strong></p>
<p>和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong></p>
<p>这是为了安全考虑。</p>
<p>而Javascript的GC在<code>100ms</code>甚至以上</p>
<p>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。</p>
<p>这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong></p>
<p><strong>GC优化策略</strong></p>
<p>这里介绍常用到的：<strong>分代回收（Generation GC）</strong></p>
<p>目的是通过区分“临时”与“持久”对象:</p>
<ul>
<li>多回收“临时对象”区（<code>young generation</code>）</li>
<li>少回收“持久对象”区（<code>tenured generation</code>）</li>
<li>减少每次需遍历的对象，从而减少每次GC的耗时。</li>
</ul>
<p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）</p>
<p>更多可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33816534">V8 内存浅析</a></p>
<p>JavaScript可以用来做以下事情：</p>
<ol>
<li><strong>动态修改HTML和CSS</strong>：JavaScript可以动态地改变HTML的内容和CSS的样式，从而使网页内容更加丰富和生动。</li>
<li><strong>处理用户交互</strong>：JavaScript可以响应用户的操作，比如点击、滑动、键盘输入等，使得网页具有更好的交互性。</li>
<li><strong>创建动画和游戏</strong>：JavaScript可以用来制作动画、小游戏等，提高用户的使用体验。</li>
<li><strong>与服务器交互</strong>：JavaScript可以通过Ajax技术向服务器发送请求或接收数据，实现网页的异步更新。</li>
</ol>
<p>本文学习自：<a target="_blank" rel="noopener" href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>页面加载过程细说</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/d312cb1f.html">https://penge666.github.io/posts/d312cb1f.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-06-15</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-06-17</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>计算机网络</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8ed57ebe.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_37.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">内存回收</div></div></a></div><div class="next-post pull-right"><a href="/posts/68ad5ab4.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_61.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Kafka核心知识总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/b032cb51.html" title="Linux网络:I&#x2F;O多路复用-[select&#x2F;poll&#x2F;epoll]"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_2.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-09-07</div><div class="title">Linux网络:I&#x2F;O多路复用-[select&#x2F;poll&#x2F;epoll]</div></div></a></div><div><a href="/posts/51aeee82.html" title="TCP协议"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_118.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-24</div><div class="title">TCP协议</div></div></a></div><div><a href="/posts/9b06a28b.html" title="HTTP队头阻塞"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_25.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-27</div><div class="title">HTTP队头阻塞</div></div></a></div><div><a href="/posts/f5ef6bcf.html" title="HTTP学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_23.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-09-11</div><div class="title">HTTP学习笔记</div></div></a></div><div><a href="/posts/d78d2a72.html" title="HTTP通信过程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-15</div><div class="title">HTTP通信过程</div></div></a></div><div><a href="/posts/db38782f.html" title="模块1:通信协议综述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_17.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-22</div><div class="title">模块1:通信协议综述</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A2%B3%E7%90%86%E4%B8%BB%E5%B9%B2%E6%B5%81%E7%A8%8B"><span class="toc-text">梳理主干流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A5%E6%94%B6url%E5%88%B0%E5%BC%80%E5%90%AF%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%BA%BF%E7%A8%8B"><span class="toc-text">从浏览器接收url到开启网络请求线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">多进程的浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-text">多线程的浏览器内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90URL"><span class="toc-text">解析URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%83%BD%E6%98%AF%E5%8D%95%E7%8B%AC%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">网络请求都是单独的线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%8F%91%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82"><span class="toc-text">开启网络线程到发出一个完整的http请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E6%9F%A5%E8%AF%A2%E5%BE%97%E5%88%B0IP"><span class="toc-text">DNS查询得到IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-ip%E8%AF%B7%E6%B1%82"><span class="toc-text">tcp&#x2F;ip请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%B1%82%E5%9B%A0%E7%89%B9%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-text">五层因特网协议栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E8%AF%B7%E6%B1%82%E5%88%B0%E5%AF%B9%E5%BA%94%E5%90%8E%E5%8F%B0%E6%8E%A5%E6%94%B6%E5%88%B0%E8%AF%B7%E6%B1%82"><span class="toc-text">从服务器接收到请求到对应后台接收到请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">后台的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%92%8C%E5%89%8D%E5%8F%B0%E7%9A%84http%E4%BA%A4%E4%BA%92"><span class="toc-text">后台和前台的http交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">http报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="toc-text">cookie以及优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip%E5%8E%8B%E7%BC%A9"><span class="toc-text">gzip压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">长连接与短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-2-0"><span class="toc-text">http 2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https"><span class="toc-text">https</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-text">http的缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%BC%B1%E7%BC%93%E5%AD%98"><span class="toc-text">强缓存与弱缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%A4%B4%E9%83%A8%E7%AE%80%E8%BF%B0"><span class="toc-text">缓存头部简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">头部的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B"><span class="toc-text">解析页面流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="toc-text">流程简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML%E8%A7%A3%E6%9E%90%EF%BC%8C%E6%9E%84%E5%BB%BADOM"><span class="toc-text">HTML解析，构建DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90CSS%E8%A7%84%E5%88%99"><span class="toc-text">生成CSS规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93%E6%A0%91"><span class="toc-text">构建渲染树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-text">渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%82%E4%B8%8E%E5%A4%8D%E5%90%88%E5%B1%82"><span class="toc-text">简单层与复合层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome%E4%B8%AD%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-text">Chrome中的调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%A4%96%E9%93%BE%E7%9A%84%E4%B8%8B%E8%BD%BD"><span class="toc-text">资源外链的下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loaded%E5%92%8Cdomcontentloaded"><span class="toc-text">loaded和domcontentloaded</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="toc-text">CSS的可视化格式模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%9D%97%EF%BC%88Containing-Block%EF%BC%89"><span class="toc-text">包含块（Containing Block）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A1%86%EF%BC%88Controlling-Box%EF%BC%89"><span class="toc-text">控制框（Controlling Box）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%EF%BC%88Block-Formatting-Context%EF%BC%89"><span class="toc-text">BFC（Block Formatting Context）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IFC%EF%BC%88Inline-Formatting-Context%EF%BC%89"><span class="toc-text">IFC（Inline Formatting Context）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">JS引擎解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E8%A7%A3%E9%87%8A%E9%98%B6%E6%AE%B5"><span class="toc-text">JS的解释阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-text">JS的预处理阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-text">JS的执行阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">回收机制</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/分布式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Kevinの分布式学习笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 Kevinの操作系统笔记 (20)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据结构/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (11)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>