<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Cpp面经 | Penge666</title><meta name="keywords" content="Cpp"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Cpp基础部分">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp面经">
<meta property="og:url" content="https://penge666.github.io/posts/680a3d55.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="Cpp基础部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_22.webp">
<meta property="article:published_time" content="2024-05-13T12:35:09.000Z">
<meta property="article:modified_time" content="2024-05-14T02:18:32.392Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_22.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/680a3d55"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cpp面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-14 10:18:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Cpp面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-05-13T12:35:09.000Z" title="发表于 2024-05-13 20:35:09">2024-05-13</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-14T02:18:32.392Z" title="更新于 2024-05-14 10:18:32">2024-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.8w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Cpp面经"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="C-98"><a href="#C-98" class="headerlink" title="C++98"></a>C++98</h2><h3 id="1-在main执行的前后需要处理什么工作？"><a href="#1-在main执行的前后需要处理什么工作？" class="headerlink" title="1. 在main执行的前后需要处理什么工作？"></a>1. 在main执行的前后需要处理什么工作？</h3><p><strong>Main函数之前</strong></p>
<p>(1) 设置栈指针</p>
<p>(2) 全局对象初始化，在main之前调用构造函数</p>
<p>(3) 将main函数的参数argc，argv等传递给main函数</p>
<p><strong>Main函数之后</strong></p>
<p>全局对象的析构函数</p>
<h3 id="2-什么是内存对齐？"><a href="#2-什么是内存对齐？" class="headerlink" title="2.什么是内存对齐？"></a>2.什么是内存对齐？</h3><p>学习自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解</a></p>
<p>还是得看例子：【从例子解释概念】</p>
<p>还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(s);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。</p>
<p>精简：</p>
<p>(1) 在计算机中，内存是按字节划分的，而CPU在读取数据时，并不是一个字节一个字节的读取，实际上是<strong>按块的大小读取</strong>，块大小可以是2，4，8，16等等，称为内存访问粒度。</p>
<p>(2) 内存对齐则是将特定的数据类型按照一定的规则摆放在内存上，具体规则是按照变量的声明顺序，依次安排内存，其偏移量为变量大小的整数倍。</p>
<h3 id="3-为什么要做内存对齐？"><a href="#3-为什么要做内存对齐？" class="headerlink" title="3. 为什么要做内存对齐？"></a>3. 为什么要做内存对齐？</h3><p>这个的话展开说就是：</p>
<p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p>
<p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p>
<p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204345153.png" alt="image-20240513204345153"></p>
<p>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204405396.png" alt="image-20240513204405396"></p>
<p>精简：</p>
<p>(1) <strong>平台原因(移植原因)：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>(2) <strong>性能原因：</strong>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<h3 id="4-说说内存对齐规则？"><a href="#4-说说内存对齐规则？" class="headerlink" title="4. 说说内存对齐规则？"></a>4. 说说内存对齐规则？</h3><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p>
<p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p>
<p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
<p>(3) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<p>下面给出几个例子以便于理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2; </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上测试都是在Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节，下面根据上面所说的规则以s2来分析其内存布局：</p>
<p>首先使用规则1，对成员变量进行对齐：</p>
<p>sizeof(c1) = 1 &lt;= 4(有效对齐位)，按照1字节对齐，占用第0单元；</p>
<p>sizeof(i) = 4 &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为4的倍数，占用第4，5，6，7单元；</p>
<p>sizeof(c2) = 1 &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元；</p>
<p>然后使用规则2，对结构体整体进行对齐：</p>
<p>s2中变量i占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到s2占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。</p>
<p>根据上面的分析，不难得出上面例子三个结构体的内存布局如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204725927.png" alt="image-20240513204725927"></p>
<p><strong>#pragma pack(n)</strong></p>
<p>不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数。</p>
<p>例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204744215.png" alt="image-20240513204744215"></p>
<p>如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204752271.png" alt="image-20240513204752271"></p>
<p>经过上面的实例分析，大家应该对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。</p>
<p>精简：</p>
<p>(1) 每个特定平台上的编译器都有自己的默认<strong>“对齐系数”（也叫对齐模数）</strong>。32位系统，gcc中默认#pragma pack(4)，即对齐系数默认为4。可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p>
<p>(2) 有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中<strong>较小</strong>的那个。<strong>有效对齐值也叫对齐单位</strong>。</p>
<p>(3) 结构体第一个成员的偏移量为0，以后每个成员相对于结构体首地址的偏移量都是该成员大小与有效对齐值中<strong>较小</strong>数的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
<p>(4) 结构体的总大小为<strong>有效对齐值的整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<h3 id="5-指针和引用的区别？"><a href="#5-指针和引用的区别？" class="headerlink" title="5. 指针和引用的区别？"></a>5. 指针和引用的区别？</h3><p>(1) 指针是一个变量，存储的是一个地址。引用跟原来的变量实质上是同一个东西，是原变量的别名</p>
<p>(2) 指针可以有多级，引用只有一级</p>
<p>(3) 指针可以为空，引用不能为NULL且在定义时必须初始化</p>
<p>(4) 指针在初始化后可以改变指向，而引用在初始化之后不可再改变</p>
<p>(5) sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140966943">C++中指针与引用的区别</a></li>
</ul>
<h3 id="6-堆和栈的区别？"><a href="#6-堆和栈的区别？" class="headerlink" title="6. 堆和栈的区别？"></a>6. 堆和栈的区别？</h3><p>(1) 栈由系统自动分配，堆是自己申请和释放的。</p>
<p>(2) 堆向上，向高地址方向增长。栈向下，向低地址方向增长。</p>
<p>(3) 在空间连续性上，栈区的空间是连续的；但堆的空间是不连续的。</p>
<p>(4) 堆只能动态分配。栈有静态分配和动态分配，静态分配由编译器完成，动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</p>
<p>(5) 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p>
<p>(6) 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h3 id="7-new-delete-与-malloc-free的异同？"><a href="#7-new-delete-与-malloc-free的异同？" class="headerlink" title="7. new / delete 与 malloc / free的异同？"></a>7. new / delete 与 malloc / free的异同？</h3><p>(1) 都可用于内存的动态申请和释放</p>
<p>(2) 前者是C++运算符，后者是C/C++语言标准库函数</p>
<p>(3) new自动计算要分配的空间大小，malloc需要手工计算</p>
<p>(4) new是类型安全的，malloc不是。</p>
<p>(5) new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始类型的内存，接下来在该内存上调用构造函数初始化对象；最后返回该内存指针。</p>
<p>(6) delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存</p>
<p>(7) malloc/free可重载，new/delete不可重载，operator new/operator delete可重载</p>
<h3 id="8-被free回收的内存是立即返还给操作系统吗？"><a href="#8-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="8. 被free回收的内存是立即返还给操作系统吗？"></a>8. 被free回收的内存是立即返还给操作系统吗？</h3><p>不会，new或者malloc申请内存是向内存管理器申请，内存管理器再向操作系统申请，这里面涉及到系统调用，如果频繁的申请释放，效率会很低，所以一般进程申请了内存后，释放资源后并不会立即将内存还给操作系统，而是放到一个类似于内存缓存池的地方，下次申请的时候首先会在内存缓存池中查找合适的内存，减少了大量的系统调用，提高速度。</p>
<h3 id="9-宏函数和普通函数有何区别？"><a href="#9-宏函数和普通函数有何区别？" class="headerlink" title="9. 宏函数和普通函数有何区别？"></a>9. 宏函数和普通函数有何区别？</h3><p>(1) 宏函数作用在预编译期，进行文本替换，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；普通函数调用在运行时需要跳转到具体调用函数。</p>
<p>(2) 宏函数属于在结构中插入代码，没有返回值；普通函数调用具有返回值。</p>
<p>(3) 宏函数参数没有类型，不进行类型检查；普通函数参数具有类型，需要检查类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义，没有类型检查</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，有类型检查</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.5</span>;</span><br><span class="line">    <span class="comment">// 使用宏，虽然y的类型不是整数，但仍然可以计算</span></span><br><span class="line">    <span class="type">double</span> r1 = <span class="built_in">SQUARE</span>(y);  <span class="comment">// 结果是2.25</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数，如果尝试将y作为参数，编译器会报错，因为y的类型与函数期望的类型不匹配</span></span><br><span class="line">    <span class="type">int</span> r2 = <span class="built_in">square</span>(y);  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>SQUARE(x)</code>是一个宏，它接受任何类型的参数<code>x</code>，并返回<code>x</code>的平方。因为宏没有类型检查，所以你可以传递任何类型的参数给宏，编译器不会报错。</p>
<p>但是，<code>square(x)</code>是一个函数，它期望一个整数类型的参数<code>x</code>。如果你尝试将一个非整数类型的值（如<code>double</code>类型的值）传递给这个函数，编译器会报错，因为函数参数的类型检查失败。</p>
<h3 id="10-宏定义和typedef有何区别？"><a href="#10-宏定义和typedef有何区别？" class="headerlink" title="10. 宏定义和typedef有何区别？"></a>10. 宏定义和typedef有何区别？</h3><p>(1) 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
<p>(2) 宏替换发生在预编译期，属于文本插入替换；typedef是编译的一部分。</p>
<p>(3) 宏不检查类型；typedef会检查数据类型。</p>
<h3 id="11-宏定义和const的区别？"><a href="#11-宏定义和const的区别？" class="headerlink" title="11. 宏定义和const的区别？"></a>11. 宏定义和const的区别？</h3><p>(1) 宏定义发生在预编译期。const是在编译、运行的时候起作用</p>
<p>(2) 宏定义只做替换，不做类型检查和计算。const常量有数据类型，编译器做类型检查。</p>
<p>(3) define只是将宏名称进行文本替换，占用代码段内存。const在程序运行中只有一份备份，占用数据段内存。</p>
<h3 id="12-内联函数和宏函数的区别？"><a href="#12-内联函数和宏函数的区别？" class="headerlink" title="12. 内联函数和宏函数的区别？"></a>12. 内联函数和宏函数的区别？</h3><p>(1) 宏函数在预处理阶段进行文本替换，inline函数在编译阶段进行替换</p>
<p>(2) inline函数有类型检查，相比宏函数比较安全</p>
<p>(3) Inline函数具有返回值，宏函数没有</p>
<h3 id="13-变量声明和定义的区别？"><a href="#13-变量声明和定义的区别？" class="headerlink" title="13. 变量声明和定义的区别？"></a>13. 变量声明和定义的区别？</h3><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间。只有在定义处才为其分配存储空间。<strong>相同变量可以在多处声明，但只能在一处定义</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>isOK!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-strlen和sizeof的区别？"><a href="#14-strlen和sizeof的区别？" class="headerlink" title="14. strlen和sizeof的区别？"></a>14. strlen和sizeof的区别？</h3><p>(1) sizeof是C/C++操作符，并不是函数，结果在编译时得到。strlen是字符处理的库函数。</p>
<p>(2) sizeof参数可以是任何数据的类型或者数据。strlen的参数只能是字符指针，它指向了一个结尾是’\0’的字符串。</p>
<h3 id="15-常量指针和指针常量的区别？"><a href="#15-常量指针和指针常量的区别？" class="headerlink" title="15. 常量指针和指针常量的区别？"></a>15. 常量指针和指针常量的区别？</h3><p>(1) 指针常量（底层const）是一个指针，它指向了一个只读值。它实际上只是限制了指针的拥有者不能通过指针修改它所指向的值，对这个值的属性没有限制，这个值是可以是常量也可以变量，均不影响。</p>
<p>(2) 常量指针（顶层const）是一个不能给改变指向的指针，即我们可以通过指针修改它所指向的值，但不能修改指针的指向。</p>
<p>详细说明：</p>
<p><strong>指针常量</strong></p>
<p>指针常量：顾名思义它就是一个常量，但是是指针修饰的。</p>
<p>格式为：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> p <span class="comment">//指针常量</span></span><br><span class="line">在这个例子下定义以下代码：</span><br></pre></td></tr></table></figure>
<p>在这个例子下定义以下代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a，b；</span><br><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</span></span><br></pre></td></tr></table></figure>
<p><strong>常量指针</strong></p>
<p>常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> *p = &amp;a; <span class="comment">//常量指针</span></span><br><span class="line">在这个例子下定义以下代码：</span><br></pre></td></tr></table></figure>
<p>在这个例子下定义以下代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a，b；</span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure>
<p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p>
<p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p>
<h3 id="16-指针常量能不能赋值给非指针常量？"><a href="#16-指针常量能不能赋值给非指针常量？" class="headerlink" title="16. 指针常量能不能赋值给非指针常量？"></a>16. 指针常量能不能赋值给非指针常量？</h3><p>不能，指针常量限制了指针的拥有者不能通过指针修改它所指向的值，如果指针常量可以赋值给非指针常量，那就意味着拥有者可以使用这种方法获取写权限，这在语义上是冲突的。</p>
<h3 id="17-C-和Python的区别？"><a href="#17-C-和Python的区别？" class="headerlink" title="17. C++和Python的区别？"></a>17. C++和Python的区别？</h3><p>(1) Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。</p>
<p>(2) python可以很方便的跨平台，但是效率没有C++高。</p>
<p>(3) C++中需要事先定义变量的类型，而Python不需要</p>
<p>(4) Python的库函数比C++的多，调用起来很方便</p>
<h3 id="18-C-中struct和class的区别？"><a href="#18-C-中struct和class的区别？" class="headerlink" title="18. C++中struct和class的区别？"></a>18. C++中struct和class的区别？</h3><p>(1) 两者都拥有成员函数、公有和私有部分</p>
<p>(2) 任何可以使用class完成的工作，同样可以使用struct完成</p>
<p>(3) 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p>
<p>(4) class默认是private继承，而struct模式是public继承</p>
<h3 id="19-C-和C的struct的区别？"><a href="#19-C-和C的struct的区别？" class="headerlink" title="19. C++和C的struct的区别？"></a>19. C++和C的struct的区别？</h3><p>C语言：struct是用户自定义数据类型（UDT），不能设置权限，成员不可以是函数，不能被继承。</p>
<p>C++：struct是抽象数据类型（ADT）支持成员函数的定义，能设置权限，能被继承与实现多态。</p>
<h3 id="20-C-中const和static的作用？"><a href="#20-C-中const和static的作用？" class="headerlink" title="20. C++中const和static的作用？"></a>20. C++中const和static的作用？</h3><p><strong>(1) Static（类外）：</strong></p>
<p>①　隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他模块中使用，加了之后只能在该文件所在的编译模块中使用</p>
<p>②　静态变量没有定义初始值时，会初始化为0。</p>
<p>③　静态变量在函数内定义，生命周期跟随程序（同全局变量），且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</p>
<p><strong>(2) Static（类内）：</strong></p>
<p>①　static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化， 必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</p>
<p>②　static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问</p>
<p><strong>(3) Const（类外）：</strong></p>
<p>①　const常量在定义时必须初始化，之后无法更改</p>
<p>②　const形参可以接收const和非const类型的实参</p>
<p><strong>(4) Const（类内）：</strong></p>
<p>①　const成员变量：只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</p>
<p>②　const成员函数：const类对象不可以调用类中的非const成员函数；非const类对象则均可调用；const成员函数不可以改变类中非mutable数据成员的值。</p>
<p>举例说明</p>
<p>在C++中，<code>const</code>和<code>static</code>都是修饰符，它们可以用来修改变量、函数或对象的行为。</p>
<ul>
<li><code>const</code>: <code>const</code>关键字可以用来修饰变量，表示这个变量的值是常量，不能被修改。在类中，如果一个成员函数被声明为<code>const</code>，那么这个函数不能修改类的任何成员变量（除非这个变量是<code>mutable</code>的）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x = a;  // Error, can&#x27;t modify x in a const function</span></span><br><span class="line">        y = a;  <span class="comment">// OK, y is mutable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static</code>: <code>static</code>关键字在类中有两种用法。一种是修饰成员变量，这样这个变量就变成了一个静态成员变量，它不属于类的任何对象，而是属于类本身，所有的对象都共享这一个变量。另一种是修饰成员函数，这样这个函数就变成了一个静态成员函数，它可以在不创建对象的情况下被调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::x = <span class="number">0</span>;  <span class="comment">// Define static member variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">setX</span>(<span class="number">10</span>);  <span class="comment">// Call static member function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从类外部来看，<code>const</code>和<code>static</code>修饰的成员变量或函数可以通过类名直接访问（对于<code>static</code>），或者通过对象访问但不能修改（对于<code>const</code>）。</p>
<h3 id="21-数组名和指针（这里为指向数组首元素的指针）的区别？"><a href="#21-数组名和指针（这里为指向数组首元素的指针）的区别？" class="headerlink" title="21.数组名和指针（这里为指向数组首元素的指针）的区别？"></a>21.数组名和指针（这里为指向数组首元素的指针）的区别？</h3><p>(1) 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</p>
<p>(2) 二者均可通过增减偏移量来访问数组中的元素。</p>
<p>(3) 数组名不是真正意义上的指针，实际上是一个常量指针，所以不能进行自增自减操作。</p>
<p>(4) 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作， 但sizeof运算符不能再得到原数组的大小了。</p>
<h3 id="22-C代码使用C语言编译和C-编译有什么不同？"><a href="#22-C代码使用C语言编译和C-编译有什么不同？" class="headerlink" title="22. C代码使用C语言编译和C++编译有什么不同？"></a>22. C代码使用C语言编译和C++编译有什么不同？</h3><p>(1) C++虽然语法上支持和兼容C语言，但为了支持多种特性，在编译上却做了很多C语言所没有的其他处理。</p>
<p>(2) 比如说现在有一个C语言函数库，而我们用C++去调用该函数库，在编译链接时链接器会报错。因为<strong>C++为了支持函数重载，会在编译时给每个函数进行“改名”</strong>，但是C语言在编译时则不会改名，C函数库中的函数名都保持原样，这就会使链接器在函数库中找不到改名后的对应函数地址，然后报错。<strong>extern “C”可以很好地解决这个问题</strong>。</p>
<p>(3) 因为C++的函数改名规则，<strong>C++代码在使用其他模块的函数前必须包含其头文件或显式声明函数</strong>，不然它无法识别该函数是C函数还是C++函数，是否需要进行改名。<strong>C语言编译器即使不提前声明函数也可以调用函数，因为C编译器没有改名规则</strong>。</p>
<h3 id="23-extern”C”的用法？"><a href="#23-extern”C”的用法？" class="headerlink" title="23. extern”C”的用法？"></a>23. extern”C”的用法？</h3><p>在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++，在以下情况时会用到该语法：</p>
<p>(1) <strong>C++代码中调用C语言函数库</strong>；</p>
<p>(2) <strong>在多个人协同开发时，可能有人擅长C语言，而有人擅长C++</strong></p>
<h3 id="24-说说野指针和悬空指针？"><a href="#24-说说野指针和悬空指针？" class="headerlink" title="24. 说说野指针和悬空指针？"></a>24. 说说野指针和悬空指针？</h3><p>(1) <strong>野指针：</strong>指的是没有被初始化过的指针。解决方法：定义指针变量要及时初始化或者置空。（保持良好的编码规范）</p>
<p>(2) <strong>悬空指针：</strong>指针最初指向的内存已经被释放了的一种指针。解决方法：释放操作后立即置空，或者使用智能指针</p>
<p>野指针和空悬指针的区别是野指针是指向未知地址的指针，而空悬指针是指向已经被释放的地址的指针</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *p;</span><br><span class="line">// 此时 p 是“野指针”</span><br></pre></td></tr></table></figure>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *p <span class="operator">=</span> malloc(size)<span class="comment">;</span></span><br><span class="line">assert(p)<span class="comment">;</span></span><br><span class="line">free(p)<span class="comment">; </span></span><br><span class="line">// 现在 p 是“悬空指针”</span><br><span class="line">// 避免“悬空指针”</span><br><span class="line"><span class="attribute">p</span> <span class="operator">=</span> NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="25-C-中的重载、重写（覆盖）和隐藏的区别？"><a href="#25-C-中的重载、重写（覆盖）和隐藏的区别？" class="headerlink" title="25. C++中的重载、重写（覆盖）和隐藏的区别？"></a>25. C++中的重载、重写（覆盖）和隐藏的区别？</h3><p>(1) 重载是指在<strong>同一范围定义中的同名函数</strong>才存在重载关系。主要特点是<strong>函数名相同，参数类型和数目有所不同</strong>，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</p>
<p>(2) 重写指的是在派生类中重写父类的函数体，<strong>要求基类函数必须是虚函数</strong>，且重写的函数签名<strong>（返回值、函数名、参数列表）</strong>必须完全一致。</p>
<p>(3) 隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数。</p>
<p>(4) <strong>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</strong></p>
<p>(5) <strong>隐藏和重写的区别在于基类函数是否是虚函数</strong>。</p>
<h3 id="26-浅拷贝和深拷贝的区别？"><a href="#26-浅拷贝和深拷贝的区别？" class="headerlink" title="26. 浅拷贝和深拷贝的区别？"></a>26. 浅拷贝和深拷贝的区别？</h3><p>(1) 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。如果原来的指针所指向的资源释放了，那么使用新指针就会出现错误。</p>
<p>(2) 深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p>
<h3 id="27-public，protected和private权限的区别？"><a href="#27-public，protected和private权限的区别？" class="headerlink" title="27. public，protected和private权限的区别？"></a>27. public，protected和private权限的区别？</h3><p><strong>(1) 访问权限：</strong></p>
<p>①　public的变量和函数在类的内部外部都可以访问。</p>
<p>②　protected的变量和函数只能在类的内部和其派生类中访问。</p>
<p>③　private修饰的元素只能在类内访问。</p>
<p><strong>(2) 继承权限：</strong></p>
<p>①　Public:基类的公有成员和保护成员作为派生类的成员时，都保持原有的访问权限，基类的私有成员任然是私有的</p>
<p>②　Protected：基类的公有成员和保护成员都成为派生类的保护成员，基类的私有成员仍然是私有的</p>
<p>③　private：基类的公有成员和保护成员都成为派生类的私有成员，基类的私有成员任然是私有的</p>
<p><strong>对于继承权限而言，它所针对的是类外的访问权限。对于类内来说，不管是何种继承，派生类均可访问基类的公用和保护成员，但不可访问基类的私有成员。</strong></p>
<h3 id="28-如何用代码判断大小端存储？"><a href="#28-如何用代码判断大小端存储？" class="headerlink" title="28. 如何用代码判断大小端存储？"></a>28. 如何用代码判断大小端存储？</h3><p>(1) <strong>大端存储：</strong>字数据的高字节存储在低地址中</p>
<p>(2) <strong>小端存储：</strong>字数据的高字节存储在高地址中</p>
<p>(3) <strong>方式一：使用强制类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">0x1234</span>;</span><br><span class="line">	<span class="type">char</span> c=(<span class="type">char</span>)(a);</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="number">0x12</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;big&quot;</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;small&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4) <strong>方式二：使用union联合体</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sxg226273531/article/details/135996096">如何使用联合体判断大小端，详细介绍其内存原理（附完整代码）</a></li>
</ul>
<h3 id="29-volatile、mutable和explicit关键字的用法？"><a href="#29-volatile、mutable和explicit关键字的用法？" class="headerlink" title="29. volatile、mutable和explicit关键字的用法？"></a>29. volatile、mutable和explicit关键字的用法？</h3><p>(1) volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示它可能被某些编译器未知的因素更改</strong>，所以系统总是重新从它所在的内存读取数据而不会去使用内存读取优化（使用寄存器），即使它前面的指令刚刚从该处读取过数据。</p>
<p>【防止编译的时候被优化！每次都得从内存中读取！】</p>
<p>(2) mutable关键字是一种类型修饰符，<strong>被mutable修饰的数据成员表示他可以被const成员函数所修改（const成员函数无法修改类中的普通数据成员）</strong>，它的修改不会影响整个类对象的状态。</p>
<p>(3) <strong>explicit关键字用来修饰类的构造函数，</strong>加上该关键字，表示该类不能发生相应的隐式类型转换（函数调用传参时的类型转换），只能以显式地进行类型转换（调用构造函数） 。</p>
<h3 id="30-C-中有几种类型的new？"><a href="#30-C-中有几种类型的new？" class="headerlink" title="30. C++中有几种类型的new？"></a>30. C++中有几种类型的new？</h3><p>【未看】</p>
<p>在C++中，new有三种典型的使用方法：<strong>plain new，nothrow new和placement new</strong></p>
<p>(1) <strong>plain new</strong>：最普通的new，它在分配内存失败时会抛出std::bad_alloc异常而不是返回NULL</p>
<p>(2) <strong>nothrow new</strong> ：不会抛出异常的new，分配内存失败时返回NULL</p>
<p>(3) <strong>placement new</strong>：不分配内存，只在一块分配好了的内存上调用类的构造函数</p>
<h3 id="31-形参与实参的区别？"><a href="#31-形参与实参的区别？" class="headerlink" title="31. 形参与实参的区别？"></a>31. 形参与实参的区别？</h3><p>(1) <strong>形参在定义时不分配内存，只有在被调用时才分配内存</strong></p>
<p>(2) 实参可以任意形式的表达式，但在进行函数调用时，它们都必须具有确定的值</p>
<p>(3) 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生<strong>“类型不匹配”</strong>的错误</p>
<p>(4) <strong>函数调用中发生的数据传送是单向的。</strong> 即只能把实参的值传送给形参。</p>
<h3 id="32-值传递、指针传递、引用传递的区别和效率？"><a href="#32-值传递、指针传递、引用传递的区别和效率？" class="headerlink" title="32. 值传递、指针传递、引用传递的区别和效率？"></a>32. 值传递、指针传递、引用传递的区别和效率？</h3><p>(1) 值传递：实参的值向形参进行值拷贝，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。</p>
<p>(2) 指针传递：同样有实参的值向形参进行值拷贝，但拷贝的数据是一个固定大小的地址。</p>
<p>(3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。</p>
<p>(4) <strong>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰</strong>。</p>
<h3 id="33-C-有哪几种的构造函数？"><a href="#33-C-有哪几种的构造函数？" class="headerlink" title="33. C++有哪几种的构造函数？"></a>33. C++有哪几种的构造函数？</h3><p>(1) 默认构造函数（无参数）</p>
<p>(2) 初始化构造函数（有参数）</p>
<p>(3) 拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="34-什么情况下会调用拷贝构造函数？"><a href="#34-什么情况下会调用拷贝构造函数？" class="headerlink" title="34. 什么情况下会调用拷贝构造函数？"></a>34. 什么情况下会调用拷贝构造函数？</h3><p>(1) 用类的一个实例对象去初始化构造一个类的新对象的时候</p>
<p>(2) 函数的参数是类的对象时（值传递）</p>
<p>(3) 函数的返回值是函数体内局部对象的类的对象时</p>
<h3 id="35-说说C-中的初始化？"><a href="#35-说说C-中的初始化？" class="headerlink" title="35. 说说C++中的初始化？"></a>35. 说说C++中的初始化？</h3><p>C++中变量的初始化有很多种方式，如：默认初始化，值初始化，直接初始化，拷贝初始化。下面一一介绍。</p>
<p>(1) <strong>默认初始化</strong></p>
<p>①　默认初始化是指定义变量时 没有指定初值时进行的初始化操作。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>②　对于内置类型变量（如int，double，bool等），<strong>如果是全局变量或静态变量，则初始化为0，如果是栈或者堆变量，则将拥有未定义的值</strong>。</p>
<p>③　对于类类型的变量（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发错误。因此，建议为每个类都定义一个默认构造函数（=default）。</p>
<p>④　注意：默认初始化的值并不是绝对的，在一些情况下会产生未知的错误，<strong>一般定义变量时最好都要为它设定初始值，这是一种良好的编程习惯。</strong></p>
<p>(2) <strong>值初始化</strong></p>
<p>①　值初始化是指使用了初始化器（即使用了圆括号或花括号）但却没有提供初始值的情况。</p>
<p>②　特别的，采用动态分配内存的方式（即采用new关键字）创建的变量，不加括号时，如int <em>p=new int，是默认初始化，加了括号，如int </em>p=new int()，为值初始化。</p>
<p>③　若不采用动态分配内存的方式（即不采用new运算符），写成int a();是错误的值初始化方式，因为这种方式是声明了一个函数而不是进行值初始化。如果一定要进行值初始化，必须结合拷贝初始化使用，即写成int a=int()。</p>
<p>④　值初始化和默认初始化一样，对于内置类型初始化为0，对于类类型则调用其默认构造函数，如果没有默认构造函数，则不能进行初始化。</p>
<p>(3) <strong>直接初始化</strong></p>
<p>①　直接初始化是指采用小括号的方式进行变量初始化（小括号里一定要有初始值，如果没提供初始值，那就是值初始化了！）</p>
<p>②　<strong>对于类类型来说，直接初始化会直接调用与实参匹配的构造函数。</strong></p>
<p>(4) <strong>拷贝初始化</strong></p>
<p>①　拷贝初始化是指采用等号（=）进行初始化的方式，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p>
<p>②　拷贝初始化首先使用指定构造函数创建一个临时对象，然后用<strong>拷贝构造函数</strong>将那个临时对象拷贝到正在创建的对象。</p>
<h3 id="36-直接初始化、拷贝初始化、赋值的差别？"><a href="#36-直接初始化、拷贝初始化、赋值的差别？" class="headerlink" title="36. 直接初始化、拷贝初始化、赋值的差别？"></a>36. 直接初始化、拷贝初始化、赋值的差别？</h3><p>(1) 这三种操作非常类似，语法上也很相像，<strong>区分这三者主要看他们的最终调用的函数</strong>。</p>
<p>(2) 直接初始化：<strong>要创建的对象不存在</strong>，主要利用<strong>初始化器（圆括号）</strong>使用其他的初始值进行初始化操作，一般这个初始值是别的对象或数据类型，<strong>直接初始化调用类的构造函数（调用参数类型最佳匹配的那个）</strong>。</p>
<p>(3) 拷贝初始化：<strong>要创建的对象不存在</strong>，使用已有的对象（与创建的对象类型一致）来进行初始化，这个已有的对象既可以是临时对象也可以是其他对象。<strong>既可以使用初始化器（圆括号），也可以使用赋值号（“=”）来进行初始化操作，但他们的背后都会调用类的拷贝构造函数</strong>。</p>
<p>(4) 赋值：<strong>要创建的对象已存在</strong>，用已存在的对象给它赋值，这属于重载“=”号运算符的范畴，他并不是一种初始化操作，<strong>背后调用类的重载“=”运算符函数</strong>。</p>
<p>(5) 对于内置类型变量（如int，double，bool等），直接初始化与拷贝初始化差别可以忽略不计。</p>
<h3 id="37-静态变量什么时候初始化？"><a href="#37-静态变量什么时候初始化？" class="headerlink" title="37. 静态变量什么时候初始化？"></a>37. 静态变量什么时候初始化？</h3><p>视编译器而定，有些可能在代码执行之前就初始化，有些则可能直到代码执行时才初始化。</p>
<h3 id="38-delete、delete-的区别？"><a href="#38-delete、delete-的区别？" class="headerlink" title="38. delete、delete []的区别？"></a>38. delete、delete []的区别？</h3><p>delete只会调用一次析构函数，delete [] 会根据数组元素的数量，对数组中的每个元素调用析构函数。</p>
<h3 id="39-malloc、calloc、realloc的区别？"><a href="#39-malloc、calloc、realloc的区别？" class="headerlink" title="39. malloc、calloc、realloc的区别？"></a>39. malloc、calloc、realloc的区别？</h3><p>(1) <strong>malloc函数</strong>：void* malloc(unsigned int num_size); 需要手动计算分配大小，申请的空间的值是随机初始化的</p>
<p>(2) <strong>calloc函数</strong>：void* calloc(size_t n,size_t size);无需手动计算分配大小，申请的空间的值是初始化为0的</p>
<p>(3) <strong>realloc函数</strong> ：给动态分配的空间分配额外的空间，用于扩充容量。</p>
<p>详细解释：</p>
<p><code>malloc</code>, <code>calloc</code> 和 <code>realloc</code> 都是 C 和 C++ 语言中用来动态分配内存的函数，但它们各有不同的用途和行为。</p>
<ul>
<li><code>malloc</code>: 这是最常用的动态内存分配函数。<code>malloc</code> 接受一个参数，即要分配的字节数，然后返回一个指向新分配内存的指针，或者在无法分配内存时返回 NULL。需要注意的是 <code>malloc</code> 不会清零新分配的内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>calloc</code>: 这个函数与 <code>malloc</code> 类似，但它接受两个参数：要分配的元素数量和每个元素的大小。<code>calloc</code> 会返回一个指向新分配内存的指针，或者在无法分配内存时返回 NULL。与 <code>malloc</code> 不同，<code>calloc</code> 会清零新分配的内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存，并将内存清零</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>realloc</code>: 这个函数用于改变已分配的内存大小。<code>realloc</code> 接受两个参数：一个指向已分配内存的指针和新的内存大小（以字节为单位）。<code>realloc</code> 会返回一个指向新内存的指针，或者在无法分配内存时返回 NULL。如果新的内存大小大于原来的大小，<code>realloc</code> 会保留原来内存的内容，并可能将新的内存部分初始化为零。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存</span></span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 扩大内存以存储20个整数</span></span><br></pre></td></tr></table></figure>
<p>在使用这些函数时，一定要记住在不再需要内存时使用 <code>free</code> 函数释放它，以防止内存泄漏。</p>
<h3 id="40-说说类成员的初始化方式？"><a href="#40-说说类成员的初始化方式？" class="headerlink" title="40. 说说类成员的初始化方式？"></a>40. 说说类成员的初始化方式？</h3><p>(1) <strong>构造函数初始化：</strong>在构造函数体中初始化,在所有的数据成员被分配内存空间后，才进行赋值操作。背后会调用一次数据成员的构造函数和赋值函数。</p>
<p>(2) <strong>初始化列表：</strong>给数据成员分配内存空间时就进行初始化，相比起构造函数初始化，少了一次调用赋值函数的操作，因此效率会更高一些。</p>
<h3 id="41-构造函数的执行顺序？"><a href="#41-构造函数的执行顺序？" class="headerlink" title="41. 构造函数的执行顺序？"></a>41. 构造函数的执行顺序？</h3><p>(1) 基类的构造函数</p>
<p>(2) 派生类的数据成员的构造函数</p>
<p>(3) 派生类自己的构造函数</p>
<h3 id="42-析构函数的执行顺序？"><a href="#42-析构函数的执行顺序？" class="headerlink" title="42. 析构函数的执行顺序？"></a>42. 析构函数的执行顺序？</h3><p>(1) 调用派生类的析构函数；</p>
<p>(2) 调用派生类的数据成员的析构函数；</p>
<p>(3) 调用基类的析构函数。</p>
<h3 id="43-有哪些情况必须使用初始化列表？"><a href="#43-有哪些情况必须使用初始化列表？" class="headerlink" title="43. 有哪些情况必须使用初始化列表？"></a>43. 有哪些情况必须使用初始化列表？</h3><p>要不然进入到括号里面就对象就构造完成了。</p>
<p>(1) 当初始化一个引用成员时</p>
<p>(2) 当初始化一个常量成员时</p>
<p>(3) 当调用一个基类的构造函数，而它拥有一组参数时</p>
<p>(4) 当调用一个成员类的构造函数，而它拥有一组参数时</p>
<h3 id="44-初始化列表的初始化顺序？"><a href="#44-初始化列表的初始化顺序？" class="headerlink" title="44. 初始化列表的初始化顺序？"></a>44. 初始化列表的初始化顺序？</h3><p>这和对象内存有关。</p>
<p>初始化列表中出现的顺序并不是真正的初始化顺序，初始化顺序只取决于成员变量在类中的声明顺序。我们应尽可能保证成员变量的声明顺序与初始化列表顺序一致，才能真正保证其效率。</p>
<h3 id="45-C-中新增的string与C中的-char-有什么区别？"><a href="#45-C-中新增的string与C中的-char-有什么区别？" class="headerlink" title="45. C++中新增的string与C中的 char *有什么区别？"></a>45. C++中新增的string与C中的 char *有什么区别？</h3><p>(1) string对char*进行了封装，包含了字符串的属性以及对外提供了通用方法。</p>
<p>(2) string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h3 id="46-什么是内存泄露，如何检测与避免？"><a href="#46-什么是内存泄露，如何检测与避免？" class="headerlink" title="46. 什么是内存泄露，如何检测与避免？"></a>46. 什么是内存泄露，如何检测与避免？</h3><p>(1) 内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的内存块，使用完后必须显式释放的内存，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。</p>
<p>(2) 检测方法：有专门的内存泄漏检测工具，Linux下可以使用Valgrind工具 ，Windows下可以使用CRT库。</p>
<p>(3) 避免方法：使用智能指针，良好的编程习惯。</p>
<h3 id="47-什么是内存溢出和内存越界？"><a href="#47-什么是内存溢出和内存越界？" class="headerlink" title="47. 什么是内存溢出和内存越界？"></a>47. 什么是内存溢出和内存越界？</h3><p>(1) 内存溢出指的是程序在申请内存时，没有足够的内存空间供其使用。</p>
<p>(2) 内存越界指的是申请了一块内存，使用的时候超出了这块内存区域。</p>
<h3 id="48-介绍C-面向对象的三大特性？"><a href="#48-介绍C-面向对象的三大特性？" class="headerlink" title="48. 介绍C++面向对象的三大特性？"></a>48. 介绍C++面向对象的三大特性？</h3><p>(1) <strong>继承</strong></p>
<p>让某个类获得另一个类的属性和方法。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展，是代码复用的一种机制。</p>
<p>常见的继承有两种方式：</p>
<p><strong>实现继承：</strong>指使用基类的属性和方法而无需额外编码的能力</p>
<p><strong>接口继承：</strong>指仅使用属性和方法的名称、但是子类必须提供实现的能力</p>
<p>(2) <strong>封装</strong></p>
<p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。在C++中借以权限机制实现这一特性，利用三种访问权限控制外界对对象数据的访问。</p>
<p>(3) <strong>多态</strong></p>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>常见的多态有两种方式：</p>
<p><strong>编译时多态（重载）：</strong>是指允许存在多个同名函数，而这些函数的参数表不同</p>
<p><strong>运行时多态（重写）：</strong>是指子类重新定义父类的虚函数的做法</p>
<h3 id="49-说说C-的四种强制转换？"><a href="#49-说说C-的四种强制转换？" class="headerlink" title="49. 说说C++的四种强制转换？"></a>49. 说说C++的四种强制转换？</h3><p>(1) <strong>reinterpret_cast：</strong>reinterpret_cast 用以处理互不相关的类型之间的转换，reinterpret_cast 操作执行的是比特位拷贝，即编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去。这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。</p>
<p>(2) <strong>const_cast：</strong>该运算符用来修改类型的const属性，可以使指向常量的指针被转化成指向非常量的指针，并且仍然指向原来的对象，使拥有者可以通过指针修改对象。</p>
<p>(3) <strong>static_cast：</strong>static_cast 用于进行比较“自然”和低风险的转换，如<strong>整型和浮点型、字符型与整型</strong>之间的互相转换。static_cast <strong>不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。</strong>因为这些属于风险比较高的转换。他的安全性比起reinterpret_cast 更高，但是由于该操作符没有运行时类型检查机制，在进行下行转换（把基类指针或引用转换成派生类指针或引用）时仍然是不安全的。</p>
<p>(4) <strong>dynamic_cast：</strong>dynamic_cast主要用于类层次间的上行转换和下行转换，因为有动态类型检测，在进行下行转换时比static_cast更安全。</p>
<p>举例</p>
<p>C++中有四种类型的强制类型转换，分别是 <code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p>
<ol>
<li><code>static_cast</code>：这是最常用的类型转换符。它可以在任何的数据类型之间进行转换，但是转换的类型需要是相关的，否则可能会产生意外的结果。</li>
</ol>
<p>例如，将整数转换为浮点数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(a);  <span class="comment">// b = 10.0</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>dynamic_cast</code>：这个类型转换符主要用在类的继承体系中，用于进行上行转换和安全的下行转换。当我们试图将父类指针转换为子类指针时，可以使用 <code>dynamic_cast</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  <span class="comment">// 安全的下行转换</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>const_cast</code>：这个类型转换符用于移除常量性。如果我们有一个 <code>const</code> 变量，但我们需要修改它，可以使用 <code>const_cast</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">20</span>;  <span class="comment">// a现在是20，但这样做是危险的，因为a本来是const的</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>reinterpret_cast</code>：这个类型转换符用于进行低级别的类型转换，它可以在任何指针或整数类型之间进行转换。但是使用这个转换符需要非常小心，因为它可能会产生意外的结果。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">char</span>* c = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(p);  <span class="comment">// 将int*转换为char*</span></span><br></pre></td></tr></table></figure>
<p>注意：尽管 C++ 提供了这些强制类型转换，但应尽量避免使用它们，除非你非常确定你知道自己在做什么。在很多情况下，使用强制类型转换可能会导致未定义的行为。</p>
<h3 id="50-如何获得结构成员相对于结构开头的字节偏移量？"><a href="#50-如何获得结构成员相对于结构开头的字节偏移量？" class="headerlink" title="50. 如何获得结构成员相对于结构开头的字节偏移量？"></a>50. 如何获得结构成员相对于结构开头的字节偏移量？</h3><p>使用<stddef.h>头文件中的，offsetof宏</p>
<p>offsetof用法：offsetof(S, x)，S为结构体对象，x为结构体数据成员之一</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s, m) (reinterpret_cast<span class="string">&lt;size_t&gt;</span>(&amp;reinterpret_cast<span class="string">&lt;const volatile char&amp;&gt;</span>(static_cast<span class="string">&lt;s*&gt;</span>(nullptr)-&gt;m)))</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the first element is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, a)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the second is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, b)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the third element is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, c)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>此处，通过 <code>static_cast&lt;s*&gt;(nullptr)</code>，编译器相信在 <code>nullptr</code> 处（<code>0x0</code>）有一个真实存在的 <code>s</code> 类型的对象。</p>
<p>此处使用 <code>static_cast</code> 而非 <code>reinterpret_cast</code> 是因为 C++ 标准不允许将 <code>nullptr</code> 通过 <code>reinterpret_cast</code> 转换成其他类型的指针；</p>
<p>此类转换应用 <code>static_cast</code>。由于 <code>static_cast&lt;s*&gt;(nullptr)</code> 返回指向 <code>s</code> 类型对象的指针，因此 <code>static_cast&lt;s*&gt;(nullptr)-&gt;m</code> 就是一个虚拟但在编译器看来可用的成员变量 <code>m</code>。</p>
<p>为了求得以字节为单位的 <code>ptrdiff_t</code>，实现中通过 <code>&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)</code> 获得一个 <code>const volatile char*</code> 类型的变量。</p>
<p>由于在该实现中，虚拟的变量位于 <code>0x0</code> 位置，故而 <code>&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)</code> 即是 <code>m</code> 在 <code>s</code> 类型对象当中相对对象起始地址的偏移量。</p>
<p>最后，只需将它转换为 <code>size_t</code> 类型的值即可。</p>
<p>具体：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/677486774">理解C/C++ 中的offsetof 宏原理</a></p>
<h3 id="51-静态类型和动态类型，静态绑定和动态绑定的介绍？"><a href="#51-静态类型和动态类型，静态绑定和动态绑定的介绍？" class="headerlink" title="51. 静态类型和动态类型，静态绑定和动态绑定的介绍？"></a>51. 静态类型和动态类型，静态绑定和动态绑定的介绍？</h3><p>(1) 静态类型：对象在声明时采用的类型，在编译期既已确定；</p>
<p>(2) 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</p>
<p>(3) 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p>
<p>(4) 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</p>
<h3 id="52-全局变量和局部变量有什么区别？"><a href="#52-全局变量和局部变量有什么区别？" class="headerlink" title="52. 全局变量和局部变量有什么区别？"></a>52. 全局变量和局部变量有什么区别？</h3><p>(1) 生命周期：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>(2) 作用域：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用</p>
<h3 id="53-指针加减计算要注意什么？"><a href="#53-指针加减计算要注意什么？" class="headerlink" title="53. 指针加减计算要注意什么？"></a>53. 指针加减计算要注意什么？</h3><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，即内存越界。</p>
<h3 id="54-怎样判断两个浮点数是否相等？"><a href="#54-怎样判断两个浮点数是否相等？" class="headerlink" title="54. 怎样判断两个浮点数是否相等？"></a>54. 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</p>
<h3 id="55-类如何实现只能静态分配和只能动态分配？"><a href="#55-类如何实现只能静态分配和只能动态分配？" class="headerlink" title="55. 类如何实现只能静态分配和只能动态分配？"></a>55. 类如何实现只能静态分配和只能动态分配？</h3><p>(1) 实现只能静态分配：把operator new运算符重载为private属性。</p>
<p>(2) 实现只能动态分配：把构造函数设为private属性</p>
<h3 id="56-知道C-中的组合吗-它与继承相比有什么优缺点吗？"><a href="#56-知道C-中的组合吗-它与继承相比有什么优缺点吗？" class="headerlink" title="56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？"></a>56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？</h3><p>继承有以下几个缺点：</p>
<p>(1) 父类的内部细节对子类是可见的，破坏了封装性。</p>
<p>(2) 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p>
<p>(3) 子类与父类是一种高耦合，违背了面向对象思想。</p>
<p>使用组合的目的即为了克服这几个缺点，但也因此产生了另一些缺点，如：容易产生过多的对象、为了能组合多个对象，必须仔细对接口进行定义。</p>
<h3 id="57-为什么模板类一般都是放在一个头文件中？"><a href="#57-为什么模板类一般都是放在一个头文件中？" class="headerlink" title="57. 为什么模板类一般都是放在一个头文件中？"></a>57. 为什么模板类一般都是放在一个头文件中？</h3><p>模板定义很特殊，编译器在遇到任何的模板定义时不会为它分配内存空间，它一直处于等待状态直到被一个模板实例告知才会分配内存空间。如果在分离式编译环境下，编译器编译某一个源文件时并不知道另一个源文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器），同时由于模板定义没有被分配空间，链接器也无法查找到函数的入口地址。</p>
<h3 id="58-你了解重载运算符吗？"><a href="#58-你了解重载运算符吗？" class="headerlink" title="58. 你了解重载运算符吗？"></a>58. 你了解重载运算符吗？</h3><p>C++预定义中的运算符的操作对象只局限于基本的内置数据类型，但是对于我们自定义的类型（类）是没有办法操作的。但是大多时候我们需要对我们定义的类型进行类似的运算，这个时候就需要我们对这么运算符进行重新定义，赋予其新的功能，以满足自身的需求。<strong>这就是运算符重载，它的实质就是函数重载。</strong></p>
<p>运算符重载规则：</p>
<p>(1) 为了防止用户对标准类型进行运算符重载，C++规定重载后的运算符的操作对象必须至少有一个是用户定义的类型。</p>
<p>(2) 使用运算符不能违法运算符原来的句法规则。如不能将‘+’重载为一个操作数。</p>
<p>(3) 不能修改运算符原先的优先级。</p>
<p>(4) 不能创建一个新的运算符</p>
<p>(5) 不能进行重载的运算符：成员运算符，作用域运算符，条件运算符，sizeof运算符，typeid运算符，const_cast、dynamic_cast、reinterpret_cast、static_cast强制类型转换运算符。</p>
<p>(6) 大多数运算符可以通过成员函数和非成员函数进行重载，但是下面这四种运算符只能通过成员函数进行重载：= 赋值运算符，（）函数调用运算符，[ ]下标运算符，-&gt;通过指针访问类成员的运算符。</p>
<p>(7) 一般来说，单目运算符重载为类的成员函数，双目运算符重载为类的友元函数</p>
<h3 id="59-前-和后-重载的区别？"><a href="#59-前-和后-重载的区别？" class="headerlink" title="59. 前++和后++重载的区别？"></a>59. 前++和后++重载的区别？</h3><p>(1) 前++重载函数参数列表不需要带参数，后++参数列表需要带参数，这个参数仅仅只是区分前++和后++用，没有实际意义。</p>
<p>(2) 前++返回一个引用，后++返回一个临时对象，后++效率比较高。</p>
<h3 id="60-当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#60-当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？</h3><p>(1) 名字查找</p>
<p>(2) 确定候选函数</p>
<p>(3) 寻找最佳匹配</p>
<h3 id="61-条件编译的作用？"><a href="#61-条件编译的作用？" class="headerlink" title="61. 条件编译的作用？"></a>61. 条件编译的作用？</h3><p>(1) 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”<strong>。</strong></p>
<p>(2) 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用条件编译即可避免该错误。</p>
<h3 id="62-隐式转换是什么，如何消除类的隐式转换？"><a href="#62-隐式转换是什么，如何消除类的隐式转换？" class="headerlink" title="62. 隐式转换是什么，如何消除类的隐式转换？"></a>62. 隐式转换是什么，如何消除类的隐式转换？</h3><p>(1) C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换。<strong>最常见的隐式转换为函数传参。</strong></p>
<p>(2) C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<h3 id="63-如何在不使用额外空间的情况下，交换两个数？"><a href="#63-如何在不使用额外空间的情况下，交换两个数？" class="headerlink" title="63. 如何在不使用额外空间的情况下，交换两个数？"></a>63. 如何在不使用额外空间的情况下，交换两个数？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line"><span class="attribute">x</span>=x+y</span><br><span class="line"><span class="attribute">y</span>=x-y</span><br><span class="line"><span class="attribute">x</span>=x-y</span><br><span class="line">(2)</span><br><span class="line"><span class="attribute">x</span>=x^y</span><br><span class="line"><span class="attribute">y</span>=x^y</span><br><span class="line"><span class="attribute">x</span>=x&amp;y</span><br></pre></td></tr></table></figure>
<h3 id="64-你知道strcpy和memcpy的区别是什么？"><a href="#64-你知道strcpy和memcpy的区别是什么？" class="headerlink" title="64. 你知道strcpy和memcpy的区别是什么？"></a>64. 你知道strcpy和memcpy的区别是什么？</h3><p>(1) <strong>复制的内容不同。</strong>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类对象等。</p>
<p>(2) <strong>复制的方法不同。</strong>strcpy不需要指定长度，它遇到被复制字符串的结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度，更加安全。</p>
<p>(3) <strong>用途不同。</strong>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p>
<h3 id="65-如果有一个空类，它会默认添加哪些函数？"><a href="#65-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="65. 如果有一个空类，它会默认添加哪些函数？"></a>65. 如果有一个空类，它会默认添加哪些函数？</h3><p>(1) 默认构造函数</p>
<p>(2) 拷贝构造函数</p>
<p>(3) 析构函数</p>
<p>(4) 赋值运算符函数</p>
<h3 id="66-static-cast比C语言中的转换强在哪里？"><a href="#66-static-cast比C语言中的转换强在哪里？" class="headerlink" title="66. static_cast比C语言中的转换强在哪里？"></a>66. static_cast比C语言中的转换强在哪里？</h3><p>(1) 更加安全</p>
<p>(2) 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误</p>
<h3 id="67-成员函数里memset-this-0-sizeof-this-会发生什么？"><a href="#67-成员函数里memset-this-0-sizeof-this-会发生什么？" class="headerlink" title="67. 成员函数里memset(this,0,sizeof(*this))会发生什么？"></a>67. 成员函数里memset(this,0,sizeof(*this))会发生什么？</h3><p>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。</p>
<p><strong>对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</strong></p>
<p>(1) 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</p>
<p>(2) 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</p>
<h3 id="68-你知道回调函数吗-它的作用？"><a href="#68-你知道回调函数吗-它的作用？" class="headerlink" title="68. 你知道回调函数吗?它的作用？"></a>68. 你知道回调函数吗?它的作用？</h3><p>(1) 回调函数就是一个通过函数指针调用的函数。回调的函数的定义由程序员实现，但无需程序员调用，可将函数指针作为参数传递给某个函数库中的函数，由函数库去调用。</p>
<p>(2) 回调函数是在<strong>“你想让别人的代码执行你的代码，而别人的代码你又不能动”</strong>这种需求下产生的。</p>
<p>(3) 可以做回调函数的函数有两种，一种是普通函数，一种是静态成员函数。<strong>普通成员函数不能做回调函数</strong>，因为普通成员函数自带this指针参数，会导致函数声明与调用不匹配的情况发生。</p>
<p>(4) 回调函数是一种设计系统的思想，能够解决系统架构中的部分问题，但是系统中不能过多使用回调函数，因为回调函数会改变整个系统的运行轨迹和执行顺序，耗费资源，而且会使得代码晦涩难懂。</p>
<p><strong>回调函数的本质确实是函数指针。通过函数指针，我们可以将函数作为参数传递给另一个函数，这就是所谓的“回调”。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef int(*callback)(int);	//定义回调函数的原型（接收参数、返回值、名称等）</span></span><br><span class="line"><span class="keyword">using</span>  callback = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,callback cb)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">cb</span>(x); &#125;	<span class="comment">//接收回调函数指针的函数（需要使用回调功能的地方）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callbackImpl1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;	<span class="comment">//第一个回调函数实现示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callbackImpl2</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;	<span class="comment">//第二个回调函数实现示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> result1=<span class="built_in">func</span>(<span class="number">2</span>, &amp;callbackImpl1);	<span class="comment">//注意传入的是第一个回调函数实现的（地址）指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result1);</span><br><span class="line">	<span class="type">int</span> result2 = <span class="built_in">func</span>(<span class="number">2</span>, &amp;callbackImpl2);	<span class="comment">//注意传入的是第一个回调函数实现的（地址）指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result2);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="69-C-从代码到可执行程序经历了什么？"><a href="#69-C-从代码到可执行程序经历了什么？" class="headerlink" title="69. C++从代码到可执行程序经历了什么？"></a>69. C++从代码到可执行程序经历了什么？</h3><p><strong>(1) 预编译</strong></p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。</p>
<p><strong>(2) 编译</strong></p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p><strong>(3) 汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来。</p>
<p><strong>(4) 链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。</p>
<h3 id="70-类的对象存储空间？"><a href="#70-类的对象存储空间？" class="headerlink" title="70. 类的对象存储空间？"></a>70. 类的对象存储空间？</h3><p>(1) 非静态成员的数据类型大小之和。</p>
<p>(2) 编译器加入的额外成员变量（如指向虚函数表的指针）。</p>
<p>(3) 为了内存对齐而补入的额外空间。</p>
<p>(4) 空类大小为1，但若是作为基类，则大小为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="71-静态链接和动态链接的区别？"><a href="#71-静态链接和动态链接的区别？" class="headerlink" title="71. 静态链接和动态链接的区别？"></a>71. 静态链接和动态链接的区别？</h3><p>静态链接和动态链接是针对函数库来说的，现在的函数库分为两种：<strong>静态库和动态库</strong>。他们分别对应静态链接和动态链接。</p>
<p>(1) <strong>静态链接：</strong>所有的函数和数据都被编译进一个文件中。在使用静态库的情况下，在编译链接可执行文件时，链接器从函数库中复制函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。静态链接有以下特点：</p>
<p>①　空间浪费：因为每个可执行程序中都拥有函数库数据的一份副本，所以如果多个程序对同一个目标文件都有依赖，当他们同时运行在计算机上，会出现同一个函数库在内存中有多个副本，浪费内存空间；</p>
<p>②　更新困难：每当库函数的代码修改了，所有依赖该库的程序都需要重新进行编译链接。</p>
<p>③　运行速度快：因为在可执行程序中已经具备了所有执行程序所需要的任何东西，所以在执行的时候运行速度快。</p>
<p>(2) <strong>动态链接：</strong>动态链接会在程序运行时才将函数库与源程序执行链接，而不是像静态链接一样把所有模块都链接成一个单独的可执行文件。动态链接有以下特点：</p>
<p>①　共享库：如果多个程序都依赖同一个库，该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>②　更新方便：更新时只需要替换原来的库文件，依赖它的程序无需重新编译。当程序下一次运行时，新库会被自动加载到内存并且与其他程序执行链接，程序就完成了升级迭代。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h3 id="72-为什么不能把所有的函数写成内联函数？"><a href="#72-为什么不能把所有的函数写成内联函数？" class="headerlink" title="72. 为什么不能把所有的函数写成内联函数？"></a>72. 为什么不能把所有的函数写成内联函数？</h3><p>(1) 首先，不管是什么函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，<strong>编译器并不一定真正的内联</strong>。</p>
<p>(2) 内联函数以代码复杂为代价，省去了函数调用的开销来提高执行效率。如果内联函数体内代码执行时间相比起函数调用开销更大，则没有太大的意义。<strong>一般来说若是函数体代码比较长或者内部带有循环，则不推荐使用内联函数。</strong></p>
<p>(3) <strong>将构造函数和析构函数声明为inline是没有什么意义的，</strong>即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。</p>
<p>(4) <strong>将虚函数声明为inline，要分情况讨论。</strong>当指向派生类的指针（多态性）调用声明为inline的虚函数时，由于inline是编译期决定的，而虚函数是运行期决定的，在不知道将要调用哪个函数的情况下，编译器不会内联展开；当对象本身调用虚函数时，编译器能决议出会调用哪个函数时，就会内联展开，当然前提依然是函数并不复杂的情况下。</p>
<h3 id="73-为什么C-没有垃圾回收机制？"><a href="#73-为什么C-没有垃圾回收机制？" class="headerlink" title="73. 为什么C++没有垃圾回收机制？"></a>73. 为什么C++没有垃圾回收机制？</h3><p>(1) 实现一个垃圾回收器会带来额外的空间和时间开销。</p>
<p>(2) 垃圾回收会使得C++不适合进行很多底层的操作。</p>
<h3 id="74-说说C-的内存分区？"><a href="#74-说说C-的内存分区？" class="headerlink" title="74. 说说C++的内存分区？"></a>74. 说说C++的内存分区？</h3><p>在C++中，内存分成5个区，他们分别是<strong>堆、栈、全局/静态存储区和常量存储区和代码区</strong>。</p>
<p>(1) <strong>栈：</strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈工作效率很高，但是分配的内存容量有限。</p>
<p>(2) <strong>堆：</strong>就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>(3) <strong>全局/静态存储区：</strong>这块内存在编译时已经分配好，且在程序运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量。</p>
<p>(4) <strong>常量存储区：</strong>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<p>(5) <strong>代码区：</strong>存放程序的二进制代码。</p>
<h3 id="75-说说友元函数和友元类的特性？"><a href="#75-说说友元函数和友元类的特性？" class="headerlink" title="75. 说说友元函数和友元类的特性？"></a>75. 说说友元函数和友元类的特性？</h3><p>友元提供了<strong>不同类的成员函数之间、类的成员函数和一般函数之间</strong>进行数据共享的机制。通过友元，外部的普通函数或者另一个类中的成员函数可以访问本类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。友元具有以下特性：</p>
<p>(1) <strong>友元关系不能被继承。</strong></p>
<p>(2) <strong>友元关系是单向的，不具有交换性。</strong>若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
<p><strong>友元关系不具有传递性。</strong>若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的声明。</p>
<h3 id="76-关于this指针你知道什么？"><a href="#76-关于this指针你知道什么？" class="headerlink" title="76. 关于this指针你知道什么？"></a>76. 关于this指针你知道什么？</h3><p>(1) this指针是类的指针，指向对象的首地址。</p>
<p>(2) this指针只能在普通成员函数中使用，在全局函数、静态成员函数中都不能用this。</p>
<p>(3) this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>(4) this指针只有在普通成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p>
<p>(5) this指针主要可用于返回类对象本身的时候，直接使用 return *this。或者当形参数与成员变量名相同时用于区分，如this-&gt;n = n。</p>
<h3 id="77-在成员函数中调用delete-this会出现什么问题？"><a href="#77-在成员函数中调用delete-this会出现什么问题？" class="headerlink" title="77. 在成员函数中调用delete this会出现什么问题？"></a>77. 在成员函数中调用delete this会出现什么问题？</h3><p>当调用delete this时，类对象的内存空间被释放。因为类成员函数并没有存放在类对象的内存空间中，所以在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，因为内存被释放，所以就会出现不可预期的问题。</p>
<h3 id="78-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#78-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="78. 如果在类的析构函数中调用delete this，会发生什么？"></a>78. 如果在类的析构函数中调用delete this，会发生什么？</h3><p>会导致堆栈溢出。因为delete会调用析构函数，导致递归。</p>
<h3 id="79-C-中类的数据成员和成员函数内存分布情况？"><a href="#79-C-中类的数据成员和成员函数内存分布情况？" class="headerlink" title="79. C++中类的数据成员和成员函数内存分布情况？"></a>79. C++中类的数据成员和成员函数内存分布情况？</h3><p>(1) 普通数据成员存放在对象内存空间中</p>
<p>(2) 静态数据成员存放在全局/静态存储区中</p>
<p>(3) 普通成员函数和静态成员函数都存放在代码区中</p>
<h3 id="80-C-的多态怎么实现？"><a href="#80-C-的多态怎么实现？" class="headerlink" title="80. C++的多态怎么实现？"></a>80. C++的多态怎么实现？</h3><p>C++的多态机制有两种，分为编译时多态和运行时多态，下面分别介绍这两种多态。</p>
<p><strong>编译时多态</strong></p>
<p>(1) 主要通过模板和函数重载实现，在编译期发生，由编译器进行推断决议。</p>
<p>(2) 优点：</p>
<p>①　它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。</p>
<p>②　在编译器完成多态，提高运行期效率。</p>
<p>③　具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。</p>
<p>(3) 缺点：</p>
<p>①　程序可读性降低，代码调试带来困难。</p>
<p>②　无法实现模板的分离编译，当工程很大时，编译时间不可小觑。</p>
<p><strong>运行时多态</strong></p>
<p>(1) 运行期多态的设计思想要归结到类继承体系的设计上去。对于有相关功能的对象集合，我们总希望能够抽象出它们共有的功能集合，在基类中将这些功能声明为虚接口（虚函数），然后由子类继承基类去重写这些虚接口，以实现子类特有的具体功能。</p>
<p>(2) 在C++中，主要由虚表和虚表指针实现运行时多态。运行时多态实现细节如下：</p>
<p>①　编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。</p>
<p>②　编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p>
<p>③　在派生类定义对象时，会先调用父类的构造函数，此时，编译器只“看到了父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p>
<p>④　当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p>
<p>(3) 优点：</p>
<p>面向对象设计中重要的特性，对客观世界直觉认识。</p>
<p>(4) 缺点：</p>
<p>①　运行期间进行虚函数绑定，提高了程序运行开销。</p>
<p>②　庞大的类继承层次，对接口的修改易影响类继承层次。</p>
<p>③　由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。</p>
<p>④　虚表指针增大了对象体积，类也多了一张虚函数表。</p>
<h3 id="81-为什么要把析构函数写成虚函数？"><a href="#81-为什么要把析构函数写成虚函数？" class="headerlink" title="81. 为什么要把析构函数写成虚函数？"></a>81. 为什么要把析构函数写成虚函数？</h3><p>由于类的多态性，基类指针可以指向派生类的对象。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p>
<h3 id="82-虚函数表存放在内存的什么区域？"><a href="#82-虚函数表存放在内存的什么区域？" class="headerlink" title="82. 虚函数表存放在内存的什么区域？"></a>82. 虚函数表存放在内存的什么区域？</h3><p>C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；</p>
<p>虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</p>
<h3 id="83-模板偏特化了解吗？"><a href="#83-模板偏特化了解吗？" class="headerlink" title="83. 模板偏特化了解吗？"></a>83. 模板偏特化了解吗？</h3><p>(1) 通过编写模板，能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化（模板偏特化）。</p>
<p>(2) 所谓的模板偏特化对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上。</p>
<p>(3) 特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以<strong>最佳匹配</strong>为原则。</p>
<p>(4) 可以特例化类中的部分成员函数而不是整个类。</p>
<p>举例：</p>
<p>模板偏特化是C++模板编程中的一个重要概念。简单来说，模板偏特化就是对模板进行部分特化，也就是将模板的部分参数具体化。模板偏特化可以让我们为特定的类型或条件提供特化的实现。</p>
<p>举例来说，假设我们有一个模板类用于存储数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    T data[N];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们想要对<code>bool</code>类型的数组进行特化，因为<code>bool</code>类型的数组可以通过位操作进行压缩存储，从而节省空间。我们可以通过模板偏特化来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">bool</span>, N&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用位操作进行压缩存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[(N+<span class="number">7</span>)/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Array&lt;bool, N&gt;</code>是<code>Array&lt;T, N&gt;</code>的一个偏特化版本。当我们创建一个<code>Array&lt;bool, 100&gt;</code>对象时，编译器会使用偏特化版本的模板，从而实现对<code>bool</code>类型数组的优化存储。</p>
<h3 id="84-哪些函数不能被定义为虚函数？"><a href="#84-哪些函数不能被定义为虚函数？" class="headerlink" title="84. 哪些函数不能被定义为虚函数？"></a>84. 哪些函数不能被定义为虚函数？</h3><p>(1) <strong>构造函数。</strong>每一个声明了虚函数的类对象都有一个指向虚表(vtable)的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的,假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？再者，虚函数主要是在调用对象不确定的情况下使用的，然而构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。</p>
<p>(2) <strong>静态函数。</strong>静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p>
<p>(3) <strong>友元函数。</strong>友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p>
<p>(4) <strong>普通函数。</strong>普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
<h3 id="85-构造函数和析构函数可以调用虚函数吗，为什么？"><a href="#85-构造函数和析构函数可以调用虚函数吗，为什么？" class="headerlink" title="85. 构造函数和析构函数可以调用虚函数吗，为什么？"></a>85. 构造函数和析构函数可以调用虚函数吗，为什么？</h3><p>(1) <strong>构造函数调用虚函数没有意义</strong>，因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编。</p>
<p>(2) <strong>析构函数调用虚函数没有意义，</strong>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p>
<h3 id="86-构造函数和析构函数可否抛出异常？"><a href="#86-构造函数和析构函数可否抛出异常？" class="headerlink" title="86. 构造函数和析构函数可否抛出异常？"></a>86. 构造函数和析构函数可否抛出异常？</h3><p>(1) <strong>构造函数不可抛出异常：</strong>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，<strong>如果某个对象的构造函数中发生异常，则该对象的析构函数不会被调用。因此会造成内存泄漏。</strong></p>
<p>(2) <strong>析构函数不可抛出异常：</strong>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。再者，通常异常发生时，C++ 的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p>
<h3 id="87-模板类和模板函数的区别是什么？"><a href="#87-模板类和模板函数的区别是什么？" class="headerlink" title="87. 模板类和模板函数的区别是什么？"></a>87. 模板类和模板函数的区别是什么？</h3><p>函数模板的实例化是由编译器在处理函数调用时自动完成的，而类模板的实例化必须由程序员在代码中显式地指定。即函数模板允许隐式调用和显式调用，而类模板只能显式调用。</p>
<h3 id="88-什么是虚继承？"><a href="#88-什么是虚继承？" class="headerlink" title="88. 什么是虚继承？"></a>88. 什么是虚继承？</h3><p>(1) 由于C++支持多继承，因此除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承。</p>
<p>(2) 多继承有可能引发一直特别情况：B和C公有继承A，D又公有继承B和C，这种方式是一种菱形继承或者钻石继承，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513220826075.png" alt="image-20240513220826075"></p>
<p>(3) 如果D调用了A的方法，则会引发数据的二义性和冗余，编译器不知道是要调用B所继承的A，还是C所继承的A。</p>
<p>(4) 为了解决这个问题，C++引入了虚拟继承，在虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</p>
<h3 id="89-抽象基类为什么不能创建对象？纯虚函数又是什么？"><a href="#89-抽象基类为什么不能创建对象？纯虚函数又是什么？" class="headerlink" title="89. 抽象基类为什么不能创建对象？纯虚函数又是什么？"></a>89. 抽象基类为什么不能创建对象？纯虚函数又是什么？</h3><p>(1) 带有纯虚函数的类为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的。抽象类会将所有派生类中有关的操作抽象成一个通用接口且不做具体实现（纯虚函数），具体实现由派生类实现，因此抽象基类不可以创建对象。</p>
<p>(2) 纯虚函数是一种特殊的虚函数，该类函数没有函数体。因为在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<h3 id="90-说说RTTI？"><a href="#90-说说RTTI？" class="headerlink" title="90. 说说RTTI？"></a>90. 说说RTTI？</h3><p><strong>运行时类型识别（Run-time type identification , RTTI）</strong>，是指在只有一个指向基类的指针或引用时，确定所指对象的准确类型的操作。其常被说成是C++的四大扩展之一（其他三个为异常、模板和名字空间）。使用RTTI有两种方法：</p>
<p>1、typeid()</p>
<p>第一种就像sizeof()，它看上像一个函数，但实际上它是由编译器实现的。typeid()带有一个参数，它可以是一个对象引用或指针，返回全局typeinfo类的常量对象的一个引用。可以用运算符“= =”和“!=”来互相比较这些对象，也可以用name()来获得类型的名称。同时，我们也可以用typeid 检查基本类型和非多态类型。如果想知道一个指针所指对象的精确类型，我们必须逆向引用这个指针。比如：</p>
<p>2、dynamic_cast (expression)</p>
<p>该运算符为强制类型转换符，上文第49条有提及</p>
<h3 id="91-多继承的优缺点，作为一个开发者怎么看待多继承？"><a href="#91-多继承的优缺点，作为一个开发者怎么看待多继承？" class="headerlink" title="91. 多继承的优缺点，作为一个开发者怎么看待多继承？"></a>91. 多继承的优缺点，作为一个开发者怎么看待多继承？</h3><p>多重继承的优点很明显，就是一个对象可以调用多个基类中的接口。多继承容易导致菱形继承问题，虽然可以用虚继承解决该问题，但也会造成内存结构复杂，效率降低，继承体系过于复杂化的缺点。</p>
<h3 id="92-为什么拷贝构造函数必须传引用不能传值？"><a href="#92-为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="92. 为什么拷贝构造函数必须传引用不能传值？"></a>92. 为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数的作用就是用来拷贝对象的，使用一个已存在的对象来初始化一个新的对象。如果使用传值方式，那么在拷贝构造函数被调用时，<strong>在进行参数传递的时候就会调用拷贝构造函数，这样会导致递归溢出。</strong></p>
<h3 id="93-为什么在C-C-中要将代码分为头文件和源文件，不能写到一起吗？"><a href="#93-为什么在C-C-中要将代码分为头文件和源文件，不能写到一起吗？" class="headerlink" title="93. 为什么在C/C++中要将代码分为头文件和源文件，不能写到一起吗？"></a>93. 为什么在C/C++中要将代码分为头文件和源文件，不能写到一起吗？</h3><p>(1) <strong>将所有代码写入一个文件中当然可以，同样可以通过编译且正常运行</strong>。</p>
<p>(2) <strong>分开写的目的是方便未来。</strong>有时候我们写的代码会给别人去用，如果是非开源代码，可以将源文件封装起来并生成库文件（<strong>库文件是二进制文件，无法查阅代码</strong>）。只对外开放头文件和库文件，那么别人就无法看到代码的具体实现了。</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="1-auto、decltype的用法？"><a href="#1-auto、decltype的用法？" class="headerlink" title="1. auto、decltype的用法？"></a>1. auto、decltype的用法？</h3><p>(1) auto：C++11引入了auto类型说明符，它可以让编译器通过初始值来进行类型推演，使得程序员无需知道类型名称就可以定义变量，所以auto 定义的变量必须有初始值。</p>
<p>(2) decltype: auto定义的变量必须初始化，如果我们不想要初始化就可以使用decltype，它会返回参数的数据类型，并定义新的变量，而且新变量的值不会被初始化。</p>
<h3 id="2-C-中NULL和nullptr的区别？"><a href="#2-C-中NULL和nullptr的区别？" class="headerlink" title="2. C++中NULL和nullptr的区别？"></a>2. C++中NULL和nullptr的区别？</h3><p>(1) NULL是一个宏定义，C中NULL为（void*)0，C++中NULL为整数0。</p>
<p>(2) 将NULL定义为0带来的一个问题是无法与整数的0区分，因为C++中允许有函数重载，若是有个a、b两个重载函数，参数分别为整数和指针，那么在传入NULL参数时，会把NULL当做整数0来看，导致错误调用了参数为整数的函数。</p>
<p>(3) nullptr可以解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<h3 id="3-说说final和override关键字？"><a href="#3-说说final和override关键字？" class="headerlink" title="3. 说说final和override关键字？"></a>3. 说说final和override关键字？</h3><p>(1) Override指定了子类的这个虚函数是对父类虚函数的重写，如果函数名不小心打错了的话，编译器会进行报错。</p>
<p>(2) 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后如果被继承或重写，编译器会报错。</p>
<p>举例：</p>
<p>在C++中，<code>final</code> 和 <code>override</code> 是两个非常有用的关键字，它们主要用于类和成员函数的继承。</p>
<ol>
<li><code>final</code> 关键字可以用于阻止类的进一步继承，或者阻止虚函数的进一步覆盖。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;   <span class="comment">// 这个类不能被继承</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;   <span class="comment">// 这个函数不能被子类覆盖</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>override</code> 关键字用于明确表示一个虚函数覆盖了基类中的虚函数。这有助于编译器检查我们的代码，如果基类中没有对应的虚函数，使用 <code>override</code> 将导致编译错误。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;   <span class="comment">// 明确表示这个函数覆盖了基类的虚函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上就是 <code>final</code> 和 <code>override</code> 在C++中的基本用法。这两个关键字都可以帮助我们编写出更清晰、更安全的代码。</p>
<h3 id="4-C-中的智能指针？"><a href="#4-C-中的智能指针？" class="headerlink" title="4. C++中的智能指针？"></a>4. C++中的智能指针？</h3><p>(1) 智能指针会管理程序员申请的内存，在使用结束后会自动释放，防止堆内存泄漏。</p>
<p>(2) <strong>auto_ptr：</strong>最原始的智能指针。auto_ptr采用的是<strong>独享所有权语义</strong>，一个非空的auto_ptr总是拥有它所指向的资源，转移一个auto_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空。由于支持拷贝语义，拷贝后源对象变得无效，如果程序员忽视了这点，这可能引发很严重的问题。<strong>在C++11中该指针已被弃用</strong>。</p>
<p>(3) <strong>unique_ptr：</strong>与auto_ptr类似，采用<strong>独享所有权语义</strong>。<strong>unique_ptr提供移动语义</strong>，这在很大程度上避免了auto_ptr的错误，因为很明显必须使用std::move()进行转移，提醒程序员在这个地方发生了移动。</p>
<p>(4) <strong>shared_ptr：</strong>采用<strong>引用计数器</strong>的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。引用计数器的变化依据如下所示。</p>
<p>①　每次创建类的新对象时，初始化指针并将引用计数置为1</p>
<p>②　当对象作为另一对象的副本而创建时，拷贝构造函数会拷贝指针并增加与之相应的引用计数</p>
<p>③　对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</p>
<p>④　调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</p>
<p>(5) <strong>weak_ptr：</strong> 由于shared_ptr引用计数存在的问题，即互相引用形成环（环形引用），使得两个指针指向的内存都无法释放，如下所示。</p>
<p>①　为了解决这个问题，C++引入了weak_ptr(弱引用)，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，<strong>它只引用，不计数</strong>。</p>
<p>②　如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。</p>
<p>③　weak_ptr不保证它指向的内存一定是有效的，在使用之前应先检查weak_ptr是否为空指针，避免访问非法内存，也因此weak_ptr并不能直接访问对象，他只能通过转化为shared_ptr来使用对象。</p>
<blockquote>
<p><strong>share_ptr手写</strong></p>
</blockquote>
<p><strong>share_ptr-double free问题</strong>：double free 问题就是一块内存空间或者资源被释放两次。</p>
<p>double free 可能是下面这些原因造成的：</p>
<ul>
<li>直接使用原始指针创建多个 shared_ptr，而没有使用 shared_ptr 的 make_shared 工厂函数，从而导致多个独立的引用计数。</li>
<li>循环引用，即两个或多个 shared_ptr 互相引用，导致引用计数永远无法降为零，从而无法释放内存。</li>
</ul>
<p>case1:举例</p>
<p>在C++中，std::shared_ptr 是一个智能指针，它可以自动管理对象的生命周期。它通过引用计数来确保当没有任何 shared_ptr 指向一个对象时，该对象会被自动删除。</p>
<p>然而，直接使用原始指针创建多个 shared_ptr，而没有使用 shared_ptr 的 make_shared 工厂函数，可能会导致多个独立的引用计数，进而导致double-free的问题。</p>
<p>下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// 创建一个原始指针指向一个新的int对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个独立的shared_ptr，它们都指向同一个对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当sp1和sp2离开其作用域时，它们都会试图删除同一个对象，导致double-free的问题</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了两个独立的 shared_ptr，它们都指向同一个对象。当它们离开其作用域时，它们都会试图删除同一个对象，导致double-free的问题。</p>
<p>正确的做法是使用 make_shared 工厂函数来创建 shared_ptr，或者只使用一个原始指针来初始化一个 shared_ptr，然后使用这个 shared_ptr 来初始化其他的 shared_ptr。这样，所有的 shared_ptr 都会共享同一个引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 使用原始指针初始化一个shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">// 使用sp1初始化sp2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 使用make_shared创建一个shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">// 使用sp1初始化sp2</span></span><br></pre></td></tr></table></figure>
<p>在上述正确的做法中，所有的 shared_ptr 都会共享同一个引用计数，因此不会出现double-free的问题。</p>
<p>case2:</p>
<p>循环引用问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;b_ptr = b; <span class="comment">// A 指向 B</span></span><br><span class="line">        b-&gt;a_ptr = a; <span class="comment">// B 指向 A</span></span><br><span class="line">    &#125; <span class="comment">// a 和 b 离开作用域，但由于循环引用，它们的析构函数不会被调用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用weak_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 替代 shared_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;b_ptr = b; <span class="comment">// A 指向 B</span></span><br><span class="line">        b-&gt;a_ptr = a; <span class="comment">// B 对 A 使用 weak_ptr</span></span><br><span class="line">    &#125; <span class="comment">// a 和 b 离开作用域，它们的析构函数会被正确调用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>enable_shared_from_this</strong><br>从名字可以看出几个关键词：enable: 允许 shared 指 shared_ptr, from_this 则是指从类自身this 构造 shared_ptr。</p>
<p>想象这样一个场景:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这段代码需要在NeedCallSomeAPI函数中调用SomeAPI，而SomeAPI需要的是一个std::shared_ptr的实参。这个时候应该怎么做？ 这样吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的做法是错误的，因为SomeAPI调用结束后std::shared_ptr对象的引用计数会降为0，导致 this 被意外释放。</p>
<p>这种情况下，我们需要使用std::enable_shared_from_this ，使用方法很简单，只需要让SomeData继承std::enable_shared_from_this，然后调用shared_from_this，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> shared_ptr&lt;st&gt; &amp;d)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span> : enable_shared_from_this&lt;st&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;st&gt; <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;st&gt;(<span class="keyword">new</span> st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">66</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> shared_ptr&lt;st&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; d-&gt;num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = st::<span class="built_in">New</span>();</span><br><span class="line">    p-&gt;<span class="built_in">f1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，当下面👇这些场景用到 shared_ptr 时，需要搭配上 enable_shared_from_this:</p>
<ul>
<li>当你需要将this指针传递给其他函数或方法，而这些函数或方法需要一个std::shared_ptr，而不是裸指针。</li>
<li>当你需要在类的成员函数内部创建指向当前对象的std::shared_ptr，例如在回调函数或事件处理中。</li>
</ul>
<p>手敲智能指针是面试常见的题目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr), count_(ptr ? new size_t(<span class="number">1</span>) : nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr_</span>(other.ptr_), <span class="built_in">count_</span>(other.count_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count_) &#123;</span><br><span class="line">            ++(*count_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr_ = other.ptr_;</span><br><span class="line">            count_ = other.count_;</span><br><span class="line">            <span class="keyword">if</span> (count_) &#123;</span><br><span class="line">                ++(*count_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_ ? *count_ : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count_ &amp;&amp; --(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* ptr_;</span><br><span class="line">    <span class="type">size_t</span>* count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass 构造函数\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass 析构函数\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyClass::do_something() 被调用\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SimpleSharedPtr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            SimpleSharedPtr&lt;MyClass&gt; ptr2 = ptr1;</span><br><span class="line">            ptr1-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">            ptr2-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr">https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr</a></li>
</ul>
<h3 id="5-说说STL容器中的智能指针？"><a href="#5-说说STL容器中的智能指针？" class="headerlink" title="5. 说说STL容器中的智能指针？"></a>5. 说说STL容器中的智能指针？</h3><p>具备<strong>独占所有权语义</strong>的智能指针不能在STL的容器中使用，如auto_ptr和unique_ptr，因为STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，容易导致错误，而unique_ptr又不支持普通的拷贝和赋值操作，也不能用在STL标准容器中。</p>
<h3 id="6-说说lambda函数？"><a href="#6-说说lambda函数？" class="headerlink" title="6. 说说lambda函数？"></a>6. 说说lambda函数？</h3><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象。每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，该实例是一个右值。lambda的优点有以下几点：</p>
<p>(1) <strong>距离</strong>：很多人认为，让定义位于使用的地方附近很有用。这样，就无需翻阅很多页的源代码，以了解函数。另外，如果需要修改代码，设计的内容就在附近，就很好修改。</p>
<p>(2) <strong>简洁</strong>：函数符代码要比lambda代码更加繁琐，函数和lambda的简洁程度相当。</p>
<p>(3) <strong>功能</strong>：lambda可以访问作用域内的任何动态变量，可以采用取值、引用的形式进行捕获。</p>
<h3 id="7-什么是声明时初始化？"><a href="#7-什么是声明时初始化？" class="headerlink" title="7. 什么是声明时初始化？"></a>7. 什么是声明时初始化？</h3><p>C++11新增了<strong>类成员初始化新机制</strong>——声明时初始化，可以直接在类中声明数据成员时就进行初始化操作，而不用借助构造函数或者初始化列表。</p>
<h3 id="8-C-11添加哪几种构造函数关键字？"><a href="#8-C-11添加哪几种构造函数关键字？" class="headerlink" title="8. C++11添加哪几种构造函数关键字？"></a>8. C++11添加哪几种构造函数关键字？</h3><p>(1) default关键字可以显式要求编译器生成默认构造函数，防止在调用时相关构造函数没有定义而报错。</p>
<p>(2) delete关键字可以删除构造函数、赋值运算符函数等，在使用时编译器会报错</p>
<h3 id="9-说说C-的左值和右值？"><a href="#9-说说C-的左值和右值？" class="headerlink" title="9. 说说C++的左值和右值？"></a>9. 说说C++的左值和右值？</h3><p>(1) 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。</p>
<p>(2) 在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p>
<p>(3) 纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和字面量值；将亡值则是C++11新增的新右值，它表示该对象的内存空间接下来会被其他对象接管。通过这种接管空间的方式可以避免内存空间的释放和分配，延长变量值的生命期。</p>
<p>(4) C++11对于引用了也有了新的解释。传统的C++引用被称为<strong>左值引用</strong>，符号为&amp;，他关联的是左值。C++11中增加了<strong>右值引用</strong>，符号为&amp;&amp;。<strong>右值引用会关联到右值</strong>，右值被存储到特定位置，右值引用会指向该特定位置，也就是说，<strong>右值虽然无法获取地址，但是右值引用是可以获取地址的</strong>，该地址表示临时对象的存储位置。使用std::move可以使一个左值转换为右值引用。</p>
<h3 id="10-说说移动构造函数？"><a href="#10-说说移动构造函数？" class="headerlink" title="10. 说说移动构造函数？"></a>10. 说说移动构造函数？</h3><p>(1) 移动构造是C++11标准中提供的一种新的构造方法，用来给予程序员新的构造选择，用以替换拷贝构造。</p>
<p>(2) 拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，拷贝的内存越大越耗费时间，并且进行了深拷贝，就需要给对象分配地址空间。</p>
<p>(3) 移动构造函数会直接接管源对象空间，既不会产生额外的拷贝开销，也不会给新对象分配内存空间。提高程序的执行效率，节省内存消耗。</p>
<p>(4) 移动构造函数的参数必须是<strong>自身类型的右值引用</strong>，也就是说能调用移动构造函数的参数必然是个右值（纯右值和将亡值）。</p>
<h3 id="11-什么是列表初始化？"><a href="#11-什么是列表初始化？" class="headerlink" title="11. 什么是列表初始化？"></a>11. 什么是列表初始化？</h3><p>列表初始化是C++ 11新引进的初始化方式，它采用一对花括号（即<strong>｛｝</strong>）进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化。</p>
<h3 id="12-初始化列表和列表初始化的区别？"><a href="#12-初始化列表和列表初始化的区别？" class="headerlink" title="12.初始化列表和列表初始化的区别？"></a>12.初始化列表和列表初始化的区别？</h3><p>(1) 初始化列表是在创建类对象时，对类对象内部的数据成员进行的一种初始化方式，具体用在类的构造函数中。</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="1-什么是STL？"><a href="#1-什么是STL？" class="headerlink" title="1.什么是STL？"></a>1.什么是STL？</h3><p>Standard Template Library（标准模板库），是C++的标准库之一，它是一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。STL包含6大部件：<strong>容器、迭代器、算法、仿函数、适配器和空间配置器</strong>。</p>
<h3 id="2-SGI的二级空间配置器了解吗？"><a href="#2-SGI的二级空间配置器了解吗？" class="headerlink" title="2.SGI的二级空间配置器了解吗？"></a>2.SGI的二级空间配置器了解吗？</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/331809729">5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiajun07061225/article/details/8807890">【STL深入学习】SGI STL空间配置器详解（二）-第二级空间配置器</a></li>
</ul>
<p>(1) 对象构造前的空间配置和对象析构后的空间释放，由<stl_alloc.h>负责，SGI设计了<strong>双层级配置器</strong>：</p>
<p>①　第一级空间配置器直接使用malloc和free，如果在申请动态内存时找不到足够大的内存块，将返回NULL 指针，宣告内存申请失败。</p>
<p>②　第二级空间配置器视情况使用不同的策略，当申请内存大于128字节时，调用第一级配置器。当申请内存小于128b字节时，采用内存池方式，维护16个（128/8）自由链表，每个链表维护8字节大小的内存块，从中进行内存分配，如果内存不足转第一级配置器处理。</p>
<p>(2) <strong>二级空间配置器存在的问题</strong>：</p>
<p>①　自由链表所挂区块都是8的整数倍，因此当我们需要非8倍数的区块，往往会导致浪费。</p>
<p>②　由于配置器的链表都是静态变量，他们存放在全局/静态区，其释放时机就是程序结束，这样子会导致自由链表一直占用内存。</p>
<h3 id="3-traits技法"><a href="#3-traits技法" class="headerlink" title="3.traits技法?"></a>3.traits技法?</h3><p>入门案例：</p>
<p>在C++中，traits（特性）是一种常用的技术，主要用于在编译期间获取类型的信息。通过traits，我们可以编写出更加通用、灵活的代码。</p>
<p>下面是一个简单的traits的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个traits模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTraits</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，我们假设类型T不是一个指针</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_pointer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针类型进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTraits</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="comment">// 对于指针类型，我们设定is_pointer为true</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_pointer = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MyTraits&lt;<span class="type">int</span>&gt;::is_pointer &lt;&lt; endl;  <span class="comment">// 输出0，表示int不是指针</span></span><br><span class="line">    cout &lt;&lt; MyTraits&lt;<span class="type">int</span>*&gt;::is_pointer &lt;&lt; endl; <span class="comment">// 输出1，表示int*是指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们定义了一个名为 <code>MyTraits</code> 的模板，并对指针类型进行了特化。通过 <code>MyTraits</code>，我们可以在编译期间判断一个类型是否是指针类型。</p>
<p>除了这个简单的例子，traits还有很多其他的应用，例如获取一个类型的大小、判断一个类型是否是const类型、获取一个容器的迭代器类型等等。通过traits，我们可以更好地抽象和封装代码，提高代码的复用性和灵活性。</p>
<h3 id="4-说说STL中的容器？"><a href="#4-说说STL中的容器？" class="headerlink" title="4.说说STL中的容器？"></a>4.说说STL中的容器？</h3><p>(1) <strong>vector</strong></p>
<p>①　vector底层是一个动态数组，包含三个迭代器：start、finish、end_of_storage。start和finish之间是已经被使用的空间范围，表示当前vector中有多少个元素，即有效空间size。start和end_of_storage是整块连续空间包括备用空间的大小，表示它分配的内存中可以容纳多少元素，即容量capacity。</p>
<p>②　<strong>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍）</strong>，然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间。之所以是1.5倍或者2倍，是因为考虑到可能产生的堆空间浪费，增长倍数不能太大，使用1.5或者2是比较合理的倍数。</p>
<p>③　当释放或者删除（vec.clear()）里面的数据时，其<strong>存储空间不释放</strong>，仅仅是清空了里面的数据。</p>
<p>④　对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器都会失效。</p>
<p>⑤　reserve函数的作用：将vector直接扩充到确定的大小，可以减少多次开辟和释放空间的效率问题（优化push_back），还可以减少拷贝数据的次数，<strong>它直接更改capacity</strong>。</p>
<p>⑥　resize()函数的作用：<strong>可以改变vector有效空间的大小，即size的大小</strong>。如果size大于capacity，capacity的大小也会随着改变。</p>
<p>⑦　vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此<strong>vector的元素类型不能是引用</strong>。</p>
<p>⑧　当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。<strong>erase方法会返回下一个有效的迭代器</strong>。</p>
<p>⑨　释放vector内存的方法：</p>
<p><strong>vec.clear()：</strong>清空内容，但是不释放内存。</p>
<p><strong>vector().swap(vec)：</strong>清空内容，且释放内存，想得到一个全新的vector。</p>
<p><strong>vec.shrink_to_fit()：</strong>请求容器降低其capacity和size匹配。</p>
<p><strong>vec.clear();vec.shrink_to_fit();：</strong>清空内容，且释放内存。</p>
<p>(2) <strong>List</strong></p>
<p>①　list的底层是一个双向链表，以结点为单位存放数据，<strong>结点的地址在内存中不一定连续</strong>，每次插入或删除一个元素，就配置或释放一个元素空间。</p>
<p>②　list不支持随机存取，如果需要大量的插入和删除，而不关心随机存取，则可以使用list。</p>
<p>(3) <strong>Deque</strong></p>
<p>①　deque的是一个<strong>双向开口的连续线性空间（双端队列）</strong>，在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</p>
<p>②　deque的底层并不是真正连续的空间，而是由一段段连续的小空间拼接而成，实际<strong>deque类似于一个动态的二维数组</strong>，由一个map（中控指针数组）和多个连续的缓冲区组成。</p>
<p>③　当deque不断增加元素时，一旦map（中控指针数组）满了，那么会增容，不过<strong>map增容的代价非常低，因为只需要拷贝存储数据的buffer数组的指针，不需要拷贝buffer中的内容</strong>。</p>
<p>④　双端队列底层是一段假象的连续空间，实际是<strong>分段连续</strong>的，为了维护其“整体连续”以及随机访问的假象，deque的迭代器设计就比较复杂。<strong>由cur、first、last指向当前遍历buffer数组，node指向map中的元素</strong>，遍历deque的操作由这几个指针进行维护。</p>
<p>⑤　deque并不是从map的第一个位置就开始存放元素，而是从中间开始存放，这样在头部和尾部插入元素就会变得容易。</p>
<p>⑥　与vector比较：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。</p>
<p>⑦　与list比较：其底层是连续空间，空间利用率比较高，不需要存储额外字段。</p>
<p>⑧　不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下。不适合大量的中间插入删除，也不适合大量的随机访问。</p>
<p>(4) <strong>map 、set、multiset、multimap</strong></p>
<p>①　底层数据结构都是红黑树，是一种自平衡的二叉搜索树</p>
<p>②　set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。</p>
<p>③　map和multimap将key和value组成的键值对作为元素，根据key的排序准则自动将元素排序，map中元素的key不允许重复，multimap可以重复。</p>
<p>④　map和set的增删改查速度为都是logn，是比较高效的。</p>
<p>⑤　map和set的插入删除效率比序列容器高，而且每次insert之后，以前保存的iterator不会失效。因为存储的是结点，不需要内存拷贝和内存移动。</p>
<p>(5) <strong>unordered_map、unordered_set</strong></p>
<p>①　底层数据结构是一个防冗余的哈希表（采用除留余数法）。其数据的存储和查找的效率很高，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。</p>
<p>②　使用开链法解决哈希冲突。</p>
<p>③　数据的存放是无序的</p>
<h3 id="5-什么是STL的顺序容器和关联式容器？"><a href="#5-什么是STL的顺序容器和关联式容器？" class="headerlink" title="5. 什么是STL的顺序容器和关联式容器？"></a>5. 什么是STL的顺序容器和关联式容器？</h3><p>(1) 关联容器(Associative Container)与顺序容器(Sequential Container)的本质区别在于：<strong>关联容器是通过键(key)存储和读取元素的，而顺序容器则通过元素在容器中的位置顺序存储和访问元素</strong>。</p>
<p>(2) 在STL中，这里的“顺序”和“关联”指的是<strong>上层接口表现出来的访问方式</strong>，并非底层存储方式。为什么这样划分呢？因为对STL的用户来说，他们并不需要知道容器的底层实现机制，只要知道如何通过上层接口访问容器元素就可以了，否则违背了泛型容器设计的初衷。</p>
<p>(3) 顺序容器主要采用向量和链表及其组合作为基本存储结构，如堆栈和各种队列。而关联式容器采用平衡二叉搜索树作为底层存储结构。</p>
<h3 id="6-说说STL的容器适配器？"><a href="#6-说说STL的容器适配器？" class="headerlink" title="6. 说说STL的容器适配器？"></a>6. 说说STL的容器适配器？</h3><p>容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现都是通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。</p>
<p>(1) <strong>stack</strong></p>
<p>①　stack（栈）是一种<strong>先进后出（First In Last Out）</strong>的数据结构，只有一个出入口，那就是栈顶，除了对栈顶元素进行操作外，没有其他方法可以操作内部的其他元素。</p>
<p>②　C++的栈是一种<strong>容器适配器</strong>，其底层数据结构一般用<strong>list或deque</strong>实现，只开放一部分的接口和方法即可完成对栈的支持。</p>
<p>(2) <strong>queue</strong></p>
<p>①　queue（队列）是一种<strong>先进先出（First In First Out）</strong>的数据结构，只有一个入口和一个出口，分别位于队头与队尾，只能在队尾插入元素，在队头取出元素，没有其他方法可以操作内部的其他元素。</p>
<p>②　C++的队列是一种<strong>容器适配器</strong>，其底层数据结构一般用<strong>list或deque</strong>实现，只开放一部分的接口和方法即可完成对队列的支持。</p>
<p>(3) <strong>priority_queue</strong></p>
<p>①　priority_queue，优先级队列，是一个<strong>拥有权值观念的queue</strong>，它跟queue一样只能在队尾插入元素，在队头取出元素。在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面。</p>
<p>②　priority queue（优先队列）的底层实现机制实际上是<strong>堆</strong>，因为大根堆总是最大值位于堆的根部，优先级最高。</p>
<p>③　C++中的堆是容器适配器，一般是vector为底层容器，以堆的处理规则来进行管理。</p>
<h3 id="7-说说STL的迭代器？"><a href="#7-说说STL的迭代器？" class="headerlink" title="7. 说说STL的迭代器？"></a>7. 说说STL的迭代器？</h3><p>(1) <strong>迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。</strong></p>
<p>(2) 在遍历容器的时候，不可避免的要对遍历的容器内部有所了解，所以，干脆把迭代器的开发工作交给容器的设计者好了，如此以来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种 STL 容器都提供有专属迭代器的缘故。</p>
<p>(3) 迭代器种类分为5类：</p>
<p>①　<strong>输入迭代器：</strong>是只读迭代器，在每个被遍历的位置上只能读取一次。</p>
<p>②　<strong>输出迭代器：</strong>是只写迭代器，在每个被遍历的位置上只能被写一次。</p>
<p>③　<strong>前向迭代器：</strong>兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持operator–，所以只能向前移动。</p>
<p>④　<strong>双向迭代器：</strong>很像前向迭代器，只是它向后移动和向前移动同样容易。</p>
<p>⑤　<strong>随机访问迭代器：</strong>有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置， 包含指针的所有操作，可进行随机访问，随意移动指定的步数。</p>
<p>(5) 通过traits技法，我们可以获取到迭代器一些特性，STL规定，每一个迭代器至少包含以下几种特性供外界获取，方便算法使用迭代器。</p>
<p>①　<strong>value_type：</strong>迭代器所指对象的类型</p>
<p>②　<strong>difference_type：</strong>两个迭代器之间的距离</p>
<p>③　<strong>pointer：</strong>迭代器所指对象的指针类型</p>
<p>④　<strong>reference：</strong>迭代器所指对象的引用类型</p>
<p>⑤　<strong>iterator_category：</strong>迭代器种类</p>
<p>(6) 迭代器失效问题</p>
<p>①　<strong>数组型数据结构（vector）：</strong>该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert( <em> iter)(或erase( </em> iter))，然后再iter++，是没有意义的。解决方法：erase( * iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter)。</p>
<p>②　<strong>链表型数据结构：</strong>对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase( * iter)会返回下一个有效迭代器的值，或者erase(iter++)。</p>
<p>③　<strong>树形数据结构：</strong> 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p>
<p>④　<strong>Deque：</strong>插入头尾会使<strong>迭代器全部失效但是引用不失效</strong>。其原因在于插入头尾可能会进行扩容，由于map的重新分配，迭代器的node失效，但是原map指向的连续数组并没有重新分配。因此，对整个迭代器来说是失效的，但对于元素的指针和引用仍然是有效的。<strong>删除头尾会使被删除的元素迭代器和引用失效，插入和删除中间会使迭代器和引用全部失效。</strong></p>
<p>⑤　<strong>unodered_map/unordered_set：</strong>由于底层是哈希表，迭代器是否失效主要看哈希表的实现策略，对于使用<strong>除留余数法和开链法</strong>的哈希表来说，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<h3 id="8-说说STL容器的线程安全性？"><a href="#8-说说STL容器的线程安全性？" class="headerlink" title="8. 说说STL容器的线程安全性？"></a>8. 说说STL容器的线程安全性？</h3><p><strong>STL只保证最低限度的线程安全性，即：</strong>多个读者是安全的，多线程可以同时读取一个容器的内容，但如果有多个写者，则必须使用同步互斥机制保证线程安全。</p>
<h3 id="9-STL容器的使用场景？"><a href="#9-STL容器的使用场景？" class="headerlink" title="9. STL容器的使用场景？"></a>9. STL容器的使用场景？</h3><p>(1) vector的使用场景：只查看，而不频繁插入删除的</p>
<p>(2) deque的使用场景：头尾需要频繁插入删除</p>
<p>(3) list的使用场景：频繁的插入删除的场景，且位置不固定</p>
<p>(4) Set：针对单一值的增删查改操作都要有，且要求数据有序</p>
<p>(5) Map：针对键值对的增删查改操作都要有，且要求数据有序</p>
<p>(6) unordered_set：针对单一值的增删查改操作都要有，数据排列无要求。</p>
<p>(7) unordered_map：针对键值对的增删查改操作都要有，数据排列无要求。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Cpp面经</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/680a3d55.html">https://penge666.github.io/posts/680a3d55.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-05-13</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-05-14</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Cpp</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/41691f83.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_11.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Valgrind</div></div></a></div><div class="next-post pull-right"><a href="/posts/60c6b3ce.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_16.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">tinyxml库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/af408df9.html" title="Modern Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_17.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-11</div><div class="title">Modern Cpp</div></div></a></div><div><a href="/posts/e584d079.html" title="More Effective Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-12</div><div class="title">More Effective Cpp</div></div></a></div><div><a href="/posts/bf4dced7.html" title="Effective Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_24.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-11</div><div class="title">Effective Cpp</div></div></a></div><div><a href="/posts/4772239d.html" title="Cpp基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-04</div><div class="title">Cpp基础知识</div></div></a></div><div><a href="/posts/a5a0c60f.html" title="内存屏障"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-24</div><div class="title">内存屏障</div></div></a></div><div><a href="/posts/ccc0d0ac.html" title="Effectivate Modern Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_3.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-11</div><div class="title">Effectivate Modern Cpp</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-98"><span class="toc-text">C++98</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8main%E6%89%A7%E8%A1%8C%E7%9A%84%E5%89%8D%E5%90%8E%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">1. 在main执行的前后需要处理什么工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-text">2.什么是内存对齐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-text">3. 为什么要做内存对齐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-text">4. 说说内存对齐规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. 指针和引用的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. 堆和栈的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-new-delete-%E4%B8%8E-malloc-free%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-text">7. new &#x2F; delete 与 malloc &#x2F; free的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-text">8. 被free回收的内存是立即返还给操作系统吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AE%8F%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">9. 宏函数和普通函数有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10. 宏定义和typedef有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">11. 宏定义和const的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">12. 内联函数和宏函数的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">13. 变量声明和定义的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">14. strlen和sizeof的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15. 常量指针和指针常量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B5%8B%E5%80%BC%E7%BB%99%E9%9D%9E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%EF%BC%9F"><span class="toc-text">16. 指针常量能不能赋值给非指针常量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-C-%E5%92%8CPython%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">17. C++和Python的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">18. C++中struct和class的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-C-%E5%92%8CC%E7%9A%84struct%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">19. C++和C的struct的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-C-%E4%B8%ADconst%E5%92%8Cstatic%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">20. C++中const和static的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">21.数组名和指针（这里为指向数组首元素的指针）的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-C%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%92%8CC-%E7%BC%96%E8%AF%91%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">22. C代码使用C语言编译和C++编译有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-extern%E2%80%9DC%E2%80%9D%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">23. extern”C”的用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%AF%B4%E8%AF%B4%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">24. 说说野指针和悬空指针？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E5%92%8C%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">25. C++中的重载、重写（覆盖）和隐藏的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">26. 浅拷贝和深拷贝的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-public%EF%BC%8Cprotected%E5%92%8Cprivate%E6%9D%83%E9%99%90%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">27. public，protected和private权限的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">28. 如何用代码判断大小端存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-volatile%E3%80%81mutable%E5%92%8Cexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">29. volatile、mutable和explicit关键字的用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-C-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84new%EF%BC%9F"><span class="toc-text">30. C++中有几种类型的new？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">31. 形参与实参的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-text">32. 值传递、指针传递、引用传递的区别和效率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-C-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">33. C++有哪几种的构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">34. 什么情况下会调用拷贝构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E8%AF%B4%E8%AF%B4C-%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">35. 说说C++中的初始化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E8%B5%8B%E5%80%BC%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-text">36. 直接初始化、拷贝初始化、赋值的差别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">37. 静态变量什么时候初始化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-delete%E3%80%81delete-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">38. delete、delete []的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-malloc%E3%80%81calloc%E3%80%81realloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">39. malloc、calloc、realloc的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E8%AF%B4%E8%AF%B4%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">40. 说说类成员的初始化方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">41. 构造函数的执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">42. 析构函数的执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">43. 有哪些情况必须使用初始化列表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">44. 初始化列表的初始化顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-C-%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84string%E4%B8%8EC%E4%B8%AD%E7%9A%84-char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">45. C++中新增的string与C中的 char *有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">46. 什么是内存泄露，如何检测与避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%EF%BC%9F"><span class="toc-text">47. 什么是内存溢出和内存越界？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E4%BB%8B%E7%BB%8DC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">48. 介绍C++面向对象的三大特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E8%AF%B4%E8%AF%B4C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">49. 说说C++的四种强制转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%9F"><span class="toc-text">50. 如何获得结构成员相对于结构开头的字节偏移量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9F"><span class="toc-text">51. 静态类型和动态类型，静态绑定和动态绑定的介绍？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">52. 全局变量和局部变量有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">53. 指针加减计算要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">54. 怎样判断两个浮点数是否相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%EF%BC%9F"><span class="toc-text">55. 类如何实现只能静态分配和只能动态分配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E7%9F%A5%E9%81%93C-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%E5%90%97-%E5%AE%83%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-text">56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%9F"><span class="toc-text">57. 为什么模板类一般都是放在一个头文件中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E4%BD%A0%E4%BA%86%E8%A7%A3%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%90%97%EF%BC%9F"><span class="toc-text">58. 你了解重载运算符吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E5%89%8D-%E5%92%8C%E5%90%8E-%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">59. 前++和后++重载的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">61. 条件编译的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">62. 隐式转换是什么，如何消除类的隐式转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-text">63. 如何在不使用额外空间的情况下，交换两个数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E4%BD%A0%E7%9F%A5%E9%81%93strcpy%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">64. 你知道strcpy和memcpy的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">65. 如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-static-cast%E6%AF%94C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BC%BA%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">66. static_cast比C语言中的转换强在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8Cmemset-this-0-sizeof-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">67. 成员函数里memset(this,0,sizeof(*this))会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%97-%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">68. 你知道回调函数吗?它的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">69. C++从代码到可执行程序经历了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-text">70. 类的对象存储空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">71. 静态链接和动态链接的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">72. 为什么不能把所有的函数写成内联函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">73. 为什么C++没有垃圾回收机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E8%AF%B4%E8%AF%B4C-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="toc-text">74. 说说C++的内存分区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-%E8%AF%B4%E8%AF%B4%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">75. 说说友元函数和友元类的特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-%E5%85%B3%E4%BA%8Ethis%E6%8C%87%E9%92%88%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">76. 关于this指针你知道什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">77. 在成员函数中调用delete this会出现什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">78. 如果在类的析构函数中调用delete this，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">79. C++中类的数据成员和成员函数内存分布情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-C-%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">80. C++的多态怎么实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">81. 为什么要把析构函数写成虚函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-text">82. 虚函数表存放在内存的什么区域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">83. 模板偏特化了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">84. 哪些函数不能被定义为虚函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">85. 构造函数和析构函数可以调用虚函数吗，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">86. 构造函数和析构函数可否抛出异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">87. 模板类和模板函数的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">88. 什么是虚继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">89. 抽象基类为什么不能创建对象？纯虚函数又是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-%E8%AF%B4%E8%AF%B4RTTI%EF%BC%9F"><span class="toc-text">90. 说说RTTI？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%BC%80%E5%8F%91%E8%80%85%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">91. 多继承的优缺点，作为一个开发者怎么看待多继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC%EF%BC%9F"><span class="toc-text">92. 为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8C-C-%E4%B8%AD%E8%A6%81%E5%B0%86%E4%BB%A3%E7%A0%81%E5%88%86%E4%B8%BA%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%86%99%E5%88%B0%E4%B8%80%E8%B5%B7%E5%90%97%EF%BC%9F"><span class="toc-text">93. 为什么在C&#x2F;C++中要将代码分为头文件和源文件，不能写到一起吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11"><span class="toc-text">C++11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-auto%E3%80%81decltype%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">1. auto、decltype的用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-C-%E4%B8%ADNULL%E5%92%8Cnullptr%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. C++中NULL和nullptr的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4final%E5%92%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="toc-text">3. 说说final和override关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">4. C++中的智能指针？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4STL%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">5. 说说STL容器中的智能指针？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4lambda%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">6. 说说lambda函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">7. 什么是声明时初始化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-C-11%E6%B7%BB%E5%8A%A0%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="toc-text">8. C++11添加哪几种构造函数关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%AF%B4%E8%AF%B4C-%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%9F"><span class="toc-text">9. 说说C++的左值和右值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">10. 说说移动构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">11. 什么是列表初始化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">12.初始化列表和列表初始化的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFSTL%EF%BC%9F"><span class="toc-text">1.什么是STL？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SGI%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">2.SGI的二级空间配置器了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-traits%E6%8A%80%E6%B3%95"><span class="toc-text">3.traits技法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4STL%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-text">4.说说STL中的容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AFSTL%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%92%8C%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-text">5. 什么是STL的顺序容器和关联式容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4STL%E7%9A%84%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9F"><span class="toc-text">6. 说说STL的容器适配器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B4%E8%AF%B4STL%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-text">7. 说说STL的迭代器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E8%AF%B4STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-text">8. 说说STL容器的线程安全性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">9. STL容器的使用场景？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/分布式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Kevinの分布式学习笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 Kevinの操作系统笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (24)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Redis/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/etcd/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>