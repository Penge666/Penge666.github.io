<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis核心原理 | Penge666</title><meta name="keywords" content="Redis,数据库"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis核心原理">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis核心原理">
<meta property="og:url" content="https://penge666.github.io/posts/21acb7cf.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="Redis核心原理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_8.webp">
<meta property="article:published_time" content="2024-03-28T09:36:26.000Z">
<meta property="article:modified_time" content="2024-06-04T12:00:07.665Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_8.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/21acb7cf"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis核心原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-04 20:00:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Redis核心原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-03-28T09:36:26.000Z" title="发表于 2024-03-28 17:36:26">2024-03-28</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-04T12:00:07.665Z" title="更新于 2024-06-04 20:00:07">2024-06-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right post-meta-separator"></i><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Redis/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">4.7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>180分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis核心原理"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="01-Redis-是如何执行的">01 Redis 是如何执行的</h2>
<p>Redis 是如何执行的？</p>
<h3 id="命令执行流程">命令执行流程</h3>
<p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604094617256.png" alt="image-20240604094617256"></p>
<p><strong>步骤一：用户输入一条命令</strong></p>
<p><strong>步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端</strong></p>
<p>客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监测链接客户端的 socket 链接，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 开启 Socket 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
</blockquote>
<p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，<strong>这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的</strong>，<strong>如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义</strong>，这样会加大服务器的运算量，而直接发送通讯协议，相当于把服务器端的解析工作交给了每一个客户端，这样会很大程度的提高 Redis 的运行速度。例如，当我们输入 <code>set key val</code> 命令时，客户端会把这个命令转换为 <code>*3\r\n$3\r\nSET\r\n$4\r\nKEY\r\n$4\r\nVAL\r\n</code> 协议发送给服务器端。 更多通讯协议，可访问官方文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a></p>
<p><strong>扩展知识：I/O 多路复用</strong></p>
<p>Redis 使用的是 I/O 多路复用功能来监听多 socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。</p>
<p>综合来说，此步骤的执行流程如下：</p>
<ul>
<li>与服务器端以 socket 和 I/O 多路复用的技术建立链接；</li>
<li>将命令转换为 Redis 通讯协议，再将这些协议发送至缓冲区。</li>
</ul>
<p><strong>步骤三：服务器端接收到命令</strong></p>
<p>服务器会先去输入缓冲中读取数据，然后判断数据的大小是否超过了系统设置的值(默认是 1GB)，如果大于此值就会返回错误信息，并关闭客户端连接。 默认大小如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604094816486.png" alt="image-20240604094816486"></p>
<p>当数据大小验证通过之后，服务器端会对输入缓冲区中的请求命令进行分析，提取命令请求中包含的命令参数，存储在 client 对象(服务器端会为每个链接创建一个 Client 对象)的属性中。</p>
<p><strong>步骤四：执行前准备</strong></p>
<p>① 判断是否为退出命令，如果是则直接返回；</p>
<p>② 非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；</p>
<p>③ 获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；</p>
<p>④ 用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；</p>
<p>⑤ 集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；</p>
<p>⑥ 检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；</p>
<p>⑦ 持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；</p>
<p>⑧ 集群模式最少从节点(slave)验证，如果是集群模式并且配置了 repl<em>min</em>slaves<em>to</em>write(最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；</p>
<p>⑨ 只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；</p>
<p>⑩ 客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。</p>
<p>⑪ 从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；</p>
<p>⑫ 服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；</p>
<p>⑬ lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；</p>
<p>⑭ 事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；</p>
<p>⑮ 监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。</p>
<p>当服务器经过以上操作之后，就可以执行真正的操作命令了。</p>
<p><strong>步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。</strong></p>
<p><strong>步骤六：执行完后相关记录和统计</strong> ① 检查慢查询是否开启，如果开启会记录慢查询日志； ② 检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1； ③ 检查持久化功能是否开启，如果开启则会记录持久化信息； ④ 如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。</p>
<p><strong>步骤七：返回结果给客户端</strong> 命令执行完之后，服务器会通过 socket 的方式把执行结果发送给客户端，客户端再把结果展示给用户，至此一条命令的执行就结束了。</p>
<h3 id="小结">小结</h3>
<p>当用户输入一条命令之后，客户端会以 socket 的方式把数据转换成 Redis 协议，并发送至服务器端，服务器端在接受到数据之后，会先将协议转换为真正的执行命令，在经过各种验证以保证命令能够正确并安全的执行，但验证处理完之后，会调用具体的方法执行此条命令，执行完成之后会进行相关的统计和记录，然后再把执行结果返回给客户端，整个执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604094830172.png" alt="image-20240604094830172"></p>
<h2 id="02-Redis-快速搭建与使用">02 Redis 快速搭建与使用</h2>
<p>略</p>
<h2 id="03-Redis-持久化——RDB">03 Redis 持久化——RDB</h2>
<p>Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604095023010.png" alt="image-20240604095023010"></p>
<p>Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。</p>
<h3 id="1-持久化的几种方式">1 持久化的几种方式</h3>
<p>Redis 持久化拥有以下三种方式：</p>
<ul>
<li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li>
</ul>
<p>因为每种持久化方案，都有特定的使用场景，让我们先从 RDB 持久化说起吧。</p>
<h3 id="2-RDB简介">2 RDB简介</h3>
<p>RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。</p>
<h3 id="3-持久化触发">3 持久化触发</h3>
<p>RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。</p>
<h4 id="1）手动触发">1）手动触发</h4>
<p>手动触发持久化的操作有两个： <code>save</code> 和 <code>bgsave</code> ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。</p>
<h5 id="①-save-命令">① save 命令</h5>
<p>在客户端中执行 <code>save</code> 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以<strong>在生产环境一定要慎用</strong>。</p>
<p>补充：查看redis安装路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/reid-strong$ ps -ef |  grep redis</span><br><span class="line">redis       1419       1  0 6月03 ?       00:02:00 /usr/bin/redis-server 127.0.0.1:6379</span><br><span class="line">sv          8986    3312  0 6月03 pts/0   00:00:00 redis-cli</span><br><span class="line">sv         21201   21000  0 09:54 pts/11   00:00:00 grep --color=auto redis</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/reid-strong$ <span class="built_in">ls</span> -l /proc/8986/cwd</span><br><span class="line">lrwxrwxrwx 1 sv sv 0 6月   3 20:54 /proc/8986/cwd -&gt; /home/sv</span><br></pre></td></tr></table></figure>
<p><code>save</code> 命令使用如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604095845958.png" alt="image-20240604095845958"></p>
<p>从图片可以看出，当执行完 <code>save</code> 命令之后，持久化文件 <code>dump.rdb</code> 的修改时间就变了，这就表示 <code>save</code> 成功的触发了 RDB 持久化。 <code>save</code> 命令执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604095859770.png" alt="image-20240604095859770"></p>
<h5 id="②-bgsave-命令">② bgsave 命令</h5>
<p>bgsave（background save）既后台保存的意思， 它和 <code>save</code> 命令最大的区别就是 <code>bgsave</code> 会 fork() 一个子进程来执行持久化，整个过程中只有在 fork() 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 <code>save</code> 命令来说，显然 <code>bgsave</code> 命令更适合我们使用。 <code>bgsave</code> 命令使用，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
<p><code>bgsave</code> 执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604100015348.png" alt="image-20240604100015348"></p>
<h4 id="2）自动触发">2）自动触发</h4>
<p>说完了 RDB 的手动触发方式，下面来看如何自动触发 RDB 持久化？ RDB 自动持久化主要来源于以下几种情况。</p>
<h5 id="①-save-m-n">① save m n</h5>
<p><code>save m n</code> 是指在 m 秒内，如果有 n 个键发生改变，则自动触发持久化。 参数 m 和 n 可以在 Redis 的配置文件中找到，例如，<code>save 60 1</code> 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code> 命令。 注意：当设置多个 save m n 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 save m n 命令：</p>
<ul>
<li>save 60 10</li>
<li>save 600 1</li>
</ul>
<p>当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化。</p>
<h5 id="②-flushall">② flushall</h5>
<p><code>flushall</code> 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 <code>flushall</code> 命令之后，则会触发自动持久化，把 RDB 文件清空。 执行结果如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h5 id="③-主从同步触发">③ 主从同步触发</h5>
<p>在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 <code>bgsave</code> 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。</p>
<h3 id="4-配置说明">4 配置说明</h3>
<p>查看文件所在路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ whereis redis.conf</span><br><span class="line">redis: /etc/redis</span><br></pre></td></tr></table></figure>
<p>合理的设置 RDB 的配置，可以保障 Redis 高效且稳定的运行，下面一起来看 RDB 的配置项都有哪些？</p>
<p>RDB 配置参数可以在 Redis 的配置文件中找见，具体内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RDB 保存的条件</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RDB 文件压缩</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RDB 文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># RDB 文件目录</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure>
<p>其中比较重要的参数如下列表： <strong>① save 参数</strong> 它是用来配置触发 RDB 持久化条件的参数，满足保存条件时将会把数据持久化到硬盘。 默认配置说明如下：</p>
<ul>
<li>save 900 1：表示 900 秒内如果至少有 1 个 key 值变化，则把数据持久化到硬盘；</li>
<li>save 300 10：表示 300 秒内如果至少有 10 个 key 值变化，则把数据持久化到硬盘；</li>
<li>save 60 10000：表示 60 秒内如果至少有 10000 个 key 值变化，则把数据持久化到硬盘。</li>
</ul>
<p><strong>② rdbcompression 参数</strong> 它的默认值是 <code>yes</code> 表示开启 RDB 文件压缩，Redis 会采用 LZF 算法进行压缩。如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为关闭此功能，这样的缺点是需要更多的磁盘空间来保存文件。 <strong>③ rdbchecksum 参数</strong> 它的默认值为 <code>yes</code> 表示写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</p>
<h3 id="5-配置查询">5 配置查询</h3>
<p>Redis 中可以使用命令查询当前配置参数。查询命令的格式为：<code>config get xxx</code> ，例如，想要获取 RDB 文件的存储名称设置，可以使用 <code>config get dbfilename</code> ，执行效果如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dbfilename</span><br><span class="line">1) <span class="string">&quot;dbfilename&quot;</span></span><br><span class="line">2) <span class="string">&quot;dump.rdb&quot;</span></span><br></pre></td></tr></table></figure>
<p>查询 RDB 的文件目录，可使用命令 <code>config get dir</code> ，执行效果如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/var/lib/redis&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-配置设置">6 配置设置</h3>
<p>设置 RDB 的配置，可以通过以下两种方式：</p>
<ul>
<li>手动修改 Redis 配置文件；</li>
<li>使用命令行设置，例如，使用 <code>config set dir &quot;/usr/data&quot;</code> 就是用于修改 RDB 的存储目录。</li>
</ul>
<p><strong>注意</strong>：手动修改 Redis 配置文件的方式是全局生效的，即重启 Redis 服务器设置参数也不会丢失，而使用命令修改的方式，在 Redis 重启之后就会丢失。但手动修改 Redis 配置文件，想要立即生效需要重启 Redis 服务器，而命令的方式则不需要重启 Redis 服务器。</p>
<blockquote>
<p>小贴士：Redis 的配置文件位于 Redis 安装目录的根路径下，默认名称为 redis.conf。</p>
</blockquote>
<h3 id="7-RDB-文件恢复">7 RDB 文件恢复</h3>
<p>当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。 如果根目录没有 dump.rdb 文件，请先将 dump.rdb 文件移动到 Redis 的根目录。 <strong>验证 RDB 文件是否被加载</strong> Redis 在启动时有日志信息，会显示是否加载了 RDB 文件，我们执行 Redis 启动命令：<code>src/redis-server redis.conf</code> ，如下图所示：</p>
<h3 id="8-RDB-优缺点">8 RDB 优缺点</h3>
<h4 id="1）RDB-优点">1）RDB 优点</h4>
<ul>
<li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li>
<li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li>
<li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</li>
<li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li>
</ul>
<h4 id="2）RDB-缺点">2）RDB 缺点</h4>
<ul>
<li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；</li>
<li>RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li>
</ul>
<h3 id="9-禁用持久化">9 禁用持久化</h3>
<p>禁用持久化可以提高 Redis 的执行效率，如果对数据丢失不敏感的情况下，可以在连接客户端的情况下，执行 <code>config set save &quot;&quot;</code> 命令即可禁用 Redis 的持久化，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> save <span class="string">&quot;&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h3 id="10-小结">10 小结</h3>
<p>【RDB原理,手动触发（save,bgsave），自动触发，文件名，以及简单设置】</p>
<p>通过本文我们可以得知，RDB 持久化分为手动触发和自动触发两种方式，它的优点是存储文件小，Redis 启动 时恢复数据比较快，缺点是有丢失数据的风险。RDB 文件的恢复也很简单，只需要把 RDB 文件放到 Redis 的根目录，在 Redis 启动时就会自动加载并恢复数据。</p>
<h2 id="04-Redis-持久化——AOF">04 Redis 持久化——AOF</h2>
<p>使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止的话，就会造成最新的数据全部丢失。</p>
<p>可能会操作 Redis 服务意外终止的条件：</p>
<ul>
<li>安装 Redis 的机器停止运行，蓝屏或者系统崩溃；</li>
<li>安装 Redis 的机器出现电源故障，例如突然断电；</li>
<li>使用 <code>kill -9 Redis_PID</code> 等。</li>
</ul>
<p>那么如何解决以上的这些问题呢？Redis 为我们提供了另一种持久化的方案——AOF。</p>
<h3 id="1-简介">1 简介</h3>
<p>AOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。</p>
<h3 id="2-持久化查询和设置">2 持久化查询和设置</h3>
<h4 id="1）查询-AOF-启动状态">1）查询 AOF 启动状态</h4>
<p>使用 <code>config get appendonly</code> 命令，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get appendonly</span><br><span class="line">1) <span class="string">&quot;appendonly&quot;</span></span><br><span class="line">2) <span class="string">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中，第一行为 AOF 文件的名称，而最后一行表示 AOF 启动的状态，yes 表示已启动，no 表示未启动。</p>
<h4 id="2）开启-AOF-持久化">2）开启 AOF 持久化</h4>
<p>Redis 默认是关闭 AOF 持久化的，想要开启 AOF 持久化，有以下两种方式：</p>
<ul>
<li>通过命令行的方式；</li>
<li>通过修改配置文件的方式（redis.conf）。</li>
</ul>
<p>下面分别来看以上两种方式的实现。</p>
<h5 id="①-命令行启动-AOF">① 命令行启动 AOF</h5>
<p>命令行启动 AOF，使用 <code>config set appendonly yes</code> 命令，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> appendonly <span class="built_in">yes</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p><strong>命令行启动 AOF 的优缺点</strong>：命令行启动优点是无需重启 Redis 服务，缺点是如果 Redis 服务重启，则之前使用命令行设置的配置就会失效。</p>
<h5 id="②-配置文件启动-AOF">② 配置文件启动 AOF</h5>
<p>Redis 的配置文件在它的根路径下的 redis.conf 文件中，获取 Redis 的根目录可以使用命令 <code>config get dir</code> 获取，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/var/lib/redis&quot;</span></span><br></pre></td></tr></table></figure>
<p>只需要在配置文件中设置 <code>appendonly yes</code> 即可，默认 <code>appendonly no</code> 表示关闭 AOF 持久化。 <strong>配置文件启动 AOF 的优缺点</strong>：<strong>修改配置文件的缺点是每次修改配置文件都要重启 Redis 服务才能生效，优点是无论重启多少次 Redis 服务，配置文件中设置的配置信息都不会失效</strong>。</p>
<h3 id="3-触发持久化">3 触发持久化</h3>
<p>AOF 持久化开启之后，只要满足一定条件，就会触发 AOF 持久化。AOF 的触发条件分为两种：自动触发和手动触发。</p>
<h4 id="1）自动触发">1）自动触发</h4>
<p>有两种情况可以自动触发 AOF 持久化，分为是：<strong>满足 AOF 设置的策略触发</strong>和**满足 AOF 重写触发。**其中，AOF 重写触发会在本文的后半部分详细介绍，这里重点来说 AOF 持久化策略都有哪些。</p>
<p><strong>AOF 持久化策略</strong>，分为以下三种：</p>
<ul>
<li>always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；</li>
<li>everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；</li>
<li>no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。</li>
</ul>
<p>这三种配置可以在 Redis 的配置文件（redis.conf）中设置，如下代码所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启每秒写入一次的持久化策略</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：因为每次写入磁盘都会对 Redis 的性能造成一定的影响，所以要根据用户的实际情况设置相应的策略，一般设置每秒写入一次磁盘的频率就可以满足大部分的使用场景了。</p>
</blockquote>
<p>触发自动持久化的两种情况，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604101208002.png" alt="image-20240604101208002"></p>
<h4 id="2）手动触发">2）手动触发</h4>
<p>在客户端执行 <code>bgrewriteaof</code> 命令就可以手动触发 AOF 持久化，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604101247714.png" alt="image-20240604101247714"></p>
<p>可以看出执行完 <code>bgrewriteaof</code> 命令之后，AOF 持久化就会被触发。</p>
<h3 id="4-AOF-文件重写">4 AOF 文件重写</h3>
<p>AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。</p>
<h4 id="1）什么是-AOF-重写？">1）什么是 AOF 重写？</h4>
<p>【easy say：直接从内存中取出数据生成命令】</p>
<p>AOF 重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。</p>
<h4 id="2）AOF-重写实现">2）AOF 重写实现</h4>
<p>触发 AOF 文件重写，要满足两个条件，这两个条件也是配置在 Redis 配置文件中的，它们分别：</p>
<ul>
<li>auto-aof-rewrite-min-size：允许 AOF 重写的最小文件容量，默认是 64mb 。</li>
<li>auto-aof-rewrite-percentage：AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次（上次）的 AOF 文件大一倍时，才会启动 AOF 文件重写。</li>
</ul>
<p>查询 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 的值，可使用 <code>config get xxx</code> 命令，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get auto-aof-rewrite-min-size</span><br><span class="line">1) <span class="string">&quot;auto-aof-rewrite-min-size&quot;</span></span><br><span class="line">2) <span class="string">&quot;67108864&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：只有同时满足 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 设置的条件，才会触发 AOF 文件重写。</p>
</blockquote>
<p><strong>注意</strong>：使用 <code>bgrewriteaof</code> 命令，可以自动触发 AOF 文件重写。</p>
<h4 id="3）AOF-重写流程">3）AOF 重写流程</h4>
<p>AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。</p>
<p>详细说：在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作后，服务器就会重写缓冲区中的所有内容追加到新的AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p>
<h3 id="5-配置说明">5 配置说明</h3>
<p>合理的设置 AOF 的配置，可以保障 Redis 高效且稳定的运行，以下是 AOF 的全部配置信息和说明。</p>
<p>AOF 的配置参数在 Redis 的配置文件中，也就是 Redis 根路径下的 <code>redis.conf</code> 文件中，配置参数和说明如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启 AOF，yes 为开启，默认是关闭</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF 默认文件名</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF 持久化策略配置</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次的 AOF 文件大一倍时，才会启动 AOF 文件重写。</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 AOF 重写的最小文件容量</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启启动时加载 AOF 文件效验，默认值是 yes，表示尽可能的加载 AOF 文件，忽略错误部分信息，并启动 Redis 服务。</span></span><br><span class="line"><span class="comment"># 如果值为 no，则表示，停止启动 Redis，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。</span></span><br><span class="line">aof-load-truncated <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>其中比较重要的是 appendfsync 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</p>
<p><strong>fsync 的英文全称是 File Synchronization，意为文件同步。</strong></p>
<h3 id="6-数据恢复">6 数据恢复</h3>
<h4 id="1）正常数据恢复">1）正常数据恢复</h4>
<p>正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动，执行如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604102739331.png" alt="image-20240604102739331"></p>
<p>其中 <code>DB loaded from append only file......</code> 表示 Redis 服务器在启动时，先去加载了 AOF 持久化文件。</p>
<blockquote>
<p>小贴士：默认情况下 appendonly.aof 文件保存在 Redis 的根目录下。</p>
</blockquote>
<p><strong>持久化文件加载规则</strong></p>
<ul>
<li>如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；</li>
<li>如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；</li>
<li>如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。</li>
</ul>
<p>在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 AOF 和 RDB 的加载流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604102750574.png" alt="image-20240604102750574"></p>
<h4 id="2）简单异常数据恢复">2）简单异常数据恢复</h4>
<p>在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。</p>
<p>在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 <code>aof-load-truncated</code> 等于 <code>yes</code> 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis，执行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">*</span> <span class="string">Reading</span> <span class="string">RDB</span> <span class="string">preamble</span> <span class="string">from</span> <span class="string">AOF</span> <span class="string">file...</span></span><br><span class="line"><span class="string">*</span> <span class="string">Reading</span> <span class="string">the</span> <span class="string">remaining</span> <span class="string">AOF</span> <span class="string">tail...</span></span><br><span class="line"><span class="comment"># !!! Warning: short read while loading the AOF file !!!</span></span><br><span class="line"><span class="comment"># !!! Truncating the AOF at offset 439 !!!</span></span><br><span class="line"><span class="comment"># AOF loaded anyway because aof-load-truncated is enabled</span></span><br></pre></td></tr></table></figure>
<h4 id="3）复杂异常数据恢复">3）复杂异常数据恢复</h4>
<p>AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行，错误信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Reading the remaining AOF <span class="built_in">tail</span>...</span><br><span class="line"><span class="comment"># Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;</span></span><br></pre></td></tr></table></figure>
<p>出现此类问题的解决方案如下：</p>
<ol>
<li>首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 <code>redis-check-aof</code> 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；</li>
<li>如果无法手动修复，我们可以使用 <code>redis-check-aof --fix</code> 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。</li>
</ol>
<h3 id="7-优缺点">7 优缺点</h3>
<h4 id="AOF-优点">AOF 优点</h4>
<ul>
<li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li>
<li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li>
<li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li>
</ul>
<h4 id="AOF-缺点">AOF 缺点</h4>
<ul>
<li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li>
<li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li>
<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li>
</ul>
<h3 id="8-小结">8 小结</h3>
<p>AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大，为了解决这个问题，AOF 提供自动化重写机制，最大程度的减少了 AOF 占用空间大的问题。同时 AOF 也提供了很方便的异常文件恢复命令： <code>redis-check-aof --fix</code> ，为使用 AOF 提供了很好的保障。</p>
<p>【AOF，开启方式，触发持久化，AOF重写，config文件配置文件名】</p>
<p>总结下：两种情况可以自动触发 AOF 持久化</p>
<p>满足 AOF 设置的策略触发<strong>和</strong>满足 AOF 重写触发</p>
<p>满足策略触发（不会fork子进程）：</p>
<ol>
<li>每次有写操作就同步（always）：这种策略下，每次执行写命令后，Redis会立即将该命令写入硬盘。这种模式下，数据的安全性最高，但性能影响也最大。这种情况下，Redis主进程直接进行写操作，不会新启动子进程。</li>
<li>每秒同步一次（everysec）：这种策略下，Redis会每秒将缓冲区中的写命令同步到硬盘。这种模式下，如果Redis意外宕机，最多可能丢失一秒内的写命令。这种模式下，性能和数据安全性比较平衡。这种情况下，Redis主进程直接进行写操作，不会新启动子进程。</li>
<li>完全由操作系统控制（no）：这种策略下，Redis不主动进行同步操作，完全交给操作系统来决定何时同步数据到硬盘。这种模式下，性能最好，但数据安全性最差。这种情况下，Redis主进程直接进行写操作，不会新启动子进程。</li>
</ol>
<p>满足重写触发</p>
<ul>
<li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作后，服务器就会重写缓冲区中的所有内容追加到新的AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</li>
</ul>
<h2 id="05-Redis-持久化——混合持久化">05 Redis 持久化——混合持久化</h2>
<p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时使用 RDB 和 AOF 各种的优点，Redis 4.0 之后新增了混合持久化的方式。</p>
<p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p>
<p>混合持久化的数据存储结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104522833.png" alt="image-20240604104522833"></p>
<h3 id="1-开启混合持久化">1 开启混合持久化</h3>
<p>查询是否开启混合持久化可以使用 <code>config get aof-use-rdb-preamble</code> 命令，执行结果如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get aof-use-rdb-preamble</span><br><span class="line">1) <span class="string">&quot;aof-use-rdb-preamble&quot;</span></span><br><span class="line">2) <span class="string">&quot;yes&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中 yes 表示已经开启混合持久化，no 表示关闭，Redis 5.0 默认值为 yes。 如果是其他版本的 Redis 首先需要检查一下，是否已经开启了混合持久化，如果关闭的情况下，可以通过以下两种方式开启：</p>
<ul>
<li>通过命令行开启</li>
<li>通过修改 Redis 配置文件开启</li>
</ul>
<h4 id="1）通过命令行开启">1）通过命令行开启</h4>
<p>使用命令 <code>config set aof-use-rdb-preamble yes</code> 执行结果如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  config <span class="built_in">set</span> aof-use-rdb-preamble <span class="built_in">yes</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：命令行设置配置的缺点是重启 Redis 服务之后，设置的配置就会失效。</p>
</blockquote>
<h4 id="2）通过修改-Redis-配置文件开启">2）通过修改 Redis 配置文件开启</h4>
<p>在 Redis 的根路径下找到 redis.conf 文件，把配置文件中的 <code>aof-use-rdb-preamble no</code> 改为 <code>aof-use-rdb-preamble yes</code> 如下图所示：</p>
<h3 id="2-实例运行">2 实例运行</h3>
<p>当在混合持久化关闭的情况下，使用 <code>bgrewriteaof</code> 触发 AOF 文件重写之后，查看 appendonly.aof 文件的持久化日志，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104702630.png" alt="image-20240604104702630"></p>
<p>可以看出，当混合持久化关闭的情况下 AOF 持久化文件存储的为标准的 AOF 格式的文件。 当混合持久化开启的模式下，使用 <code>bgrewriteaof</code> 命令触发 AOF 文件重写，得到 appendonly.aof 的文件内容如下图所示：</p>
<h3 id="3-数据恢复和源码解析">3 数据恢复和源码解析</h3>
<p>混合持久化的数据恢复和 AOF 持久化过程是一样的，只需要把 appendonly.aof 放到 Redis 的根目录，在 Redis 启动时，只要开启了 AOF 持久化，Redis 就会自动加载并恢复数据。 Redis 启动信息如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104723137.png" alt="image-20240604104723137"></p>
<p>可以看出 Redis 在服务器初始化的时候加载了 AOF 文件的内容。</p>
<h4 id="1）混合持久化的加载流程">1）混合持久化的加载流程</h4>
<p>混合持久化的加载流程如下：</p>
<ol>
<li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li>
<li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程；</li>
<li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li>
<li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li>
</ol>
<p>AOF 加载流程图如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104735691.png" alt="image-20240604104735691"></p>
<p>2）源码解析</p>
<p>Redis 判断 AOF 文件的开头是否是 RDB 格式的，是通过关键字 <code>REDIS</code> 判断的，RDB 文件的开头一定是 <code>REDIS</code> 关键字开头的，判断源码在 Redis 的 src/aof.c 中，核心代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line"><span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// AOF 文件开头非 RDB 格式，非混合持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* RDB preamble. Pass loading the RDB functions. */</span></span><br><span class="line">    rio rdb;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    <span class="comment">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF</span></span><br><span class="line">    <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,<span class="literal">NULL</span>,<span class="number">1</span>) != C_OK) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载 AOF 格式的数据</span></span><br></pre></td></tr></table></figure>
<p>可以看出 Redis 是通过判断 AOF 文件的开头是否是 <code>REDIS</code> 关键字，来确定此文件是否为混合持久化文件的。</p>
<blockquote>
<p>小贴士：AOF 格式的开头是 *，而 RDB 格式的开头是 REDIS。</p>
</blockquote>
<h3 id="4-优缺点">4 优缺点</h3>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h3 id="5-持久化最佳实践">5 持久化最佳实践</h3>
<p>持久化虽然保证了数据不丢失，但同时拖慢了 Redis 的运行速度，那怎么更合理的使用 Redis 的持久化功能呢？ Redis 持久化的最佳实践可从以下几个方面考虑。</p>
<h4 id="1）控制持久化开关">1）控制持久化开关</h4>
<p>使用者可根据实际的业务情况考虑，如果对数据的丢失不敏感的情况下，可考虑关闭 Redis 的持久化，这样所以的键值操作都在内存中，就可以保证最高效率的运行 Redis 了。 持久化关闭操作：</p>
<ul>
<li>关闭 RDB 持久化，使用命令： <code>config set save &quot;&quot;</code></li>
<li>关闭 AOF 和 混合持久化，使用命令： <code>config set appendonly no</code></li>
</ul>
<h4 id="2）主从部署">2）主从部署</h4>
<p>使用主从部署，一台用于响应主业务，一台用于数据持久化，这样就可能让 Redis 更加高效的运行。</p>
<h4 id="3）使用混合持久化">3）使用混合持久化</h4>
<p>混合持久化结合了 RDB 和 AOF 的优点，Redis 5.0 默认是开启的。</p>
<h4 id="4）使用配置更高的机器">4）使用配置更高的机器</h4>
<p>Redis 对 CPU 的要求并不高，反而是对内存和磁盘的要求很高，因为 Redis 大部分时候都在做读写操作，使用更多的内存和更快的磁盘，对 Redis 性能的提高非常有帮助。</p>
<h2 id="06-字符串使用与内部实现原理">06 字符串使用与内部实现原理</h2>
<p>Redis 发展到现在已经有 9 种数据类型了，其中最基础、最常用的数据类型有 5 种，它们分别是：字符串类型、列表类型、哈希表类型、集合类型、有序集合类型，而在这 5 种数据类型中最常用的是字符串类型，所以本文我们先从字符串的使用开始说起。</p>
<p>字符串类型的全称是 Simple Dynamic Strings 简称 SDS，中文意思是：简单动态字符串。它是以键值对 key-value 的形式进行存储的，根据 key 来存储和获取 value 值，它的使用相对来说比较简单，但在实际项目中应用非常广泛。</p>
<h3 id="1-字符串类型能做什么？">1 字符串类型能做什么？</h3>
<p>字符串类型的使用场景有很多，但从功能的角度来区分，大致可分为以下两种：</p>
<ul>
<li>字符串存储和操作；</li>
<li>整数类型和浮点类型的存储和计算。</li>
</ul>
<p>字符串最常用的业务场景有以下几个。</p>
<h4 id="1）页面数据缓存">1）页面数据缓存</h4>
<p>我们知道，一个系统最宝贵的资源就是数据库资源，随着公司业务的发展壮大，数据库的存储量也会越来越大，并且要处理的请求也越来越多，当数据量和并发量到达一定级别之后，数据库就变成了拖慢系统运行的“罪魁祸首”，为了避免这种情况的发生，我们可以把查询结果放入缓存(Redis)中，让下次同样的查询直接去缓存系统取结果，而非查询数据库，这样既减少了数据库的压力，同时也提高了程序的运行速度。</p>
<p>介于以上这个思路，我们可以把文章详情页的数据放入缓存系统。具体的做法是先将文章详情页序列化为字符串存入缓存，再从缓存中读取到字符串，反序列化成对象，然后再赋值到页面进行显示 (当然也可以用哈希类型进行存储，这会在下一篇文章中讲到)，这样我们就实现了文章详情页的缓存功能，架构流程对比图如下所示。</p>
<p>原始系统运行流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104932243.png" alt="image-20240604104932243"></p>
<p>引入缓存系统后的流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104943641.png" alt="image-20240604104943641"></p>
<h4 id="2）数字计算与统计">2）数字计算与统计</h4>
<p>Redis 可以用来存储整数和浮点类型的数据，并且可以通过命令直接累加并存储整数信息，这样就省去了每次先要取数据、转换数据、拼加数据、再存入数据的麻烦，只需要使用一个命令就可以完成此流程，具体实现过程本文下半部分会讲。这样我们就可以使用此功能来实现访问量的统计，当有人访问时访问量 +1 就可以了。</p>
<h4 id="3）共享-Session-信息">3）共享 Session 信息</h4>
<p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题。分布式系统每次会把请求随机分配到不同的服务器，因此我们需要借助缓存系统对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去统一的缓存系统获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<p>分布式系统单独存储 Session 流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604104957031.png" alt="image-20240604104957031"></p>
<p>分布式系统使用同一的缓存系统存储 Session 流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105008408.png" alt="image-20240604105008408"></p>
<h3 id="2-字符串如何使用？">2 字符串如何使用？</h3>
<p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作，下面我们分别来看。</p>
<h4 id="1）命令行操作方式">1）命令行操作方式</h4>
<p>字符串的操作命令有很多，但大体可分为以下几类：</p>
<ul>
<li>单个键值对操作</li>
<li>多个键值对操作</li>
<li>数字统计</li>
</ul>
<p>我们本文使用 redis-cli 来实现对 Redis 的操作，在使用命令之前，先输入 <code>redis-cli</code> 来链接到 Redis 服务器。</p>
<h5 id="①-单个键值对操作">① 单个键值对操作</h5>
<h6 id="a-添加键值对">a.添加键值对</h6>
<p>语法：set key value [expiration EX seconds|PX milliseconds] [NX|XX] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 val1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h6 id="b-获取键值对">b.获取键值对</h6>
<p>语法：get key 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;val1&quot;</span><br></pre></td></tr></table></figure>
<h6 id="c-给元素追加值">c.给元素追加值</h6>
<p>语法：append key value 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; append k1 <span class="title function_">append</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1append&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="d-查询字符串的长度">d.查询字符串的长度</h6>
<p>语法：strlen key 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; strlen <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h5 id="②-多个键值对操作">② 多个键值对操作</h5>
<h6 id="a-创建一个或多个键值对">a.创建一个或多个键值对</h6>
<p>语法：mset key value [key value …] 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k2 v2 k3 v3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：mset 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，不会出现某些 key 被更新，而另一些 key 没被更新的情况。</p>
</blockquote>
<h6 id="b-查询一个或多个元素">b.查询一个或多个元素</h6>
<p>语法：mget key [key …] 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget k2 k3</span><br><span class="line">1) &quot;v2&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br></pre></td></tr></table></figure>
<h5 id="③-数字统计">③ 数字统计</h5>
<p>在 Redis 中可以直接操作整型和浮点型，例如可以直接使用命令来加、减值。</p>
<h6 id="a-给整数类型的值加-1">a.给整数类型的值加 1</h6>
<p>语法：incr key 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr k1</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure>
<h6 id="b-给整数类型的值减-1">b.给整数类型的值减 1</h6>
<p>语法：decr key 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr k1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<h6 id="c-根据-key-减去指定的值">c.根据 key 减去指定的值</h6>
<p>语法：decrby key decrement 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; decrby k1 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行减法操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; decrby k2 3</span><br><span class="line">(integer) -3</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;-3&quot;</span><br></pre></td></tr></table></figure>
<h6 id="d-根据-key-加指定的整数值">d.根据 key 加指定的整数值</h6>
<p>语法：incrby key increment 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby k1 2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行加整数值的操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incrby k3 5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure>
<h6 id="e-根据-key-加上指定的浮点数">e.根据 key 加上指定的浮点数</h6>
<p>语法：incrbyfloat key increment 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat k3 4.9</span><br><span class="line">&quot;9.9&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;9.9&quot;</span><br></pre></td></tr></table></figure>
<p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行加浮点数的操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat k4 4.4</span><br><span class="line">&quot;4.4&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">&quot;4.4&quot;</span><br></pre></td></tr></table></figure>
<p>更多使用命令，详见附录部分。</p>
<h4 id="2）代码操作方式">2）代码操作方式</h4>
<p>本文我们使用 Java 语言来实现对 Redis 的操作，首先我们在项目中添加对 Jedis 框架的引用，如果是 Maven 项目，我们会在 pom.xml 文件中添加如下信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Jedis 是 Redis 官方推荐的 Java 客户端开发包，用于实现快速简单的操作 Redis。添加完 Jedis 之后，我们来写具体的操作代码，操作函数与命令方式的调用比较相似，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// jedis.auth(&quot;xxx&quot;); // 输入密码，没有密码，可以不设置</span></span><br><span class="line">        <span class="comment">// 添加一个元素</span></span><br><span class="line">        jedis.set(<span class="string">&quot;mystr&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">myStr</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;mystr&quot;</span>);</span><br><span class="line">        System.out.println(myStr); <span class="comment">// 输出：redis</span></span><br><span class="line">        <span class="comment">// 添加多个元素(key,value,key2,value2)</span></span><br><span class="line">        jedis.mset(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;lang&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取多个元素</span></span><br><span class="line">        List&lt;String&gt; mlist = jedis.mget(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;lang&quot;</span>);</span><br><span class="line">        System.out.println(mlist);  <span class="comment">// 输出：[redis, java]</span></span><br><span class="line">        <span class="comment">// 给元素追加字符串</span></span><br><span class="line">        jedis.append(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;,mysql&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印追加的字符串</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;db&quot;</span>)); <span class="comment">// 输出：redis,mysql</span></span><br><span class="line">        <span class="comment">// 当 key 不存在时，赋值键值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">setnx</span> <span class="operator">=</span> jedis.setnx(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;db2&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为 db 元素已经存在，所以会返回 0 条修改</span></span><br><span class="line">        System.out.println(setnx); <span class="comment">// 输出：0</span></span><br><span class="line">        <span class="comment">// 字符串截取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">range</span> <span class="operator">=</span> jedis.getrange(<span class="string">&quot;db&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(range); <span class="comment">// 输出：red</span></span><br><span class="line">        <span class="comment">// 添加键值并设置过期时间(单位：毫秒)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">setex</span> <span class="operator">=</span> jedis.setex(<span class="string">&quot;db&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        System.out.println(setex); <span class="comment">// 输出：ok</span></span><br><span class="line">        <span class="comment">// 查询键值的过期时间</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> jedis.ttl(<span class="string">&quot;db&quot;</span>);</span><br><span class="line">        System.out.println(ttl); <span class="comment">// 输出：1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-代码实战">3 代码实战</h3>
<p>本文的上半部分我们讲到了字符串的很多种使用场景，本小节就以字符串存储用户对象信息为例，我们先将用户对象信息序列化为字符串存储在 Redis，再从 Redis 中取出字符串并反序列化为对象信息为例，使用 Java 语言来实现。</p>
<p>首先添加 JSON 转换类，用于对象和字符串之间的序列化和反序列化，我们这里采用 Google 的 Gson 来实现，首先在 pom.xml 文件中添加如下引用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加完 Gson 引用之后，我们来写具体的业务代码，先见用户信息序列化之后存储在 Redis 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="comment">// 构建用户数据</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Redis&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">10</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> gson.toJson(user);</span><br><span class="line"><span class="comment">// 打印用户信息(json)</span></span><br><span class="line">System.out.println(jsonUser); <span class="comment">// 输出：&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Redis&quot;,&quot;age&quot;:10&#125;</span></span><br><span class="line"><span class="comment">// 把字符串存入 Redis</span></span><br><span class="line">jedis.set(<span class="string">&quot;user&quot;</span>, jsonUser);</span><br></pre></td></tr></table></figure>
<p>当使用用户信息时，我们从 Redis 反序列化出来，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">getUserData</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">userData</span> <span class="operator">=</span> gson.fromJson(getUserData, User.class);</span><br><span class="line"><span class="comment">// 打印对象属性信息</span></span><br><span class="line">System.out.println(userData.getId() + <span class="string">&quot;:&quot;</span> + userData.getName()); <span class="comment">// 输出结果：1:Redis</span></span><br></pre></td></tr></table></figure>
<p>以上两个步骤就完成了用户信息存放至 Redis 中的过程，也是常用的经典使用场景之一。</p>
<h3 id="4-字符串的内部实现">4 字符串的内部实现</h3>
<h4 id="1）源码分析">1）源码分析</h4>
<p>Redis 3.2 之前 SDS 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> len; <span class="comment">// 已占用的字节数</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>; <span class="comment">// 剩余可以字节数</span></span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">// 存储字符串的数据空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105046151.png" alt="image-20240604105046151"></p>
<p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* 已使用长度，1 字节存储 */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* 总长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">// 真正存储字符串的数据空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* 已使用长度，2 字节存储 */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* 已使用长度，4 字节存储 */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* 已使用长度，8 字节存储 */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p>
<h4 id="2）数据类型">2）数据类型</h4>
<p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p>
<h5 id="①-int-类型">① int 类型</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 666</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>
<h5 id="②-embstr-类型">② embstr 类型</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>
<h5 id="③-raw-类型">③ raw 类型</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abcdefghigklmnopqrstyvwxyzabcdefghigklmnopqrs</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>
<p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p>
<p><strong>raw和embstr类型的区别</strong></p>
<p>这个问题涉及到了Redis内存分配的细节。在Redis中，字符串类型的对象可以使用三种不同的编码方式：int、raw和embstr。</p>
<ol>
<li>int编码：当字符串可以被解析为数字时，Redis会选择int编码。</li>
<li>raw编码：当字符串长度超过39字节时，Redis会选择raw编码。</li>
<li>embstr编码：当字符串长度小于等于39字节时，Redis会选择embstr编码。</li>
</ol>
<p>对于raw编码，Redis会先创建一个redisObject结构，然后再创建一个sdshdr结构来存储实际的字符串。这两个结构是分开的，所以Redis需要调用两次内存分配函数。</p>
<p>而对于embstr编码，Redis会一次性分配一块连续的内存，这块内存包含了redisObject结构和sdshdr结构。这样做的好处是减少了内存碎片，提高了内存使用效率。但是，这种方式只适用于较小的字符串，因为大字符串会导致内存分配的开销过大。</p>
<p>所以，这里的&quot;两次&quot;和&quot;一次&quot;，实际上是指Redis在进行内存分配时的次数</p>
<h4 id="3）为什么是-44-字节？">3）为什么是 44 字节？</h4>
<p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p>
<p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p>
<p>在 Redis 中，所有的对象都会包含 redisObject 对象头。我们先来看 redisObject 对象的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 4 bit</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 4 bit</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">// 3 个字节</span></span><br><span class="line">    <span class="type">int</span> refcount; <span class="comment">// 4 个字节</span></span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">// 8 个字节</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>它的参数说明如下：</p>
<ul>
<li>type：对象的数据类型，例如：string、list、hash 等，占用 4 bits 也就是半个字符的大小；</li>
<li>encoding：对象数据编码，占用 4 bits；</li>
<li>lru：记录对象的 LRU(Least Recently Used 的缩写，即最近最少使用)信息，内存回收时会用到此属性，占用 24 bits(3 字节)；</li>
<li>refcount：引用计数器，占用 32 bits(4 字节)；</li>
<li>*ptr：对象指针用于指向具体的内容，占用 64 bits(8 字节)。</li>
</ul>
<p>redisObject 总共占用 0.5 bytes + 0.5 bytes + 3 bytes + 4 bytes + 8 bytes = 16 bytes(字节)。</p>
<p>了解了 redisObject 之后，我们再来看 SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：SDS<em>TYPE</em>5、SDS<em>TYPE</em>8、SDS<em>TYPE</em>16、SDS<em>TYPE</em>32、SDS<em>TYPE</em>64，在这些类型中最小的存储类型为 SDS<em>TYPE</em>５，但 SDS<em>TYPE</em>５ 类型会默认转成 SDS<em>TYPE</em>8，以下源码可以证明</p>
<p>那我们直接来看 SDS<em>TYPE</em>8 的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 <code>\0</code> 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105115478.png" alt="image-20240604105115478"></p>
<h3 id="5-小结">5 小结</h3>
<p>本文介绍了字符串的定义及其使用，它的使用主要分为：单键值对操作、多键值对操作、数字统计、键值对过期操作、字符串操作进阶等。同时也介绍了字符串使用的三个场景，字符串类型可用作为：页面数据缓存，可以缓存一些文章详情信息等；数字计算与统计，例如计算页面的访问次数；也可以用作 Session 共享，用来记录管理员的登录信息等。同时我们深入的介绍了字符串的五种数据存储结构，以及字符串的三种内部数据类型，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105128355.png" alt="image-20240604105128355"></p>
<h2 id="07-附录：更多字符串操作命令">07 附录：更多字符串操作命令</h2>
<h3 id="键值对过期操作">键值对过期操作</h3>
<h4 id="a-添加键值对并设置过期时间">a.添加键值对并设置过期时间</h4>
<p>语法：set key value [expiration EX seconds|PX milliseconds] [NX|XX] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 val1 ex 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>设置键值对 k1=val1，过期时间为 1000 秒。 查询键的过期时间可以使用 ttl key，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 997</span><br></pre></td></tr></table></figure>
<h4 id="b-赋值字符串，并设置过期时间-单位-秒">b.赋值字符串，并设置过期时间(单位/秒)</h4>
<p>语法：setex key seconds value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex k1 1000 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 999</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure>
<p>如果 key 已经存在，setex 命令将会覆写原来的旧值。</p>
<h4 id="c-赋值字符串，并设置过期时间-单位-毫秒">c.赋值字符串，并设置过期时间(单位/毫秒)</h4>
<p>与 setex 用法类似，只不过 psetex 设置的单位是毫秒。 语法：psetex key milliseconds value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psetex k1 100000 v11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 97</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v11&quot;</span><br></pre></td></tr></table></figure>
<h3 id="字符串操作进阶">字符串操作进阶</h3>
<h4 id="a-根据指定的范围截取字符串">a.根据指定的范围截取字符串</h4>
<p>语法：getrange key start end 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange hello 0 4</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange hello 0 -1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange hello 0 -2</span><br><span class="line">&quot;hello worl&quot;</span><br></pre></td></tr></table></figure>
<p>负数表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。</p>
<h4 id="b-设置字符串新值并返回旧值">b.设置字符串新值并返回旧值</h4>
<p>语法：getset key value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset db mysql</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;mysql&quot;</span><br></pre></td></tr></table></figure>
<p>使用 getset 命令时，如果 key 不为字符串会报错，如下效果所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type myset</span><br><span class="line">set</span><br><span class="line">127.0.0.1:6379&gt; getset myset v1</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>
<p>根据 type 命令可以查询出 key 所对应的数据类型为非字符串，在使用 getset 命令就会报错。</p>
<h4 id="c-赋值-创建-键值对，当-key-不存在时">c.赋值(创建)键值对，当 key 不存在时</h4>
<p>如果 key 已经存在，则执行命令无效，不会修改原来的值，否则会创建新的键值对。 语法：setnx key value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx k9 v9</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k9</span><br><span class="line">&quot;v9&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx k9 v99</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k9</span><br><span class="line">&quot;v9&quot;</span><br></pre></td></tr></table></figure>
<h4 id="d-设置一个或多个键值，当所有键值都不存在时">d.设置一个或多个键值，当所有键值都不存在时</h4>
<p>语法：msetnx key value [key value …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx k5 v5 k6 v6</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; mget k5 k6</span><br><span class="line">1) &quot;v5&quot;</span><br><span class="line">2) &quot;v6&quot;</span><br></pre></td></tr></table></figure>
<p>注意：msetnx 是一个原子操作，当一个操作失败时，其他操作也会失败。例如，如果有一个已经存在的值，那么全部键值都会设置失败，效果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;val1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k8</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k8 v8</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;val1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k8</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h4 id="e-截取字符串并赋值">e.截取字符串并赋值</h4>
<p>语法：setrange key offset value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello java&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange hello 6 redis</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello redis&quot;</span><br></pre></td></tr></table></figure>
<p>如果待截取的键不存在，会当作空白字符串处理，效果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setrange mystr 3 mystring</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get mystring</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>以上这些命令基本涵盖了所有的字符串操作，有些不常用，但很好用，例如 <code>setnx key value</code> 命令，当 key 已经存在，则执行命令无效，并不会覆盖原有的值，如果没有此 key 则会新创建一个键值对。</p>
<h2 id="08-字典使用与内部实现原理">08 字典使用与内部实现原理</h2>
<p>字典类型 (Hash) 又被成为散列类型或者是哈希表类型，它是将一个键值 (key) 和一个特殊的“哈希表”关联起来，这个“哈希表”表包含两列数据：字段和值。例如我们使用字典类型来存储一篇文章的详情信息，存储结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105548439.png" alt="image-20240604105548439"></p>
<p>同理我们也可以使用字典类型来存储用户信息，并且使用字典类型来存储此类信息，是不需要手动序列化和反序列化数据的，所以使用起来更加的方便和高效。</p>
<h3 id="1-基础使用">1.基础使用</h3>
<p>首先我们使用命令行工具 redis-cli，来对字典类型进行相关的操作。</p>
<h4 id="1）插入单个元素">1）插入单个元素</h4>
<p>语法：hset key field value 示例：【hset表示hash】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash key2 value2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="2）当某键不存在时，插入数据">2）当某键不存在时，插入数据</h4>
<p>语法：hsetnx key field value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash k4 v4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k4</span><br><span class="line">&quot;v4&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>尝试插入已存在的键</strong>，不会改变原来的值，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash k4 val4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k4</span><br><span class="line">&quot;v4&quot;</span><br></pre></td></tr></table></figure>
<p>尝试修改已经存在的 k4 赋值为 val4，但并没有生效，查询 k4 的结果依然是原来的值 v4。</p>
<h4 id="3）查询单个元素">3）查询单个元素</h4>
<p>语法：hget key field 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash key1</span><br><span class="line">&quot;value1&quot;</span><br></pre></td></tr></table></figure>
<h4 id="4）删除-key-中的一个或多个元素">4）删除 key 中的一个或多个元素</h4>
<p>语法：hdel myhash field [field …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash key1 key2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>注意：不能使用类似于 <code>hdel myhash</code> 的命令删除整个 Hash 值的。</p>
<h4 id="5）某个整数值累加计算">5）某个整数值累加计算</h4>
<p>语法：hincrby key field increment 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash k3 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash k3 2</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k3</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure>
<p>更多操作命令，详见附录部分。</p>
<h3 id="2-代码实战">2.代码实战</h3>
<p>接下来我们用 Java 代码实现对 Redis 的操作，同样我们先引入 Jedis 框架 ，接下来再用代码来对字典类型进行操作，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 把 Key 值定义为变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDISKEY</span> <span class="operator">=</span> <span class="string">&quot;myhash&quot;</span>;</span><br><span class="line">        <span class="comment">// 插入单个元素</span></span><br><span class="line">        jedis.hset(REDISKEY, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询单个元素</span></span><br><span class="line">        Map&lt;String, String&gt; singleMap = jedis.hgetAll(REDISKEY);</span><br><span class="line">        System.out.println(singleMap.get(<span class="string">&quot;key1&quot;</span>));  <span class="comment">// 输出：value1</span></span><br><span class="line">        <span class="comment">// 查询所有元素</span></span><br><span class="line">        Map&lt;String, String&gt; allMap = jedis.hgetAll(REDISKEY);</span><br><span class="line">        System.out.println(allMap.get(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// 输出：val2</span></span><br><span class="line">        System.out.println(allMap); <span class="comment">// 输出：&#123;key1=value1, k1=val1, k2=val2, k3=9.2, k4=v4...&#125;</span></span><br><span class="line">        <span class="comment">// 删除单个元素</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">delResult</span> <span class="operator">=</span> jedis.hdel(REDISKEY, <span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果：&quot;</span> + delResult);    <span class="comment">// 输出：删除结果：1</span></span><br><span class="line">        <span class="comment">// 查询单个元素</span></span><br><span class="line">        System.out.println(jedis.hget(REDISKEY, <span class="string">&quot;key1&quot;</span>)); <span class="comment">// 输出：返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，在 Jedis 中我们可以直接使用 Map 来接收 Redis 中读取的字典类型的数据，省去了手动转化的麻烦，还是比较方便的。</p>
<h3 id="3-数据结构">3.数据结构</h3>
<p>字典类型本质上是由数组和链表结构组成的，来看字典类型的源码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span> <span class="comment">// dict.h</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个 entry</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>字典类型的数据结构，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105603601.png" alt="image-20240604105603601"></p>
<p>通常情况下字典类型会使用数组的方式来存储相关的数据，但发生哈希冲突时才会使用链表的结构来存储数据。</p>
<h3 id="4-哈希冲突">4.哈希冲突</h3>
<p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为<strong>哈希冲突</strong>。</p>
<p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p>
<p>键值查询的流程如下：</p>
<ul>
<li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li>
<li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li>
</ul>
<p>键值查询流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105621709.png" alt="image-20240604105621709"></p>
<h3 id="5-渐进式rehash">5.渐进式rehash</h3>
<p>Redis 为了保证应用的高性能运行，提供了一个重要的机制——渐进式 rehash。 渐进式 rehash 是用来保证字典缩放效率的，也就是说在字典进行扩容或者缩容是会采取渐进式 rehash 的机制。</p>
<h4 id="1）扩容">1）扩容</h4>
<p>当元素数量等于数组长度时就会进行扩容操作，源码在 dict.c 文件中，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 需要的容量小于当前容量，则不需要扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictht n; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> realsize = _dictNextPower(size); <span class="comment">// 重新计算扩容后的值</span></span><br><span class="line">    <span class="comment">/* 计算新的扩容大小等于当前容量，不需要扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">/* 分配一个新的哈希表，并将所有指针初始化为NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次初始化</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n; <span class="comment">// 把增量输入放入新 ht[1] 中</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// 非默认值 -1，表示需要进行 rehash</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上源码可以看出，如果需要扩容则会申请一个新的内存地址赋值给 ht[1]，并把字典的 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p>
<h4 id="2）缩容">2）缩容</h4>
<p>当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p>
<h4 id="3）渐进式rehash流程">3）渐进式rehash流程</h4>
<p>在进行渐进式 rehash 时，会同时保留两个 hash 结构，新键值对加入时会直接插入到新的 hash 结构中，并会把旧 hash 结构中的元素一点一点的移动到新的 hash 结构中，当移除完最后一个元素时，清空旧 hash 结构，主要的执行流程如下：</p>
<ul>
<li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li>
<li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li>
<li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li>
</ul>
<p><strong>总结：</strong></p>
<p>渐进式rehash的设计主要是为了解决一次性rehash可能带来的大量计算阻塞问题。在一次性rehash过程中，需要一次性将所有的键值对从旧的哈希表迁移到新的哈希表，如果哈希表的键值对数量非常大，那么这个过程可能会消耗大量的CPU时间，导致Redis服务器在一段时间内无法处理其他命令，这就是所说的&quot;操作阻塞&quot;。</p>
<p>而渐进式rehash采取了一种分步进行的策略，它并不是一次性完成所有键值对的迁移，而是分多次、逐步地将旧哈希表的键值对迁移到新哈希表。在每次Redis执行命令时，都会顺带做一部分的迁移工作，比如迁移10个键值对。这样，即使是在需要rehash的情况下，Redis也可以保持对外的服务，处理客户端的命令请求。</p>
<p>同时，为了解决哈希表的冲突问题，Redis采用了开放寻址法和链地址法等处理冲突的方式，通过扩大哈希表的容量，减少哈希冲突，从而提高哈希表操作的效率。</p>
<p>所以，渐进式rehash和冲突处理策略共同解决了哈希表操作变慢的问题。</p>
<p><strong>补充</strong>：</p>
<p>Redis中的字典是一种关联数组，它的结构体包含一些重要的元素：</p>
<ol>
<li>type：字典私有数据的处理方法</li>
<li>privdata：私有数据</li>
<li>ht[2]：包含两个哈希表的数组，通常我们使用 ht[0]，在rehash时使用 ht[1]</li>
<li>rehashidx：记录rehash进度的标志，如果为-1表示rehash未进行</li>
</ol>
<p>具体的哈希表(ht)中包含以下元素：</p>
<ol>
<li>table：数组，数组中的每个元素都是一个链表</li>
<li>size：哈希表table的大小</li>
<li>sizemask：哈希表大小掩码，用于计算索引值</li>
<li>used：哈希表已有节点的数量</li>
</ol>
<p>这是一个基本的数据结构，可以高效地进行数据查找、插入和删除操作。</p>
<h3 id="6-使用场景">6.使用场景</h3>
<p>哈希字典的典型使用场景如下：</p>
<ul>
<li>商品购物车，购物车非常适合用哈希字典表示，使用人员唯一编号作为字典的 key，value 值可以存储商品的 id 和数量等信息；</li>
<li>存储用户的属性信息，使用人员唯一编号作为字典的 key，value 值为属性字段和对应的值；</li>
<li>存储文章详情页信息等。</li>
</ul>
<h3 id="7-小结">7.小结</h3>
<p>本文我们学习了字典类型的操作命令和在代码中的使用，也明白了字典类型实际是由数组和链表组成的，当字典进行扩容或者缩容时会进行渐进式 rehash 操作，渐进式 rehash 是用来保证 Redis 运行效率的，它的执行流程是同时保留两个哈希表，把旧表中的元素一点一点的移动到新表中，查询的时候会先查询两个哈希表，当所有元素都移动到新的哈希表之后，就会删除旧的哈希表。</p>
<h2 id="09-附录：更多字典操作命令">09 附录：更多字典操作命令</h2>
<h3 id="插入一个或多个元素">插入一个或多个元素</h3>
<p>语法：hmset key field value [field value …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset myhash k1 val1 k2 val2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash k1 k2</span><br><span class="line">1) &quot;val1&quot;</span><br><span class="line">2) &quot;val2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询一个或多个元素">查询一个或多个元素</h3>
<p>语法：hmget key field [field …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget myhash k1 k2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询某个-key-的所有字段">查询某个 key 的所有字段</h3>
<p>语法：hkeys key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询某个-key-的所有值">查询某个 key 的所有值</h3>
<p>语法：hvals key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询某个-key-的所有字段和值">查询某个 key 的所有字段和值</h3>
<p>语法：hgetall key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="某个浮点值累加计算">某个浮点值累加计算</h3>
<p>语法：hincrbyfloat key field increment 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrbyfloat myhash k3 2.2</span><br><span class="line">&quot;9.2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询元素是否存在">查询元素是否存在</h3>
<p>语法：hexists key field 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists myhash key1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h3 id="查询元素个数">查询元素个数</h3>
<p>语法：hlen key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h2 id="10-列表使用与内部实现原理">10 列表使用与内部实现原理</h2>
<p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p>
<h3 id="1-基础使用-2">1 基础使用</h3>
<p>列表类型的使用相对来说比较简单，对它的操作就相当操作一个没有任何 key 值的 value 集合，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105813094.png" alt="image-20240604105813094"></p>
<h4 id="1）给列表添加一个或多个元素">1）给列表添加一个或多个元素</h4>
<p>语法：lpush key value [value …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="2）给列表尾部添加一个或多个元素">2）给列表尾部添加一个或多个元素</h4>
<p>语法：rpush key value [value …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list2 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="3）返回列表指定区间内的元素">3）返回列表指定区间内的元素</h4>
<p>语法：lrange key start stop 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<p>其中 -1 代表列表中的最后一个元素。</p>
<h4 id="4）获取并删除列表的第一个元素">4）获取并删除列表的第一个元素</h4>
<p>语法：lpop key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5）获取并删除列表的最后一个元素">5）获取并删除列表的最后一个元素</h4>
<p>语法：rpop key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h4 id="6）根据下标获取对应的元素">6）根据下标获取对应的元素</h4>
<p>语法：lindex key index 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list3 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>更多操作命令，详见附录部分。</p>
<h3 id="2-代码实战-2">2 代码实战</h3>
<p>下面来看列表类型在 Java 中的使用，同样先添加 Jedis 框架，使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 声明 Redis key</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDISKEY</span> <span class="operator">=</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">        <span class="comment">// 在头部插入一个或多个元素</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">lpushResult</span> <span class="operator">=</span> jedis.lpush(REDISKEY, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Sql&quot;</span>);</span><br><span class="line">        System.out.println(lpushResult); <span class="comment">// 输出：2</span></span><br><span class="line">        <span class="comment">// 获取第 0 个元素的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idValue</span> <span class="operator">=</span> jedis.lindex(REDISKEY, <span class="number">0</span>);</span><br><span class="line">        System.out.println(idValue); <span class="comment">// 输出：Sql</span></span><br><span class="line">        <span class="comment">// 查询指定区间的元素</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(REDISKEY, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// 输出：[Sql, Java]</span></span><br><span class="line">        <span class="comment">// 在元素 Java 前面添加 MySQL 元素</span></span><br><span class="line">        jedis.linsert(REDISKEY, ListPosition.BEFORE, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(jedis.lrange(REDISKEY, <span class="number">0</span>, -<span class="number">1</span>)); <span class="comment">// 输出：[Sql, MySQL, Java]</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下：</p>
<blockquote>
<p>2 Sql [Sql, Java] [Sql, MySQL, Java]</p>
</blockquote>
<h3 id="3-内部实现">3 内部实现</h3>
<p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding list</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p>
<p>quicklist (快速列表) 是 Redis 3.2 引入的数据类型，早期的列表类型使用的是ziplist (压缩列表) 和双向链表组成的，Redis 3.2 改为用 quicklist 来存储列表元素。</p>
<p>我们来看下 quicklist 的实现源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span> <span class="comment">// src/quicklist.h</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* ziplist 的个数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* quicklist 的节点数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">/* LZF 压缩算法深度 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;           <span class="comment">/* 对应的 ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist 字节数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* ziplist 个数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 该节点先前是否被压缩 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* 节点太小无法压缩 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; </span><br><span class="line">    <span class="type">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>
<p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105827673.png" alt="image-20240604105827673"></p>
<p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，ziplist 数据结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105837234.png" alt="image-20240604105837234"></p>
<p>【连锁更新问题】</p>
<p>其中的字段含义如下：</p>
<ul>
<li>zlbytes：压缩列表字节长度，占 4 字节；</li>
<li>zltail：压缩列表尾元素相对于起始元素地址的偏移量，占 4 字节；</li>
<li>zllen：压缩列表的元素个数；</li>
<li>entryX：压缩列表存储的所有元素，可以是字节数组或者是整数；</li>
<li>zlend：压缩列表的结尾，占 1 字节。</li>
</ul>
<h3 id="4-源码解析">4 源码解析</h3>
<p>下面我们来看一下更多关于列表类型的源码实现。</p>
<h4 id="1）添加功能源码分析">1）添加功能源码分析</h4>
<p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        <span class="comment">// 在列表头部添加元素</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        <span class="comment">// 在列表尾部添加元素</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 quicklistPushHead 为例，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 在头部节点插入元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p>
<p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p>
<p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。 quicklistPushHead 执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604105930222.png" alt="image-20240604105930222"></p>
<h4 id="2）删除功能源码分析">2）删除功能源码分析</h4>
<p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p>
<h5 id="①-单一元素删除">① 单一元素删除</h5>
<p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> &#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="type">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p>
<h5 id="②-区间元素删除">② 区间元素删除</h5>
<p>区间元素删除的函数是 quicklistDelRange，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start 表示开始删除的下标，count 表示要删除的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="type">const</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> extent = count; </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// 删除的元素个数大于已有元素</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// 删除指定的元素个数</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// extent 为剩余需要删除的元素个数，</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> del;</span><br><span class="line">        <span class="type">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 删除整个 quicklistNode</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">           <span class="comment">// 删除本节点的所有元素</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除本节点部分元素</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line">        D(<span class="string">&quot;[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), &quot;</span></span><br><span class="line">          <span class="string">&quot;node count: %u&quot;</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余待删除元素的个数</span></span><br><span class="line">        extent -= del;</span><br><span class="line">        <span class="comment">// 下个 quicklistNode</span></span><br><span class="line">        node = next;</span><br><span class="line">        <span class="comment">// 从下个 quicklistNode 起始位置开始删除</span></span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p>
<p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p>
<h4 id="3）更多源码">3）更多源码</h4>
<p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p>
<ul>
<li>quicklistCreate：创建 quicklist；</li>
<li>quicklistInsertAfter：在某个元素的后面添加数据；</li>
<li>quicklistInsertBefore：在某个元素的前面添加数据；</li>
<li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li>
<li>quicklistReplaceAtIndex：替换某个元素。</li>
</ul>
<h3 id="5-使用场景">5 使用场景</h3>
<p>列表的典型使用场景有以下两个：</p>
<ul>
<li>消息队列：列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列；</li>
<li>文章列表：对于博客站点来说，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。</li>
</ul>
<h3 id="6-小结">6 小结</h3>
<p>通过本文我们可以知道列表类型并不是简单的双向链表，而是采用了 quicklist 的数据结构对数据进行存取，quicklist 是 Redis 3.2 新增的数据类型，它的底层采取的是压缩列表加双向链表的存储结构，quicklist 为了存储更多的数据，会对每个 quicklistNode 节点进行压缩，这样就可以有效的存储更多的消息队列或者文章的数据了。</p>
<h2 id="11-附录：更多列表操作命令">11 附录：更多列表操作命令</h2>
<h3 id="在某值之前-之后添加某个元素">在某值之前/之后添加某个元素</h3>
<p>语法：linsert key before|after pivot value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; linsert list3 before b A</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list3 0 -1</span><br><span class="line">&quot;a&quot;</span><br><span class="line">&quot;A&quot;</span><br><span class="line">&quot;b&quot;</span><br><span class="line">&quot;c&quot;</span><br></pre></td></tr></table></figure>
<h3 id="根据下标修改元素">根据下标修改元素</h3>
<p>语法：lset key index value 示例*：*</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list3 0 A</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;A&quot;</span><br></pre></td></tr></table></figure>
<h3 id="根据下标删除元素">根据下标删除元素</h3>
<p>语法：ltrim key start stop 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ltrim list 0 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询列表的长度">查询列表的长度</h3>
<p>语法：llen key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h3 id="删除指定个数的元素">删除指定个数的元素</h3>
<p><strong>语法</strong>：lrem key count value 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list a a b b c c</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 a</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="12-集合使用与内部实现原理">12 集合使用与内部实现原理</h2>
<p>集合类型 (Set) 是一个无序并唯一的键值集合。</p>
<p>之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset v2 v1 v3 #插入数据 v2、v1、v3 </span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset #查询数据</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>从上面代码执行结果可以看出，myset 的存储顺序并不是以插入的先后顺序进行存储的。</p>
<p>集合类型和列表类型的区别如下：</p>
<ul>
<li>列表可以存储重复元素，集合只能存储非重复元素；</li>
<li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li>
</ul>
<h3 id="1-基础使用-3">1 基础使用</h3>
<p>集合类型的功能比列表类型丰富一些，集合类型可以用来统计多个集合的交集、错集和并集，如下代码所示。</p>
<h4 id="1）添加一个或多个元素">1）添加一个或多个元素</h4>
<p>语法：sadd key member [member …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset v1 v2 v3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="2）查询集合所有元素">2）查询集合所有元素</h4>
<p>语法：smembers key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3）查询集合的成员数量">3）查询集合的成员数量</h4>
<p>语法：scard key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="4）查询集合中是否包含某个元素">4）查询集合中是否包含某个元素</h4>
<p>语法：sismember key member 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember myset v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset v4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h4 id="5）从一个集合中移动一个元素到另一个集合">5）从一个集合中移动一个元素到另一个集合</h4>
<p>语法：smove source destination member 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 v3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<h4 id="6）移除集合中一个或多个元素">6）移除集合中一个或多个元素</h4>
<p>语法：srem key member [member …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;v5&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem myset v5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v1&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br></pre></td></tr></table></figure>
<p>注意：使用 srem 指令，不存在的元素将会被忽略。 更多操作命令，详见附录部分。</p>
<h3 id="2-代码实战-3">2 代码实战</h3>
<p>下面来看集合类型在 Java 中的使用，同样先添加 Jedis 框架，使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建集合并添加元素</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询集合中的所有元素</span></span><br><span class="line">        Set&lt;String&gt; members = jedis.smembers(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(members); <span class="comment">// 输出：[java, golang]</span></span><br><span class="line">        <span class="comment">// 查询集合中的元素数量</span></span><br><span class="line">        System.out.println(jedis.scard(<span class="string">&quot;set1&quot;</span>));</span><br><span class="line">        <span class="comment">// 移除集合中的一个元素</span></span><br><span class="line">        jedis.srem(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;set1&quot;</span>)); <span class="comment">// 输出：[java]</span></span><br><span class="line">        <span class="comment">// 创建集合 set2 并添加元素</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询两个集合中交集</span></span><br><span class="line">        Set&lt;String&gt; inters = jedis.sinter(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(inters); <span class="comment">// 输出：[java]</span></span><br><span class="line">        <span class="comment">// 查询两个集合中并集</span></span><br><span class="line">        Set&lt;String&gt; unions = jedis.sunion(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(unions); <span class="comment">// 输出：[java,golang]</span></span><br><span class="line">        <span class="comment">// 查询两个集合的错集</span></span><br><span class="line">        Set&lt;String&gt; diffs = jedis.sdiff(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(diffs); <span class="comment">// 输出：[golang]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-内部实现-2">3 内部实现</h3>
<p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604110227735.png" alt="image-20240604110227735"></p>
<p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset 1 9 3 -2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，<strong>当所有元素都为整数时，集合会以 intset 结构进行(数据)存储</strong>。 当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储： 1）当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。 2）当元素为非整数时，集合将会使用 hashtable 来存储，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myht &quot;redis&quot; &quot;db&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding myht</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，<strong>当元素为非整数时，集合会使用 hashtable 进行存储</strong>。</p>
<h3 id="4-源码解析-2">4 源码解析</h3>
<p>集合源码在 t_set.c 文件中，核心源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 添加元素到集合</span></span><br><span class="line"><span class="comment"> * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 字典类型</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// inset 数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转化为整数类型失败，使用字典类型存储</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未知编码(类型)</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p>
<h3 id="5-使用场景-2">5 使用场景</h3>
<p>集合类型的经典使用场景如下：</p>
<ul>
<li>微博关注我的人和我关注的人都适合用集合存储，可以保证人员不会重复；</li>
<li>中奖人信息也适合用集合类型存储，这样可以保证一个人不会重复中奖。</li>
</ul>
<h3 id="6-小结-2">6 小结</h3>
<p>通过本文我们知道了，集合类型是由整数集合 (intset) 或者是哈希表 (hashtable) 组成的，集合类型比较适合用来数据去重和保障数据的唯一性，除此之外，集合类型还可以用来统计多个集合的交集、错集和并集 (见附录)。当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<h2 id="13-附录：更多集合操作命令">13 附录：更多集合操作命令</h2>
<h3 id="移除并返回集合中的一个随机元素">移除并返回集合中的一个随机元素</h3>
<p>语法：spop key [count] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset 1</span><br><span class="line">1) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="随机返回集合中指定数量的元素列表">随机返回集合中指定数量的元素列表</h3>
<p>语法：srandmember key [count] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="返回一个集合或多个集合的交集">返回一个集合或多个集合的交集</h3>
<p>语法：sinter key [key …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter myset myset2</span><br><span class="line">1) &quot;v1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="把集合的交集复制到新的集合中">把集合的交集复制到新的集合中</h3>
<p>语法：sinterstore destination key [key …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinterstore myset3 myset myset2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset3</span><br><span class="line">1) &quot;v1&quot;</span><br></pre></td></tr></table></figure>
<p>命令解析：从以上代码可以看出，我们把集合 myset 和 集合 myset2 的合集元素 v1 复制到了新的集合 myset3 中，但 v1 并不会从原有集合中移除。</p>
<h3 id="查询一个或多个集合的并集">查询一个或多个集合的并集</h3>
<p>语法：sunion key [key …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion group1 group2</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br></pre></td></tr></table></figure>
<h3 id="把一个或多个集合的并集复制到新集合中">把一个或多个集合的并集复制到新集合中</h3>
<p>语法：sunionstore destination key [key …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunionstore group3 group1 group2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers group3</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br></pre></td></tr></table></figure>
<p>注意：只是把一个或多个集合的并集复制到新集合中，并不会在原集合中删除复制的元素。</p>
<h3 id="查询一个或多个集合的错集">查询一个或多个集合的错集</h3>
<p>语法：sdiff key [key …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff group1 group2</span><br><span class="line">1) &quot;java&quot;</span><br></pre></td></tr></table></figure>
<p>注意：执行命令时集合的先后顺序会影响返回的结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sdiff group1 group2</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff group2 group1</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure>
<p>这是因为查询错集是以第一个集合为主的，当第二个元素包含第一个元素时，查询的错集结果就是空。</p>
<h3 id="把一个或多个集合的错集复制到新集合">把一个或多个集合的错集复制到新集合</h3>
<p>语法：sdiffstore destination key [key …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiffstore group3 group1 group2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers group3</span><br><span class="line">1) &quot;java&quot;</span><br></pre></td></tr></table></figure>
<h2 id="14-有序集合使用与内部实现原理">14 有序集合使用与内部实现原理</h2>
<p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p>
<p>当我们把学生的成绩存储在有序集合中时，它的存储结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604110443985.png" alt="image-20240604110443985"></p>
<p>下面我们先从有序集合的使用开始说起。</p>
<h3 id="1-基础使用-4">1 基础使用</h3>
<h4 id="1）添加一个或多个元素-2">1）添加一个或多个元素</h4>
<p>语法：zadd key [NX|XX] [CH] [INCR] score member [score member …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 10 java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 3 golang 4 sql 1 redis</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p>可以看出有序集合的添加是 <code>zadd 键值 分值1 元素值1 分值2 元素值2</code> 的形式添加的。</p>
<h4 id="2）查询所有元素列表">2）查询所有元素列表</h4>
<p>语法：zrange key start stop [WITHSCORES] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;mysql&quot;</span><br><span class="line">3) &quot;java&quot;</span><br></pre></td></tr></table></figure>
<p>其中 -1 表示最后一个元素，查询结果包含开始和结束元素。</p>
<h4 id="3）删除一个或多个元素-根据元素值">3）删除一个或多个元素(根据元素值)</h4>
<p>语法：zrem key member [member …] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;sql&quot;</span><br><span class="line">4) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem zset1 redis sql #删除元素：reids、sql</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;java&quot;</span><br></pre></td></tr></table></figure>
<p>删除命令中如果包含了不存在的元素，并不会影响命令的正常执行，不存在的元素将会被忽略。</p>
<h4 id="4）查询某元素的-score-值">4）查询某元素的 score 值</h4>
<p>语法：zscore key member 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 redis</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5）查询-score-区间内元素">5）查询 score 区间内元素</h4>
<p>语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count] 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset1 3 10</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;sql&quot;</span><br><span class="line">4) &quot;java&quot;</span><br></pre></td></tr></table></figure>
<h4 id="6）查询某元素排名">6）查询某元素排名</h4>
<p>语法：zrank key member 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset 5 redis 10 java 8 mysql #创建有序集合</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrank zset java #查询元素排序</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrank zset redis</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<p>可以看出，排名是从 0 开始的，排名可以理解为元素排序后的下标值。</p>
<p>更多操作命令，详见附录部分。</p>
<h3 id="2-代码实战-4">2 代码实战</h3>
<p>下面来看有序集合在 Java 中的使用，同样先添加 Jedis 框架，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZSetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;小明&quot;</span>, <span class="number">80.5d</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小红&quot;</span>, <span class="number">75d</span>);</span><br><span class="line">        map.put(<span class="string">&quot;老王&quot;</span>, <span class="number">85d</span>);</span><br><span class="line">        <span class="comment">// 为有序集合(ZSet)添加元素</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;grade&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询分数在 80 分到 100 分之间的人(包含 80 分和 100 分)</span></span><br><span class="line">        Set&lt;String&gt; gradeSet = jedis.zrangeByScore(<span class="string">&quot;grade&quot;</span>, <span class="number">80</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(gradeSet); <span class="comment">// 输出：[小明, 老王]</span></span><br><span class="line">        <span class="comment">// 查询小红的排名(排名从 0 开始)</span></span><br><span class="line">        System.out.println(jedis.zrank(<span class="string">&quot;grade&quot;</span>, <span class="string">&quot;小明&quot;</span>)); <span class="comment">// 输出：1</span></span><br><span class="line">        <span class="comment">// 从集合中移除老王</span></span><br><span class="line">        jedis.zrem(<span class="string">&quot;grade&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询有序集合中的所有元素(根据排名从小到大)</span></span><br><span class="line">        Set&lt;String&gt; range = jedis.zrange(<span class="string">&quot;grade&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(range); <span class="comment">// 输出：[小红, 小明]</span></span><br><span class="line">        <span class="comment">// 查询有序集合中的所有元素(根据 score 从小到大)</span></span><br><span class="line">        Set&lt;String&gt; rangeByScore = jedis.zrangeByScore(<span class="string">&quot;grade&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(rangeByScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-内部实现-3">3 内部实现</h3>
<p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p>
<h4 id="1）ziplist">1）ziplist</h4>
<p>当数据比较少时，有序集合使用的是 ziplist 存储的，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myzset 1 db 2 redis 3 mysql</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding myzset</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，有序集合把 myset 键值对存储在 ziplist 结构中了。 有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>
<ul>
<li>有序集合保存的元素个数要小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>
</ul>
<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。 接下来我们来测试以下，当有序集合中某个元素长度大于 64 字节时会发生什么情况？ 代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zmaxleng 1.0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zmaxleng</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd zmaxleng 2.0 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zmaxleng</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可以看出，当有序集合保存的所有元素成员的长度大于 64 字节时，有序集合就会从 ziplist 转换成为 skiplist。</p>
<blockquote>
<p>小贴士：可以通过配置文件中的 zset-max-ziplist-entries（默认 128）和 zset-max-ziplist-value（默认 64）来设置有序集合使用 ziplist 存储的临界值。</p>
</blockquote>
<h3 id="2）skiplist">2）skiplist</h3>
<p>skiplist 数据编码底层是使用 zset 结构实现的，而 zset 结构中包含了一个字典和一个跳跃表，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p>更多关于跳跃表的源码实现，会在后面的章节详细介绍。</p>
<h5 id="①-跳跃表实现原理">① 跳跃表实现原理</h5>
<p>跳跃表的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604110525193.png" alt="image-20240604110525193"></p>
<p>根据以上图片展示，当我们在跳跃表中查询值 32 时，执行流程如下：</p>
<ul>
<li>从最上层开始找，1 比 32 小，在当前层移动到下一个节点进行比较；</li>
<li>7 比 32 小，当前层移动下一个节点比较，由于下一个节点指向 Null，所以以 7 为目标，移动到下一层继续向后比较；</li>
<li>18 小于 32，继续向后移动查找，对比 77 大于 32，以 18 为目标，移动到下一层继续向后比较；</li>
<li>对比 32 等于 32，值被顺利找到。</li>
</ul>
<p>从上面的流程可以看出，跳跃表会想从最上层开始找起，依次向后查找，如果本层的节点大于要找的值，或者本层的节点为 Null 时，以上一个节点为目标，往下移一层继续向后查找并循环此流程，直到找到该节点并返回，如果对比到最后一个元素仍未找到，则返回 Null。</p>
<h5 id="②-为什么是跳跃表？而非红黑树？">② 为什么是跳跃表？而非红黑树？</h5>
<p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p>
<h3 id="4-使用场景">4 使用场景</h3>
<p>有序集合的经典使用场景如下：</p>
<ul>
<li>学生成绩排名</li>
<li>粉丝列表，根据关注的先后时间排序</li>
</ul>
<h3 id="5-小结-2">5 小结</h3>
<p>通过本文的学习我们了解到，有序集合具有唯一性和排序的功能，排序功能是借助分值字段 score 实现的，score 字段不仅可以实现排序功能，还可以实现数据的赛选与过滤的功能。我们还了解到了有序集合是由 压缩列表 (ziplist) 或跳跃列表 (skiplist) 来存储的，当元素个数小于 128 个，并且所有元素的值都小于 64 字节时，有序集合会采取 ziplist 来存储，反之则会用 skiplist 来存储，其中 skiplist 是从上往下、从前往后进行元素查找的，相比于传统的普通列表，可能会快很多，因为普通列表只能从前往后依次查找。</p>
<h2 id="15-附录：更多有序集合操作命令">15 附录：更多有序集合操作命令</h2>
<h3 id="查询有序集合的总个数">查询有序集合的总个数</h3>
<p>语法：zcard key 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcard zset1</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>
<h3 id="查询-score-区间内的元素个数">查询 score 区间内的元素个数</h3>
<p>语法：zcount key min max 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount zset1 0 10</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>
<h3 id="累加元素的-score-值">累加元素的 score 值</h3>
<p>语法：zincrby key increment member 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 redis #查询 zset1 的 score 值</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zincrby zset1 2 redis #累加 score 值</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zscore zset1 redis</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查询某元素倒序排名">查询某元素倒序排名</h3>
<p>语法：zrevrank key member 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrank zset1 python #倒序查询</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #正序列表</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br></pre></td></tr></table></figure>
<h3 id="根据排名删除元素">根据排名删除元素</h3>
<p>语法：zremrangebyrank key start stop 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyrank zset1 0 2 #删除元素</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;python&quot;</span><br></pre></td></tr></table></figure>
<h3 id="删除-score-区间内的元素">删除 score 区间内的元素</h3>
<p>语法：zremrangebyscore key min max 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 python</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyscore zset1 4 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zscore zset1 python</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="复制交集元素到新集合">复制交集元素到新集合</h3>
<p>语法：zinterstore destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MA 参数 numkeys 表示需要几个集合参与查询。 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange zset2 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;db&quot;</span><br><span class="line">127.0.0.1:6379&gt; zinterstore zset3 2 zset1 zset2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange zset3 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br></pre></td></tr></table></figure>
<h3 id="复制并集元素到新集合">复制并集元素到新集合</h3>
<p>语法：zunionstore destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MA 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange zset2 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;db&quot;</span><br><span class="line">127.0.0.1:6379&gt; zunionstore zset3 2 zset1 zset2</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; zrange zset3 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">5) &quot;db&quot;</span><br></pre></td></tr></table></figure>
<p>【有序集合：字典+跳表</p>
<p>集合对象的编码可以是 intset或者 hashtable 。</p>
<p>哈希对象的编码可以是 ziplist或者 hashtable</p>
<p>列表：双向链表/压缩列表</p>
<p>字符串对象：字符串对象</p>
<p>】</p>
<h2 id="16-Redis-事务深入解析">16 Redis 事务深入解析</h2>
<blockquote>
<p>作为关系型数据库中一项非常重要的基础功能——事务，在 Redis 中是如何处理并使用的？</p>
</blockquote>
<h3 id="前言">前言</h3>
<p>事务指的是提供一种将多个命令打包，一次性按顺序地执行的机制，并且保证服务器只有在执行完事务中的所有命令后，才会继续处理此客户端的其他命令。</p>
<p>事务也是其他关系型数据库所必备的基础功能，以支付的场景为例，正常情况下只有正常消费完成之后，才会减去账户余额。但如果没有事务的保障，可能会发生消费失败了，但依旧会把账户的余额给扣减了，我想这种情况应该任何人都无法接受吧？所以事务是数据库中一项非常重要的基础功能。</p>
<h3 id="事务基本使用">事务基本使用</h3>
<p>事务在其他语言中，一般分为以下三个阶段：</p>
<ul>
<li>开启事务——Begin Transaction</li>
<li>执行业务代码，提交事务——Commit Transaction</li>
<li>业务处理中出现异常，回滚事务——Rollback Transaction</li>
</ul>
<p>以 Java 中的事务执行为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redis 中的事务从开始到结束也是要经历三个阶段：</p>
<ul>
<li>开启事务</li>
<li>命令入列</li>
<li>执行事务/放弃事务</li>
</ul>
<p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p>
<h4 id="开启事务"><strong>开启事务</strong></h4>
<p>multi 命令用于开启事务，实现代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态。</p>
<p><strong>注意</strong>：<strong>[※]multi 命令不能嵌套使用</strong>，如果已经开启了事务的情况下，再执行 multi 命令，会提示如下错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">error</span>) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure>
<p>执行效果，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure>
<p>当客户端是非事务状态时，使用 multi 命令，客户端会返回结果 OK，如果客户端已经是事务状态，再执行 multi 命令会 multi 命令不能嵌套的错误，但不会终止客户端为事务的状态，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604163012445.png" alt="image-20240604163012445"></p>
<h4 id="命令入列"><strong>命令入列</strong></h4>
<p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>
<p>执行流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604163052756.png" alt="image-20240604163052756"></p>
<p><strong>注意</strong>：命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p>
<h4 id="执行事务-放弃事务"><strong>执行事务/放弃事务</strong></h4>
<p>执行事务的命令是 exec，放弃事务的命令是 discard。</p>
<p>执行事务示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>放弃事务示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">discard</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>执行流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604163121196.png" alt="image-20240604163121196"></p>
<h3 id="事务错误-回滚">事务错误&amp;回滚</h3>
<p>【※】<strong>事务执行中的错误分为以下三类：</strong></p>
<ul>
<li><strong>执行时才会出现的错误（简称：执行时错误）；</strong></li>
<li><strong>入列时错误，不会终止整个事务；</strong></li>
<li><strong>入列时错误，会终止整个事务。</strong></li>
</ul>
<h4 id="执行时错误"><strong>执行时错误</strong></h4>
<p>示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v&quot;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expire k 10s</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>执行命令解释如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604163213007.png" alt="image-20240604163213007"></p>
<p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p>
<h4 id="入列错误不会导致事务结束"><strong>入列错误不会导致事务结束</strong></h4>
<p>示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v&quot;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>执行命令解释如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604163235276.png" alt="image-20240604163235276"></p>
<p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果，下文会详细讲解关于 watch 的内容。</p>
<h4 id="入列错误导致事务结束"><strong>入列错误导致事务结束</strong></h4>
<p>示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k</span></span><br><span class="line">(error) ERR wrong number of arguments for &#x27;set&#x27; command</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>执行命令解释如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604163251187.png" alt="image-20240604163251187"></p>
<h4 id="为什么不支持事务回滚？"><strong>为什么不支持事务回滚？</strong></h4>
<p>Redis 官方文档的解释如下：</p>
<blockquote>
<p>If you have a relational databases background, the fact that Redis commands can fail during a transaction, but still Redis will execute the rest of the transaction instead of rolling back, may look odd to you.</p>
<p>However there are good opinions for this behavior:</p>
<ul>
<li>Redis commands can fail only if called with a wrong syntax (and the problem is not detectable during the command queueing), or against keys holding the wrong data type: this means that in practical terms a failing command is the result of a programming errors, and a kind of error that is very likely to be detected during development, and not in production.</li>
<li>Redis is internally simplified and faster because it does not need the ability to roll back.</li>
</ul>
<p>An argument against Redis point of view is that bugs happen, however it should be noted that in general the roll back does not save you from programming errors. For instance if a query increments a key by 2 instead of 1, or increments the wrong key, there is no way for a rollback mechanism to help. Given that no one can save the programmer from his or her errors, and that the kind of errors required for a Redis command to fail are unlikely to enter in production, we selected the simpler and faster approach of not supporting roll backs on errors.</p>
</blockquote>
<p>大概的意思是，作者不支持事务回滚的原因有以下两个：</p>
<ul>
<li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li>
<li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li>
</ul>
<p>这里不支持事务回滚，指的是不支持运行时错误的事务回滚。</p>
<p><strong>【✳。redis只有事务结束，没有事务回滚！】</strong></p>
<h3 id="监控">监控</h3>
<p>watch 命令用于客户端并发情况下，为事务提供一个<strong>乐观锁（CAS，Check And Set）</strong>，也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个<strong>监控项被修改</strong>了，那么<strong>整个事务</strong>就会<strong>终止执行</strong>。</p>
<p>watch 基本语法如下：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure>
<p><code>watch</code> 示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p>
<p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 <code>get k</code> 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p>
<p>执行流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604170547497.png" alt="image-20240604170547497"></p>
<p><strong>注意</strong>： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">(error) ERR WATCH inside MULTI is not allowed</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure>
<p>执行命令解释如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604170600546.png" alt="image-20240604170600546"></p>
<p>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</p>
<p>unwatch 示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">unwatch</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p>
<h3 id="代码实战">代码实战</h3>
<p>以下是事务在 Java 中的使用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置键值</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启监视 watch</span></span><br><span class="line">        jedis.watch(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 开始事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="comment">// 命令入列</span></span><br><span class="line">        tx.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        tx.exec();</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识点练习">知识点练习</h3>
<h4 id="以下两个客户端交替执行的结果是？"><strong>以下两个客户端交替执行的结果是？</strong></h4>
<p>客户端一，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>
<p>客户端二，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>客户端一，再执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br></pre></td></tr></table></figure>
<p>此时 k 的值为多少？</p>
<p>答： k 的值为 v，而非 v2。</p>
<p>题目解析：本题考查的是 watch 命令监控时，即使把原对象的值重新赋值给了原对象，这个时候 watch 命令也会认为监控对象还是被修改了。</p>
<h3 id="小结-2">小结</h3>
<p>事务为多个命令提供一次性按顺序执行的机制，与 Redis 事务相关的命令有以下五个：</p>
<ul>
<li>multi：开启事务</li>
<li>exec：执行事务</li>
<li>discard：丢弃事务</li>
<li>watch：为事务提供乐观锁实现</li>
<li>unwatch：取消监控（取消事务中的乐观锁）</li>
</ul>
<p>正常情况下 Redis 事务分为三个阶段：开启事务、命令入列、执行事务。Redis 事务并不支持运行时错误的事务回滚，但在某些入列错误，如 <code>set key</code> 或者是 <code>watch</code> 监控项被修改时，提供整个事务回滚的功能。</p>
<h2 id="17-Redis-键值过期操作">17 Redis 键值过期操作</h2>
<h3 id="过期设置">过期设置</h3>
<p>Redis 中设置过期时间主要通过以下四种方式：</p>
<ul>
<li>expire key seconds：设置 key 在 n 秒后过期；</li>
<li>pexpire key milliseconds：设置 key 在 n 毫秒后过期；</li>
<li>expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；</li>
<li>pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；</li>
</ul>
<p>下面分别来看以上这些命令的具体实现。</p>
<h4 id="expire：N-秒后过期"><strong>expire：N 秒后过期</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire key 100</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key</span><br><span class="line">(integer) 97</span><br></pre></td></tr></table></figure>
<p>其中命令 ttl 的全称是 Time To Live，表示此键值在 n 秒后过期。例如，上面的结果 97 表示 key 在 97s 后过期。</p>
<h4 id="pexpire：N-毫秒后过期"><strong>pexpire：N 毫秒后过期</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key2 value2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pexpire key2 100000</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pttl key2</span><br><span class="line">(integer) 94524</span><br></pre></td></tr></table></figure>
<p>其中 <code>pexpire key2 100000</code> 表示设置 key2 在 100000 毫秒（100 秒）后过期。</p>
<h4 id="expireat：过期时间戳精确到秒"><strong>expireat：过期时间戳精确到秒</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key3 value3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expireat key3 1573472683</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 67</span><br></pre></td></tr></table></figure>
<p>其中 <code>expireat key3 1573472683</code> 表示 key3 在时间戳 1573472683 后过期（精确到秒），使用 ttl 查询可以发现在 67s 后 key3 会过期。</p>
<blockquote>
<p>小贴士：在 Redis 可以使用 time 命令查询当前时间的时间戳（精确到秒），示例如下：</p>
<p>127.0.0.1:6379&gt; time</p>
<ol>
<li>“1573472563”</li>
<li>“248426”</li>
</ol>
</blockquote>
<h4 id="pexpireat：过期时间戳精确到毫秒"><strong>pexpireat：过期时间戳精确到毫秒</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key4 value4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pexpireat key4 1573472683000</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pttl key4</span><br><span class="line">(integer) 3522</span><br></pre></td></tr></table></figure>
<p>其中 <code>pexpireat key4 1573472683000</code> 表示 key4 在时间戳 1573472683000 后过期（精确到毫秒），使用 ttl 查询可以发现在 3522ms 后 key4 会过期。</p>
<h4 id="字符串中的过期操作"><strong>字符串中的过期操作</strong></h4>
<p>字符串中几个直接操作过期时间的方法，如下列表：</p>
<ul>
<li>set key value ex seconds：设置键值对的同时指定过期时间（精确到秒）；</li>
<li>set key value px milliseconds：设置键值对的同时指定过期时间（精确到毫秒）；</li>
<li>setex key seconds valule：设置键值对的同时指定过期时间（精确到秒）。</li>
</ul>
<p>实现示例如下。</p>
<p><strong>1. set key value ex seconds</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k v ex 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k</span><br><span class="line">(integer) 97</span><br></pre></td></tr></table></figure>
<p><strong>2. set key value ex milliseconds</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k2 v2 px 100000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pttl k2</span><br><span class="line">(integer) 92483</span><br></pre></td></tr></table></figure>
<p><strong>3. setex key seconds valule</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex k3 100 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k3</span><br><span class="line">(integer) 91</span><br></pre></td></tr></table></figure>
<h3 id="移除过期时间">移除过期时间</h3>
<p>使用命令： <code>persist key</code> 可以移除键值的过期时间，如下代码所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl k3</span><br><span class="line">(integer) 97</span><br><span class="line">127.0.0.1:6379&gt; persist k3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl k3</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>
<p>可以看出第一次使用 ttl 查询 k3 会在 97s 后过期，当使用了 persist 命令之后，在查询 k3 的存活时间发现结果是 -1，它表示 k3 永不过期。</p>
<h3 id="Java实现过期操作">Java实现过期操作</h3>
<p>本文将使用 Jedis 框架来实现对 Redis 过期时间的操作，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTLTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码(如果没有密码，此行可省略)</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对（默认情况下永不过期）</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询 TTL（过期时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> jedis.ttl(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过期时间：&quot;</span> + ttl);</span><br><span class="line">        <span class="comment">// 设置 100s 后过期</span></span><br><span class="line">        jedis.expire(<span class="string">&quot;k&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 等待 1s 后执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行 expire 后的 TTL=&quot;</span> + jedis.ttl(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过期时间：-1</span><br><span class="line">执行 expire 后的 TTL=99</span><br></pre></td></tr></table></figure>
<p>可以看出使用 Jedis 来操作 Redis 的过期时间还是很方便的，可直接使用 <code>jedis.ttl(&quot;k&quot;)</code> 查询键值的生存时间，使用 <code>jedis.expire(&quot;k&quot;,seconds)</code> 方法设置过期时间（精确到秒）。</p>
<blockquote>
<p>小贴士：使用 Jedis 之前，先要把 Jedis 引入到程序中，如果使用的是 Maven 项目的，直接在 pom.xml 文件中添加以下引用：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;version&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>更多过期操作方法</strong>，如下列表：</p>
<ul>
<li>pexpire(String key, long milliseconds)：设置 n 毫秒后过期；</li>
<li>expireAt(String key, long unixTime)：设置某个时间戳后过期（精确到秒）；</li>
<li>pexpireAt(String key, long millisecondsTimestamp)：设置某个时间戳后过期（精确到毫秒）；</li>
<li>persist(String key)：移除过期时间。</li>
</ul>
<p>完整示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTLTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码(如果没有密码，此行可省略)</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对（默认情况下永不过期）</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询 TTL（过期时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> jedis.ttl(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过期时间：&quot;</span> + ttl);</span><br><span class="line">        <span class="comment">// 设置 100s 后过期</span></span><br><span class="line">        jedis.expire(<span class="string">&quot;k&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 等待 1s 后执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行 expire 后的 TTL=&quot;</span> + jedis.ttl(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置 n 毫秒后过期</span></span><br><span class="line">        jedis.pexpire(<span class="string">&quot;k&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 设置某个时间戳后过期（精确到秒）</span></span><br><span class="line">        jedis.expireAt(<span class="string">&quot;k&quot;</span>, <span class="number">1573468990</span>);</span><br><span class="line">        <span class="comment">// 设置某个时间戳后过期（精确到毫秒）</span></span><br><span class="line">        jedis.pexpireAt(<span class="string">&quot;k&quot;</span>, <span class="number">1573468990000L</span>);</span><br><span class="line">        <span class="comment">// 移除过期时间</span></span><br><span class="line">        jedis.persist(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="持久化中的过期键">持久化中的过期键</h3>
<p>上面我们讲了过期键在 Redis 正常运行中一些使用案例，接下来，我们来看 Redis 在持久化的过程中是如何处理过期键的。</p>
<p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p>
<h4 id="RDB-中的过期键"><strong>RDB 中的过期键</strong></h4>
<p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p>
<p><strong>1. RDB 文件生成</strong></p>
<p>从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键不会被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p>
<p><strong>2. RDB 文件加载</strong></p>
<p>RDB 加载分为以下两种情况：</p>
<ul>
<li>如果 Redis 是主服务器运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li>如果 Redis 是从服务器运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
<p>RDB 文件加载的源码可以在 rdb.c 文件的 rdbLoad() 函数中找到，源码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the key already expired. This function is used when loading</span></span><br><span class="line"><span class="comment">* an RDB file from disk, either at startup, or when an RDB was</span></span><br><span class="line"><span class="comment">* received from the master. In the latter case, the master is</span></span><br><span class="line"><span class="comment">* responsible for key expiry. If we would expire keys here, the</span></span><br><span class="line"><span class="comment">* snapshot taken by the master may not be reflected on the slave. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 如果服务器为主节点的话，</span></span><br><span class="line"><span class="comment">* 那么在键已经过期的时候，不再将它们关联到数据库中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">    decrRefCount(key);</span><br><span class="line">    decrRefCount(val);</span><br><span class="line">    <span class="comment">// 跳过</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AOF-中的过期键"><strong>AOF 中的过期键</strong></h4>
<p><strong>1. AOF 文件写入</strong></p>
<p>当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。</p>
<p><strong>2. AOF 重写</strong></p>
<p>执行 AOF 重写时，会对 Redis 中的键值对进行检查已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。</p>
<h3 id="主从库的过期键">主从库的过期键</h3>
<p>当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>
<h3 id="小结-3">小结</h3>
<p>本文我们知道了 Redis 中的四种设置过期时间的方式：expire、pexpire、expireat、pexpireat，其中比较常用的是 expire 设置键值 n 秒后过期。</p>
<p>字符串中可以在添加键值的同时设置过期时间，并可以使用 persist 命令移除过期时间。同时我们也知道了过期键在 RDB 写入和 AOF 重写时都不会被记录。</p>
<p>过期键在主从模式下，从库对过期键的处理要完全依靠主库，主库删除过期键之后会发送 del 命令给所有的从库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604171410049.png" alt="image-20240604171410049"></p>
<h2 id="18-Redis-过期策略与源码分析">18 Redis 过期策略与源码分析</h2>
<p>在 Redis 中我们可以给一些元素设置过期时间，那当它过期之后 Redis 是如何处理这些过期键呢？</p>
<h3 id="过期键执行流程">过期键执行流程</h3>
<p>Redis 之所以能知道那些键值过期，是因为在 Redis 中维护了一个字典，存储了所有设置了过期时间的键值，我们称之为过期字典。</p>
<p>过期键判断流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604171941410.png" alt="image-20240604171941410"></p>
<h3 id="过期键源码分析">过期键源码分析</h3>
<p>过期键存储在 redisDb 结构中，源代码在 src/server.h 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></span><br><span class="line"><span class="comment"> * by integers from 0 (the default database) up to the max configured</span></span><br><span class="line"><span class="comment"> * database. The database number is the &#x27;id&#x27; field in the structure. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：本文的所有源码都是基于 Redis 5。</p>
</blockquote>
<p>过期键数据结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604171958365.png" alt="image-20240604171958365"></p>
<h3 id="过期策略">过期策略</h3>
<p>Redis 会删除已过期的键值，以此来减少 Redis 的空间占用，但因为 Redis 本身是单线的，如果因为删除操作而影响主业务的执行就得不偿失了，为此 Redis 需要制定多个（过期）删除策略来保证糟糕的事情不会发生。</p>
<p>常见的过期策略有以下三种：</p>
<ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<p>下面分别来看每种策略有何不同。</p>
<h4 id="定时删除"><strong>定时删除</strong></h4>
<p>在设置键值过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。</p>
<ul>
<li>**优点：**保证内存可以被尽快地释放。</li>
<li>**缺点：**在 Redis 高负载的情况下或有大量过期键需要同时处理时，会造成 Redis 服务器卡顿，影响主业务执行。</li>
</ul>
<h4 id="惰性删除"><strong>惰性删除</strong></h4>
<p>不主动删除过期键，每次从数据库获取键值时判断是否过期，如果过期则删除键值，并返回 null。</p>
<ul>
<li>**优点：**因为每次访问时，才会判断过期键，所以此策略只会使用很少的系统资源。</li>
<li>**缺点：**系统占用空间删除不及时，导致空间利用率降低，造成了一定的空间浪费。</li>
</ul>
<p><strong>源码解析</strong></p>
<p>惰性删除的源码位于 src/db.c 文件的 expireIfNeeded 方法中，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断键是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    <span class="comment">// 增加过期键个数</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 传播键过期的消息</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">    <span class="comment">// server.lazyfree_lazy_expire 为 1 表示异步删除（懒空间释放），反之同步删除</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断键是否过期</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">mstime_t</span> now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键的过期时间</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有对数据库的读写命令在执行之前，都会调用 expireIfNeeded 方法判断键值是否过期，过期则会从数据库中删除，反之则不做任何处理。</p>
<p>惰性删除执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604172032518.png" alt="image-20240604172032518"></p>
<h4 id="定期删除"><strong>定期删除</strong></h4>
<p>每隔一段时间检查一次数据库，随机删除一些过期键。</p>
<p>Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 <code>hz 10</code>。</p>
<p>需要注意的是：Redis 每次扫描并不是遍历过期字典中的所有键，而是采用随机抽取判断并删除过期键的形式执行的。</p>
<p><strong>定期删除流程</strong></p>
<ol>
<li>从过期字典中随机取出 20 个键；</li>
<li>删除这 20 个键中过期的键；</li>
<li>如果过期 key 的比例超过 25%，重复步骤 1。</li>
</ol>
<p>同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</p>
<p>定期删除执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604172045333.png" alt="image-20240604172045333"></p>
<ul>
<li>**优点：**通过限制删除操作的时长和频率，来减少删除操作对 Redis 主业务的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li>
<li>**缺点：**内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li>
</ul>
<p><strong>源码解析</strong></p>
<p>定期删除的核心源码在 src/expire.c 文件下的 activeExpireCycle 方法中，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> current_db = <span class="number">0</span>; <span class="comment">/* 上次定期删除遍历到的数据库ID */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* 上一次执行快速定期删除的时间点 */</span></span><br><span class="line">    <span class="type">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dbs_per_call = CRON_DBS_PER_CALL; <span class="comment">// 每次定期删除，遍历的数据库的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ACTIVE_EXPIRE_CYCLE_FAST_DURATION 是快速定期删除的执行时长</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">    <span class="comment">// 慢速定期删除的执行时长</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* 删除操作的执行时长 */</span></span><br><span class="line">    <span class="type">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="type">int</span> expired;</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line">        current_db++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// .......</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每个数据库中检查的键的数量</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line">            <span class="comment">// 从数据库中随机选取 num 个键进行检查</span></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> ttl;</span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedInteger</span><br><span class="line">                <span class="comment">// 过期检查，并对过期键进行删除</span></span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* We want the average TTL of keys yet not expired. */</span></span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">                total_sampled++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 每次检查只删除 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4 个过期键 */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activeExpireCycle 方法在规定的时间，分多次遍历各个数据库，从过期字典中随机检查一部分过期键的过期时间，删除其中的过期键。</p>
<p>这个函数有两种执行模式，一个是快速模式一个是慢速模式，体现是代码中的 timelimit 变量，这个变量是用来约束此函数的运行时间的。快速模式下 timelimit 的值是固定的，等于预定义常量 ACTIVE_EXPIRE_CYCLE_FAST_DURATION，慢速模式下，这个变量的值是通过 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100 计算的。</p>
<h4 id="Redis-使用的过期策略"><strong>Redis 使用的过期策略</strong></h4>
<p><strong>Redis 使用的是惰性删除加定期删除的过期策略。</strong></p>
<h3 id="小结-4">小结</h3>
<p>通过本文可知 Redis 是通过设置过期字典的形式来判断过期键的，Redis 采用的是惰性删除和定期删除的形式删除过期键的，Redis 的定期删除策略并不会遍历删除每个过期键，而是采用随机抽取的方式删除过期键，同时为了保证过期扫描不影响 Redis 主业务，Redis 的定期删除策略中还提供了最大执行时间，以保证 Redis 正常并高效地运行。</p>
<h2 id="19-Redis-管道技术——Pipeline">19 Redis 管道技术——Pipeline</h2>
<p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>通常情况下 Redis 是单行执行的，客户端先向服务器发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。</p>
<p>但如果出现集中大批量的请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p>
<p>普通命令模式，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604172200176.png" alt="image-20240604172200176"></p>
<p>管道模式，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604172808877.png" alt="image-20240604172808877"></p>
<blockquote>
<p>小贴士：管道中命令越多，管道技术的作用就更大，相比于普通模式来说执行效率就越高。</p>
</blockquote>
<h3 id="管道技术解决了什么问题？">管道技术解决了什么问题？</h3>
<p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p>
<h3 id="管道技术使用">管道技术使用</h3>
<p>本文我们使用 Jedis 客户端提供的 Pipeline 对象来实现管道技术。首先先获取 Pipeline 对象，再为 Pipeline 对象设置需要执行的命令，最后再使用 sync() 方法或 syncAndReturnAll() 方法来统一执行这些命令，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            pipe.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：297毫秒</span><br></pre></td></tr></table></figure>
<p>如果要接收管道所有命令的执行结果，可使用 syncAndReturnAll() 方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令并返回结果</span></span><br><span class="line">        List&lt;Object&gt; res = pipe.syncAndReturnAll();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : res) &#123;</span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管道技术-VS-普通命令">管道技术 VS 普通命令</h3>
<p>上面使用管道技术执行一个 for 循环所用的时间为 297 毫秒，接下来我们用普通的命令执行此循环，看下程序的执行时间，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            jedis.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：17276毫秒</span><br></pre></td></tr></table></figure>
<p><strong>结论</strong></p>
<p>从上面的结果可以看出，管道的执行时间是 297 毫秒，而普通命令执行时间是 17276 毫秒，管道技术要比普通的执行快了 58 倍。</p>
<h3 id="管道技术需要注意的事项">管道技术需要注意的事项</h3>
<p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p>
<ul>
<li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li>
<li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li>
<li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li>
</ul>
<h3 id="小结-5">小结</h3>
<p>使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率，但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p>
<p>【Redis管道的工作原理是这样的：在同一个TCP连接上，客户端可以连续发送多个命令而无需等待服务器的回复，同时服务器也可以连续接收并处理这些命令。当所有命令都处理完毕后，服务器将所有命令的结果一次性发送回客户端。】</p>
<h2 id="20-查询附近的人——GEO">20 查询附近的人——GEO</h2>
<p>受过高等教育的我们都知道，我们所处的任何位置都可以用经度和纬度来标识，经度的范围 -180 到 180，纬度的范围为 -90 到 90。纬度以赤道为界，赤道以南为负数，赤道以北为正数；经度以本初子午线（英国格林尼治天文台）为界，东边为正数，西边为负数。</p>
<p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，关于 GEO 的命令不多，主要包含以下 6 个：</p>
<ol>
<li>geoadd：添加地理位置</li>
<li>geopos：查询位置信息</li>
<li>geodist：距离统计</li>
<li>georadius：查询某位置内的其他成员信息</li>
<li>geohash：查询位置的哈希值</li>
<li>zrem：删除地理位置</li>
</ol>
<p>下面我们分别来看这些命令的使用。</p>
<h3 id="基础使用">基础使用</h3>
<h4 id="添加地理位置"><strong>添加地理位置</strong></h4>
<p>我们先用百度地图提供的经纬度查询工具，地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://api.map.baidu.com/lbsapi/getpoint/index.html">http://api.map.baidu.com/lbsapi/getpoint/index.html</a></p>
</blockquote>
<p>如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604172934996.png" alt="image-20240604172934996"></p>
<p>找了以下 4 个地点，添加到 Redis 中：</p>
<ol>
<li>天安门：116.404269,39.913164</li>
<li>月坛公园：116.36,39.922461</li>
<li>北京欢乐谷：116.499705,39.874635</li>
<li>香山公园：116.193275,39.996348</li>
</ol>
<p>代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd site 116.404269 39.913164 tianan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.36 39.922461 yuetan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.499705 39.874635 huanle</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.193275 39.996348 xiangshan</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude <span class="keyword">member</span> [longitude latitude <span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure>
<p>重点参数说明如下：</p>
<ul>
<li>longitude 表示经度</li>
<li>latitude 表示纬度</li>
<li>member 是为此经纬度起的名字</li>
</ul>
<p>此命令支持一次添加一个或多个位置信息。</p>
<h4 id="查询位置信息"><strong>查询位置信息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos site tianan</span><br><span class="line">1) 1) &quot;116.40541702508926392&quot;</span><br><span class="line">   2) &quot;39.91316289865137179&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure>
<p>此命令支持查看一个或多个位置信息。</p>
<h4 id="距离统计"><strong>距离统计</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist site tianan yuetan km</span><br><span class="line">&quot;3.9153&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出天安门距离月坛公园的直线距离大概是 3.9 km，我们打开地图使用工具测试一下咱们的统计结果是否准确，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604172949414.png" alt="image-20240604172949414"></p>
<p>可以看出 Redis 的统计和使用地图工具统计的距离是完全吻合的。</p>
<blockquote>
<p>注意：此命令统计的距离为两个位置的直线距离。</p>
</blockquote>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 <span class="selector-attr">[unit]</span></span><br></pre></td></tr></table></figure>
<p>unit 参数表示统计单位，它可以设置以下值：</p>
<ul>
<li>m：以米为单位，默认单位；</li>
<li>km：以千米为单位；</li>
<li>mi：以英里为单位；</li>
<li>ft：以英尺为单位。</li>
</ul>
<h4 id="查询某位置内的其他成员信息"><strong>查询某位置内的其他成员信息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure>
<p>此命令的意思是查询天安门（116.405419,39.913164）附近 5 公里范围内的成员列表。</p>
<p>相关语法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">georadius</span> <span class="selector-tag">key</span> <span class="selector-tag">longitude</span> <span class="selector-tag">latitude</span> <span class="selector-tag">radius</span> <span class="selector-tag">m</span>|<span class="selector-tag">km</span>|<span class="selector-tag">ft</span>|<span class="selector-tag">mi</span> <span class="selector-attr">[WITHCOORD]</span> <span class="selector-attr">[WITHDIST]</span> <span class="selector-attr">[WITHHASH]</span> <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[ASC|DESC]</span></span><br></pre></td></tr></table></figure>
<p>可选参数说明如下。</p>
<p><strong>1. WITHCOORD</strong></p>
<p>说明：返回满足条件位置的经纬度信息。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withcoord</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) 1) &quot;116.40426903963088989&quot;</span><br><span class="line">      2) &quot;39.91316289865137179&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) 1) &quot;116.36000186204910278&quot;</span><br><span class="line">      2) &quot;39.92246025586381819&quot;</span><br></pre></td></tr></table></figure>
<p><strong>2. WITHDIST</strong></p>
<p>说明：返回满足条件位置与查询位置的直线距离。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br></pre></td></tr></table></figure>
<p><strong>3. WITHHASH</strong></p>
<p>说明：返回满足条件位置的哈希信息。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withhash</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) (integer) 4069885552230465</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) (integer) 4069879797297521</span><br></pre></td></tr></table></figure>
<p><strong>4. COUNT count</strong></p>
<p>说明：指定返回满足条件位置的个数。</p>
<p>例如，指定返回一条满足条件的信息，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km count 1</span><br><span class="line">1) &quot;tianan&quot;</span><br></pre></td></tr></table></figure>
<p><strong>5. ASC|DESC</strong></p>
<p>说明：从近到远|从远到近排序返回。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km desc</span><br><span class="line">1) &quot;yuetan&quot;</span><br><span class="line">2) &quot;tianan&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km asc</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure>
<p>当然以上这些可选参数也可以一起使用，例如以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist desc</span><br><span class="line">1) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br><span class="line">2) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br></pre></td></tr></table></figure>
<p><strong>5. 查询哈希值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash site tianan</span><br><span class="line">1) &quot;wx4g0cgp000&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure>
<p>此命令支持查询一个或多个地址的哈希值。</p>
<p><strong>6. 删除地理位置</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem site xiaoming</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure>
<p>此命令支持删除一个或多个位置信息。</p>
<h3 id="代码实战-2">代码实战</h3>
<p>下面我们用 Java 代码，来实现查询附近的人，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoCoordinate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoRadiusResponse;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoUnit;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeoHashExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, GeoCoordinate&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加小明的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoming&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.404269</span>, <span class="number">39.913164</span>));</span><br><span class="line">        <span class="comment">// 添加小红的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaohong&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.36</span>, <span class="number">39.922461</span>));</span><br><span class="line">        <span class="comment">// 添加小美的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaomei&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.499705</span>, <span class="number">39.874635</span>));</span><br><span class="line">        <span class="comment">// 添加小二</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoer&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.193275</span>, <span class="number">39.996348</span>));</span><br><span class="line">        jedis.geoadd(<span class="string">&quot;person&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询小明和小红的直线距离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小明和小红相距：&quot;</span> + jedis.geodist(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xiaohong&quot;</span>, GeoUnit.KM) + <span class="string">&quot; KM&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询小明附近 5 公里的人</span></span><br><span class="line">        List&lt;GeoRadiusResponse&gt; res = jedis.georadiusByMemberReadonly(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, GeoUnit.KM);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明附近的人：&quot;</span> + res.get(i).getMemberByString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序执行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明和小红相距：3.9153 KM</span><br><span class="line">小明附近的人：xiaohong</span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<p>Redis 中的 GEO 经典使用场景如下：</p>
<ol>
<li>查询附近的人、附近的地点等；</li>
<li>计算相关的距离信息。</li>
</ol>
<h3 id="小结-6">小结</h3>
<p>GEO 是 Redis 3.2 版本中新增的功能，只有升级到 3.2+ 才能使用，GEO 本质上是基于 ZSet 实现的，这点在 Redis 源码找到相关信息，我们可以 GEO 使用实现查找附近的人或者附近的地点，还可以用它来计算两个位置相隔的直线距离。</p>
<h2 id="21-游标迭代器（过滤器）——Scan">21 游标迭代器（过滤器）——Scan</h2>
<h3 id="一个问题引发的「血案」">一个问题引发的「血案」</h3>
<p>曾经发生过这样一件事，我们的 Redis 服务器存储了海量的数据，其中登录用户信息是以 user_token_id 的形式存储的。运营人员想要当前所有的用户登录信息，然后悲剧就发生了：因为我们的工程师使用了 <code>keys user_token_*</code> 来查询对应的用户，结果导致 Redis 假死不可用，以至于影响到线上的其他业务接连发生问题，然后就收到了一堆的系统预警短信。并且这个假死的时间是和存储的数据成正比的，数据量越大假死的时间就越长，导致的故障时间也越长。</p>
<p>那如何避免这个问题呢？</p>
<h3 id="问题的解决方案">问题的解决方案</h3>
<p>在 Redis 2.8 之前，我们只能使用 keys 命令来查询我们想要的数据，但这个命令存在两个缺点：</p>
<ol>
<li>此命令没有分页功能，我们只能一次性查询出所有符合条件的 key 值，如果查询结果非常巨大，那么得到的输出信息也会非常多；</li>
<li>keys 命令是遍历查询，因此它的查询时间复杂度是 o(n)，所以数据量越大查询时间就越长。</li>
</ol>
<p>然而，比较幸运的是在 Redis 2.8 时推出了 Scan，解决了我们这些问题，下面来看 Scan 的具体使用。</p>
<h3 id="Scan-命令使用">Scan 命令使用</h3>
<p>我们先来模拟海量数据，使用 Pipeline 添加 10w 条数据，Java 代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加 10w 条数据</span></span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100001</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;user_token_&quot;</span> + i, <span class="string">&quot;id&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据插入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来查询用户 id 为 9999* 的数据，Scan 命令使用如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match user_token_9999* count 10000</span><br><span class="line">1) &quot;127064&quot;</span><br><span class="line">2) 1) &quot;user_token_99997&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 127064 match user_token_9999* count 10000</span><br><span class="line">1) &quot;1740&quot;</span><br><span class="line">2) 1) &quot;user_token_9999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1740 match user_token_9999* count 10000</span><br><span class="line">1) &quot;21298&quot;</span><br><span class="line">2) 1) &quot;user_token_99996&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 21298 match user_token_9999* count 10000</span><br><span class="line">1) &quot;65382&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 65382 match user_token_9999* count 10000</span><br><span class="line">1) &quot;78081&quot;</span><br><span class="line">2) 1) &quot;user_token_99998&quot;</span><br><span class="line">   2) &quot;user_token_99992&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 78081 match user_token_9999* count 10000</span><br><span class="line">1) &quot;3993&quot;</span><br><span class="line">2) 1) &quot;user_token_99994&quot;</span><br><span class="line">   2) &quot;user_token_99993&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3993 match user_token_9999* count 10000</span><br><span class="line">1) &quot;13773&quot;</span><br><span class="line">2) 1) &quot;user_token_99995&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 13773 match user_token_9999* count 10000</span><br><span class="line">1) &quot;47923&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 47923 match user_token_9999* count 10000</span><br><span class="line">1) &quot;59751&quot;</span><br><span class="line">2) 1) &quot;user_token_99990&quot;</span><br><span class="line">   2) &quot;user_token_99991&quot;</span><br><span class="line">   3) &quot;user_token_99999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 59751 match user_token_9999* count 10000</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) (empty list or set)</span><br></pre></td></tr></table></figure>
<p>从以上的执行结果，我们看出两个问题：</p>
<ol>
<li>查询的结果为空，但游标值不为 0，表示遍历还没结束；</li>
<li>设置的是 count 10000，但每次返回的数量都不是 10000，且不固定，这是因为 count 只是限定服务器单次遍历的字典槽位数量（约等于），而不是规定返回结果的 count 值。</li>
</ol>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>cursor：光标位置，整数值，从 0 开始，到 0 结束，查询结果是空，但游标值不为 0，表示遍历还没结束；</li>
<li>match pattern：正则匹配字段；</li>
<li>count：限定服务器单次遍历的字典槽位数量（约等于），只是对增量式迭代命令的一种提示（hint），并不是查询结果返回的最大数量，它的默认值是 10。</li>
</ul>
<h3 id="代码实战-3">代码实战</h3>
<p>本文我们使用 Java 代码来实现 Scan 的查询功能，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanParams;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 定义 match 和 count 参数</span></span><br><span class="line">        <span class="type">ScanParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanParams</span>();</span><br><span class="line">        params.count(<span class="number">10000</span>);</span><br><span class="line">        params.match(<span class="string">&quot;user_token_9999*&quot;</span>);</span><br><span class="line">        <span class="comment">// 游标</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ScanResult&lt;String&gt; res = jedis.scan(cursor, params);</span><br><span class="line">            <span class="keyword">if</span> (res.getCursor().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 表示最后一条</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = res.getCursor(); <span class="comment">// 设置游标</span></span><br><span class="line">            <span class="keyword">for</span> (String item : res.getResult()) &#123;</span><br><span class="line">                <span class="comment">// 打印查询结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;查询结果：&quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询结果：user_token_99997</span><br><span class="line">查询结果：user_token_9999</span><br><span class="line">查询结果：user_token_99996</span><br><span class="line">查询结果：user_token_99998</span><br><span class="line">查询结果：user_token_99992</span><br><span class="line">查询结果：user_token_99994</span><br><span class="line">查询结果：user_token_99993</span><br><span class="line">查询结果：user_token_99995</span><br><span class="line">查询结果：user_token_99990</span><br><span class="line">查询结果：user_token_99991</span><br><span class="line">查询结果：user_token_99999</span><br></pre></td></tr></table></figure>
<h3 id="Scan-相关命令">Scan 相关命令</h3>
<p>Scan 是一个系列指令，除了 Scan 之外，还有以下 3 个命令：</p>
<ol>
<li>HScan 遍历字典游标迭代器</li>
<li>SScan 遍历集合的游标迭代器</li>
<li>ZScan 遍历有序集合的游标迭代器</li>
</ol>
<p>来看这些命令的具体使用。</p>
<h4 id="HScan-使用"><strong>HScan 使用</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan myhash 0 match k2* count 10</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;k2&quot;</span><br><span class="line">   2) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>
<h4 id="SScan-使用"><strong>SScan 使用</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan myset 0 match v2* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>
<h4 id="ZScan-使用"><strong>ZScan 使用</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan zset 0 match red* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;redis&quot;</span><br><span class="line">   2) &quot;10&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>
<h3 id="Scan-说明">Scan 说明</h3>
<p>官方对 Scan 命令的描述信息如下。</p>
<h4 id="Scan-guarantees"><strong>Scan guarantees</strong></h4>
<blockquote>
<p>The SCAN command, and the other commands in the SCAN family, are able to provide to the user a set of guarantees associated to full iterations.</p>
<ul>
<li>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point SCANreturned it to the user.</li>
<li>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, SCAN ensures that this element will never be returned.</li>
</ul>
<p>However because SCAN has very little state associated (just the cursor) it has the following drawbacks:</p>
<ul>
<li>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</li>
<li>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</li>
</ul>
</blockquote>
<p>官方文档地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
</blockquote>
<p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p>
<ul>
<li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li>
<li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li>
</ul>
<p>然后，Scan 命令包含以下缺点：</p>
<ul>
<li>一个元素可能被返回多次，需要客户端来实现去重；</li>
<li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。</li>
</ul>
<h3 id="小结-7">小结</h3>
<p>通过本文我们可以知道 Scan 包含以下四个指令：</p>
<ol>
<li>Scan：用于检索当前数据库中所有数据；</li>
<li>HScan：用于检索哈希类型的数据；</li>
<li>SScan：用于检索集合类型中的数据；</li>
<li>ZScan：由于检索有序集合中的数据。</li>
</ol>
<p>Scan 具备以下几个特点：</p>
<ol>
<li>Scan 可以实现 keys 的匹配功能；</li>
<li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li>
<li>Scan 提供了 count 参数，可以规定遍历的数量；</li>
<li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li>
<li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li>
<li>单次返回空值且游标不为 0，说明遍历还没结束；</li>
<li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li>
<li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li>
</ol>
<p><strong>Scan命令的主要用途是</strong>允许用户在不阻塞服务器的情况下遍历数据库的键。在大规模数据集中，如果你需要遍历所有的键，使用Scan命令比使用Keys命令更加高效，因为Keys命令在处理大量数据时可能会阻塞服务器。</p>
<p>此外，Scan命令还支持一个可选的匹配模式参数(match)，可以让用户只迭代那些与给定模式匹配的键。这个特性让Scan命令在搜索特定的键时变得非常有用。</p>
<h2 id="22-优秀的基数统计算法——HyperLogLog">22 优秀的基数统计算法——HyperLogLog</h2>
<h3 id="为什么要使用-HyperLogLog？">为什么要使用 HyperLogLog？</h3>
<p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p>
<p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p>
<p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p>
<h3 id="HyperLogLog-介绍">HyperLogLog 介绍</h3>
<p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p>
<p>HLL 具有以下几个特点：</p>
<ul>
<li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li>
<li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li>
<li>误差可以被设置辅助计算因子进行降低。</li>
</ul>
<h3 id="基础使用-2">基础使用</h3>
<p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p>
<h4 id="添加元素"><strong>添加元素</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element <span class="selector-attr">[element ...]</span></span><br></pre></td></tr></table></figure>
<p>此命令支持添加一个或多个元素至 HLL 结构中。</p>
<h4 id="统计不重复的元素"><strong>统计不重复的元素</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure>
<p>此命令支持统计一个或多个 HLL 结构。</p>
<h4 id="合并一个或多个-HLL-至新结构"><strong>合并一个或多个 HLL 至新结构</strong></h4>
<p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd k &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd k2 &quot;redis&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge k3 k k2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount k3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey <span class="selector-attr">[sourcekey ...]</span></span><br></pre></td></tr></table></figure>
<p><strong>pfmerge 使用场景</strong></p>
<p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p>
<h3 id="代码实战-4">代码实战</h3>
<p>接下来我们使用 Java 代码来实现 HLL 的三个基础功能，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HyperLogLogExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计元素</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印统计元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k：&quot;</span> + count);</span><br><span class="line">        <span class="comment">// 合并 HLL</span></span><br><span class="line">        jedis.pfmerge(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印新 HLL</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k2：&quot;</span> + jedis.pfcount(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k：2</span><br><span class="line">k2：2</span><br></pre></td></tr></table></figure>
<h3 id="HLL-算法原理">HLL 算法原理</h3>
<p>HyperLogLog 算法来源于论文 <a target="_blank" rel="noopener" href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</em></a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p>
<p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p>
<ul>
<li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li>
<li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li>
<li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li>
</ul>
<p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p>
<p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p>
<p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p>
<blockquote>
<p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500‬ 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1⁄1000+1⁄100000)≈1998 元，显然此算法更符合实际平均数。</p>
</blockquote>
<p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文，链接地址在文末。</p>
<h3 id="小结-8">小结</h3>
<p>当需要做大量数据统计时，普通的集合类型已经不能满足我们的需求了，这个时候我们可以借助 Redis 2.8.9 中提供的 HyperLogLog 来统计，它的优点是只需要使用 12k 的空间就能统计 2^64 的数据，但它的缺点是存在 0.81% 的误差，HyperLogLog 提供了三个操作方法 pfadd 添加元素、pfcount 统计元素和 pfmerge 合并元素。</p>
<h3 id="参考文献">参考文献</h3>
<ul>
<li>论文 <a target="_blank" rel="noopener" href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm</em></a></li>
</ul>
<h2 id="23-内存淘汰机制与算法">23 内存淘汰机制与算法</h2>
<p>在本文开始之前，我们先要明白：在 Redis 中，过期策略和内存淘汰策略两个完全不同的概念，但很多人会把两者搞混。</p>
<p>首先，Redis 过期策略指的是 Redis 使用那种策略，来删除已经过期的键值对；而 Redis 内存淘汰机制指的是，当 Redis 运行内存已经超过 Redis 设置的最大内存之后，将采用什么策略来删除符合条件的键值对，以此来保障 Redis 高效的运行。</p>
<p>过期策略前面的文章，我们已经详细地讲过了，本文我们重点来看 Redis 的内存淘汰机制。</p>
<h3 id="Redis-最大运行内存">Redis 最大运行内存</h3>
<p>只有在 Redis 的运行内存达到了某个阀值，才会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>
<p>内存淘汰执行流程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604174034161.png" alt="image-20240604174034161"></p>
<h4 id="查询最大运行内存"><strong>查询最大运行内存</strong></h4>
<p>我们可以使用命令 <code>config get maxmemory</code> 来查看设置的最大运行内存，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br><span class="line">1) &quot;maxmemory&quot;</span><br><span class="line">2) &quot;0&quot;</span><br></pre></td></tr></table></figure>
<p>我们发现此值竟然是 0，这是 64 位操作系统默认的值，当 maxmemory 为 0 时，表示没有内存大小限制。</p>
<blockquote>
<p>小贴士：32 位操作系统，默认的最大内存值是 3GB。</p>
</blockquote>
<h3 id="内存淘汰策略">内存淘汰策略</h3>
<h4 id="查看-Redis-内存淘汰策略"><strong>查看 Redis 内存淘汰策略</strong></h4>
<p>我们可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) &quot;maxmemory-policy&quot;</span><br><span class="line">2) &quot;noeviction&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出此 Redis 使用的是 noeviction 类型的内存淘汰机制，它表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。</p>
<h4 id="内存淘汰策略分类"><strong>内存淘汰策略分类</strong></h4>
<p>早期版本的 Redis 有以下 6 种淘汰策略：</p>
<ol>
<li><strong>noeviction</strong>：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>volatile-lru</strong>：淘汰所有设置了过期时间的键值中最久未使用的键值；</li>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
</ol>
<p>在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p>
<ol>
<li><strong>volatile-lfu</strong>：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
<li><strong>allkeys-lfu</strong>：淘汰整个键值中最少使用的键值。</li>
</ol>
<p>其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p>
<h4 id="修改-Redis-内存淘汰策略"><strong>修改 Redis 内存淘汰策略</strong></h4>
<p>设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。</p>
<ul>
<li>方式一：通过“config set maxmemory-policy 策略”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li>
<li>方式二：通过修改 Redis 配置文件修改，设置“maxmemory-policy 策略”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li>
</ul>
<h3 id="内存淘汰算法">内存淘汰算法</h3>
<p>从内测淘汰策略分类上，我们可以得知，除了随机删除和不删除之外，主要有两种淘汰算法：LRU 算法和 LFU 算法。</p>
<h4 id="LRU-算法"><strong>LRU 算法</strong></h4>
<p>LRU 全称是 Least Recently Used 译为最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p>
<p><strong>1. LRU 算法实现</strong></p>
<p>LRU 算法需要基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可。</p>
<p><strong>2. 近 LRU 算法</strong></p>
<p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间，Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p>
<p><strong>3. LRU 算法缺点</strong></p>
<p>LRU 算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰，因此在 Redis 4.0 之后引入了 LFU 算法，下面我们一起来看。</p>
<h4 id="LFU-算法"><strong>LFU 算法</strong></h4>
<p>LFU 全称是 Least Frequently Used 翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>LFU 解决了偶尔被访问一次之后，数据就不会被淘汰的问题，相比于 LRU 算法也更合理一些。</p>
<p>在 Redis 中每个对象头中记录着 LFU 的信息，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>在 Redis 中 LFU 存储分为两部分，16 bit 的 ldt（last decrement time）和 8 bit 的 logc（logistic counter）。</p>
<ol>
<li>logc 是用来存储访问频次，8 bit 能表示的最大整数值为 255，它的值越小表示使用频率越低，越容易淘汰；</li>
<li>ldt 是用来存储上一次 logc 的更新时间。</li>
</ol>
<h3 id="小结-9">小结</h3>
<p>通过本文我们了解到，Redis 内存淘汰策略和过期回收策略是完全不同的概念，内存淘汰策略是解决 Redis 运行内存过大的问题的，通过与 maxmemory 比较，决定要不要淘汰数据，根据 maxmemory-policy 参数，决定使用何种淘汰策略，在 Redis 4.0 之后已经有 8 种淘汰策略了，默认的策略是 noeviction 当内存超出时不淘汰任何键值，只是新增操作会报错。</p>
<h2 id="24-消息队列——发布订阅模式">24 消息队列——发布订阅模式</h2>
<p>在 Redis 中提供了专门的类型：Publisher（发布者）和 Subscriber（订阅者）来实现消息队列。</p>
<p>在文章开始之前，先来介绍消息队列中有几个基础概念，以便大家更好的理解本文的内容。</p>
<p>首先，发布消息的叫做发布方或发布者，也就是消息的生产者，而接收消息的叫做消息的订阅方或订阅者，也就是消费者，用来处理生产者发布的消息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604190138707.png" alt="image-20240604190138707"></p>
<p>除了发布和和订阅者，在消息队列中还有一个重要的概念：channel 意为频道或通道，可以理解为某个消息队列的名称，首先消费者先要订阅某个 channel，然后当生产者把消息发送到这个 channel 中时，消费者就可以正常接收到消息了，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604190159465.png" alt="image-20240604190159465"></p>
<h3 id="普通订阅与发布">普通订阅与发布</h3>
<p>消息队列有两个重要的角色，一个是发送者，另一个就是订阅者，对应的命令如下：</p>
<ul>
<li>发布消息：publish channel “message”</li>
<li>订阅消息：subscribe channel</li>
</ul>
<p>下面我们来看具体的命令实现。</p>
<h4 id="订阅消息"><strong>订阅消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel #订阅消息channel</span><br><span class="line">Reading messages...</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel <span class="selector-attr">[channel ...]</span></span><br></pre></td></tr></table></figure>
<p>此命令支持订阅一个或多个频道的命令，也就是说一个订阅者可以订阅多个频道。例如，某个客户端订阅了两个频道 channel 和 channel2，当两个发布者分别推送消息后，订阅者的信息输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel channel2 #订阅 channel 和 channel2</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel2&quot;</span><br><span class="line">3) (integer) 2</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel&quot; # 收到 channel 消息</span><br><span class="line">3) &quot;message 1.&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel2&quot; # 收到 channel2 消息</span><br><span class="line">3) &quot;message 2.&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出此订阅者可以收到来自两个频道的消息推送。</p>
<h4 id="发送消息"><strong>发送消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel &quot;hello,redis.&quot; #发布消息</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure>
<p>最后的返回值表示成功发送给几个订阅方，1 表示成功发给了一个订阅者，这个数字可以是 0~n，这是由订阅者的数量决定的。</p>
<p>例如，当有两个订阅者时，推送的结果为 2，如下代码所示。</p>
<p>订阅者一：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
<p>订阅者二：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
<p>发送消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel &quot;message&quot;</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<p>可以看出，此消息已成功发给两个订阅者，结果也变成 2 了。</p>
<h3 id="主题订阅">主题订阅</h3>
<p>上面介绍了普通的订阅与发布模式，但如果我要订阅某一个类型的消息就不适用了，例如我要订阅日志类的消息队列，它们的命名都是 logXXX，这个时候就需要使用 Redis 提供的另一个功能 Pattern Subscribe 主题订阅，这种方式可以使用 <code>*</code> 来匹配多个频道，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604190215916.png" alt="image-20240604190215916"></p>
<p>主题模式的具体实现代码如下，订阅者：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe log_* #主题订阅 log_*</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_user&quot; #接收到频道 log_user 的消息推送</span><br><span class="line">4) &quot;user message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_sys&quot; #接收到频道 log_sys 的消息推送</span><br><span class="line">4) &quot;sys message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_db&quot; #接收到频道 log_db 的消息推送</span><br><span class="line">4) &quot;db message&quot;</span><br></pre></td></tr></table></figure>
<p>从上面的运行结果，可以看出使用命令 <code>psubscribe log_*</code> 可以接收到所有频道包含 log_XXX 的消息。</p>
<p>相关语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psubscribe <span class="keyword">pattern</span> [<span class="keyword">pattern</span> ...]</span><br></pre></td></tr></table></figure>
<p>生产者的代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish log_user &quot;user message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_sys &quot;sys message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_db &quot;db message&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h3 id="代码实战-5">代码实战</h3>
<p>下面我们使用 Jedis 实现普通的发布订阅模式和主题订阅的功能。</p>
<h4 id="普通模式"><strong>普通模式</strong></h4>
<p>消费者代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 接收并处理消息</span></span><br><span class="line">    jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 推送消息</span></span><br><span class="line">    jedis.publish(<span class="string">&quot;channel&quot;</span>, <span class="string">&quot;Hello, channel.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发布者和订阅者模式运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程作为消费者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure>
<h4 id="主题订阅模式"><strong>主题订阅模式</strong></h4>
<p>主题订阅模式的生产者的代码是一样，只有消费者的代码是不同的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    jedis.psubscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> &#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(pattern + <span class="string">&quot; 主题 | 频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主题模式运行代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; pConsumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel* 主题 | 频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<p>发布订阅模式存在以下两个缺点：</p>
<ol>
<li>无法持久化保存消息，如果 Redis 服务器宕机或重启，那么所有的消息将会丢失；</li>
<li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li>
</ol>
<p>然而这些缺点在 Redis 5.0 添加了 Stream 类型之后会被彻底的解决。</p>
<p>除了以上缺点外，发布订阅模式还有另一个需要注意问题：当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</p>
<h3 id="小结-10">小结</h3>
<p>本文介绍了消息队列的几个名词，生产者、消费者对应的就是消息的发送者和接收者，也介绍了发布订阅模式的三个命令：</p>
<ul>
<li>subscribe channel 普通订阅</li>
<li>publish channel message 消息推送</li>
<li>psubscribe pattern 主题订阅</li>
</ul>
<p>使用它们之后就可以完成单个频道和多个频道的消息收发，但发送与订阅模式也有一些缺点，比如“发后既忘”和不能持久化等问题，然而这些问题会等到 Stream 类型的出现而得到解决，关于更多 Stream 的内容后面文章会详细介绍。</p>
<h2 id="25-消息队列的其他实现方式">25 消息队列的其他实现方式</h2>
<p>在 Redis 5.0 之前消息队列的实现方式有很多种，比较常见的除了我们上文介绍的发布订阅模式，还有两种：List 和 ZSet 的实现方式。</p>
<p>List 和 ZSet 的方式解决了发布订阅模式不能持久化的问题，但这两种方式也有自己的缺点，接下来我们一起来了解一下，先从 List 实现消息队列的方式说起。</p>
<h3 id="List-版消息队列">List 版消息队列</h3>
<p>List 方式是实现消息队列最简单和最直接的方式，它主要是通过 lpush 和 rpop 存入和读取实现消息队列的，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604190256339.png" alt="image-20240604190256339"></p>
<p>List 使用命令的方式实现消息队列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mq &quot;hello&quot; #推送消息 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush mq &quot;msg&quot; #推送消息 msg</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 hello</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 msg</span><br><span class="line">&quot;mq&quot;</span><br></pre></td></tr></table></figure>
<p>其中，mq 就相当于频道名称 channel，而 lpush 用于生产消息， rpop 拉取消息。</p>
<h4 id="代码实现"><strong>代码实现</strong></h4>
<p>接下来我们用 Java 代码的方式来实现 List 形式的消息队列，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMQExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;mq&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收到了消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收到消息：Hello, List.</span><br></pre></td></tr></table></figure>
<p>我们使用无限循环来获取队列中的数据，这样就可以实时地获取相关信息了，但这样会带来另一个新的问题，当队列中如果没有数据的情况下，无限循环会一直消耗系统的资源，这时候我们可以使用 brpop 替代 rpop 来完美解决这个问题。</p>
<p>b 是 blocking 的缩写，表示阻塞读，也就是当队列没有数据时，它会进入休眠状态，当有数据进入队列之后，它才会“苏醒”过来执行读取任务，这样就可以解决 while 循环一直执行消耗系统资源的问题了，改良版代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMQExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 消费者 改良版</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; bConsumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 2.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 3.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者（阻塞版）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞读</span></span><br><span class="line">            <span class="keyword">for</span> (String item : jedis.brpop(<span class="number">0</span>,<span class="string">&quot;mq&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 读取到相关数据，进行业务处理</span></span><br><span class="line">                System.out.println(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，brpop() 方法的第一个参数是设置超时时间的，设置 0 表示一直阻塞。</p>
<h4 id="优缺点分析"><strong>优缺点分析</strong></h4>
<p>List 优点：</p>
<ul>
<li>消息可以被持久化，借助 Redis 本身的持久化（AOF、RDB 或者是混合持久化），可以有效的保存数据；</li>
<li>消费者可以积压消息，不会因为客户端的消息过多而被强行断开。</li>
</ul>
<p>List 缺点：</p>
<ul>
<li>消息不能被重复消费，一个消息消费完就会被删除；</li>
<li>没有主题订阅的功能。</li>
</ul>
<h3 id="ZSet-版消息队列">ZSet 版消息队列</h3>
<p>ZSet 版消息队列相比于之前的两种方式，List 和发布订阅方式在实现上要复杂一些，但 ZSet 因为多了一个 score（分值）属性，从而使它具备更多的功能，例如我们可以用它来存储时间戳，以此来实现延迟消息队列等。</p>
<p>它的实现思路和 List 相同也是利用 zadd 和 zrangebyscore 来实现存入和读取，这里就不重复叙述了，读者可以根据 List 的实现方式来实践一下，看能不能实现相应的功能，如果写不出来也没关系，本课程的后面章节，介绍延迟队列的时候会用 ZSet 来实现。</p>
<h4 id="优缺点分析-2"><strong>优缺点分析</strong></h4>
<p>ZSet 优点：</p>
<ul>
<li>支持消息持久化；</li>
<li>相比于 List 查询更方便，ZSet 可以利用 score 属性很方便的完成检索，而 List 则需要遍历整个元素才能检索到某个值。</li>
</ul>
<p>ZSet 缺点：</p>
<ul>
<li>ZSet 不能存储相同元素的值，也就是如果有消息是重复的，那么只能插入一条信息在有序集合中；</li>
<li>ZSet 是根据 score 值排序的，不能像 List 一样，按照插入顺序来排序；</li>
<li>ZSet 没有向 List 的 brpop 那样的阻塞弹出的功能。</li>
</ul>
<h3 id="小结-11">小结</h3>
<p>本文介绍了消息队列的另外两种实现方式 List 和 ZSet，它们都是利用自身方法，先把数据放到队列里，在使用无限循环读取队列中的消息，以实现消息队列的功能，相比发布订阅模式本文介绍的这两种方式的优势是支持持久化，当然它们各自都存在一些问题，所以期待下一课时 Stream 的出现能够解决这些问题。</p>
<h2 id="26-消息队列终极解决方案——Stream（上）">26 消息队列终极解决方案——Stream（上）</h2>
<h3 id="基础使用-3">基础使用</h3>
<p>Stream 既然是一个数据类型，那么和其他数据类型相似，它也有一些自己的操作方法，例如：</p>
<ul>
<li>xadd 添加消息；</li>
<li>xlen 查询消息长度；</li>
<li>xdel 根据消息 ID 删除消息；</li>
<li>del 删除整个 Stream；</li>
<li>xrange 读取区间消息</li>
<li>xread 读取某个消息之后的消息。</li>
</ul>
<p>具体使用如下所述。</p>
<h4 id="添加消息"><strong>添加消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis age 10</span><br><span class="line">&quot;1580880750844-0&quot; #结果返回的是消息 id</span><br></pre></td></tr></table></figure>
<p>其中 <code>*</code> 表示使用 Redis 的规则：时间戳 + 序号的方式自动生成 ID，用户也可以自己指定 ID。</p>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xadd <span class="keyword">key</span> ID field <span class="type">string</span> [field <span class="type">string</span> ...]</span><br></pre></td></tr></table></figure>
<h4 id="查询消息的长度"><strong>查询消息的长度</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlen <span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h4 id="删除消息"><strong>删除消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis</span><br><span class="line">&quot;1580881585129-0&quot; #消息 ID</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xdel key 1580881585129-0 #删除消息，根据 ID</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdel key ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure>
<p>此命令支持删除一条或多条消息，根据消息 ID。</p>
<h4 id="删除整个-Stream"><strong>删除整个 Stream</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key #删除整个 Stream</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">del</span> key <span class="selector-attr">[key ...]</span></span><br></pre></td></tr></table></figure>
<p>此命令支持删除一个或多个 Stream。</p>
<h4 id="查询区间消息"><strong>查询区间消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xrange mq - +</span><br><span class="line">1) 1) &quot;1580882060464-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;redis&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;10&quot;</span><br><span class="line">2) 1) &quot;1580882071524-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;java&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br></pre></td></tr></table></figure>
<p>其中：<code>-</code> 表示第一条消息，<code>+</code> 表示最后一条消息。</p>
<p>相关语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xrange key <span class="keyword">start</span> <span class="keyword">end</span> [COUNT count]</span><br></pre></td></tr></table></figure>
<h4 id="查询某个消息之后的消息"><strong>查询某个消息之后的消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 streams mq 1580882060464-0</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580882071524-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;java&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br></pre></td></tr></table></figure>
<p>在名称为 mq 的 Stream 中，从消息 ID 为 1580882060464-0 的，往后查询一条消息。</p>
<p>相关语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xread <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[BLOCK milliseconds]</span> STREAMS key <span class="selector-attr">[key ...]</span> ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure>
<p>此命令提供了阻塞读的参数 block，我们可以使用它读取从当前数据以后新增数据，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br></pre></td></tr></table></figure>
<p>其中 <code>block 0</code> 表示一直阻塞，<code>$</code> 表示从最后开始读取，这个时候新开一个命令行插入一条数据，此命令展示的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mq * name sql age 20 #新窗口添加数据</span><br><span class="line">&quot;1580890737890-0&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞读取到的新数据</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580890737890-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;sql&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">(36.37s)</span><br></pre></td></tr></table></figure>
<h3 id="基础版消息队列">基础版消息队列</h3>
<p>使用 Stream 消费分组实现消息队列的功能和列表方式的消息队列比较相似，使用 xadd 命令和 xread 循环读取就可以实现基础版的消息队列，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id</span> <span class="operator">=</span> jedis.xadd(<span class="string">&quot;mq&quot;</span>, <span class="literal">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，new StreamEntryID().LAST_ENTRY 标识获取当前时间以后的新增消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(<span class="string">&quot;mq&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().LAST_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xread(<span class="number">1</span>, <span class="number">120</span> * <span class="number">1000</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID());</span><br><span class="line">                <span class="comment">// 使用 Gson 来打印 JSON 格式的消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息添加成功 ID：1580895735148-0</span><br><span class="line">读取到消息 ID：1580895735148-0</span><br><span class="line">内容：&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;10&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码需要特殊说明的是，我们使用 <code>new StreamEntryID().LAST_ENTRY</code> 来实现读取当前时间以后新增的消息，如果要从头读取历史消息把这行代码中的 <code>.LAST_ENTRY</code> 去掉即可。</p>
<p>还有一点需要注意，在 Jedis 框架中如果使用 jedis.xread() 方法来阻塞读取消息队列，第二个参数 long block 必须设置大于 0，如果设置小于 0，此阻塞条件就无效了，我查看了 jedis 的源码发现，它只有判断在大于 0 的时候才会设置阻塞属性，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    params[streamsIndex++] = Keyword.BLOCK.raw;</span><br><span class="line">    params[streamsIndex++] = Protocol.toByteArray(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 block 属性我们可以设置一个比较大的值来阻塞读取消息。</p>
<blockquote>
<p>所谓的阻塞读取消息指的是当队列中没有数据时会进入休眠模式，等有数据之后才会唤醒继续执行。</p>
</blockquote>
<h3 id="小结-12">小结</h3>
<p>本文介绍了 Stream 的基础方法，并使用 xadd 存入消息和 xread 循环阻塞读取消息的方式实现了简易版的消息队列，交互流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604192242356.png" alt="image-20240604192242356"></p>
<h2 id="27-消息队列终极解决方案——Stream（下）">27 消息队列终极解决方案——Stream（下）</h2>
<p>在开始使用消息分组之前，我们必须手动创建分组才行，以下是几个和 Stream 分组有关的命令，我们先来学习一下它的使用。</p>
<h3 id="消息分组命令">消息分组命令</h3>
<h4 id="创建消费者群组"><strong>创建消费者群组</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create mq group1 0-0 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgroup create stream-<span class="keyword">key</span> <span class="keyword">group</span>-<span class="keyword">key</span> ID</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>mq 为 Stream 的 key；</li>
<li>group1 为分组的名称；</li>
<li>0-0 表示从第一条消息开始读取。</li>
</ul>
<p>如果要从当前最后一条消息向后读取，使用 <code>$</code> 即可，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create mq group2 $</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h4 id="读取消息"><strong>读取消息</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 streams mq &gt;</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580959593553-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;redis&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;10&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xreadgroup <span class="keyword">group</span> <span class="keyword">group</span>-<span class="keyword">key</span> consumer-<span class="keyword">key</span> streams stream-<span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>&gt;</code> 表示读取下一条消息；</li>
<li>group1 表示分组名称；</li>
<li>c1 表示 consumer（消费者）名称。</li>
</ul>
<p>xreadgroup 命令和 xread 使用类似，也可以设置阻塞读取，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c2 streams mq &gt;</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580959606181-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;java&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c2 streams mq &gt;</span><br><span class="line">(nil) #队列中的消息已经被读取完</span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 block 0 streams mq &gt; #阻塞读取</span><br></pre></td></tr></table></figure>
<p>此时打开另一个命令行创建使用 xadd 添加一条消息，阻塞命令执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 block 0 streams mq &gt;</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580961475368-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;sql&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">(86.14s)</span><br></pre></td></tr></table></figure>
<h4 id="消息消费确认"><strong>消息消费确认</strong></h4>
<p>接收到消息之后，我们要手动确认一下（ack），命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xack mq group1 1580959593553-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xack <span class="keyword">key</span> <span class="keyword">group</span>-<span class="keyword">key</span> ID [ID ...]</span><br></pre></td></tr></table></figure>
<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 ack 确认消息已经被消费完成，整个流程的执行如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604192818740.png" alt="image-20240604192818740"></p>
<h4 id="查询未确认的消费队列"><strong>查询未确认的消费队列</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xpending mq group1</span><br><span class="line">1) (integer) 1 #未确认（ack）的消息数量为 1 条</span><br><span class="line">2) &quot;1580994063971-0&quot;</span><br><span class="line">3) &quot;1580994063971-0&quot;</span><br><span class="line">4) 1) 1) &quot;c1&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; xack  mq group1 1580994063971-0 #消费确认</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xpending mq group1</span><br><span class="line">1) (integer) 0 #没有未确认的消息</span><br><span class="line">2) (nil)</span><br><span class="line">3) (nil)</span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure>
<h4 id="xinfo-查询相关命令"><strong>xinfo 查询相关命令</strong></h4>
<p><strong>1. 查询流信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo stream mq</span><br><span class="line"> 1) &quot;length&quot;</span><br><span class="line"> 2) (integer) 2 #队列中有两个消息</span><br><span class="line"> 3) &quot;radix-tree-keys&quot;</span><br><span class="line"> 4) (integer) 1</span><br><span class="line"> 5) &quot;radix-tree-nodes&quot;</span><br><span class="line"> 6) (integer) 2</span><br><span class="line"> 7) &quot;groups&quot;</span><br><span class="line"> 8) (integer) 1 #一个消费分组</span><br><span class="line"> 9) &quot;last-generated-id&quot;</span><br><span class="line">10) &quot;1580959606181-0&quot;</span><br><span class="line">11) &quot;first-entry&quot;</span><br><span class="line">12) 1) &quot;1580959593553-0&quot;</span><br><span class="line">    2) 1) &quot;name&quot;</span><br><span class="line">       2) &quot;redis&quot;</span><br><span class="line">       3) &quot;age&quot;</span><br><span class="line">       4) &quot;10&quot;</span><br><span class="line">13) &quot;last-entry&quot;</span><br><span class="line">14) 1) &quot;1580959606181-0&quot;</span><br><span class="line">    2) 1) &quot;name&quot;</span><br><span class="line">       2) &quot;java&quot;</span><br><span class="line">       3) &quot;age&quot;</span><br><span class="line">       4) &quot;20&quot;</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinfo stream stream-<span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 查询消费组消息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo groups mq</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;group1&quot; #消息分组名称</span><br><span class="line">   3) &quot;consumers&quot;</span><br><span class="line">   4) (integer) 1 #一个消费者客户端</span><br><span class="line">   5) &quot;pending&quot;</span><br><span class="line">   6) (integer) 1 #一个未确认消息</span><br><span class="line">   7) &quot;last-delivered-id&quot;</span><br><span class="line">   8) &quot;1580959593553-0&quot; #读取的最后一条消息 ID</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinfo <span class="built_in">groups</span> stream-key</span><br></pre></td></tr></table></figure>
<p><strong>3. 查看消费者组成员信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo consumers mq group1</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;c1&quot; #消费者名称</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 0 #未确认消息</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 481855</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinfo consumers stream <span class="keyword">group</span>-<span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h4 id="删除消费者"><strong>删除消费者</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup delconsumer mq group1 c1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgroup delconsumer stream-<span class="keyword">key</span> <span class="keyword">group</span>-<span class="keyword">key</span> consumer-<span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h4 id="删除消费组"><strong>删除消费组</strong></h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup destroy mq group1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>相关语法：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgroup destroy stream-<span class="keyword">key</span> <span class="keyword">group</span>-<span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h3 id="代码实战-6">代码实战</h3>
<p>接下来我们使用 Jedis 来实现 Stream 分组消息队列，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamGroupExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq&quot;</span>; <span class="comment">// 流 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;g1&quot;</span>; <span class="comment">// 分组名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_CONSUMER_NAME</span> <span class="operator">=</span> <span class="string">&quot;c1&quot;</span>; <span class="comment">// 消费者 1 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_CONSUMER2_NAME</span> <span class="operator">=</span> <span class="string">&quot;c2&quot;</span>; <span class="comment">// 消费者 2 的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">        <span class="comment">// 创建消费组</span></span><br><span class="line">        createGroup(_STREAM_KEY, _GROUP_NAME);</span><br><span class="line">        <span class="comment">// 消费者 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 消费者 2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer2()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建消费分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stream    流 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 分组名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createGroup</span><span class="params">(String stream, String groupName)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        jedis.xgroupCreate(stream, groupName, <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 添加消息 1</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id</span> <span class="operator">=</span> jedis.xadd(_STREAM_KEY, <span class="literal">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">        <span class="comment">// 添加消息 2</span></span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id2</span> <span class="operator">=</span> jedis.xadd(_STREAM_KEY, <span class="literal">null</span>, map2);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="literal">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 1 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER2_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="literal">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 2 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息添加成功 ID：1580971482344-0</span><br><span class="line">消息添加成功 ID：1580971482415-0</span><br><span class="line">Consumer 1 读取到消息 ID：1580971482344-0 内容：&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;redis&quot;</span>&#125;</span><br><span class="line">Consumer 2 读取到消息 ID：1580971482415-0 内容：&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;java&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中，jedis.xreadGroup() 方法的第五个参数 noAck 表示是否自动确认消息，如果设置 true 收到消息会自动确认（ack）消息，否则则需要手动确认。</p>
<blockquote>
<p>注意：Jedis 框架要使用最新版，低版本 block 设置大于 0 时，会有 bug 抛连接超时异常。</p>
</blockquote>
<p>可以看出，同一个分组内的多个 consumer 会读取到不同消息，不同的 consumer 不会读取到分组内的同一条消息。</p>
<h3 id="小结-13">小结</h3>
<p>本文我们介绍了 Stream 分组的相关知识，使用 Jedis 的 xreadGroup() 方法实现了消息的阻塞读取，并且使用此方法自带 noAck 参数，实现了消息的自动确认，通过本文我们也知道了，一个分组内的多个 consumer 会轮询收到消息队列的消息，并且不会出现一个消息被多个 consumer 读取的情况。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Redis核心原理</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/21acb7cf.html">https://penge666.github.io/posts/21acb7cf.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-03-28</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-06-04</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Redis</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>数据库</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1bd023c5.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_136.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis实战</div></div></a></div><div class="next-post pull-right"><a href="/posts/a97adce4.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_4.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Feed流</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1bd023c5.html" title="Redis实战"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_136.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-06-04</div><div class="title">Redis实战</div></div></a></div><div><a href="/posts/51d1b1e7.html" title="Redis学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-25</div><div class="title">Redis学习笔记</div></div></a></div><div><a href="/posts/1cc56f91.html" title="redis练手[easy]"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_91.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-06-04</div><div class="title">redis练手[easy]</div></div></a></div><div><a href="/posts/69dcf386.html" title="Memcached笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_17.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-27</div><div class="title">Memcached笔记</div></div></a></div><div><a href="/posts/b5f22718.html" title="LSM-Tree"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-28</div><div class="title">LSM-Tree</div></div></a></div><div><a href="/posts/5f51f1dd.html" title="聊聊MVCC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_72.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-06-02</div><div class="title">聊聊MVCC</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">01 Redis 是如何执行的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">命令执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Redis-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">02 Redis 快速搭建与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E2%80%94%E2%80%94RDB"><span class="toc-text">03 Redis 持久化——RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1 持久化的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RDB%E7%AE%80%E4%BB%8B"><span class="toc-text">2 RDB简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%81%E4%B9%85%E5%8C%96%E8%A7%A6%E5%8F%91"><span class="toc-text">3 持久化触发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">1）手动触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-save-%E5%91%BD%E4%BB%A4"><span class="toc-text">① save 命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-bgsave-%E5%91%BD%E4%BB%A4"><span class="toc-text">② bgsave 命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">2）自动触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-save-m-n"><span class="toc-text">① save m n</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-flushall"><span class="toc-text">② flushall</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E8%A7%A6%E5%8F%91"><span class="toc-text">③ 主从同步触发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">4 配置说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%85%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2"><span class="toc-text">5 配置查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">6 配置设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-RDB-%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D"><span class="toc-text">7 RDB 文件恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-RDB-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">8 RDB 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89RDB-%E4%BC%98%E7%82%B9"><span class="toc-text">1）RDB 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89RDB-%E7%BC%BA%E7%82%B9"><span class="toc-text">2）RDB 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%A6%81%E7%94%A8%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">9 禁用持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B0%8F%E7%BB%93"><span class="toc-text">10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E2%80%94%E2%80%94AOF"><span class="toc-text">04 Redis 持久化——AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%AE%BE%E7%BD%AE"><span class="toc-text">2 持久化查询和设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%9F%A5%E8%AF%A2-AOF-%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81"><span class="toc-text">1）查询 AOF 启动状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%BC%80%E5%90%AF-AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2）开启 AOF 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8-AOF"><span class="toc-text">① 命令行启动 AOF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8-AOF"><span class="toc-text">② 配置文件启动 AOF</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%A6%E5%8F%91%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3 触发持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">1）自动触发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">2）手动触发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AOF-%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99"><span class="toc-text">4 AOF 文件重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF-AOF-%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-text">1）什么是 AOF 重写？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89AOF-%E9%87%8D%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-text">2）AOF 重写实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89AOF-%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-text">3）AOF 重写流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">5 配置说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">6 数据恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%AD%A3%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">1）正常数据恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%AE%80%E5%8D%95%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">2）简单异常数据恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%A4%8D%E6%9D%82%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">3）复杂异常数据恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">7 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E4%BC%98%E7%82%B9"><span class="toc-text">AOF 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E7%BC%BA%E7%82%B9"><span class="toc-text">AOF 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B0%8F%E7%BB%93"><span class="toc-text">8 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E2%80%94%E2%80%94%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">05 Redis 持久化——混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AF%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">1 开启混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AF"><span class="toc-text">1）通过命令行开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9-Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BC%80%E5%90%AF"><span class="toc-text">2）通过修改 Redis 配置文件开启</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">2 实例运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">3 数据恢复和源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">1）混合持久化的加载流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4 优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">5 持久化最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%8E%A7%E5%88%B6%E6%8C%81%E4%B9%85%E5%8C%96%E5%BC%80%E5%85%B3"><span class="toc-text">1）控制持久化开关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BB%E4%BB%8E%E9%83%A8%E7%BD%B2"><span class="toc-text">2）主从部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%BD%BF%E7%94%A8%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3）使用混合持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%9B%B4%E9%AB%98%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="toc-text">4）使用配置更高的机器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">06 字符串使用与内部实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1 字符串类型能做什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98"><span class="toc-text">1）页面数据缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%BB%9F%E8%AE%A1"><span class="toc-text">2）数字计算与统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%85%B1%E4%BA%AB-Session-%E4%BF%A1%E6%81%AF"><span class="toc-text">3）共享 Session 信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">2 字符串如何使用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">1）命令行操作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%8D%95%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">① 单个键值对操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">a.添加键值对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E8%8E%B7%E5%8F%96%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">b.获取键值对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#c-%E7%BB%99%E5%85%83%E7%B4%A0%E8%BF%BD%E5%8A%A0%E5%80%BC"><span class="toc-text">c.给元素追加值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#d-%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">d.查询字符串的长度</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">② 多个键值对操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">a.创建一个或多个键值对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">b.查询一个或多个元素</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E6%95%B0%E5%AD%97%E7%BB%9F%E8%AE%A1"><span class="toc-text">③ 数字统计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E7%BB%99%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%8A%A0-1"><span class="toc-text">a.给整数类型的值加 1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E7%BB%99%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%87%8F-1"><span class="toc-text">b.给整数类型的值减 1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#c-%E6%A0%B9%E6%8D%AE-key-%E5%87%8F%E5%8E%BB%E6%8C%87%E5%AE%9A%E7%9A%84%E5%80%BC"><span class="toc-text">c.根据 key 减去指定的值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#d-%E6%A0%B9%E6%8D%AE-key-%E5%8A%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%BC"><span class="toc-text">d.根据 key 加指定的整数值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e-%E6%A0%B9%E6%8D%AE-key-%E5%8A%A0%E4%B8%8A%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">e.根据 key 加上指定的浮点数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">2）代码操作方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">3 代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">4 字符串的内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1）源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2）数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-int-%E7%B1%BB%E5%9E%8B"><span class="toc-text">① int 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-embstr-%E7%B1%BB%E5%9E%8B"><span class="toc-text">② embstr 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-raw-%E7%B1%BB%E5%9E%8B"><span class="toc-text">③ raw 类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-44-%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">3）为什么是 44 字节？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93"><span class="toc-text">5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-%E9%99%84%E5%BD%95%EF%BC%9A%E6%9B%B4%E5%A4%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">07 附录：更多字符串操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">键值对过期操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">a.添加键值对并设置过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E8%B5%8B%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-%E5%8D%95%E4%BD%8D-%E7%A7%92"><span class="toc-text">b.赋值字符串，并设置过期时间(单位&#x2F;秒)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%B5%8B%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-%E5%8D%95%E4%BD%8D-%E6%AF%AB%E7%A7%92"><span class="toc-text">c.赋值字符串，并设置过期时间(单位&#x2F;毫秒)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E8%BF%9B%E9%98%B6"><span class="toc-text">字符串操作进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">a.根据指定的范围截取字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B0%E5%80%BC%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%97%A7%E5%80%BC"><span class="toc-text">b.设置字符串新值并返回旧值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%B5%8B%E5%80%BC-%E5%88%9B%E5%BB%BA-%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%BD%93-key-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6"><span class="toc-text">c.赋值(创建)键值对，当 key 不存在时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%EF%BC%8C%E5%BD%93%E6%89%80%E6%9C%89%E9%94%AE%E5%80%BC%E9%83%BD%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6"><span class="toc-text">d.设置一个或多个键值，当所有键值都不存在时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E8%B5%8B%E5%80%BC"><span class="toc-text">e.截取字符串并赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">08 字典使用与内部实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">1.基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%8F%92%E5%85%A5%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1）插入单个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%BD%93%E6%9F%90%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%EF%BC%8C%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">2）当某键不存在时，插入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">3）查询单个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%88%A0%E9%99%A4-key-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">4）删除 key 中的一个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E6%9F%90%E4%B8%AA%E6%95%B4%E6%95%B0%E5%80%BC%E7%B4%AF%E5%8A%A0%E8%AE%A1%E7%AE%97"><span class="toc-text">5）某个整数值累加计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">2.代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3.数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-text">4.哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-text">5.渐进式rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%89%A9%E5%AE%B9"><span class="toc-text">1）扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%BC%A9%E5%AE%B9"><span class="toc-text">2）缩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%B5%81%E7%A8%8B"><span class="toc-text">3）渐进式rehash流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6.使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B0%8F%E7%BB%93"><span class="toc-text">7.小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-%E9%99%84%E5%BD%95%EF%BC%9A%E6%9B%B4%E5%A4%9A%E5%AD%97%E5%85%B8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">09 附录：更多字典操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">插入一个或多个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">查询一个或多个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA-key-%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5"><span class="toc-text">查询某个 key 的所有字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA-key-%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC"><span class="toc-text">查询某个 key 的所有值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA-key-%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E5%80%BC"><span class="toc-text">查询某个 key 的所有字段和值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E6%B5%AE%E7%82%B9%E5%80%BC%E7%B4%AF%E5%8A%A0%E8%AE%A1%E7%AE%97"><span class="toc-text">某个浮点值累加计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">查询元素是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-text">查询元素个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%88%97%E8%A1%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">10 列表使用与内部实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-2"><span class="toc-text">1 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E7%BB%99%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1）给列表添加一个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%BB%99%E5%88%97%E8%A1%A8%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">2）给列表尾部添加一个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">3）返回列表指定区间内的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">4）获取并删除列表的第一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">5）获取并删除列表的最后一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%89%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">6）根据下标获取对应的元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-2"><span class="toc-text">2 代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">3 内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">4 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1）添加功能源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2）删除功能源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-text">① 单一元素删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8C%BA%E9%97%B4%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-text">② 区间元素删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%9B%B4%E5%A4%9A%E6%BA%90%E7%A0%81"><span class="toc-text">3）更多源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B0%8F%E7%BB%93"><span class="toc-text">6 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E9%99%84%E5%BD%95%EF%BC%9A%E6%9B%B4%E5%A4%9A%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">11 附录：更多列表操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9F%90%E5%80%BC%E4%B9%8B%E5%89%8D-%E4%B9%8B%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">在某值之前&#x2F;之后添加某个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0"><span class="toc-text">根据下标修改元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">根据下标删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%97%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">查询列表的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">删除指定个数的元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">12 集合使用与内部实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-3"><span class="toc-text">1 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1）添加一个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="toc-text">2）查询集合所有元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E7%9A%84%E6%88%90%E5%91%98%E6%95%B0%E9%87%8F"><span class="toc-text">3）查询集合的成员数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">4）查询集合中是否包含某个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%AD%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88"><span class="toc-text">5）从一个集合中移动一个元素到另一个集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%89%E7%A7%BB%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">6）移除集合中一个或多个元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-3"><span class="toc-text">2 代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">3 内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2"><span class="toc-text">4 源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-text">5 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B0%8F%E7%BB%93-2"><span class="toc-text">6 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%99%84%E5%BD%95%EF%BC%9A%E6%9B%B4%E5%A4%9A%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">13 附录：更多集合操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%B9%B6%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="toc-text">移除并返回集合中的一个随机元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8"><span class="toc-text">随机返回集合中指定数量的元素列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">返回一个集合或多个集合的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86%E5%A4%8D%E5%88%B6%E5%88%B0%E6%96%B0%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-text">把集合的交集复制到新的集合中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86"><span class="toc-text">查询一个或多个集合的并集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86%E5%A4%8D%E5%88%B6%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-text">把一个或多个集合的并集复制到新集合中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E9%94%99%E9%9B%86"><span class="toc-text">查询一个或多个集合的错集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E9%94%99%E9%9B%86%E5%A4%8D%E5%88%B6%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88"><span class="toc-text">把一个或多个集合的错集复制到新集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">14 有序集合使用与内部实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-4"><span class="toc-text">1 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0-2"><span class="toc-text">1）添加一个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8"><span class="toc-text">2）查询所有元素列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0-%E6%A0%B9%E6%8D%AE%E5%85%83%E7%B4%A0%E5%80%BC"><span class="toc-text">3）删除一个或多个元素(根据元素值)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84-score-%E5%80%BC"><span class="toc-text">4）查询某元素的 score 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E6%9F%A5%E8%AF%A2-score-%E5%8C%BA%E9%97%B4%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-text">5）查询 score 区间内元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%85%83%E7%B4%A0%E6%8E%92%E5%90%8D"><span class="toc-text">6）查询某元素排名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-4"><span class="toc-text">2 代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">3 内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89ziplist"><span class="toc-text">1）ziplist</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89skiplist"><span class="toc-text">2）skiplist</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">① 跳跃表实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%9F%E8%80%8C%E9%9D%9E%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-text">② 为什么是跳跃表？而非红黑树？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-2"><span class="toc-text">5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E9%99%84%E5%BD%95%EF%BC%9A%E6%9B%B4%E5%A4%9A%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">15 附录：更多有序集合操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E6%80%BB%E4%B8%AA%E6%95%B0"><span class="toc-text">查询有序集合的总个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-score-%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-text">查询 score 区间内的元素个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84-score-%E5%80%BC"><span class="toc-text">累加元素的 score 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%85%83%E7%B4%A0%E5%80%92%E5%BA%8F%E6%8E%92%E5%90%8D"><span class="toc-text">查询某元素倒序排名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">根据排名删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-score-%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">删除 score 区间内的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%A4%E9%9B%86%E5%85%83%E7%B4%A0%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88"><span class="toc-text">复制交集元素到新集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%B9%B6%E9%9B%86%E5%85%83%E7%B4%A0%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88"><span class="toc-text">复制并集元素到新集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Redis-%E4%BA%8B%E5%8A%A1%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-text">16 Redis 事务深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">事务基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">开启事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%85%A5%E5%88%97"><span class="toc-text">命令入列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1-%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-text">执行事务&#x2F;放弃事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%94%99%E8%AF%AF-%E5%9B%9E%E6%BB%9A"><span class="toc-text">事务错误&amp;回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF"><span class="toc-text">执行时错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F"><span class="toc-text">入列错误不会导致事务结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F"><span class="toc-text">入列错误导致事务结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-text">为什么不支持事务回滚？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7"><span class="toc-text">监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BB%83%E4%B9%A0"><span class="toc-text">知识点练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E4%B8%A4%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9F"><span class="toc-text">以下两个客户端交替执行的结果是？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Redis-%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">17 Redis 键值过期操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E8%AE%BE%E7%BD%AE"><span class="toc-text">过期设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#expire%EF%BC%9AN-%E7%A7%92%E5%90%8E%E8%BF%87%E6%9C%9F"><span class="toc-text">expire：N 秒后过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pexpire%EF%BC%9AN-%E6%AF%AB%E7%A7%92%E5%90%8E%E8%BF%87%E6%9C%9F"><span class="toc-text">pexpire：N 毫秒后过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expireat%EF%BC%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E7%A1%AE%E5%88%B0%E7%A7%92"><span class="toc-text">expireat：过期时间戳精确到秒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pexpireat%EF%BC%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E7%A1%AE%E5%88%B0%E6%AF%AB%E7%A7%92"><span class="toc-text">pexpireat：过期时间戳精确到毫秒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">字符串中的过期操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">移除过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">Java实现过期操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">持久化中的过期键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">RDB 中的过期键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">AOF 中的过期键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">主从库的过期键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">18 Redis 过期策略与源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">过期键执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">过期键源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-text">定期删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">Redis 使用的过期策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Redis-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Pipeline"><span class="toc-text">19 Redis 管道技术——Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">管道技术解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8"><span class="toc-text">管道技术使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF-VS-%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4"><span class="toc-text">管道技术 VS 普通命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-text">管道技术需要注意的事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9F%A5%E8%AF%A2%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E2%80%94%E2%80%94GEO"><span class="toc-text">20 查询附近的人——GEO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-text">添加地理位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-text">查询位置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E7%BB%9F%E8%AE%A1"><span class="toc-text">距离统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%BD%8D%E7%BD%AE%E5%86%85%E7%9A%84%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98%E4%BF%A1%E6%81%AF"><span class="toc-text">查询某位置内的其他成员信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-2"><span class="toc-text">代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%B8%B8%E6%A0%87%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89%E2%80%94%E2%80%94Scan"><span class="toc-text">21 游标迭代器（过滤器）——Scan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E3%80%8C%E8%A1%80%E6%A1%88%E3%80%8D"><span class="toc-text">一个问题引发的「血案」</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">问题的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scan-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="toc-text">Scan 命令使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-3"><span class="toc-text">代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scan-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">Scan 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HScan-%E4%BD%BF%E7%94%A8"><span class="toc-text">HScan 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SScan-%E4%BD%BF%E7%94%A8"><span class="toc-text">SScan 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZScan-%E4%BD%BF%E7%94%A8"><span class="toc-text">ZScan 使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scan-%E8%AF%B4%E6%98%8E"><span class="toc-text">Scan 说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scan-guarantees"><span class="toc-text">Scan guarantees</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%BC%98%E7%A7%80%E7%9A%84%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94HyperLogLog"><span class="toc-text">22 优秀的基数统计算法——HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-HyperLogLog%EF%BC%9F"><span class="toc-text">为什么要使用 HyperLogLog？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog-%E4%BB%8B%E7%BB%8D"><span class="toc-text">HyperLogLog 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-2"><span class="toc-text">基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">统计不重复的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA-HLL-%E8%87%B3%E6%96%B0%E7%BB%93%E6%9E%84"><span class="toc-text">合并一个或多个 HLL 至新结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-4"><span class="toc-text">代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HLL-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">HLL 算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-text">23 内存淘汰机制与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%80%E5%A4%A7%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98"><span class="toc-text">Redis 最大运行内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%A4%A7%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98"><span class="toc-text">查询最大运行内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">查看 Redis 内存淘汰策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%88%86%E7%B1%BB"><span class="toc-text">内存淘汰策略分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">修改 Redis 内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-text">内存淘汰算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">LRU 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LFU-%E7%AE%97%E6%B3%95"><span class="toc-text">LFU 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">24 消息队列——发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-text">普通订阅与发布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF"><span class="toc-text">订阅消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">发送消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98%E8%AE%A2%E9%98%85"><span class="toc-text">主题订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-5"><span class="toc-text">代码实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F"><span class="toc-text">普通模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">主题订阅模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-10"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">25 消息队列的其他实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E7%89%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">List 版消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZSet-%E7%89%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">ZSet 版消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-2"><span class="toc-text">优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-11"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94Stream%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">26 消息队列终极解决方案——Stream（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-3"><span class="toc-text">基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B6%88%E6%81%AF"><span class="toc-text">添加消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">查询消息的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF"><span class="toc-text">删除消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B4%E4%B8%AA-Stream"><span class="toc-text">删除整个 Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E6%B6%88%E6%81%AF"><span class="toc-text">查询区间消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%B6%88%E6%81%AF%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-text">查询某个消息之后的消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">基础版消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-12"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94Stream%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">27 消息队列终极解决方案——Stream（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E7%BB%84%E5%91%BD%E4%BB%A4"><span class="toc-text">消息分组命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4%E7%BB%84"><span class="toc-text">创建消费者群组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B6%88%E6%81%AF"><span class="toc-text">读取消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%A1%AE%E8%AE%A4"><span class="toc-text">消息消费确认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%AA%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97"><span class="toc-text">查询未确认的消费队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xinfo-%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">xinfo 查询相关命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">删除消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B6%88%E8%B4%B9%E7%BB%84"><span class="toc-text">删除消费组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-6"><span class="toc-text">代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-13"><span class="toc-text">小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/分布式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Kevinの分布式学习笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 Kevinの操作系统笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (23)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Redis/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>