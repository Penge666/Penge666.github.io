<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>现代C++实战30讲 | Penge666</title><meta name="keywords" content="Cpp,读书笔记"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="《现代C++实战30讲》">
<meta property="og:type" content="article">
<meta property="og:title" content="现代C++实战30讲">
<meta property="og:url" content="https://penge666.github.io/posts/ab4dcc4b.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="《现代C++实战30讲》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_82.webp">
<meta property="article:published_time" content="2024-04-06T13:37:45.000Z">
<meta property="article:modified_time" content="2024-07-01T14:39:38.143Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_82.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/ab4dcc4b"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '现代C++实战30讲',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-01 22:39:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">现代C++实战30讲</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-04-06T13:37:45.000Z" title="发表于 2024-04-06 21:37:45">2024-04-06</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-01T14:39:38.143Z" title="更新于 2024-07-01 22:39:38">2024-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a><i class="fas fa-angle-right post-meta-separator"></i><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/Cpp/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>269分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="现代C++实战30讲"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="01丨基础篇">01丨基础篇</h2>
<h3 id="01-堆、栈、RAII：C-里该如何管理资源？">01 | 堆、栈、RAII：C++里该如何管理资源？</h3>
<h4 id="1-1-基本概念">1.1 基本概念</h4>
<p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。</p>
<p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<ul>
<li>new 和 delete 操作的区域是 free store</li>
<li>malloc 和 free 操作的区域是 heap</li>
</ul>
<p>但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，在本专栏里，除非另有特殊说明，我会只使用堆这一术语。</p>
<p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足”后进先出”（last-in-first-out 或 LIFO）。</p>
<p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p>
<h4 id="1-2-堆">1.2 堆</h4>
<h4 id="1-3-栈">1.3 栈</h4>
<p>编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。</p>
<h4 id="1-4-RAII">1.4 RAII</h4>
<h4 id="1-5-参考资料">1.5 参考资料</h4>
<ol>
<li>Wikipedia, “Memory management”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_management">https://en.wikipedia.org/wiki/Memory_management</a></li>
<li>Wikipedia, “Stack-based memory allocation”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation">https://en.wikipedia.org/wiki/Stack-based_memory_allocation</a></li>
<li>Wikipedia, “Resource acquisition is initialization”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RAII">https://en.wikipedia.org/wiki/RAII</a></li>
<li>Wikipedia, “Call stack”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">https://en.wikipedia.org/wiki/Call_stack</a></li>
<li>Wikipedia, “Object slicing”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_slicing">https://en.wikipedia.org/wiki/Object_slicing</a></li>
<li>Stack Overflow, “Why does the stack address grow towards decreasing memory addresses?” <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4560720/why-doesthe-stack-address-grow-towards-decreasing-memory-addresses">https://stackoverflow.com/questions/4560720/why-doesthe-stack-address-grow-towards-decreasing-memory-addresses</a></li>
</ol>
<h3 id="02-自己动手，实现C-的智能指针">02 | 自己动手，实现C++的智能指针</h3>
<h4 id="2-1-回顾">2.1 回顾</h4>
<p>上一讲给出了下面这个类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : ptr_(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">shape_wrapper</span>() &#123; <span class="keyword">delete</span> ptr_; &#125;</span><br><span class="line">    <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shape* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西：</p>
<ol>
<li>这个类只适用于 shape 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为异常</li>
</ol>
<p>下面我们来逐一看一下怎么弥补这些问题。</p>
<h4 id="2-2-模板化和易用性">2.2 模板化和易用性</h4>
<p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : ptr_(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="function">smart_ptr&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line">    *q = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-拷贝构造和赋值">2.3 拷贝构造和赋值</h4>
<p>试试在拷贝时转移指针的所有权？大致实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">smart_ptr</span>(rhs).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T* ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在拷贝构造函数中，通过调用 other 的 release 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 swap 来交换对指针的所有权。实现上是不复杂的。</p>
<p>如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。</p>
<p>目前这种惯用法（见参考资料 [1]）则保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p>
<p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……</p>
<h4 id="2-4-“移动”指针？">2.4 “移动”指针？</h4>
<p>在下一讲我们将完整介绍一下移动语义。这一讲，我们先简单看一下 smart_ptr 可以如何使用”移动”来改善其行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改了两个地方：</p>
<ul>
<li>把拷贝构造函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr&amp;&amp;；现在它成了移动构造函数。</li>
<li>把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</li>
</ul>
<p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用（记住，C++ 里那些复杂的规则也是为方便编程而设立的）。于是，我们自然地得到了以下结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">smart_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; <span class="comment">// 编译出错</span></span><br><span class="line">smart_ptr&lt;shape&gt; ptr3;</span><br><span class="line">ptr3 = ptr1; <span class="comment">// 编译出错</span></span><br><span class="line">ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// OK，可以</span></span><br><span class="line">smart_ptr&lt;shape&gt; ptr4&#123;std::<span class="built_in">move</span>(ptr3)&#125;; <span class="comment">// OK，可以</span></span><br></pre></td></tr></table></figure>
<p>这也是 C++11 的 unique_ptr 的基本行为。</p>
<p>补充上述内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;explicit smart_ptr\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123; <span class="keyword">delete</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr &amp;<span class="keyword">operator</span>=(smart_ptr rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr &amp;other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">swap</span>(ptr_, other.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *temp = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">smart_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">smart_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拷贝赋值操作</span></span><br><span class="line">    sp1 = sp2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用移动赋值操作</span></span><br><span class="line">    sp1 = std::<span class="built_in">move</span>(sp2);</span><br><span class="line">    cout &lt;&lt; sp2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语句1：<code>sp1 = sp2;</code></p>
<p>这条语句在上面的代码是存在问题的。因为sp2需要赋值变量给<code> smart_ptr &amp;operator=(smart_ptr rhs)</code>函数中的参数，由于需要拷贝构造到内存一份副本，但是上述类并未有拷贝构造，所以报错。</p>
<p>解决方法：</p>
<ol>
<li>添加<code>smart_ptr(smart_ptr &amp;other)</code>函数</li>
<li>添加<code>smart_ptr &amp;operator=(smart_ptr &amp;rhs)</code>函数</li>
</ol>
<p>语句2：<code> sp1 = std::move(sp2);</code></p>
<p>因为需要传参，传参就需要拷贝，就会创建一份对象副本。所以先会调用移动构造创建一个对象，在进行对象的赋值。</p>
<h4 id="2-5-子类指针向基类指针的转换">2.5 子类指针向基类指针的转换</h4>
<p>不知道你注意到没有，一个 <code>circle*</code> 是可以隐式转换成 <code>shape*</code> 的，但上面的 <code>smart_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。</p>
<p>只需要修改我们的移动构造函数一处即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给 <code>smart_ptr&lt;shape&gt;</code>，但不能移动给 <code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p>
<p>至于非隐式的转换，因为本来就是要写特殊的转换函数的，我们留到这一讲的最后再讨论。</p>
<h4 id="2-6-引用计数">2.6 引用计数</h4>
<p>unique_ptr 和 shared_ptr 的主要区别如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629223526282.png" alt="image-20240629223526282"></p>
<p>先来写出共享计数的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_count</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_count</span>()</span><br><span class="line">        : <span class="built_in">count_</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++count_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : ptr_(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_ &amp;&amp; !shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">    shared_count* shared_count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便实现赋值（及其他一些惯用法），我们需要一个新的 swap 成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    <span class="built_in">swap</span>(shared_count_, rhs.shared_count_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">        other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p>
<blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="string">&#x27;ptr_&#x27;</span> <span class="keyword">is</span> a <span class="keyword">private</span> member of <span class="string">&#x27;smart_ptr&lt;circle&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 <code>ptr_</code> 和 <code>shared_count_</code>。我们需要在 smart_ptr 的定义中显式声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">smart_ptr</span>;</span><br></pre></td></tr></table></figure>
<p>此外，我们之前的实现（类似于单一所有权的 unique_ptr ）中用 release 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-指针类型转换">2.7 指针类型转换</h4>
<p>对应于 C++ 里的不同的类型强制转换：</p>
<ul>
<li>static_cast</li>
<li>reinterpret_cast</li>
<li>const_cast</li>
<li>dynamic_cast</li>
</ul>
<p>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other, T* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = ptr;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以实现转换所需的函数模板了。下面实现一个 dynamic_pointer_cast 来示例一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smart_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* ptr = <span class="built_in">dynamic_cast</span>&lt;T*&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smart_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-8-代码列表">2.8 代码列表</h4>
<p>完整的 smart_ptr 代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_count</span>() <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">count_</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++count_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">smart_ptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : ptr_(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~smart_ptr(): %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr_ &amp;&amp; !shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">            other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other, T* ptr) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = ptr;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr rhs) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr&amp; rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">        <span class="built_in">swap</span>(shared_count_, rhs.shared_count_);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">    shared_count* shared_count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr&lt;T&gt;&amp; lhs, smart_ptr&lt;T&gt;&amp; rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smart_ptr&lt;T&gt; <span class="title">static_pointer_cast</span><span class="params">(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* ptr = <span class="built_in">static_cast</span>&lt;T*&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smart_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smart_ptr&lt;T&gt; <span class="title">reinterpret_pointer_cast</span><span class="params">(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* ptr = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smart_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smart_ptr&lt;T&gt; <span class="title">const_pointer_cast</span><span class="params">(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* ptr = <span class="built_in">const_cast</span>&lt;T*&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smart_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smart_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* ptr = <span class="built_in">dynamic_cast</span>&lt;T*&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smart_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你足够细心的话，你会发现我在代码里加了不少 noexcept。这对这个智能指针在它的目标场景能正确使用是十分必要的。</p>
<h4 id="2-9-参考资料">2.9 参考资料</h4>
<ol>
<li>Stack Overflow, GManNickG’s answer to “What is the copy-and-swapidiom?”. <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/3279550/816999">https://stackoverflow.com/a/3279550/816999</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::shared_ptr”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/shared_ptr">https://en.cppreference.com/w/cpp/memory/shared_ptr</a></li>
</ol>
<h3 id="03-右值和移动究竟解决了什么问题？">03 | 右值和移动究竟解决了什么问题？</h3>
<p>移动语义是 C++11 里引入的一个重要概念；理解这个概念，是理解很多现代 C++ 里的优化的基础。</p>
<h4 id="3-1-值分左右">3.1 值分左右</h4>
<p>C++标准里规定了下面这些值类别（value categories）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629225559111.png" alt="image-20240629225559111"></p>
<p>先理解一下这些名词的字面含义：</p>
<ul>
<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>
<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>
<li>一个 glvalue 是 generalized lvalue，广义左值</li>
<li>一个 xvalue 是 expiring lvalue，将亡值</li>
<li>一个 prvalue 是 pure rvalue，纯右值</li>
</ul>
<p>暂且抛开这些概念，只看其中两个：lvalue 和 prvalue。</p>
<p>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</p>
<ul>
<li>变量、函数或数据成员的名字</li>
<li>返回左值引用的表达式，如 ++x、x = 1、cout &lt;&lt; ‘ ‘</li>
<li>字符串字面量如 “hello world”</li>
</ul>
<p>在函数调用时，左值可以绑定到左值引用的参数，如 T&amp;。一个常量只能绑定到常左值引用，如 const T&amp;。</p>
<p>反之，纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称之为”临时对象”。最常见的情况有：</p>
<ul>
<li>返回非引用类型的表达式，如 x++、x + 1、<code>make_shared&lt;int&gt;(42)</code></li>
<li>除字符串字面量之外的字面量，如 42、true</li>
</ul>
<p>在 C++11 之前，右值可以绑定到常左值引用（const lvalue reference）的参数，如 const T&amp;，但不可以绑定到非常左值引用（non-const lvalue reference），如 T&amp;。从 C++11 开始，C++ 语言里多了一种引用类型——右值引用。右值引用的形式是 T&amp;&amp;，比左值引用多一个 &amp; 符号。跟左值引用一样，我们可以使用 const 和 volatile 来进行修饰，但最常见的情况是，我们不会用 const 和 volatile 来修饰右值。本专栏就属于这种情况。</p>
<p>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能性。由于 C++ 有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。回想一下，在上一讲中，我们就利用了重载，让 smart_ptr 的构造函数可以有不同的行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">        other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用右值引用的第二个重载函数中的变量 other 算是左值还是右值呢？根据定义，other 是个变量的名字，变量有标识符、有地址，所以它还是一个左值——虽然它的类型是右值引用。</p>
<p>尤其重要的是，拿这个 other 去调用函数时，它匹配的也会是左值引用。也就是说，**类型是右值引用的变量是一个左值！**这点可能有点反直觉，但跟 C++ 的其他方面是一致的。毕竟对于一个右值引用的变量，你是可以取地址的，这点上它和左值完全一致。稍后我们再回到这个话题上来。</p>
<p>再看一下下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smart_ptr&lt;shape&gt; ptr1&#123;<span class="keyword">new</span> <span class="built_in">circle</span>()&#125;;</span><br><span class="line">smart_ptr&lt;shape&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure>
<p>第一个表达式里的 new circle() 就是一个纯右值；但对于指针，我们通常使用值传递，并不关心它是左值还是右值。</p>
<p>第二个表达式里的 std::move(ptr) 就有趣点了。它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在我们这儿 std::move(ptr1) 等价于 <code>static_cast&lt;smart_ptr&lt;shape&gt;&amp;&amp;&gt;(ptr1)</code>。因此，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用，这样构造 ptr2 时就会选择上面第二个重载。</p>
<p>我们可以把 std::move(ptr1) 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue。我们用下面的图来表示会更清楚一点：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240629225630474.png" alt="image-20240629225630474"></p>
<p>另外请注意，”值类别”（value category）和”值类型”（value type）是两个看似相似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在 C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&amp;）和指针（*）才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在 Python 里，一切类型都是引用类型。</p>
<h4 id="3-2-生命周期和表达式类型">3.2 生命周期和表达式类型</h4>
<p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢？在这儿，C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。我们先看一个没有生命周期延长的基本情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;circle()&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~circle()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">triangle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;triangle()&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">triangle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~triangle()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">result</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">result</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;result()&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">result</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~result()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">result <span class="title">process_shape</span><span class="params">(<span class="type">const</span> shape&amp; shape1, <span class="type">const</span> shape&amp; shape2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;process_shape()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">result</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;main()&quot;</span>);</span><br><span class="line">    <span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>());</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;something else&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果可能会是（circle 和 triangle 的顺序在标准中没有规定）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">circle()</span><br><span class="line">triangle()</span><br><span class="line">process_shape()</span><br><span class="line">result()</span><br><span class="line">~result()</span><br><span class="line">~triangle()</span><br><span class="line">~circle()</span><br><span class="line">something else</span><br></pre></td></tr></table></figure>
<p>目前我让 process_shape 也返回了一个结果，这是为了下一步演示的需要。你可以看到结果的临时对象最后生成、最先析构。</p>
<p>为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：</p>
<blockquote>
<p>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。</p>
</blockquote>
<p>我们对上面的代码只要改一行就能演示这个效果。把 process_shape 那行改成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result&amp;&amp; r = <span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>());</span><br></pre></td></tr></table></figure>
<p>我们就能看到不同的结果了：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">circle()</span><br><span class="line">triangle()</span><br><span class="line">process_shape()</span><br><span class="line">result()</span><br><span class="line">~triangle()</span><br><span class="line">~circle()</span><br><span class="line">something else</span><br><span class="line">~result()</span><br></pre></td></tr></table></figure>
<p>现在 result 的生成还在原来的位置，但析构被延到了 main 的最后。</p>
<p>需要万分注意的是，这条生命期延长规则只对 prvalue 有效，而对 xvalue 无效。如果由于某种原因，prvalue 在绑定到引用以前已经变成了 xvalue，那生命期就不会延长。不注意这点的话，代码就可能会产生隐秘的 bug。比如，我们如果这样改一下代码，结果就不对了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line">…</span><br><span class="line">result&amp;&amp; r = std::<span class="built_in">move</span>(<span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>()));</span><br></pre></td></tr></table></figure>
<p>这时的代码输出就回到了前一种情况。虽然执行到 something else 那儿我们仍然有一个有效的变量 r，但它指向的对象已经不存在了，对 r 的解引用是一个未定义行为。由于 r 指向的是栈空间，通常不会立即导致程序崩溃，而会在某些复杂的组合条件下才会引致问题……</p>
<p>对 C++ 的这条生命期延长规则，在后面讲到视图（view）的时候会十分有用。那时我们会看到，有些 C++ 的用法实际上会隐式地利用这条规则。</p>
<p>此外，参考资料 [5] 中提到了一个有趣的事实：你可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响</p>
<p>同样的例子可以说明上述表达核心。</p>
<p><strong>例子1：没有生命周期延长的情况</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Begin main()\n&quot;</span>;</span><br><span class="line">    <span class="built_in">createA</span>();  <span class="comment">// 调用 createA() 返回一个临时对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End main()\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Begin main()</span><br><span class="line">A constructor</span><br><span class="line">A destructor</span><br><span class="line">End main()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>createA()</code> 返回的临时对象 <code>A()</code> 在完整表达式结束后立即销毁。因此，在 <code>createA()</code> 调用之后，临时对象 <code>A()</code> 的析构函数被调用。</p>
<p><strong>例子2：使用生命周期延长的情况1</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Begin main()\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> A&amp; ref = <span class="built_in">createA</span>();  <span class="comment">// 使用引用延长临时对象的生命周期</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End main()\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Begin main()</span><br><span class="line">A constructor</span><br><span class="line">End main()</span><br><span class="line">A destructor</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>createA()</code> 返回的临时对象 <code>A()</code> 被延长其生命周期，因为它绑定到了常量引用 <code>const A&amp; ref</code> 上。因此，临时对象 <code>A()</code> 的析构函数在 <code>main()</code> 函数结束时才被调用，而不是在完整表达式结束时立即被销毁。</p>
<p>这些例子展示了C++中临时对象生命周期延长的效果，通过绑定到引用来延长临时对象的生命周期，可以有效地避免在表达式结束时过早销毁临时对象</p>
<p>也可以直接用右值引用延长生命周期</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base <span class="title">createBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Base</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating base object with move semantics\n&quot;</span>;</span><br><span class="line">    Base&amp;&amp; ref2 = <span class="built_in">createBase</span>();  <span class="comment">// 使用移动语义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main()\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子3：使用生命周期延长的情况2+</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base <span class="title">createBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Base</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating base object with move semantics\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> Base&amp; ref = std::<span class="built_in">move</span>(<span class="built_in">createBase</span>());  <span class="comment">// 使用移动语义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main()\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用了 <code>std::move()</code> 将 <code>createBase()</code> 返回的临时对象转换为一个 xvalue（将其作为右值引用），而不再是 prvalue。因此，生命周期延长规则不再适用，临时对象 <code>Base()</code> 在完整表达式结束后立即被销毁，导致其析构函数在 <code>main()</code> 函数结束前被调用。</p>
<p>注意：如果使用了std::move函数将其转换成右值引用的话就会出错，我认为这是编译器的选择。</p>
<h4 id="3-3-移动的意义">3.3 移动的意义</h4>
<p>对于 smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销——在引用计数指针的场景下，这个开销并不大。移动构造和拷贝构造的差异仅在于：</p>
<ul>
<li>少了一次 other.shared_count_-&gt;add_count() 的调用</li>
<li>被移动的指针被清空，因而析构时也少了一次 shared_count_-&gt;reduce_count() 的调用</li>
</ul>
<p>在使用容器类的情况下，移动更有意义。我们可以尝试分析一下下面这个假想的语句（假设 name 是 string 类型）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string result = <span class="built_in">string</span>(<span class="string">&quot;Hello, &quot;</span>) + name + <span class="string">&quot;.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在 C++11 之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外开销，执行流程大致如下：</p>
<ol>
<li>调用构造函数 string(const char*)，生成临时对象 1；”Hello, “ 复制 1 次。</li>
<li>调用 operator+(const string&amp;, const string&amp;)，生成临时对象 2；”Hello,” 复制 2 次，name 复制 1 次。</li>
<li>调用 operator+(const string&amp;, const char*)，生成对象 3；”Hello, “ 复制 3 次，name 复制 2 次，”.” 复制 1 次。</li>
<li>假设返回值优化能够生效（最佳情况），对象 3 可以直接在 result 里构造完成。</li>
<li>临时对象 2 析构，释放指向 string(“Hello, “) + name 的内存。</li>
<li>临时对象 1 析构，释放指向 string(“Hello, “) 的内存。</li>
</ol>
<p>既然 C++ 是一门追求性能的语言，一个合格的 C++ 程序员会写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string result = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">result += name;</span><br><span class="line">result += <span class="string">&quot;.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，只会调用构造函数一次和 string::operator+= 两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。但显然代码就啰嗦多了——尤其如果拼接的步骤比较多的话。从 C++11 开始，这不再是必须的。同样上面那个单行的语句，执行流程大致如下：</p>
<ol>
<li>调用构造函数 string(const char*)，生成临时对象 1；”Hello, “ 复制 1 次。</li>
<li>调用 operator+(string&amp;&amp;, const string&amp;)，直接在临时对象 1 上面执行追加操作，并把结果移动到临时对象 2；name 复制 1 次。</li>
<li>调用 operator+(string&amp;&amp;, const char*)，直接在临时对象 2 上面执行追加操作，并把结果移动到 result；”.” 复制 1 次。</li>
<li>临时对象 2 析构，内容已经为空，不需要释放任何内存。</li>
<li>临时对象 1 析构，内容已经为空，不需要释放任何内存。</li>
</ol>
<p>性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。程序员只需要牺牲一点点性能，就可以大大增加代码的可读性。而且，所谓的性能牺牲，也只是相对于优化得很好的 C 或 C++ 代码而言——这样的 C++ 代码的性能仍然完全可以超越 Python 类的语言的相应代码。</p>
<p>一句话总结，移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</p>
<h4 id="3-4-如何实现移动？">3.4 如何实现移动？</h4>
<p>要让你设计的对象支持移动的话，通常需要下面几步：</p>
<ul>
<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝——如 unique_ptr）。</li>
<li>你的对象应该有 swap 成员函数，支持和另外一个对象快速交换成员。</li>
<li>在你的对象的名空间下，应当有一个全局的 swap 函数，调用成员函数 swap 来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的 swap 函数。</li>
<li>实现通用的 operator=。</li>
<li>上面各个函数如果不抛异常的话，应当标为 noexcept。这对移动构造函数尤为重要。</li>
</ul>
<p>具体写法可以参考我们当前已经实现的 smart_ptr：</p>
<ul>
<li>smart_ptr 有拷贝构造和移动构造函数（虽然此处我们的模板构造函数严格来说不算拷贝或移动构造函数）。移动构造函数应当从另一个对象获取资源，清空其资源，并将其置为一个可析构的状态。</li>
</ul>
<h4 id="3-5-不要返回本地变量的引用">3.5 不要返回本地变量的引用</h4>
<p>在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（<strong>named return value optimization</strong>，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout/endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj</span>(<span class="type">const</span> Obj&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj(const Obj&amp;)&quot;</span></span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj</span>(Obj&amp;&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj(Obj&amp;&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Obj <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj obj;</span><br><span class="line">    <span class="comment">// 简单返回对象；一般有 NRVO</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Obj <span class="title">simple_with_move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj obj;</span><br><span class="line">    <span class="comment">// move 会禁止 NRVO</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Obj <span class="title">complicated</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj obj1;</span><br><span class="line">    Obj obj2;</span><br><span class="line">    <span class="comment">// 有分支，一般无 NRVO</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** 1 ***&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> obj1 = <span class="built_in">simple</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** 2 ***&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> obj2 = <span class="built_in">simple_with_move</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** 3 ***&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> obj3 = <span class="built_in">complicated</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** <span class="number">1</span> ***</span><br><span class="line"><span class="built_in">Obj</span>()</span><br><span class="line">*** <span class="number">2</span> ***</span><br><span class="line"><span class="built_in">Obj</span>()</span><br><span class="line"><span class="built_in">Obj</span>(Obj&amp;&amp;)</span><br><span class="line">*** <span class="number">3</span> ***</span><br><span class="line"><span class="built_in">Obj</span>()</span><br><span class="line"><span class="built_in">Obj</span>()</span><br><span class="line"><span class="built_in">Obj</span>(Obj&amp;&amp;)</span><br></pre></td></tr></table></figure>
<p>也就是，用了 std::move 反而妨碍了返回值优化。</p>
<h4 id="3-6-引用坍缩和完美转发">3.6 引用坍缩和完美转发</h4>
<p>引用坍缩（又称”引用折叠”）。</p>
<p>我们已经讲了对于一个实际的类型 T，它的左值引用是 T&amp;，右值引用是 T&amp;&amp;。那么：</p>
<ol>
<li>是不是看到 T&amp;，就一定是个左值引用？</li>
<li>是不是看到 T&amp;&amp;，就一定是个右值引用？</li>
</ol>
<p>对于前者的回答是”是”，对于后者的回答为”否”。</p>
<p>关键在于，在有模板的代码里，对于类型参数的推导结果可能是引用。我们可以略过一些繁复的语法规则，要点是：</p>
<ul>
<li>对于 <code>template &lt;typename T&gt; foo(T&amp;&amp;)</code> 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。</li>
<li>如果 T 是左值引用，那 T&amp;&amp; 的结果仍然是左值引用——即 type&amp; &amp;&amp; 坍缩成了 type&amp;。</li>
<li>如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然就是一个右值引用。</li>
</ul>
<p>我们之前提到过，右值引用变量仍然会匹配到左值引用上去。下面的代码会验证这一行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> shape&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;foo(const shape&amp;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(shape&amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;foo(shape&amp;&amp;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> shape&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bar(const shape&amp;)&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(shape&amp;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bar(shape&amp;&amp;)&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>(<span class="built_in">circle</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar(shape&amp;&amp;)</span><br><span class="line">foo(const shape&amp;)</span><br></pre></td></tr></table></figure>
<p>如果我们要让 bar 调用右值引用的那个 foo 的重载，我们必须写成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(std::move(s));</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(<span class="built_in">static_cast</span>&lt;shape&amp;&amp;&gt;(s));</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;circle()&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~circle()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">triangle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;triangle()&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">triangle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~triangle()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">result</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">result</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;result()&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">result</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~result()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> shape&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;foo(const shape&amp;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(shape&amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;foo(shape&amp;&amp;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> shape&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bar(const shape&amp;)&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(shape&amp;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bar(shape&amp;&amp;)&quot;</span>);</span><br><span class="line"><span class="comment">//    foo(s);</span></span><br><span class="line">	<span class="built_in">foo</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>(<span class="built_in">circle</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可如果两个 bar 的重载除了调用 foo 的方式不一样，其他都差不多的话，我们为什么要提供两个不同的 bar 呢？</p>
<p>事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类型：左值的仍然是左值，右值的仍然是右值。这个功能在 C++ 标准库中已经提供了，叫 std::forward。它和 std::move 一样都是利用引用坍缩机制来实现。此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个 bar 函数简化成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T&amp;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T&amp;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于下面这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">circle temp;</span><br><span class="line"><span class="built_in">bar</span>(temp);</span><br><span class="line"><span class="built_in">bar</span>(<span class="built_in">circle</span>());</span><br></pre></td></tr></table></figure>
<p>现在的输出是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(const shape&amp;)</span><br><span class="line">foo(shape&amp;&amp;)</span><br></pre></td></tr></table></figure>
<p>因为在 T 是模板参数时，T&amp;&amp; 的作用主要是保持值类别进行转发，它有个名字就叫”转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做”万能引用”（universal reference）。</p>
<h4 id="3-7-参考资料">3.7 参考资料</h4>
<ol>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Value categories”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></li>
<li>Anders Schau Knatten, “lvalues, rvalues, glvalues, prvalues, xvalues, help!”. <a target="_blank" rel="noopener" href="https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalueshelp/">https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalueshelp/</a></li>
<li>Jeaye, “Value category cheat-sheet”. <a target="_blank" rel="noopener" href="https://blog.jeaye.com/2017/03/19/xvalues/">https://blog.jeaye.com/2017/03/19/xvalues/</a></li>
<li>Thomas Becker, “C++ rvalue references explained”. <a target="_blank" rel="noopener" href="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a></li>
<li>Herb Sutter, “GotW #88: A candidate for the ‘most important const’”. <a target="_blank" rel="noopener" href="https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-mostimportant-const/">https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-mostimportant-const/</a></li>
</ol>
<h3 id="04-容器汇编-I：比较简单的若干容器">04 | 容器汇编 I：比较简单的若干容器</h3>
<h4 id="4-1-string">4.1 string</h4>
<p>在 string 的情况下，由于考虑到和 C 字符串的兼容，end 指向代表字符串结尾的 \0 字符。</p>
<p>string 的内存布局大致如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630210006451.png" alt="image-20240630210006451"></p>
<p>一些策略：</p>
<ul>
<li>如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>
<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。</li>
<li>如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）。</li>
</ul>
<h4 id="4-2-vector">4.2 vector</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630210029449.png" alt="image-20240630210029449"></p>
<p>vector 通常保证<strong>强异常安全性</strong>，如果元素类型没有提供一个<strong>保证不抛异常的移动构造函数</strong>，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 smart_ptr 的实现中标上 noexcept 的原因。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj1()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj1</span>(<span class="type">const</span> Obj1&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj1(const Obj1&amp;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj1</span>(Obj1&amp;&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj1(Obj1&amp;&amp;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj2()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj2</span>(<span class="type">const</span> Obj2&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj2(const Obj2&amp;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj2</span>(Obj2&amp;&amp;) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj2(Obj2&amp;&amp;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Obj1&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;Obj2&gt; v2;</span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">    v2.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v2.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v2.<span class="built_in">emplace_back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Obj1</span>()</span><br><span class="line"><span class="built_in">Obj1</span>()</span><br><span class="line"><span class="built_in">Obj1</span>()</span><br><span class="line"><span class="built_in">Obj1</span>(<span class="type">const</span> Obj1&amp;)</span><br><span class="line"><span class="built_in">Obj1</span>(<span class="type">const</span> Obj1&amp;)</span><br><span class="line"><span class="built_in">Obj2</span>()</span><br><span class="line"><span class="built_in">Obj2</span>()</span><br><span class="line"><span class="built_in">Obj2</span>()</span><br><span class="line"><span class="built_in">Obj2</span>(Obj2&amp;&amp;)</span><br><span class="line"><span class="built_in">Obj2</span>(Obj2&amp;&amp;)</span><br></pre></td></tr></table></figure>
<p>Obj1 和 Obj2 的定义只差了一个 noexcept，但这个小小的差异就导致了 vector 是否会移动对象。这点非常重要。</p>
<p>C++11 开始提供的 emplace… 系列函数是为了提升容器的性能而设计的。你可以试试把 v1.emplace_back() 改成 v1.push_back(Obj1())。对于 vector 里的内容，结果是一样的；但使用 push_back 会额外生成临时对象，多一次拷贝构造和一次析构。</p>
<p>在扩容的时，只有移动构造函数加上noexcept关键字，才会使用移动构造函数。vector 保证<strong>强异常安全性</strong>。</p>
<h4 id="4-3-deque">4.3 deque</h4>
<p>deque 的内存布局一般是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630211458535.png" alt="image-20240630211458535"></p>
<h4 id="4-4-list">4.4 list</h4>
<p>list 的内存布局一般是下图这个样子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630211520024.png" alt="image-20240630211520024"></p>
<p>某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p>
<ul>
<li>merge</li>
<li>remove</li>
<li>remove_if</li>
<li>reverse</li>
<li>sort</li>
<li>unique</li>
</ul>
<h4 id="4-5-forward-list">4.5 forward_list</h4>
<p>从 C++11 开始，前向列表 forward_list 成了标准的一部分。</p>
<p>它的内存布局：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630211605261.png" alt="image-20240630211605261"></p>
<h4 id="4-6-queue">4.6 queue</h4>
<p>queue 缺省用 deque 来实现。</p>
<p>从概念上讲，它的结构可如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630211620663.png" alt="image-20240630211620663"></p>
<h4 id="4-7-stack">4.7 stack</h4>
<p>queue 缺省也是用 deque 来实现。</p>
<p>一般图形表示法会把 stack 表示成一个竖起的 vector：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630211637452.png" alt="image-20240630211637452"></p>
<h4 id="4-8-参考资料">4.8 参考资料</h4>
<ol>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Containers library”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a></li>
<li>QuantStack, xeus-cling. <a target="_blank" rel="noopener" href="https://github.com/QuantStack/xeus-cling">https://github.com/QuantStack/xeus-cling</a></li>
<li>吴咏炜, output_container. <a target="_blank" rel="noopener" href="https://github.com/adah1972/output_container/blob/master/output_container.h">https://github.com/adah1972/output_container/blob/master/output_container.h</a></li>
</ol>
<h3 id="05-容器汇编-II：需要函数对象的容器">05 | 容器汇编 II：需要函数对象的容器</h3>
<h4 id="5-1-函数对象及其特化">5.1 函数对象及其特化</h4>
<p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，less 和 hash。</p>
<p>在标准库里，通用的 less 大致是这样定义的：</p>
<p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，less 和 hash。</p>
<p>在标准库里，通用的 less 大致是这样定义的：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，less 是一个函数对象，并且是个二元函数，执行对任意类型的值的比较，返回布尔类型。作为函数对象，它定义了函数调用运算符（operator()），并且缺省行为是对指定类型的对象进行 &lt; 的比较操作。</p>
<p>在需要大小比较的场合，C++ 通常默认会使用 less，包括我们今天会讲到的若干容器和排序算法 sort。如果我们需要产生相反的顺序的话，则可以使用 greater，大于关系。</p>
<p>计算哈希值的函数对象 hash 的目的是把一个某种类型的值转换成一个无符号整数哈希值，类型为 size_t。它没有一个可用的默认实现。对于常用的类型，系统提供了需要的特化 [2]，类似于：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; : <span class="keyword">public</span> unary_function&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要点是，对于每个类，类的作者都可以提供 hash 的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。</p>
<p>用下面这个例子来加深一下理解：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::less/greater/hash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout/endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output_container.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始数组</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v &#123; <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">29</span> &#125;;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hex;</span><br><span class="line">    <span class="keyword">auto</span> hp = <span class="built_in">hash</span>&lt;<span class="type">int</span>*&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hash(nullptr) = &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">hp</span>(<span class="literal">nullptr</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hash(v.data()) = &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">hp</span>(v.<span class="built_in">data</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.data() = &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(v.<span class="built_in">data</span>())</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> hs = <span class="built_in">hash</span>&lt;string&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hash(\&quot;hello\&quot;) = &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">hs</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hash(\&quot;hellp\&quot;) = &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">hs</span>(<span class="built_in">string</span>(<span class="string">&quot;hellp&quot;</span>)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MSVC 下的某次运行结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; 13, 6, 4, 11, 29 &#125;</span><br><span class="line">&#123; 4, 6, 11, 13, 29 &#125;</span><br><span class="line">&#123; 29, 13, 11, 6, 4 &#125;</span><br><span class="line">hash(nullptr) = a8c7f832281a39c5</span><br><span class="line">hash(v.data()) = 7a0bdfd7df0923d2</span><br><span class="line">v.data() = 000001EFFB10EAE0</span><br><span class="line">hash(&quot;hello&quot;) = a430d84680aabd0b</span><br><span class="line">hash(&quot;hellp&quot;) = a430e54680aad322</span><br></pre></td></tr></table></figure>
<p>可以看到，在这个实现里，空指针的哈希值是一个非零的数值，指针的哈希值也和指针的数值不一样。要注意不同的实现处理的方式会不一样。事实上，我的测试结果是 GCC、Clang 和 MSVC 对常见类型的哈希方式都各有不同。</p>
<p>在上面的例子里，我们同时可以看到，这两个函数对象的值不重要。我们甚至可以认为，每个 less（或 greater 或 hash）对象都是等价的。关键在于其类型。以 sort 为例，第三个参数的类型确定了其排序行为。</p>
<p>对于容器也是如此，函数对象的类型确定了容器的行为。</p>
<h4 id="5-2-priority-queue">5.2 priority_queue</h4>
<p>priority_queue 也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 less）。在使用缺省的 less 作为其 Compare 模板参数时，最大的数值会出现在容器的”顶部”。如果需要最小的数值出现在容器顶部，则可以传递 greater 作为其 Compare 模板参数。</p>
<h4 id="5-3-关联容器">5.3 关联容器</h4>
<p>关联容器有 set（集合）、map（映射）、multiset（多重集）和 multimap（多重映射）。跳出 C++ 的语境，map（映射）的更常见的名字是关联数组和字典 [3]，而在 JSON里直接被称为对象（object）。在 C++ 外这些容器常常是无序的；在 C++ 里关联容器则被认为是有序的。</p>
<p>关联容器都有 find、lower_bound、upper_bound 等查找函数，结果是一个迭代器：</p>
<ul>
<li>find(k) 可以找到任何一个等价于查找键 k 的元素（!(x &lt; k || k &lt; x)）</li>
<li>lower_bound(k) 找到第一个不小于查找键 k 的元素（!(x &lt; k)）</li>
<li>upper_bound(k) 找到第一个大于查找键 k 的元素（k &lt; x）</li>
</ul>
<p>如果你需要在 multimap 里精确查找满足某个键的区间的话，建议使用 equal_range，可以一次性取得上下界（半开半闭）。</p>
<p>对于自定义类型，我推荐尽量使用标准的 less 实现，通过重载 &lt;（及其他标准比较运算符）对该类型的对象进行排序。存储在关联容器中的键一般应满足严格弱序关系（strict weak ordering；[4]），即：</p>
<ul>
<li>对于任何该类型的对象 x：!(x &lt; x)（非自反）</li>
<li>对于任何该类型的对象 x 和 y：如果 x &lt; y，则 !(y &lt; x)（非对称）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x &lt; y 并且 y &lt; z，则 x &lt; z（传递性）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x 和 y 不可比（!(x &lt; y) 并且 !(y &lt; x)）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）</li>
</ul>
<h4 id="5-4-无序关联容器">5.4 无序关联容器</h4>
<p>从 C++11 开始，每一个关联容器都有一个对应的无序关联容器，它们是：</p>
<ul>
<li>unordered_set</li>
<li>unordered_map</li>
<li>unordered_multiset</li>
<li>unordered_multimap</li>
</ul>
<p>一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span> <span class="comment">// std::complex</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout/endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span> <span class="comment">// std::unordered_map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span> <span class="comment">// std::unordered_set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output_container.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;complex&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> complex&lt;T&gt;&amp; v)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hash&lt;T&gt; h;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">h</span>(v.<span class="built_in">real</span>()) + <span class="built_in">h</span>(v.<span class="built_in">imag</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    unordered_map&lt;complex&lt;<span class="type">double</span>&gt;, <span class="type">double</span>&gt; umc &#123;</span><br><span class="line">        &#123; &#123; <span class="number">1.0</span>, <span class="number">1.0</span> &#125;, <span class="number">1.4142</span> &#125;,</span><br><span class="line">        &#123; &#123; <span class="number">3.0</span>, <span class="number">4.0</span> &#125;, <span class="number">5.0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; umc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出可能是（顺序不能保证）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; 21, 5, 8, 3, 13, 2, 1 &#125;</span><br><span class="line">&#123; (3,4) =&gt; 5, (1,1) =&gt; 1.4142 &#125;</span><br></pre></td></tr></table></figure>
<p>请注意我们在 std 名空间中添加了特化，这是少数用户可以向 std 名空间添加内容的情况之一。正常情况下，向 std 名空间添加声明或定义是禁止的，属于未定义行为。</p>
<h4 id="5-5-array">5.5 array</h4>
<p>C 数组在 C++ 里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++ 的容器相差是非常大的：</p>
<ul>
<li>C 数组没有 begin 和 end 成员函数（虽然可以使用全局的 begin 和 end 函数）</li>
<li>C 数组没有 size 成员函数（得用一些模板技巧来获取其长度）</li>
<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>
</ul>
<p>在 C 的年代，大家有时候会定义这样一个宏来获得数组的长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_LEN(a) (sizeof(a) / sizeof((a)[0]))</span></span><br></pre></td></tr></table></figure>
<p>如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。现在 GCC 会友好地发出警告：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ARRAY_LEN</span>(a) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [8]’ [-Wsizeof-array-argument]</p>
<p>cout &lt;&lt; ARRAY_LEN(a) &lt;&lt; endl;</p>
</blockquote>
<p>C++17 直接提供了一个 size 方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout/endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// std::size</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不能编译</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::size(arr)</span></span><br><span class="line">    <span class="comment">// &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The array length is &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">size</span>(arr)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">test</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，C 数组也没有良好的复制行为。</p>
<p>array 可以避免 C 数组的种种怪异行径。</p>
<h4 id="5-6-参考资料">5.6 参考资料</h4>
<ol>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Containers library”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Explicit (full) template specialization”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_specialization">https://en.cppreference.com/w/cpp/language/template_specialization</a></li>
<li>Wikipedia, “Associative array”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a></li>
<li>Wikipedia, “Weak ordering”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Weak_ordering">https://en.wikipedia.org/wiki/Weak_ordering</a></li>
<li>Wikipedia, “Hash table”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a></li>
</ol>
<h3 id="06-异常：用还是不用，这是个问题">06 | 异常：用还是不用，这是个问题</h3>
<p>首先，开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。</p>
<h4 id="6-1-没有异常的世界">6.1 没有异常的世界</h4>
<p>我们先来看看没有异常的世界是什么样子的。最典型的情况就是 C 了。</p>
<p>假设我们要做一些矩阵的操作，定义了下面这个矩阵的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span>* data;</span><br><span class="line">    <span class="type">size_t</span> nrows;</span><br><span class="line">    <span class="type">size_t</span> ncols;</span><br><span class="line">&#125; matrix;</span><br></pre></td></tr></table></figure>
<p>我们至少需要有初始化和清理的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">matrix_err_code</span> &#123;</span></span><br><span class="line">    MATRIX_SUCCESS,</span><br><span class="line">    MATRIX_ERR_MEMORY_INSUFFICIENT,</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">matrix_alloc</span><span class="params">(matrix* ptr, <span class="type">size_t</span> nrows, <span class="type">size_t</span> ncols)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = nrows * ncols * <span class="keyword">sizeof</span>(<span class="type">float</span>);</span><br><span class="line">    <span class="type">float</span>* data = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> MATRIX_ERR_MEMORY_INSUFFICIENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;data = data;</span><br><span class="line">    ptr-&gt;nrows = nrows;</span><br><span class="line">    ptr-&gt;ncols = ncols;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_dealloc</span><span class="params">(matrix* ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ptr-&gt;data);</span><br><span class="line">    ptr-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    ptr-&gt;nrows = <span class="number">0</span>;</span><br><span class="line">    ptr-&gt;ncols = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们做一下矩阵乘法吧。函数定义大概会是这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">matrix_multiply</span><span class="params">(matrix* result, <span class="type">const</span> matrix* lhs, <span class="type">const</span> matrix* rhs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> errcode;</span><br><span class="line">    <span class="keyword">if</span> (lhs-&gt;ncols != rhs-&gt;nrows) &#123;</span><br><span class="line">        <span class="keyword">return</span> MATRIX_ERR_MISMATCHED_MATRIX_SIZE;</span><br><span class="line">        <span class="comment">// 呃，得把这个错误码添到 enum matrix_err_code 里</span></span><br><span class="line">    &#125;</span><br><span class="line">    errcode = matrix_alloc(result, lhs-&gt;nrows, rhs-&gt;ncols);</span><br><span class="line">    <span class="keyword">if</span> (errcode != MATRIX_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行矩阵乘法运算</span></span><br><span class="line">    <span class="keyword">return</span> MATRIX_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">matrix c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(matrix));</span><br><span class="line">errcode = matrix_multiply(c, a, b);</span><br><span class="line"><span class="keyword">if</span> (errcode != MATRIX_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">goto</span> error_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用乘法的结果做其他处理</span></span><br><span class="line"></span><br><span class="line">error_exit:</span><br><span class="line">    matrix_dealloc(&amp;c);</span><br><span class="line">    <span class="keyword">return</span> errcode;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们有大量需要判断错误的代码，零散分布在代码各处。</p>
<p>可这是 C 啊。我们用 C++、不用异常可以吗？</p>
<p>当然可以，但你会发现结果好不了多少。毕竟，C++ 的构造函数是不能返回错误码的，所以你根本不能用构造函数来做可能出错的事情。你不得不定义一个只能清零的构造函数，再使用一个 init 函数来做真正的构造操作。C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……</p>
<h4 id="6-2-使用异常">6.2 使用异常</h4>
<p>如果使用异常的话，我们就可以在构造函数里做真正的初始化工作了。假设我们的矩阵类有下列的数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span>* data_;</span><br><span class="line">    <span class="type">size_t</span> nrows_;</span><br><span class="line">    <span class="type">size_t</span> ncols_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数和析构函数我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">matrix::<span class="built_in">matrix</span>(<span class="type">size_t</span> nrows, <span class="type">size_t</span> ncols)</span><br><span class="line">&#123;</span><br><span class="line">    data_ = <span class="keyword">new</span> <span class="type">float</span>[nrows * ncols];</span><br><span class="line">    nrows_ = nrows;</span><br><span class="line">    ncols_ = ncols;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix::~<span class="built_in">matrix</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乘法函数可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="keyword">friend</span> matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix&amp;, <span class="type">const</span> matrix&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix&amp; lhs, <span class="type">const</span> matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.ncols != rhs.nrows) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;matrix sizes mismatch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">matrix <span class="title">result</span><span class="params">(lhs.nrows, rhs.ncols)</span></span>;</span><br><span class="line">    <span class="comment">// 进行矩阵乘法运算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用乘法的代码则更是简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix c = a * b;</span><br></pre></td></tr></table></figure>
<p>你可能已经非常疑惑了：错误处理在哪儿呢？只有一个 throw，跟前面的 C 代码能等价吗？</p>
<p>异常处理并不意味着需要写显式的 try 和 catch。<strong>异常安全的代码，可以没有任何 try 和 catch</strong>。</p>
<p>如果你不确定什么是”异常安全”，我们先来温习一下概念：异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。</p>
<p>我们看看可能会出现错误 / 异常的地方：</p>
<ul>
<li>首先是内存分配。如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。这种情况下，在 catch 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。</li>
<li>如果是矩阵的长宽不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象 c 根本不会被构造出来。</li>
<li>如果在乘法函数里内存分配失败呢？一样，result 对象根本没有构造出来，也就没有 c 对象了。还是一切正常。</li>
<li>如果 a、b 是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄漏。</li>
</ul>
<p>总而言之，只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。</p>
<h4 id="6-3-避免异常的风格指南？">6.3 避免异常的风格指南？</h4>
<p>但大名鼎鼎的 Google 的 C++ 风格指南不是说要避免异常吗 [1]？这又是怎么回事呢？</p>
<p>答案实际已经在 Google 的文档里了：</p>
<blockquote>
<p>Given that Google’s existing code is not exception-tolerant, the costs of using<br>
exceptions are somewhat greater than the costs in a new project. The conversion<br>
process would be slow and error-prone. We don’t believe that the available<br>
alternatives to exceptions, such as error codes and assertions, introduce a<br>
significant burden.</p>
<p>Our advice against using exceptions is not predicated on philosophical or moral<br>
grounds, but practical ones. Because we’d like to use our open-source projects<br>
at Google and it’s difficult to do so if those projects use exceptions, we need to<br>
advise against exceptions in Google open-source projects as well. Things would<br>
probably be different if we had to do it all over again from scratch.</p>
</blockquote>
<p>我来翻译一下（我的加重）：</p>
<blockquote>
<p>鉴于 Google 的现有代码不能承受异常，<strong>使用异常的代价要比在全新的项目中使用异常</strong><br>
<strong>大一些。</strong> 转换 [代码来使用异常的] 过程会缓慢而容易出错。我们不认为可代替异常的方<br>
法，如错误码或断言，会带来明显的负担。</p>
<p>我们反对异常的建议并非出于哲学或道德的立场，而是出于实际考虑。因为我们希望在<br>
Google 使用我们的开源项目，而如果这些项目使用异常的话就会对我们的使用带来困<br>
难，我们也需要反对在 Google 的开源项目中使用异常。<strong>如果我们从头再来一次的话，</strong><br>
<strong>事情可能就会不一样了。</strong></p>
</blockquote>
<p>这个如果还比较官方、委婉的话，Reddit 上还能找到一个更个人化的表述 [2]：</p>
<blockquote>
<p>I use [sic] to work at Google, and Craig Silverstein, who wrote the first draft of<br>
the style guideline, said that he regretted the ban on exceptions, but he had no<br>
choice; when he wrote it, it wasn’t only that the compiler they had at the time<br>
did a very bad job on exceptions, but that they already had a huge volume of<br>
non-exception-safe code.</p>
</blockquote>
<p>我的翻译（同样，我的加重）：</p>
<blockquote>
<p>我过去在 Google 工作，写了风格指南初稿的 Craig Silverstein 说过 <strong>他对禁用异常感到</strong><br>
<strong>遗憾</strong> ，但他当时别无选择。在他写风格指南的时候，不仅<strong>他们使用的编译器在异常上工</strong><br>
<strong>作得很糟糕，而且他们已经有了一大堆异常不安全的代码了。</strong></p>
</blockquote>
<p>当然，除了历史原因以外，也有出于性能等其他原因禁用异常的。美国国防部的联合攻击战斗机（JSF）项目的 C++ 编码规范就禁用异常，因为工具链不能保证抛出异常时的实时性能。不过在那种项目里，被禁用的 C++ 特性就多了，比如动态内存分配都不能使用。</p>
<p>一些游戏项目为了追求高性能，也禁用异常。这个实际上也有一定的历史原因，因为今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。LLVM 项目的编码规范里就明确指出这是不使用 RTTI 和异常的原因 [3]：</p>
<blockquote>
<p>In an effort to reduce code and executable size, LLVM does not use RTTI (e.g. dynamic_cast&lt;&gt;;) or exceptions.</p>
</blockquote>
<h4 id="6-4-异常的问题">6.4 异常的问题</h4>
<p>异常当然不是一个完美的特性，否则也不会招来这些批评和禁用了。对它的批评主要有两条：</p>
<ul>
<li>异常违反了”你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。</li>
<li>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。</li>
</ul>
<p>对于第一条，开发者没有什么可做的。事实上，这也算是 C++ 实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提高主流程（happy path）的性能。只要程序不抛异常，C++ 代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失 [4]。除了非常有限的一些场景，可执行文件大小通常不会是个问题。</p>
<p>第二条可以算作是一个真正有效的批评。和 Java 不同，C++ 里不会对异常规约进行编译时的检查。从 C++17 开始，C++ 甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常—— noexcept、noexcept(true) 或 throw()。这也是 C++ 的运行时唯一会检查的东西了。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 std::terminate 来终止应用程序。不管是程序员的声明，还是编译器的检查，都不会告诉你哪些函数会抛出哪些异常。</p>
<p>当然，不声明异常是有理由的。特别是在泛型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：</p>
<ol>
<li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证 [5]，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。</li>
<li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况，了解需要准备处理哪些异常。</li>
<li>对于肯定不会抛出异常的代码，将其标为 noexcept。注意类的特殊成员（构造函数、析构函数、赋值函数等）会自动成为 noexcept，如果它们调用的代码都是 noexcept 的话。所以，像 swap 这样的成员函数应当尽可能标成 noexcept。</li>
</ol>
<h4 id="6-5-使用异常的理由">6.5 使用异常的理由</h4>
<p>虽然后面我们会描述到一些不使用异常、也不使用错误返回码的错误处理方式，但异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误。比如，在说容器的时候，有一个我没提的地方是，在能使用 [] 运算符的地方，C++ 的标准容器也提供了 at 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段。</p>
<p>C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过， vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。</p>
<p>只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc，除非你明确知道你的目标运行环境不会产生这个异常。这对普通配置的 Linux 环境而言，倒确实是对的……这也算是 Google 这么规定的一个底气吧。</p>
<p>虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 assert，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，assert 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。</p>
<p>标准 C++ 可能会产生哪些异常，可以查看参考资料 [6]。</p>
<h4 id="6-6-参考资料">6.6 参考资料</h4>
<ol>
<li>Google, “Google C++ style guide”. <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Exceptions">https://google.github.io/styleguide/cppguide.html#Exceptions</a></li>
<li>Reddit, Discussion on “Examples of C++ projects which embrace exceptions?”. <a target="_blank" rel="noopener" href="https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/">https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/</a></li>
<li>LLVM Project, “LLVM coding standards”. <a target="_blank" rel="noopener" href="https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions">https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions</a></li>
<li>Standard C++ Foundation, “FAQ—exceptions and error handling”. <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/exceptions">https://isocpp.org/wiki/faq/exceptions</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Exceptions”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::exception”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/error/exception">https://en.cppreference.com/w/cpp/error/exception</a></li>
</ol>
<h3 id="07-迭代器和好用的新for循环">07 | 迭代器和好用的新for循环</h3>
<h4 id="7-1-什么是迭代器？">7.1 什么是迭代器？</h4>
<p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求（[1]）。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。</p>
<p>我在用 output_container.h 输出容器内容的时候，实际上就对容器的 begin 和 end 成员函数返回的对象类型提出了要求。假设前者返回的类型是 I，后者返回的类型是 S，这些要求是：</p>
<ul>
<li>I 对象支持 <code>*</code> 操作，解引用取得容器内的某个对象。</li>
<li>I 对象支持 ++，指向下一个对象。</li>
<li>I 对象可以和 I 或 S 对象进行相等比较，判断是否遍历到了特定位置（在 S 的情况下是是否结束了遍历）。</li>
</ul>
<p>注意在 C++17 之前，begin 和 end 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I 和 S 可以是不同的类型。</p>
<p>上面的类型 I，多多少少就是一个满足输入迭代器（input iterator）的类型了。不过， output_container.h 只使用了前置 ++，但输入迭代器要求前置和后置 ++ 都得到支持。</p>
<p>输入迭代器不要求对同一迭代器可以多次使用 <code>*</code> 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p>
<p>一个前向迭代器的类型，如果同时支持 —（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。</p>
<p>一个双向迭代器，如果额外支持在整数类型上的 +、-、+=、-=，跳跃式地移动迭代器；支持 []，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p>
<p>一个随机访问迭代器 i 和一个整数 n，在 <code>*i</code> 可解引用且 i + n 是合法迭代器的前提下，如果额外还满足 <code>*(addressdof(*i) + n)</code> 等价于 <code>*(i + n)</code>，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguous iterator）。</p>
<p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 <code>*i</code> 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p>
<p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p>
<ul>
<li>对象可以被拷贝构造、拷贝赋值和析构。</li>
<li>对象支持 * 运算符。</li>
<li>对象支持前置 ++ 运算符。</li>
</ul>
<p>迭代器类型的关系可从下图中全部看到：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630212317383.png" alt="image-20240630212317383"></p>
<p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，vector 的迭代器，在很多实现里就直接是使用指针的。</p>
<h4 id="7-2-常用迭代器">7.2 常用迭代器</h4>
<p>最常用的迭代器就是容器的 iterator 类型了。一般而言，iterator 可写入，const_iterator 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p>
<ul>
<li>vector::iterator 和 array::iterator 可以满足到连续迭代器。</li>
<li>deque::iterator 可以满足到随机访问迭代器（记得它的内存只有部分连续）。</li>
<li>list::iterator 可以满足到双向迭代器（链表不能快速跳转）。</li>
<li>forward_list::iterator 可以满足到前向迭代器（单向链表不能反向遍历）。</li>
</ul>
<p>很常见的一个输出迭代器是 back_inserter 返回的类型 back_inserter_iterator 了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是 ostream_iterator，方便我们把容器内容”拷贝”到一个输出流。</p>
<h4 id="7-3-使用输入行迭代器">7.3 使用输入行迭代器</h4>
<p>下面我们来看一下一个我写的输入迭代器。它的功能本身很简单，就是把一个输入流（istream）的内容一行行读进来。配上 C++11 引入的基于范围的 for 循环的语法，我们可以把遍历输入流的代码以一种自然、非过程式的方式写出来，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> string&amp; line : <span class="built_in">istream_line_reader</span>(is)) &#123;</span><br><span class="line">    <span class="comment">// 示例循环体中仅进行简单输出</span></span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以对比一下以传统的方式写的 C++ 代码，其中需要照顾不少细节：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">getline</span>(is, line);</span><br><span class="line">    <span class="keyword">if</span> (!is) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们后面会分析一下这个输入迭代器。在此之前，我先解说一下基于范围的 for 循环这个语法。虽然这可以说是个语法糖，但它对提高代码的可读性真的非常重要。如果不用这个语法糖的话，简洁性上的优势就小多了。我们直接把这个循环改写成等价的普通 for 循环的样子。</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; r = <span class="built_in">istream_line_reader</span>(is);</span><br><span class="line">    <span class="keyword">auto</span> it = r.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> end = r.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != end; ++it) &#123;</span><br><span class="line">        <span class="type">const</span> string&amp; line = *it;</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它做的事情也不复杂，就是：</p>
<ul>
<li>获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。</li>
<li>自动生成遍历这个范围的迭代器。</li>
<li>循环内自动生成根据冒号左边的声明和 *it 来进行初始化的语句。</li>
<li>下面就是完全正常的循环体。</li>
</ul>
<p>生成迭代器这一步有可能是——但不一定是——调用 r 的 begin 和 end 成员函数。具体规则是：</p>
<ul>
<li>对于 C 数组（必须是没有退化为指针的情况），编译器会自动生成指向数组头尾的指针（相当于自动应用可用于数组的 std::begin 和 std::end 函数）。</li>
<li>对于有 begin 和 end 成员的对象，编译器会调用其 begin 和 end 成员函数（我们目前的情况）。</li>
<li>否则，编译器会尝试在 r 对象所在的名空间寻找可以用于 r 的 begin 和 end 函数，并</li>
<li>调用 begin® 和 end®；找不到的话则失败报错。</li>
</ul>
<h4 id="7-4-定义输入行迭代器">7.4 定义输入行迭代器</h4>
<p>C++ 里有些固定的类型要求规范。对于一个迭代器，我们需要定义下面的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">istream_line_reader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123; <span class="comment">// 实现 InputIterator</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> string value_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; reference;</span><br><span class="line">        <span class="keyword">typedef</span> input_iterator_tag iterator_category;</span><br><span class="line">        <span class="comment">// …</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仿照一般的容器，我们把迭代器定义为 istream_line_reader 的嵌套类。它里面的这五个类型是必须定义的（其他泛型 C++ 代码可能会用到这五个类型；之前标准库定义了一个可以继承的类模板 std::iterator 来产生这些类型定义，但这个类目前已经被废弃[2]）。其中：</p>
<ul>
<li>difference_type 是代表迭代器之间距离的类型，定义为 ptrdiff_t 只是种标准做法（指针间差值的类型），对这个类型没什么特别作用。</li>
<li>value_type 是迭代器指向的对象的值类型，我们使用 string，表示迭代器指向的是字符串。</li>
<li>pointer 是迭代器指向的对象的指针类型，这儿就平淡无奇地定义为 value_type 的常指针了（我们可不希望别人来更改指针指向的内容）。类似的，reference 是 value_type 的常引用。</li>
<li>iterator_category 被定义为 input_iterator_tag，标识这个迭代器的类型是</li>
<li>input iterator（输入迭代器）。</li>
</ul>
<p>作为一个真的只能读一次的输入迭代器，有个特殊的麻烦（前向迭代器或其衍生类型没有）：到底应该让 <code>*</code> 负责读取还是 ++ 负责读取。我们这儿采用常见、也较为简单的做法，让 ++ 负责读取，<code>*</code> 负责返回读取的内容（这个做法会有些副作用，但按我们目前的用法则没有问题）。这样的话，这个 iterator 类需要有一个数据成员指向输入流，一个数据成员来存放读取的结果。根据这个思路，我们定义这个类的基本成员函数和数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">istream_line_reader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">        <span class="comment">//…</span></span><br><span class="line">        <span class="built_in">iterator</span>() <span class="keyword">noexcept</span></span><br><span class="line">            : <span class="built_in">stream_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(istream&amp; is)</span></span></span><br><span class="line"><span class="function">            : stream_(&amp;is)</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">            ++*<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> line_;</span><br><span class="line">        &#125;</span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;line_;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getline</span>(*stream_, line_);</span><br><span class="line">            <span class="keyword">if</span> (!*stream_) &#123;</span><br><span class="line">                stream_ = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">iterator <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">            ++*<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        istream* stream_;</span><br><span class="line">        string line_;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们定义了默认构造函数，将 <code>stream_</code> 清空；相应的，在带参数的构造函数里，我们根据传入的输入流来设置 <code>stream_</code>。我们也定义了 <code>*</code> 和 -&gt; 运算符来取得迭代器指向的文本行的引用和指针，并用 ++ 来读取输入流的内容（后置 ++ 则以惯常方式使用前置 ++ 和拷贝构造来实现）。唯一”特别”点的地方，是我们在构造函数里调用了 ++，确保在构造后调用 <code>*</code> 运算符时可以读取内容，符合日常先使用 <code>*</code>、再使用 ++ 的习惯。一旦文件读取到尾部（或出错），则 <code>stream_</code> 被清空，回到默认构造的情况。</p>
<p>对于迭代器之间的比较，我们则主要考虑文件有没有读到尾部的情况，简单定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; rhs) <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stream_ == rhs.stream_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; rhs) <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">operator</span>==(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个 iterator 的定义后，istream_line_reader 的定义就简单得很了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">istream_line_reader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">        <span class="comment">//…</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">istream_line_reader</span>() <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">stream_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">istream_line_reader</span><span class="params">(istream&amp; is)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        : stream_(&amp;is)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(*stream_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    istream* stream_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，构造函数只是简单地把输入流的指针赋给 stream_ 成员变量。begin 成员函数则负责构造一个真正有意义的迭代器；end 成员函数则只是返回一个默认构造的迭代器而已。</p>
<p>以上就是一个完整的基于输入流的行迭代器了。这个行输入模板的设计动机和性能测试结果可参见参考资料 [3] 和 [4]；完整的工程可用代码，请参见参考资料 [5]。该项目中还提供了利用 C 文件接口的 file_line_reader 和基于内存映射文件的 mmap_line_reader。</p>
<h4 id="7-5-参考资料">7.5 参考资料</h4>
<ol>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Iterator library”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/iterator">https://en.cppreference.com/w/cpp/iterator</a></li>
<li>Jonathan Boccara, “std::iterator is deprecated: why, what it was, and what to use instead”. <a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/">https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/</a></li>
<li>吴咏炜, “Python yield and C++ coroutines”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cpluspluscoroutines/">https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cpluspluscoroutines/</a></li>
<li>吴咏炜, “Performance of my line readers”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/">https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/</a></li>
<li>吴咏炜, nvwa. <a target="_blank" rel="noopener" href="https://github.com/adah1972/nvwa/">https://github.com/adah1972/nvwa/</a></li>
</ol>
<h3 id="08-易用性改进-I：自动类型推断和初始化">08 | 易用性改进 I：自动类型推断和初始化</h3>
<h4 id="8-1-自动类型推断">8.1 自动类型推断</h4>
<ol>
<li>
<p>auto</p>
<p>自动类型推断，顾名思义，就是编译器能够根据表达式的类型，自动决定变量的类型（从 C++14 开始，还有函数的返回类型），不再需要程序员手工声明（[1]）。但需要说明的是，auto 并没有改变 C++ 是静态类型语言这一事实——使用 auto 的变量（或函数返回值）的类型仍然是编译时就确定了，只不过编译器能自动帮你填充而已。</p>
<p>auto 实际使用的规则类似于函数模板参数的推导规则（[3]）。当你写了一个含 auto 的表达式时，相当于把 auto 替换为模板参数的结果。举具体的例子：</p>
<ul>
<li>auto a = expr; 意味着用 expr 去匹配一个假想的 <code>template &lt;typename T&gt; f(T)</code> 函数模板，结果为值类型。</li>
<li>const auto&amp; a = expr; 意味着用 expr 去匹配一个假想的 <code>template &lt;typename T&gt; f(const T&amp;)</code> 函数模板，结果为常左值引用类型。</li>
<li>auto&amp;&amp; a = expr; 意味着用 expr 去匹配一个假想的 <code>template &lt;typename T&gt; f(T&amp;&amp;)</code> 函数模板，根据 <strong>[第 3 讲]</strong> 中我们讨论过的转发引用和引用坍缩规则，结果是一个跟 expr 值类别相同的引用类型。</li>
</ul>
</li>
<li>
<p>decltype</p>
<p>decltype 的用途是获得一个表达式的类型，结果可以跟类型一样使用。它有两个基本用法：</p>
<ul>
<li>
<p>decltype(变量名) 可以获得变量的精确类型。</p>
</li>
<li>
<p>decltype(表达式) （表达式不是变量名，但包括 decltype((变量名)) 的情况）可以获得表达式的引用类型；除非表达式的结果是个纯右值（prvalue），此时结果仍然是值类型。</p>
<p>如果我们有 int a;，那么：</p>
</li>
<li>
<p>decltype(a) 会获得 int（因为 a 是 int）。</p>
</li>
<li>
<p>decltype((a)) 会获得 int&amp;（因为 a 是 lvalue）。</p>
</li>
<li>
<p>decltype(a + a) 会获得 int（因为 a + a 是 prvalue）。</p>
</li>
</ul>
</li>
<li>
<p>decltype(auto)</p>
<p>通常情况下，能写 auto 来声明变量肯定是件比较轻松的事。但这儿有个限制，你需要在写下 auto 时就决定你写下的是个引用类型还是值类型。根据类型推导规则，auto 是值类型，auto&amp; 是左值引用类型，auto&amp;&amp; 是转发引用（可以是左值引用，也可以是右值引用）。使用 auto 不能通用地根据表达式类型来决定返回值的类型。不过， decltype(expr) 既可以是值类型，也可以是引用类型。因此，我们可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expr) a = expr;</span><br></pre></td></tr></table></figure>
<p>这种写法明显不能让人满意，特别是表达式很长的情况（而且，任何代码重复都是潜在的问题）。为此，C++14 引入了 decltype(auto) 语法。对于上面的情况，我们只需要像下面这样写就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a = expr;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="8-2-函数返回值类型推断">8.2 函数返回值类型推断</h4>
<p>从 C++14 开始，函数的返回值也可以用 auto 或 decltype(auto) 来声明了。同样的，用 auto 可以得到值类型，用 auto&amp; 或 auto&amp;&amp; 可以得到引用类型；而用 decltype(auto) 可以根据返回表达式通用地决定返回的是值类型还是引用类型。</p>
<p>和这个形式相关的有另外一个语法，后置返回值类型声明。严格来说，这不算”类型推断”，不过我们也放在一起讲吧。它的形式是这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(参数)</span> -&gt; 返回值类型声明</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，在返回类型比较复杂、特别是返回类型跟参数类型有某种推导关系时会使用这种语法。以后我们会讲到一些实例。今天暂时不多讲了。</p>
<h4 id="8-3-类模板的模板参数推导">8.3 类模板的模板参数推导</h4>
<p>如果你用过 pair 的话，一般都不会使用下面这种形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr&#123;<span class="number">1</span>, <span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 make_pair 显然更容易一些：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pr = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>这是因为函数模板有模板参数推导，使得调用者不必手工指定参数类型；但 C++17 之前的类模板却没有这个功能，也因而催生了像 make_pair 这样的工具函数。</p>
<p>在进入了 C++17 的世界后，这类函数变得不必要了。现在我们可以直接写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair pr&#123;<span class="number">1</span>, <span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>在初次见到 array 时，我觉得它的主要缺点就是不能像 C 数组一样自动从初始化列表来推断数组的大小了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; a2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 啰嗦</span></span><br><span class="line"><span class="comment">// array&lt;int&gt; a3&#123;1, 2, 3&#125;; 不行</span></span><br></pre></td></tr></table></figure>
<p>这个问题在 C++17 里也是基本不存在的。虽然不能只提供一个模板参数，但你可以两个参数全都不写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 得到 array&lt;int, 3&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种自动推导机制，可以是编译器根据构造函数来自动生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">    <span class="built_in">MyObj</span>(T value);</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyObj obj1 &#123; <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) &#125;; <span class="comment">// 得到 MyObj&lt;string&gt;</span></span><br><span class="line">MyObj obj2 &#123; <span class="string">&quot;hello&quot;</span> &#125;; <span class="comment">// 得到 MyObj&lt;const char*&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以是手工提供一个推导向导，达到自己需要的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">    <span class="built_in">MyObj</span>(T value);</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MyObj</span>(<span class="type">const</span> <span class="type">char</span>*) -&gt; MyObj&lt;string&gt;;</span><br><span class="line"></span><br><span class="line">MyObj obj1 &#123; <span class="string">&quot;hello&quot;</span> &#125;; <span class="comment">// 得到 MyObj&lt;string&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多的技术细节请参见参考资料 [4]。</p>
<h4 id="8-4-结构化绑定">8.4 结构化绑定</h4>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, <span class="type">int</span>&gt;::iterator lower, upper;</span><br><span class="line">std::<span class="built_in">tie</span>(lower, upper) = mmp.<span class="built_in">equal_range</span>(<span class="string">&quot;four&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子里，返回值是个 pair，我们希望用两个变量来接收数值，就不得不声明了两个变量，然后使用 tie 来接收结果。在 C++11/14 里，这里是没法使用 auto 的。好在 C++17 引入了一个新语法，解决了这个问题。目前，我们可以把上面的代码简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [lower, upper] = mmp.<span class="built_in">equal_range</span>(<span class="string">&quot;four&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个语法使得我们可以用 auto 声明变量来分别获取 pair 或 tuple 返回值里各个子项，可以让代码的可读性更好。</p>
<p>关于这个语法的更多技术说明，请参见参考资料 [5]。</p>
<h4 id="8-5-列表初始化">8.5 列表初始化</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这不是对标准库容器的特殊魔法，而是一个通用的、可以用于各种类的方法。从技术角度，编译器的魔法只是对 {1, 2, 3} 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 <code>initializer_list&lt;int&gt;</code>。程序员只需要声明一个接受 initializer_list 的构造函数即可使用。从效率的角度，至少在动态对象的情况下，容器和数组也并无二致，都是通过拷贝（构造）进行初始化。</p>
<p>对于初始化列表在构造函数外的用法和更多的技术细节，请参见参考资料 [6]。</p>
<h4 id="8-6-统一初始化">8.6 统一初始化</h4>
<p>你可能已经注意到了，我在代码里使用了大括号 {} 来进行对象的初始化。这当然也是 C++11 引入的新语法，能够代替很多小括号 () 在变量初始化时使用。这被称为统一初始化（uniform initialization）。</p>
<p>大括号对于构造一个对象而言，最大的好处是避免了 C++ 里”最令人恼火的语法分析”（the most vexing parse）。我也遇到过。假设你有一个类，原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">utf8_to_wstring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">utf8_to_wstring</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">wchar_t</span>*();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后你在 Windows 下想使用这个类来帮助转换文件名，打开文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(utf8_to_wstring(filename))</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面这个写法会被编译器认为是和下面的写法等价的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(utf8_to_wstring filename)</span></span>;</span><br></pre></td></tr></table></figure>
<p>换句话说，编译器认为你是声明了一个叫 ifs 的函数，而不是对象！</p>
<p>如果你把任何一对小括号替换成大括号（或者都替换，如下），则可以避免此类问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs&#123;utf8_to_wstring&#123;filename&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>推而广之，你几乎可以在所有初始化对象的地方使用大括号而不是小括号。它还有一个附带的特点：当一个构造函数没有标成 explicit 时，你可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象的话。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Obj 类可以使用浮点数进行构造的话，上面的写法就是合法的。如果有无参数、多参数的构造函数，也可以使用这个形式。除了形式上的区别，它跟 Obj(1.0) 的主要区别是，后者可以用来调用 Obj(int)，而使用大括号时编译器会拒绝”窄”转换，不接受以 {1.0} 或 Obj{1.0} 的形式调用构造函数 Obj(int)。</p>
<p>这个语法主要的限制是，如果一个构造函数既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会千方百计地试图调用使用初始化列表的构造函数，导致各种意外。所以，如果给一个推荐的话，那就是：</p>
<ul>
<li>如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法。</li>
<li>如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况。</li>
</ul>
<p>关于这个语法的更多详细用法讨论，请参见参考资料 [7]。</p>
<h4 id="8-7-类数据成员的默认初始化">8.7 类数据成员的默认初始化</h4>
<p>按照 C++98 的语法，数据成员可以在构造函数里进行初始化。这本身不是问题，但实践中，如果数据成员比较多、构造函数又有多个的话，逐个去初始化是个累赘，并且很容易在增加数据成员时漏掉在某个构造函数中进行初始化。为此，C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">float</span> re)</span><br><span class="line">        : <span class="built_in">re_</span>(re)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">float</span> re, <span class="type">float</span> im)</span><br><span class="line">        : <span class="built_in">re_</span>(re)</span><br><span class="line">        , <span class="built_in">im_</span>(im)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> re_ &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">float</span> im_ &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-8-参考资料">8.8 参考资料</h4>
<ol>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Placeholder type specifiers”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/auto">https://en.cppreference.com/w/cpp/language/auto</a></li>
<li>Wikipedia, “Argument-dependent name lookup”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Argument-dependent_name_lookup">https://en.wikipedia.org/wiki/Argument-dependent_name_lookup</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Template argument deduction”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">https://en.cppreference.com/w/cpp/language/template_argument_deduction</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Class template argument deduction”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">https://en.cppreference.com/w/cpp/language/class_template_argument_deduction</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Structured binding declaration”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/structured_binding">https://en.cppreference.com/w/cpp/language/structured_binding</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::initializer_list”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/initializer_list">https://en.cppreference.com/w/cpp/utility/initializer_list</a></li>
<li>Scott Meyers,Effective Modern C++, item 7. O’Reilly Media, 2014. 有中文版（高博译，中国电力出版社，2018 年）</li>
</ol>
<h2 id="02丨提高篇">02丨提高篇</h2>
<h3 id="10-到底应不应该返回对象？">10 | 到底应不应该返回对象？</h3>
<h4 id="10-1-F-20">10.1 F.20</h4>
<p>《C++ 核心指南》的 F.20 这一条款是这么说的 [1]：</p>
<blockquote>
<p>F.20: For “out” output values, prefer return values to output parameters</p>
</blockquote>
<p>翻译一下：</p>
<blockquote>
<p>在函数输出数值时，尽量使用返回值而非输出参数</p>
</blockquote>
<h4 id="10-2-如何返回一个对象？">10.2 如何返回一个对象？</h4>
<p>一个用来返回的对象，通常应当是<strong>可移动构造 / 赋值</strong>的，一般也同时是<strong>可拷贝构造 / 赋值</strong>的。如果这样一个对象同时又<strong>可以默认构造</strong>，我们就称其为一个**半正则（semiregular）**的对象。如果可能的话，我们应当尽量让我们的类满足半正则这个要求。</p>
<p>半正则意味着我们的 matrix 类提供下面的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通构造</span></span><br><span class="line">    <span class="built_in">matrix</span>(<span class="type">size_t</span> rows, <span class="type">size_t</span> cols);</span><br><span class="line">    <span class="comment">// 半正则要求的构造</span></span><br><span class="line">    <span class="built_in">matrix</span>();</span><br><span class="line">    <span class="built_in">matrix</span>(<span class="type">const</span> matrix&amp;);</span><br><span class="line">    <span class="built_in">matrix</span>(matrix&amp;&amp;);</span><br><span class="line">    <span class="comment">// 半正则要求的赋值</span></span><br><span class="line">    matrix&amp; <span class="keyword">operator</span>=(<span class="type">const</span> matrix&amp;);</span><br><span class="line">    matrix&amp; <span class="keyword">operator</span>=(matrix&amp;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先看一下在没有返回值优化的情况下 C++ 是怎样返回对象的。以矩阵乘法为例，代码应该像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix&amp; lhs, <span class="type">const</span> matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.<span class="built_in">cols</span>() != rhs.<span class="built_in">rows</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;sizes mismatch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">matrix <span class="title">result</span><span class="params">(lhs.rows(), rhs.cols())</span></span>;</span><br><span class="line">    <span class="comment">// 具体计算过程</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <strong>[第 3 讲]</strong> 里说过的，返回非引用类型的表达式结果是个纯右值（prvalue）。在执行 auto r = … 的时候，编译器会认为我们实际是在构造 matrix r(…)，而”…”部分是一个纯右值。因此编译器会首先试图匹配 matrix(matrix&amp;&amp;)，在没有时则试图匹配 matrix(const matrix&amp;)；也就是说，有移动支持时使用移动，没有移动支持时则拷贝。</p>
<h4 id="10-3-返回值优化（拷贝消除）">10.3 返回值优化（拷贝消除）</h4>
<p>我们再来看一个能显示生命期过程的对象的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can copy and move</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Create A\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destroy A\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Copy A\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Move A\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA_unnamed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">getA_unnamed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你认为执行结果里应当有一行”Copy A”或”Move A”的话，你就忽视了返回值优化的威力了。即使完全关闭优化，三种主流编译器（GCC、Clang 和 MSVC）都只输出两行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Create A</span><br><span class="line">Destroy A</span><br></pre></td></tr></table></figure>
<p>我们把代码稍稍改一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">getA_named</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">getA_named</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回结果有了一点点小变化。虽然 GCC 和 Clang 的结果完全不变，但 MSVC 在非优化编译的情况下产生了不同的输出（优化编译——使用命令行参数 /O1、/O2 或 /Ox——则不变）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create A</span><br><span class="line">Move A</span><br><span class="line">Destroy A</span><br><span class="line">Destroy A</span><br></pre></td></tr></table></figure>
<p>也就是说，返回内容被移动构造了。</p>
<p>我们继续变形一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA_duang</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rand</span>() &gt; <span class="number">42</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">getA_duang</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回所有的编译器都被难倒了，输出是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Create A</span><br><span class="line">Create A</span><br><span class="line">Move A</span><br><span class="line">Destroy A</span><br><span class="line">Destroy A</span><br><span class="line">Destroy A</span><br></pre></td></tr></table></figure>
<p>关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(A&amp;&amp;) = delete;</span><br></pre></td></tr></table></figure>
<p>我们可以立即看到”Copy A”出现在了结果输出中，说明目前结果变成拷贝构造了。</p>
<p>如果再进一步，把拷贝构造函数也删除呢？是不是上面的 getA_unnamed、getA_named 和 getA_duang 都不能工作了？</p>
<p>在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 getA_unnamed 这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的！C++17 要求对于这种情况，对象必须被直接构造在目标位置上，不经过任何拷贝或移动的步骤 [3]。</p>
<p><strong>综上，还是编译器的问题：</strong></p>
<p>在C++11及之后的标准中，当编译器需要返回一个局部对象时，优先会尝试使用移动语义来优化返回值，这样可以避免不必要的拷贝。如果移动构造函数被删除（或者没有定义），编译器会回退到拷贝构造函数。然而，由于返回的是一个临时对象，如果不能使用移动构造函数，编译器不能自动退回到拷贝构造函数。</p>
<h4 id="10-4-回到-F-20">10.4 回到 F.20</h4>
<p>理解了 C++ 里的对返回值的处理和返回值优化之后，我们再回过头看一下 F.20 里陈述的理由的话，应该就显得很自然了：</p>
<blockquote>
<p>A return value is self-documenting, whereas a &amp; could be either in-out or outonly and is liable to be misused.</p>
<p>返回值是可以自我描述的；而 &amp; 参数既可能是输入输出，也可能是仅输出，且很容易被误用。</p>
</blockquote>
<p>我想我对返回对象的可读性，已经给出了充足的例子。对于其是否有性能影响这一问题，也给出了充分的说明。</p>
<p>我们最后看一下 F.20 里描述的例外情况：</p>
<ul>
<li>“对于非值类型，比如返回值可能是子对象的情况，使用 unique_ptr 或 shared_ptr 来返回对象。”也就是面向对象、工厂方法这样的情况，像 <strong>[第 1 讲]</strong> 里给出的 create_shape 应该这样改造。</li>
<li>“对于移动代价很高的对象，考虑将其分配在堆上，然后返回一个句柄（如 unique_ptr），或传递一个非 const 的目标对象的引用来填充（用作输出参数）。”也就是说不方便移动的，那就只能使用一个 RAII 对象来管理生命周期，或者老办法输出参数了。</li>
<li>“要在一个内层循环里在多次函数调用中重用一个自带容量的对象：将其当作输入 / 输出参数并将其按引用传递。”这也是个需要继续使用老办法的情况。</li>
</ul>
<h4 id="10-5-参考资料">10.5 参考资料</h4>
<ol>
<li>Bjarne Stroustrup and Herb Sutter (editors), “C++ core guidelines”, item F.20. <a target="_blank" rel="noopener" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out</a> (非官方中文版可参见 <a target="_blank" rel="noopener" href="https://github.com/lynnboy/CppCoreGuidelines-zh-CN">https://github.com/lynnboy/CppCoreGuidelines-zh-CN</a>)</li>
<li>Conrad Sanderson and Ryan Curtin, Armadillo. <a target="_blank" rel="noopener" href="http://arma.sourceforge.net/">http://arma.sourceforge.net/</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Copy elision”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">https://en.cppreference.com/w/cpp/language/copy_elision</a></li>
</ol>
<h3 id="11-Unicode：进入多文字支持的世界">11 | Unicode：进入多文字支持的世界</h3>
<h4 id="11-1-一些历史">11.1 一些历史</h4>
<p>ASCII [1] 是一种创立于 1963 年的 7 位编码，用 0 到 127 之间的数值来代表最常用的字符，包含了控制字符（很多在今天已不再使用）、数字、大小写拉丁字母、空格和基本标点。它在编码上具有简单性，字母和数字的编码位置非常容易记忆。时至今日，ASCII 可以看作是字符编码的基础，主要的编码方式都保持着与 ASCII 的兼容性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630223634689.png" alt="image-20240630223634689"></p>
<p>ASCII 里只有基本的拉丁字母，它既没有带变音符的拉丁字母（如 é 和 ä ），也不支持像希腊字母（如 α、β、γ）、西里尔字母（如 Пушкин）这样的其他欧洲文字（也难怪，毕竟它是 American Standard Code for Information Interchange）。很多其他编码方式纷纷应运而生，包括 ISO 646 系列、ISO/IEC 8859 系列等等；大部分编码方式都是头 128 个字符与 ASCII 兼容，后 128 个字符是自己的扩展，总共最多是 256 个字符。每次只有一套方式可以生效，称之为一个代码页（code page）。这种做法，只能适用于文字相近、且字符数不多的国家。比如，下图表示了 ISO-8859-1（也称作 Latin-1）和后面的 Windows 扩展代码页 1252（下图中绿框部分为 Windows 的扩展），就只能适用于西欧国家。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630223652632.png" alt="image-20240630223652632"></p>
<p>最早的中文字符集标准是 1980 年的国标 GB2312 [3]，其中收录了 6763 个常用汉字和 682 个其他符号。我们平时会用到编码 GB2312，其实更正确的名字是 EUC-CN [4]，它是一种与 ASCII 兼容的编码方式。它用单字节表示 ASCII 字符而用双字节表示 GB2312 中的字符；由于 GB2312 中本身也含有 ASCII 中包含的字符，在使用中逐渐就形成了”半角”和”全角”的区别。</p>
<p>国标字符集后面又有扩展，这个扩展后的字符集就是 GBK [5]，是中文版 Windows 使用的标准编码方式。GB2312 和 GBK 所占用的编码位置可以参看下面的图（由 John M. Długosz 为 Wikipedia 绘制）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630223707850.png" alt="image-20240630223707850"></p>
<p>图中 GBK/1 和 GBK/2 为 GB2312 中已经定义的区域，其他的则是后面添加的字符，总共定义了两万多个编码点，支持了绝大部分现代汉语中还在使用的字。</p>
<p>Unicode [6] 作为一种统一编码的努力，诞生于八十年代末九十年代初，标准的第一版出版于 1991—1992 年。由于最初发明者的目标放得太低，只期望对活跃使用中的现代文字进行编码，他们认为 16 比特的”宽 ASCII”就够用了。这就导致了早期采纳 Unicode 的组织，特别是微软，在其操作系统和工具链中广泛采用了 16 比特的编码方式。在今天，微软的系统中宽字符类型 wchar_t 仍然是 16 位的，操作系统底层接口大量使用 16 位字符编码的 API，说到 Unicode 编码时仍然指的是 16 位的编码 UTF-16（这一不太正确的名字，跟中文 GBK 编码居然可以被叫做 ANSI 相比，实在是小巫见大巫了）。在微软以外的世界， Unicode 本身不作编码名称用，并且最主流的编码方式并不是 UTF-16，而是和 ASCII 全兼容的 UTF-8。</p>
<p>早期 Unicode 组织的另一个决定是不同语言里的同一个字符使用同一个编码点，来减少总编码点的数量。中日韩三国使用的汉字就这么被统一了：像”将”、”径”、”网”等字，每个字在 Unicode 中只占一个编码点。这对网页的字体选择也造成了不少麻烦，时至今日我们仍然可以看到这个问题 [10]。不过这和我们的主题无关，就不再多费笔墨了。</p>
<h4 id="11-2-Unicode-简介">11.2 Unicode 简介</h4>
<p>Unicode 在今天已经大大超出了最初的目标。到 Unicode 12.1 为止，Unicode 已经包含了 137,994 个字符，囊括所有主要语言（使用中的和已经不再使用的），并包含了表情符号、数学符号等各种特殊字符。仍然要指出一下，Unicode 字符是根据含义来区分的，而非根据字形。除了前面提到过中日韩汉字没有分开，像斜体（italics）、小大写字母（small caps）等排版效果在 Unicode 里也没有独立的对应。不过，因为 Unicode 里包含了很多数学、物理等自然科学中使用的特殊符号，某些情况下你也可以找到对应的符号，可以用在聊天中耍酷，如 𝒷𝒶𝒹（但不适合严肃的排版）。</p>
<p>Unicode 的编码点是从 0x0 到 0x10FFFF，一共 1,114,112 个位置。一般用”U+”后面跟 16 进制的数值来表示一个 Unicode 字符，如 U+0020 表示空格，U+6C49 表示”汉”，U+1F600 表示”😀”，等等（不足四位的一般写四位）。</p>
<p>Unicode 字符的常见编码方式有：</p>
<ul>
<li>UTF-32 [7]：32 比特，是编码点的直接映射。</li>
<li>UTF-16 [8]：对于从 U+0000 到 U+FFFF 的字符，使用 16 比特的直接映射；对于大于 U+FFFF 的字符，使用 32 比特的特殊映射关系——在 Unicode 的 16 比特编码点中 0xD800–0xDFFF 是一段空隙，使得这种变长编码成为可能。在一个 UTF-16 的序列中，如果看到内容是 0xD800–0xDBFF，那这就是 32 比特编码的前 16 比特；如果看到内容是 0xDC00–0xDFFF，那这是 32 比特编码的后 16 比特；如果内容在 0xD800–0xDFFF 之外，那就是一个 16 比特的映射。</li>
<li>UTF-8 [9]：1 到 4 字节的变长编码。在一个合法的 UTF-8 的序列中，如果看到一个字节的最高位是 0，那就是一个单字节的 Unicode 字符；如果一个字节的最高两比特是 10，那这是一个 Unicode 字符在编码后的后续字节；否则，这就是一个 Unicode 字符在编码后的首字节，且最高位开始连续 1 的个数表示了这个字符按 UTF-8 的方式编码有几个字节。</li>
</ul>
<p>在上面三种编码方式里，只有 UTF-8 完全保持了和 ASCII 的兼容性，目前得到了最广泛的使用。在我们下面讲具体编码方式之前，我们先看一下上面提到的三个字符在这三种方式下的编码结果：</p>
<ul>
<li>UTF-32：U+0020 映射为 0x00000020，U+6C49 映射为 0x00006C49，U+1F600 映射为 0x0001F600。</li>
<li>UTF-16：U+0020 映射为 0x0020，U+6C49 映射为 0x6C49，而 U+1F600 会映射为 0xD83D DE00。</li>
<li>UTF-8：U+0020 映射为 0x20，U+6C49 映射为 0xE6 B1 89，而 U+1F600 会映射为 0xF0 9F 98 80。</li>
</ul>
<p>Unicode 有好几种（上面还不是全部）不同的编码方式，上面的 16 比特和 32 比特编码方式还有小头党和大头党之争（”汉”按字节读取时是 6C 49 呢，还是 49 6C？）；同时，任何一种编码方式还需要跟传统的编码方式容易区分。因此，Unicode 文本文件通常有一个使用 BOM（byte order mark）字符的约定，即字符 U+FEFF [11]。由于 Unicode 不使用 U+FFFE，在文件开头加一个 BOM 即可区分各种不同编码：</p>
<ul>
<li>如果文件开头是 0x00 00 FE FF，那这是大头在前的 UTF-32 编码；</li>
<li>否则如果文件开头是 0xFF FE 00 00，那这是小头在前的 UTF-32 编码；</li>
<li>否则如果文件开头是 0xFE FF，那这是大头在前的 UTF-16 编码；</li>
<li>否则如果文件开头是 0xFF FE，那这是小头在前的 UTF-16 编码（注意，这条规则和第二条的顺序不能相反）；</li>
<li>否则如果文件开头是 0xEF BB BF，那这是 UTF-8 编码；</li>
<li>否则，编码方式使用其他算法来确定。</li>
</ul>
<p>在 UTF-8 编码下使用 BOM 字符并非必需，尤其在 Unix 上。但 Windows 上通常会使用 BOM 字符，以方便区分 UTF-8 和传统编码。</p>
<p>总结：</p>
<p><strong>Unicode</strong> 是一种字符编码标准。</p>
<ul>
<li>
<p><strong>UTF-8</strong>: 可变长度编码，使用1到4个字节表示一个字符。向后兼容ASCII，是目前最广泛使用的Unicode编码。</p>
</li>
<li>
<p><strong>UTF-16</strong>: 可变长度编码，使用2或4个字节表示一个字符。常用于操作系统和编程语言的内部表示。</p>
</li>
<li>
<p><strong>UTF-32</strong>: 固定长度编码，使用4个字节表示一个字符。虽然内存占用较大，但便于字符处理。</p>
</li>
</ul>
<p>字符编码是将字符映射为计算机可处理的数字表示的规则，用于在计算机中存储和传输文本。</p>
<h4 id="11-3-C-中的-Unicode-字符类型">11.3 C++ 中的 Unicode 字符类型</h4>
<p>C++98 中有 char 和 wchar_t 两种不同的字符类型，其中 char 的长度是单字节，而 wchar_t 的长度不确定。在 Windows 上它是双字节，只能代表 UTF-16，而在 Unix 上一般是四字节，可以代表 UTF-32。为了解决这种混乱，目前我们有了下面的改进：</p>
<ul>
<li>C++11 引入了 char16_t 和 char32_t 两个独立的字符类型（不是类型别名），分别代表 UTF-16 和 UTF-32。</li>
<li>C++20 将引入 char8_t 类型，进一步区分了可能使用传统编码的窄字符类型和 UTF-8 字符类型。</li>
<li>除了 string 和 wstring，我们也相应地有了 u16string、u32string（和将来的 u8string）。</li>
<li>除了传统的窄字符 / 字符串字面量（如 “hi”）和宽字符 / 字符串字面量（如 L”hi”），引入了新的 UTF-8、UTF-16 和 UTF-32 字面量，分别形如 u8”hi”、u”hi” 和 U”hi”。</li>
<li>为了确保非 ASCII 字符在源代码中可以简单地输入，引入了新的 Unicode 换码序列。比如，我们前面说到的三个字符可以这样表达成一个 UTF-32 字符串字面量：U”\u6C49\U0001F600”。要生成 UTF-16 或 UTF-8 字符串字面量只需要更改前缀即可。</li>
</ul>
<p>使用这些新的字符（串）类型，我们可以用下面的代码表达出 UTF-32 和其他两种 UTF 编码间是如何转换的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span> unicode_max = <span class="number">0x10FFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_utf_16</span><span class="params">(<span class="type">char32_t</span> ch, u16string&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt; unicode_max) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;invalid code point&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">        result += <span class="built_in">char16_t</span>(ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char16_t</span> first = <span class="number">0xD800</span> | ((ch - <span class="number">0x10000</span>) &gt;&gt; <span class="number">10</span>);</span><br><span class="line">        <span class="type">char16_t</span> second = <span class="number">0xDC00</span> | (ch &amp; <span class="number">0x3FF</span>);</span><br><span class="line">        result += first;</span><br><span class="line">        result += second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_utf_8</span><span class="params">(<span class="type">char32_t</span> ch, string&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt; unicode_max) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;invalid code point&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line">        result += ch;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch &lt; <span class="number">0x800</span>) &#123;</span><br><span class="line">        result += <span class="number">0xC0</span> | (ch &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        result += <span class="number">0x80</span> | (ch &amp; <span class="number">0x3F</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">        result += <span class="number">0xE0</span> | (ch &gt;&gt; <span class="number">12</span>);</span><br><span class="line">        result += <span class="number">0x80</span> | ((ch &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>);</span><br><span class="line">        result += <span class="number">0x80</span> | (ch &amp; <span class="number">0x3F</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result += <span class="number">0xF0</span> | (ch &gt;&gt; <span class="number">18</span>);</span><br><span class="line">        result += <span class="number">0x80</span> | ((ch &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3F</span>);</span><br><span class="line">        result += <span class="number">0x80</span> | ((ch &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>);</span><br><span class="line">        result += <span class="number">0x80</span> | (ch &amp; <span class="number">0x3F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char32_t</span> str[] = <span class="string">U&quot; \u6C49\U0001F600&quot;</span>;</span><br><span class="line">    u16string u16str;</span><br><span class="line">    string u8str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">to_utf_16</span>(ch, u16str);</span><br><span class="line">        <span class="built_in">to_utf_8</span>(ch, u8str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char16_t</span> ch : u16str) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; <span class="built_in">unsigned</span>(ch) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> ch : u8str) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">unsigned</span>(ch) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0020 6c49 d83d de00</span><br><span class="line">20 e6 b1 89 f0 9f 98 80</span><br></pre></td></tr></table></figure>
<h4 id="11-4-平台区别">11.4 平台区别</h4>
<p>下面我们看一下在两个主流的平台上一般是如何处理 Unicode 编码问题的。</p>
<ol>
<li>
<p>Unix</p>
<p>现代 Unix 系统，包括 Linux 和 macOS 在内，已经全面转向了 UTF-8。这样的系统中一般直接使用 char[] 和 string 来代表 UTF-8 字符串，包括输入、输出和文件名，非常简单。不过，由于一个字符单位不能代表一个完整的 Unicode 字符，在需要真正进行文字处理的场合转换到 UTF-32 往往会更简单。在以前及需要和 C 兼容的场合，会使用 wchar_t、uint32_t 或某个等价的类型别名；在新的纯 C++ 代码里，就没有理由不使用 char32_t 和 u32string 了。</p>
<p>Unix 下输出宽字符串需要使用 wcout（这点和 Windows 相同），并且需要进行区域设置，通常使用 setlocale(LC_ALL, “en_US.UTF-8”); 即足够。由于没有什么额外好处，Unix 平台下一般只用 cout，不用 wcout。</p>
</li>
<li>
<p>Windows</p>
<p>Windows 由于历史原因和保留向后兼容性的需要（Windows 为了向后兼容性已经到了大规模放弃优雅的程度了），一直用 char 表示传统编码（如，英文 Windows 上是 Windows-1252，简体中文 Windows 上是 GBK），用 wchar_t 表示 UTF-16。由于传统编码一次只有一种、且需要重启才能生效，要得到好的多语言支持，在和操作系统交互时必须使用 UTF-16。</p>
<p>对于纯 Windows 编程，全面使用宽字符（串）是最简单的处理方式。当然，源代码和文本很少用 UTF-16 存储，通常还是 UTF-8（除非是纯 ASCII，否则需要加入 BOM 字符来和传统编码相区分）。这时可能会有一个小小的令人惊讶的地方：微软的编译器会把源代码里窄字符串字面量中的非 ASCII 字符转换成传统编码。换句话说，同样的源代码在不同编码的 Windows 下编译可能会产生不同的结果！如果你希望保留 UTF-8 序列的话，就应该使用 UTF-8 字面量（并在将来使用 char8_t 字符类型）。</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dump</span><span class="params">(<span class="type">const</span> T&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : str) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(ch));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="type">char</span> u8str[] = <span class="string">u8&quot;你好&quot;</span>;</span><br><span class="line">    <span class="built_in">dump</span>(str);</span><br><span class="line">    <span class="built_in">dump</span>(u8str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面展示的是以上代码在 Windows 下系统传统编码设置为简体中文时的编译、运行结果：</p>
<p>text</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c4 e3 ba c3 00</span><br><span class="line">e4 bd a0 e5 a5 bd 00</span><br></pre></td></tr></table></figure>
<p>Windows 下的 wcout 主要用在配合宽字符的输出，此外没什么大用处。原因一样，只有进行了正确的区域设置，才能输出含非 ASCII 字符的宽字符串。如果要输出中文，得写 setlocale(LC_ALL, “Chinese_China.936”);，这显然就让”统一码”输出失去意义了。</p>
<p>由于窄字符在大部分 Windows 系统上只支持传统编码，要打开一个当前编码不支持的文件名称，就必需使用宽字符的文件名。微软的 fstream 系列类及其 open 成员函数都支持 const wchar_t* 类型的文件名，这是 C++ 标准里所没有的。</p>
</li>
</ol>
<h4 id="11-5-统一化处理">11.5 统一化处理</h4>
<p>要想写出跨平台的处理字符串的代码，我们一般考虑两种方式之一：</p>
<ul>
<li>源代码级兼容，但内码不同</li>
<li>源代码和内码都完全兼容</li>
</ul>
<p>微软推荐的方式一般是前者。做 Windows 开发的人很多都知道 tchar.h 和 _T 宏，它们就起着类似的作用（虽然目的不同）。根据预定义宏的不同，系统会在同一套代码下选择不同的编码方式及对应的函数。拿一个最小的例子来说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    _putts(_T(<span class="string">&quot;Hello world!\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用缺省的命令行参数进行编译，上面的代码相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果在命令行上加上了 /D_UNICODE，那代码则相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _putws(<span class="string">L&quot;Hello world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个代码还是只能在 Windows 上用，并且仍然不漂亮（所有的字符和字符串字面量都得套上 _T）。后者无解，前者则可以找到替代方案（甚至自己写也不复杂）。C++ REST SDK 中就提供了类似的封装，可以跨平台地开发网络应用。但可以说，这种方式是一种主要照顾 Windows 的开发方式。</p>
<p>相应的，对 Unix 开发者而言更自然的方式是全面使用 UTF-8，仅在跟操作系统、文件系统打交道时把字符串转换成需要的编码。利用临时对象的生命周期，我们可以像下面这样写帮助函数和宏。</p>
<p>utf8_to_native.hpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTF8_TO_NATIVE_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTF8_TO_NATIVE_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32) || defined(_UNICODE)</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::wstring <span class="title">utf8_to_wstring</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;</span><br><span class="line"><span class="function">std::wstring <span class="title">utf8_to_wstring</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NATIVE_STR(s) utf8_to_wstring(s).c_str()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">to_c_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">to_c_str</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NATIVE_STR(s) to_c_str(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UTF8_TO_NATIVE_HPP</span></span></span><br></pre></td></tr></table></figure>
<p>utf8_to_native.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utf8_to_native.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32) || defined(_UNICODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">throw_system_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">msg</span><span class="params">(reason)</span></span>;</span><br><span class="line">    msg += <span class="string">&quot; failed&quot;</span>;</span><br><span class="line">    <span class="function">std::error_code <span class="title">ec</span><span class="params">(GetLastError(), std::system_category())</span></span>;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(ec, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/* unnamed namespace */</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::wstring <span class="title">utf8_to_wstring</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, str, <span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">throw_system_error</span>(<span class="string">&quot;utf8_to_wstring&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::wstring <span class="title">result</span><span class="params">(len - <span class="number">1</span>, <span class="string">L&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, str, <span class="number">-1</span>, result.<span class="built_in">data</span>(), len) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">throw_system_error</span>(<span class="string">&quot;utf8_to_wstring&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::wstring <span class="title">utf8_to_wstring</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">utf8_to_wstring</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在头文件里，定义了在 Windows 下会做 UTF-8 到 UTF-16 的转换；在其他环境下则不真正做转换，而是不管提供的是字符指针还是 string 都会转换成字符指针。在 Windows 下每次调用 NATIVE_STR 会生成一个临时对象，当前语句执行结束后这个临时对象会自动销毁。</p>
<p>使用该功能的代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utf8_to_native.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> filename[] = <span class="string">u8&quot;测试.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(NATIVE_STR(filename))</span></span>;</span><br><span class="line">    <span class="comment">// 对 ifs 进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这样的代码可以同时适用于现代 Unix 和现代 Windows（任何语言设置下），用来读取名为”测试.txt”的文件。</p>
<h4 id="11-6-编程支持">11.6 编程支持</h4>
<p>快速介绍一下其他的一些支持 Unicode 及其转换的 API。</p>
<ol>
<li>
<p>Windows API</p>
<p>上一节的代码在 Windows 下用到了 MultiByteToWideChar [12]，从某个编码转到 UTF-16。Windows 也提供了反向的 WideCharToMultiByte [13]，从 UTF-16 转到某个编码。从上面可以看到，C 接口用起来并不方便，可以考虑自己封装一下。</p>
</li>
<li>
<p>iconv</p>
<p>Unix 下最常用的底层编码转换接口是 iconv [14]，提供 iconv_open、iconv_close 和 iconv 三个函数。这同样是 C 接口，实践中应该封装一下。</p>
</li>
<li>
<p>ICU4C</p>
<p>ICU [15] 是一个完整的 Unicode 支持库，提供大量的方法，ICU4C 是其 C/C++ 的版本。ICU 有专门的字符串类型，内码是 UTF-16，但可以直接用于 IO streams 的输出。下面的程序应该在所有平台上都有同样的输出（但在 Windows 上要求当前系统传统编码能支持待输出的字符）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unicode/unistr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unicode/ustream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> icu::UnicodeString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> str = UnicodeString::<span class="built_in">fromUTF8</span>(<span class="string">u8&quot;你好&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    string u8str;</span><br><span class="line">    str.<span class="built_in">toUTF8String</span>(u8str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In UTF-8 it is &quot;</span> &lt;&lt; u8str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>codecvt</p>
<p>C++11 曾经引入了一个头文件 <code>&lt;codecvt&gt;</code> [16] 用作 UTF 编码间的转换，但很遗憾，那个头文件目前已因为存在安全性和易用性问题被宣告放弃（deprecated）[17]。<code>&lt;locale&gt;</code> 中有另外一个 codecvt 模板 [18]，本身接口不那么好用，而且到 C++20 还会发生变化，这儿也不详细介绍了。有兴趣的话可以直接看参考资料。</p>
</li>
</ol>
<h4 id="11-7-参考资料">11.7 参考资料</h4>
<ol>
<li>Wikipedia, “ASCII”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ASCII">https://en.wikipedia.org/wiki/ASCII</a></li>
<li>Wikipedia, “EBCDIC”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/EBCDIC">https://en.wikipedia.org/wiki/EBCDIC</a></li>
<li>Wikipedia, “GB 2312”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GB_2312">https://en.wikipedia.org/wiki/GB_2312</a></li>
<li>Wikipedia, “EUC-CN”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN">https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN</a></li>
<li>Wikipedia, “GBK”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GBK_(character_encoding)">https://en.wikipedia.org/wiki/GBK_(character_encoding)</a></li>
<li>Wikipedia, “Unicode”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a></li>
<li>Wikipedia, “UTF-32”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-32">https://en.wikipedia.org/wiki/UTF-32</a></li>
<li>Wikipedia, “UTF-16”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a></li>
<li>Wikipedia, “UTF-8”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-8">https://en.wikipedia.org/wiki/UTF-8</a></li>
<li>吴咏炜, “Specify LANG in a UTF-8 web page”. <a target="_blank" rel="noopener" href="http://wyw.dcweb.cn/lang_utf8.htm">http://wyw.dcweb.cn/lang_utf8.htm</a></li>
<li>Wikipedia, “Byte order mark”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byte_order_mark">https://en.wikipedia.org/wiki/Byte_order_mark</a></li>
<li>Microsoft, “MultiByteToWideChar function”.<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-multibytetowidechar">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-multibytetowidechar</a></li>
<li>Microsoft, “WideCharToMultiByte function”.<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-widechartomultibyte">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-widechartomultibyte</a></li>
<li>Wikipedia, “iconv”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Iconv">https://en.wikipedia.org/wiki/Iconv</a></li>
<li>ICU Technical Committee, ICU—International Components for Unicode. <a target="_blank" rel="noopener" href="http://site.icu-project.org/">http://site.icu-project.org/</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “<code>Standard library header &lt;codecvt&gt;</code>“. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/codecvt">https://en.cppreference.com/w/cpp/header/codecvt</a></li>
<li>Alisdair Meredith, “<code>Deprecating &lt;codecvt&gt;</code>“. <a target="_blank" rel="noopener" href="http://www.openstd.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html">http://www.openstd.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::codecvt”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/locale/codecvt">https://en.cppreference.com/w/cpp/locale/codecvt</a></li>
</ol>
<h3 id="12-编译期多态：泛型编程和模板入门">12 | 编译期多态：泛型编程和模板入门</h3>
<h4 id="12-1-面向对象和多态">12.1 面向对象和多态</h4>
<p>在面向对象的开发里，最基本的一个特性就是”多态” [1]——用相同的代码得到不同结果。</p>
<p>在很多动态类型语言里，有所谓的”鸭子”类型 [2]：</p>
<blockquote>
<p>如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子。</p>
</blockquote>
<p>鸭子类型使得开发者可以不使用继承体系来灵活地实现一些”约定”，尤其是使得混合不同来源、使用不同对象继承体系的代码成为可能。唯一的要求只是，这些不同的对象有”共通”的成员函数。这些成员函数应当有相同的名字和相同结构的参数（并不要求参数类型相同）。</p>
<p>来看一下 C++ 中的具体例子。</p>
<h4 id="12-2-容器类的共性">12.2 容器类的共性</h4>
<p>容器类是有很多共性的。其中，一个最最普遍的共性就是，容器类都有 begin 和 end 成员函数——这使得通用地遍历一个容器成为可能。容器类不必继承一个共同的 Container 基类，而我们仍然可以写出通用的遍历容器的代码，如使用基于范围的循环。</p>
<p>大部分容器是有 size 成员函数的，在”泛型”编程中，我们同样可以取得一个容器的大小，而不要求容器继承一个叫 SizeableContainer 的基类。</p>
<p>很多容器具有 push_back 成员函数，可以在尾部插入数据。同样，我们不需要一个叫 BackPushableContainer 的基类。在这个例子里，push_back 函数的参数显然是都不一样的，但明显，所有的 push_back 函数都只接收一个参数。</p>
<p>我们可以清晰看到的是，虽然 C++ 的标准容器没有对象继承关系，但彼此之间有着很多的同构性。这些同构性很难用继承体系来表达，也完全不必要用继承来表达。C++ 的模板，已经足够表达这些鸭子类型。</p>
<h4 id="12-3-C-模板">12.3 C++ 模板</h4>
<ol>
<li>
<p>定义模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_gcd</span><span class="params">(E a, E b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="built_in">E</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        E r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对于”整数”这只鸭子的要求实际上是：</p>
<ul>
<li>
<p>可以通过常量 0 来构造</p>
</li>
<li>
<p>可以拷贝（构造和赋值）</p>
</li>
<li>
<p>可以作不等于的比较</p>
</li>
<li>
<p>可以进行取余数的操作</p>
<p>对于标准的 int、long、long long 等类型及其对应的无符号类型，以上代码都能正常工作，并能得到正确的结果。</p>
<p>至于类模板的例子，我们可以直接参考 [第 2 讲] 中的智能指针。</p>
</li>
</ul>
</li>
<li>
<p>实例化模板</p>
<p>不管是类模板还是函数模板，编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。一般而言，这也是编译器会报错的时候。</p>
<p>当我们在使用 <code>vector&lt;int&gt;</code> 这样的表达式时，我们就在隐式地实例化 <code>vector&lt;int&gt;</code>。我们同样也可以选择用 <code>template class vector&lt;int&gt;</code>; 来显式实例化，或使用 <code>extern template class vector&lt;int&gt;</code>; 来告诉编译器不需要实例化。显式实例化和外部实例化通常在大型项目中可以用来集中模板的实例化，从而加速编译过程——不需要在每个用到模板的地方都进行实例化了——但这种方式有额外的管理开销，如果实例化了不必要实例化的模板的话，反而会导致可执行文件变大。因而，显式实例化和外部实例化应当谨慎使用。</p>
</li>
<li>
<p>特化模板</p>
<blockquote>
<p>通用而言，Herb Sutter 给出了明确的建议：对函数使用重载，对类模板进行特化 [3]。</p>
</blockquote>
<p>展示特化的更好的例子是 C++11 之前的静态断言。使用特化技巧可以大致实现 static_assert 的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compile_time_error</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compile_time_error</span>&lt;<span class="literal">true</span>&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC_ASSERT(Expr, Msg)       \</span></span><br><span class="line"><span class="meta">    &#123;                                  \</span></span><br><span class="line"><span class="meta">        compile_time_error<span class="string">&lt;bool(Expr)&gt;</span> \</span></span><br><span class="line"><span class="meta">            ERROR_##_Msg;              \</span></span><br><span class="line"><span class="meta">        (void)ERROR_##_Msg;            \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面首先声明了一个 struct 模板，然后仅对 true 的情况进行了特化，产生了一个 struct 的定义。这样。如果遇到 <code>compile_time_error&lt;false&gt;</code> 的情况——也就是下面静态断言里的 Expr 不为真的情况——编译就会失败报错，因为 <code>compile_time_error&lt;false&gt;</code> 从来就没有被定义过。</p>
</li>
</ol>
<h4 id="12-4-“动态”多态和”静态”多态的对比">12.4 “动态”多态和”静态”多态的对比</h4>
<p>我前面描述了面向对象的”动态”多态，也描述了 C++ 里基于泛型编程的”静态”多态。需要看到的是，两者解决的实际上是不太一样的问题。”动态”多态解决的是运行时的行为<br>
变化。”静态”多态或者”泛型”——解决的是很不同的问题，让适用于不同类型的”同构”算法可以用同一套代码来实现，实际上强调的是对代码的复用。</p>
<p>C++ 里提供了很多标准算法，都一样只作出了基本的约定，然后对任何满足约定的类型都可以工作。以排序为例，C++ 里的标准 sort 算法（以两参数的重载为例）只要求：</p>
<ul>
<li>参数满足随机访问迭代器的要求。</li>
<li>迭代器指向的对象之间可以使用 &lt; 来比较大小，满足严格弱序关系。</li>
<li>迭代器指向的对象可以被移动。</li>
</ul>
<p>它的性能超出 C 的 qsort，因为编译器可以内联（inline）对象的比较操作；而在 C 里面比较只能通过一个额外的函数调用来实现。此外，C 的 qsort 函数要求数组指向的内容是可按比特复制的，C++ 的 sort 则要求迭代器指向的内容是可移动的，可适用于更广的情况。</p>
<h4 id="12-5-参考资料">12.5 参考资料</h4>
<p>[1] Wikipedia, “Polymorphism”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">https://en.wikipedia.org/wiki/Polymorphism_(computer_science)</a><br>
[2] Wikipedia, “Duck typing”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Duck_typing">https://en.wikipedia.org/wiki/Duck_typing</a><br>
[3] Herb Sutter, “Why not specialize function templates?”. <a target="_blank" rel="noopener" href="http://www.gotw.ca/publications/mill17.htm">http://www.gotw.ca/publications/mill17.htm</a></p>
<h3 id="13-编译期能做些什么？一个完整的计算世界">13 | 编译期能做些什么？一个完整的计算世界</h3>
<p><strong>模板的另外一种重要用途——编译期计算，也称作”模板元编程”。</strong></p>
<p>介绍：模板元编程（Template Metaprogramming）能够在编译期计算出结果的原因在于它的定义和执行方式。C++ 编译器在编译期间解析和实例化模板，这使得模板的计算可以在代码生成之前完成。这种机制允许我们在编译期执行一些计算和逻辑操作，而不是等到运行期。</p>
<p>先简单来看几个模板的例子：</p>
<p><strong>1. 编译期展开</strong></p>
<p>当编译器遇到模板时，它会根据具体的模板参数展开模板并生成相应的代码。这个过程发生在编译期，因此所有涉及模板的计算也在编译期完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = Factorial&lt;<span class="number">5</span>&gt;::value;  <span class="comment">// 编译期计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 静态常量表达式</strong></p>
<p>模板元编程中的计算结果通常存储在 <code>constexpr</code> 或 <code>static const</code> 变量中，这些变量在编译期就可以确定它们的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = Square&lt;<span class="number">4</span>&gt;::value;  <span class="comment">// 编译期计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 模板递归</strong></p>
<p>模板元编程中的递归展开机制允许编译器在编译期进行复杂的递归计算。例如，计算斐波那契数列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = Fibonacci&lt;<span class="number">10</span>&gt;::value;  <span class="comment">// 编译期计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译期，编译器将递归展开 <code>Fibonacci&lt;10&gt;</code> 的计算，最终得到结果 <code>55</code>。</p>
<p><strong>4. 类型元编程</strong></p>
<p>除了数值计算，模板元编程还支持类型级别的计算。编译器在编译期通过模板生成和操作类型。例如，条件选择类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Condition, <span class="keyword">typename</span> TrueType, <span class="keyword">typename</span> FalseType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Conditional</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = TrueType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TrueType, <span class="keyword">typename</span> FalseType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Conditional</span>&lt;<span class="literal">false</span>, TrueType, FalseType&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = FalseType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> SelectedType = Conditional&lt;(<span class="built_in">sizeof</span>(<span class="type">int</span>) &gt; <span class="number">4</span>), <span class="type">long</span>, <span class="type">int</span>&gt;::type;  <span class="comment">// 编译期选择类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板元编程能够在编译期计算出结果的原因在于：</p>
<ol>
<li><strong>编译期展开</strong>：模板在编译期间实例化和展开。</li>
<li><strong>静态常量表达式</strong>：使用 <code>constexpr</code> 或 <code>static const</code> 变量，计算结果在编译期确定。</li>
<li><strong>模板递归</strong>：允许复杂的递归计算在编译期进行。</li>
<li><strong>类型元编程</strong>：支持在编译期进行类型级别的计算和选择。</li>
</ol>
<h4 id="13-1-编译期计算">13.1 编译期计算</h4>
<p>首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 [1]。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = n * factorial&lt;n - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面定义了一个递归的阶乘函数。</p>
<p>那我们怎么知道这个计算是不是在编译时做的呢？我们可以直接看编译输出。下面直接贴出对上面这样的代码加输出（<code>printf(&quot;%d\n&quot;, factorial&lt;10&gt;::value);</code>）在 x86-64 下的编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">    .string &quot;%d\n&quot;</span><br><span class="line">main:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line">    mov esi, 3628800</span><br><span class="line">    mov edi, OFFSET FLAT:.LC0</span><br><span class="line">    mov eax, 0</span><br><span class="line">    call printf</span><br><span class="line">    mov eax, 0</span><br><span class="line">    pop rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>我们可以明确看到，编译结果里明明白白直接出现了常量 3628800。</p>
<p>可以看到，要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。比如，下面的模板可以代表条件语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> cond, <span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>&lt;<span class="literal">true</span>, Then, Else&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Then type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>&lt;<span class="literal">false</span>, Then, Else&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Else type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If 模板有三个参数，第一个是布尔值，后面两个则是代表不同分支计算的类型，这个类型可以是我们上面定义的任何一个模板实例，包括 If 和 factorial。第一个 struct 声明规定了模板的形式，然后我们不提供通用定义，而是提供了两个特化。第一个特化是真的情况，定义结果 type 为 Then 分支；第二个特化是假的情况，定义结果 type 为 Else 分支。</p>
<p>循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> condition, <span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>&lt;<span class="literal">true</span>, Body&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> WhileLoop&lt;Body::cond_value, <span class="keyword">typename</span> Body::next_type&gt;::typetype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>&lt;<span class="literal">false</span>, Body&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Body::res_type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">While</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> WhileLoop&lt;Body::cond_value, Body&gt;::type type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个循环的模板定义稍复杂点。首先，我们对循环体类型有一个约定，它必须提供一个静态数据成员，cond_value，及两个子类型定义，res_type 和 next_type：</p>
<ul>
<li>cond_value 代表循环的条件（真或假）</li>
<li>res_type 代表退出循环时的状态</li>
<li>next_type 代表下面循环执行一次时的状态</li>
</ul>
<p>如果你之前模板用得不多的话，还有一个需要了解的细节，就是用 :: 取一个成员类型、并且 :: 左边有模板参数的话，得额外加上 typename 关键字来标明结果是一个类型。上面循环模板的定义里就出现了多次这样的语法。MSVC 在这方面往往比较宽松，不写 typename 也不会报错，但这是不符合 C++ 标准的用法。</p>
<p>为了进行计算，我们还需要通用的代表数值的类型。下面这个模板可以通用地代表一个整数常数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> T value = v;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> integral_constant type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>integral_constant 模板同时包含了整数的类型和数值，而通过这个类型的 value 成员我们又可以重新取回这个数值。有了这个模板的帮忙，我们就可以进行一些更通用的计算了。下面这个模板展示了如何使用循环模板来完成从 1 加到 n 的计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> result, <span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SumLoop</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> cond_value = n != <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> res_value = result;</span><br><span class="line">    <span class="keyword">typedef</span> integral_constant&lt;<span class="type">int</span>, res_value&gt; res_type;</span><br><span class="line">    <span class="keyword">typedef</span> SumLoop&lt;result + n, n - <span class="number">1</span>&gt; next_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> SumLoop&lt;<span class="number">0</span>, n&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后你使用 <code>While&lt;Sum&lt;10&gt;::type&gt;::type::value</code> 就可以得到 1 加到 10 的结果。虽然有点绕，但代码实质就是在编译期间进行了以下的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    result = result + n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-2-编译期类型推导">13.2 编译期类型推导</h4>
<p>C++ 标准库在 <code>&lt;type_traits&gt;</code> 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）[2]。和上一节给出的例子相似，这些特点既是类型，又是常值。</p>
<p>为了方便地在值和类型之间转换，标准库定义了一些经常需要用到的工具类。上面描述的 integral_constant 就是其中一个（我的定义有所简化）。为了方便使用，针对布尔值有两个额外的类型定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;<span class="type">bool</span>, <span class="literal">true</span>&gt; true_type;</span><br><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;<span class="type">bool</span>, <span class="literal">false</span>&gt; false_type;</span><br></pre></td></tr></table></figure>
<p>这两个标准类型 true_type 和 false_type 经常可以在函数重载中见到。有一个工具函数常常会写成下面这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _destroy(ptr, <span class="built_in">is_trivially_destructible</span>&lt;T&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> _destroy(T* ptr, true_type)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> _destroy(T* ptr, false_type)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似上面，很多容器类里会有一个 destroy 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用 is_trivially_destructible 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 true_type，要么是 false_type。如果要得到布尔值的话，当然使用 <code>is_trivially_destructible&lt;T&gt;::value</code> 就可以，但此处不需要。我们需要的是，使用 () 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。</p>
<p>除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 remove_const 为例（用来去除类型里的 const 修饰），它的定义大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，它也是利用模板的特化，针对 const 类型去掉相应的修饰。比如，如果我们对 const string&amp; 应用 remove_const，就会得到 string&amp;，即， <code>remove_const&lt;const string&amp;&gt;::type</code> 等价于 string&amp;。</p>
<p>这里有一个细节你要注意一下，如果对 <code>const char*</code> 应用 remove_const 的话，结果还是 <code>const char*</code>。原因是，<code>const char*</code> 是指向 const char 的指针，而不是指向 char 的 const 指针。如果我们对 <code>char * const</code> 应用 remove_const 的话，还是可以得到 <code>char*</code> 的。</p>
<h4 id="13-3-简易写法">13.3 简易写法</h4>
<p>如果你觉得写 <code>is_trivially_destructible&lt;T&gt;::value</code> 和 <code>remove_const&lt;T&gt;::type</code> 非常啰嗦的话，那你绝不是一个人。在当前的 C++ 标准里，前者有增加 <code>_v</code> 的编译时常量，后者有增加 <code>_t</code> 的类型别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_trivially_destructible_v = is_trivially_destructible&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>
<p>至于什么是 constexpr，我们会单独讲。using 是现代 C++ 的新语法，功能大致与 typedef 相似，但 typedef 只能针对某个特定的类型，而 using 可以生成别名模板。目前我们只需要知道，在你需要 trait 模板的结果数值和类型时，使用带 <code>_v</code> 和 <code>_t</code> 后缀的模板可能会更方便，尤其是带 <code>_t</code> 后缀的类型转换模板。</p>
<h4 id="13-4-通用的-fmap-函数模板">13.4 通用的 fmap 函数模板</h4>
<p>你应当多多少少听到过 map-reduce。抛开其目前在大数据应用中的具体方式不谈，从概念本源来看，map [3] 和 reduce [4] 都来自函数式编程。下面我们演示一个 map 函数（当然，在 C++ 里它的名字就不能叫 map 了），其中用到了目前为止我们学到的多个知识点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OutContainer</span> = vector, <span class="keyword">typename</span> F, <span class="keyword">class</span> R&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">fmap</span>(F&amp;&amp; f, R&amp;&amp; inputs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(*inputs.<span class="built_in">begin</span>()))&gt; result_type;</span><br><span class="line">    OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; item : inputs) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">f</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们：</p>
<ul>
<li>用 decltype 来获得用 f 来调用 inputs 元素的类型（参考第 8 讲）；</li>
<li>用 decay_t 来把获得的类型变成一个普通的值类型；</li>
<li>缺省使用 vector 作为返回值的容器，但可以通过模板参数改为其他容器；</li>
<li>使用基于范围的 for 循环来遍历 inputs，对其类型不作其他要求（参考第 7 讲）；</li>
<li>存放结果的容器需要支持 push_back 成员函数（参考第 4 讲）。</li>
</ul>
<p>下面的代码可以验证其功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">fmap</span>(add_1, v);</span><br></pre></td></tr></table></figure>
<p>在 fmap 执行之后，我们会在 result 里得到一个新容器，其内容是 2, 3, 4, 5, 6。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">OutContainer</span> = vector,</span><br><span class="line">    <span class="keyword">typename</span> F, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">fmap</span>(F &amp;&amp;f, R &amp;&amp;inputs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> result_type = <span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(*inputs.<span class="built_in">begin</span>()))&gt;;</span><br><span class="line">    OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;item : inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">f</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的 vector 作为返回容器</span></span><br><span class="line">    <span class="keyword">auto</span> result_vector = <span class="built_in">fmap</span>(add_1, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : result_vector) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 list 作为返回容器</span></span><br><span class="line">    <span class="keyword">auto</span> result_list = <span class="built_in">fmap</span>&lt;list&gt;(add_1, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : result_list) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>template &lt;typename, typename&gt; class OutContainer = vector</code>：这是一个模板模板参数，表示返回的容器类型。默认情况下，它是 <code>std::vector</code>。它接收两个模板参数：元素类型和分配器类型。</p>
<h4 id="13-5-参考资料">13.5 参考资料</h4>
<ol>
<li>Todd L. Veldhuizen, “C++ templates are Turing complete”. <a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “<code>Standard library header &lt;type_traits&gt;</code>“. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a></li>
<li>Wikipedia, “Map (higher-order function)”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">https://en.wikipedia.org/wiki/Map_(higher-order_function)</a></li>
<li>Wikipedia, “Fold (higher-order function)”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a></li>
</ol>
<h3 id="14-SFINAE：不是错误的替换失败是怎么回事">14 | SFINAE：不是错误的替换失败是怎么回事?</h3>
<p>讲模板里的一个特殊概念——替换失败非错（substituion failure is not an error），英文简称为SFINAE。</p>
<p>在开始之前，先简单看看概念。</p>
<p>SFINAE（替换失败非错误）是 C++ 模板元编程中的一个特殊概念，它指的是当模板参数替换失败时，编译器不会报错，而是会忽略这个模板并尝试其他可能的重载。</p>
<p><strong>具体说明</strong></p>
<p>在函数模板的重载决议过程中，当一个函数名称和某个函数模板名称匹配时，编译器会：</p>
<ol>
<li>根据名称找出所有适用的函数和函数模板。</li>
<li>对于适用的函数模板，根据实际参数对模板形参进行替换。如果在替换过程中发生错误，这个模板会被丢弃，而不是报错。</li>
<li>在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配并调用它。</li>
<li>如果没有找到最佳匹配，或者找到多个匹配程度相当的函数，编译器会报错。</li>
</ol>
<p>举个例子：假设我们有两个模板函数，一个用于处理整型，一个用于处理其他类型。在这两个函数模板中，我们使用 SFINAE 技术来决定哪个模板是适用的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板1：用于处理整型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板2：用于处理非整型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">process</span>(i); <span class="comment">// 调用第一个模板函数</span></span><br><span class="line">    <span class="built_in">process</span>(d); <span class="comment">// 调用第二个模板函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SFINAE 常用于模板元编程，以提供以下功能：</p>
<ol>
<li><strong>函数模板重载</strong>：根据模板参数的特性选择合适的模板实例化。</li>
<li><strong>类型特征检测</strong>：通过检测类型特性（如是否为整型）来选择不同的实现。</li>
<li><strong>实现条件编译</strong>：根据不同的类型特性或编译条件，选择不同的模板代码路径。</li>
</ol>
<h4 id="14-1-函数模板的重载决议">14.1 函数模板的重载决议</h4>
<p>今天来着重看一个函数模板的情况。当一个函数名称和某个函数模板名称匹配时，重载决议过程大致如下：</p>
<ul>
<li>根据名称找出所有适用的函数和函数模板</li>
<li>对于适用的函数模板，要根据实际情况对模板形参进行替换；替换过程中如果发生错误，这个模板会被丢弃</li>
<li>在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配，产生对该函数的调用</li>
<li>如果没有找到最佳匹配，或者找到多个匹配程度相当的函数，则编译器需要报错</li>
</ul>
<p>一个具体的例子（改编自参考资料 [1]）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>&lt;Test&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>我们来分析一下。首先看 <code>f&lt;Test&gt;(10);</code> 的情况：</p>
<ul>
<li>我们有两个模板符合名字 f</li>
<li>替换结果为 f(Test::foo) 和 f(Test)</li>
<li>使用参数 10 去匹配，只有前者参数可以匹配，因而第一个模板被选择</li>
</ul>
<p>再看一下 <code>f&lt;int&gt;(10)</code> 的情况：</p>
<ul>
<li>还是两个模板符合名字 f</li>
<li>替换结果为 f(int::foo) 和 f(int)；显然前者不是个合法的类型，被抛弃</li>
<li>使用参数 10 去匹配 f(int)，没有问题，那就使用这个模板实例了</li>
</ul>
<p>在这儿，体现的是 SFINAE 设计的最初用法：如果模板实例化中发生了失败，没有理由编译就此出错终止，因为还是可能有其他可用的函数重载的。</p>
<p>这儿的失败仅指函数模板的原型声明，即参数和返回值。函数体内的失败不考虑在内。如果重载决议选择了某个函数模板，而函数体在实例化的过程中出错，那我们仍然会得到一个编译错误。</p>
<h4 id="14-2-编译期成员检测">14.2 编译期成员检测</h4>
<p>编译期成员检测不过，很快人们就发现 SFINAE 可以用于其他用途。比如，根据某个实例化的成功或失败来在编译期检测类的特性。下面这个模板，就可以检测一个类是否有一个名叫 reserve、参数类型为 size_t 的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_reserve</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">        <span class="type">char</span> dummy;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bad</span> &#123;</span><br><span class="line">        <span class="type">char</span> dummy[<span class="number">2</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="built_in">void</span> (U::*)(<span class="type">size_t</span>)&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SFINAE</span> &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> good <span class="title">reserve</span><span class="params">(SFINAE&lt;U, &amp;U::reserve&gt;*)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> bad <span class="title">reserve</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="built_in">sizeof</span>(<span class="built_in">reserve</span>&lt;T&gt;(<span class="literal">nullptr</span>)) == <span class="built_in">sizeof</span>(good);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个模板里：</p>
<ul>
<li>我们首先定义了两个结构 good 和 bad；它们的内容不重要，我们只关心它们的大小必须不一样。</li>
<li>然后我们定义了一个 SFINAE 模板，内容也同样不重要，但模板的第二个参数需要是第一个参数的成员函数指针，并且参数类型是 size_t，返回值是 void。</li>
<li>随后，我们定义了一个要求 <code>SFINAE*</code> 类型的 reserve 成员函数模板，返回值是 good；再定义了一个对参数类型无要求的 reserve 成员函数模板（不熟悉 … 语法的，可以看参考资料 [2]），返回值是 bad。</li>
<li>最后，我们定义常整型布尔值 value，结果是 true 还是 false，取决于 nullptr 能不能和 <code>SFINAE*</code> 匹配成功，而这又取决于模板参数 T 有没有返回类型是 void、接受一个参数并且类型为 size_t 的成员函数 reserve。</li>
</ul>
<p>那这样的模板有什么用处呢？</p>
<h4 id="14-3-SFINAE-模板技巧">14.3 SFINAE 模板技巧</h4>
<ol>
<li><code>enable_if</code></li>
</ol>
<p>C++11 开始，标准库里有了一个叫 enable_if 的模板（定义在 <code>&lt;type_traits&gt;</code> 里），可以用它来选择性地启用某个函数的重载。</p>
<p>假设我们有一个函数，用来往一个容器尾部追加元素。我们希望原型是这个样子的：</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然，container 有没有 reserve 成员函数，是对性能有影响的——如果有的话，我们通常应该预留好内存空间，以免产生不必要的对象移动甚至拷贝操作。利用 enable_if 和 上面的 has_reserve 模板，我们就可以这么写：</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">enable_if_t</span>&lt;has_reserve&lt;C&gt;::value, <span class="type">void</span>&gt; <span class="built_in">append</span>(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    container.<span class="built_in">reserve</span>(container.<span class="built_in">size</span>() + size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">enable_if_t</span>&lt;!has_reserve&lt;C&gt;::value, <span class="type">void</span>&gt; <span class="built_in">append</span>(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enable_if_t&lt;has_reserve&lt;C&gt;::value, void&gt;</code> 的意思可以理解成：如果类型 C 有 reserve 成员的话，那我们启用下面的成员函数，它的返回类型为 void。</p>
<p>enable_if 的定义（其实非常简单）和它的进一步说明，请查看参考资料 [3]。参考资料里同时展示了一个通用技巧，可以用在构造函数（无返回值）或不想手写返回值类型的情况下。但那个写法更绕一些，不是必需要用的话，就采用上面那个写出返回值类型的写法吧。</p>
<p><strong><code>enable_if</code> 的基本用法</strong></p>
<p><code>enable_if</code> 有两个模板参数：</p>
<ul>
<li>第一个参数是一个布尔表达式，如果该表达式为 true，则 <code>enable_if</code> 将定义一个类型成员 <code>type</code>。</li>
<li>第二个参数是一个类型，默认是 <code>void</code>。</li>
</ul>
<p>当第一个参数为 true 时，<code>enable_if</code> 将定义一个类型成员 <code>type</code>，否则 <code>type</code> 不存在。</p>
<p><strong>示例代码</strong></p>
<p>以下是一个使用 <code>enable_if</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有在 T 是整型时，才启用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有在 T 是浮点型时，才启用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Floating point: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">10</span>);        <span class="comment">// 整型，调用第一个重载</span></span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">10.5</span>);      <span class="comment">// 浮点型，调用第二个重载</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>print_type是一个模板函数，有两个版本：</p>
<ul>
<li>第一个版本只在 <code>T</code> 是整型时启用。</li>
<li>第二个版本只在 <code>T</code> 是浮点型时启用。</li>
</ul>
<ol>
<li>
<p>通过 <code>std::enable_if</code> 和 <code>std::is_integral</code>、<code>std::is_floating_point</code> 组合，实现了条件编译。</p>
</li>
<li>
<p>在 <code>main</code> 函数中，根据传入的参数类型，编译器会选择合适的重载版本。</p>
</li>
<li>
<p>decltype 返回值</p>
<p>如果只需要在某个操作有效的情况下启用某个函数，而不需要考虑相反的情况的话，有另外一个技巧可以用。对于上面的 append 的情况，如果我们想限制只有具有 reserve 成员函数的类可以使用这个重载，我们可以把代码简化成：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">append</span><span class="params">(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(declval&lt;C&amp;&gt;().reserve(<span class="number">1U</span>), <span class="type">void</span>())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    container.<span class="built_in">reserve</span>(container.<span class="built_in">size</span>() + size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们第一次用到 declval [4]，需要简单介绍一下。这个模板用来声明一个某个类型的参数，但这个参数只是用来参加模板的匹配，不允许实际使用。使用这个模板，我们可以在某类型没有默认构造函数的情况下，假想出一个该类的对象来进行类型推导。</p>
<p><code>declval&lt;C&amp;&gt;().reserve(1U)</code> 用来测试 C&amp; 类型的对象是不是可以拿 1U 作为参数来调用 reserve 成员函数。此外，我们需要记得，C++ 里的逗号表达式的意思是按顺序逐个估值，并返回最后一项。所以，上面这个函数的返回值类型是 void。</p>
<p>这个方式和 enable_if 不同，很难表示否定的条件。如果要提供一个专门给<strong>没有</strong> reserve 成员函数的 C 类型的 append 重载，这种方式就不太方便了。因而，这种方式的主要用途是避免错误的重载。</p>
</li>
<li>
<p>void_t</p>
<p>void_t 是 C++17 新引入的一个模板 [5]。它的定义简单得令人吃惊：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br></pre></td></tr></table></figure>
<p>换句话说，这个类型模板会把任意类型映射到 void。它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个”任意类型”的有效性。利用 decltype、declval 和模板特化，我们可以把 has_reserve 的定义大大简化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void_t</span>&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> has_reserve : false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_reserve</span>&lt;T, <span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">declval</span>&lt;T&amp;&gt;().<span class="built_in">reserve</span>(<span class="number">1U</span>))&gt;&gt; : true_type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里第二个 has_reserve 模板的定义实际上是一个偏特化 [6]。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最”特别”的一个。像上面的例子，所有类型都能满足第一个模板，但不是所有的类型都能满足第二个模板，所以第二个更特别。当第二个模板能被满足时，编译器就会选择第二个特化的模板；而只有第二个模板不能被满足时，才会回到第一个模板的通用情况。</p>
<p>有了这个 has_reserve 模板，我们就可以继续使用其他的技巧，如 enable_if 和下面的标签分发，来对重载进行限制。</p>
</li>
<li>
<p>标签分发</p>
<p>在上一讲，我们提到了用 true_type 和 false_type 来选择合适的重载。这种技巧有个专门的名字，叫标签分发（tag dispatch）。我们的 append 也可以用标签分发来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> _append(C&amp; container, T* ptr, <span class="type">size_t</span> size, true_type)</span><br><span class="line">&#123;</span><br><span class="line">    container.<span class="built_in">reserve</span>(container.<span class="built_in">size</span>() + size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> _append(C&amp; container, T* ptr, <span class="type">size_t</span> size, false_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _append(container, ptr, size, integral_constant&lt;<span class="type">bool</span>, has_reserve&lt;C&gt;::value&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回想起上一讲里 true_type 和 false_type 的定义，你应该很容易看出这个代码跟使用 enable_if 是等价的。当然，在这个例子，标签分发并没有使用 enable_if 显得方便。作为一种可以替代 enable_if 的通用惯用法，你还是需要了解一下。</p>
<p>另外，如果我们用 void_t 那个版本的 has_reserve 模板的话，由于模板的实例会继承 false_type 或 true_type 之一，代码可以进一步简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _append(container, ptr, size, has_reserve&lt;C&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="14-4-静态多态的限制？">14.4 静态多态的限制？</h4>
<p>看到这儿，你可能会怀疑，为什么我们不能像在 Python 之类的语言里一样，直接写下面这样的代码呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (has_reserve&lt;C&gt;::value) &#123;</span><br><span class="line">        container.<span class="built_in">reserve</span>(container.<span class="built_in">size</span>() + size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你试验一下，就会发现，在 C 类型没有 reserve 成员函数的情况下，编译是不能通过的，会报错。这是因为 C++ 是静态类型的语言，所有的函数、名字必须在编译时被成功解析、确定。在动态类型的语言里，只要语法没问题，缺成员函数要执行到那一行上才会被发现。这赋予了动态类型语言相当大的灵活性；只不过，不能在编译时检查错误，同样也是很多人对动态类型语言的抱怨所在……</p>
<p>那在 C++ 里，我们有没有更好的办法呢？实际上是有的。具体方法，下回分解。</p>
<h4 id="14-5-参考资料">14.5 参考资料</h4>
<p>[1] Wikipedia, “Substitution failure is not an error”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a><br>
[2] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Variadic functions”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/variadic">https://en.cppreference.com/w/c/variadic</a><br>
[3] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::enable_if”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/enable_if">https://en.cppreference.com/w/cpp/types/enable_if</a><br>
[4] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::declval”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/declval">https://en.cppreference.com/w/cpp/utility/declval</a><br>
[5] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::void_t”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/void_t">https://en.cppreference.com/w/cpp/types/void_t</a><br>
[6] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Partial template specialization”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/partial_specialization">https://en.cppreference.com/w/cpp/language/partial_specialization</a></p>
<h3 id="15-constexpr：一个常态的世界">15 | constexpr：一个常态的世界</h3>
<p>在 C++11 引入、在 C++14 得到大幅改进的 constexpr 关键字的字面意思是 constant expression，常量表达式。存在两类 constexpr 对象：</p>
<ul>
<li>constexpr 变量</li>
<li>constexpr 函数</li>
</ul>
<p>补充：</p>
<ul>
<li><strong><code>constexpr</code> 变量</strong>：一个在编译时完全确定的常数。</li>
<li><strong><code>constexpr</code> 函数</strong>：至少对于某一组参数可以在编译期间产生一个常量。</li>
</ul>
<p>一个 constexpr 变量是一个编译时完全确定的常数。一个 constexpr 函数至少对于某一组实参可以在编译期间产生一个编译期常数。</p>
<p>注意一个 constexpr 函数不保证在所有情况下都会产生一个编译期常数（因而也是可以作为普通函数来使用的）。编译器也没法通用地检查这点。编译器唯一强制的是：</p>
<ul>
<li>constexpr 变量必须立即初始化</li>
<li>初始化只能使用字面量或常量表达式，后者不允许调用任何非 constexpr 函数</li>
</ul>
<p>constexpr 的实际规则当然稍微更复杂些，而且随着 C++ 标准的演进也有着一些变化，特别是对 constexpr 函数如何实现的要求在慢慢放宽。要了解具体情况包括其在不同 C++ 标准中的限制，可以查看参考资料 [1]。下面我们也会回到这个问题略作展开。</p>
<p>要检验一个 constexpr 函数能不能产生一个真正的编译期常量，可以把结果赋给一个 constexpr 变量。成功的话，我们就确认了，至少在这种调用情况下，我们能真正得到一个编译期常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// constexpr 变量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> constantValue = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// constexpr 函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 constexpr 函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 编译时计算</span></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;constantValue: &quot;</span> &lt;&lt; constantValue &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 使用 constexpr 函数作为普通函数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> runtimeResult = <span class="built_in">add</span>(x, y); <span class="comment">// 运行时计算</span></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;runtimeResult: &quot;</span> &lt;&lt; runtimeResult &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-constexpr-和编译期计算">15.2 constexpr 和编译期计算</h4>
<p>以 [第 13 讲] 提到的阶乘函数为例，和那个版本基本等价的写法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个问题：在这个 constexpr 函数里，是不能写 static_assert(n &gt;= 0) 的。一个 constexpr 函数仍然可以作为普通函数使用——显然，传入一个普通 int 是不能使用静态断言的。替换方法是在 factorial 的实现开头加入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Arg must be non-negative&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-3-constexpr-和-const">15.3 constexpr 和 const</h4>
<p>const 的原本和基础的含义，自然是表示它修饰的内容不会变化，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1</span>:</span><br><span class="line">n = <span class="number">2</span>; <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<p>本质上，const 用来表示一个<strong>运行时常量</strong>。</p>
<p>在 C++ 里，const 后面渐渐带上了现在的 constexpr 用法，也代表编译期常数。现在——在有了 constexpr 之后——我们应该使用 constexpr 在这些用法中替换 const 了。从编译器的角度，为了向后兼容性，const 和 constexpr 在很多情况下还是等价的。但有时候，它们也有些细微的区别，其中之一为是否内联的问题。</p>
<p><strong><code>const</code> 变量</strong></p>
<p><code>const</code> 变量是一个运行时常量，表示它的值不会在运行时改变。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeconst int n <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">// n <span class="operator">=</span> <span class="number">2</span><span class="comment">; // 出错，n 是一个常量，不能改变</span></span><br></pre></td></tr></table></figure>
<p><strong><code>constexpr</code> 变量</strong></p>
<p><code>constexpr</code> 变量是一个编译时常量，表示它的值在编译时就能确定。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeconstexpr int m <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">// m <span class="operator">=</span> <span class="number">3</span><span class="comment">; // 出错，m 是一个常量，不能改变</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码对比</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// const 变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// n = 2; // 出错，n 是一个常量，不能改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// constexpr 变量</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// m = 3; // 出错，m 是一个常量，不能改变</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m: &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>区别和使用场景</strong></p>
<ol>
<li><strong>运行时常量 vs 编译时常量</strong>：
<ul>
<li><code>const</code> 用于表示运行时常量。</li>
<li><code>constexpr</code> 用于表示编译时常量。</li>
</ul>
</li>
<li><strong>内联问题</strong>：
<ul>
<li><code>constexpr</code> 更适合用在需要编译时计算的情况下，它可以使得编译器在编译时就进行计算和优化。</li>
<li>在某些情况下，<code>constexpr</code> 比 <code>const</code> 更倾向于内联，从而提高程序的效率。</li>
</ul>
</li>
</ol>
<p><strong>例子展示细微区别</strong></p>
<p>考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);     <span class="comment">// 运行时常量</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> y = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 编译时常量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>x</code> 是一个 <code>const</code> 变量，它的值在运行时确定。</li>
<li><code>y</code> 是一个 <code>constexpr</code> 变量，它的值在编译时确定。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong><code>const</code></strong> 用于表示一个值在运行时不变。</li>
<li><strong><code>constexpr</code></strong> 用于表示一个值在编译时就能确定。</li>
<li>现代 C++ 更推荐使用 <code>constexpr</code> 来表示编译时常量，因为它可以使编译器在编译时进行更多优化。</li>
</ul>
<h4 id="15-4-内联变量">15.4 内联变量</h4>
<p>C++17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，const 缺省是不内联的，而 constexpr 缺省就是内联的。这种区别在你用 &amp; 去取一个 const int 值的地址、或将其传到一个形参类型为 const int&amp; 的函数去的时候（这在 C++ 文档里的行话叫 ODR-use），就会体现出来。</p>
<p>下面是个合法的完整程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">magic</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; magic::number &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们稍微改一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">magic</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">// 调用 push_back(const T&amp;)</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(magic::number);</span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在链接时就会报错了，说找不到 magic::number（注意：MSVC 缺省不报错，但使用标准模式——/Za 命令行选项——也会出现这个问题）。这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> magic::number = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>必须正正好好一个，多了少了都不行，所以叫 one definition rule。内联函数，现在又有了内联变量，以及模板，则不受这条规则限制。</p>
<p>修正这个问题的简单方法是把 magic 里的 static const 改成 static constexpr 或 static inline const。前者可行的原因是，类的静态 constexpr 成员变量默认就是内联的。const 常量和类外面的 constexpr 变量不默认内联，需要手工加 inline 关键字才会变成内联。</p>
<h4 id="15-5-constexpr-变量模板">15.5 constexpr 变量模板</h4>
<p>变量模板是 C++14 引入的新概念。之前我们需要用类静态数据成员来表达的东西，使用变量模板可以更简洁地表达。constexpr 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。由此，type traits 都获得了一种更简单的表示方式。再看一下我们在 <strong>[第13 讲]</strong> 用过的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_trivially_destructible_v = is_trivially_destructible&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>
<h4 id="15-6-constexpr-变量仍是-const">15.6 constexpr 变量仍是 const</h4>
<p>一个 constexpr 变量仍然是 const 常类型。需要注意的是，就像 const char* 类型是指向常量的指针、自身不是 const 常量一样，下面这个表达式里的 const 也是不能缺少的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure>
<p>第二行里，constexpr 表示 b 是一个编译期常量，const 表示这个引用是常量引用。去掉这个 const 的话，编译器就会认为你是试图将一个普通引用绑定到一个常数上，报一个类似下面的错误信息：</p>
<blockquote>
<p>error: binding reference of type ‘int&amp;’ to ‘const int’ discards qualifiers</p>
</blockquote>
<p>如果按照 const 位置的规则，constexpr const int&amp; b 实际该写成 const int&amp; constexpr b。不过，constexpr 不需要像 const 一样有复杂的组合，因此永远是写在类型前面的。</p>
<h4 id="15-7-constexpr-构造函数和字面类型">15.7 constexpr 构造函数和字面类型</h4>
<p>一个合理的 constexpr 函数，应当至少对于某一组编译期常量的输入，能得到编译期常量的结果。为此，对这个函数也是有些限制的：</p>
<ul>
<li>最早，constexpr 函数里连循环都不能有，但在 C++14 放开了。</li>
<li>目前，constexpr 函数仍不能有 try … catch 语句和 asm 声明，但到 C++20 会放开。</li>
<li>constexpr 函数里不能使用 goto 语句。</li>
<li>等等。</li>
</ul>
<p>一个有意思的情况是一个类的构造函数。如果一个类的构造函数里面只包含常量表达式、满足对 constexpr 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 constexpr 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何”副作用”，比如内存分配、输入、输出等等。</p>
<p>为了全面支持编译期计算，C++14 开始，很多标准类的构造函数和成员函数已经被标为 constexpr，以便在编译期使用。当然，大部分的容器类，因为用到了动态内存分配，不能成为字面类型。下面这些不使用动态内存分配的字面类型则可以在常量表达式中使用：</p>
<ul>
<li>array</li>
<li>initializer_list</li>
<li>pair</li>
<li>tuple</li>
<li>string_view</li>
<li>optional</li>
<li>variant</li>
<li>bitset</li>
<li>complex</li>
<li>chrono::duration</li>
<li>chrono::time_point</li>
<li>shared_ptr（仅限默认构造和空指针构造）</li>
<li>unique_ptr（仅限默认构造和空指针构造）</li>
<li>…</li>
</ul>
<h4 id="15-8-if-constexpr">15.8 if constexpr</h4>
<p>上一讲的结尾，我们给出了一个在类型参数 C 没有 reserve 成员函数时不能编译的代码：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(C&amp; container, T* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (has_reserve&lt;C&gt;::value) &#123;</span><br><span class="line">        container.<span class="built_in">reserve</span>(container.<span class="built_in">size</span>() + size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++17 里，我们只要在 if 后面加上 constexpr，代码就能工作了 [2]。当然，它要求括号里的条件是个编译期常量。满足这个条件后，标签分发、enable_if 那些技巧就不那么有用了。显然，使用 if constexpr 能比使用其他那些方式，写出更可读的代码……</p>
<h4 id="15-9-output-container-h-解读">15.9 output_container.h 解读</h4>
<p>到了今天，我们终于把 output_container.h（[3]）用到的 C++ 语法特性都讲过了，我们就拿里面的代码来讲解一下，让你加深对这些特性的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type trait to detect std::pair</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pair</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pair</span>&lt;std::pair&lt;T, U&gt;&gt; : std::true_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_pair_v = is_pair&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>
<p>这段代码利用模板特化（<strong>[第 12 讲]</strong> 、<strong>[第 14 讲]</strong>）和 false_type、true_type 类型（<strong>[第 13 讲]</strong>），定义了 is_pair，用来检测一个类型是不是 pair。随后，我们定义了内联 constexpr 变量（本讲）is_pair_v，用来简化表达。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type trait to detect whether an</span></span><br><span class="line"><span class="comment">// output function already exists</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_output_function</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">output</span><span class="params">(U* ptr)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; *ptr, std::true_type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">output</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">output</span>&lt;T&gt;(<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> has_output_function_v = has_output_function&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>
<p>这段代码使用 SFINAE 技巧（<strong>[第 14 讲]</strong>），来检测模板参数 T 的对象是否已经可以直接输出到 ostream。然后，一样用一个内联 constexpr 变量来简化表达。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output function for std::pair</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> std::pair&lt;T, U&gt;&amp; pr);</span><br></pre></td></tr></table></figure>
<p>再然后我们声明了一个 pair 的输出函数（标准库没有提供这个功能）。我们这儿只是声明，是因为我们这儿有两个输出函数，且可能互相调用。所以，我们要先声明其中之一。</p>
<p>下面会看到，pair 的通用输出形式是”(x, y)”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element output function for</span></span><br><span class="line"><span class="comment">// containers that define a key_type</span></span><br><span class="line"><span class="comment">// and have its value type as</span></span><br><span class="line"><span class="comment">// std::pair</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">output_element</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp; element, <span class="type">const</span> Cont&amp;, <span class="type">const</span> std::true_type)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;<span class="keyword">typename</span> Cont::key_type&gt;(), os)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Element output function for other</span></span><br><span class="line"><span class="comment">// containers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">output_element</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp; element, <span class="type">const</span> Cont&amp;, ...)</span> -&gt; <span class="title">decltype</span><span class="params">(os)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于容器成员的输出，我们也声明了两个不同的重载。我们的意图是，如果元素的类型是 pair 并且容器定义了一个 key_type 类型，我们就认为遇到了关联容器，输出形式为”x =&gt; y”（而不是”(x, y)”）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main output function, enabled</span></span><br><span class="line"><span class="comment">// only if no output function</span></span><br><span class="line"><span class="comment">// already exists</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;!has_output_function_v&lt;T&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> T&amp; container)</span><br><span class="line">    -&gt; <span class="keyword">decltype</span>(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>(), os)</span><br></pre></td></tr></table></figure>
<p>主输出函数的定义。注意这儿这个函数的启用有两个不同的 SFINAE 条件：</p>
<ul>
<li>用 decltype 返回值的方式规定了被输出的类型必须有 begin() 和 end() 成员函数。</li>
<li>用 enable_if_t 规定了只在被输出的类型没有输出函数时才启用这个输出函数。否则，对于 string 这样的类型，编译器发现有两个可用的输出函数，就会导致编译出错。</li>
</ul>
<p>我们可以看到，用 decltype 返回值的方式比较简单，不需要定义额外的模板。但表达否定的条件还是要靠 enable_if。此外，因为此处是需要避免有二义性的重载，constexpr 条件语句帮不了什么忙。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> element_type = <span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(*container.<span class="built_in">begin</span>())&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_char_v = is_same_v&lt;element_type, <span class="type">char</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!is_char_v)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对非字符类型，我们在开始输出时，先输出”{ “。这儿使用了 decay_t，是为了把类型里的引用和 const/volatile 修饰去掉，只剩下值类型。如果容器里的成员是 char，这儿会把 char&amp; 和 const char&amp; 还原成 char。</p>
<p>后面的代码就比较简单了。可能唯一需要留意的是下面这句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">output_element</span>(os, *it, container, <span class="built_in">is_pair</span>&lt;element_type&gt;());</span><br></pre></td></tr></table></figure>
<p>这儿我们使用了标签分发技巧来输出容器里的元素。要记得，output_element 不纯粹使用标签分发，还会检查容器是否有 key_type 成员类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">output_element</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp; element, <span class="type">const</span> Cont&amp;, <span class="type">const</span> std::true_type)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;<span class="keyword">typename</span> Cont::key_type&gt;(), os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; element.first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; element.second;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">output_element</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp; element, <span class="type">const</span> Cont&amp;, ...)</span> -&gt; <span class="title">decltype</span><span class="params">(os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; element;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output_element 的两个重载的实现都非常简单，应该不需要解释了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> std::pair&lt;T, U&gt;&amp; pr)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; pr.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pr.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，pair 的输出的实现也非常简单。</p>
<p>唯一需要留意的，是上面三个函数的输出内容可能还是容器，因此我们要将其实现放在后面，确保它能看到我们的通用输出函数。</p>
<p>要看一下用到 output_container 的例子，可以回顾 <strong>[第 4 讲]</strong> 和 <strong>[第 5 讲]</strong>。</p>
<h4 id="15-10-参考资料">15.10 参考资料</h4>
<ol>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “constexpr specifier”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr">https://en.cppreference.com/w/cpp/language/constexpr</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “if statement”, section “constexpr if”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/if">https://en.cppreference.com/w/cpp/language/if</a></li>
<li>吴咏炜, output_container. <a target="_blank" rel="noopener" href="https://github.com/adah1972/output_container/blob/master/output_container.h">https://github.com/adah1972/output_container/blob/master/output_container.h</a></li>
</ol>
<h3 id="16-函数对象和lambda：进入函数式编程">16 | 函数对象和lambda：进入函数式编程</h3>
<h4 id="16-1-C-98-的函数对象">16.1 C++98 的函数对象</h4>
<p>函数对象（function object）[1] 自 C++98 开始就已经被标准化了。从概念上来说，函数对象是一个可以被当作函数来用的对象。它有时也会被叫做 functor，但这个术语在范畴论里有着完全不同的含义，还是不用为妙——否则玩函数式编程的人可能会朝着你大皱眉头的。</p>
<p>下面的代码定义了一个简单的加 n 的函数对象类（根据一般的惯例，我们使用了 struct关键字而不是 class 关键字）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">adder</span> &#123;</span><br><span class="line">    <span class="built_in">adder</span>(<span class="type">int</span> n)</span><br><span class="line">        : <span class="built_in">n_</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + n_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它看起来相当普通，唯一有点特别的地方就是定义了一个 operator()，这个运算符允许我们像调用函数一样使用小括号的语法。随后，我们可以定义一个实际的函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_2 = <span class="built_in">adder</span>(<span class="number">2</span>); <span class="comment">// C++11 风格</span></span><br><span class="line"><span class="function">adder <span class="title">add_2</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// C++98 风格</span></span><br></pre></td></tr></table></figure>
<p>得到的结果 add_2 就可以当作一个函数来用了。你如果写下 add_2(5) 的话，就会得到结果 7。</p>
<p>C++98 里也定义了少数高阶函数：你可以传递一个函数对象过去，结果得到一个新的函数对象。最典型的也许是目前已经从 C++17 标准里移除的 bind1st 和 bind2nd 了（在 <code>&lt;functional&gt;</code> 头文件中提供）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_2 = <span class="built_in">bind2nd</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这样产生的 add_2 功能和前面相同，是把参数 2 当作第二个参数绑定到函数对象 plus（它的 operator() 需要两个参数）上的结果。当然，auto 在 C++98 里是没有的，结果要赋给一个变量就有点别扭了，得写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder2nd&lt;plus&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">add_2</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="16-2-函数的指针和引用">16.2 函数的指针和引用</h4>
<p>除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。不管是函数指针还是函数引用，你也都可以当成函数对象来用。</p>
<p>假设我们有下面的函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们有下面的模板声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test1</span><span class="params">(T fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fn</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test2</span><span class="params">(T&amp; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fn</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test3</span><span class="params">(T* fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fn)(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们拿 add_2 去调用这三个函数模板时，fn 的类型将分别被推导为 <code>int (*)(int)</code>、 <code>int (&amp;)(int)</code> 和 <code>int (*)(int)</code>。不管我们得到的是指针还是引用，我们都可以直接拿它当普通的函数用。当然，在函数指针的情况下，我们直接写 *value 也可以。因而上面三个函数拿 add_2 作为实参调用的结果都是 4。</p>
<p>很多接收函数对象的地方，也可以接收函数的指针或引用。但在个别情况下，需要通过函数对象的类型来区分函数对象的时候，就不能使用函数指针或引用了——原型相同的函数，它们的类型也是相同的。</p>
<h4 id="16-3-Lambda-表达式">16.3 Lambda 表达式</h4>
<p>看一下上一节给出的代码在使用 lambda 表达式时可以如何简化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_2 = [](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然，定义 add_2 不再需要定义一个额外的类型了，我们可以直接写出它的定义。理解它只需要注意下面几点：</p>
<ul>
<li>Lambda 表达式以一对中括号开始（中括号中是可以有内容的；稍后我们再说）跟函数定义一样，我们有参数列表</li>
<li>跟正常的函数定义一样，我们会有一个函数体，里面会有 return 语句</li>
<li>Lambda 表达式一般不需要说明返回值（相当于 auto）；有特殊情况需要说明时，则应使用箭头语法的方式（参见**[第 8 讲]**）：[] (int x) -&gt; int { … }</li>
<li>每个 lambda 表达式都有一个全局唯一的类型，要精确捕捉 lambda 表达式到一个变量中，只能通过 auto 声明的方式</li>
</ul>
<p>当然，我们想要定义一个通用的 adder 也不难</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> adder = [](<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> [n](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + n;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这次我们直接返回了一个 lambda 表达式，并且中括号中写了 n 来捕获变量 n 的数值。这个函数的实际效果和前面的 adder 函数对象完全一致。也就是说，捕获 n 的效果相当于在一个函数对象中用成员变量存储其数值。</p>
<p>一个 lambda 表达式除了没有名字之外，还有一个特点是你可以立即进行求值。这就使得我们可以把一段独立的代码封装起来，达到更干净、表意的效果。</p>
<p>先看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这个表达式的结果是 3 的平方 9。即使这个看似无聊的例子，都是有意义的，因为它免去了我们定义一个 constexpr 函数的必要。只要能满足 constexpr 函数的条件，一个 lambda 表达式默认就是 constexpr 函数。</p>
<h4 id="16-4-变量捕获">16.4 变量捕获</h4>
<p>变量捕获的开头是可选的默认捕获符 = 或 &amp;，表示会自动按值或按引用捕获用到的本地变量，然后后面可以跟（逗号分隔）：</p>
<ul>
<li>本地变量名标明对其按值捕获（不能在默认捕获符 = 后出现；因其已自动按值捕获所有本地变量）</li>
<li>&amp; 加本地变量名标明对其按引用捕获（不能在默认捕获符 &amp; 后出现；因其已自动按引用捕获所有本地变量）</li>
<li>this 标明按引用捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况）；注意默认捕获符 = 和 &amp; 号可以自动捕获 this（并且在 C++20 之前，在 = 后写 this 会导致出错）</li>
<li>*this 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）</li>
<li>变量名 = 表达式 标明按值捕获表达式的结果（可理解为 auto 变量名 = 表达式）</li>
<li>&amp;变量名 = 表达式 标明按引用捕获表达式的结果（可理解为 auto&amp; 变量名 = 表达式）</li>
</ul>
<p>从工程的角度，大部分情况不推荐使用默认捕获符。更一般化的一条工程原则是：<strong>显式的代码比隐式的代码更容易维护</strong>。</p>
<p>一般而言，按值捕获是比较安全的做法。按引用捕获时则需要更小心些，必须能够确保被捕获的变量和 lambda 表达式的生命期至少一样长，并在有下面需求之一时才使用：</p>
<ul>
<li>需要在 lambda 表达式中修改这个变量并让外部观察到</li>
<li>需要看到这个变量在外部被修改的结果</li>
<li>这个变量的复制代价比较高</li>
</ul>
<p>如果希望以移动的方式来捕获某个变量的话，则应考虑 变量名 = 表达式 的形式。表达式可以返回一个 prvalue 或 xvalue，比如可以是 std::move(需移动捕获的变量)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">task</span>(<span class="type">int</span> data)</span><br><span class="line">        : <span class="built_in">data_</span>(data)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">lazy_launch</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        [*<span class="keyword">this</span>, count = <span class="built_in">get_count</span>()]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">            ostringstream oss;</span><br><span class="line">            oss &lt;&lt; <span class="string">&quot;Done work &quot;</span> &lt;&lt; data_</span><br><span class="line">                &lt;&lt; <span class="string">&quot; (No. &quot;</span> &lt;&lt; count</span><br><span class="line">                &lt;&lt; <span class="string">&quot;) in thread &quot;</span></span><br><span class="line">                &lt;&lt; this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            msg_ = oss.<span class="built_in">str</span>();</span><br><span class="line">            <span class="built_in">calculate</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">        cout &lt;&lt; msg_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">    string msg_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = task &#123; <span class="number">37</span> &#125;;</span><br><span class="line">    thread t1 &#123; t.<span class="built_in">lazy_launch</span>() &#125;;</span><br><span class="line">    thread t2 &#123; t.<span class="built_in">lazy_launch</span>() &#125;;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子稍复杂，演示了好几个 lambda 表达式的特性：</p>
<ul>
<li>mutable 标记使捕获的内容可更改（缺省不可更改捕获的值，相当于定义了 operator()(…) const）；</li>
<li>[*this] 按值捕获外围对象（task）；</li>
<li>[count = get_count()] 捕获表达式可以在生成 lambda 表达式时计算并存储等号后表达式的结果。</li>
</ul>
<p>这样，多个线程复制了任务对象，可以独立地进行计算。请自行运行一下代码，并把 <code>*this</code> 改成 this，看看输出会有什么不同。</p>
<h4 id="16-5-泛型-lambda-表达式">16.5 泛型 lambda 表达式</h4>
<p>函数的返回值可以 auto，但参数还是要一一声明的。在 lambda 表达式里则更进一步，在参数声明时就可以使用 auto（包括 auto&amp;&amp; 等形式）。不过，它的功能也不那么神秘，就是给你自动声明了模板而已。毕竟，在 lambda 表达式的定义过程中是没法写 template 关键字的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟上面的函数等价的 lambda 表达式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sum = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能要问，这么写有什么用呢？问得好。简单来说，答案是可组合性。上面这个 sum，就跟标准库里的 plus 模板一样，是可以传递给其他接受函数对象的函数的，而 + 本身则不行。下面的例子虽然略有点无聊，也可以演示一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> <span class="comment">// std::array</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout/endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// std::accumulate</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array a &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">accumulate</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>,</span><br><span class="line">        [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然函数名字叫 accumulate——累加——但它的行为是通过第四个参数可修改的。我们把上面的加号 + 改成星号 *，上面的计算就从从 1 加到 5 变成了算 5 的阶乘了。</p>
<h4 id="16-6-bind-模板">16.6 bind 模板</h4>
<p>我们上面提到了 bind1st 和 bind2nd 目前已经从 C++ 标准里移除。原因实际上有两个：</p>
<ul>
<li>它的功能可以被 lambda 表达式替代</li>
<li>有了一个更强大的 bind 模板 [5]</li>
</ul>
<p>拿我们之前给出的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>现在我们可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// for _1, _2...</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), <span class="built_in">bind</span>(plus&lt;&gt;(), _1, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>原先我们只能把一个给定的参数绑定到第一个参数或第二个参数上，现在则可以非常自由地适配各种更复杂的情况！当然，bind 的参数数量，必须是第一个参数（函数对象）所需的参数数量加一。而 bind 的结果的参数数量则没有限制——你可以无聊地写出 <code>bind(plus&lt;&gt;(), _1, _3)(1, 2, 3)</code>，而结果是 4（完全忽略第二个参数）。</p>
<p>你可能会问，它的功能是不是可以被 lambda 表达式替代呢。回答是”是”。对 bind 只需要稍微了解一下就好——在 C++14 之后的年代里，已经没有什么地方必须要使用 bind 了。</p>
<h4 id="16-7-function-模板">16.7 function 模板</h4>
<p>每一个 lambda 表达式都是一个单独的类型，所以只能使用 auto 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用 function 模板 [6]。function 模板的参数就是函数的类型，一个函数对象放到 function 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。注意 function 对象的创建还是比较耗资源的，所以请你只在用 auto 等方法解决不了问题的时候使用这个模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; op_dict &#123;</span><br><span class="line">    &#123; <span class="string">&quot;+&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">         <span class="keyword">return</span> x + y;</span><br><span class="line">     &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;-&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">         <span class="keyword">return</span> x - y;</span><br><span class="line">     &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;*&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">         <span class="keyword">return</span> x * y;</span><br><span class="line">     &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;/&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">         <span class="keyword">return</span> x / y;</span><br><span class="line">     &#125; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这儿，由于要把函数对象存到一个 map 里，我们必须使用 function 模板。随后，我们就可以用类似于 op_dict.at(“+”)(1, 6) 这样的方式来使用 function 对象。这种方式对表达式的解析处理可能会比较有用。</p>
<h4 id="16-8-参考资料">16.8 参考资料</h4>
<p>[1] Wikipedia, “Function object”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Function_object">https://en.wikipedia.org/wiki/Function_object</a><br>
[2] Wikipedia, “Anonymous function”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Anonymous_function">https://en.wikipedia.org/wiki/Anonymous_function</a><br>
[3] Wikipedia, “Lambda calculus”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a><br>
[4] Wikipedia, “Currying”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a><br>
[5] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::bind”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/functional/bind">https://en.cppreference.com/w/cpp/utility/functional/bind</a><br>
[6] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::function”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/functional/function">https://en.cppreference.com/w/cpp/utility/functional/function</a></p>
<h3 id="17-函数式编程：一种越来越流行的编程范式">17 | 函数式编程：一种越来越流行的编程范式</h3>
<p>大致了解下函数式编程先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数示例：计算两个数的和</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数示例：接受一个函数和一个值，并返回另一个函数</span></span><br><span class="line"><span class="function">std::function&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">createAdder</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x](<span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数组合和不可变性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::transform 来应用一个函数到向量的每个元素</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(vec.size())</span></span>;</span><br><span class="line">    std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">2</span>;  <span class="comment">// 纯函数，没有副作用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用纯函数</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用高阶函数</span></span><br><span class="line">    <span class="keyword">auto</span> addFive = <span class="built_in">createAdder</span>(<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 10 = &quot;</span> &lt;&lt; <span class="built_in">addFive</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用不可变性和函数组合处理向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">processVector</span>(numbers);  <span class="comment">// 输出：2 4 6 8 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的代码里不那么明显的一点是，函数式编程期望函数的行为像数学上的函数，而非一个计算机上的子程序。这样的函数一般被称为纯函数（pure function），要点在于：</p>
<ul>
<li>会影响函数结果的只是函数的参数，没有对环境的依赖</li>
<li>返回的结果就是函数执行的唯一后果，不产生对环境的其他影响</li>
</ul>
<p>我们的代码中也体现了其他一些函数式编程的特点：</p>
<ul>
<li>函数就像普通的对象一样被传递、使用和返回。</li>
<li>代码为说明式而非命令式。在熟悉函数式编程的基本范式后，你会发现说明式代码的可读性通常比命令式要高，代码还短。</li>
<li>一般不鼓励（甚至完全不使用）可变量。上面代码里只有 count 的内容在执行过程中被修改了，而且这种修改实际是 transform 接口带来的。如果接口像 <strong>[第 13 讲]</strong> 展示的 fmap 函数一样返回一个容器的话，就可以连这个问题都消除了。（C++ 毕竟不是一门函数式编程语言，对灵活性的追求压倒了其他考虑。）</li>
</ul>
<h4 id="17-3-高阶函数">17.3 高阶函数</h4>
<p>既然函数（对象）可以被传递、使用和返回，自然就有函数会接受函数作为参数或者把函数作为返回值，这样的函数就被称为高阶函数。我们现在已经见过不少高阶函数了，如：</p>
<ul>
<li>sort</li>
<li>transform</li>
<li>accumulate</li>
<li>fmap</li>
<li>adder</li>
</ul>
<p>事实上，C++ 里以 algorithm（算法）[3] 名义提供的很多函数都是高阶函数。</p>
<p>许多高阶函数在函数式编程中已成为基本的惯用法，在不同语言中都会出现，虽然可能是以不同的名字。我们在此介绍非常常见的三个，map（映射）、reduce（归并）和 filter（过滤）。</p>
<p>Map 在 C++ 中的直接映射是 transform（在 <code>&lt;algorithm&gt;</code> 头文件中提供）。它所做的事情也是数学上的映射，把一个范围里的对象转换成相同数量的另外一些对象。这个函数的基本实现非常简单，但这是一种强大的抽象，在很多场合都用得上。</p>
<p>Reduce 在 C++ 中的直接映射是 accumulate（在 <code>&lt;numeric&gt;</code> 头文件中提供）。它的功能是在指定的范围里，使用给定的初值和函数对象，从左到右对数值进行归并。在不提供函数对象作为第四个参数时，功能上相当于默认提供了加法函数对象，这时相当于做累加；提供了其他函数对象时，那当然就是使用该函数对象进行归并了。</p>
<p>Filter 的功能是进行过滤，筛选出符合条件的成员。它在当前 C++（C++20 之前）里的映射可以认为有两个：copy_if 和 partition。这是因为在 C++20 带来 ranges 之前，在 C++ 里实现惰性求值不太方便。上面说的两个函数里，copy_if 是把满足条件的元素拷贝到另外一个迭代器里；partition 则是根据过滤条件来对范围里的元素进行分组，把满足条件的放在返回值迭代器的前面。另外，remove_if 也有点相近，通常用于删除满足条件的元素。它确保把不满足条件的元素放在返回值迭代器的前面（但不保证满足条件的元素在函数返回后一定存在），然后你一般需要使用容器的 erase 成员函数来将待删除的元素真正删除。</p>
<h4 id="17-4-命令式编程和说明式编程">17.4 命令式编程和说明式编程</h4>
<p>传统上 C++ 属于命令式编程。命令式编程里，代码会描述程序的具体执行步骤。好处是代码显得比较直截了当；缺点就是容易让人只见树木、不见森林，只能看到代码啰嗦地怎么做（how），而不是做什么（what），更不用说为什么（why）了。</p>
<p>说明式编程则相反。以数据库查询语言 SQL 为例，SQL 描述的是类似于下面的操作：你想从什么地方（from）选择（select）满足什么条件（where）的什么数据，并可选指定排序（order by）或分组（group by）条件。你不需要告诉数据库引擎具体该如何去执行这个操作。事实上，在选择查询策略上，大部分数据库用户都不及数据库引擎”聪明”；正如大部分开发者在写出优化汇编代码上也不及编译器聪明一样。</p>
<p>这并不是说说明式编程一定就优于命令式编程。事实上，对于很多算法，命令式才是最自然的实现。</p>
<p>所以，我个人认为，说明式编程跟命令式编程可以结合起来产生既优雅又高效的代码。对于从命令式编程成长起来的大部分程序员，我的建议是：</p>
<ul>
<li>写表意的代码，不要过于专注性能而让代码难以维护——记住高德纳的名言：”过早优化是万恶之源。”</li>
<li>使用有意义的变量，但尽量不要去修改变量内容——变量的修改非常容易导致程序员的思维错误。</li>
<li>类似地，尽量使用没有副作用的函数，并让你写的代码也尽量没有副作用，用返回值来代表状态的变化——没有副作用的代码更容易推理，更不容易出错。</li>
<li>代码的隐式依赖越少越好，尤其是不要使用全局变量——隐式依赖会让代码里的错误难以排查，也会让代码更难以测试。</li>
<li>使用知名的高级编程结构，如基于范围的 for 循环、映射、归并、过滤——这可以让你的代码更简洁，更易于推理，并减少类似下标越界这种低级错误的可能性。</li>
</ul>
<p>这些跟函数式编程有什么关系呢？——这些差不多都是来自函数式编程的最佳实践。学习函数式编程，也是为了更好地体会如何从这些地方入手，写出易读而又高性能的代码。</p>
<h4 id="17-5-不可变性和并发">17.5 不可变性和并发</h4>
<p>在多核的时代里，函数式编程比以前更受青睐，一个重要的原因是函数式编程对并行并发天然友好。影响多核性能的一个重要因素是数据的竞争条件——由于共享内存数据需要加锁带来的延迟。函数式编程强调不可变性（immutability）、无副作用，天然就适合并发。更妙的是，如果你使用高层抽象的话，有时可以轻轻松松”免费”得到性能提升。</p>
<p>拿我们这一讲开头的例子来说，对代码做下面的改造，启用 C++17 的并行执行策略 [5]，就能自动获得在多核环境下的性能提升：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_lines</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** begin, <span class="type">const</span> <span class="type">char</span>** end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(end - begin)</span></span>;</span><br><span class="line">    <span class="built_in">transform</span>(execution::par, begin, end, count.<span class="built_in">begin</span>(), count_file);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>(execution::par, count.<span class="built_in">begin</span>(), count.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，两个高阶函数的调用中都加入了 execution::par，来启动自动并行计算。要注意的是，我把 accumulate 换成了 reduce [6]，原因是前者已经定义成从左到右的归并，无法并行。reduce 则不同，初始值可以省略，操作上没有规定顺序，并反过来要求对元素的归并操作满足交换律和结合率（加法当然是满足的）。</p>
<h4 id="17-6-Y-组合子">17.6 Y 组合子</h4>
<p>限于篇幅，这一讲我们只是很初浅地探讨了函数式编程。对于 C++ 的函数式编程的深入探讨是有整本书的（见参考资料 [8]），而今天讲的内容在书的最前面几章就覆盖完了。在后面，我们还会探讨部分的函数式编程话题；今天我们只再讨论一个有点有趣、也有点烧脑的话题，Y 组合子 [9]。第一次阅读的时候，如果觉得困难，可以跳过这一部分。</p>
<p>不过，我并不打算讨论 Haskell Curry 使用的 Y 组合子定义——这个比较复杂，需要写一篇完整的文章来讨论（[10]），而且在 C++ 中的实用性非常弱。</p>
<h4 id="17-7-参考资料">17.7 参考资料</h4>
<p>[1] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::transform”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a><br>
[2] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::accumulate”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a><br>
[3] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “<code>Standard library header &lt;algorithm&gt;</code>“. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/algorithm">https://en.cppreference.com/w/cpp/header/algorithm</a><br>
[4] 袁英杰, “Immutability: The Dark Side”. <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/13cd4c650125">https://www.jianshu.com/p/13cd4c650125</a><br>
[5] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “<code>Standard library header &lt;execution&gt;</code>“. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/execution">https://en.cppreference.com/w/cpp/header/execution</a><br>
[6] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::reduce”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/reduce">https://en.cppreference.com/w/cpp/algorithm/reduce</a><br>
[7] Intel, tbb. <a target="_blank" rel="noopener" href="https://github.com/intel/tbb">https://github.com/intel/tbb</a><br>
[8] Ivan Čukić, Functional Programming in C++. Manning, 2019, <a target="_blank" rel="noopener" href="https://www.manning.com/books/functional-programming-in-c-plus-plus">https://www.manning.com/books/functional-programming-in-c-plus-plus</a><br>
[9] Wikipedia, “Fixed-point combinator”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fixedpoint_combinator">https://en.wikipedia.org/wiki/Fixedpoint_combinator</a><br>
[10] 吴咏炜, “Y Combinator and C++”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/">https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/</a></p>
<h3 id="18-应用可变模板和tuple的编译期技巧">18 | 应用可变模板和tuple的编译期技巧</h3>
<p>如何使用可变模板和 tuple 来完成一些常见的功能，尤其是编译期计算。</p>
<h4 id="18-1-可变模板">18.1 可变模板</h4>
<p>可变模板 [1] 是 C++11 引入的一项新功能，使我们可以在模板参数里表达不定个数和类型的参数。从实际的角度，它有两个明显的用途：</p>
<ul>
<li>用于在通用工具模板中转发参数到另外一个函数</li>
<li>用于在递归的模板中表达通用的情况（另外会有至少一个模板特化来表达边界情况）</li>
</ul>
<h4 id="18-2-转发用法">18.2 转发用法</h4>
<p>以标准库里的 make_unique 为例，它的定义差不多是下面这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，它就可以把传递给自己的全部参数转发到模板参数类的构造函数上去。注意，在这种情况下，我们通常会使用 std::forward，确保参数转发时仍然保持正确的左值或右值引用类型。</p>
<p>稍微解释一下上面三处出现的 …：</p>
<ul>
<li>typename… Args 声明了一系列的类型——class… 或 typename… 表示后面的标识符代表了一系列的类型。</li>
<li>Args&amp;&amp;… args 声明了一系列的形参 args，其类型是 Args&amp;&amp;。</li>
<li><code>forward&lt;Args&gt;(args)...</code> 会在编译时实际逐项展开 Args 和 args ，参数有多少项，展开后就是多少项。</li>
</ul>
<p>举一个例子，如果我们需要在堆上传递一个 <code>vector&lt;int&gt;</code>，假设我们希望初始构造的大小为 100，每个元素都是 1，那我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make_unique&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">100</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>模板实例化之后，会得到相当于下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> unique_ptr&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">make_unique</span>(<span class="type">int</span>&amp;&amp; arg1, <span class="type">int</span>&amp;&amp; arg2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> unique_ptr&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(forward&lt;<span class="type">int</span>&gt;(arg1), forward&lt;<span class="type">int</span>&gt;(arg2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所述，<code>forward&lt;Args&gt;(args)...</code> 为每一项可变模板参数都以同样的形式展开。项数也允许为零，那样，我们在调用构造函数时也同样没有任何参数。</p>
<h4 id="18-3-递归用法">18.3 递归用法</h4>
<p>我们也可以用可变模板来实现编译期递归。下面就是个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span>... Targ&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y, Targ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(x + y, args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的定义里，如果 sum 得到的参数只有一个，会走到上面那个重载。如果有两个或更多参数，编译器就会选择下面那个重载，执行一次加法，随后你的参数数量就少了一个，因而递归总会终止到上面那个重载，结束计算。</p>
<p>注意我们都不必使用相同的数据类型：只要这些数据之间可以应用 +，它们的类型无关紧要……</p>
<p>再看另一个复杂些的例子，函数的组合 [2]。如果我们有函数 f 和 函数 g ，要得到函数的联用 g ∘ f ，其满足：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">g</span> ∘ f )(<span class="name">x</span>) = g(<span class="name">f</span> (<span class="name">x</span>))</span><br></pre></td></tr></table></figure>
<p>我们能不能用一种非常简单的方式，写不包含变量 的表达式来表示函数组合呢？答案是肯定的。</p>
<p>跟上面类似，我们需要写出递归的终结情况，单个函数的”组合”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(F f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [f](<span class="keyword">auto</span>&amp;&amp;... x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(forward&lt;<span class="keyword">decltype</span>(x)&gt;(x)...);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们仅返回一个泛型 lambda 表达式，保证参数可以转发到 f。记得我们在 <strong>[第 16 讲]</strong> 讲过泛型 lambda 表达式，本质上就是一个模板，所以我们按转发用法的可变模板来理解上面的 … 部分就对了。</p>
<p>下面是正常有组合的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(F f, Args... other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [f, other...](<span class="keyword">auto</span>&amp;&amp;... x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">compose</span>(other...)(forward&lt;<span class="keyword">decltype</span>(x)&gt;(x)...));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个模板里，我们返回一个 lambda 表达式，然后用 f 捕捉第一个函数对象，用 args… 捕捉后面的函数对象。我们用 args… 继续组合后面的部分，然后把结果传到 f 里面。</p>
<p>上面的模板定义我实际上已经有所简化，没有保持值类别。完整的包含完美转发的版本，请看参考资料 [3] 中的 functional.h 实现。</p>
<p>下面我们来试验一下使用这个 compose 函数。我们先写一个对输入范围中每一项都进行平方的函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> square_list = [](<span class="keyword">auto</span>&amp;&amp; container) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fmap</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;, container);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们这儿用了泛型 lambda 表达式，是因为组合的时候不能使用模板，只能是函数对象或函数（指针）——如果我们定义一个 square_list 模板的话，组合时还得显式实例化才行（写成 <code>square_list&lt;const vector&lt;int&gt;&amp;&gt;</code> 的样子），很不方便。</p>
<p>我们再写一个求和的函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sum_list = [](<span class="keyword">auto</span>&amp;&amp; container) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那先平方再求和，就可以这样简单定义了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared_sum = <span class="built_in">compose</span>(sum_list, square_list);</span><br></pre></td></tr></table></figure>
<p>我们可以验证这个定义是可以工作的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">squared_sum</span>(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>我们会得到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure>
<h4 id="18-4-tuple">18.4 tuple</h4>
<p>上面的写法虽然看起来还不错，但实际上有个缺陷：被 compose 的函数除了第一个（最右边的），其他的函数只能接收一个参数。要想进一步推进类似的技巧，我们得首先解决这个问题。</p>
<p>在 C++ 里，要通用地用一个变量来表达多个值，那就得看多元组——tuple 模板了 [4]。tuple 算是 C++98 里的 pair 类型的一般化，可以表达任意多个固定数量、固定类型的值的组合。</p>
<ul>
<li>tuple 的成员数量由尖括号里写的类型数量决定。</li>
<li>可以使用 get 函数对 tuple 的内容进行读和写。（当一个类型在 tuple 中出现正好一次时，我们也可以传类型取内容，即，对我们上面的三元组，<code>get&lt;int&gt;</code> 是合法的，<code>get&lt;string&gt;</code> 则不是。）</li>
<li>可以用 <code>tuple_size_v</code> （在编译期）取得多元组里面的项数。</li>
</ul>
<p>我们已经有了参数的项数（使用 tuple_size_v），所以我们下面要做的是生成从 0 到项数减一之间的整数序列。标准库里已经定义了相关的工具，我们需要的就是其中的 make_index_sequence [5]，其简化实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integer_sequence</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">using</span> index_sequence = integer_sequence&lt;<span class="type">size_t</span>, Ints...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">index_sequence_helper</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> index_sequence_helper&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, Ints...&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">index_sequence_helper</span>&lt;<span class="number">0</span>, Ints...&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> index_sequence&lt;Ints...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> make_index_sequence = <span class="keyword">typename</span> index_sequence_helper&lt;N&gt;::type;</span><br></pre></td></tr></table></figure>
<p>正如一般的模板代码，它看起来还是有点绕的。其要点是，如果我们给出 <code>make_index_sequence&lt;N&gt;</code>，则结果是 <code>integer_sequence&lt;size_t, 0, 1, 2, …, N - 1&gt;</code>（一下子想不清楚的话，可以拿纸笔来模拟一下模板的<a target="_blank" rel="noopener" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPHN0cmluZz4KI2luY2x1ZGUgPHZlY3Rvcj4KI2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8dHVwbGU+CiNpbmNsdWRlIDx0eXBlX3RyYWl0cz4KCnRlbXBsYXRlIDxjbGFzcyBULCBULi4uIEludHM+CnN0cnVjdCBpbnRlZ2VyX3NlcXVlbmNlIHsKfTsKCnRlbXBsYXRlIDxzaXplX3QuLi4gSW50cz4KdXNpbmcgaW5kZXhfc2VxdWVuY2UgPSBpbnRlZ2VyX3NlcXVlbmNlPHNpemVfdCwgSW50cy4uLj47Cgp0ZW1wbGF0ZSA8c2l6ZV90IE4sIHNpemVfdC4uLiBJbnRzPgpzdHJ1Y3QgaW5kZXhfc2VxdWVuY2VfaGVscGVyIHsKICAgIHR5cGVkZWYgdHlwZW5hbWUgaW5kZXhfc2VxdWVuY2VfaGVscGVyPE4gLSAxLCBOIC0gMSwgSW50cy4uLj46OnR5cGUgdHlwZTsKfTsKCnRlbXBsYXRlIDxzaXplX3QuLi4gSW50cz4Kc3RydWN0IGluZGV4X3NlcXVlbmNlX2hlbHBlcjwwLCBJbnRzLi4uPiB7CiAgICB0eXBlZGVmIGluZGV4X3NlcXVlbmNlPEludHMuLi4+IHR5cGU7Cn07Cgp0ZW1wbGF0ZSA8c2l6ZV90IE4+CnVzaW5nIG1ha2VfaW5kZXhfc2VxdWVuY2UgPSB0eXBlbmFtZSBpbmRleF9zZXF1ZW5jZV9oZWxwZXI8Tj46OnR5cGU7CgppbnQgbWFpbigpCnsKICAgIG1ha2VfaW5kZXhfc2VxdWVuY2U8Mz4ge307Cn0=&amp;insightsOptions=cpp2a&amp;std=cpp2a&amp;rev=1.0">展开过程</a>）。而有了这样一个模板的帮助之后，我们就可以写出下面这样的函数（同样，这是标准库里的 apply<br>
函数模板 [6] 的简化版本）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>, <span class="type">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">apply_impl</span><span class="params">(F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">get</span>&lt;I&gt;(forward&lt;Tuple&gt;(t))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">apply</span><span class="params">(F&amp;&amp; f, Tuple&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">apply_impl</span>(</span><br><span class="line">        forward&lt;F&gt;(f),</span><br><span class="line">        forward&lt;Tuple&gt;(t),</span><br><span class="line">        make_index_sequence&lt;tuple_size_v&lt;<span class="type">remove_reference_t</span>&lt;Tuple&gt;&gt;&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们如果有一个三元组 t，类型为 <code>tuple&lt;int, string, string&gt;</code>，去 apply 到一个函数 f，展开后我们得到 <code>apply_impl(f, t, index_sequence&lt;0, 1, 2&gt;&#123;&#125;)</code>，再展开后我们就得到了上面那个有 <code>get&lt;0&gt;</code>、<code>get&lt;1&gt;</code>、<code>get&lt;2&gt;</code> 的函数调用形式。换句话说，我们利用一个计数序列的类型，可以在编译时展开 tuple 里的各个成员，并用来调用函数。</p>
<p>完整可运行代码（可以使用 <a target="_blank" rel="noopener" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPHN0cmluZz4KI2luY2x1ZGUgPHZlY3Rvcj4KI2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8dHVwbGU+CiNpbmNsdWRlIDx0eXBlX3RyYWl0cz4KCnRlbXBsYXRlIDxjbGFzcyBULCBULi4uIEludHM+CnN0cnVjdCBpbnRlZ2VyX3NlcXVlbmNlIHsKfTsKCnRlbXBsYXRlIDxzaXplX3QuLi4gSW50cz4KdXNpbmcgaW5kZXhfc2VxdWVuY2UgPSBpbnRlZ2VyX3NlcXVlbmNlPHNpemVfdCwgSW50cy4uLj47Cgp0ZW1wbGF0ZSA8c2l6ZV90IE4sIHNpemVfdC4uLiBJbnRzPgpzdHJ1Y3QgaW5kZXhfc2VxdWVuY2VfaGVscGVyIHsKICAgIHR5cGVkZWYgdHlwZW5hbWUgaW5kZXhfc2VxdWVuY2VfaGVscGVyPE4gLSAxLCBOIC0gMSwgSW50cy4uLj46OnR5cGUgdHlwZTsKfTsKCnRlbXBsYXRlIDxzaXplX3QuLi4gSW50cz4Kc3RydWN0IGluZGV4X3NlcXVlbmNlX2hlbHBlcjwwLCBJbnRzLi4uPiB7CiAgICB0eXBlZGVmIGluZGV4X3NlcXVlbmNlPEludHMuLi4+IHR5cGU7Cn07Cgp0ZW1wbGF0ZSA8c2l6ZV90IE4+CnVzaW5nIG1ha2VfaW5kZXhfc2VxdWVuY2UgPSB0eXBlbmFtZSBpbmRleF9zZXF1ZW5jZV9oZWxwZXI8Tj46OnR5cGU7Cgp0ZW1wbGF0ZSA8Y2xhc3MgRiwgY2xhc3MgVHVwbGUsIHNpemVfdC4uLiBJPgpjb25zdGV4cHIgZGVjbHR5cGUoYXV0bykgYXBwbHlfaW1wbChGJiYgZiwgVHVwbGUmJiB0LCBpbmRleF9zZXF1ZW5jZTxJLi4uPikKewogICAgcmV0dXJuIGYoc3RkOjpnZXQ8ST4oc3RkOjpmb3J3YXJkPFR1cGxlPih0KSkuLi4pOwp9Cgp0ZW1wbGF0ZSA8Y2xhc3MgRiwgY2xhc3MgVHVwbGU+CmNvbnN0ZXhwciBkZWNsdHlwZShhdXRvKSBhcHBseShGJiYgZiwgVHVwbGUmJiB0KQp7CiAgICByZXR1cm4gYXBwbHlfaW1wbCgKICAgICAgICBzdGQ6OmZvcndhcmQ8Rj4oZiksCiAgICAgICAgc3RkOjpmb3J3YXJkPFR1cGxlPih0KSwKICAgICAgICBtYWtlX2luZGV4X3NlcXVlbmNlPHN0ZDo6dHVwbGVfc2l6ZV92PHN0ZDo6cmVtb3ZlX3JlZmVyZW5jZV90PFR1cGxlPj4+IHt9KTsKfQoKdm9pZCBrKHN0ZDo6c3RyaW5nJiBzLCBpbnQmIG4sIHN0ZDo6dmVjdG9yPHN0ZDo6c3RyaW5nPiYgdikKewogICAgdXNpbmcgbmFtZXNwYWNlIHN0ZDsKICAgIGNvdXQgPDwgcyA8PCBlbmRsCiAgICAgICAgIDw8IG4gPDwgZW5kbDsKfQoKaW50IG1haW4oKQp7CiAgICBzdGQ6OnR1cGxlIHQgPSB7IHN0ZDo6c3RyaW5nKCJrIiksIDEwLCBzdGQ6OnZlY3RvcjxzdGQ6OnN0cmluZz4ge30gfTsKICAgIDo6YXBwbHkoaywgdCk7Cn0=&amp;insightsOptions=cpp2a&amp;std=cpp2a&amp;rev=1.0">cppinsights</a> 查看下面代码中模板展开的过程）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integer_sequence</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">using</span> index_sequence = integer_sequence&lt;<span class="type">size_t</span>, Ints...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">index_sequence_helper</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> index_sequence_helper&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, Ints...&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... Ints&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">index_sequence_helper</span>&lt;<span class="number">0</span>, Ints...&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> index_sequence&lt;Ints...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> make_index_sequence = <span class="keyword">typename</span> index_sequence_helper&lt;N&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>, <span class="type">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">apply_impl</span><span class="params">(F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(std::<span class="built_in">get</span>&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">apply</span><span class="params">(F&amp;&amp; f, Tuple&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">apply_impl</span>(</span><br><span class="line">        std::forward&lt;F&gt;(f),</span><br><span class="line">        std::forward&lt;Tuple&gt;(t),</span><br><span class="line">        make_index_sequence&lt;std::tuple_size_v&lt;std::<span class="type">remove_reference_t</span>&lt;Tuple&gt;&gt;&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">(std::string&amp; s, <span class="type">int</span>&amp; n, std::vector&lt;std::string&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl</span><br><span class="line">         &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple t = &#123; std::<span class="built_in">string</span>(<span class="string">&quot;k&quot;</span>), <span class="number">10</span>, std::vector&lt;std::string&gt; &#123;&#125; &#125;;</span><br><span class="line">    ::<span class="built_in">apply</span>(k, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-5-数值预算">18.5 数值预算</h4>
<p>我们下面看一个源自实际项目的例子。需求是，我们希望快速地计算一串二进制数中 1 比特的数量。举个例子，如果我们有十进制的 31 和 254，转换成二进制是 00011111 和 11111110，那我们应该得到 5 + 7 = 12。</p>
<p>显然，每个数字临时去数肯定会慢，我们应该预先把每个字节的 256 种情况记录下来。因而，如何得到这些计数值是个问题。在没有编译期编程时，我们似乎只能用另外一个程序先行计算，然后把结果填进去——这就很不方便很不灵活了。有了编译期编程，我们就不用写死，而让编译器在编译时帮我们计算数值。</p>
<p>利用 constexpr 函数，我们计算单个数值完全没有问题。快速定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">count_bits</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (value &amp; <span class="number">1</span>) + <span class="built_in">count_bits</span>(value &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可 256 个，总不见得把计算语句写上 256 遍吧？这就需要用到我们上面讲到的 index_sequence 了。我们定义一个模板，它的参数是一个序列，在初始化时这个模板会对参数里的每一项计算比特数，并放到数组成员里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... V&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_count_t</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> charcount[<span class="keyword">sizeof</span>...(V)] = &#123; <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="built_in">count_bits</span>(V))... &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上面用 sizeof…(V) 可以获得参数的个数（在 tuple_size_v 的实现里实际也用到它了）。如果我们模板参数传 0, 1, 2, 3，结果里面就会有个含 4 项元素的数组，数值分别是对 0、1、2、3 的比特计数。</p>
<p>然后，我们当然就可以利用 make_index_sequence 来展开计算了，想产生几项就可以产生几项。不过，要注意到 make_index_sequence 的结果是个类型，不能直接用在 bit_count_t 的构造中。我们需要用模板匹配来中转一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... V&gt;</span><br><span class="line"><span class="function"><span class="type">bit_count_t</span>&lt;V...&gt; <span class="title">get_bit_count</span><span class="params">(index_sequence&lt;V...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bit_count_t</span>&lt;V...&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bit_count = <span class="built_in">get_bit_count</span>(<span class="built_in">make_index_sequence</span>&lt;<span class="number">256</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>得到 bit_count 后，我们要计算一个序列里的比特数就只是轻松查表相加了，此处不再赘述。</p>
<h4 id="18-6-参考资料">18.6 参考资料</h4>
<p>[1] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “Parameter pack”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/parameter_pack">https://en.cppreference.com/w/cpp/language/parameter_pack</a><br>
[2] Wikipedia, “Function composition”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Function_composition">https://en.wikipedia.org/wiki/Function_composition</a><br>
[3] 吴咏炜, nvwa. <a target="_blank" rel="noopener" href="https://github.com/adah1972/nvwa">https://github.com/adah1972/nvwa</a><br>
[4] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::tuple”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/tuple">https://en.cppreference.com/w/cpp/utility/tuple</a><br>
[5] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::integer_sequence”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/integer_sequence">https://en.cppreference.com/w/cpp/utility/integer_sequence</a><br>
[6] <a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::apply”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/apply">https://en.cppreference.com/w/cpp/utility/apply</a></p>
<h3 id="19-thread和future：领略异步中的未来">19 | thread和future：领略异步中的未来</h3>
<h4 id="19-1-为什么要使用并发编程？">19.1 为什么要使用并发编程？</h4>
<p>如果你不熟悉进程和线程的话，我们就先来简单介绍一下它们的关系。我们编译完执行的 C++ 程序，那在操作系统看来就是一个进程了。而每个进程里可以有一个或多个线程：</p>
<ul>
<li>每个进程有自己的独立地址空间，不与其他进程分享；一个进程里可以有多个线程，彼此共享同一个地址空间。</li>
<li>堆内存、文件、套接字等资源都归进程管理，同一个进程里的多个线程可以共享使用。每个进程占用的内存和其他资源，会在进程退出或被杀死时返回给操作系统。</li>
<li>并发应用开发可以用多进程或多线程的方式。多线程由于可以共享资源，效率较高；反之，多进程（默认）不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低。但多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出。</li>
</ul>
<p>我们讲 C++ 里的并发，主要讲的就是多线程。它对开发人员的挑战是全方位的。从纯逻辑的角度，并发的思维模式就比单线程更为困难。在其之上，我们还得加上：</p>
<ul>
<li>编译器和处理器的重排问题</li>
<li>原子操作和数据竞争</li>
<li>互斥锁和死锁问题</li>
<li>无锁算法</li>
<li>条件变量</li>
<li>信号量</li>
<li>……</li>
</ul>
<p>即使对于专家，并发编程都是困难的，上面列举的也只是部分难点而已。对于并发的基本挑战，Herb Sutter 在他的 Effective Concurrency 专栏给出了一个较为全面的概述 [2]。要对 C++ 的并发编程有全面的了解，则可以阅读曼宁出版的 C++ Concurrency in Action（有中文版，但翻译口碑不好）[3]。而我们今天主要要介绍的，则是并发编程的基本概念，包括传统的多线程开发，以及高层抽象 future（姑且译为未来量）的用法。</p>
<h4 id="19-2-基于-thread-的多线程开发">19.2 基于 thread 的多线程开发</h4>
<p>以下几个地方可能需要稍加留意一下：</p>
<ul>
<li>thread 的构造函数的第一个参数是函数（对象），后面跟的是这个函数所需的参数。</li>
<li>thread 要求在析构之前要么 join（阻塞直到线程退出），要么 detach（放弃对线程的管理），否则程序会异常退出。</li>
<li>sleep_for 是 this_thread 名空间下的一个自由函数，表示当前线程休眠指定的时间。</li>
</ul>
<p>thread 不能在析构时自动 join 有点不那么自然，这可以算是一个缺陷吧。在 C++20 的 jthread [5] 到来之前，我们只能自己小小封装一下了。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Arg&gt;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(Arg&amp;&amp;... arg)</span><br><span class="line">        : <span class="built_in">thread_</span>(std::forward&lt;Arg&gt;(arg)...)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(scoped_thread&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">thread_</span>(std::<span class="built_in">move</span>(other.thread_))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread_.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            thread_.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread thread_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现里有下面几点需要注意：</p>
<ol>
<li>我们使用了可变模板和完美转发来构造 thread 对象。</li>
<li>thread 不能拷贝，但可以移动；我们也类似地实现了移动构造函数。</li>
<li>只有 joinable（已经 join 的、已经 detach 的或者空的线程对象都不满足 joinable）的 thread 才可以对其调用 join 成员函数，否则会引发异常。</li>
</ol>
<h4 id="19-3-mutex">19.3 mutex</h4>
<p>互斥量的基本语义是，一个互斥量只能被一个线程锁定，用来保护某个代码块在同一时间只能被一个线程执行。</p>
<p>目前的 C++ 标准中，事实上提供了不止一个互斥量类。我们先看最简单、也最常用的mutex 类 [6]。mutex 只可默认构造，不可拷贝（或移动），不可赋值，主要提供的方法是：</p>
<ul>
<li>lock：锁定，锁已经被其他线程获得时则阻塞执行</li>
<li>try_lock：尝试锁定，获得锁返回 true，在锁被其他线程获得时返回 false</li>
<li>unlock：解除锁定（只允许在已获得锁时调用）</li>
</ul>
<p>你可能会想到，如果一个线程已经锁定了某个互斥量，再次锁定会发生什么？对于 mutex，回答是危险的未定义行为。你不应该这么做。如果有特殊需要可能在同一线程对同一个互斥量多次加锁，就需要用到递归锁 recursive_mutex 了 [7]。除了允许同一线程可以无阻塞地多次加锁外（也必须有对应数量的解锁操作），recursive_mutex 的其他行为和 mutex 一致。</p>
<p>除了 mutex 和 recursive_mutex，C++ 标准库还提供了：</p>
<ul>
<li>timed_mutex：允许锁定超时的互斥量</li>
<li>recursive_timed_mutex：允许锁定超时的递归互斥量</li>
<li>shared_mutex：允许共享和独占两种获得方式的互斥量</li>
<li>shared_timed_mutex：允许共享和独占两种获得方式的、允许锁定超时的互斥量</li>
</ul>
<p>这些我们就不做讲解了，需要的请自行查看参考资料 [8]。另外，<code>&lt;mutex&gt;</code> 头文件中也定义了锁的 RAII 包装类，如我们上面用过的 lock_guard。为了避免手动加锁、解锁的麻烦，以及在有异常或出错返回时发生漏解锁，我们一般应当使用 lock_guard，而不是手工调用互斥量的 lock 和 unlock 方法。C++ 里另外还有 unique_lock（C++11）和 scoped_lock（C++17），提供了更多的功能，你在有更复杂的需求时应该检查一下它们是否合用。</p>
<h4 id="19-4-执行任务，返回数据">19.4 执行任务，返回数据</h4>
<p>如果我们要在某个线程执行一些后台任务，然后取回结果，我们该怎么做呢？</p>
<p>比较传统的做法是使用信号量或者条件变量。由于 C++17 还不支持信号量，我们要模拟传统的做法，只能用条件变量了。由于我的重点并不是传统的做法，条件变量 [9] 我就不展开讲了，而只是展示一下示例的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line">    <span class="comment">// 定义同上，略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(condition_variable&amp; cv, <span class="type">int</span>&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 假装我们计算了很久</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    result = <span class="number">42</span>;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex cv_mut;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    scoped_thread th &#123; work, <span class="built_in">ref</span>(cv), <span class="built_in">ref</span>(result) &#125;;</span><br><span class="line">    <span class="comment">// 干一些其他事</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am waiting now\n&quot;</span>;</span><br><span class="line">    unique_lock lock &#123; cv_mut &#125;;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Answer: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，为了这个小小的”计算”，我们居然需要定义 5 个变量：线程、条件变量、互斥量、单一锁和结果变量。我们也需要用 ref 模板来告诉 thread 的构造函数，我们需要传递条件变量和结果变量的引用，因为 thread 默认复制或移动所有的参数作为线程函数的参数。这种复杂性并非逻辑上的复杂性，而只是实现导致的，不是我们希望的写代码的方式。</p>
<p>下面，我们就看看更高层的抽象，未来量 future [10]，可以如何为我们简化代码。</p>
<h4 id="19-5-future">19.5 future</h4>
<p>我们先把上面的代码直接翻译成使用 async [11]（它会返回一个 future）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 假装我们计算了很久</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fut = <span class="built_in">async</span>(launch::async, work);</span><br><span class="line">    <span class="comment">// 干一些其他事</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am waiting now\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Answer: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们稍稍分析一下：</p>
<ul>
<li>work 函数现在不需要考虑条件变量之类的实现细节了，专心干好自己的计算活、老老实实返回结果就可以了。</li>
<li>调用 async 可以获得一个未来量，launch::async 是运行策略，告诉函数模板 async 应当在新线程里异步调用目标函数。在一些老版本的 GCC 里，不指定运行策略，默认不会起新线程。</li>
<li>async 函数模板可以根据参数来推导出返回类型，在我们的例子里，返回类型是 <code>future&lt;int&gt;</code>。</li>
<li>在未来量上调用 get 成员函数可以获得其结果。这个结果可以是返回值，也可以是异常，即，如果 work 抛出了异常，那 main 里在执行 fut.get() 时也会得到同样的异常，需要有相应的异常处理代码程序才能正常工作。</li>
</ul>
<p>这里有两个要点，从代码里看不出来，我特别说明一下：</p>
<ol>
<li>一个 future 上只能调用一次 get 函数，第二次调用为未定义行为，通常导致程序崩溃。</li>
<li>这样一来，自然一个 future 是不能直接在多个线程里用的。</li>
</ol>
<p>上面的第 1 点是 future 的设计，需要在使用时注意一下。第 2 点则是可以解决的。要么直接拿 future 来移动构造一个 shared_future [12]，要么调用 future 的 share 方法来生成一个 shared_future，结果就可以在多个线程里用了——当然，每个 shared_future 上仍然还是只能调用一次 get 函数。</p>
<h4 id="19-6-promise">19.6 promise</h4>
<p>我们上面用 async 函数生成了未来量，但这不是唯一的方式。另外有一种常用的方式是 promise [13]，我称之为”承诺量”。我们同样看一眼上面的例子用 promise 该怎么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line">    <span class="comment">// 定义同上，略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 假装我们计算了很久</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    <span class="keyword">auto</span> fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    scoped_thread th &#123; work, <span class="built_in">move</span>(prom) &#125;;</span><br><span class="line">    <span class="comment">// 干一些其他事</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am waiting now\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Answer: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>promise 和 future 在这里成对出现，可以看作是一个一次性管道：有人需要兑现承诺，往 promise 里放东西（set_value）；有人就像收期货一样，到时间去 future（写到这里想到，期货英文不就是 future 么，是不是该翻译成期货量呢？😝）里拿（get）就行了。我们把 prom 移动给新线程，这样老线程就完全不需要管理它的生命周期了。</p>
<p>就这个例子而言，使用 promise 没有 async 方便，但可以看到，这是一种非常灵活的方式，你不需要在一个函数结束的时候才去设置 future 的值。仍然需要注意的是，一组 promise 和 future 只能使用一次，既不能重复设，也不能重复取。</p>
<p>promise 和 future 还有个有趣的用法是使用 void 类型模板参数。这种情况下，两个线程之间不是传递参数，而是进行同步：当一个线程在一个 <code>future&lt;void&gt;</code> 上等待时（使用 get() 或 wait()），另外一个线程可以通过调用 <code>promise&lt;void&gt;</code> 上的 set_value() 让其结束等待、继续往下执行。有</p>
<h4 id="19-7-packaged">19.7 packaged</h4>
<p>我们最后要讲的一种 future 的用法是打包任务 packaged_task [14]，我们同样给出完成相同功能的示例，让你方便对比一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line">    <span class="comment">// 定义同上，略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 假装我们计算了很久</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    packaged_task&lt;<span class="built_in">int</span>()&gt; task &#123; work &#125;;</span><br><span class="line">    <span class="keyword">auto</span> fut = task.<span class="built_in">get_future</span>();</span><br><span class="line">    scoped_thread th &#123; <span class="built_in">move</span>(task) &#125;;</span><br><span class="line">    <span class="comment">// 干一些其他事</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am waiting now\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Answer: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包任务里打包的是一个函数，模板参数就是一个函数类型。跟 thread、future、promise 一样，packaged_task 只能移动，不能复制。它是个函数对象，可以像正常函数一样被执行，也可以传递给 thread 在新线程中执行。它的特别地方，自然也是你可以从它得到一个未来量了。通过这个未来量，你可以得到这个打包任务的返回值，或者，至少知道这个打包任务已经执行结束了。</p>
<h4 id="19-8-参考资料">19.8 参考资料</h4>
<ol>
<li>Herb Sutter, “The free lunch is over”. <a target="_blank" rel="noopener" href="http://www.gotw.ca/publications/concurrency-ddj.htm">http://www.gotw.ca/publications/concurrency-ddj.htm</a></li>
<li>Herb Sutter, “Effective concurrency”. <a target="_blank" rel="noopener" href="https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-usean-active-object-instead-of-a-mutex/">https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-usean-active-object-instead-of-a-mutex/</a></li>
<li>Anthony Williams, C++ Concurrency in Action (2nd ed.). Manning, 2019, <a target="_blank" rel="noopener" href="https://www.manning.com/books/c-plus-plus-concurrency-in-action-secondedition">https://www.manning.com/books/c-plus-plus-concurrency-in-action-secondedition</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::thread”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/thread">https://en.cppreference.com/w/cpp/thread/thread</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::jthread”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/jthread">https://en.cppreference.com/w/cpp/thread/jthread</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::mutex”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/mutex">https://en.cppreference.com/w/cpp/thread/mutex</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::recursive_mutex”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/recursive_mutex">https://en.cppreference.com/w/cpp/thread/recursive_mutex</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “<code>Standard library header &lt;mutex&gt;</code>“. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/mutex">https://en.cppreference.com/w/cpp/header/mutex</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::recursive_mutex”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/condition_variable">https://en.cppreference.com/w/cpp/thread/condition_variable</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::future”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/future">https://en.cppreference.com/w/cpp/thread/future</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::async”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/async">https://en.cppreference.com/w/cpp/thread/async</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::shared_future”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/shared_future">https://en.cppreference.com/w/cpp/thread/shared_future</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::promise”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/promise">https://en.cppreference.com/w/cpp/thread/promise</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::packaged_task”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/packaged_task">https://en.cppreference.com/w/cpp/thread/packaged_task</a></li>
</ol>
<h2 id="03丨实战篇">03丨实战篇</h2>
<h3 id="21-工具漫谈：编译、格式化、代码检查、排错各显身手">21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</h3>
<h4 id="21-1-编译器">21.1 编译器</h4>
<ol>
<li>MSVC（Microsoft Visual C++）：MSVC是由微软开发和维护的C++编译器和开发环境</li>
<li>GCC：GNU 工具链的主要组成部分。</li>
<li>Clang：Clang是一个开源的C/C++/Objective-C编译器前端,由LLVM编译器基础设施项目开发和维护。</li>
</ol>
<h4 id="21-2-格式化工具">21.2 格式化工具</h4>
<ol>
<li>Clang-Format</li>
</ol>
<h4 id="21-3-代码检查工具">21.3 代码检查工具</h4>
<ol>
<li>
<p>Clang-Tidy</p>
<p>默认情况下，Clang-Tidy 只做基本的分析。你也可以告诉它你想现代化你的代码和提高代码的可读性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-tidy --checks=<span class="string">&#x27;clang-analyzer-*,modernize-*,readability-*&#x27;</span> test.cpp</span><br></pre></td></tr></table></figure>
<p>以下面简单程序为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        b[i] = <span class="built_in">sqr</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clang-Tidy 会报告下列问题：</p>
<ul>
<li>
<p><code>&lt;stddef.h&gt;</code> 应当替换成 <code>&lt;cstddef&gt;</code></p>
</li>
<li>
<p>函数形式 int func(…) 应当修改成 auto func(…) -&gt; int</p>
</li>
<li>
<p>不要使用 C 数组，应当改成 std::array</p>
</li>
<li>
<p>5 是魔术数，应当改成具名常数</p>
</li>
<li>
<p>NULL 应当改成 nullptr</p>
<p>前两条我不想听。这种情况下，使用配置文件来定制行为就必要了。配置文件叫 .clangtidy，应当放在你的代码目录下或者代码的一个父目录下。Clang-Tidy 会使用最”近”的那个配置文件。下面的配置文件反映了我的偏好：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Checks: &#x27;clang-diagnostic-*,clang-analyzer-*,modernize-*,readability-*,-moderni</span><br></pre></td></tr></table></figure>
<p>使用 Clang-Tidy 还需要注意的地方是，额外的命令行参数应当跟在命令行最后的 — 后面。比如，如果我们要扫描一个 C++ 头文件 foo.h，我们就需要明确告诉 Clang-Tidy 这是 C++ 文件（默认 .h 是 C 文件）。然后，如果我们需要包含父目录下的 common 目录，语言标准使用了 C++17，命令行就应该是下面这个样子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-tidy foo.h -- -x c++ -std=c++17 -I../common</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Cppcheck</p>
</li>
</ol>
<h4 id="21-4-排错工具">21.4 排错工具</h4>
<ol>
<li>
<p>Valgrind</p>
</li>
<li>
<p>nvwa::debug_new</p>
<p>在 nvwa [21] 项目里，我也包含了一个很小的内存泄漏检查工具。它的最大优点是小巧，并且对程序运行性能影响极小；缺点主要是不及 Valgrind 易用和强大，只能检查 new 导致的内存泄漏，并需要侵入式地对项目做修改。</p>
<p>需要检测内存泄漏时，你需要把 debug_new.cpp 加入到项目里。比如，可以简单地在命令行上加入这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++ test.cpp ../nvwa/nvwa/debug_new.cpp</span><br></pre></td></tr></table></figure>
<p>下面是可能的运行时报错：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Leaked object at 0x100302760 (size 20, 0x1000018a4)</span><br><span class="line">*** 1 leaks found</span><br></pre></td></tr></table></figure>
<p>在使用 GCC 和 Clang 时，可以让它自动帮你找出内存泄漏点的位置。在命令行上需要加入可执行文件的名称，并产生调试信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++ -D_DEBUG_NEW_PROGNAME=\&quot;a.out\&quot; -g test.cpp ../nvwa/nvwa/debug_new.cpp</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以在运行时看到一个更明确的错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Leaked object at 0x100302760 (size 20, main (in a.out) (test.cpp:3))</span><br><span class="line">*** 1 leaks found</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="21-5-网页工具">21.5 网页工具</h4>
<p>【<a target="_blank" rel="noopener" href="https://blog.csdn.net/csdnnews/article/details/137662169">用编译器的视角看源码 …</a>】</p>
<ol>
<li>
<p>Compiler Explorer</p>
<p>这个网站，你不仅可以快速查看你的代码在不同编译器里的优化结果，还能快速分享结果。比如，下面这个链接，就可以展示我们之前讲过的一个模板元编程代码的编译结果： <a target="_blank" rel="noopener" href="https://godbolt.org/z/zPNEJ4">https://godbolt.org/z/zPNEJ4</a></p>
</li>
<li>
<p>C++ Insights</p>
<p>如果你在上面的链接里点击了”CppInsights”按钮的话，你就会跳转到 C++ Insights [24] 网站，并且你贴在 <a target="_blank" rel="noopener" href="http://godbolt.org">godbolt.org</a> 的代码也会一起被带过去。这个网站提供了另外一个编译器目前没有提供、但十分有用的功能：展示模板的展开过程。</p>
</li>
</ol>
<h4 id="21-6-参考资料">21.6 参考资料</h4>
<ol>
<li>Visual Studio. <a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/">https://visualstudio.microsoft.com/</a></li>
<li>GCC, the GNU Compiler Collection. <a target="_blank" rel="noopener" href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></li>
<li>Clang: a C language family frontend for LLVM. <a target="_blank" rel="noopener" href="https://clang.llvm.org/">https://clang.llvm.org/</a></li>
<li>Jim Springfield, “Rejuvenating the Microsoft C/C++ compiler”. <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/cppblog/rejuvenating-the-microsoft-cccompiler/">https://devblogs.microsoft.com/cppblog/rejuvenating-the-microsoft-cccompiler/</a></li>
<li>Casey Carter, “Use the official range-v3 with MSVC 2017 version 15.9”. <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/cppblog/use-the-official-range-v3-with-msvc-2017-version-15-9/">https://devblogs.microsoft.com/cppblog/use-the-official-range-v3-with-msvc-2017-version-15-9/</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “std::regex”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/regex/basic_regex">https://en.cppreference.com/w/cpp/regex/basic_regex</a></li>
<li>Microsoft, “Concurrency Runtime”. <a target="_blank" rel="noopener" href="https://docs.microsoft.com/enus/cpp/parallel/concrt/concurrency-runtime">https://docs.microsoft.com/enus/cpp/parallel/concrt/concurrency-runtime</a></li>
<li>ISO/IEC JTC1 SC22 WG21, “Programming languages—C++extensions for coroutines”. <a target="_blank" rel="noopener" href="http://www.openstd.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf">http://www.openstd.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf</a></li>
<li>Ulzii Luvsanbat, “Announcing: MSVC conforms to the C++ standard”. <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-cstandard/">https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-cstandard/</a></li>
<li>Jonathan Adamczewski, “The growth of modern C++ support”. <a target="_blank" rel="noopener" href="http://brnz.org/hbr/?p=1404">http://brnz.org/hbr/?p=1404</a></li>
<li>Vim Online. <a target="_blank" rel="noopener" href="https://www.vim.org/">https://www.vim.org/</a></li>
<li>Xavier Deguillard, clang_complete. <a target="_blank" rel="noopener" href="https://github.com/xavierd/clang_complete">https://github.com/xavierd/clang_complete</a></li>
<li>“libc++” C++ Standard Library . <a target="_blank" rel="noopener" href="https://libcxx.llvm.org/">https://libcxx.llvm.org/</a></li>
<li><a target="_blank" rel="noopener" href="http://cppreference.com">cppreference.com</a>, “C++ compiler support”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/compiler_support">https://en.cppreference.com/w/cpp/compiler_support</a></li>
<li>Homebrew. <a target="_blank" rel="noopener" href="https://brew.sh/">https://brew.sh/</a></li>
<li>吴咏炜, “MSVCRT.DLL console I/O bug”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2016/05/27/msvcrt-dll-console-io-bug/">https://yongweiwu.wordpress.com/2016/05/27/msvcrt-dll-console-io-bug/</a></li>
<li>ClangFormat. <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormat.html">https://clang.llvm.org/docs/ClangFormat.html</a></li>
<li>Clang-Tidy. <a target="_blank" rel="noopener" href="https://clang.llvm.org/extra/clang-tidy/">https://clang.llvm.org/extra/clang-tidy/</a></li>
<li>Daniel Marjamäki, Cppcheck. <a target="_blank" rel="noopener" href="https://github.com/danmar/cppcheck">https://github.com/danmar/cppcheck</a></li>
<li>Valgrind Home. <a target="_blank" rel="noopener" href="https://valgrind.org/">https://valgrind.org/</a></li>
<li>吴咏炜, nvwa. <a target="_blank" rel="noopener" href="https://github.com/adah1972/nvwa/">https://github.com/adah1972/nvwa/</a></li>
<li>Matt Godbolt, “Compiler Explorer”. <a target="_blank" rel="noopener" href="https://godbolt.org/">https://godbolt.org/</a></li>
<li>Matt Godbolt, compiler-explorer. <a target="_blank" rel="noopener" href="https://github.com/mattgodbolt/compilerexplorer">https://github.com/mattgodbolt/compilerexplorer</a></li>
<li>Andreas Fertig, “C++ Insights”. <a target="_blank" rel="noopener" href="https://cppinsights.io/">https://cppinsights.io/</a></li>
</ol>
<h3 id="22-处理数据类型变化和错误：optional、variant、expected-和Herbception">22 | 处理数据类型变化和错误：optional、variant、expected 和Herbception</h3>
<h4 id="22-1-optional">22.1 optional</h4>
<p><code>optional</code> 是 C++17 引入的一个非常有用的标准库类型,它用于表示一个可选的值。它可以持有一个值,也可以表示为空。这在很多场景下都非常有用,比如:</p>
<p>1.函数返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 返回空值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; *result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: Division by zero&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.处理可选参数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">int</span> data, std::optional&lt;<span class="type">double</span>&gt; weight = std::<span class="literal">nullopt</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing data: &quot;</span> &lt;&lt; data;</span><br><span class="line">    <span class="keyword">if</span> (weight.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;, weight: &quot;</span> &lt;&lt; *weight;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">processData</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">processData</span>(<span class="number">100</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在面向对象（引用语义）的语言里，我们有时候会使用空值 null 表示没有找到需要的对象。也有人推荐使用一个特殊的空对象，来避免空值带来的一些问题 [1]。可不管是空值，还是空对象，对于一个返回普通对象（值语义）的 C++ 函数都是不适用的——空值和空对象只能用在返回引用 / 指针的场合，一般情况下需要堆内存分配，在 C++ 里会引额外的开销。</p>
<p>C++17 引入的 optional 模板 [2] 可以（部分）解决这个问题。语义上来说，optional 代表一个”也许有效””可选”的对象。语法上来说，一个 optional 对象有点像一个指针，但它所管理的对象是直接放在 optional 里的，没有额外的内存分配。</p>
<p>构造一个 <code>optional&lt;T&gt;</code> 对象有以下几种方法：</p>
<ol>
<li>
<p>不传递任何参数，或者使用特殊参数 std::nullopt（可以和 nullptr 类比），可以构造一个”空”的 optional 对象，里面不包含有效值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; opt1; <span class="comment">// 默认构造，空的 optional 对象</span></span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; opt2 = std::<span class="literal">nullopt</span>; <span class="comment">// 使用 std::nullopt 构造空的 optional 对象</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt1 has value: &quot;</span> &lt;&lt; opt1.<span class="built_in">has_value</span>() &lt;&lt; std::endl; <span class="comment">// 输出 false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt2 has value: &quot;</span> &lt;&lt; opt2.<span class="built_in">has_value</span>() &lt;&lt; std::endl; <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第一个参数是 std::in_place，后面跟构造 T 所需的参数，可以在 optional 对象上直接构造出 T 的有效值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;std::string&gt; opt = std::<span class="built_in">optional</span>&lt;std::string&gt;(std::in_place, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt has value: &quot;</span> &lt;&lt; opt.<span class="built_in">has_value</span>() &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt value: &quot;</span> &lt;&lt; *opt &lt;&lt; std::endl; <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p><code>std::in_place</code> 是 C++17 中引入的一个特殊的构造函数参数,用于在容器内部直接构造对象,而不需要先创建对象然后再将其移动或拷贝到容器中。</p>
<p>在示例中:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; opt = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="built_in">std</span>::in_place, <span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码使用 <code>std::in_place</code> 指示 <code>std::optional&lt;std::string&gt;</code> 应该在内部直接构造 <code>std::string</code> 对象,参数为 <code>&quot;Hello, World!&quot;</code>。</p>
</li>
<li>
<p>如果 T 类型支持拷贝构造或者移动构造的话，那在构造 <code>optional&lt;T&gt;</code> 时也可以传递一个 T 的左值或右值来将 T 对象拷贝或移动到 optional 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::optional&lt;std::string&gt; opt1 = str;            <span class="comment">// 拷贝构造</span></span><br><span class="line">    std::optional&lt;std::string&gt; opt2 = std::<span class="built_in">move</span>(str); <span class="comment">// 移动构造</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt1 has value: &quot;</span> &lt;&lt; opt1.<span class="built_in">has_value</span>() &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt1 value: &quot;</span> &lt;&lt; *opt1 &lt;&lt; std::endl;                <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt2 has value: &quot;</span> &lt;&lt; opt2.<span class="built_in">has_value</span>() &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt2 value: &quot;</span> &lt;&lt; *opt2 &lt;&lt; std::endl;                <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于上面的第 1 种情况，optional 对象里是没有值的，在布尔值上下文里，会得到 false（类似于空指针的行为）。对于上面的第 2、3 两种情况，optional 对象里是有值的，在布尔值上下文里，会得到 true（类似于有效指针的行为）。类似的，在 optional 对象有值的情况下，你可以用 * 和 -&gt; 运算符去解引用（没值的情况下，结果是未定义行为）。</p>
<p>虽然 optional 是 C++17 才标准化的，但实际上这个用法更早就通行了。因为 optional 的实现不算复杂，有些库里就自己实现了一个版本。比如 cpptoml [3] 就给出 了下面这样的示例（进行了翻译和重排版），用法跟标准的 optional 完全吻合。</p>
<p>cpptoml 里只是个缩微版的 optional，实现只有几十行，也不支持我们上面说的所有构造方式。标准库的 optional 为了方便程序员使用，除了我目前描述的功能，还支持下面的操作：</p>
<ul>
<li>
<p>安全的析构行为</p>
</li>
<li>
<p>显式的 has_value 成员函数，判断 optional 是否有值</p>
<ul>
<li>
<pre><code class="language-c++">#include &lt;optional&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::optional&lt;int&gt; opt = 42;
    if (opt.has_value()) &#123;
        std::cout &lt;&lt; &quot;opt contains value: &quot; &lt;&lt; *opt &lt;&lt; std::endl; // 输出 42
    &#125; else &#123;
        std::cout &lt;&lt; &quot;opt is empty&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- value 成员函数，行为类似于 `*`，但在 optional 对象无值时会抛出异常</span><br><span class="line"></span><br><span class="line">- std::bad_optional_access</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt = <span class="number">42</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> value = opt.<span class="built_in">value</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;opt value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_optional_access&amp; e) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>value_or 成员函数，在 optional 对象无值时返回传入的参数</p>
<ul>
<li>
<pre><code class="language-c++">#include &lt;optional&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::optional&lt;int&gt; opt;
    int value = opt.value_or(100);
    std::cout &lt;&lt; &quot;opt value or 100: &quot; &lt;&lt; value &lt;&lt; std::endl; // 输出 100

    return 0;
&#125;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- swap 成员函数，和另外一个 optional 对象进行交换</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt1 = <span class="number">42</span>;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt2 = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">        opt1.<span class="built_in">swap</span>(opt2);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;opt1: &quot;</span> &lt;&lt; *opt1 &lt;&lt; <span class="string">&quot;, opt2: &quot;</span> &lt;&lt; *opt2 &lt;&lt; std::endl; <span class="comment">// 输出 opt1: 100, opt2: 42</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>reset 成员函数，清除 optional 对象包含的值</p>
<ul>
<li>
<pre><code class="language-c++">#include &lt;optional&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::optional&lt;int&gt; opt = 42;
    opt.reset();
    std::cout &lt;&lt; &quot;opt has value: &quot; &lt;&lt; opt.has_value() &lt;&lt; std::endl; // 输出 false

    return 0;
&#125;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- emplace 成员函数，在 optional 对象上构造一个新的值（不管成功与否，原值会被丢弃）</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt;</span><br><span class="line">        opt.<span class="built_in">emplace</span>(<span class="number">42</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;opt value: &quot;</span> &lt;&lt; *opt &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    </span><br><span class="line">        opt.<span class="built_in">emplace</span>(<span class="number">100</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;opt value: &quot;</span> &lt;&lt; *opt &lt;&lt; std::endl; <span class="comment">// 输出 100</span></span><br><span class="line">        opt = <span class="number">666</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;opt value: &quot;</span> &lt;&lt; *opt &lt;&lt; std::endl; <span class="comment">// 输出 100</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>make_optional 全局函数，产生一个 optional 对象（类似 make_pair、make_unique 等）</p>
<ul>
<li>
<pre><code class="language-c++">#include &lt;optional&gt;
#include &lt;iostream&gt;

int main() &#123;
    auto opt = std::make_optional&lt;int&gt;(42);
    std::cout &lt;&lt; &quot;opt value: &quot; &lt;&lt; *opt &lt;&lt; std::endl; // 输出 42

    return 0;
&#125;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 全局比较操作</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt1 = <span class="number">42</span>;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt2 = <span class="number">100</span>;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; opt3 = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">        std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;opt1 == opt2: &quot;</span> &lt;&lt; (opt1 == opt2) &lt;&lt; std::endl; <span class="comment">// 输出 false</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;opt1 == opt3: &quot;</span> &lt;&lt; (opt1 == opt3) &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>等等</p>
</li>
</ul>
<p>如果我们认为无值就是数据无效，应当跳过剩下的处理，我们可以写出下面这样的高阶函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">has_value</span><span class="params">(<span class="type">const</span> optional&lt;T&gt;&amp; x)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">has_value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">has_value</span><span class="params">(<span class="type">const</span> optional&lt;T&gt;&amp; first, <span class="type">const</span> optional&lt;Args&gt;&amp;... other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first.<span class="built_in">has_value</span>() &amp;&amp; <span class="built_in">has_value</span>(other...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lift_optional</span><span class="params">(F&amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [f = forward&lt;F&gt;(f)](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(forward&lt;<span class="keyword">decltype</span>(args)&gt;(args).<span class="built_in">value</span>()...))&gt; result_type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">has_value</span>(args...)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">optional</span>&lt;result_type&gt;(<span class="built_in">f</span>(forward&lt;<span class="keyword">decltype</span>(args)&gt;(args).<span class="built_in">value</span>()...));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">optional</span>&lt;result_type&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>has_value 比较简单，它可以有一个或多个 optional 参数，并在所有参数都有值时返回真，否则返回假。lift_optional 稍复杂些，它接受一个函数，返回另外一个函数。在返回的函数里，参数是一个或多个 optional 类型，result_type 是用参数的值（value()）去调用原先函数时的返回值类型，最后返回的则是 result_type 的 optional 封装。函数内部会检查所有的参数是否都有值（通过调用 has_value）：有值时会去拿参数的值去调用原先的函数，否则返回一个空的 optional 对象。</p>
<p>这个函数能把一个原本要求参数全部有效的函数抬升（lift）成一个接受和返回 optional 参数的函数，并且，只在参数全部有效时去调用原来的函数。这是一种非常函数式的编程方式。使用上面函数的示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需包含 lift_optional 的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准库没有提供 optional 的输出</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="built_in">optional</span>&lt;<span class="type">int</span>&gt;(x))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; *x &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(Nothing)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> inc_opt = <span class="built_in">lift_optional</span>(increase);</span><br><span class="line">    <span class="keyword">auto</span> plus_opt = <span class="built_in">lift_optional</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; <span class="built_in">inc_opt</span>(<span class="built_in">optional</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">inc_opt</span>(<span class="built_in">make_optional</span>(<span class="number">41</span>)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus_opt</span>(<span class="built_in">make_optional</span>(<span class="number">41</span>), <span class="built_in">optional</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus_opt</span>(<span class="built_in">make_optional</span>(<span class="number">41</span>), <span class="built_in">make_optional</span>(<span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Nothing)</span><br><span class="line">(<span class="number">42</span>)</span><br><span class="line">(Nothing)</span><br><span class="line">(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<h4 id="22-2-variant">22.2 variant</h4>
<p>optional 是一个非常简单而又好用的模板，很多情况下，使用它就足够解决问题了。在某种意义上，可以把它看作是允许有两种数值的对象：要么是你想放进去的对象，要么是 nullopt（再次提醒，联想 nullptr）。如果我们希望除了我们想放进去的对象，还可以是 nullopt 之外的对象怎么办呢（比如，某种出错的状态）？又比如，如果我希望有三种或更多不同的类型呢？这种情况下，variant [4] 可能就是一个合适的解决方案。</p>
<p>在没有 variant 类型之前，你要达到类似的目的，恐怕会使用一种叫做带标签的联合（tagged union）的数据结构。比如，下面就是一个可能的数据结构定义：</p>
<p><strong><code>std::variant</code> 的特点</strong></p>
<ol>
<li><strong>类型安全</strong>：<code>std::variant</code> 确保只能包含定义的类型之一，并且提供了类型安全的访问方法。</li>
<li><strong>代替联合体</strong>：与传统的 C++ 联合体相比，<code>std::variant</code> 更加安全，因为它会跟踪当前存储的类型。</li>
<li><strong>多态性</strong>：通过 <code>std::variant</code>，可以在单个变量中存储多种类型，且访问时无需动态类型转换。</li>
</ol>
<p><strong>定义和初始化</strong></p>
<p>可以在 <code>std::variant</code> 中定义多个类型，并通过直接赋值或构造函数初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">10</span>;               <span class="comment">// 保存 int 类型</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    var = <span class="number">3.14</span>;             <span class="comment">// 保存 double 类型</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(var) &lt;&lt; std::endl; <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">    var = <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 保存 std::string 类型</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl; <span class="comment">// 输出 Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问 <code>std::variant</code></strong></p>
<p>可以通过 <code>std::get</code> 和 <code>std::get_if</code> 来访问 <code>std::variant</code> 中存储的值。</p>
<ol>
<li><strong><code>std::get</code></strong>：直接获取存储的值，但如果类型不匹配会抛出 <code>std::bad_variant_access</code> 异常。</li>
<li><strong><code>std::get_if</code></strong>：返回指向存储值的指针，如果类型不匹配返回 <code>nullptr</code>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::get 获取值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::get_if 获取值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> value = std::<span class="built_in">get_if</span>&lt;<span class="type">int</span>&gt;(&amp;var)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No matching type&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问当前存储的类型</strong></p>
<p>可以使用 <code>std::visit</code> 和 <code>std::holds_alternative</code> 来访问和处理 <code>std::variant</code> 中当前存储的类型。</p>
<ol>
<li><strong><code>std::visit</code></strong>：使用访问者模式处理存储的值。</li>
<li><strong><code>std::holds_alternative</code></strong>：检查 <code>std::variant</code> 是否持有特定类型。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::visit 访问存储的值</span></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">        std::cout &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">    &#125;, var); <span class="comment">// 输出 Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前存储的类型</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::string&gt;(var)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds a string&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出 The variant holds a string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个综合例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Operand = std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">Operand <span class="title">add</span><span class="params">(<span class="type">const</span> Operand&amp; lhs, <span class="type">const</span> Operand&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg1, <span class="keyword">auto</span>&amp;&amp; arg2) -&gt; Operand &#123;</span><br><span class="line">        <span class="keyword">using</span> T1 = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg1)&gt;;</span><br><span class="line">        <span class="keyword">using</span> T2 = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg2)&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T1, <span class="type">int</span>&gt; &amp;&amp; std::is_same_v&lt;T2, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T1, <span class="type">double</span>&gt; &amp;&amp; std::is_same_v&lt;T2, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T1, std::string&gt; &amp;&amp; std::is_same_v&lt;T2, std::string&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Operand&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, lhs, rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Operand op1 = <span class="number">10</span>;</span><br><span class="line">    Operand op2 = <span class="number">20</span>;</span><br><span class="line">    Operand result = <span class="built_in">add</span>(op1, op2);</span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; std::endl; &#125;, result); <span class="comment">// 输出 30</span></span><br><span class="line"></span><br><span class="line">    op1 = <span class="number">3.14</span>;</span><br><span class="line">    op2 = <span class="number">2.86</span>;</span><br><span class="line">    result = <span class="built_in">add</span>(op1, op2);</span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; std::endl; &#125;, result); <span class="comment">// 输出 6.0</span></span><br><span class="line"></span><br><span class="line">    op1 = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    op2 = std::<span class="built_in">string</span>(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    result = <span class="built_in">add</span>(op1, op2);</span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; std::endl; &#125;, result); <span class="comment">// 输出 Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有 variant 类型之前，你要达到类似的目的，恐怕会使用一种叫做带标签的联合（tagged union）的数据结构。比如，下面就是一个可能的数据结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FloatIntChar</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        Float,</span><br><span class="line">        Int,</span><br><span class="line">        Char</span><br><span class="line">    &#125; type;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">float</span> float_value;</span><br><span class="line">        <span class="type">int</span> int_value;</span><br><span class="line">        <span class="type">char</span> char_value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个数据结构的最大问题，就是它实际上有很多复杂情况需要特殊处理。对于我们上面例子里的 POD 类型，这么写就可以了（但我们仍需小心保证我们设置的 type 和实际使用的类型一致）。如果我们把其中一个类型换成非 POD 类型，就会有复杂问题出现。比如，下面的代码是不能工作的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StringIntChar</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; String,</span><br><span class="line">        Int,</span><br><span class="line">        Char</span><br><span class="line">    &#125; type;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        string string_value;</span><br><span class="line">        <span class="type">int</span> int_value;</span><br><span class="line">        <span class="type">char</span> char_value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会很合理地看到在 union 里使用 string 类型会带来构造和析构上的问题，所以会拒绝工作。要让这个代码工作，我们得手工加上析构函数，并且，在析构函数里得小心地判断存储的是什么数值，来决定是否应该析构（否则，默认不调用任何 union 里的析构函数，从而可能导致资源泄漏）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">StringIntChar</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == String) &#123;</span><br><span class="line">        string_value.~<span class="built_in">string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们才能安全地使用它（还是很麻烦）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringIntChar obj &#123;</span><br><span class="line">    .type = StringIntChar::String,</span><br><span class="line">    .string_value = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; obj.string_value &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>这里用到了按成员初始化的语法，把类型设置成了字符串，同时设置了字符串的值。不用说，这是件麻烦、容易出错的事情。同时，细查之后我发现，这个语法虽然在 C99 里有，但在 C++ 里要在 C++20 才会被标准化，因此实际是有兼容性问题的——老版本的 MSVC，或最新版本的 MSVC 在没有开启 C++20 支持时，就不支持这个语法。</p>
<p>所以，目前的主流建议是，应该避免使用”裸” union 了。替换方式，就是这一节要说的 variant。上面的例子，如果用 variant 的话，会非常的干净利落：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variant&lt;string, <span class="type">int</span>, <span class="type">char</span>&gt; obj &#123;<span class="string">&quot;Hello world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;string&gt;(obj) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>可以注意到我上面构造时使用的是 const char*，但构造函数仍然能够正确地选择 string 类型，这是因为标准要求实现在没有一个完全匹配的类型的情况下，会选择成员类型中能够以传入的类型来构造的那个类型进行初始化（有且只有一个时）。string 类存在形式为 string(const char*) 的构造函数（不精确地说），所以上面的构造能够正确进行。</p>
<p>跟 tuple 相似，variant 上可以使用 get 函数模板，其模板参数可以是代表序号的数字，也可以是类型。如果编译时可以确定序号或类型不合法，我们在编译时就会出错。如果序号或类型合法，但运行时发现 variant 里存储的并不是该类对象，我们则会得到一个异常 bad_variant_access。</p>
<p>variant 上还有一个重要的成员函数是 index，通过它我们能获得当前的数值的序号。就我们上面的例子而言，obj.index() 即为 1。正常情况下，variant 里总有一个有效的数值（缺省为第一个类型的默认构造结果），但如果 emplace 等修改操作中发生了异常， variant 里也可能没有任何有效数值，此时 index() 将会得到 variant_npos。</p>
<p>从基本概念来讲，variant 就是一个安全的 union，相当简单，我就不多做其他介绍了。你可以自己看文档来了解进一步的信息。其中比较有趣的一个非成员函数是 visit [5]，文档里展示了一个非常简洁的、可根据当前包含的变量类型进行函数分发的方法。</p>
<p><strong>平台细节</strong>：在老于 Mojave 的 macOS 上编译含有 optional 或 variant 的代码，需要在文件开头加上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__clang__) &amp;&amp; defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;__config&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _LIBCPP_AVAILABILITY_BAD_VARIANT_ACCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_AVAILABILITY_BAD_VARIANT_ACCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>原因是苹果在头文件里把 optional 和 variant 在早期版本的 macOS 上禁掉了，而上面的代码去掉了这几个宏里对使用 bad_optional_access 和 bad_variant_access 的平台限制。</p>
<h4 id="22-3-expected">22.3 expected</h4>
<p><code>std::expected</code> 是一个在 C++23 标准库中引入的类模板，它是用于处理可能失败的操作的一种新工具。<code>std::expected</code> 结合了返回值和错误处理的能力，可以取代诸如 <code>std::optional</code> 和异常处理等传统方法。</p>
<p><strong><code>std::expected</code> 的基本概念</strong></p>
<p><code>std::expected</code> 模板类包含两种状态之一：</p>
<ol>
<li><strong>成功状态</strong>：包含一个有效值。</li>
<li><strong>失败状态</strong>：包含一个错误值。</li>
</ol>
<p>它通过将这两种状态封装在一个对象中，使得函数可以返回一个结果或一个错误，从而提供了一种更为显式的错误处理方式。</p>
<p><strong>头文件</strong></p>
<p><code>std::expected</code> 定义在头文件 <code>&lt;expected&gt;</code> 中。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>定义和初始化</strong></p>
<p>可以通过多种方式来初始化 <code>std::expected</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成功状态</span></span><br><span class="line">    std::expected&lt;<span class="type">int</span>, std::string&gt; success = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Success: &quot;</span> &lt;&lt; success.<span class="built_in">value</span>() &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败状态</span></span><br><span class="line">    std::expected&lt;<span class="type">int</span>, std::string&gt; failure = std::<span class="built_in">unexpected</span>(<span class="string">&quot;Error occurred&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!failure) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failure: &quot;</span> &lt;&lt; failure.<span class="built_in">error</span>() &lt;&lt; std::endl; <span class="comment">// 输出 Error occurred</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问 <code>std::expected</code></strong></p>
<p>可以使用成员函数 <code>value</code> 和 <code>error</code> 来访问 <code>std::expected</code> 中的值或错误。此外，还可以使用布尔值上下文检查 <code>std::expected</code> 是否处于成功状态。</p>
<ol>
<li><strong><code>value</code></strong>：获取存储的成功值。如果对象处于失败状态，调用 <code>value</code> 会抛出 <code>std::bad_expected_access</code> 异常。</li>
<li><strong><code>error</code></strong>：获取存储的错误值。如果对象处于成功状态，调用 <code>error</code> 会抛出 <code>std::bad_expected_access</code> 异常。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::expected&lt;<span class="type">int</span>, std::string&gt; result = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_expected_access&lt;std::string&gt;&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">error</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = std::<span class="built_in">unexpected</span>(<span class="string">&quot;Error occurred&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = result.<span class="built_in">value</span>(); <span class="comment">// 会抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_expected_access&lt;std::string&gt;&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">error</span>() &lt;&lt; std::endl; <span class="comment">// 输出 Error occurred</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：使用 <code>std::expected</code> 实现简单的文件读取</strong></p>
<p>以下是一个使用 <code>std::expected</code> 实现简单文件读取的示例。如果读取成功，返回文件内容；否则返回错误消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="function">std::expected&lt;std::string, std::string&gt; <span class="title">readFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unexpected</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">content</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(file)), std::istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">readFile</span>(<span class="string">&quot;example.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File content:\n&quot;</span> &lt;&lt; result.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ol>
<li><strong>定义 <code>std::expected</code> 对象</strong>：
<ul>
<li><code>std::expected&lt;int, std::string&gt; success = 42;</code>：表示成功状态，包含整数值 42。</li>
<li><code>std::expected&lt;int, std::string&gt; failure = std::unexpected(&quot;Error occurred&quot;);</code>：表示失败状态，包含错误消息。</li>
</ul>
</li>
<li><strong>访问 <code>std::expected</code> 的值和错误</strong>：
<ul>
<li>使用 <code>value()</code> 函数获取成功状态的值。</li>
<li>使用 <code>error()</code> 函数获取失败状态的错误消息。</li>
</ul>
</li>
<li><strong>检查 <code>std::expected</code> 的状态</strong>：
<ul>
<li>在布尔上下文中使用 <code>std::expected</code> 对象可以检查它是否处于成功状态。</li>
</ul>
</li>
</ol>
<p>和前面介绍的两个模板不同，expected 不是 C++ 标准里的类型。但概念上这三者有相关性，因此我们也放在一起讲一下。</p>
<p>我前面已经提到，optional 可以作为一种代替异常的方式：在原本该抛异常的地方，我们可以改而返回一个空的 optional 对象。当然，此时我们就只知道没有返回一个合法的对象，而不知道为什么没有返回合法对象了。我们可以考虑改用一个 variant，但我们此时需要给错误类型一个独特的类型才行，因为这是 variant 模板的要求。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">error_code</span> &#123;</span><br><span class="line">    success,</span><br><span class="line">    operation_failure,</span><br><span class="line">    object_not_found,</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">variant&lt;Obj, error_code&gt; <span class="title">get_object</span><span class="params">(…)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这当然是一种可行的错误处理方式：我们可以判断返回值的 index()，来决定是否发生了错误。但这种方式不那么直截了当，也要求实现对允许的错误类型作出规定。Andrei Alexandrescu 在 2012 年首先提出的 Expected 模板 [6]，提供了另外一种错误处理方式。他的方法的要点在于，把完整的异常信息放在返回值，并在必要的时候，可以”重放”出来，或者手工检查是不是某种类型的异常。</p>
<p>他的概念并没有被广泛推广，最主要的原因可能是性能。异常最被人诟病的地方是性能，而他的方式对性能完全没有帮助。不过，后面的类似模板都汲取了他的部分思想，至少会用一种显式的方式来明确说明当前是异常情况还是正常情况。在目前的 expected 的标准提案[7] 里，用法有点是 optional 和 variant 的某种混合：模板的声明形式像 variant，使用正常返回值像 optional。</p>
<p>下面的代码展示了一个 expected 实现 [8] 的基本用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tl/expected.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> tl::expected;</span><br><span class="line"><span class="keyword">using</span> tl::unexpected;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 expected 的安全除法</span></span><br><span class="line"><span class="function">expected&lt;<span class="type">int</span>, string&gt; <span class="title">safe_divide</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unexpected</span>(<span class="string">&quot;divide by zero&quot;</span>s);</span><br><span class="line">    <span class="keyword">if</span> (i == INT_MIN &amp;&amp; j == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unexpected</span>(<span class="string">&quot;integer divide overflows&quot;</span>s);</span><br><span class="line">    <span class="keyword">if</span> (i % j != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unexpected</span>(<span class="string">&quot;not integer division&quot;</span>s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个测试函数</span></span><br><span class="line"><span class="function">expected&lt;<span class="type">int</span>, string&gt; <span class="title">caller</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="built_in">safe_divide</span>(j, k);</span><br><span class="line">    <span class="keyword">if</span> (q)</span><br><span class="line">        <span class="keyword">return</span> i + *q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持 expected 的输出函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> E&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> expected&lt;T, E&gt;&amp; exp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (exp) &#123;</span><br><span class="line">        os &lt;&lt; exp.<span class="built_in">value</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;unexpected: &quot;</span> &lt;&lt; exp.<span class="built_in">error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调试使用的检查宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(expr)                                    \</span></span><br><span class="line"><span class="meta">    &#123;                                                  \</span></span><br><span class="line"><span class="meta">        auto result = (expr);                          \</span></span><br><span class="line"><span class="meta">        cout &lt;&lt; result;                                \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (result == unexpected(<span class="string">&quot;divide by zero&quot;</span>s)) &#123; \</span></span><br><span class="line"><span class="meta">            cout &lt;&lt; <span class="string">&quot;: Are you serious?&quot;</span>;              \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == 42) &#123;                     \</span></span><br><span class="line"><span class="meta">            cout &lt;&lt; <span class="string">&quot;: Ha, I got you!&quot;</span>;                \</span></span><br><span class="line"><span class="meta">        &#125;                                              \</span></span><br><span class="line"><span class="meta">        cout &lt;&lt; endl;                                  \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">caller</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">caller</span>(<span class="number">37</span>, <span class="number">20</span>, <span class="number">7</span>));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">caller</span>(<span class="number">39</span>, <span class="number">21</span>, <span class="number">7</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unexpected: divide by zero: Are you serious?</span><br><span class="line">unexpected: not integer division</span><br><span class="line">42: Ha, I got you</span><br></pre></td></tr></table></figure>
<p>一个 <code>expected&lt;T, E&gt;</code> 差不多可以看作是 T 和 <code>unexpected&lt;E&gt;</code> 的 variant。在学过上面的 variant 之后，我们应该很容易看明白上面的程序了。下面是几个需要注意一下的地方：</p>
<ul>
<li>如果一个函数要正常返回数据，代码无需任何特殊写法；如果它要表示出现了异常，则可以返回一个 unexpected 对象。</li>
<li>这个返回值可以用来和一个正常值或 unexpected 对象比较，可以在布尔值上下文里检查是否有正常值，也可以用 <code>*</code> 运算符来取得其中的正常值——与 optional 类似，在没有正常值的情况下使用 <code>*</code> 是未定义行为。</li>
<li>可以用 value 成员函数来取得其中的正常值，或使用 error 成员函数来取得其中的错误值——与 variant 类似，在 expected 中没有对应的值时产生异常 bad_expected_access。</li>
<li>返回错误跟抛出异常比较相似，但检查是否发生错误的代码还是要比异常处理啰嗦。</li>
</ul>
<h4 id="22-4-Herbception">22.4 Herbception</h4>
<p>C++ 中的异常处理（Exception Handling）机制使用的是堆栈展开（stack unwinding），这在某些情况下会导致性能开销和代码复杂性。特别是在高性能或实时系统中，异常处理的不可预测性是一个问题。为了应对这些挑战，Herb Sutter 提出了“Herbception”这个概念。</p>
<p><strong>Herbception 的核心思想</strong></p>
<ol>
<li><strong>零开销异常处理</strong>：Herbception 提议的核心思想之一是实现零开销的异常处理。这意味着在不抛出异常时，异常处理机制不应带来任何运行时开销。</li>
<li><strong>结构化异常处理（SEH）和契约（Contracts）</strong>：Herb Sutter 提到可以借鉴其他编程语言的做法，如 C# 的结构化异常处理和契约编程，将其引入到 C++ 中。这将使得异常处理更加高效和明确。</li>
<li><strong>静态和动态混合检查</strong>：通过静态分析和运行时检查相结合，尽可能在编译期捕获错误，从而减少运行时异常的发生。</li>
</ol>
<h3 id="提议的改进">提议的改进</h3>
<ol>
<li><strong><code>[[noexcept]]</code> 默认行为</strong>：让所有函数默认情况下都使用 <code>[[noexcept]]</code>，除非显式声明它们可能抛出异常。这将显著减少异常处理的开销，因为编译器可以假设大多数函数不会抛出异常。</li>
<li><strong>契约编程</strong>：引入契约（Contracts）机制，包括前置条件（Preconditions）、后置条件（Postconditions）和不变性（Invariants）。契约编程可以在编译时进行检查，捕获大多数逻辑错误，从而减少运行时异常的需求。</li>
<li><strong>改进的错误处理机制</strong>：提出一种新的错误处理机制，该机制在性能和可预测性方面优于传统的异常处理。例如，通过返回 <code>std::expected</code> 或 <code>std::outcome</code> 类型，显式地处理可能的错误。</li>
</ol>
<p><strong>示例：使用 <code>std::expected</code></strong></p>
<p>虽然 <code>std::expected</code> 不是 Herbception 的一部分，但它体现了类似的思想，即通过返回值而非抛出异常来处理错误。以下是一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="function">std::expected&lt;std::string, std::string&gt; <span class="title">readFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unexpected</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">content</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(file)), std::istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">readFile</span>(<span class="string">&quot;example.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File content:\n&quot;</span> &lt;&lt; result.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""></h3>
<h3 id="23-数字计算：介绍线性代数和数值计算库">23 | 数字计算：介绍线性代数和数值计算库</h3>
<h4 id="23-1-Armadillo">23.1 Armadillo</h4>
<h4 id="23-2-Boost-Multiprecision">23.2 Boost.Multiprecision</h4>
<h4 id="23-3-参考资料">23.3 参考资料</h4>
<ol>
<li>Wikipedia, “Basic Linear Algebra Subprograms”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms</a></li>
<li>Wikipedia, “LAPACK”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/LAPACK">https://en.wikipedia.org/wiki/LAPACK</a></li>
<li>Wikipedia, “ARPACK”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ARPACK">https://en.wikipedia.org/wiki/ARPACK</a></li>
<li>Zhang Xianyi et al., OpenBLAS. <a target="_blank" rel="noopener" href="https://github.com/xianyi/OpenBLAS">https://github.com/xianyi/OpenBLAS</a></li>
<li>Intel, Math Kernel Library. <a target="_blank" rel="noopener" href="https://software.intel.com/mkl">https://software.intel.com/mkl</a></li>
<li>Ilya Yaroshenko, mir-glas. <a target="_blank" rel="noopener" href="https://github.com/libmir/mir-glas">https://github.com/libmir/mir-glas</a></li>
<li>Conrad Sanderson and Ryan Curtin, “Armadillo: C++ library for linear algebra &amp; scientific computing”. <a target="_blank" rel="noopener" href="http://arma.sourceforge.net/">http://arma.sourceforge.net/</a></li>
<li>Wikipedia, “Expression templates”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Expression_templates">https://en.wikipedia.org/wiki/Expression_templates</a></li>
<li>John Maddock, Boost.Multiprecision. <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html">https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html</a></li>
<li>The GNU MP bignum library. <a target="_blank" rel="noopener" href="https://gmplib.org/">https://gmplib.org/</a></li>
<li>吴咏炜, “Choosing a multi-precision library for C++—a critique”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precisionlibrary-for-c-a-critique/">https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precisionlibrary-for-c-a-critique/</a></li>
</ol>
<h3 id="24-Boost：你需要的”瑞士军刀”">24 | Boost：你需要的”瑞士军刀”</h3>
<h4 id="24-1-Boost-概览">24.1 Boost 概览</h4>
<p>Boost 的网站把 Boost 描述成为经过同行评审的、可移植的 C++ 源码库（peer-reviewed portable C++ source libraries）[1]。换句话说，它跟很多个人开源库不一样的地方在于，它的代码是经过评审的。事实上，Boost 项目的背后有很多 C++ 专家，比如发起人之一的 Dave Abarahams 是 C++ 标准委员会的成员，也是《C++ 模板元编程》一书 [2] 的作者。这也就使得 Boost 有了很不一样的特殊地位：它既是 C++ 标准库的灵感来源之一，也是 C++ 标准库的试验田。下面这些 C++ 标准库就源自 Boost：</p>
<ul>
<li>智能指针</li>
<li>thread</li>
<li>regex</li>
<li>random</li>
<li>array</li>
<li>bind</li>
<li>tuple</li>
<li>optional</li>
<li>variant</li>
<li>any</li>
<li>string_view</li>
<li>filesystem</li>
<li>等等</li>
</ul>
<p>当然，将来还会有新的库从 Boost 进入 C++ 标准，如网络库的标准化就是基于 Boost.Asio 进行的。因此，即使相关的功能没有被标准化，我们也可能可以从 Boost 里看到某个功能可能会被标准化的样子——当然，最终标准化之后的样子还是经常有所变化的。</p>
<p>我们也可以在我们的编译器落后于标准、不能提供标准库的某个功能时使用 Boost 里的替代品。比如，我之前提到过老版本的 macOS 上苹果的编译器不支持 optional 和 variant。除了我描述的不正规做法，改用 Boost 也是方法之一。比如，对于 variant，所需的改动只是：</p>
<ul>
<li>把包含 <code>&lt;variant&gt;</code> 改成包含 <code>&lt;boost/variant.hpp&gt;</code></li>
<li>把代码中的 std::variant 改成 boost::variant</li>
</ul>
<p>这样，就基本大功告成了。</p>
<h4 id="24-2-Boost-的安装">24.2 Boost 的安装</h4>
<p>在主要的开发平台上，现在你都可以直接安装 Boost，而不需要自己从源代码编译了：</p>
<ul>
<li>在 Windows 下使用 MSVC，我们可以使用 NuGet 安装（按需逐个安装）</li>
<li>在 Linux 下，我们可以使用系统的包管理器（如 apt 和 yum）安装（按需逐个安装，或一次性安装所有的开发需要的包）</li>
<li>在 macOS 下，我们可以使用 Homebrew 安装（一次性安装完整的 Boost）</li>
</ul>
<h4 id="24-3-Boost-TypeIndex">24.3 Boost.TypeIndex</h4>
<p>TypeIndex 是一个很轻量级的库，它不需要链接，解决的也是使用模板时的一个常见问题，如何精确地知道一个表达式或变量的类型。我们还是看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">cbegin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** Using typeid\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(<span class="type">const</span> <span class="type">int</span>).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(v).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(it).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** Using type_id\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id</span>&lt;<span class="keyword">decltype</span>(v)&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id</span>&lt;<span class="keyword">decltype</span>(it)&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** Using type_id_with_cvr\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>((v))&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">move</span>((v)))&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>((it))&gt;() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码里，展示了标准的 typeid 和 Boost 的 type_id 和 type_id_with_cvr 的使用。它们的区别是：</p>
<ul>
<li>typeid 是标准 C++ 的关键字，可以应用到变量或类型上，返回一个 std::type_info。我们可以用它的 name 成员函数把结果转换成一个字符串，但标准不保证这个字符串的可读性和唯一性。</li>
<li>type_id 是 Boost 提供的函数模板，必须提供类型作为模板参数——所以对于表达式和变量我们需要使用 decltype。结果可以直接输出到 IO 流上。</li>
<li>type_id_with_cvr 和 type_id 相似，但它获得的结果会包含 const/volatile 状态及引用类型。</li>
</ul>
<p>上面程序在 MSVC 下的输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Using typeid</span><br><span class="line">int</span><br><span class="line">class std::vector&lt;int,class std::allocator&lt;int&gt; &gt;</span><br><span class="line">class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct</span><br><span class="line">std::_Simple_types&lt;int&gt; &gt; &gt;</span><br><span class="line">*** Using type_id</span><br><span class="line">int</span><br><span class="line">class std::vector&lt;int,class std::allocator&lt;int&gt; &gt;</span><br><span class="line">class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct</span><br><span class="line">std::_Simple_types&lt;int&gt; &gt; &gt;</span><br><span class="line">*** Using type_id_with_cvr</span><br><span class="line">int const</span><br><span class="line">class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; &amp;</span><br><span class="line">class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; &amp;&amp;</span><br><span class="line">class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct</span><br><span class="line">std::_Simple_types&lt;int&gt; &gt; &gt; &amp;</span><br></pre></td></tr></table></figure>
<p>在 GCC 下的输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Using typeid</span><br><span class="line">i</span><br><span class="line">St6vectorIiSaIiEE</span><br><span class="line">N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE</span><br><span class="line">*** Using type_id</span><br><span class="line">int</span><br><span class="line">std::vector&lt;int, std::allocator&lt;int&gt; &gt;</span><br><span class="line">__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int,</span><br><span class="line">std::allocator&lt;int&gt; &gt; &gt;</span><br><span class="line">*** Using type_id_with_cvr</span><br><span class="line">int const</span><br><span class="line">std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;</span><br><span class="line">std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;&amp;</span><br><span class="line">__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int,</span><br><span class="line">std::allocator&lt;int&gt; &gt; &gt;&amp;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 MSVC 下 typeid 直接输出了比较友好的类型名称，但 GCC 下没有。此外，我们可以注意到：</p>
<ul>
<li>typeid 的输出忽略了 const 修饰，也不能输出变量的引用类型。</li>
<li>type_id 保证可以输出友好的类型名称，输出时也不需要调用成员函数，但例子里它忽略了 int 的 const 修饰，也和 typeid 一样不能输出表达式的引用类型。</li>
<li>type_id_with_cvr 可以输出 const/volatile 状态和引用类型，注意这种情况下模板参数必须包含引用类型，所以我用了 decltype((v)) 这种写法，而不是 decltype(v)。如果你忘了这两者的区别，请复习一下 <strong>[第 8 讲]</strong> 的 decltype。</li>
</ul>
<p>显然，除非你正在使用 MSVC，否则调试期 typeid 的用法完全应该用 Boost 的 type_id 来替代。另外，如果你的开发环境要求禁用 RTTI（运行时类型识别），那 typeid 在 Clang 和 GCC 下根本不能使用，而使用 Boost.TypeIndex 库仍然没有问题。</p>
<p>当然，上面说的前提都是你在调试中试图获得变量的类型，而不是要获得一个多态对象的运行时类型。后者还是离不开 RTTI 的——虽然你也可以用一些其他方式来模拟 RTTI，但我个人觉得一般的项目不太有必要这样做。下面的代码展示了 typeid 和 type_id 在获取对象类型上的差异：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TYPEID(object, type)          \</span></span><br><span class="line"><span class="meta">    cout &lt;&lt; <span class="string">&quot;typeid(&quot;</span> #object &lt;&lt; <span class="string">&quot;)&quot;</span>        \</span></span><br><span class="line"><span class="meta">         &lt;&lt; (typeid(object) == typeid(type) \</span></span><br><span class="line"><span class="meta">                    ? <span class="string">&quot; is &quot;</span>                \</span></span><br><span class="line"><span class="meta">                    : <span class="string">&quot; is NOT &quot;</span>)           \</span></span><br><span class="line"><span class="meta">         &lt;&lt; #type &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TYPE_ID(object,              \</span></span><br><span class="line"><span class="meta">    type)                                  \</span></span><br><span class="line"><span class="meta">    cout &lt;&lt; <span class="string">&quot;type_id(&quot;</span> #object             \</span></span><br><span class="line"><span class="meta">         &lt;&lt; <span class="string">&quot;)&quot;</span>                            \</span></span><br><span class="line"><span class="meta">         &lt;&lt; (type_id&lt;decltype(             \</span></span><br><span class="line"><span class="meta">                            object)&gt;()     \</span></span><br><span class="line"><span class="meta">                        == type_id<span class="string">&lt;type&gt;</span>() \</span></span><br><span class="line"><span class="meta">                    ? <span class="string">&quot; is &quot;</span>               \</span></span><br><span class="line"><span class="meta">                    : <span class="string">&quot; is NOT &quot;</span>)          \</span></span><br><span class="line"><span class="meta">         &lt;&lt; #type &lt;&lt; endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shape* ptr = <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPEID</span>(*ptr, shape);</span><br><span class="line">    <span class="built_in">CHECK_TYPEID</span>(*ptr, circle);</span><br><span class="line">    <span class="built_in">CHECK_TYPE_ID</span>(*ptr, shape);</span><br><span class="line">    <span class="built_in">CHECK_TYPE_ID</span>(*ptr, circle);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeid(*ptr) is NOT shape</span><br><span class="line">typeid(*ptr) is circle</span><br><span class="line">type_id(*ptr) is shape</span><br><span class="line">type_id(*ptr) is NOT circle</span><br></pre></td></tr></table></figure>
<h4 id="24-4-Boost-Core">24.4 Boost.Core</h4>
<p>Core 里面提供了一些通用的工具，这些工具常常被 Boost 的其他库用到，而我们也可以使用，不需要链接任何库。在这些工具里，有些已经（可能经过一些变化后）进入了 C++ 标准，如：</p>
<ul>
<li>addressof，在即使用户定义了 operator&amp; 时也能获得对象的地址</li>
<li>enable_if，这个我们已经深入讨论过了（[第 14 讲]）</li>
<li>is_same，判断两个类型是否相同，C++11 开始在 <code>&lt;type_traits&gt;</code> 中定义</li>
<li>ref，和标准库的相同，我们在 <strong>[第 19 讲]</strong> 讨论线程时用过</li>
</ul>
<p>我们在剩下的里面来挑几个讲讲。</p>
<ol>
<li>
<p>boost::core::demangle</p>
<p>boost::core::demangle 能够用来把 typeid 返回的内部名称”反粉碎”（demangle）成可读的形式，看代码和输出应该就非常清楚了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/core/demangle.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::core::demangle;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">cbegin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** Using typeid\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(<span class="type">const</span> <span class="type">int</span>).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(v).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(it).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** Demangled\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">demangle</span>(<span class="built_in">typeid</span>(<span class="type">const</span> <span class="type">int</span>).<span class="built_in">name</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">demangle</span>(<span class="built_in">typeid</span>(v).<span class="built_in">name</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">demangle</span>(<span class="built_in">typeid</span>(it).<span class="built_in">name</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 下的输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Using typeid</span><br><span class="line">i</span><br><span class="line">St6vectorIiSaIiEE</span><br><span class="line">N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE</span><br><span class="line">*** Demangled</span><br><span class="line">int</span><br><span class="line">std::vector&lt;int, std::allocator&lt;int&gt; &gt;</span><br><span class="line">__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int,</span><br><span class="line">std::allocator&lt;int&gt; &gt; &gt;</span><br></pre></td></tr></table></figure>
<p>如果你不使用 RTTI 的话，那直接使用 TypeIndex 应该就可以。如果你需要使用 RTTI、又不是（只）使用 MSVC 的话，demangle 就会给你不少帮助。</p>
</li>
<li>
<p>boost::noncopyable</p>
<p>boost::noncopyable 提供了一种非常简单也很直白的把类声明成不可拷贝的方式。比如，我们 <strong>[第 1 讲]</strong> 里的 shape_wrapper，用下面的写法就明确表示了它不允许被拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/core/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> : <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你当然也可以自己把拷贝构造和拷贝赋值函数声明成 = delete，不过，上面的写法是不是可读性更佳？</p>
</li>
<li>
<p>boost::swap</p>
<p>你有没有印象在通用的代码如何对一个不知道类型的对象执行交换操作？不记得的话，标准做法是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，我们需要（在某个小作用域里）引入 std::swap，然后让编译器在”看得到” std::swap 的情况下去编译 swap 指令。根据 ADL，如果在被交换的对象所属类型的名空间下有 swap 函数，那个函数会被优先使用，否则，编译器会选择通用的 std::swap。似乎有点小啰嗦。使用 Boost 的话，你可以一行搞定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">swap</span>(lhs, rhs);</span><br></pre></td></tr></table></figure>
<p>当然，你需要包含头文件 <code>&lt;boost/core/swap.hpp&gt;</code>。</p>
</li>
</ol>
<h4 id="24-5-Boost-Conversion">24.5 Boost.Conversion</h4>
<p>Conversion 同样是一个不需要链接的轻量级的库。它解决了标准 C++ 里的另一个问题，标准类型之间的转换不够方便。在 C++11 之前，这个问题尤为严重。在 C++11 里，标准引入了一系列的函数，已经可以满足常用类型之间的转换。但使用 Boost.Conversion 里的 lexical_cast 更不需要去查阅方法名称或动脑子去努力记忆。</p>
<p>下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::bad_lexical_cast;</span><br><span class="line"><span class="keyword">using</span> boost::lexical_cast;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 整数到字符串的转换</span></span><br><span class="line">    <span class="type">int</span> d = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> d_str = <span class="built_in">lexical_cast</span>&lt;string&gt;(d);</span><br><span class="line">    cout &lt;&lt; d_str &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 字符串到浮点数的转换</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">lexical_cast</span>&lt;<span class="type">float</span>&gt;(d_str) / <span class="number">4.0</span>;</span><br><span class="line">    cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 测试 lexical_cast 的转换异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">lexical_cast</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (bad_lexical_cast&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试标准库 stoi 的转换异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = std::<span class="built_in">stoi</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (invalid_argument&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 下的输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">42</span><br><span class="line">10.5</span><br><span class="line">bad lexical cast: source type value could not be interpreted as</span><br><span class="line">target</span><br><span class="line">stoi</span><br></pre></td></tr></table></figure>
<p>我觉得 GCC 里 stoi 的异常输出有点太言简意赅了……而 lexical_cast 的异常输出在不同的平台上有很好的一致性。</p>
<h4 id="24-6-Boost-ScopeExit">24.6 Boost.ScopeExit</h4>
<p>我们说过 RAII 是推荐的 C++ 里管理资源的方式。不过，作为 C++ 程序员，跟 C 函数打交道也很正常。每次都写个新的 RAII 封装也有点浪费。Boost 里提供了一个简单的封装，你可以从下面的示例代码里看到它是如何使用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scope_exit.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Cannot open file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BOOST_SCOPE_EXIT</span>(&amp;fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;File is closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">BOOST_SCOPE_EXIT_END</span></span><br><span class="line"><span class="function">    <span class="title">puts</span><span class="params">(<span class="string">&quot;Faking an exception&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Exception received&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一需要说明的可能就是 BOOST_SCOPE_EXIT 里的那个 &amp; 符号了——把它理解成 lambda 表达式的按引用捕获就对了（虽然 BOOST_SCOPE_EXIT 可以支持 C++98 的代码）。如果不需要捕获任何变量，BOOST_SCOPE_EXIT 的参数必须填为 void。</p>
<p>使用这个库也只需要头文件。注意实现类似的功能在 C++11 里相当容易，但由于 ScopeExit 可以支持 C++98 的代码，因而它的实现还是相当复杂的。</p>
<h4 id="24-6-Boost-Program-options">24.6 Boost.Program_options</h4>
<p>传统上 C 代码里处理命令行参数会使用 getopt。我也用过，比如在下面的代码中：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/adah1972/breaktext/blob/master/breaktext.c">https://github.com/adah1972/breaktext/blob/master/breaktext.c</a></p>
<p>这种方式有不少缺陷：</p>
<ul>
<li>一个选项通常要在三个地方重复：说明文本里，getopt 的参数里，以及对 getopt 的返回结果进行处理时。不知道你觉得怎样，我反正发生过改了一处、漏改其他的错误。</li>
<li>对选项的附加参数需要手工写代码处理，因而常常不够严格（C 的类型转换不够方便，尤其是检查错误）。</li>
</ul>
<p>Program_options 正是解决这个问题的。这个代码有点老了，不过还挺实用；懒得去找特别的处理库时，至少这个伸手可用。使用这个库需要链接 boost_program_options 库。</p>
<p>下面的代码展示了代替上面的 getopt 用法的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> po = boost::program_options;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">string locale;</span><br><span class="line">string lang;</span><br><span class="line"><span class="type">int</span> width = <span class="number">72</span>;</span><br><span class="line"><span class="type">bool</span> keep_indent = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> verbose = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">po::options_description <span class="title">desc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;Usage: breaktext [OPTION]... &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;&lt;Input File&gt; [Output File]\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;Available options&quot;</span>)</span></span>;</span><br><span class="line">    desc.<span class="built_in">add_options</span>()(</span><br><span class="line">        <span class="string">&quot;locale,L&quot;</span>,</span><br><span class="line">        po::<span class="built_in">value</span>&lt;string&gt;(&amp;locale),</span><br><span class="line">        <span class="string">&quot;Locale of the console (system locale by default)&quot;</span>)(</span><br><span class="line">        <span class="string">&quot;lang,l&quot;</span>,</span><br><span class="line">        po::<span class="built_in">value</span>&lt;string&gt;(&amp;lang),</span><br><span class="line">        <span class="string">&quot;Language of input (asssume no language by default)&quot;</span>)(</span><br><span class="line">        <span class="string">&quot;width,w&quot;</span>,</span><br><span class="line">        po::<span class="built_in">value</span>&lt;<span class="type">int</span>&gt;(&amp;width),</span><br><span class="line">        <span class="string">&quot;Width of output text (72 by default)&quot;</span>)(<span class="string">&quot;help,h&quot;</span>, <span class="string">&quot;Show this help message and exit&quot;</span>)(</span><br><span class="line">        <span class="string">&quot;,i&quot;</span>,</span><br><span class="line">        po::<span class="built_in">bool_switch</span>(&amp;keep_indent),</span><br><span class="line">        <span class="string">&quot;Keep space indentation&quot;</span>)(</span><br><span class="line">        <span class="string">&quot;,v&quot;</span>,</span><br><span class="line">        po::<span class="built_in">bool_switch</span>(&amp;verbose),</span><br><span class="line">        <span class="string">&quot;Be verbose&quot;</span>);</span><br><span class="line"></span><br><span class="line">    po::variables_map vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        po::<span class="built_in">store</span>(po::<span class="built_in">parse_command_line</span>(argc, argv, desc), vm);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (po::error&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vm.<span class="built_in">notify</span>();</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="built_in">count</span>(<span class="string">&quot;help&quot;</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; desc &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>略加说明一下：</p>
<ul>
<li>options_description 是基本的选项描述对象的类型，构造时我们给出对选项的基本描述。</li>
<li>options_description 对象的 add_options 成员函数会返回一个函数对象，然后我们直接用括号就可以添加一系列的选项。</li>
<li>每个选项初始化时可以有两个或三个参数，第一项是选项的形式，使用长短选项用逗号隔开的字符串（可以只提供一种），最后一项是选项的文字描述，中间如果还有一项的话，就是选项的值描述。</li>
<li>选项的值描述可以用 value、bool_switch 等方法，参数是输出变量的指针。</li>
<li>variables_map，变量映射表，用来存储对命令行的扫描结果；它继承了标准的 std::map。</li>
<li>notify 成员函数用来把变量映射表的内容实际传送到选项值描述里提供的那些变量里去。</li>
<li>count 成员函数继承自 std::map，只能得到 0 或 1 的结果。</li>
</ul>
<h4 id="24-7-Boost-Hana">24.7 Boost.Hana</h4>
<p>Boost 里自然也有模板元编程相关的东西。但我不打算介绍 MPL、Fusion 和 Phoenix 那些，因为有些技巧，在 C++11 和 Lambda 表达式到来之后，已经略显得有点过时了。 Hana 则不同，它是一个使用了 C++11/14 实现技巧和惯用法的新库，也和一般的模板库一样，只要有头文件就能使用。</p>
<p>Hana 里定义了一整套供编译期使用的数据类型和函数。我们现在看一下它提供的部分类型：</p>
<ul>
<li>type：把类型转化成对象（我们在 <strong>[第 13 讲]</strong> 曾经示例过相反的动作，把数值转化成对象），来方便后续处理。</li>
<li>integral_constant：跟 std::integral_constant 相似，但定义了更多的运算符和语法糖。特别的，你可以用字面量来生成一个 long long 类型的<br>
integral_constant，如 1_c。</li>
<li>string：一个编译期使用的字符串类型。</li>
<li>tuple：跟 std::tuple 类似，意图是当作编译期的 vector 来使用。</li>
<li>map：编译期使用的关联数组。</li>
<li>set：编译期使用的集合。</li>
</ul>
<p>Hana 里的算法的名称跟标准库的类似，我就不一一列举了。下面的例子展示了一个基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/hana.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> hana = boost::hana;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> hana::literals;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tup = hana::<span class="built_in">make_tuple</span>(</span><br><span class="line">        hana::type_c&lt;shape*&gt;,</span><br><span class="line">        hana::type_c&lt;circle&gt;,</span><br><span class="line">        hana::type_c&lt;triangle&gt;);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> no_pointers = hana::<span class="built_in">remove_if</span>(</span><br><span class="line">        tup, [](<span class="keyword">auto</span> a) &#123;</span><br><span class="line">            <span class="keyword">return</span> hana::traits::<span class="built_in">is_pointer</span>(a);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        no_pointers == hana::<span class="built_in">make_tuple</span>(hana::type_c&lt;circle&gt;, hana::type_c&lt;triangle&gt;));</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        hana::<span class="built_in">reverse</span>(no_pointers) == hana::<span class="built_in">make_tuple</span>(hana::type_c&lt;triangle&gt;, hana::type_c&lt;circle&gt;));</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        tup[<span class="number">1</span>_c] == hana::type_c&lt;circle&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序可以编译，但没有任何运行输出。在这个程序里，我们做了下面这几件事：</p>
<ul>
<li>使用 type_c 把类型转化成 type 对象，并构造了类型对象的 tuple</li>
<li>使用 remove_if 算法移除了 tup 中的指针类型</li>
<li>使用静态断言确认了结果是我们想要的</li>
<li>使用静态断言确认了可以用 reverse 把 tup 反转一下</li>
<li>使用静态断言确认了可以用方括号运算符来获取 tup 中的某一项</li>
</ul>
<p>可以看到，Hana 本质上以类似普通的运行期编程的写法，来做编译期的计算。上面展示的只是一些最基本的用法，而 Hana 的文档里展示了很多有趣的用法。尤其值得一看的是，文档中展示了如何利用 Hana 提供的机制，来自己定义 <code>switch_</code>、<code>case_</code>、<code>default_</code>，使得下面的代码可以通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boost::any a = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">std::string r = switch_(a)(</span><br><span class="line">    <span class="built_in">case_</span>&lt;<span class="type">int</span>&gt;([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;int: &quot;</span>s + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="built_in">case_</span>&lt;<span class="type">char</span>&gt;([](<span class="keyword">auto</span> c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;char: &quot;</span>s + std::string &#123; c &#125;;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="built_in">default_</span>([] &#123; <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>s; &#125;));</span><br><span class="line"><span class="built_in">assert</span>(r == <span class="string">&quot;char: x&quot;</span>s);</span><br></pre></td></tr></table></figure>
<p>我个人认为很有意思。</p>
<h4 id="24-8-参考资料">24.8 参考资料</h4>
<ol>
<li>Boost C++ Libraries. <a target="_blank" rel="noopener" href="https://www.boost.org/">https://www.boost.org/</a></li>
<li>David Abarahams and Aleksey Gurtovoy, C++ Template Metaprogramming. Addison-Wesley, 2004. 有中文版（荣耀译，机械工业出版社，2010 年）</li>
</ol>
<h3 id="25-两个单元测试库：C-里如何进行单元测试">25 | 两个单元测试库：C++里如何进行单元测试?</h3>
<h4 id="25-1-Boost-Test">25.1 Boost.Test</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOST_TEST_MAIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/test/unit_test.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">42</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Not the answer&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(my_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOST_TEST_MESSAGE</span>(<span class="string">&quot;Testing&quot;</span>);</span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(<span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">BOOST_CHECK_THROW</span>(<span class="built_in">test</span>(<span class="number">41</span>), std::runtime_error);</span><br><span class="line">    <span class="built_in">BOOST_CHECK_NO_THROW</span>(<span class="built_in">test</span>(<span class="number">42</span>));</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(<span class="number">2</span> + <span class="number">2</span> == expected);</span><br><span class="line">    <span class="built_in">BOOST_CHECK</span>(<span class="number">2</span> + <span class="number">2</span> == expected);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(null_test)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里可以看到：</p>
<ul>
<li>我们在包含单元测试的头文件之前定义了 BOOST_TEST_MAIN。如果编译时用到了多个源文件，只有一个应该定义该宏。多文件测试的时候，我一般会考虑把这个定义这个宏加包含放在一个单独的文件里（只有两行）。</li>
<li>我们用 BOOST_AUTO_TEST_CASE 来定义一个测试用例。一个测试用例里应当有多个测试语句（如 BOOST_CHECK）。</li>
<li>我们用 BOOST_CHECK 或 BOOST_TEST 来检查一个应当成立的布尔表达式（区别下面会讲）。</li>
<li>我们用 BOOST_CHECK_THROW 来检查一个应当抛出异常的语句。</li>
<li>我们用 BOOST_CHECK_NO_THROW 来检查一个不应当抛出异常的语句。</li>
</ul>
<p>可以用下面的命令行来进行编译：</p>
<ul>
<li>MSVC：<code>cl /DBOOST_TEST_DYN_LINK /EHsc /MD test.cpp</code></li>
<li>GCC：<code>g++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></li>
<li>Clang：<code>clang++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></li>
</ul>
<p>运行结果如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630230458072.png" alt="image-20240630230458072"></p>
<p>我们现在能看到 BOOST_CHECK 和 BOOST_TEST 的区别了。后者是一个较新加入 Boost.Test 的宏，能利用模板技巧来输出表达式的具体内容。但在某些情况下， BOOST_TEST 试图输出表达式的内容会导致编译出错，这时可以改用更简单的 BOOST_CHECK。</p>
<p>不管是 BOOST_CHECK 还是 BOOST_TEST，在测试失败时，执行仍然会继续。在某些情况下，一个测试失败后继续执行后面的测试已经没有意义，这时，我们就可以考虑使用 BOOST_REQUIRE 或 BOOST_TEST_REQUIRE——表达式一旦失败，整个测试用例会停止执行（但其他测试用例仍会正常执行）。</p>
<p>缺省情况下单元测试的输出只包含错误信息和结果摘要，但输出的详细程度是可以通过命令行选项来进行控制的。如果我们在运行测试程序时加上命令行参数 —log_level=all（或 -l all），我们就可以得到下面这样更详尽的输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630230513473.png" alt="image-20240630230513473"></p>
<p>现在额外可以看到：</p>
<ul>
<li>在进入、退出测试模块和用例时的提示</li>
<li>BOOST_TEST_MESSAGE 的输出</li>
<li>正常通过的测试的输出</li>
<li>用例里无测试断言的警告</li>
</ul>
<p>使用 Windows 的同学如果运行了测试程序的话，多半会惊恐地发现终端上的文字颜色已经发生了变化。这似乎是 Boost.Test 在 Windows 上特有的一个问题：建议你把单元测试的色彩显示关掉。你可以在系统高级设置里添加下面这个环境变量，也可以直接在命令行上输入：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> BOOST_TEST_COLOR_OUTPUT=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Boost.Test 产生的可执行代码支持很多命令行参数，可以用 —help 命令行选项来查看。常用的有：</p>
<ul>
<li>build_info 可用来展示构建信息</li>
<li>color_output 可用来打开或关闭输出中的色彩</li>
<li>log_format 可用来指定日志输出的格式，包括纯文本、XML、JUnit 等</li>
<li>log_level 可指定日志输出的级别，有 all、test_suite、error、fatal_error、nothing等一共 11 个级别</li>
<li>run_test 可选择只运行指定的测试用例</li>
<li>show_progress 可在测试时显示进度，在测试数量较大时比较有用（见下图）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240630230536028.png" alt="image-20240630230536028"></p>
<h4 id="25-2-Catch2">25.2 Catch2</h4>
<p>优点：</p>
<ul>
<li>只需要单个头文件即可使用，不需要安装和链接，简单方便</li>
<li>可选使用 BDD（Behavior-Driven Development）风格的分节形式</li>
<li>测试失败可选直接进入调试器（Windows 和 macOS 上）</li>
</ul>
<p>拿前面 Boost.Test 的示例直接改造一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CATCH_CONFIG_MAIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;catch.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">42</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Not the answer&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_CASE</span>(<span class="string">&quot;My first test&quot;</span>, <span class="string">&quot;[my]&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;Testing&quot;</span>);</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">CHECK_THROWS_AS</span>(<span class="built_in">test</span>(<span class="number">41</span>), std::runtime_error);</span><br><span class="line">    <span class="built_in">CHECK_NOTHROW</span>(<span class="built_in">test</span>(<span class="number">42</span>));</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="number">2</span> + <span class="number">2</span> == expected);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_CASE</span>(<span class="string">&quot;A null test&quot;</span>, <span class="string">&quot;[null]&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例的参数：第一项是名字，第二项是标签，可以一个或多个。你除了可以直接在命令行上写测试的名字（不需要选项）来选择运行哪个测试外，也可以写测试的标签来选择运行哪些测试。</p>
<p>这是它在 Windows 下用 MSVC 编译的输出。</p>
<p>终端的色彩不会被搞乱。缺省的输出清晰程度相当不错。至少在 Windows 下，它看起来可能是个比 Boost.Test 更好的选择。但反过来，在浅色的终端里，Catch2 的色彩不太友好。Boost.Test 在 Linux 和 macOS 下则不管终端的色彩设定，都有比较友好的输出。</p>
<p>和 Boost.Test 类似，Catch2 的测试结果输出格式也是可以修改的。默认格式是纯文本，但你可以通过使用 -r junit 来设成跟 JUnit 兼容的格式，或使用 -r xml 输出成 Catch2 自己的 XML 格式。这方面，它比 Boost.Test 明显易用的一个地方是格式参数大小写不敏感，而在 Boost.Test 里你必须用全大写的形式，如 -f JUNIT，麻烦！</p>
<p>BDD 风格的测试一般采用这样的结构：</p>
<ul>
<li>Scenario：场景，我要做某某事</li>
<li>Given：给定，已有的条件</li>
<li>When：当，某个事件发生时</li>
<li>Then：那样，就应该发生什么</li>
</ul>
<p>如果我们要测试一个容器，那代码就应该是这个样子的：</p>
<p>cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SCENARIO</span>(<span class="string">&quot;Int container can be accessed and modified&quot;</span>, <span class="string">&quot;[container]&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GIVEN</span>(<span class="string">&quot;A container with initialized items&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IntContainer c &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="built_in">REQUIRE</span>(c.<span class="built_in">size</span>() == <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">WHEN</span>(<span class="string">&quot;I access existing items&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">THEN</span>(<span class="string">&quot;The items can be retrieved intact&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">1</span>] == <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">2</span>] == <span class="number">3</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">3</span>] == <span class="number">4</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">4</span>] == <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">WHEN</span>(<span class="string">&quot;I modify items&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c[<span class="number">1</span>] = <span class="number">-2</span>;</span><br><span class="line">            c[<span class="number">3</span>] = <span class="number">-4</span>;</span><br><span class="line">            <span class="built_in">THEN</span>(<span class="string">&quot;Only modified items are changed&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">1</span>] == <span class="number">-2</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">2</span>] == <span class="number">3</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">3</span>] == <span class="number">-4</span>);</span><br><span class="line">                <span class="built_in">CHECK</span>(c[<span class="number">4</span>] == <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在程序前面加上类型定义来测试你自己的容器类或标准容器（如 <code>vector&lt;int&gt;</code>）。这是一种非常直观的写测试的方式。正常情况下，你当然应该看到：</p>
<blockquote>
<p>All tests passed (12 assertions in 1 test case)</p>
</blockquote>
<p>如果你没有留意到的话，在 GIVEN 里 WHEN 之前的代码是在每次 WHEN 之前都会执行一遍的。这也是 BDD 方式的一个非常方便的地方。</p>
<p>如果测试失败，我们就能看到类似下面这样的信息输出了（我存心制造了一个错误）。</p>
<p>如果没有失败的情况下，想看到具体的测试内容，可以传递参数 —success（或 -s）。</p>
<h4 id="25-3-参考资料">25.3 参考资料</h4>
<ol>
<li>Gennadiy Rozental and Raffi Enficiaud, Boost.Test. <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html">https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html</a></li>
<li>Two Blue Cubes Ltd., Catch2. <a target="_blank" rel="noopener" href="https://github.com/catchorg/Catch2">https://github.com/catchorg/Catch2</a></li>
<li>Wikipedia, “Behavior-driven development”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Behavior-driven_development">https://en.wikipedia.org/wiki/Behavior-driven_development</a></li>
</ol>
<h3 id="26-Easylogging-和spdlog：两个好用的日志库">26 | Easylogging++和spdlog：两个好用的日志库</h3>
<h4 id="26-1-Easylogging">26.1 Easylogging++</h4>
<p>事实上，我本来想只介绍 Easylogging++ 的。但在检查其 GitHub 页面时，我发现了一个问题：它在 2019 年基本没有更新，且目前上报的问题也没有人处理。</p>
<ol>
<li>
<p>概述</p>
<p>Easylogging++ 一共只有两个文件，一个是头文件，一个是普通 C++ 源文件。事实上，它的一个较早版本只有一个文件。正如 Catch2 里一旦定义了 CATCH_CONFIG_MAIN 编译速度会大大减慢一样，把什么东西都放一起最终证明对编译速度还是相当不利的，因此，有人提交了一个补丁，把代码拆成了两个文件。使用 Easylogging++ 也只需要这两个文件——除此之外，就只有对标准和系统头文件的依赖了。</p>
<p>要使用 Easylogging++，推荐直接把这两个文件放到你的项目里。Easylogging++ 有很多的配置项会影响编译结果，我们先大致查看一下常用的可配置项：</p>
<ul>
<li>ELPP_UNICODE：启用 Unicode 支持，为在 Windows 上输出混合语言所必需</li>
<li>ELPP_THREAD_SAFE：启用多线程支持</li>
<li>ELPP_DISABLE_LOGS：全局禁用日志输出</li>
<li>ELPP_DEFAULT_LOG_FILE：定义缺省日志文件名称</li>
<li>ELPP_NO_DEFAULT_LOG_FILE：不使用缺省的日志输出文件</li>
<li>ELPP_UTC_DATETIME：在日志里使用协调世界时而非本地时间</li>
<li>ELPP_FEATURE_PERFORMANCE_TRACKING：开启性能跟踪功能</li>
<li>ELPP_FEATURE_CRASH_LOG：启用 GCC 专有的崩溃日志功能</li>
<li>ELPP_SYSLOG：允许使用系统日志（Unix 世界的 syslog）来记录日志</li>
<li>ELPP_STL_LOGGING：允许在日志里输出常用的标准容器对象（std::vector 等）</li>
<li>ELPP_QT_LOGGING：允许在日志里输出 Qt 的核心对象（QVector 等）</li>
<li>ELPP_BOOST_LOGGING：允许在日志里输出某些 Boost 的容器（boost::container::vector 等）</li>
<li>ELPP_WXWIDGETS_LOGGING：允许在日志里输出某些 wxWidgets 的模板对象（wxVector 等）</li>
</ul>
</li>
<li>
<p>开始使用 Easylogging++</p>
<p>一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;easylogging++.h&quot;</span></span></span><br><span class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;My first info log&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出到终端和 myeasylog.log 文件里：</p>
<blockquote>
<p>2020-01-25 20:47:50,990 INFO [default] My first info log</p>
</blockquote>
</li>
<li>
<p>使用 Unicode</p>
<p>就我们日志输出而言，启用 Unicode 支持的好处是：</p>
<ul>
<li>
<p>可以使用宽字符来输出</p>
</li>
<li>
<p>日志文件的格式是 UTF-8，而不是传统的字符集，只能支持一种文字</p>
<p>要启用 Unicode 支持，你需要定义宏 ELPP_UNICODE，并确保程序中有对 std::locale::global 或 setlocale 的调用（如 [第 11 讲] 中所述，只有进行了正确的区域设置，才能输出含非 ASCII 字符的宽字符串）。下面的程序给出了一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;easylogging++.h&quot;</span></span></span><br><span class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">L&quot;测试 test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>改变输出文件名</p>
<p>Easylogging++ 的缺省输出日志名为 myeasylog.log，可以直接在命令行上使用宏定义来修改。只需要在命令行上加入下面的选项就可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DELPP_DEFAULT_LOG_FILE=\&quot;test.log\&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用配置文件设置日志选项</p>
<p>Easylogging++ 库自己支持配置文件。我自己使用的配置文件是这个样子的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* GLOBAL:</span><br><span class="line">   FORMAT               =  &quot;%datetime&#123;%Y-%M-%d %H:%m:%s.%g&#125; %levshort %msg&quot;</span><br><span class="line">   FILENAME             =  &quot;test.log&quot;</span><br><span class="line">   ENABLED              =  true</span><br><span class="line">   TO_FILE              =  true     ## 输出到文件</span><br><span class="line">   TO_STANDARD_OUTPUT   =  true     ## 输出到标准输出</span><br><span class="line">   SUBSECOND_PRECISION  =  6        ## 秒后面保留 6 位</span><br><span class="line">   MAX_LOG_FILE_SIZE    =  2097152  ## 最大日志文件大小设为 2MB</span><br><span class="line">   LOG_FLUSH_THRESHOLD  =  10       ## 写 10 条日志刷新一次缓存</span><br><span class="line">* DEBUG:</span><br><span class="line">   FORMAT               = &quot;%datetime&#123;%Y-%M-%d %H:%m:%s.%g&#125; %levshort [%fbase:%line] %msg&quot;</span><br><span class="line">   TO_FILE              =  true</span><br><span class="line">   TO_STANDARD_OUTPUT   =  false    ## 调试日志不输出到标准输出</span><br></pre></td></tr></table></figure>
<p>假设这个配置文件的名字是 log.conf，我们在代码中可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;easylogging++.h&quot;</span></span></span><br><span class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    el::Configurations conf &#123; <span class="string">&quot;log.conf&quot;</span> &#125;;</span><br><span class="line">    el::Loggers::<span class="built_in">reconfigureAllLoggers</span>(conf);</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;A debug message&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;An info message&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意编译命令行上应当加上 -DELPP_NO_DEFAULT_LOG_FILE，否则 Easylogging++ 仍然会生成缺省的日志文件。</p>
<p>此外，我也推荐在编译时定义宏 ELPP_DEBUG_ASSERT_FAILURE，这样能在找不到配置文件时直接终止程序，而不是继续往下执行、在终端上以缺省的方式输出日志了。</p>
</li>
<li>
<p>性能跟踪</p>
<p>Easylogging++ 可以用来在日志中记录程序执行的性能数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;easylogging++.h&quot;</span></span></span><br><span class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TIMED_FUNC</span>(timer);</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;A warning message&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="built_in">TIMED_SCOPE</span>(timer1, <span class="string">&quot;void bar()&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">TIMED_BLOCK</span>(timer2, <span class="string">&quot;a block&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100u</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    el::Configurations conf &#123; <span class="string">&quot;log.conf&quot;</span> &#125;;</span><br><span class="line">    el::Loggers::<span class="built_in">reconfigureAllLoggers</span>(conf);</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单说明一下：</p>
<ul>
<li>
<p>TIMED_FUNC 接受一个参数，是用于性能跟踪的对象的名字。它能自动产生函数的名称。示例中的 TIMED_FUNC 和 TIMED_SCOPE 的作用是完全相同的。</p>
</li>
<li>
<p>TIMED_SCOPE 接受两个参数，分别是用于性能跟踪的对象的名字，以及用于记录的名字。如果你不喜欢 TIMED_FUNC 生成的函数名字，可以用 TIMED_SCOPE 来代替。</p>
</li>
<li>
<p>TIMED_BLOCK 用于对下面的代码块进行性能跟踪，参数形式和 TIMED_SCOPE 相同。</p>
<p>在编译含有上面三个宏的代码时，需要定义宏 ELPP_FEATURE_PERFORMANCE_TRACKING。你一般也应该定义 ELPP_PERFORMANCE_MICROSECONDS，来获取微秒级的精度。下面是定义了上面两个宏编译的程序的某次执行的结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2020-01-26 15:00:11.99736 W A warning message</span><br><span class="line">2020-01-26 15:00:11.99748 I Executed [void foo()] in [110 us]</span><br><span class="line">2020-01-26 15:00:11.99749 W A warning message</span><br><span class="line">2020-01-26 15:00:11.99750 I Executed [void foo()] in [5 us]</span><br><span class="line">2020-01-26 15:00:11.99750 W A warning message</span><br><span class="line">2020-01-26 15:00:11.99751 I Executed [void foo()] in [4 us]</span><br><span class="line">2020-01-26 15:00:11.99774 I Executed [a block] in [232 us]</span><br><span class="line">2020-01-26 15:00:11.99776 I Executed [void bar()] in [398 us]</span><br></pre></td></tr></table></figure>
<p>不过需要注意，由于 Easylogging++ 本身有一定开销，且开销有一定的不确定性，这种方式只适合颗粒度要求比较粗的性能跟踪。</p>
<p>性能跟踪产生的日志级别固定为 Info。性能跟踪本身可以在配置文件里的 GLOBAL 节下用 PERFORMANCE_TRACKING = false 来关闭。当然，关闭所有 Info 级别的输出也能达到关闭性能跟踪的效果。</p>
</li>
</ul>
</li>
<li>
<p>记录崩溃日志</p>
<p>在 GCC 和 Clang 下，通过定义宏 ELPP_FEATURE_CRASH_LOG 我们可以启用崩溃日志。此时，当程序崩溃时，Easylogging++ 会自动在日志中记录程序的调用栈信息。通过记录下的信息，再利用 addr2line 这样的工具，我们就能知道是程序的哪一行引发了崩溃。下面的代码可以演示这一行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;easylogging++.h&quot;</span></span></span><br><span class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boom</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    el::Configurations conf &#123; <span class="string">&quot;log.conf&quot;</span> &#125;;</span><br><span class="line">    el::Loggers::<span class="built_in">reconfigureAllLoggers</span>(conf);</span><br><span class="line">    <span class="built_in">boom</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 macOS 的需要特别注意一下：由于缺省方式产生的可执行文件是位置独立的，系统每次加载程序会在不同的地址，导致无法通过地址定位到程序行。在编译命令行尾部加上 <code>-Wl,-no_pie</code> 可以解决这个问题。</p>
</li>
</ol>
<h4 id="26-2-spdlog">26.2 spdlog</h4>
<p>跟 Easylogging++ 比起来，spdlog 要新得多了：前者是 2012 年开始的项目，而后者是 2014 年开始的。我在 2016 年末开始在项目中使用 Easylogging++ 时，Easylogging++的版本是 9.85 左右，而 spdlog 大概是 0.11，成熟度和热度都不那么高。</p>
<p>功能点：</p>
<ul>
<li>非常快（性能是其主要目标）</li>
<li>只需要头文件即可使用</li>
<li>没有其他依赖</li>
<li>跨平台</li>
<li>有单线程和多线程的日志记录器</li>
<li>日志文件旋转切换</li>
<li>每日日志文件</li>
<li>终端日志输出</li>
<li>可选异步日志</li>
<li>多个日志级别</li>
<li>通过用户自定义式样来定制输出格式</li>
</ul>
<ol>
<li>
<p>开始使用 spdlog</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spdlog::<span class="built_in">info</span>(<span class="string">&quot;My first info log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里看不到的是，输出结果中的”info”字样是彩色的，方便快速识别日志的级别。这个功能在 Windows、Linux 和 macOS 上都能正常工作，对用户还是相当友好的。不过，和 Easylogging++ 缺省就会输出到文件中不同，spdlog 缺省只是输出到终端而已。</p>
<p>spdlog 不是使用 IO 流风格的输出了。它采用跟 Python 里的 str.format 一样的方式，使用大括号——可选使用序号和格式化要求——来对参数进行格式化。下面是一个很简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">warn</span>(<span class="string">&quot;Message with arg &#123;&#125;&quot;</span>, <span class="number">42</span>);</span><br><span class="line">spdlog::<span class="built_in">error</span>(<span class="string">&quot;&#123;0:d&#125;, &#123;0:x&#125;, &#123;0:o&#125;, &#123;0:b&#125;&quot;</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>输出会像下面这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2020-01-26 17:20:08.355] [warning] Message with arg 42</span><br><span class="line">[2020-01-26 17:20:08.355] [error] 42, 2a, 52, 101010</span><br></pre></td></tr></table></figure>
<p>事实上，这就是 C++20 的 format 的风格了——spdlog 就是使用了一个 format 的库实现 fmt [3]。</p>
</li>
<li>
<p>设置输出文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">&quot;basic_logger&quot;</span>, <span class="string">&quot;test.log&quot;</span>);</span><br><span class="line">    spdlog::<span class="built_in">set_default_logger</span>(file_logger);</span><br><span class="line">    spdlog::<span class="built_in">info</span>(<span class="string">&quot;Into file: &#123;1&#125; &#123;0&#125;&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后，终端上没有任何输出，但 test.log 文件里就会增加如下的内容：</p>
<blockquote>
<p>[2020-01-26 17:47:37.864] [basic_logger] [info] Into file: hello world</p>
</blockquote>
<p>如果同时输出到终端和文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/stdout_color_sinks.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> spdlog::sinks;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_multi_sink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> console_sink = <span class="built_in">make_shared</span>&lt;stdout_color_sink_mt&gt;();</span><br><span class="line">    console_sink-&gt;<span class="built_in">set_level</span>(spdlog::level::warn);</span><br><span class="line">    console_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;%H:%M:%S.%e %^%L%$ %v&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> file_sink = <span class="built_in">make_shared</span>&lt;basic_file_sink_mt&gt;(<span class="string">&quot;test.log&quot;</span>);</span><br><span class="line">    file_sink-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line">    file_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f %L %v&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> logger = <span class="built_in">shared_ptr</span>&lt;spdlog::logger&gt;(</span><br><span class="line">        <span class="keyword">new</span> spdlog::<span class="built_in">logger</span>(<span class="string">&quot;multi_sink&quot;</span>, &#123; console_sink, file_sink &#125;));</span><br><span class="line">    logger-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">    spdlog::<span class="built_in">set_default_logger</span>(logger);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set_multi_sink</span>();</span><br><span class="line">    spdlog::<span class="built_in">warn</span>(<span class="string">&quot;this should appear in both console and file&quot;</span>);</span><br><span class="line">    spdlog::<span class="built_in">info</span>(<span class="string">&quot;this message should not appear in the console, only in the file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致说明一下：</p>
<ul>
<li>console_sink 是一个指向 stdout_color_sink_mt 的智能指针，我们设定让它只显示警告级别及以上的日志信息，并把输出式样调整成带毫秒的时间、有颜色的短级别以及信息本身。</li>
<li>file_sink 是一个指向 basic_file_sink_mt 的智能指针，我们设定让它显示跟踪级别及以上（也就是所有级别了）的日志信息，并把输出式样调整成带微秒的日期时间、短级别以及信息本身。</li>
<li>然后我们创建了日志记录器，让它具有上面的两个日志槽。注意这儿的两个细节：
<ol>
<li>这儿的接口普遍使用 shared_ptr；</li>
<li>由于 make_shared 在处理 initializer_list 上的缺陷，对 spdlog::logger 的构造只能直接调用 shared_ptr 的构造函数，而不能使用 make_shared，否则编译会出错。</li>
</ol>
</li>
<li>最后我们调用了 spdlog::set_default_logger 把缺省的日志记录器设置成刚创建的对象。这样，之后的日志缺省就会记录到这个新的日志记录器了（我们当然也可以手工调用这个日志记录器的 critical、error、warn 等日志记录方法）。</li>
</ul>
</li>
<li>
<p>日志文件切换</p>
<p>在 Easylogging++ 里实现日志文件切换是需要写代码的，而且完善的多文件切换代码需要写上几十行代码才能实现。这项工作在 spdlog 则是超级简单的，因为 spdlog 直接提供了一个实现该功能的日志槽。把上面的例子改造成带日志文件切换我们只需要修改两处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/rotating_file_sink.h&quot;</span></span></span><br><span class="line"><span class="comment">// 替换 basic_file_sink.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> file_sink = <span class="built_in">make_shared</span>&lt;rotating_file_sink_mt&gt;(<span class="string">&quot;test.log&quot;</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 替换 basic_file_sink_mt，文件大</span></span><br><span class="line"><span class="comment">// 小为 5MB，一共保留 3 个日志文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>适配用户定义的流输出</p>
<p>虽然 spdlog 缺省不支持容器的输出，但是，它是可以和用户提供的流 &lt;&lt; 运算符协同工作的。如果我们要输出普通容器的话，我们只需要在代码开头加入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output_container.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/fmt/ostr.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>前一行包含了我们用于容器输出的代码，后一行包含了 spdlog 使用 ostream 来输出对象的能力。注意此处包含的顺序是重要的：spdlog 必须能看到用户的 &lt;&lt; 的定义。在有了这两行之后，我们就可以像下面这样写代码了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Content of vector: &#123;&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只用头文件吗？</p>
<p>使用 spdlog 可以使用只用头文件的方式，也可以使用预编译的方式。</p>
</li>
<li>
<p>其他</p>
<p>下面这些功能点值得提一下：</p>
<ul>
<li>可以使用多个不同的日志记录器，用于不同的模块或功能。</li>
<li>可以使用异步日志，减少记日志时阻塞的可能性。</li>
<li>通过 spdlog::to_hex 可以方便地在日志里输出二进制信息。</li>
<li>可用的日志槽还有 syslog、systemd、Android、Windows 调试输出等；扩展新的日志槽较为容易。</li>
</ul>
</li>
</ol>
<h4 id="26-3-参考资料">26.3 参考资料</h4>
<ol>
<li>Amrayn Web Services, easyloggingpp. <a target="_blank" rel="noopener" href="https://github.com/amrayn/easyloggingpp">https://github.com/amrayn/easyloggingpp</a></li>
<li>Gabi Melman, spdlog. <a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></li>
<li>Victor Zverovich, fmt. <a target="_blank" rel="noopener" href="https://github.com/fmtlib/fmt">https://github.com/fmtlib/fmt</a></li>
<li>Andrey Semashev, Boost.Log v2. <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html">https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html</a></li>
<li>Kjell Hedström, g3log. <a target="_blank" rel="noopener" href="https://github.com/KjellKod/g3log">https://github.com/KjellKod/g3log</a></li>
<li>Stanford University, NanoLog. <a target="_blank" rel="noopener" href="https://github.com/PlatformLab/NanoLog">https://github.com/PlatformLab/NanoLog</a></li>
</ol>
<h3 id="27-C-REST-SDK：使用现代C-开发网络应用">27 | C++ REST SDK：使用现代C++开发网络应用</h3>
<p>C++ REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C++ 库。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>现代C++实战30讲</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/ab4dcc4b.html">https://penge666.github.io/posts/ab4dcc4b.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-04-06</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-01</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Cpp</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>读书笔记</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/af408df9.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_80.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Modern Cpp</div></div></a></div><div class="next-post pull-right"><a href="/posts/1bd023c5.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_30.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/af408df9.html" title="Modern Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-09</div><div class="title">Modern Cpp</div></div></a></div><div><a href="/posts/e584d079.html" title="More Effective Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-12</div><div class="title">More Effective Cpp</div></div></a></div><div><a href="/posts/bf4dced7.html" title="Effective Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_34.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-13</div><div class="title">Effective Cpp</div></div></a></div><div><a href="/posts/ccc0d0ac.html" title="Effectivate Modern Cpp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_107.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-09</div><div class="title">Effectivate Modern Cpp</div></div></a></div><div><a href="/posts/4772239d.html" title="Cpp基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_30.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-21</div><div class="title">Cpp基础知识</div></div></a></div><div><a href="/posts/a5a0c60f.html" title="内存屏障"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_91.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-26</div><div class="title">内存屏障</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E4%B8%A8%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">01丨基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII%EF%BC%9AC-%E9%87%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-text">01 | 堆、栈、RAII：C++里该如何管理资源？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%A0%86"><span class="toc-text">1.2 堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%A0%88"><span class="toc-text">1.3 栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-RAII"><span class="toc-text">1.4 RAII</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">1.5 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%8C%E5%AE%9E%E7%8E%B0C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">02 | 自己动手，实现C++的智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%9B%9E%E9%A1%BE"><span class="toc-text">2.1 回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%92%8C%E6%98%93%E7%94%A8%E6%80%A7"><span class="toc-text">2.2 模板化和易用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">2.3 拷贝构造和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E2%80%9C%E7%A7%BB%E5%8A%A8%E2%80%9D%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">2.4 “移动”指针？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88%E5%90%91%E5%9F%BA%E7%B1%BB%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.5 子类指针向基类指针的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">2.6 引用计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.7 指针类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-%E4%BB%A3%E7%A0%81%E5%88%97%E8%A1%A8"><span class="toc-text">2.8 代码列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">2.9 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%A9%B6%E7%AB%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">03 | 右值和移动究竟解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%80%BC%E5%88%86%E5%B7%A6%E5%8F%B3"><span class="toc-text">3.1 值分左右</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2 生命周期和表达式类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">3.3 移动的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%EF%BC%9F"><span class="toc-text">3.4 如何实现移动？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">3.5 不要返回本地变量的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%BC%95%E7%94%A8%E5%9D%8D%E7%BC%A9%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">3.6 引用坍缩和完美转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">3.7 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%AE%B9%E5%99%A8%E6%B1%87%E7%BC%96-I%EF%BC%9A%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%AE%B9%E5%99%A8"><span class="toc-text">04 | 容器汇编 I：比较简单的若干容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-string"><span class="toc-text">4.1 string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-vector"><span class="toc-text">4.2 vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-deque"><span class="toc-text">4.3 deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-list"><span class="toc-text">4.4 list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-forward-list"><span class="toc-text">4.5 forward_list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-queue"><span class="toc-text">4.6 queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-stack"><span class="toc-text">4.7 stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">4.8 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E5%AE%B9%E5%99%A8%E6%B1%87%E7%BC%96-II%EF%BC%9A%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">05 | 容器汇编 II：需要函数对象的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%89%B9%E5%8C%96"><span class="toc-text">5.1 函数对象及其特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-priority-queue"><span class="toc-text">5.2 priority_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">5.3 关联容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">5.4 无序关联容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-array"><span class="toc-text">5.5 array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">5.6 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E5%BC%82%E5%B8%B8%EF%BC%9A%E7%94%A8%E8%BF%98%E6%98%AF%E4%B8%8D%E7%94%A8%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-text">06 | 异常：用还是不用，这是个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%B2%A1%E6%9C%89%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%96%E7%95%8C"><span class="toc-text">6.1 没有异常的世界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="toc-text">6.2 使用异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E9%81%BF%E5%85%8D%E5%BC%82%E5%B8%B8%E7%9A%84%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%9F"><span class="toc-text">6.3 避免异常的风格指南？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%BC%82%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">6.4 异常的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-text">6.5 使用异常的理由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">6.6 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%A5%BD%E7%94%A8%E7%9A%84%E6%96%B0for%E5%BE%AA%E7%8E%AF"><span class="toc-text">07 | 迭代器和好用的新for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-text">7.1 什么是迭代器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%B8%B8%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">7.2 常用迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E4%BD%BF%E7%94%A8%E8%BE%93%E5%85%A5%E8%A1%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">7.3 使用输入行迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E8%A1%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">7.4 定义输入行迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">7.5 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-%E6%98%93%E7%94%A8%E6%80%A7%E6%94%B9%E8%BF%9B-I%EF%BC%9A%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">08 | 易用性改进 I：自动类型推断和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">8.1 自动类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">8.2 函数返回值类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="toc-text">8.3 类模板的模板参数推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="toc-text">8.4 结构化绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">8.5 列表初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">8.6 统一初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">8.7 类数据成员的默认初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">8.8 参考资料</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E4%B8%A8%E6%8F%90%E9%AB%98%E7%AF%87"><span class="toc-text">02丨提高篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%B0%E5%BA%95%E5%BA%94%E4%B8%8D%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">10 | 到底应不应该返回对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-F-20"><span class="toc-text">10.1 F.20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">10.2 如何返回一个对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%EF%BC%88%E6%8B%B7%E8%B4%9D%E6%B6%88%E9%99%A4%EF%BC%89"><span class="toc-text">10.3 返回值优化（拷贝消除）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E5%9B%9E%E5%88%B0-F-20"><span class="toc-text">10.4 回到 F.20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">10.5 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Unicode%EF%BC%9A%E8%BF%9B%E5%85%A5%E5%A4%9A%E6%96%87%E5%AD%97%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%96%E7%95%8C"><span class="toc-text">11 | Unicode：进入多文字支持的世界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-%E4%B8%80%E4%BA%9B%E5%8E%86%E5%8F%B2"><span class="toc-text">11.1 一些历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-Unicode-%E7%AE%80%E4%BB%8B"><span class="toc-text">11.2 Unicode 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-C-%E4%B8%AD%E7%9A%84-Unicode-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-text">11.3 C++ 中的 Unicode 字符类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-%E5%B9%B3%E5%8F%B0%E5%8C%BA%E5%88%AB"><span class="toc-text">11.4 平台区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-%E7%BB%9F%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-text">11.5 统一化处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-%E7%BC%96%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="toc-text">11.6 编程支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">11.7 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%85%A5%E9%97%A8"><span class="toc-text">12 | 编译期多态：泛型编程和模板入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">12.1 面向对象和多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%85%B1%E6%80%A7"><span class="toc-text">12.2 容器类的共性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-C-%E6%A8%A1%E6%9D%BF"><span class="toc-text">12.3 C++ 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-%E2%80%9C%E5%8A%A8%E6%80%81%E2%80%9D%E5%A4%9A%E6%80%81%E5%92%8C%E2%80%9D%E9%9D%99%E6%80%81%E2%80%9D%E5%A4%9A%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">12.4 “动态”多态和”静态”多态的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">12.5 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%BC%96%E8%AF%91%E6%9C%9F%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%96%E7%95%8C"><span class="toc-text">13 | 编译期能做些什么？一个完整的计算世界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="toc-text">13.1 编译期计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-%E7%BC%96%E8%AF%91%E6%9C%9F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">13.2 编译期类型推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-%E7%AE%80%E6%98%93%E5%86%99%E6%B3%95"><span class="toc-text">13.3 简易写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-%E9%80%9A%E7%94%A8%E7%9A%84-fmap-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">13.4 通用的 fmap 函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">13.5 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-SFINAE%EF%BC%9A%E4%B8%8D%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%A4%B1%E8%B4%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="toc-text">14 | SFINAE：不是错误的替换失败是怎么回事?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD%E5%86%B3%E8%AE%AE"><span class="toc-text">14.1 函数模板的重载决议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E7%BC%96%E8%AF%91%E6%9C%9F%E6%88%90%E5%91%98%E6%A3%80%E6%B5%8B"><span class="toc-text">14.2 编译期成员检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-SFINAE-%E6%A8%A1%E6%9D%BF%E6%8A%80%E5%B7%A7"><span class="toc-text">14.3 SFINAE 模板技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-text">14.4 静态多态的限制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">14.5 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-constexpr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%B8%B8%E6%80%81%E7%9A%84%E4%B8%96%E7%95%8C"><span class="toc-text">15 | constexpr：一个常态的世界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-constexpr-%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="toc-text">15.2 constexpr 和编译期计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-constexpr-%E5%92%8C-const"><span class="toc-text">15.3 constexpr 和 const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F"><span class="toc-text">15.4 内联变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-constexpr-%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="toc-text">15.5 constexpr 变量模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-6-constexpr-%E5%8F%98%E9%87%8F%E4%BB%8D%E6%98%AF-const"><span class="toc-text">15.6 constexpr 变量仍是 const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-7-constexpr-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-text">15.7 constexpr 构造函数和字面类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-8-if-constexpr"><span class="toc-text">15.8 if constexpr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-9-output-container-h-%E8%A7%A3%E8%AF%BB"><span class="toc-text">15.9 output_container.h 解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-10-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">15.10 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8Clambda%EF%BC%9A%E8%BF%9B%E5%85%A5%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">16 | 函数对象和lambda：进入函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-C-98-%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">16.1 C++98 的函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">16.2 函数的指针和引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">16.3 Lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7"><span class="toc-text">16.4 变量捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-%E6%B3%9B%E5%9E%8B-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">16.5 泛型 lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-6-bind-%E6%A8%A1%E6%9D%BF"><span class="toc-text">16.6 bind 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-7-function-%E6%A8%A1%E6%9D%BF"><span class="toc-text">16.7 function 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">16.8 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%B8%80%E7%A7%8D%E8%B6%8A%E6%9D%A5%E8%B6%8A%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-text">17 | 函数式编程：一种越来越流行的编程范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">17.3 高阶函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E8%AF%B4%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">17.4 命令式编程和说明式编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-5-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-text">17.5 不可变性和并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-6-Y-%E7%BB%84%E5%90%88%E5%AD%90"><span class="toc-text">17.6 Y 组合子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">17.7 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%BA%94%E7%94%A8%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%92%8Ctuple%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E6%8A%80%E5%B7%A7"><span class="toc-text">18 | 应用可变模板和tuple的编译期技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">18.1 可变模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-2-%E8%BD%AC%E5%8F%91%E7%94%A8%E6%B3%95"><span class="toc-text">18.2 转发用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-%E9%80%92%E5%BD%92%E7%94%A8%E6%B3%95"><span class="toc-text">18.3 递归用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4-tuple"><span class="toc-text">18.4 tuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-5-%E6%95%B0%E5%80%BC%E9%A2%84%E7%AE%97"><span class="toc-text">18.5 数值预算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">18.6 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-thread%E5%92%8Cfuture%EF%BC%9A%E9%A2%86%E7%95%A5%E5%BC%82%E6%AD%A5%E4%B8%AD%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-text">19 | thread和future：领略异步中的未来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#19-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-text">19.1 为什么要使用并发编程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-2-%E5%9F%BA%E4%BA%8E-thread-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="toc-text">19.2 基于 thread 的多线程开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-3-mutex"><span class="toc-text">19.3 mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-4-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="toc-text">19.4 执行任务，返回数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-future"><span class="toc-text">19.5 future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-6-promise"><span class="toc-text">19.6 promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-7-packaged"><span class="toc-text">19.7 packaged</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">19.8 参考资料</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E4%B8%A8%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-text">03丨实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%B7%A5%E5%85%B7%E6%BC%AB%E8%B0%88%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E3%80%81%E6%8E%92%E9%94%99%E5%90%84%E6%98%BE%E8%BA%AB%E6%89%8B"><span class="toc-text">21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-1-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">21.1 编译器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-2-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-text">21.2 格式化工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-3-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7"><span class="toc-text">21.3 代码检查工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-%E6%8E%92%E9%94%99%E5%B7%A5%E5%85%B7"><span class="toc-text">21.4 排错工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-5-%E7%BD%91%E9%A1%B5%E5%B7%A5%E5%85%B7"><span class="toc-text">21.5 网页工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">21.6 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%98%E5%8C%96%E5%92%8C%E9%94%99%E8%AF%AF%EF%BC%9Aoptional%E3%80%81variant%E3%80%81expected-%E5%92%8CHerbception"><span class="toc-text">22 | 处理数据类型变化和错误：optional、variant、expected 和Herbception</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#22-1-optional"><span class="toc-text">22.1 optional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-2-variant"><span class="toc-text">22.2 variant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-3-expected"><span class="toc-text">22.3 expected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-4-Herbception"><span class="toc-text">22.4 Herbception</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E8%AE%AE%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">提议的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97%EF%BC%9A%E4%BB%8B%E7%BB%8D%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%92%8C%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E5%BA%93"><span class="toc-text">23 | 数字计算：介绍线性代数和数值计算库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#23-1-Armadillo"><span class="toc-text">23.1 Armadillo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-2-Boost-Multiprecision"><span class="toc-text">23.2 Boost.Multiprecision</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-3-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">23.3 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Boost%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9A%84%E2%80%9D%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E2%80%9D"><span class="toc-text">24 | Boost：你需要的”瑞士军刀”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#24-1-Boost-%E6%A6%82%E8%A7%88"><span class="toc-text">24.1 Boost 概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-2-Boost-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">24.2 Boost 的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-3-Boost-TypeIndex"><span class="toc-text">24.3 Boost.TypeIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-4-Boost-Core"><span class="toc-text">24.4 Boost.Core</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-5-Boost-Conversion"><span class="toc-text">24.5 Boost.Conversion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-6-Boost-ScopeExit"><span class="toc-text">24.6 Boost.ScopeExit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-6-Boost-Program-options"><span class="toc-text">24.6 Boost.Program_options</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-7-Boost-Hana"><span class="toc-text">24.7 Boost.Hana</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">24.8 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%B8%A4%E4%B8%AA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BA%93%EF%BC%9AC-%E9%87%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">25 | 两个单元测试库：C++里如何进行单元测试?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#25-1-Boost-Test"><span class="toc-text">25.1 Boost.Test</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-2-Catch2"><span class="toc-text">25.2 Catch2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-3-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">25.3 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-Easylogging-%E5%92%8Cspdlog%EF%BC%9A%E4%B8%A4%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E6%97%A5%E5%BF%97%E5%BA%93"><span class="toc-text">26 | Easylogging++和spdlog：两个好用的日志库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#26-1-Easylogging"><span class="toc-text">26.1 Easylogging++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-2-spdlog"><span class="toc-text">26.2 spdlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-3-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">26.3 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-C-REST-SDK%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3C-%E5%BC%80%E5%8F%91%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8"><span class="toc-text">27 | C++ REST SDK：使用现代C++开发网络应用</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/分布式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Kevinの分布式学习笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 Kevinの操作系统笔记 (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据结构/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>