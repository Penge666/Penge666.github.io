<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>libevent源码剖析 | Penge666</title><meta name="keywords" content="网络编程"><meta name="author" content="Penge666"><meta name="copyright" content="Penge666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="libevent源码剖析">
<meta property="og:type" content="article">
<meta property="og:title" content="libevent源码剖析">
<meta property="og:url" content="https://penge666.github.io/posts/32933883.html">
<meta property="og:site_name" content="Penge666">
<meta property="og:description" content="libevent源码剖析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://penge666.github.io/assets/photo1/default_cover_72.webp">
<meta property="article:published_time" content="2024-05-24T11:02:48.000Z">
<meta property="article:modified_time" content="2024-06-02T09:21:44.819Z">
<meta property="article:author" content="Penge666">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://penge666.github.io/assets/photo1/default_cover_72.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://penge666.github.io/posts/32933883"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'libevent源码剖析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-02 17:21:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Penge666" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/hhh.jpeg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Penge666</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">libevent源码剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-05-24T11:02:48.000Z" title="发表于 2024-05-24 19:02:48">2024-05-24</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-02T09:21:44.819Z" title="更新于 2024-06-02 17:21:44">2024-06-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">1.6w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="libevent源码剖析"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一-序幕">一 序幕</h2>
<h3 id="1-前言">1 前言</h3>
<p>libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分享心得；二则对libevent代码和设计思想做系统的、更深层次的分析，写出来，也可供后来者参考。</p>
<blockquote>
<p>libevent是用c语言编写的（MS大牛们都偏爱c语言哪），而且几乎是无处不函数指针，学习其源代码也需要相当的c语言基础。</p>
</blockquote>
<h3 id="2-libevent简介">2 libevent简介</h3>
<p>上来当然要先夸奖啦，libevent 有几个显著的亮点：<br>
1）事件驱动（event-driven），高性能;<br>
2）轻量级，专注于网络，不如ACE那么臃肿庞大；<br>
3）源代码相当精炼、易读；<br>
4）跨平台，支持Windows、Linux、*BSD和Mac Os；<br>
5）支持多种I/O多路复用技术， epoll、poll、dev/poll、select和kqueue等；<br>
6）支持I/O，定时器和信号等事件；<br>
7）注册事件优先级；</p>
<p>libevent已经被广泛的应用，作为底层的网络库；比如memcached、Vomit、Nylon、Netchat等等。<br>
libevent当前的最新稳定版是1.4.13；这也是本文参照的版本。</p>
<h3 id="3-学习的好处">3 学习的好处</h3>
<p>学习libevent有助于提升程序设计功力，除了网络程序设计方面外，libevent的代码里有很多有用的设计技巧和基础数据结构，比如信息隐藏、函数指针、c语言的多态支持、链表和堆等等，都有助于提升自身的程序功力。</p>
<p>程序设计不止要了解框架，很多细节之处恰恰也是事关整个系统成败的关键。只对libevent本身的框架大概了解，那或许仅仅是一知半解，不深入代码分析，就难以了解其设计的精巧之处，也就难以为自己所用。</p>
<p>事实上libevent本身就是一个典型的Reactor模型，理解Reactor模式是理解libevent的基石；因此下一节将介绍典型的事件驱动设计模式—Reactor模式。</p>
<p>参考资料：<br>
libevent: <a target="_blank" rel="noopener" href="http://monkey.org/~provos/libevent/">http://monkey.org/~provos/libevent/</a></p>
<h2 id="二-reactor模式">二 reactor模式</h2>
<p>前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，并列出libevent中的几个重要组件和Reactor的对应关系，在后面的章节中可能还会提到本节介绍的基本概念。</p>
<h3 id="1-reactor的事件处理机制">1 reactor的事件处理机制</h3>
<p>首先来回想一下普通函数调用的机制：程序调用某函数?函数执行，程序等待?函数将结果和控制权返回给程序?程序继续处理。</p>
<p>reactor释义“反应堆”，是一种事件驱动机制。和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到reactor上，如果相应的时间发生，reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。使用libevent也是想libevent框架注册相应的事件和回调函数；当这些时间发声时，libevent会调用这些回调函数处理相应的事件（I/O读写、定时和信号）。用“<strong>好莱坞原则</strong>”来形容reactor再合适不过了：<strong>不要打电话给我们，我们会打电话通知你。</strong></p>
<p>举个例子：你去应聘某xx公司，面试结束后。“普通函数调用机制”公司HR比较懒，不会记你的联系方式，那怎么办呢，你只能面试完后自己打电话去问结果；有没有被录取啊，还是被据了；</p>
<p>“reactor”公司HR就记下了你的联系方式，结果出来后会主动打电话通知你：有没有被录取啊，还是被据了；你不用自己打电话去问结果，事实上也不能，你没有HR的留联系方式。</p>
<h3 id="2-reactor模式的优点">2 reactor模式的优点</h3>
<p>reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：<br>
1）响应快，不必为单个同步时间所阻塞，虽然reactor本身依然是同步的；<br>
2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；<br>
3）可扩展性，可以方便的通过增加reactor实例个数来充分利用CPU资源；<br>
4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>
<h3 id="3-reactor模式框架">3 reactor模式框架</h3>
<p>使用reactor模型，必备的几个组件：事件源、reactor框架、多路复用机制和事件处理程序，先来看看reactor模型的整体框架，接下来再对每个组件做逐一说明。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172134310.png" alt="image-20240602172134310"></p>
<p>1）事件源<br>
Linux上是文件描述符，Windows上就是Socket或者Handle了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I/O事件。</p>
<p>2）event demultiplexer——事件多路分发机制<br>
由操作系统提供的I/O多路复用机制，比如select和epoll。程序首先将其关心的句柄（事件源）及其事件注册到event demultiplexer上；<br>
当有事件到达时，event demultiplexer会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”；程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。对应到libevent中，依然是select、poll、epoll等，但是libevent使用结构体eventop进行了封装，以统一的接口来支持这些I/O多路复用机制，达到了对外隐藏底层系统机制的目的。</p>
<p>3）reactor——反应器<br>
reactor，是事件管理的接口，内部使用event demultiplexer注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到libevent中，就是event_base结构体。一个典型的Reactor声明方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reactor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">register_handler</span><span class="params">(Event_Handler *pHandler, <span class="type">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove_handler</span><span class="params">(Event_Handler *pHandler, <span class="type">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_events</span><span class="params">(timeval *ptv)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反应器的理解：</p>
<p>这段代码是描述了一个典型的Reactor（反应器）设计模式在事件驱动编程中的应用。</p>
<p>Reactor设计模式是一种事件处理模式，用于处理服务请求，这些服务请求被发送至一个或多个服务处理程序。</p>
<p>在这个类中：</p>
<ul>
<li><code>register_handler</code>方法用于注册事件处理程序，当某个事件发生时，将调用该事件处理程序。</li>
<li><code>remove_handler</code>方法用于移除事件处理程序，不再对该事件进行处理。</li>
<li><code>handle_events</code>方法是事件循环，用于处理所有已经就绪的事件。</li>
</ul>
<p>通俗易懂的说，Reactor就像是一个电话交换员或者邮局。当有电话打入或者邮件发送到邮局时，交换员或者邮局就会根据电话或者邮件的目的地，将它们转发给对应的接收者。在这个过程中，电话交换员或者邮局就扮演了Reactor的角色，电话或者邮件就是事件，接收者就是事件处理程序。当电话打入或者邮件到达时（事件发生），交换员或者邮局就会调用对应的接收者（事件处理程序）来处理电话或者邮件（处理事件）。</p>
<p>4）Event Handler——事件处理程序<br>
事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。对应到libevent中，就是event结构体。</p>
<p>下面是两种典型的Event Handler类声明方式，二者互有优缺点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Event_Handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_read</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_write</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_timeout</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_close</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HANDLE <span class="title">get_handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event_Handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// events maybe read/write/timeout/close .etc</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_events</span><span class="params">(<span class="type">int</span> events)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HANDLE <span class="title">get_handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-reactor事件处理流程">4 reactor事件处理流程</h3>
<p>前面说过reactor将事件流“逆置”了，那么使用reactor模式后，事件控制流是什么样子呢？<br>
可以参见下面的序列图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172127005.png" alt="image-20240602172127005"></p>
<h3 id="5-小结">5 小结</h3>
<p>上面讲到了reactor的基本概念、框架和处理流程，对reactor有个基本清晰的了解后，再来对比看libevent就会更容易理解了，接下来就正式进入到libevent的代码世界了，加油！</p>
<p>参考资料：<br>
Pattern-Oriented Software Architecture, Patterns for Concurrent and Networked Objects, Volume 2</p>
<h2 id="三-libevent基本使用场景和事件流程">三 libevent基本使用场景和事件流程</h2>
<h3 id="1-前言-2">1 前言</h3>
<p>学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不错的方法，至少从个人的经验上讲，用此方法分析libevent是比较有效的。</p>
<h3 id="2-基本应用场景">2 基本应用场景</h3>
<p>基本应用场景也是使用libevnet的基本流程，下面来考虑一个最简单的场景，使用livevent设置定时器，应用程序只需要执行下面几个简单的步骤即可。</p>
<p>1）首先初始化libevent库，并保存返回的指针<br>
<code>struct event_base * base = event_init();</code>实际上这一步相当于初始化一个reactor实例；在初始化libevent后，就可以注册事件了。</p>
<p>2）初始化事件event，设置回调函数和关注的事件<br>
<code>evtimer_set(&amp;ev, timer_cb, NULL);</code>事实上这等价于调用<code>event_set(&amp;ev, -1, 0, timer_cb, NULL);</code><br>
event_set的函数原型是：<br>
<code>void event_set(struct event *ev, int fd, short event, void (*cb)(int, short, void *), void *arg)</code><br>
ev：执行要初始化的event对象；<br>
fd：该event绑定的“句柄”，对于信号事件，它就是关注的信号；<br>
event：在该fd上关注的事件类型，它可以是EV_READ, EV_WRITE, EV_SIGNAL；<br>
cb：这是一个函数指针，当fd上的事件event发生时，调用该函数执行处理，它有三个参数，调用时由event_base负责传入，按顺序，实际上就是event_set时的fd, event和arg；<br>
arg：传递给cb函数指针的参数；<br>
由于定时事件不需要fd，并且定时事件是根据添加时（event_add）的超时值设定的，因此这里event也不需要设置。这一步相当于初始化一个event handler，在libevent中事件类型保存在event结构体中。<br>
注意：libevent并不会管理event事件集合，这需要应用程序自行管理；</p>
<p>3）设置event从属的event_base<br>
<code>event_base_set(base, &amp;ev);</code><br>
这一步相当于指明event要注册到哪个event_base实例上；</p>
<p>4）是正式的添加事件的时候了<br>
<code>event_add(&amp;ev, timeout);</code><br>
基本信息都已设置完成，只要简单的调用event_add()函数即可完成，其中timeout是定时值；<br>
这一步相当于调用Reactor::register_handler()函数注册事件。</p>
<p>5）程序进入无限循环，等待就绪事件并执行事件处理<br>
<code>event_base_dispatch(base);</code></p>
<h3 id="3-实例代码">3 实例代码</h3>
<p>上面例子的程序代码如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> ev;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span> *argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timer wakeup/n&quot;</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv); <span class="comment">// reschedule timer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">event_init</span>();</span><br><span class="line">    tv.tv_sec = <span class="number">10</span>; <span class="comment">// 10s period</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">evtimer_set</span>(&amp;ev, time_cb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv);</span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-事件处理流程">4 事件处理流程</h3>
<p>当应用程序向libevent注册一个事件后，libevent内部是怎么样进行处理的呢？下面的图就给出了这一基本流程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602172116761.png" alt="image-20240602172116761"></p>
<p>1）首先应用程序准备并初始化event，设置好事件类型和回调函数；这对应于前面第步骤2和3；<br>
2）向libevent添加该事件event。对于定时事件，libevent使用一个小根堆管理，key为超时时间；对于Signal和I/O事件，libevent将其放入到等待链表（wait list）中，这是一个双向链表结构；<br>
3）程序调用event_base_dispatch()系列函数进入无限循环，等待事件，以select()函数为例；每次循环前libevent会检查定时事件的最小超时时间tv，根据tv设置select()的最大等待时间，以便于后面及时处理超时事件；当select()返回后，首先检查超时事件，然后检查I/O事件；libevent将所有的就绪事件，放入到激活链表中；然后对激活链表中的事件，调用事件的回调函数执行事件处理；、</p>
<p><strong>解释1</strong>：每次循环前libevent会检查定时事件的最小超时时间tv，根据tv设置select()的最大等待时间，以便于后面及时处理超时事件。</p>
<p>【重点】举个例子，假设我们有一个定时事件，10秒后触发。我们调用event_base_dispatch开始事件循环，然后libevent检查定时事件的最小超时时间，发现是10秒后。于是，libevent调用select函数，设置最大等待时间为10秒。10秒后，即使没有I/O事件发生，select函数也会返回，然后libevent就知道这个定时事件已经就绪，就会调用相应的回调函数处理这个定时事件。</p>
<h3 id="5-小结-2">5 小结</h3>
<p>本节介绍了libevent的简单实用场景，并介绍了libevent的事件处理流程，读者应该对libevent有了基本的印象，下面将会详细介绍libevent的事件管理框架（reactor模式中的reactor框架），在此之前会对源代码文件做简单的分类。</p>
<h2 id="四-libevent源代码文件组织">四 libevent源代码文件组织</h2>
<h3 id="1-前言-3">1 前言</h3>
<p>详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，但并不是说它不重要！</p>
<h3 id="2-源代码组织结构">2 源代码组织结构</h3>
<p>libevent的源代码虽然都在一层文件夹下面，但是其代码分类还是相当清晰的，主要可分为头文件、内部使用的头文件、辅助功能函数、日志、libevent框架、对系统I/O多路复用机制的封装、信号管理、定时事件管理、缓冲区管理、基本数据结构和基于libevent的两个实用库等几个部分，有些部分可能就是一个源文件。</p>
<p>源代码中的test部分就不在我们关注的范畴了。<br>
1）头文件<br>
主要就是<strong>event.h</strong>：事件宏定义、接口函数声明，主要结构体event的声明；</p>
<p>2）内部头文件<br>
<strong>xxx-internal.h</strong>：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；</p>
<p>3）libevent框架<br>
<strong>event.c</strong>：event整体框架的代码实现；</p>
<p>4）对系统I/O多路复用机制的封装<br>
<strong>epoll.c</strong>：对epoll的封装；<br>
<strong>select.c</strong>：对select的封装；<br>
<strong>devpoll.c</strong>：对dev/poll的封装;<br>
<strong>kqueue.c</strong>：对kqueue的封装；</p>
<p>5）定时事件管理<br>
<strong>min-heap.h</strong>：其实就是一个以时间作为key的小根堆结构；</p>
<p>6）信号管理<br>
<strong>signal.c</strong>：对信号事件的处理；</p>
<p>7）辅助功能函数<br>
<strong>evutil.h 和evutil.c</strong>：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。</p>
<p>8）日志<br>
log.h和log.c：log日志函数</p>
<p>9）缓冲区管理<br>
<strong>evbuffer.c</strong>和<strong>buffer.c</strong>：libevent对缓冲区的封装；</p>
<p>10）基本数据结构<br>
compat/sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；</p>
<p>11）实用网络库<br>
http和evdns：是基于libevent实现的http服务器和异步dns查询库；</p>
<h3 id="3-小结">3 小结</h3>
<p>本节介绍了libevent的组织和分类，下面将会详细介绍libevent的核心部分event结构。</p>
<h2 id="五-libevent的核心：事件event">五 libevent的核心：事件event</h2>
<p>对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理。</p>
<h3 id="1-libevent的核心-event">1 libevent的核心-event</h3>
<p>libevent是基于事件驱动（event-driven）的，从名字也可以看到event是整个库的核心。event就是reactor框架中的事件处理程序组件；它提供了函数接口，供reactor在事件发生时调用，以执行相应的事件处理，通常它会绑定一个有效的句柄。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">TAILQ_ENTRY</span> (event) ev_next;</span><br><span class="line">	<span class="built_in">TAILQ_ENTRY</span> (event) ev_active_next;</span><br><span class="line">	<span class="built_in">TAILQ_ENTRY</span> (event) ev_signal_next;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_heap_idx; <span class="comment">/* for managing timeouts */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event_base</span> *ev_base;</span><br><span class="line">	<span class="type">int</span> ev_fd;</span><br><span class="line">	<span class="type">short</span> ev_events;</span><br><span class="line">	<span class="type">short</span> ev_ncalls;</span><br><span class="line">	<span class="type">short</span> *ev_pncalls; <span class="comment">/* Allows deletes in callback */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> ev_timeout;</span><br><span class="line">	<span class="type">int</span> ev_pri;  <span class="comment">/* smaller numbers are higher priority */</span></span><br><span class="line">	<span class="built_in">void</span> (*ev_callback)(<span class="type">int</span>, <span class="type">short</span>, <span class="type">void</span> *arg);</span><br><span class="line">	<span class="type">void</span> *ev_arg;</span><br><span class="line">	<span class="type">int</span> ev_res;  <span class="comment">/* result passed to event callback */</span></span><br><span class="line">	<span class="type">int</span> ev_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先给出event结构体的声明，它位于event.h文件中：</p>
<p>下面简单解释一下结构体中各字段的含义。</p>
<p>1）<strong>ev_events</strong>：event关注的事件类型，它可以是以下3种类型：<br>
I/O事件： EV_WRITE和EV_READ<br>
定时事件：EV_TIMEOUT<br>
信号： EV_SIGNAL<br>
辅助选项：EV_PERSIST，表明是一个永久事件</p>
<p>libevent中的定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_TIMEOUT 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_READ    0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_WRITE   0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SIGNAL  0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PERSIST 0x10 <span class="comment">/* Persistant event */</span></span></span><br></pre></td></tr></table></figure>
<p>可以看出事件类型可以使用“|”运算符进行组合，需要说明的是，信号和I/O事件不能同时设置；还可以看出libevent使用event结构体将这3种事件的处理统一起来；</p>
<p>2）<strong>ev_next</strong>，<strong>ev_active_nex</strong>t和<strong>ev_signal_next</strong>都是双向链表节点指针；它们是libevent对不同事件类型和在不同的时期，对事件的管理时使用到的字段。libevent使用双向链表保存所有注册的I/O和Signal事件，ev_next就是该I/O事件在链表中的位置；称此链表为“已注册事件链表”；同样ev_signal_next就是signal事件在signal事件链表中的位置；ev_active_next：libevent将所有的激活事件放入到链表active list中，然后遍历active list执行调度，ev_active_next就指明了event在active list中的位置；</p>
<p>2）<strong>min_heap_idx</strong>和<strong>ev_timeout</strong>，如果是timeout事件，它们是event在小根堆中的索引和超时值，libevent使用小根堆来管理定时事件，这将在后面定时事件处理时专门讲解。</p>
<p>3）<strong>ev_base</strong>该事件所属的反应堆实例，这是一个event_base结构体，下一节将会详细讲解；</p>
<p>4）<strong>ev_fd</strong>，对于I/O事件，是绑定的文件描述符；对于signal事件，是绑定的信号；</p>
<p>5）<strong>ev_callback</strong>，event的回调函数，被ev_base调用，执行事件处理程序，这是一个函数指针，原型为：<br>
<code>void (*ev_callback)(int fd, short events, void *arg);</code>其中参数fd对应于ev_fd；events对应于ev_events；arg对应于ev_arg；</p>
<p>6）<strong>ev_arg</strong>：void*，表明可以是任意类型的数据，在设置event时指定；</p>
<p>7）<strong>eb_flags</strong>：libevent用于标记event信息的字段，表明其当前的状态，可能的值有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_TIMEOUT  0x01 <span class="comment">// event在time堆中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_INSERTED 0x02 <span class="comment">// event在已注册事件链表中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_SIGNAL   0x04 <span class="comment">// 未见使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_ACTIVE   0x08 <span class="comment">// event在激活链表中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_INTERNAL 0x10 <span class="comment">// 内部使用标记</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_INIT     0x80 <span class="comment">// event已被初始化</span></span></span><br></pre></td></tr></table></figure>
<p>8）<strong>ev_ncalls</strong>：事件就绪执行时，调用ev_callback的次数，通常为1；</p>
<p>9）<strong>ev_pncalls</strong>：指针，通常指向ev_ncalls或者为NULL；</p>
<p>10）<strong>ev_res</strong>：记录了当前激活事件的类型；</p>
<h3 id="2-libevent对event的管理">2 libevent对event的管理</h3>
<p>从event结构体中的3个链表节点指针和一个堆索引出发，大体上也能窥出libevent对event的管理方法了，可以参见下面的示意图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240526115502487.png" alt="image-20240526115502487"></p>
<p>每次当有事件event转变为就绪状态时，libevent就会把它移入到active event list[priority]中，其中priority是event的优先级；接着libevent会根据自己的调度策略选择就绪事件，调用其cb_callback()函数执行事件处理；并根据就绪的句柄和事件类型填充cb_callback函数的参数。</p>
<h3 id="3-事件设置的接口函数">3 事件设置的接口函数</h3>
<p>要向libevent添加一个事件，需要首先设置event对象，这通过调用libevent提供的函数有：event_set(), event_base_set(), event_priority_set()来完成；下面分别进行讲解。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set</span>(<span class="params"><span class="keyword">struct</span> <span class="keyword">event</span> *ev, <span class="built_in">int</span> fd, <span class="built_in">short</span> events, <span class="keyword">void</span> (*callback</span>)(<span class="params"><span class="built_in">int</span>, <span class="built_in">short</span>, <span class="keyword">void</span> *</span>), <span class="keyword">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<p>1）设置事件ev绑定的文件描述符或者信号，对于定时事件，设为-1即可；<br>
2）设置事件类型，比如EV_READ|EV_PERSIST, EV_WRITE, EV_SIGNAL等；<br>
3）设置事件的回调函数以及参数arg；<br>
4）初始化其它字段，比如缺省的event_base和优先级；</p>
<p><code>int event_base_set(struct event_base *base, struct event *ev)</code><br>
设置event ev将要注册到的event_base；libevent有一个全局event_base指针current_base，默认情况下事件ev将被注册到current_base上，使用该函数可以指定不同的event_base；如果一个进程中存在多个libevent实例，则必须要调用该函数为event设置不同的event_base；</p>
<p><code>int event_priority_set(struct event *ev, int pri);</code><br>
设置event ev的优先级，没什么可说的，注意的一点就是：当ev正处于就绪状态时，不能设置，返回-1。</p>
<h3 id="4-小结">4 小结</h3>
<p>本节讲述了libevent的核心event结构，以及libevent支持的事件类型和libevent对event的管理模型；接下来将会描述libevent的事件处理框架，以及其中使用的重要的结构体event_base；</p>
<h2 id="六-初见事件处理框架">六 初见事件处理框架</h2>
<p>前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细处理流程了，本节将分析libevent的事件处理框架event_base和libevent注册、删除事件的具体流程，可结合前一节libevent对event的管理。</p>
<h3 id="1-事件处理框架-event-base">1 事件处理框架-event_base</h3>
<p>回想Reactor模式的几个基本组件，本节讲解的部分对应于reactor框架组件。在libevent中，这就表现为event_base结构体，结构体声明如下，它位于event-internal.h文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span></span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *evsel;</span><br><span class="line">	 <span class="type">void</span> *evbase;　</span><br><span class="line">	 <span class="type">int</span> event_count;  <span class="comment">/* counts number of total events */</span></span><br><span class="line">	 <span class="type">int</span> event_count_active; <span class="comment">/* counts number of active events */</span></span><br><span class="line">	 <span class="type">int</span> event_gotterm;  <span class="comment">/* Set to terminate loop */</span></span><br><span class="line">	 <span class="type">int</span> event_break;  <span class="comment">/* Set to terminate loop immediately */</span></span><br><span class="line">	 <span class="comment">/* active event management */</span></span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">event_list</span> **activequeues;</span><br><span class="line">	 <span class="type">int</span> nactivequeues;</span><br><span class="line">	 <span class="comment">/* signal handling info */</span></span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">evsignal_info</span> sig;</span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">event_list</span> eventqueue;</span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">timeval</span> event_tv;</span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">min_heap</span> timeheap;</span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">timeval</span> tv_cache;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面详细解释一下结构体中各字段的含义。</p>
<p>1）<strong>evsel</strong>和<strong>evbase</strong>这两个字段的设置可能会让人有些迷惑，这里你可以把evsel和evbase看作是类和静态函数的关系，比如添加事件时的调用行为：evsel-&gt;add(evbase, ev)，实际执行操作的是evbase；这相当于class::add(instance, ev)，instance就是class的一个对象实例。<br>
evsel指向了全局变量static const struct eventop *eventops[]中的一个；</p>
<p>前面也说过，libevent将系统提供的I/O demultiplex机制统一封装成了eventop结构；因此eventops[]包含了select、poll、kequeue和epoll等等其中的若干个全局实例对象。evbase实际上是一个eventop实例对象；先来看看eventop结构体，它的成员是一系列的函数指针, 在event-internal.h文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventop</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">void</span> *(*init)(<span class="keyword">struct</span> event_base *); <span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">int</span> (*add)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 注册事件</span></span><br><span class="line">	<span class="built_in">int</span> (*del)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 删除事件</span></span><br><span class="line">	<span class="built_in">int</span> (*dispatch)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *, <span class="keyword">struct</span> timeval *); <span class="comment">// 事件分发</span></span><br><span class="line">	<span class="built_in">void</span> (*dealloc)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *); <span class="comment">// 注销，释放资源</span></span><br><span class="line">	<span class="comment">/* set if we need to reinitialize the event base */</span></span><br><span class="line">	<span class="type">int</span> need_reinit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也就是说，在libevent中，每种I/O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I/O demultiplex机制了，这个在后面会再次提到。</p>
<p>2）<strong>activequeues</strong>是一个二级指针，前面讲过libevent支持事件优先级，因此你可以把它看作是数组，其中的元素activequeues[priority]是一个链表，链表的每个节点指向一个优先级为priority的就绪事件event。</p>
<p>3）<strong>eventqueue</strong>，链表，保存了所有的注册事件event的指针。</p>
<p>4）<strong>sig</strong>是由来管理信号的结构体，将在后面信号处理时专门讲解；</p>
<p>5）<strong>timeheap</strong>是管理定时事件的小根堆，将在后面定时事件处理时专门讲解；</p>
<p>6）<strong>event_tv</strong>和<strong>tv_cache</strong>是libevent用于时间管理的变量，将在后面讲到；</p>
<p>其它各个变量都能因名知意，就不再啰嗦了。</p>
<h3 id="2-创建和初始化event-base">2 创建和初始化event_base</h3>
<p>创建一个event_base对象也既是创建了一个新的libevent实例，程序需要通过调用<code>event_init()</code>（内部调用event_base_new函数执行具体操作）函数来创建，该函数同时还对新生成的libevent实例进行了初始化。该函数首先为event_base实例申请空间，然后初始化timer mini-heap，选择并初始化合适的系统I/O 的demultiplexer机制，初始化各事件链表；函数还检测了系统的时间设置，为后面的时间管理打下基础。</p>
<h3 id="3-接口函数">3 接口函数</h3>
<p>前面提到reactor框架的作用就是提供事件的注册、注销接口；根据系统提供的事件多路分发机制执行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数来处理事件。libevent中对应的接口函数主要就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">event_add</span><span class="params">(<span class="keyword">struct</span> event *ev, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">event_del</span><span class="params">(<span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> loops)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_active</span><span class="params">(<span class="keyword">struct</span> event *event, <span class="type">int</span> res, <span class="type">short</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_process_active</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span></span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>本节将按介绍事件注册和删除的代码流程，libevent的事件循环框架将在下一节再具体描述。<br>
对于定时事件，这些函数将调用timer heap管理接口执行插入和删除操作；对于I/O和Signal事件将调用eventopadd和delete接口函数执行插入和删除操作（eventop会对Signal事件调用Signal处理接口执行操作）；这些组件将在后面的内容描述。</p>
<p>1）注册事件<br>
函数原型：<code>int event_add(struct event *ev, const struct timeval *tv);</code><br>
参数：<br>
ev：指向要注册的事件；<br>
tv：超时时间；<br>
函数将ev注册到ev-&gt;ev_base上，事件类型由ev-&gt;ev_events指明，如果注册成功，ev将被插入到已注册链表中；如果tv不是NULL，则会同时注册定时事件，将ev添加到timer堆上；<br>
如果其中有一步操作失败，那么函数保证没有事件会被注册，可以讲这相当于一个原子操作。这个函数也体现了libevent细节之处的巧妙设计，且仔细看程序代码，部分有省略，注释直接附在代码中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_add</span><span class="params">(<span class="keyword">struct</span> event *ev, <span class="type">const</span> <span class="keyword">struct</span> timeval *tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event_base</span> *base = ev-&gt;ev_base; <span class="comment">// 要注册到的event_base</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *evsel = base-&gt;evsel;</span><br><span class="line">	<span class="type">void</span> *evbase = base-&gt;evbase; <span class="comment">// base使用的系统I/O策略</span></span><br><span class="line">								 <span class="comment">// 新的timer事件，调用timer heap接口在堆上预留一个位置</span></span><br><span class="line">								 <span class="comment">// 注：这样能保证该操作的原子性：</span></span><br><span class="line">								 <span class="comment">// 向系统I/O机制注册可能会失败，而当在堆上预留成功后，</span></span><br><span class="line">								 <span class="comment">// 定时事件的添加将肯定不会失败；</span></span><br><span class="line">								 <span class="comment">// 而预留位置的可能结果是堆扩充，但是内部元素并不会改变</span></span><br><span class="line">	<span class="keyword">if</span> (tv != <span class="literal">NULL</span> &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min_heap_reserve</span>(&amp;base-&gt;timeheap,</span><br><span class="line">			<span class="number">1</span> + <span class="built_in">min_heap_size</span>(&amp;base-&gt;timeheap)) == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> (<span class="number">-1</span>);  <span class="comment">/* ENOMEM == errno */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果事件ev不在已注册或者激活链表中，则调用evbase注册事件</span></span><br><span class="line">	<span class="keyword">if</span> ((ev-&gt;ev_events &amp; (EV_READ | EV_WRITE | EV_SIGNAL)) &amp;&amp;</span><br><span class="line">		!(ev-&gt;ev_flags &amp; (EVLIST_INSERTED | EVLIST_ACTIVE))) &#123;</span><br><span class="line">		res = evsel-&gt;<span class="built_in">add</span>(evbase, ev);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="comment">// 注册成功，插入event到已注册链表中</span></span><br><span class="line">			<span class="built_in">event_queue_insert</span>(base, ev, EVLIST_INSERTED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 准备添加定时事件</span></span><br><span class="line">	<span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; tv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">timeval</span> now;</span><br><span class="line">		<span class="comment">// EVLIST_TIMEOUT表明event已经在定时器堆中了，删除旧的</span></span><br><span class="line">		<span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)</span><br><span class="line">			<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">		<span class="comment">// 如果事件已经是就绪状态则从激活链表中删除</span></span><br><span class="line">		<span class="keyword">if</span> ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;</span><br><span class="line">			(ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123;</span><br><span class="line">			<span class="comment">// 将ev_callback调用次数设置为0</span></span><br><span class="line">			<span class="keyword">if</span> (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;</span><br><span class="line">				*ev-&gt;ev_pncalls = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_ACTIVE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算时间，并插入到timer小根堆中</span></span><br><span class="line">		<span class="built_in">gettime</span>(base, &amp;now);</span><br><span class="line">		<span class="built_in">evutil_timeradd</span>(&amp;now, tv, &amp;ev-&gt;ev_timeout);</span><br><span class="line">		<span class="built_in">event_queue_insert</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">event_queue_insert</span>()负责将事件插入到对应的链表中，下面是程序代码；</span><br><span class="line"><span class="built_in">event_queue_remove</span>()负责将事件从对应的链表中删除，这里就不再重复贴代码了；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_queue_insert</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> event *ev, <span class="type">int</span> queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ev可能已经在激活列表中了，避免重复插入</span></span><br><span class="line">	<span class="keyword">if</span> (ev-&gt;ev_flags &amp; queue) &#123;</span><br><span class="line">		<span class="keyword">if</span> (queue &amp; EVLIST_ACTIVE)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	ev-&gt;ev_flags |= queue; <span class="comment">// 记录queue标记</span></span><br><span class="line">	<span class="keyword">switch</span> (queue) &#123;</span><br><span class="line">	<span class="keyword">case</span> EVLIST_INSERTED: <span class="comment">// I/O或Signal事件，加入已注册事件链表</span></span><br><span class="line">		<span class="built_in">TAILQ_INSERT_TAIL</span>(&amp;base-&gt;eventqueue, ev, ev_next);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EVLIST_ACTIVE: <span class="comment">// 就绪事件，加入激活链表</span></span><br><span class="line">		base-&gt;event_count_active++;</span><br><span class="line">		<span class="built_in">TAILQ_INSERT_TAIL</span>(base-&gt;activequeues[ev-&gt;ev_pri], ev, ev_active_next);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EVLIST_TIMEOUT: <span class="comment">// 定时事件，加入堆</span></span><br><span class="line">		<span class="built_in">min_heap_push</span>(&amp;base-&gt;timeheap, ev);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）删除事件：<br>
函数原型为：int event_del(struct event *ev);<br>
该函数将删除事件ev，对于I/O事件，从I/O 的demultiplexer上将事件注销；对于Signal事件，将从Signal事件链表中删除；对于定时事件，将从堆上删除；<br>
同样删除事件的操作则不一定是原子的，比如删除时间事件之后，有可能从系统I/O机制中注销会失败。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_del</span><span class="params">(<span class="keyword">struct</span> event *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event_base</span> *base;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *evsel;</span><br><span class="line">	<span class="type">void</span> *evbase;</span><br><span class="line">	<span class="comment">// ev_base为NULL，表明ev没有被注册</span></span><br><span class="line">	<span class="keyword">if</span> (ev-&gt;ev_base == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 取得ev注册的event_base和eventop指针</span></span><br><span class="line">	base = ev-&gt;ev_base;</span><br><span class="line">	evsel = base-&gt;evsel;</span><br><span class="line">	evbase = base-&gt;evbase;</span><br><span class="line">	<span class="comment">// 将ev_callback调用次数设置为</span></span><br><span class="line">	<span class="keyword">if</span> (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;</span><br><span class="line">		*ev-&gt;ev_pncalls = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从对应的链表中删除</span></span><br><span class="line">	<span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)</span><br><span class="line">		<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">	<span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE)</span><br><span class="line">		<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_ACTIVE);</span><br><span class="line">	<span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_INSERTED) &#123;</span><br><span class="line">		<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_INSERTED);</span><br><span class="line">		<span class="comment">// EVLIST_INSERTED表明是I/O或者Signal事件，</span></span><br><span class="line">		<span class="comment">// 需要调用I/O demultiplexer注销事件</span></span><br><span class="line">		<span class="keyword">return</span> (evsel-&gt;<span class="built_in">del</span>(evbase, ev));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-小节">4 小节</h3>
<p>分析了event_base这一重要结构体，初步看到了libevent对系统的I/O demultiplex机制的封装event_op结构，并结合源代码分析了事件的注册和删除处理，下面将会接着分析事件管理框架中的主事件循环部分。</p>
<h2 id="七-事件主循环">七 事件主循环</h2>
<p><strong>事件主循环</strong></p>
<p>现在我们已经初步了解了libevent的Reactor组件——<strong>event_base</strong>和<strong>事件管理框架</strong>，接下来就是libevent事件处理的中心部分——<strong>事件主循环</strong>，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。</p>
<h3 id="1-阶段性的胜利">1. 阶段性的胜利</h3>
<p>libevent将I/O事件、定时器和信号事件处理很好的结合到了一起，本节也会介绍libevent是如何做到这一点的。<br>
在看完本节的内容后，读者应该会对Libevent的基本框架：事件管理和主循环有比较清晰的认识了，并能够把libevent的事件控制流程清晰的串通起来，剩下的就是一些细节的内容了。</p>
<h3 id="2-事件处理主循环">2. 事件处理主循环</h3>
<p>libevent的事件主循环主要是通过**event_base_loop ()**函数完成的，其主要操作如下面的流程图所示，<strong>event_base_loop</strong>所作的就是持续执行下面的循环。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240526121015838.png" alt="image-20240526121015838"></p>
<p>清楚了event_base_loop所作的主要操作，就可以对比源代码看个究竟了，代码结构还是相当清晰的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> =</span> base-&gt;evsel;</span><br><span class="line">    <span class="type">void</span> *evbase = base-&gt;evbase;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="type">int</span> res, done;</span><br><span class="line">    <span class="comment">// 清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;sig.ev_signal_added)</span><br><span class="line">        evsignal_base = base;</span><br><span class="line">    done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123; <span class="comment">// 事件主循环</span></span><br><span class="line">        <span class="comment">// 查看是否需要跳出循环，程序可以调用event_loopexit_cb()设置event_gotterm标记</span></span><br><span class="line">        <span class="comment">// 调用event_base_loopbreak()设置event_break标记</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_gotterm) &#123;</span><br><span class="line">            base-&gt;event_gotterm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_break) &#123;</span><br><span class="line">            base-&gt;event_break = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校正系统时间，如果系统使用的是非MONOTONIC时间，用户可能会向后调整了系统时间</span></span><br><span class="line">        <span class="comment">// 在timeout_correct函数里，比较last wait time和当前时间，如果当前时间&lt; last wait time</span></span><br><span class="line">        <span class="comment">// 表明时间有问题，这是需要更新timer_heap中所有定时事件的超时时间。</span></span><br><span class="line">        timeout_correct(base, &amp;tv);</span><br><span class="line">        <span class="comment">// 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间</span></span><br><span class="line">        tv_p = &amp;tv;</span><br><span class="line">        <span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class="line">            timeout_next(base, &amp;tv_p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 依然有未处理的就绪时间，就让I/O demultiplexer立即返回，不必等待</span></span><br><span class="line">            <span class="comment">// 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理</span></span><br><span class="line">            evutil_timerclear(&amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前没有注册事件，就退出</span></span><br><span class="line">        <span class="keyword">if</span> (!event_haveevents(base)) &#123;</span><br><span class="line">            event_debug((<span class="string">&quot;%s: no events registered.&quot;</span>, __func__));</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新last wait time，并清空time cache</span></span><br><span class="line">        gettime(base, &amp;base-&gt;event_tv);</span><br><span class="line">        base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；</span></span><br><span class="line">        <span class="comment">// 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中</span></span><br><span class="line">        res = evsel-&gt;dispatch(base, evbase, tv_p);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 将time cache赋值为当前系统时间</span></span><br><span class="line">        gettime(base, &amp;base-&gt;tv_cache);</span><br><span class="line">        <span class="comment">// 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中</span></span><br><span class="line">        timeout_process(base);</span><br><span class="line">        <span class="comment">// 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理</span></span><br><span class="line">        <span class="comment">// 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，</span></span><br><span class="line">        <span class="comment">// 然后处理链表中的所有就绪事件；</span></span><br><span class="line">        <span class="comment">// 因此低优先级的就绪事件可能得不到及时处理；</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_count_active) &#123;</span><br><span class="line">            event_process_active(base);</span><br><span class="line">            <span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; (flags &amp; EVLOOP_ONCE))</span><br><span class="line">                done = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; EVLOOP_NONBLOCK)</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束，清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    event_debug((<span class="string">&quot;%s: asked to terminate loop.&quot;</span>, __func__));</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-I-O和Timer事件的统一">3. I/O和Timer事件的统一</h3>
<p>libevent将Timer和Signal事件都统一到了系统的I/O 的<strong>demultiplex</strong>机制中了，相信读者从上面的流程和代码中也能窥出一斑了，下面就再啰嗦一次了。<br>
首先将Timer事件融合到系统I/O多路复用机制中，还是相当清晰的，因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）<strong>timeout</strong>，即使没有I/O事件发生，它们也保证能在timeout时间内返回。<br>
那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。<br>
这是在Reactor和Proactor模式（主动器模式，比如Windows上的IOCP）中处理Timer事件的经典方法了，ACE采用的也是这种方法，大家可以参考POSA vol2书中的Reactor模式一节。<br>
堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选（当然是非唯一的），libevent就是采用的堆结构。</p>
<h3 id="4-I-O和Signal事件的统一">4. I/O和Signal事件的统一</h3>
<p>Signal是异步事件的经典事例，将Signal事件统一到系统的I/O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。<br>
如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理，不就可以了嘛。是的，这也是libevent中使用的方法。<br>
问题的核心在于，当Signal发生时，如何通知系统的I/O多路复用机制，这里先买个小关子，放到信号处理一节再详细说明，我想读者肯定也能想出通知的方法，比如使用<strong>pipe</strong>。</p>
<h3 id="5-小节">5 小节</h3>
<p>介绍了libevent的事件主循环，描述了libevent是如何处理就绪的I/O事件、定时器和信号事件，以及如何将它们无缝的融合到一起。</p>
<h2 id="八-集成信号处理">八 集成信号处理</h2>
<p>简单说</p>
<p>Libevent处理信号事件的方式类似于它处理socket事件的方式。它提供了一个统一的接口，使得你可以在一次事件循环中等待多个不同类型的事件，包括信号事件。</p>
<p>在libevent中，你可以通过<code>event_new</code>函数创建一个信号事件。这个函数需要你提供一个信号号码（如SIGINT，代表终端中断信号），一个回调函数，以及一个可选的回调函数参数。当这个信号发生时，libevent会调用你指定的回调函数。</p>
<p>创建信号事件后，你需要通过<code>event_add</code>函数将这个事件添加到事件循环中。这个函数需要你提供一个事件，以及一个可选的超时参数（如果你希望这个事件在一段时间后自动超时）。</p>
<p>在事件循环中，libevent使用<code>sigaction</code>系统调用来接收信号。当一个信号发生时，libevent的内部信号处理函数会被调用。这个函数会查看每个信号事件，看看是否有任何事件的信号号码与当前发生的信号相匹配。如果有，libevent就会将这个事件添加到“就绪”队列中，等待事件循环下一次迭代时被处理。</p>
<p>在事件循环的每次迭代中，libevent会检查“就绪”队列中的事件，调用每个事件的回调函数。这个过程会一直持续，直到没有更多的就绪事件，或者你停止了事件循环。</p>
<p>总的来说，libevent通过提供一个统一的事件处理接口，以及内部的信号处理机制，使得处理信号事件变得相当简单。你只需要创建一个信号事件，提供一个回调函数，然后将事件添加到事件循环中，libevent就会在相应的信号发生时调用你的回调函数，处理事件。</p>
<hr>
<p>现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和Signal以及Timer事件的集成，这一节将分析如何将Signal集成到事件主循环的框架中。</p>
<h3 id="1-集成策略——使用socket-pair">1 集成策略——使用socket pair</h3>
<p>前一节已经做了足够多的介绍了，基本方法就是采用“消息机制”。在libevent中这是通过socket pair完成的，下面就来详细分析一下。<br>
Socket pair就是一个socket对，包含两个socket，一个读socket，一个写socket。工作方式如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527184944634.png" alt="image-20240527184944634"></p>
<p>创建一个socket pair并不是复杂的操作，可以参见下面的流程图，清晰起见，其中忽略了一些错误处理和检查。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185026436.png" alt="image-20240527185026436"></p>
<p>Libevent提供了辅助函数evutil_socketpair()来创建一个socket pair，可以结合上面的创建流程来分析该函数。</p>
<h3 id="2-集成到事件主循环——通知event-base">2 集成到事件主循环——通知event_base</h3>
<p>Socket pair创建好了，可是libevent的事件主循环还是不知道Signal是否发生了啊，看来我们还差了最后一步，那就是：为socket pair的读socket在libevent的event_base实例上注册一个persist的读事件。</p>
<p>这样当向写socket写入数据时，读socket就会得到通知，触发读事件，从而event_base就能相应的得到通知了。<br>
前面提到过，Libevent会在事件主循环中检查标记，来确定是否有触发的signal，如果标记被设置就处理这些signal，这段代码在各个具体的I/O机制中，以Epoll为例，在epoll_dispatch()函数中，代码片段如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">epoll_wait</span>(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">		<span class="built_in">event_warn</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">evsignal_process</span>(base);<span class="comment">// 处理signal事件</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base-&gt;sig.evsignal_caught) &#123;</span><br><span class="line">	<span class="built_in">evsignal_process</span>(base);<span class="comment">// 处理signal事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的处理框架如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185103712.png" alt="image-20240527185103712"></p>
<p>注1：libevent中，初始化阶段并不注册读socket的读事件，而是在注册信号阶段才会测试并注册；<br>
注2：libevent中，检查I/O事件是在各系统I/O机制的dispatch()函数中完成的，该dispatch()函数在event_base_loop()函数中被调用；</p>
<h3 id="3-evsignal-info结构体">3 evsignal_info结构体</h3>
<p>Libevent中Signal事件的管理是通过结构体evsignal_info完成的，结构体位于evsignal.h文件中，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">evsignal_info</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> ev_signal;</span><br><span class="line">    <span class="type">int</span> ev_signal_pair[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ev_signal_added;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> evsignal_caught;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_list</span> evsigevents[NSIG];</span><br><span class="line">    <span class="type">sig_atomic_t</span> evsigcaught[NSIG];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_SIGACTION</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> **sh_old;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">ev_sighandler_t</span> **sh_old;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> sh_old_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面详细介绍一下个字段的含义和作用：<br>
1）ev_signal， 为socket pair的读socket向event_base注册读事件时使用的event结构体；<br>
2）ev_signal_pair，socket pair对，作用见第一节的介绍；<br>
3）ev_signal_added，记录ev_signal事件是否已经注册了；<br>
4）evsignal_caught，是否有信号发生的标记；是volatile类型，因为它会在另外的线程中被修改；<br>
5）evsigvents[NSIG]，数组，evsigevents[signo]表示注册到信号signo的事件链表；<br>
6）evsigcaught[NSIG]，具体记录每个信号触发的次数，evsigcaught[signo]是记录信号signo被触发的次数；<br>
7）sh_old记录了原来的signal处理函数指针，当信号signo注册的event被清空时，需要重新设置其处理函数；<br>
evsignal_info的初始化包括，创建socket pair，设置ev_signal事件（但并没有注册，而是等到有信号注册时才检查并注册），并将所有标记置零，初始化信号的注册事件链表指针等。</p>
<h3 id="4-注册、注销signal事件">4 注册、注销signal事件</h3>
<p>注册signal事件是通过evsignal_add(struct event *ev)函数完成的，libevent对所有的信号注册同一个处理函数evsignal_handler()，该函数将在下一段介绍，注册过程如下：<br>
1）取得ev要注册到的信号signo；<br>
2） 如果信号signo未被注册，那么就为signo注册信号处理函数evsignal_handler()；<br>
3） 如果事件ev_signal还没哟注册，就注册ev_signal事件；<br>
4） 将事件ev添加到signo的event链表中；</p>
<p>从signo上注销一个已注册的signal事件就更简单了，直接从其已注册事件的链表中移除即可。如果事件链表已空，那么就恢复旧的处理函数；</p>
<p>下面的讲解都以signal()函数为例，sigaction()函数的处理和signal()相似。<br>
处理函数evsignal_handler()函数做的事情很简单，就是记录信号的发生次数，并通知event_base有信号触发，需要处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">evsignal_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno; <span class="comment">// 不覆盖原来的错误代码</span></span><br><span class="line">    <span class="keyword">if</span> (evsignal_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">event_warn</span>(<span class="string">&quot;%s: received signal %d, but have no base configured&quot;</span>, __func__, sig);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录信号sig的触发次数，并设置event触发标记</span></span><br><span class="line">    evsignal_base-&gt;sig.evsigcaught[sig]++;</span><br><span class="line">    evsignal_base-&gt;sig.evsignal_caught = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_SIGACTION</span></span><br><span class="line">    <span class="built_in">signal</span>(sig, evsignal_handler); <span class="comment">// 重新注册信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 向写socket写一个字节数据，触发event_base的I/O事件，从而通知其有信号触发，需要处理</span></span><br><span class="line">    <span class="built_in">send</span>(evsignal_base-&gt;sig.ev_signal_pair[<span class="number">0</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno; <span class="comment">// 错误代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-小节-2">5 小节</h3>
<p>本节介绍了libevent对signal事件的具体处理框架，包括事件注册、删除和socket pair通知机制，以及是如何将Signal事件集成到事件主循环之中的。</p>
<h2 id="九-集成定时器事件">九 集成定时器事件</h2>
<p>现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libevent对堆的调整操作做了一些优化，本节还会描述这些优化方法。</p>
<h3 id="1-集成到事件主循环">1 集成到事件主循环</h3>
<p>因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I/O事件发生，它们也保证能在timeout时间内返回。</p>
<p>那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。</p>
<p>具体的代码在源文件event.c的event_base_loop()中，现在就对比代码来看看这一处理方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据Timer事件计算evsel-&gt;dispatch的最大等待时间</span></span><br><span class="line">	<span class="built_in">timeout_next</span>(base, &amp;tv_p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">// 如果还有活动事件，就不要等待，让evsel-&gt;dispatch立即返回</span></span><br><span class="line">	<span class="built_in">evutil_timerclear</span>(&amp;tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 调用select() or epoll_wait() 等待就绪I/O事件</span></span><br><span class="line">res = evsel-&gt;<span class="built_in">dispatch</span>(base, evbase, tv_p);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 处理超时事件，将超时事件插入到激活链表中</span></span><br><span class="line"><span class="built_in">timeout_process</span>(base);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>timeout_next()函数根据堆中具有最小超时值的事件和当前时间来计算等待时间，下面看看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">timeout_next</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> timeval **tv_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> *tv = *tv_p;</span><br><span class="line">    <span class="comment">// 堆的首元素具有最小的超时值</span></span><br><span class="line">    <span class="keyword">if</span> ((ev = <span class="built_in">min_heap_top</span>(&amp;base-&gt;timeheap)) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有定时事件，将等待时间设置为NULL,表示一直阻塞直到有I/O事件发生</span></span><br><span class="line">        *tv_p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得当前时间</span></span><br><span class="line">    <span class="built_in">gettime</span>(base, &amp;now);</span><br><span class="line">    <span class="comment">// 如果超时时间&lt;=当前值，不能等待，需要立即返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">evutil_timercmp</span>(&amp;ev-&gt;ev_timeout, &amp;now, &lt;=)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">evutil_timerclear</span>(tv);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算等待的时间=当前时间-最小的超时时间</span></span><br><span class="line">    <span class="built_in">evutil_timersub</span>(&amp;ev-&gt;ev_timeout, &amp;now, tv);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-Timer小根堆">2 Timer小根堆</h3>
<p>Libevent使用堆来管理Timer事件，其key值就是事件的超时时间，源代码位于文件min_heap.h中。</p>
<p>所有的数据结构书中都有关于堆的详细介绍，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)。堆是一个完全二叉树，基本存储方式是一个数组。</p>
<p>Libevent实现的堆还是比较轻巧的，虽然我不喜欢这种编码方式（搞一些复杂的表达式）。轻巧到什么地方呢，就以插入元素为例，来对比说明，下面伪代码中的size表示当前堆的元素个数：</p>
<p>典型的代码逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap[size++] = <span class="keyword">new</span>; <span class="comment">// 先放到数组末尾，元素个数+1</span></span><br><span class="line"><span class="comment">// 下面就是shift_up()的代码逻辑，不断的将new向上调整</span></span><br><span class="line">_child = size;</span><br><span class="line"><span class="keyword">while</span>(_child&gt;<span class="number">0</span>) <span class="comment">// 循环</span></span><br><span class="line">&#123;</span><br><span class="line">   _parent = (_child<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// 计算parent</span></span><br><span class="line">   <span class="keyword">if</span>(Heap[_parent].key &lt; Heap[_child].key)</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// 调整结束，跳出循环</span></span><br><span class="line">   <span class="built_in">swap</span>(_parent, _child); <span class="comment">// 交换parent和child</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而libevent的heap代码对这一过程做了优化，在插入新元素时，只是为新元素预留了一个位置hole（初始时hole位于数组尾部），但并不立刻将新元素插入到hole上，而是不断向上调整hole的值，将父节点向下调整，最后确认hole就是新元素的所在位置时，才会真正的将新元素插入到hole上，因此在调整过程中就比上面的代码少了一次赋值的操作，代码逻辑是：</p>
<p>下面就是shift_up()的代码逻辑，不断的将new的“预留位置”向上调整</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面就是shift_up()的代码逻辑，不断的将new的“预留位置”向上调整</span></span><br><span class="line">_hole = size; <span class="comment">// _hole就是为new预留的位置，但并不立刻将new放上</span></span><br><span class="line"><span class="keyword">while</span>(_hole&gt;<span class="number">0</span>) <span class="comment">// 循环</span></span><br><span class="line">&#123;</span><br><span class="line">    _parent = (_hole<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// 计算parent</span></span><br><span class="line">    <span class="keyword">if</span>(Heap[_parent].key &lt; <span class="keyword">new</span>.key)</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 调整结束，跳出循环</span></span><br><span class="line">    Heap[_hole] = Heap[_parent]; <span class="comment">// 将parent向下调整</span></span><br><span class="line">    _hole = _parent; <span class="comment">// 将_hole调整到_parent</span></span><br><span class="line">&#125;</span><br><span class="line">Heap[_hole] = <span class="keyword">new</span>; <span class="comment">// 调整结束，将new插入到_hole指示的位置</span></span><br><span class="line">size++; <span class="comment">// 元素个数+1</span></span><br></pre></td></tr></table></figure>
<p>由于每次调整都少做一次赋值操作，在调整路径比较长时，调整效率会比第一种有所提高。libevent中的min_heap_shift_up_()函数就是上面逻辑的具体实现，对应的向下调整函数是min_heap_shift_down_()。</p>
<p>举个例子，向一个小根堆3, 5, 8, 7, 12中插入新元素2，使用第一中典型的代码逻辑，其调整过程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185307526.png" alt="image-20240527185307526"></p>
<p>使用libevent中的堆调整逻辑，调整过程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185319336.png" alt="image-20240527185319336"></p>
<p>对于删除和元素修改操作，也遵从相同的逻辑，就不再罗嗦了。</p>
<h3 id="3-小节">3 小节</h3>
<p>通过设置系统I/O机制的wait时间，从而简捷的集成Timer事件；主要分析了libevent对堆调整操作的优化。</p>
<h2 id="十-支持I-O多路复用技术">十 支持I/O多路复用技术</h2>
<p>Libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而这些在Windows、Linux、Unix等不同平台上却各有不同，如何能提供优雅而统一的支持方式，是首要关键的问题，这其实不难，本节就来分析一下。</p>
<h3 id="1-统一的关键">1 统一的关键</h3>
<p>Libevent支持多种I/O多路复用技术的关键就在于结构体eventop，这个结构体前面也曾提到过，它的成员是一系列的函数指针, 定义在event-internal.h文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventop</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> *(*init)(<span class="keyword">struct</span> event_base *); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">int</span> (*add)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 注册事件</span></span><br><span class="line">    <span class="built_in">int</span> (*del)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 删除事件</span></span><br><span class="line">    <span class="built_in">int</span> (*dispatch)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *, <span class="keyword">struct</span> timeval *); <span class="comment">// 事件分发</span></span><br><span class="line">    <span class="built_in">void</span> (*dealloc)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *); <span class="comment">// 注销，释放资源</span></span><br><span class="line">    <span class="comment">/* set if we need to reinitialize the event base */</span></span><br><span class="line">    <span class="type">int</span> need_reinit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在libevent中，每种I/O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。</p>
<p>比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I/O demultiplex机制了。</p>
<h3 id="2-设置I-O-demultiplex机制">2 设置I/O demultiplex机制</h3>
<p>Libevent把所有支持的I/O demultiplex机制存储在一个全局静态数组eventops中，并在初始化时选择使用何种机制，数组内容根据优先级顺序声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In order of preference */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *eventops[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EVENT_PORTS</span></span><br><span class="line">    &amp;evportops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_WORKING_KQUEUE</span></span><br><span class="line">    &amp;kqops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    &amp;epollops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_DEVPOLL</span></span><br><span class="line">    &amp;devpollops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_POLL</span></span><br><span class="line">    &amp;pollops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_SELECT</span></span><br><span class="line">    &amp;selectops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    &amp;win32ops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>然后libevent根据系统配置和编译选项决定使用哪一种I/O demultiplex机制，这段代码在函数event_base_new()中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base-&gt;evbase = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; eventops[i] &amp;&amp; !base-&gt;evbase; i++) </span><br><span class="line">&#123;</span><br><span class="line">    base-&gt;evsel = eventops[i];</span><br><span class="line">    base-&gt;evbase = base-&gt;evsel-&gt;<span class="built_in">init</span>(base);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看出，libevent在编译阶段选择系统的I/O demultiplex机制，而不支持在运行阶段根据配置再次选择。<br>
以Linux下面的epoll为例，实现在源文件epoll.c中，eventops对象epollops定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> epollops = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;epoll&quot;</span>,</span><br><span class="line">    epoll_init,</span><br><span class="line">    epoll_add,</span><br><span class="line">    epoll_del,</span><br><span class="line">    epoll_dispatch,</span><br><span class="line">    epoll_dealloc,</span><br><span class="line">    <span class="number">1</span> <span class="comment">/* need reinit */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>变量epollops中的函数指针具体声明如下，注意到其返回值和参数都和eventop中的定义严格一致，这是函数指针的语法限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">epoll_init</span>    <span class="params">(<span class="keyword">struct</span> event_base *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epoll_add</span>    <span class="params">(<span class="type">void</span> *, <span class="keyword">struct</span> event *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epoll_del</span>    <span class="params">(<span class="type">void</span> *, <span class="keyword">struct</span> event *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epoll_dispatch</span><span class="params">(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *, <span class="keyword">struct</span> timeval *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">epoll_dealloc</span>    <span class="params">(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么如果选择的是epoll，那么调用结构体eventop的init和dispatch函数指针时，实际调用的函数就是epoll的初始化函数epoll_init()和事件分发函数epoll_dispatch()了；</p>
<p>关于epoll的具体用法这里就不多说了，可以参见介绍epoll的文章（本人的哈哈）：<br>
<a target="_blank" rel="noopener" href="http://blog.csdn.net/sparkliang/archive/2009/11/05/4770655.aspx">http://blog.csdn.net/sparkliang/archive/2009/11/05/4770655.aspx</a></p>
<p>C++语言提供了虚函数来实现多态，在C语言中，这是通过函数指针实现的。对于各类函数指针的详细说明可以参见文章：<br>
<a target="_blank" rel="noopener" href="http://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx">http://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx</a></p>
<p>同样的，上面epollops以及epoll的各种函数都直接定义在了epoll.c源文件中，对外都是不可见的。对于libevent的使用者而言，完全不会知道它们的存在，对epoll的使用也是通过eventop来完成的，达到了信息隐藏的目的。</p>
<h3 id="3-小节-2">3 小节</h3>
<p>支持多种I/O demultiplex机制的方法其实挺简单的，借助于函数指针就OK了。通过对源代码的分析也可以看出，Libevent是在编译阶段选择系统的I/O demultiplex机制的，而不支持在运行阶段根据配置再次选择。</p>
<h2 id="十一-时间管理">十一 时间管理</h2>
<p>为了支持定时器，Libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的时间值调整等。下面就结合源代码来分析一下。</p>
<h3 id="1-初始化检测">1 初始化检测</h3>
<p>Libevent在初始化时会检测系统时间的类型，通过调用函数detect_monotonic()完成，它通过调用clock_gettime()来检测系统是否支持monotonic时钟类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">detect_monotonic</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>    ts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;ts) == <span class="number">0</span>)</span><br><span class="line">        use_monotonic = <span class="number">1</span>; <span class="comment">// 系统支持monotonic时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monotonic时间指示的是系统从boot后到现在所经过的时间，如果系统支持Monotonic时间就将全局变量use_monotonic设置为1，设置use_monotonic到底有什么用，这个在后面说到时间校正时就能看出来了。</p>
<h3 id="2-时间缓存">2 时间缓存</h3>
<p>结构体event_base中的tv_cache，用来记录时间缓存。这个还要从函数gettime()说起，先来看看该函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gettime</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> timeval *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果tv_cache时间缓存已设置，就直接使用</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tv_cache.tv_sec) &#123;</span><br><span class="line">        *tp = base-&gt;tv_cache;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果支持monotonic，就用clock_gettime获取monotonic时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line">    <span class="keyword">if</span> (use_monotonic) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span>    ts;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;ts) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        tp-&gt;tv_sec = ts.tv_sec;</span><br><span class="line">        tp-&gt;tv_usec = ts.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 否则只能取得系统当前时间</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">evutil_gettimeofday</span>(tp, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果tv_cache已经设置，那么就直接使用缓存的时间；否则需要再次执行系统调用获取系统时间。</p>
<p>函数evutil_gettimeofday()用来获取当前系统时间，在Linux下其实就是系统调用gettimeofday()；Windows没有提供函数gettimeofday，而是通过调用_ftime()来完成的。</p>
<p>在每次系统事件循环中，时间缓存tv_cache将会被相应的清空和设置，再次来看看下面event_base_loop的主要代码逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">        <span class="built_in">timeout_correct</span>(base, &amp;tv); <span class="comment">// 时间校正</span></span><br><span class="line">        <span class="comment">// 更新event_tv到tv_cache指示的时间或者当前时间（第一次）</span></span><br><span class="line">         <span class="comment">// event_tv &lt;--- tv_cache</span></span><br><span class="line">        <span class="built_in">gettime</span>(base, &amp;base-&gt;event_tv);</span><br><span class="line">        <span class="comment">// 清空时间缓存-- 时间点1</span></span><br><span class="line">        base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 等待I/O事件就绪</span></span><br><span class="line">        res = evsel-&gt;<span class="built_in">dispatch</span>(base, evbase, tv_p);</span><br><span class="line">        <span class="comment">// 缓存tv_cache存储了当前时间的值-- 时间点2</span></span><br><span class="line">         <span class="comment">// tv_cache &lt;--- now</span></span><br><span class="line">        <span class="built_in">gettime</span>(base, &amp;base-&gt;tv_cache);</span><br><span class="line">        <span class="comment">// .. 处理就绪事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时也要清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间event_tv指示了dispatch()上次返回，也就是I/O事件就绪时的时间，第一次进入循环时，由于tv_cache被清空，因此gettime()执行系统调用获取当前系统时间；而后将会更新为tv_cache指示的时间。</p>
<p>时间tv_cache在dispatch()返回后被设置为当前系统时间，因此它缓存了本次I/O事件就绪时的时间（event_tv）。<br>
从代码逻辑里可以看出event_tv取得的是tv_cache上一次的值，因此event_tv应该小于tv_cache的值。</p>
<p>设置时间缓存的优点是不必每次获取时间都执行系统调用，这是个相对费时的操作；在上面标注的时间点2到时间点1的这段时间（处理就绪事件时），调用gettime()取得的都是tv_cache缓存的时间。</p>
<h3 id="3-时间校正">3 时间校正</h3>
<p>如果系统支持monotonic时间，该时间是系统从boot后到现在所经过的时间，因此不需要执行校正。<br>
根据前面的代码逻辑，如果系统不支持monotonic时间，用户可能会手动的调整时间，如果时间被向前调整了（MS前面第7部分讲成了向后调整，要改正），比如从5点调整到了3点，那么在时间点2取得的值可能会小于上次的时间，这就需要调整了，下面来看看校正的具体代码，由函数timeout_correct()完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">timeout_correct</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> timeval *tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> **pev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> off;</span><br><span class="line">    <span class="keyword">if</span> (use_monotonic) <span class="comment">// monotonic时间就直接返回，无需调整</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">gettime</span>(base, tv); <span class="comment">// tv &lt;---tv_cache</span></span><br><span class="line">    <span class="comment">// 根据前面的分析可以知道event_tv应该小于tv_cache</span></span><br><span class="line">    <span class="comment">// 如果tv &lt; event_tv表明用户向前调整时间了，需要校正时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">evutil_timercmp</span>(tv, &amp;base-&gt;event_tv, &gt;=)) &#123;</span><br><span class="line">        base-&gt;event_tv = *tv;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算时间差值</span></span><br><span class="line">    <span class="built_in">evutil_timersub</span>(&amp;base-&gt;event_tv, tv, &amp;off);</span><br><span class="line">    <span class="comment">// 调整定时事件小根堆</span></span><br><span class="line">    pev = base-&gt;timeheap.p;</span><br><span class="line">    size = base-&gt;timeheap.n;</span><br><span class="line">    <span class="keyword">for</span> (; size-- &gt; <span class="number">0</span>; ++pev) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> *ev_tv = &amp;(**pev).ev_timeout;</span><br><span class="line">        <span class="built_in">evutil_timersub</span>(ev_tv, &amp;off, ev_tv);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;event_tv = *tv; <span class="comment">// 更新event_tv为tv_cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调整小根堆时，因为所有定时事件的时间值都会被减去相同的值，因此虽然堆中元素的时间键值改变了，但是相对关系并没有改变，不会改变堆的整体结构。因此只需要遍历堆中的所有元素，将每个元素的时间键值减去相同的值即可完成调整，不需要重新调整堆的结构。<br>
当然调整完后，要将event_tv值重新设置为tv_cache值了。</p>
<h3 id="4-小节-2">4 小节</h3>
<p>主要分析了一下libevent对系统时间的处理，时间缓存、时间校正和定时堆的时间值调整等，逻辑还是很简单的，时间的加减、设置等辅助函数则非常简单，主要在头文件evutil.h中，就不再多说了。</p>
<h2 id="十二-让libevent支持多线程">十二 让libevent支持多线程</h2>
<p>Libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代码并没有太大的关系，纯粹是使用上的技巧。</p>
<h3 id="1-错误使用示例">1 错误使用示例</h3>
<p>在多核的CPU上只使用一个线程始终是对不起CPU的处理能力啊，那好吧，那就多创建几个线程，比如下面的简单服务器场景。<br>
1）主线程创建工作线程1；<br>
2）接着主线程监听在端口上，等待新的连接；<br>
3）在线程1中执行event事件循环，等待事件到来；<br>
4）新连接到来，主线程调用libevent接口event_add将新连接注册到libevent上；<br>
… …<br>
上面的逻辑看起来没什么错误，在很多服务器设计中都可能用到主线程和工作线程的模式….<br>
可是就在线程1注册事件时，主线程很可能也在操作事件，比如删除，修改，通过libevent的源代码也能看到，没有同步保护机制，问题麻烦了，看起来不能这样做啊，难道只能使用单线程不成！？</p>
<h3 id="2-支持多线程的几种模式">2 支持多线程的几种模式</h3>
<p>Libevent并不是线程安全的，但这不代表libevent不支持多线程模式，其实方法在前面已经将signal事件处理时就接触到了，那就是消息通知机制。</p>
<p>一句话，“你发消息通知我，然后再由我在合适的时间来处理”；<br>
说到这就再多说几句，再打个比方，把你自己比作一个工作线程，而你的头是主线程，你有一个消息信箱来接收别人发给你的消息，当时头有个新任务要指派给你。</p>
<h4 id="2-1-暴力抢占">2.1 暴力抢占</h4>
<p>那么第一节中使用的多线程方法相当下面的流程：<br>
1）当时你正在做事，比如在写文档；<br>
2）你的头找到了一个任务，要指派给你，比如帮他搞个PPT，哈；<br>
3）头命令你马上搞PPT，你这是不得不停止手头的工作，把PPT搞定了再接着写文档；<br>
…</p>
<h4 id="2-2-纯粹的消息通知机制">2.2 纯粹的消息通知机制</h4>
<p>那么基于纯粹的消息通知机制的多线程方式就像下面这样：<br>
1 当时你正在写文档；<br>
2 你的头找到了一个任务，要指派给你，帮他搞个PPT；<br>
3 头发个消息到你信箱，有个PPT要帮他搞定，这时你并不鸟他；<br>
4 你写好文档，接着检查消息发现头有个PPT要你搞定，你开始搞PPT；<br>
…</p>
<p>第一种的好处是消息可以立即得到处理，但是很方法很粗暴，你必须立即处理这个消息，所以你必须处理好切换问题，省得把文档上的内容不小心写到PPT里。在操作系统的进程通信中，消息队列（消息信箱）都是操作系统维护的，你不必关心。<br>
第二种的优点是通过消息通知，切换问题省心了，不过消息是不能立即处理的（基于消息通知机制，这个总是难免的），而且所有的内容都通过消息发送，比如PPT的格式、内容等等信息，这无疑增加了通信开销。</p>
<h4 id="2-3-消息通知-同步层">2.3 消息通知+同步层</h4>
<p>有个折中机制可以减少消息通信的开销，就是提取一个同步层，还拿上面的例子来说，你把工作安排都存放在一个工作队列中，而且你能够保证“任何人把新任务扔到这个队列”，“自己取出当前第一个任务”等这些操作都能够保证不会把队列搞乱（其实就是个加锁的队列容器）。<br>
再来看看处理过程和上面有什么不同：<br>
1）当时你正在写文档；<br>
2）你的头找到了一个任务，要指派给你，帮他搞个PPT；<br>
3) 头有个PPT要你搞定，他把任务push到你的工作队列中，包括了PPT的格式、内容等信息；<br>
4) 头发个消息（一个字节）到你信箱，有个PPT要帮他搞定，这时你并不鸟他；<br>
5) 你写好文档，发现有新消息（这预示着有新任务来了），检查工作队列知道头有个PPT要你搞定，你开始搞PPT；<br>
…</p>
<p>工作队列其实就是一个加锁的容器（队列、链表等等），这个很容易实现实现；而消息通知仅需要一个字节，具体的任务都push到了在工作队列中，因此想比2.2减少了不少通信开销。</p>
<p>多线程编程有很多陷阱，线程间资源的同步互斥不是一两句能说得清的，而且出现bug很难跟踪调试；这也有很多的经验和教训，因此如果让我选择，在绝大多数情况下都会选择机制3作为实现多线程的方法。</p>
<h3 id="3例子——memcached">3例子——memcached</h3>
<p>Memcached中的网络部分就是基于libevent完成的，其中的多线程模型就是典型的消息通知+同步层机制。下面的图足够说明其多线程模型了，其中有详细的文字说明。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185527228.png" alt="image-20240527185527228"></p>
<h3 id="4-小节-3">4 小节</h3>
<p>本节更是libevent的使用方面的技巧，讨论了一下如何让libevent支持多线程，以及几种支持多线程的机制，和memcached使用libevent的多线程模型。</p>
<blockquote>
<p><strong>libevent解决了网络编程哪些痛点？</strong></p>
</blockquote>
<p><strong>高效的网络缓冲区</strong><br>
在内核中有读缓冲区和写缓冲区，减少用户态和内核态的切换。<br>
用户态读缓冲区的存在是为了处理粘包的问题，因为网络协议栈是不知道用户界定数据包的格式，没法确定一个完整的数据包。<br>
用户态写缓冲区的存在是因为用户根本不清楚内核写缓存区的状态，需要把没有写出去的数据缓存起来等待下次写事件时把数据写出去。<br>
buffer的设计有三种类型：<br>
（1）固定数组，固定长度。限定了处理数据包的能力，没有动态伸缩的能力；需要<strong>频繁挪动数据。</strong><br>
（2）ring buffer。可伸缩性差。<br>
（3）chain buffer。解决可伸缩性差的问题，避免频繁挪动数据；同时也引进了新的问题，一个数据可能在多个buffer中都有，即数据分割，这会导致多次系统调用，从而引起中断上下文的切换。解决办法是使用readv()将内核中连续的buffer读到用户态不连续的buffer中，writev()把用户态不连续的buffer写到内核连续的buffer中；从而减少<strong>系统调用</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185935359.png" alt="image-20240527185935359"></p>
<p>evbuffer就是chain buffer类型的缓冲区。</p>
<p><strong>IO函数使用与网络原理</strong><br>
（1）有了libevent可以不使用IO函数。因为如果使用IO函数，既需要知道这些IO函数里面的系统调用返回值的含义。<br>
（2）有了libevent就可以不清楚数据拷贝原理。<br>
（3）有了libevent就可以不清楚网络原理以及网络编程流程。<br>
（4）有了libevent只需要知道事件处理，IO操作完全交由libevent处理。</p>
<p><strong>多线程</strong><br>
加锁的效果比较好。<br>
一个线程尽量只处理一个reactor的事件。<br>
（1）buffer加锁时，读要读出一个完整的数据包。<br>
（2）buffer加锁时，写要写一个完整的数据包。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>libevent源码剖析</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://penge666.github.io/posts/32933883.html">https://penge666.github.io/posts/32933883.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Penge666</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-05-24</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-06-02</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>网络编程</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/69dcf386.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_17.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Memcached笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/d696d4de.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">模块5:数据中心</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d0543761.html" title="muduo网络库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_22.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-04</div><div class="title">muduo网络库</div></div></a></div><div><a href="/posts/73cae4d3.html" title="libhv入门教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_28.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-24</div><div class="title">libhv入门教程</div></div></a></div><div><a href="/posts/b1577ae3.html" title="SEDA异步事件框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_117.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-30</div><div class="title">SEDA异步事件框架</div></div></a></div><div><a href="/posts/ef701d36.html" title="Nginx网络工作原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_130.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-06-03</div><div class="title">Nginx网络工作原理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%BA%8F%E5%B9%95"><span class="toc-text">一 序幕</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-libevent%E7%AE%80%E4%BB%8B"><span class="toc-text">2 libevent简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">3 学习的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-reactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">二 reactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-reactor%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">1 reactor的事件处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-reactor%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">2 reactor模式的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-reactor%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6"><span class="toc-text">3 reactor模式框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-reactor%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">4 reactor事件处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93"><span class="toc-text">5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-libevent%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">三 libevent基本使用场景和事件流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80-2"><span class="toc-text">1 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2 基本应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">3 实例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">4 事件处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-2"><span class="toc-text">5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-libevent%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-text">四 libevent源代码文件组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80-3"><span class="toc-text">1 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-text">2 源代码组织结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-text">3 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-libevent%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9A%E4%BA%8B%E4%BB%B6event"><span class="toc-text">五 libevent的核心：事件event</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-libevent%E7%9A%84%E6%A0%B8%E5%BF%83-event"><span class="toc-text">1 libevent的核心-event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-libevent%E5%AF%B9event%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">2 libevent对event的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E4%BB%B6%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">3 事件设置的接口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-text">4 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%88%9D%E8%A7%81%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6"><span class="toc-text">六 初见事件处理框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6-event-base"><span class="toc-text">1 事件处理框架-event_base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96event-base"><span class="toc-text">2 创建和初始化event_base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">3 接口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E8%8A%82"><span class="toc-text">4 小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E4%BA%8B%E4%BB%B6%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">七 事件主循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%B6%E6%AE%B5%E6%80%A7%E7%9A%84%E8%83%9C%E5%88%A9"><span class="toc-text">1. 阶段性的胜利</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">2. 事件处理主循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-I-O%E5%92%8CTimer%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%9F%E4%B8%80"><span class="toc-text">3. I&#x2F;O和Timer事件的统一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-I-O%E5%92%8CSignal%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%9F%E4%B8%80"><span class="toc-text">4. I&#x2F;O和Signal事件的统一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E8%8A%82"><span class="toc-text">5 小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E9%9B%86%E6%88%90%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">八 集成信号处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E6%88%90%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8socket-pair"><span class="toc-text">1 集成策略——使用socket pair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9B%86%E6%88%90%E5%88%B0%E4%BA%8B%E4%BB%B6%E4%B8%BB%E5%BE%AA%E7%8E%AF%E2%80%94%E2%80%94%E9%80%9A%E7%9F%A5event-base"><span class="toc-text">2 集成到事件主循环——通知event_base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-evsignal-info%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">3 evsignal_info结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E5%86%8C%E3%80%81%E6%B3%A8%E9%94%80signal%E4%BA%8B%E4%BB%B6"><span class="toc-text">4 注册、注销signal事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E8%8A%82-2"><span class="toc-text">5 小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E9%9B%86%E6%88%90%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">九 集成定时器事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E6%88%90%E5%88%B0%E4%BA%8B%E4%BB%B6%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">1 集成到事件主循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Timer%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="toc-text">2 Timer小根堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E8%8A%82"><span class="toc-text">3 小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E6%94%AF%E6%8C%81I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-text">十 支持I&#x2F;O多路复用技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%9F%E4%B8%80%E7%9A%84%E5%85%B3%E9%94%AE"><span class="toc-text">1 统一的关键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AEI-O-demultiplex%E6%9C%BA%E5%88%B6"><span class="toc-text">2 设置I&#x2F;O demultiplex机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E8%8A%82-2"><span class="toc-text">3 小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">十一 时间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%80%E6%B5%8B"><span class="toc-text">1 初始化检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%B6%E9%97%B4%E7%BC%93%E5%AD%98"><span class="toc-text">2 时间缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E6%A0%A1%E6%AD%A3"><span class="toc-text">3 时间校正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E8%8A%82-2"><span class="toc-text">4 小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E8%AE%A9libevent%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">十二 让libevent支持多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">1 错误使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">2 支持多线程的几种模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9A%B4%E5%8A%9B%E6%8A%A2%E5%8D%A0"><span class="toc-text">2.1 暴力抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%BA%AF%E7%B2%B9%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">2.2 纯粹的消息通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5-%E5%90%8C%E6%AD%A5%E5%B1%82"><span class="toc-text">2.3 消息通知+同步层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94memcached"><span class="toc-text">3例子——memcached</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E8%8A%82-3"><span class="toc-text">4 小节</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>用勇气改变可以改变的事，用胸怀接受不能接受的事，用智慧分辨两者的不同✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/Penge666/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">惊喜网站</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By Penge666</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/分布式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Kevinの分布式学习笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 Kevinの操作系统笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Cpp/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 KevinのCpp基础笔记 (23)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/Redis/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Penge666.github.io/categories/etcd/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 Kevinの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://Penge666.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/photo1/default_cover_20.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>