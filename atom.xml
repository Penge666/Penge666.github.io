<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-09-19T11:18:04.619Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Raft-lab2</title>
    <link href="https://penge666.github.io/posts/4091b1cf.html"/>
    <id>https://penge666.github.io/posts/4091b1cf.html</id>
    <published>2024-09-05T03:06:06.000Z</published>
    <updated>2024-09-19T11:18:04.619Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：由于最近找工作战况严峻，不得以只能再掏个去年的项目，顺便温故一下之前学习分布式知识，commit就是最好的证明~PS：找工作的风气…，希望写这个Lab的不要太功利，bug才是真正提高自己水平的~</p><p>那段时光也是最能静下心来，算是研究生生涯中相对美好的时光~~~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914110620319.png" alt="image-20240914110620319"></p><p>写这篇文章的时候，发生了一件很不愉快的事情，让我觉得生命中认识某些人是我的悲哀。</p><p>真正厉害的人，是在避开车马喧嚣后，还可以在心中修篱种菊；是在面对不如意时，还可以戒掉抱怨，学会自愈。</p><p>很多事情就像风吹过一样，随风散去ba~</p><h2 id="实验说明">实验说明</h2><p>地址：<a href="http://nil.csail.mit.edu/6.824/2022/labs/lab-raft.html">http://nil.csail.mit.edu/6.824/2022/labs/lab-raft.html</a></p><p><strong>任务要求</strong></p><ul><li>实现leader和follower追加新日志条目的代码</li><li>运行<code>go test -run 2B</code>来测试</li></ul><p><strong>任务提示</strong></p><ul><li>你的首要目标应该是通过<code>TestBasicAgree2B()</code>。从实现<code>Start()</code>开始，然后根据Figure2写通过AppendEntries RPCs发送和接收新日志条目的代码。</li><li>你需要实现论文5.4.1节提到的选举限制.</li><li>在lab 2B的早期测试中无法达成协议的一种可能是，即使leader还活着也在反复举行选举。寻找选举计时器管理中的错误，或者在赢得选举后不立即发送心跳。</li><li>你的代码可能具有重复检查某些事件的循环。不要让这些循环连续执行而不暂停，因为这会拖慢实现，导致测试失败。使用Go的<a href="https://pkg.go.dev/sync#Cond">条件变量</a>，或者在每个循环迭代中插入一个<code>time.Sleep(10 * time.Millisecond)</code>。</li><li>为了将来的实验，请编写或重写干净而清晰的代码，思路可以参考raft-structure、raft-locking和guide文档。</li></ul><p>如果你的代码运行太慢，接下来的测试可能会失败。你可以使用<code>time</code>命令检查你的解决方案使用了多少实时时间和CPU时间。下面是典型的输出示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ time <span class="keyword">go</span> test -run <span class="number">2</span>B</span><br><span class="line">Test (<span class="number">2</span>B): basic agreement ...</span><br><span class="line">... Passed -- <span class="number">1.6</span> <span class="number">3</span> <span class="number">18</span> <span class="number">5158</span> <span class="number">3</span></span><br><span class="line">Test (<span class="number">2</span>B): RPC <span class="type">byte</span> count ...</span><br><span class="line">... Passed -- <span class="number">3.3</span> <span class="number">3</span> <span class="number">50</span> <span class="number">115122</span> <span class="number">11</span></span><br><span class="line">Test (<span class="number">2</span>B): agreement despite follower disconnection ...</span><br><span class="line">... Passed -- <span class="number">6.3</span> <span class="number">3</span> <span class="number">64</span> <span class="number">17489</span> <span class="number">7</span></span><br><span class="line">Test (<span class="number">2</span>B): no agreement <span class="keyword">if</span> too many followers disconnect ...</span><br><span class="line">... Passed -- <span class="number">4.9</span> <span class="number">5</span> <span class="number">116</span> <span class="number">27838</span> <span class="number">3</span></span><br><span class="line">Test (<span class="number">2</span>B): concurrent Start()s ...</span><br><span class="line">... Passed -- <span class="number">2.1</span> <span class="number">3</span> <span class="number">16</span> <span class="number">4648</span> <span class="number">6</span></span><br><span class="line">Test (<span class="number">2</span>B): rejoin of partitioned leader ...</span><br><span class="line">... Passed -- <span class="number">8.1</span> <span class="number">3</span> <span class="number">111</span> <span class="number">26996</span> <span class="number">4</span></span><br><span class="line">Test (<span class="number">2</span>B): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">... Passed -- <span class="number">28.6</span> <span class="number">5</span> <span class="number">1342</span> <span class="number">953354</span> <span class="number">102</span></span><br><span class="line">Test (<span class="number">2</span>B): RPC counts aren<span class="string">&#x27;t too high ...</span></span><br><span class="line"><span class="string">... Passed -- 3.4 3 30 9050 12</span></span><br><span class="line"><span class="string">PASS</span></span><br><span class="line"><span class="string">ok raft 58.142s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">real 0m58.475s</span></span><br><span class="line"><span class="string">user 0m2.477s</span></span><br><span class="line"><span class="string">sys 0m1.406s</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure><ul><li><p>&quot;ok raft 58.142s&quot;意味着Go测量Part 2B花费的实际时间为58.142秒。</p></li><li><p>“user 0m2.477s”意味着代码消耗了2.477秒的CPU时间，即实际执行指令所花费的时间（而不是等待或休眠的时间）。</p></li><li><p>如果你的解决方案在Part 2B测试中使用的实时时间远远超过一分钟，或者CPU时间远远超过5秒，那么你之后可能会遇到麻烦。</p><p>查看花费在睡眠或等待RPC超时上的时间、在没有睡眠或等待条件或通道消息的情况下运行的循环，或者大量的RPC发送。</p></li></ul><h2 id="原理说明">原理说明</h2><p><strong>FAQ</strong></p><p><strong>Q：为什么要日志复制？</strong></p><p>A：当一个节点成为领导人后，他需要将自己的日志，复制到其他的跟随者节点，而这，正是复制状态机的实现关键，只要领导人将自己的日志都正确，安全地复制到了跟随者节点，这样可以保证，不管我们外部向任意一个集群发起指令请求，他都会帮助我们找到领导人，而领导人会帮我们将该请求的日志信息都复制到所有的节点，并执行日志的请求，所以无论我们向集群的任意的节点发起输入，最终得到的输出都是一致的。</p><p><strong>Q：raft集群怎么得以保障各个机器上的数据的一致性？</strong></p><p>A：prevLogIndex和prevLogTerm保证。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914144119304.png" alt="image-20240914144119304"></p><p><strong>描述：</strong></p><p>在这个场景中，S1 是当前任期4的领导者，而 S2 在先前崩溃后刚刚恢复，因此 S2 的日志缺失了一些任期4的内容，导致集群中的日志不一致。</p><p>作为领导者，S1 在发送心跳信号（也就是 <code>AppendEntries</code> RPC）时，会附带上它自己最后一条日志的任期号和索引号。而跟随者 S2 收到这个心跳信号后，会对比 S1 发送过来的上一个日志的任期号和索引号与它自己本地日志中的相应值。如果 S1 和 S2 的这些值一致，说明在这个索引号之前，两者的日志是完全一致的，S2 就可以安全地复制 S1 的日志到自己的日志序列中。</p><p>但是，如果 S1 和 S2 的任期号或日志索引号不一致，说明 S2 缺失了一些日志或日志有冲突。在这种情况下，S1 会通过回溯，逐步减少发送的索引号，直到找到两者日志序列一致的位置。</p><p>具体而言，S1 会先发送包含索引 <code>6</code> 和对应任期号的日志条目，但 S2 检查发现其本地日志在该索引处的任期号不一致，接着 S1 会发送索引 <code>5</code> 处的日志，继续回溯，直到找到两者日志完全一致的索引位置。找到了双方日志的最后一致位置后，S2 就可以从该位置继续接受并复制 S1 的最新日志。</p><p>这一过程可以被看作是领导者逐步“回退”日志索引，直到找到双方日志的同步点，然后再继续日志复制，确保集群中所有节点的日志最终保持一致。</p><p><strong>根据上述日志idx和任期号，无法保证一致性</strong>。</p><p>来看下论文中举出经典的例子：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914145808506.png" alt="image-20240914145808506"></p><p>解释：</p><ul><li>现在集群中已经有过半数节点（a、b、c、d）复制并提交了索引4到9的日志，因此这些日志应该已经正确提交。</li><li>如果此时节点 <strong>f</strong> 当选为新的领导者，情况会非常危险。节点 <strong>f</strong> 的日志与其他节点的最后一致日志是索引3，它的索引4到9的日志是任期2和3的旧日志。</li><li>节点 <strong>f</strong> 当选后，会将自己未提交的旧日志从索引4到9覆盖到其他节点上，导致已经提交的日志（任期4、5、6的日志）被覆盖，破坏了系统的一致性。</li></ul><p><strong>Q：上面说到，根据上述日志idx和任期号，无法保证一致性，那raft如何解决的呢？</strong></p><p>A：</p><p>在 Raft 共识算法中，候选者在发起选举投票的 RPC 时，会携带其最后一项日志的任期号（<code>lastLogTerm</code>）和索引号（<code>lastLogIndex</code>）。每个收到 RPC 的跟随者都会将其与自己的最后一项日志的任期号和索引号进行比较，以确定候选者的日志是否过期。具体规则如下：</p><ol><li><strong>任期号比较</strong>：<ul><li>如果候选者的 <code>lastLogTerm</code> 小于跟随者的 <code>lastLogTerm</code>，则跟随者会拒绝投票。</li><li>如果候选者的 <code>lastLogTerm</code> 大于或等于跟随者的 <code>lastLogTerm</code>，则继续进行下一步比较。</li></ul></li><li><strong>索引号比较</strong>：<ul><li>如果任期号相同（即 <code>lastLogTerm</code> 相等），则比较索引号。</li><li>如果候选者的 <code>lastLogIndex</code> 小于跟随者的 <code>lastLogIndex</code>，则跟随者会拒绝投票。</li><li>如果候选者的 <code>lastLogIndex</code> 大于或等于跟随者的 <code>lastLogIndex</code>，则跟随者会投票给候选者。</li></ul></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914202007154.png" alt="image-20240914202007154"></p><p><strong>Q：领导人将一项日志复制到过半的节点后，就可以执行提交了吗？</strong></p><p>A：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914202111140.png" alt="image-20240914202111140"></p><p>【崩掉之后 新leader的节点必须在日志复制过半的节点】</p><p><strong>假设场景</strong></p><ol><li><strong>S1 在任期 2 当选领导人，写入了日志条目 2</strong>，但还未完成复制或提交就崩溃了。</li><li><strong>S5 在任期 3 当选领导人</strong>，并写入了自己的日志条目 2（任期 3），但也未完成复制或提交，随后 S5 崩溃。</li><li><strong>S1 在任期 4 再次当选领导人</strong>，并试图将它在任期 2 写的日志条目 2（任期 2）复制到其他节点上。</li></ol><p><strong>现在的问题</strong></p><ul><li>当 S1 再次成为领导人后，它是否可以提交自己在任期 2 时写的日志条目 2？</li><li>如果 S1 提交了日志条目 2，之后又崩溃了，S5 成为新领导人后会发生什么？</li></ul><p><strong>1.S1 在任期 4 是否可以提交日志条目 2？</strong></p><p>根据 Raft 的规则，<strong>日志条目只有在当前领导者的任期内被复制到过半数节点后才可以提交</strong>。即使 S1 是在任期 4 当选领导人，它也不能直接提交它在<strong>任期 2</strong> 写入的日志条目 2，原因如下：</p><ul><li><strong>Raft 的安全性</strong>要求：只有当一个日志条目被当前领导者（在它的任期内）复制到大多数节点时，才能被提交。</li><li>虽然 S1 是在任期 4 当选的领导人，但它试图提交的是<strong>任期 2</strong> 的日志条目。根据 Raft 的规则，S1 必须在<strong>任期 4</strong> 重新将该日志复制到大多数节点上，并且这些节点确认该日志在<strong>当前任期内</strong>（即任期 4）是最新的，S1 才能提交。</li></ul><p>因此，在 S1 成为任期 4 的领导人后，它需要重新将<strong>任期 4</strong> 的日志条目复制到大多数节点上，才能安全地提交这些日志条目。如果它只复制了<strong>任期 2</strong> 的日志条目，而没有在任期 4 中将这些条目重新复制到大多数节点上，它是不能立即提交的。</p><p><strong>2. 如果 S1 在任期 4 提交了日志条目 2，之后崩溃了会发生什么？</strong></p><p>假设 S1 在没有符合 Raft 安全性要求的情况下错误地提交了任期 2 的日志条目 2，然后它崩溃了，S5 在任期 5 成为领导人。此时，S5 必须遵循 Raft 的日志复制和冲突解决规则。</p><ul><li><p>S5 的日志条目 2（任期 3）会覆盖 S1 的日志条目 2（任期 2）</p><p>。这是因为 Raft 的日志冲突解决机制规定：</p><ul><li>如果某个节点的日志条目与领导者的日志不一致（即索引相同但任期不同），领导者会用自己的日志条目覆盖追随者的条目。</li><li>因为 S5 在任期 3 中写的日志条目 2（任期 3）比 S1 的日志条目 2（任期 2）更新，S5 会将它的日志条目 2（任期 3）复制到其他节点，覆盖掉之前的任期 2 的日志条目 2。</li></ul></li></ul><p><strong>3. 如果在此时提交了日志 2，会发生什么？</strong></p><p>如果 S1 在任期 4 中提交了日志条目 2（任期 2），即便它提交了该日志条目，后续如果 S5 成为领导人并覆盖了日志条目 2，那么系统的一致性可能会被破坏。</p><ul><li><strong>提交并不意味着日志条目永远不可更改</strong>。Raft 的日志一致性是基于领导者的日志，如果后续有新任期的领导者出现，并且它的日志条目比之前的日志更新，那么即使之前的日志条目已经提交，新领导者仍然可以通过覆盖的方式引入新的日志条目。</li><li>因此，如果 S1 提交了任期 2 的日志条目 2，但之后 S5 覆盖了它的日志条目，系统最终会采用 S5 的版本，S1 的日志条目将被认为是无效的。这可能导致已经执行的操作被“撤销”或“覆盖”，从而违反了系统的一致性要求。</li></ul><p><strong>Q：在 Raft 共识算法中，领导者提交日志后，存在一个时间间隔，这段时间内，虽然领导者已经将提交结果返回给了客户端，但还没有通知所有的跟随者节点成功提交。如果在这段时间内领导者崩溃了，确实会出现这样一种情况：领导者已经成功提交了日志，但其他节点还没有同步提交。这个看似“单点提交”的情况会不会影响整个集群的一致性呢？</strong></p><p>A：</p><p>在 Raft 算法中，日志的提交和复制遵循严格的多数决规则。领导者在提交日志之前，必须确保该日志已经复制到了大多数节点上。即使领导者在提交日志后崩溃，但只要日志已经复制到了大多数节点，Raft 的一致性机制依然能够保证整个集群最终能正确提交该日志。</p><p><strong>场景分析：</strong></p><p>假设在某个领导者（比如 S1）提交了日志后，但在通知所有跟随者节点成功提交之前，S1 崩溃了。此时，像 S2 和 S3 等跟随者节点并没有接收到通知，日志还没有被这些节点正式提交。</p><p>但由于 Raft 的机制，日志已经被<strong>复制到过半节点</strong>（即至少有大多数节点保存了该日志）。这意味着，只要有大多数节点存活，新的领导者在选举时，必须从拥有最新日志的节点中产生。因此，当 S1 崩溃后，只有那些已经接收到该日志并保存了该日志的节点能够当选为新的领导者。</p><p><strong>新的领导者如何处理：</strong></p><p>当新领导者（例如 S2 或 S3）被选举出来后，它会继续同步和提交之前的未完成日志。由于该日志已经复制到了大多数节点，新领导者会确认该日志的提交状态，并将其提交给那些尚未完成提交的节点。</p><p><strong>总结：</strong></p><p>因此，<strong>单点提交并不会导致日志一致性问题</strong>。一旦有一个领导者成功提交了日志，并且该日志已经复制到了大多数节点，即使领导者崩溃，新的领导者也能够接续处理并完成日志的提交。Raft 的多数决复制机制确保了只要有大多数节点存活，集群就能够保证一致性。</p><p>换句话说，<strong>单点提交意味着集群整体最终会成功提交</strong>，因为新的领导者会从大多数节点中继承并完成未完成的提交操作。</p><p><strong>理清一个概念：日志复制过半和提交</strong></p><p><strong>复制过半</strong>：当领导者将一条日志条目发送给跟随者，并且超过半数的节点（包括领导者自己）已经成功保存了这条日志，我们称这条日志复制过半。此时，日志条目只是被大多数节点持有，但并不意味着立即提交。<br><strong>日志提交</strong>：为了确保一致性，Raft 要求日志条目在当前领导者的任期内，且已经被复制到过半节点，才能被正式提交。提交意味着该日志条目是已达成共识的，并且可以被应用到状态机，影响系统的状态。</p><h2 id="实验思路">实验思路</h2><p>对于lab2中去看2b的test其实可以可以发现，其实是调用raft中的start函数，对leader节点写入log，然后检测log是否成功其实就是通过applyChan协程一直检测。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914141946975.png" alt="image-20240914141946975"></p><p>raft 数据结构新增维护日志数据变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line"><span class="comment">// 根据论文的要求定义</span></span><br><span class="line"><span class="comment">// 2A</span></span><br><span class="line">currentTerm     <span class="type">int</span>         <span class="comment">// Server当前的term</span></span><br><span class="line">voteFor         <span class="type">int</span>         <span class="comment">// Server在选举阶段的投票给了谁</span></span><br><span class="line">voteGrantedNum  <span class="type">int</span>         <span class="comment">// 收集到的投票数量</span></span><br><span class="line">state           <span class="type">int</span>         <span class="comment">// 当前状态</span></span><br><span class="line">heartbeatTimer  *time.Timer <span class="comment">// 心跳超时时间</span></span><br><span class="line">electionTimeout *time.Timer <span class="comment">// 随机选举时间</span></span><br><span class="line"><span class="comment">// 2B</span></span><br><span class="line">logs        []Entry</span><br><span class="line">commitIndex <span class="type">int</span>           <span class="comment">// 已提交日志序号</span></span><br><span class="line">lastApplied <span class="type">int</span>           <span class="comment">// 已应用日志序号</span></span><br><span class="line">nextIndex   []<span class="type">int</span>         <span class="comment">// 下一个待发送日志序号，leader 特有</span></span><br><span class="line">matchIndex  []<span class="type">int</span>         <span class="comment">// 已同步日志序号，leader 特有</span></span><br><span class="line">applyChan   <span class="keyword">chan</span> ApplyMsg <span class="comment">// 日志都是存在这里client取（2B）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义日志具体细节</span></span><br><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Index   <span class="type">int</span>         <span class="comment">// 日志索引，也就是第几行</span></span><br><span class="line">Term    <span class="type">int</span>         <span class="comment">// 任期</span></span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 具体命令内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplyMsg 结构体用于在 Raft 集群中传递应用消息。它包含两种类型的消息：命令消息和快照消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 指示该消息是否包含有效的命令</span></span><br><span class="line">CommandValid <span class="type">bool</span></span><br><span class="line"><span class="comment">// 如果 CommandValid 为 true，则 Command 包含要应用的命令</span></span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 如果 CommandValid 为 true，则 CommandIndex 包含命令的索引</span></span><br><span class="line">CommandIndex <span class="type">int</span></span><br><span class="line"><span class="comment">// 以下字段用于快照（2D 部分）</span></span><br><span class="line"><span class="comment">// 指示该消息是否包含有效的快照</span></span><br><span class="line">SnapshotValid <span class="type">bool</span></span><br><span class="line"><span class="comment">// 如果 SnapshotValid 为 true，则 Snapshot 包含快照数据</span></span><br><span class="line">Snapshot []<span class="type">byte</span></span><br><span class="line"><span class="comment">// 如果 SnapshotValid 为 true，则 SnapshotTerm 包含快照对应的任期</span></span><br><span class="line">SnapshotTerm <span class="type">int</span></span><br><span class="line"><span class="comment">// 如果 SnapshotValid 为 true，则 SnapshotIndex 包含快照对应的索引</span></span><br><span class="line">SnapshotIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Start方法：测试代码是通过Start方法给Leader节点添加日志条目。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start 方法用于启动 Raft 协议中的日志追加过程。</span></span><br><span class="line"><span class="comment">// 如果当前服务器不是领导者，则返回 false。</span></span><br><span class="line"><span class="comment">// 否则，启动日志追加过程并立即返回。</span></span><br><span class="line"><span class="comment">// 返回值包括：</span></span><br><span class="line"><span class="comment">// 1. 命令将被提交的索引</span></span><br><span class="line"><span class="comment">// 2. 当前任期</span></span><br><span class="line"><span class="comment">// 3. 当前服务器是否为领导者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">index := <span class="number">-1</span> <span class="comment">// 初始化索引为 -1</span></span><br><span class="line">term := <span class="number">-1</span>  <span class="comment">// 初始化任期为 -1</span></span><br><span class="line">isLeader := <span class="literal">true</span> <span class="comment">// 假设当前服务器是领导者</span></span><br><span class="line"><span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// 如果 Raft 实例已被终止，则返回 false</span></span><br><span class="line"><span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">fmt.Println(<span class="string">&quot;Start false1&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> index, term, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前任期</span></span><br><span class="line">term = rf.currentTerm</span><br><span class="line"><span class="comment">// 如果当前服务器是领导者，则处理命令</span></span><br><span class="line"><span class="keyword">if</span> rf.state == StateLeader &#123;</span><br><span class="line">PrettyDebug(dInfo, <span class="string">&quot;S%dcommand%d[ReceiveLog]&quot;</span>, rf.me, command)</span><br><span class="line"><span class="comment">// 定义新的日志条目</span></span><br><span class="line">PrettyDebug(dInfo, <span class="string">&quot;S%d:%d[Start-Before]&quot;</span>, rf.me, rf.logs)</span><br><span class="line">tlog := Entry&#123;&#125;</span><br><span class="line">tlog.Index = <span class="built_in">len</span>(rf.logs) + <span class="number">1</span> <span class="comment">// 设置日志条目的索引</span></span><br><span class="line">tlog.Term = term <span class="comment">// 设置日志条目的任期</span></span><br><span class="line">tlog.Command = command <span class="comment">// 设置日志条目的命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新的日志条目追加到日志中</span></span><br><span class="line">rf.logs = <span class="built_in">append</span>(rf.logs, tlog)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置返回值</span></span><br><span class="line">index = <span class="built_in">len</span>(rf.logs)</span><br><span class="line">isLeader = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">        </span><br><span class="line">PrettyDebug(dInfo, <span class="string">&quot;S%d:%d[Start-After]&quot;</span>, rf.me, rf.logs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播心跳消息，通知其他服务器更新日志</span></span><br><span class="line">rf.BroadcastHeartbeat() <span class="comment">// 之后看看怎么加</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果当前服务器不是领导者，则返回 false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Start false2&quot;</span>)</span><br><span class="line">isLeader = <span class="literal">false</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> index, term, isLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理清一下逻辑：</p><blockquote><p><strong>1.初始化</strong></p></blockquote><p>对于初始化的话的操作，对于lab2a没太大的差别。主要在于多了初始化日志下标数组。</p><blockquote><p><strong>2.go rf.ticker()</strong></p></blockquote><p>这部分代码和lab2a没太大的差别，直接复用</p><blockquote><p><strong>3.选举超时的处理</strong></p></blockquote><p>改变自身状态，从跟随者变成候选者。之后开始请求投票。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有除了自己以外的sever的请求投票</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">Len_Peers := <span class="built_in">len</span>(rf.peers)</span><br><span class="line">numID := rf.me</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; Len_Peers; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == numID &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 首先先对服务器上锁</span></span><br><span class="line"><span class="comment">// rf.mu.Lock()</span></span><br><span class="line"><span class="comment">// defer rf.mu.Unlock()</span></span><br><span class="line"><span class="comment">// 定义rpc参数</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">args := RequestVoteArgs&#123;&#125;</span><br><span class="line">args.Term = rf.currentTerm</span><br><span class="line">args.CandidateId = rf.me</span><br><span class="line">args.LastLogIndex = <span class="built_in">len</span>(rf.logs)</span><br><span class="line">args.LastLogTerm = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">args.LastLogTerm = rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply := RequestVoteReply&#123;&#125;</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送rpc请求</span></span><br><span class="line"><span class="comment">// 处理请求服务器返回的结果</span></span><br><span class="line"><span class="comment">// PrettyDebug(dInfo, &quot;S%d-term:%d-state:%d =&gt; %d[RPC-Vote]&quot;, rf.me, rf.currentTerm, rf.state, peer)</span></span><br><span class="line"><span class="keyword">if</span> rf.sendRequestVote(peer, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="comment">// PrettyDebug(dInfo, &quot;S%d-term:%d-state:%d =&gt; %d[RPC-Vote-Over]&quot;, rf.me, rf.currentTerm, rf.state, peer)</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// 任期号</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm == args.Term &amp;&amp; rf.state == StateCandidate &#123;</span><br><span class="line"><span class="comment">// 计算投票数量</span></span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">PrettyDebug(dTimer, <span class="string">&quot;S%dVote&lt;--%d[Vote]&quot;</span>, rf.me, peer)</span><br><span class="line">rf.voteGrantedNum++</span><br><span class="line"><span class="keyword">if</span> rf.voteGrantedNum &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">PrettyDebug(dInfo, <span class="string">&quot;S%d:state:%d-changeTo-state:%d[BecomeLeader]&quot;</span>, rf.me, rf.state, StateLeader)</span><br><span class="line"><span class="comment">// 当选leader</span></span><br><span class="line">rf.state = StateLeader</span><br><span class="line"><span class="comment">// 初始化nextIndex和matchIndex数组</span></span><br><span class="line"><span class="comment">// rf.nextIndex = make([]int, len(rf.peers))</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = <span class="built_in">len</span>(rf.logs) + <span class="number">1</span></span><br><span class="line">rf.matchIndex[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PrettyDebug(dLeader, &quot;S%d-term:%d-state:%d[BecomeLeader]&quot;, rf.me, rf.currentTerm, rf.state)</span></span><br><span class="line"><span class="comment">// rf.heartbeatTimer.Reset(StableHeartbeatTimeout())</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// 发送心跳给各个server</span></span><br><span class="line">rf.BroadcastHeartbeat() <span class="comment">// with lock</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &lt; reply.Term &#123;</span><br><span class="line"><span class="comment">// PrettyDebug(dError, &quot;S%d[VoteFail1]&quot;, rf.me)</span></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.voteFor = <span class="number">-1</span></span><br><span class="line">rf.voteGrantedNum = <span class="number">0</span></span><br><span class="line"><span class="comment">// PrettyDebug(dInfo, &quot;S%d:state:%d:term:%d-changeTo-state:%d:term:%d[BecomeLeader]&quot;, rf.me, rf.state, rf.currentTerm, StateFollower, reply.Term)</span></span><br><span class="line">rf.state = StateFollower</span><br><span class="line">rf.electionTimeout.Reset(RandomizedElectionTimeout())</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendRequestVote函数简单来说就是在原先投票的基础上加上日志索引的判断。</p><blockquote><p><strong>广播心跳</strong></p></blockquote><p>两种情况下会广播心跳，leader不断发送心跳包维护，成为leader的时候发送，让其他节点知道谁是Leader。</p><p>这里给出代码逻辑，实现的话自行根据逻辑实现。</p><p><strong>BroadcastHeartbeat函数逻辑</strong></p><p><strong>1.发送心跳或日志同步的准备</strong></p><ul><li>该函数是 Raft 领导者（Leader）向其他节点发送心跳或日志同步请求的逻辑。在 Raft 中，领导者需要定期向跟随者（Follower）发送心跳维持领导地位，并同步日志。</li><li>在函数开始时，打印调试信息，标识当前领导者的任期、节点 ID 和状态。</li></ul><p><strong>2. 遍历所有的跟随者</strong></p><ul><li>通过遍历集群中的所有节点（除了自己），向每个节点发送心跳或日志条目。</li><li>对每个节点，构造 AppendEntriesArgs请求参数，这个参数包括：<ul><li>当前领导者的任期 (<code>Term</code>)。</li><li>当前领导者的 ID (<code>LeaderId</code>)。</li><li>当前已提交的日志索引 (<code>LeaderCommit</code>)。</li><li>上一个日志条目的索引 (<code>PrevLogIndex</code>) 和任期 (<code>PrevLogTerm</code>)，用于日志一致性检查。</li><li>如果有新的日志条目需要同步，包含需要发送的日志条目 (<code>Entries</code>)，如果没有则 <code>Entries</code> 为空。</li></ul></li></ul><p><strong>3. 日志索引的设置</strong></p><ul><li><code>PrevLogIndex</code> 和 <code>PrevLogTerm</code> 【在代码层面是PRC的参数，是由nextIdx和matchIdx设置值的】是 Raft 中日志一致性检查的关键。它们指示领导者要发送的日志条目的前一个条目的索引和任期，确保跟随者的日志与领导者一致。</li><li>如果跟随者的日志落后，领导者会根据 <code>nextIndex</code> 确定从哪一条日志开始同步。</li><li>如果 <code>nextIndex</code> 指定的日志条目存在，领导者将从该索引开始同步日志条目。</li></ul><p><strong>4. 并发发送心跳和日志同步请求</strong></p><ul><li>使用 Goroutine 并发地向每个跟随者发送 <code>AppendEntries</code> 请求，减少等待时间，提高效率。</li><li>发送请求后，等待跟随者的响应，并处理不同的响应结果。</li></ul><p><strong>5. 处理响应结果</strong></p><ul><li>如果发送成功，领导者会根据跟随者的响应进行相应的处理：<ul><li><strong>日志不同步</strong>：如果跟随者的日志不同步（日志冲突），会根据返回的索引调整 <code>nextIndex</code>，从而重新发送早期的日志条目。</li><li><strong>日志复制成功</strong>：如果日志复制成功，更新 <code>nextIndex</code> 和 <code>matchIndex</code>，表示该跟随者已经同步到的最新日志条目。</li><li><strong>任期过期</strong>：如果领导者发现跟随者的任期比自己高，则降级为跟随者（<code>Follower</code>）状态，放弃领导地位。</li></ul></li></ul><p><strong>6. 提交日志</strong></p><ul><li>在成功复制日志后，领导者会检查是否有新的日志条目可以提交。</li><li>通过遍历 <code>matchIndex</code>，领导者检查是否有某个日志条目已经被大多数节点复制（超过半数）。</li><li>如果某个日志条目已经被大多数节点复制，并且该日志条目是当前任期的日志，领导者将其提交，并更新 <code>commitIndex</code>。</li><li>将提交的日志条目应用到状态机，并通过 <code>applyChan</code> 通知状态机执行相应的命令。</li></ul><p><strong>7. 日志应用到状态机</strong></p><ul><li>提交的日志条目会被封装成 <code>ApplyMsg</code>，通过通道 <code>applyChan</code> 传递给状态机。</li><li>领导者不断更新 <code>lastApplied</code>，确保每个已提交的日志条目都被按顺序应用。</li></ul><p><strong>AppendEntries函数逻辑</strong></p><ol><li><strong>基本检查</strong></li></ol><ul><li>开始时，获取锁以确保对 <code>rf</code> 对象的安全访问（避免并发冲突）。</li><li>检查当前节点是否被杀死（<code>rf.killed()</code>）。如果是，直接返回失败状态并标记为已终止（<code>Killed</code>）。</li></ul><ol start="2"><li><strong>任期检查</strong></li></ol><ul><li>如果领导者的任期（<code>args.Term</code>）小于当前节点的任期（<code>rf.currentTerm</code>），则拒绝该请求，返回当前节点的任期，并设置响应状态为过期（<code>OutData</code>）。</li><li>如果领导者的任期比当前节点高，更新当前节点的任期为领导者的任期，并将当前节点状态切换为跟随者（<code>Follower</code>）。</li></ul><ol start="3"><li><strong>日志一致性检查</strong></li></ol><ul><li>检查日志的一致性：<ul><li>如果领导者发送的 <code>PrevLogIndex</code> 大于当前节点的日志长度，或者 <code>PrevLogTerm</code> 与当前节点日志的对应位置不匹配，说明日志存在冲突。此时，返回失败状态（<code>FailMatch</code>），并告知领导者下次可以同步的日志索引（<code>UpNextIndex</code>）。</li><li>如果当前节点的已提交索引（<code>lastApplied</code>）比领导者的 <code>PrevLogIndex</code> 更高，说明当前节点的日志已经超前，返回失败状态（<code>AppCommitted</code>），并告知领导者应从哪个索引重新同步。</li></ul></li></ul><ol start="4"><li><strong>日志追加</strong></li></ol><ul><li>如果领导者有新的日志条目需要同步（args.Entries不为空）：<ul><li>当前节点将裁剪掉从 <code>PrevLogIndex</code> 之后的所有日志（如果有日志冲突）。</li><li>然后，追加领导者发送的日志条目到当前节点的日志中。</li></ul></li></ul><ol start="5"><li><strong>日志提交</strong></li></ol><ul><li>当前节点会根据领导者的LeaderCommit更新自己的commitIndex：<ul><li>如果领导者已经提交的日志比当前节点多，逐条提交日志，直到达到领导者的 <code>LeaderCommit</code>。</li><li>每次提交日志时，将日志条目封装成 <code>ApplyMsg</code>，通过 <code>applyChan</code> 传递给状态机进行应用。</li></ul></li></ul><ol start="6"><li><strong>更新状态</strong></li></ol><ul><li>将当前节点的状态设置为 <code>Follower</code>，并重置选举超时（<code>electionTimeout.Reset</code>），确保节点不会立即发起新的选举。</li><li>最后，返回成功的响应，指示日志追加成功，并告知领导者下次可以从哪个索引继续同步（<code>UpNextIndex</code>）。</li></ul><h2 id="测试调试">测试调试</h2><p><strong>测试样例</strong></p><ul><li><p><strong>TestBasicAgree2B</strong>：最基础的追加日志测试。先使用nCommitted()检查有多少的server认为日志已经提交（在执行Start()函数之前，所有的服务器都不应该提交日志），若满足条件则调用cfg.one()，其通过调用rf.Start(cmd)来追加日志。rf.Start(cmd)用于模拟Raft实例从Client接收实例的情况。</p></li><li><p><strong>TestRPCBytes2B</strong>：基于RPC的字节数检查保证每个cmd都只对每个peer发送一次。OR。校验RPC发送的字节数,确保每个log只对peer发送一次,发送10条log,校验log command字节总数与抓包捕获的字节总数是否一致.</p></li><li><p><strong>For2023TestFollowerFailure2B</strong>：校验Follow丢失连接之后是否正常工作</p></li><li><p><strong>For2023TestLeaderFailure2B</strong>：校验Leader丢失连接之后是否正常工作</p><ul><li>发送一条log</li><li>断开leader连接,剩下两个peer选出一个leader,再发送两条log</li><li>断开leader连接,现在客户端只能连接一个peer</li><li>遍历peer调用start() 测试是否有peer提交了日志</li></ul></li><li><p>（G - √）<strong>TestFailAgree2B</strong>：断连小部分，不影响整体Raft集群的情况检测追加日志。</p></li><li><p>（G - √）<strong>TestFailNoAgree2B</strong>：断连过半数节点，保证无日志可以正常追加。然后又重新恢复节点，检测追加日志情况。</p></li><li><p><strong>TestConcurrentStarts2B</strong>：模拟客户端并发发送多个命令</p></li><li><p>（g）<strong>TestRejoin2B</strong>：Leader 1断连，再让旧leader 1接受日志，再给新Leader 2发送日志，2断连，再重连旧Leader 1，提交日志，再让2重连，再提交日志。</p></li><li><p>（G）<strong>TestBackup2B</strong>：先给Leader 1发送日志，然后断连3个Follower（总共1Ledaer 4Follower），网络分区。提交大量命令给1。然后让leader 1和其Follower下线，之前的3个Follower上线，向它们发送日志。然后在对剩下的仅有3个节点的Raft集群重复上面网络分区的过程。</p></li><li><p><strong>TestCount2B</strong>：检查无效的RPC个数，不能过多。</p></li></ul><p>整体代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBasicAgree2B</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">servers := <span class="number">3</span></span><br><span class="line">cfg := make_config(t, servers, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">defer</span> cfg.cleanup()</span><br><span class="line">cfg.begin(<span class="string">&quot;Test (2B): basic agreement&quot;</span>)</span><br><span class="line">iters := <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">1</span>; index &lt; iters+<span class="number">1</span>; index++ &#123;</span><br><span class="line">nd, _ := cfg.nCommitted(index)</span><br><span class="line"><span class="keyword">if</span> nd &gt; <span class="number">0</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;some have committed before Start()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">xindex := cfg.one(index*<span class="number">100</span>, servers, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> xindex != index &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;got index %v but expected %v&quot;</span>, xindex, index)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cfg.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议自己根据代码进行分析</p><ol><li>配置初始化【make_config】</li><li>有多少服务器认为一条log已经提交【nCommitted】</li><li>找到leader，调用start()方法提交命令，如果当前server不是leader，则更换目标重新提交提交成功后，等待一段时间，检查cmd是否真的提交成功【one】</li></ol><blockquote><p><strong>TestFailAgree2B测试样例分析</strong></p></blockquote><p>分析下列程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFailNoAgree2B</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">servers := <span class="number">5</span></span><br><span class="line">cfg := make_config(t, servers, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">defer</span> cfg.cleanup()</span><br><span class="line">cfg.begin(<span class="string">&quot;Test (2B): no agreement if too many followers disconnect&quot;</span>)</span><br><span class="line">cfg.one(<span class="number">10</span>, servers, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 3 of 5 followers disconnect</span></span><br><span class="line">leader := cfg.checkOneLeader()</span><br><span class="line">cfg.disconnect((leader + <span class="number">1</span>) % servers)</span><br><span class="line">cfg.disconnect((leader + <span class="number">2</span>) % servers)</span><br><span class="line">cfg.disconnect((leader + <span class="number">3</span>) % servers)</span><br><span class="line">index, _, ok := cfg.rafts[leader].Start(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> ok != <span class="literal">true</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;leader rejected Start()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> index != <span class="number">2</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;expected index 2, got %v&quot;</span>, index)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">2</span> * RaftElectionTimeout)</span><br><span class="line">n, _ := cfg.nCommitted(index)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;%v committed but no majority&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// repair</span></span><br><span class="line">cfg.connect((leader + <span class="number">1</span>) % servers)</span><br><span class="line">cfg.connect((leader + <span class="number">2</span>) % servers)</span><br><span class="line">cfg.connect((leader + <span class="number">3</span>) % servers)</span><br><span class="line"><span class="comment">// the disconnected majority may have chosen a leader from</span></span><br><span class="line"><span class="comment">// among their own ranks, forgetting index 2.</span></span><br><span class="line">leader2 := cfg.checkOneLeader()</span><br><span class="line">index2, _, ok2 := cfg.rafts[leader2].Start(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">if</span> ok2 == <span class="literal">false</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;leader2 rejected Start()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> index2 &lt; <span class="number">2</span> || index2 &gt; <span class="number">3</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;unexpected index %v&quot;</span>, index2)</span><br><span class="line">&#125;</span><br><span class="line">cfg.one(<span class="number">1000</span>, servers, <span class="literal">true</span>)</span><br><span class="line">cfg.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">5个peers,断连3个后重连,测试是否正常</span><br><span class="line"></span><br><span class="line">TERM 1: 5个peer都写入 msg 10</span><br><span class="line"></span><br><span class="line">S2 S3 S4 断线 超时</span><br><span class="line"></span><br><span class="line">S1 写入 msg 20 index 2</span><br><span class="line"></span><br><span class="line">转TERM 2 开始选举 恢复连接</span><br><span class="line"></span><br><span class="line">S3 成为 TERM 3的 leader</span><br><span class="line"></span><br><span class="line">写入msg 30 msg 1000</span><br><span class="line"></span><br><span class="line">这时候S1的<span class="built_in">log</span> index=2 为msg20,prelog 1 的index和term都匹配,直接把msg 30 1000插入了,应该要把msg20删除的</span><br></pre></td></tr></table></figure><p>分析程序发现判断符号写错了</p><blockquote><p><strong>TestRejoin2B测试程序分析</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRejoin2B</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">servers := <span class="number">3</span></span><br><span class="line">cfg := make_config(t, servers, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">defer</span> cfg.cleanup()</span><br><span class="line"></span><br><span class="line">cfg.begin(<span class="string">&quot;Test (2B): rejoin of partitioned leader&quot;</span>)</span><br><span class="line"></span><br><span class="line">cfg.one(<span class="number">101</span>, servers, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// leader network failure</span></span><br><span class="line">leader1 := cfg.checkOneLeader()</span><br><span class="line">cfg.disconnect(leader1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// make old leader try to agree on some entries</span></span><br><span class="line">cfg.rafts[leader1].Start(<span class="number">102</span>)</span><br><span class="line">cfg.rafts[leader1].Start(<span class="number">103</span>)</span><br><span class="line">cfg.rafts[leader1].Start(<span class="number">104</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new leader commits, also for index=2</span></span><br><span class="line">cfg.one(<span class="number">103</span>, <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new leader network failure</span></span><br><span class="line">leader2 := cfg.checkOneLeader()</span><br><span class="line">cfg.disconnect(leader2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// old leader connected again</span></span><br><span class="line">cfg.connect(leader1)</span><br><span class="line"></span><br><span class="line">cfg.one(<span class="number">104</span>, <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// all together now</span></span><br><span class="line">cfg.connect(leader2)</span><br><span class="line"></span><br><span class="line">cfg.one(<span class="number">105</span>, servers, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">cfg.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>写入msg 101 leader1断开连接</li><li>leader1写入102 103 104</li><li>leader2写入103 然后断开连接</li><li>leader1重连</li><li>请求写入104</li><li>eader2重连</li><li>写入105</li></ol><p>报错这个错误</p><p><code>outlog.log</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">Test (2B): rejoin of partitioned leader ...</span><br><span class="line">002647 INFO S0term:1=state:1=[StartElect]</span><br><span class="line">002648 INFO S0-term:1-state:1 =&gt; 2[RPC-Vote]</span><br><span class="line">002648 INFO S0-term:1-state:1 =&gt; 1[RPC-Vote]</span><br><span class="line">002650 INFO S2:term:0 ==&gt; S0-term:1[Enter-RequestVote]</span><br><span class="line">002650 INFO S2 ==&gt; S0-term:1[RequestVote]</span><br><span class="line">002650 INFO S2:state:0:term:0-changeTo-state:0:term:1[RequestVote1]</span><br><span class="line">002650 INFO S2:state:0-changeTo-state:0[RequestVote2]</span><br><span class="line">002650 INFO S0-term:1-state:1 =&gt; 2[RPC-Vote-Over]</span><br><span class="line">002651 TIMR S0Vote&lt;--2[Vote]</span><br><span class="line">002651 INFO S0:state:1-changeTo-state:2[BecomeLeader]</span><br><span class="line">002651 LEAD S0-term:1-state:2[BecomeLeader]</span><br><span class="line">002651 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">002652 INFO S1:term:0 ==&gt; S0-term:1[Enter-RequestVote]</span><br><span class="line">002652 INFO S1 ==&gt; S0-term:1[RequestVote]</span><br><span class="line">002652 INFO S1:state:0:term:0-changeTo-state:0:term:1[RequestVote1]</span><br><span class="line">002652 INFO S1:state:0-changeTo-state:0[RequestVote2]</span><br><span class="line">002652 INFO S0-term:1-state:2 =&gt; 1[RPC-Vote-Over]</span><br><span class="line">003024 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">003048 INFO S0term[ReceiveLog]</span><br><span class="line">003048 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">003051 INFO S2:state:0:term:1-ReceiveFrom-S0[AppendEntries]</span><br><span class="line">003052 INFO S0[Heartbeat]</span><br><span class="line">cnt,len(rf.peers) 2 3</span><br><span class="line">003052 INFO S1:state:0:term:1-ReceiveFrom-S0[AppendEntries]</span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">004530 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">cmdi,ok: 101 <span class="literal">true</span></span><br><span class="line">006039 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">007542 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">009051 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">Pass==checkOneLeader()</span><br><span class="line">009483 INFO S0term[ReceiveLog]</span><br><span class="line">009483 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">009483 INFO S0term[ReceiveLog]</span><br><span class="line">009483 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">009483 INFO S0term[ReceiveLog]</span><br><span class="line">009483 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">010555 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">011512 INFO S2term:2=state:1=[StartElect]</span><br><span class="line">011512 INFO S2-term:2-state:1 =&gt; 1[RPC-Vote]</span><br><span class="line">011513 INFO S2-term:2-state:1 =&gt; 0[RPC-Vote]</span><br><span class="line">011514 INFO S1:term:1 ==&gt; S2-term:2[Enter-RequestVote]</span><br><span class="line">011514 INFO S1 ==&gt; S2-term:2[RequestVote]</span><br><span class="line">011514 INFO S1:state:0:term:1-changeTo-state:0:term:2[RequestVote1]</span><br><span class="line">011514 INFO S1:state:0-changeTo-state:0[RequestVote2]</span><br><span class="line">011514 INFO S2-term:2-state:1 =&gt; 1[RPC-Vote-Over]</span><br><span class="line">011514 TIMR S2Vote&lt;--1[Vote]</span><br><span class="line">011514 INFO S2:state:1-changeTo-state:2[BecomeLeader]</span><br><span class="line">011514 LEAD S2-term:2-state:2[BecomeLeader]</span><br><span class="line">011514 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">011675 INFO S2term[ReceiveLog]</span><br><span class="line">011676 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">011677 INFO S1:state:0:term:2-ReceiveFrom-S2[AppendEntries]</span><br><span class="line">011678 INFO S2[Heartbeat]</span><br><span class="line">cnt,len(rf.peers) 2 3</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 103 <span class="literal">true</span></span><br><span class="line">012058 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">012058 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: 103 <span class="literal">true</span></span><br><span class="line">cmdi,ok: 103 <span class="literal">true</span></span><br><span class="line">013566 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">013567 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">015074 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">015074 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">Pass==checkOneLeader()</span><br><span class="line">016924 INFO S0term[ReceiveLog]</span><br><span class="line">016925 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">016926 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">016926 LEAD S0-term:1-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">016929 INFO S1:state:0:term:2-ReceiveFrom-S0[AppendEntries]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">018429 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">019936 LEAD S2-term:2-state:2[BeginHeart]</span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">cmdi,ok: &lt;nil&gt; <span class="literal">false</span></span><br><span class="line">020620 INFO S1term:3=state:1=[StartElect]</span><br><span class="line">020621 INFO S1-term:3-state:1 =&gt; 2[RPC-Vote]</span><br><span class="line">020622 INFO S1-term:3-state:1 =&gt; 0[RPC-Vote]</span><br><span class="line">020624 INFO S0:term:2 ==&gt; S1-term:3[Enter-RequestVote]</span><br><span class="line">020624 INFO S0 ==&gt; S1-term:3[RequestVote]</span><br><span class="line">020624 INFO S0:state:0:term:2-changeTo-state:0:term:3[RequestVote1]</span><br><span class="line">020624 INFO S0:state:0-changeTo-state:0[RequestVote2]</span><br><span class="line">020624 INFO S1-term:3-state:1 =&gt; 0[RPC-Vote-Over]</span><br><span class="line">020624 TIMR S1Vote&lt;--0[Vote]</span><br><span class="line">020624 INFO S1:state:1-changeTo-state:2[BecomeLeader]</span><br><span class="line">020624 LEAD S1-term:3-state:2[BecomeLeader]</span><br><span class="line">020624 LEAD S1-term:3-state:2[BeginHeart]</span><br><span class="line">0: <span class="built_in">log</span> map[1:101]; server map[1:101 2:103]</span><br><span class="line">0: <span class="built_in">log</span> map[1:101]; server map[1:101 2:103]</span><br><span class="line">apply error: commit index=2 server=0 102 != server=2 103</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL6.824/raft2.064s</span><br></pre></td></tr></table></figure><blockquote><p><strong>TestBackup2B测试程序</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBackup2B</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">servers := <span class="number">5</span></span><br><span class="line">cfg := make_config(t, servers, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">defer</span> cfg.cleanup()</span><br><span class="line"></span><br><span class="line">cfg.begin(<span class="string">&quot;Test (2B): leader backs up quickly over incorrect follower logs&quot;</span>)</span><br><span class="line"></span><br><span class="line">cfg.one(rand.Int(), servers, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// put leader and one follower in a partition</span></span><br><span class="line">leader1 := cfg.checkOneLeader()</span><br><span class="line">cfg.disconnect((leader1 + <span class="number">2</span>) % servers)</span><br><span class="line">cfg.disconnect((leader1 + <span class="number">3</span>) % servers)</span><br><span class="line">cfg.disconnect((leader1 + <span class="number">4</span>) % servers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit lots of commands that won&#x27;t commit</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">cfg.rafts[leader1].Start(rand.Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(RaftElectionTimeout / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cfg.disconnect((leader1 + <span class="number">0</span>) % servers)</span><br><span class="line">cfg.disconnect((leader1 + <span class="number">1</span>) % servers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow other partition to recover</span></span><br><span class="line">cfg.connect((leader1 + <span class="number">2</span>) % servers)</span><br><span class="line">cfg.connect((leader1 + <span class="number">3</span>) % servers)</span><br><span class="line">cfg.connect((leader1 + <span class="number">4</span>) % servers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lots of successful commands to new group.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">cfg.one(rand.Int(), <span class="number">3</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now another partitioned leader and one follower</span></span><br><span class="line">leader2 := cfg.checkOneLeader()</span><br><span class="line">other := (leader1 + <span class="number">2</span>) % servers</span><br><span class="line"><span class="keyword">if</span> leader2 == other &#123;</span><br><span class="line">other = (leader2 + <span class="number">1</span>) % servers</span><br><span class="line">&#125;</span><br><span class="line">cfg.disconnect(other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lots more commands that won&#x27;t commit</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">cfg.rafts[leader2].Start(rand.Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(RaftElectionTimeout / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bring original leader back to life,</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; servers; i++ &#123;</span><br><span class="line">cfg.disconnect(i)</span><br><span class="line">&#125;</span><br><span class="line">cfg.connect((leader1 + <span class="number">0</span>) % servers)</span><br><span class="line">cfg.connect((leader1 + <span class="number">1</span>) % servers)</span><br><span class="line">cfg.connect(other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lots of successful commands to new group.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">cfg.one(rand.Int(), <span class="number">3</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now everyone</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; servers; i++ &#123;</span><br><span class="line">cfg.connect(i)</span><br><span class="line">&#125;</span><br><span class="line">cfg.one(rand.Int(), servers, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">cfg.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error_Log</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br></pre></td><td class="code"><pre><span class="line">Test (<span class="number">2</span>B): leader backs up quickly over incorrect follower logs ...</span><br><span class="line"><span class="number">003590</span> INFO S1term:<span class="number">1</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">003592</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">003592</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">003594</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">003608</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">003611</span> INFO S2:term:<span class="number">0</span> ==&gt; S1-term:<span class="number">1</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">003612</span> INFO S2 ==&gt; S1-term:<span class="number">1</span>[RequestVote]</span><br><span class="line"><span class="number">003612</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">0</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">1</span>[RequestVote1]</span><br><span class="line"><span class="number">003612</span> INFO S2:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">003612</span> INFO S0:term:<span class="number">0</span> ==&gt; S1-term:<span class="number">1</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">003612</span> INFO S0 ==&gt; S1-term:<span class="number">1</span>[RequestVote]</span><br><span class="line"><span class="number">003612</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">0</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">1</span>[RequestVote1]</span><br><span class="line"><span class="number">003612</span> INFO S0:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">003613</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">003613</span> TIMR S1Vote&lt;-<span class="number">-0</span>[Vote]</span><br><span class="line"><span class="number">003613</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">003613</span> TIMR S1Vote&lt;-<span class="number">-2</span>[Vote]</span><br><span class="line"><span class="number">003613</span> INFO S1:state:<span class="number">1</span>-changeTo-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">003613</span> INFO S3:term:<span class="number">0</span> ==&gt; S1-term:<span class="number">1</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">003613</span> INFO S3 ==&gt; S1-term:<span class="number">1</span>[RequestVote]</span><br><span class="line"><span class="number">003613</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">0</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">1</span>[RequestVote1]</span><br><span class="line"><span class="number">003613</span> INFO S3:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">003614</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">2</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">003613</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">003614</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">003612</span> INFO S4:term:<span class="number">0</span> ==&gt; S1-term:<span class="number">1</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">003616</span> INFO S4 ==&gt; S1-term:<span class="number">1</span>[RequestVote]</span><br><span class="line"><span class="number">003616</span> INFO S4:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">003617</span> INFO S1-term:<span class="number">1</span>-state:<span class="number">2</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">004110</span> INFO S1command1[ReceiveLog]</span><br><span class="line"><span class="number">004110</span> INFO S1:[][Start-Before]</span><br><span class="line"><span class="number">004110</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Start-After]</span><br><span class="line"><span class="number">004111</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">004113</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">1</span>-ReceiveFrom-S1[AppendEntries]</span><br><span class="line"><span class="number">004113</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">1</span>-ReceiveFrom-S1[AppendEntries]</span><br><span class="line"><span class="number">004113</span> INFO S4:term:[][Add-Before]</span><br><span class="line"><span class="number">004113</span> INFO S4FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Adding]</span><br><span class="line"><span class="number">004113</span> INFO S4FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-After]</span><br><span class="line"><span class="number">004113</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">1</span>-ReceiveFrom-S1[AppendEntries]</span><br><span class="line"><span class="number">004113</span> INFO S0:term:[][Add-Before]</span><br><span class="line"><span class="number">004113</span> INFO S0FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Adding]</span><br><span class="line"><span class="number">004113</span> INFO S0FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-After]</span><br><span class="line"><span class="number">004113</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">1</span>-ReceiveFrom-S1[AppendEntries]</span><br><span class="line"><span class="number">004114</span> INFO S2:term:[][Add-Before]</span><br><span class="line"><span class="number">004114</span> INFO S2FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Adding]</span><br><span class="line"><span class="number">004114</span> INFO S2FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-After]</span><br><span class="line"><span class="number">004114</span> INFO S1[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">004113</span> INFO S3:term:[][Add-Before]</span><br><span class="line"><span class="number">004114</span> INFO S3FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Adding]</span><br><span class="line"><span class="number">004114</span> INFO S3FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-After]</span><br><span class="line"><span class="number">004524</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass1</span><br><span class="line"><span class="number">006030</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">007537</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">009045</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">Pass==checkOneLeader()</span><br><span class="line">leader1: <span class="number">1</span></span><br><span class="line">[TestBackup2B]==pass2</span><br><span class="line"><span class="number">009661</span> INFO S1command2[ReceiveLog]</span><br><span class="line"><span class="number">009662</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">009662</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125;][Start-After]</span><br><span class="line"><span class="number">009662</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">009662</span> INFO S1command3[ReceiveLog]</span><br><span class="line"><span class="number">009662</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">009662</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">3</span> <span class="number">1</span> <span class="number">3</span>&#125;][Start-After]</span><br><span class="line"><span class="number">009662</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass3</span><br><span class="line"><span class="number">009664</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">1</span>-ReceiveFrom-S1[AppendEntries]</span><br><span class="line"><span class="number">009664</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">009664</span> INFO S2FromS1:[&#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125;][Adding]</span><br><span class="line"><span class="number">009664</span> INFO S2FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125;][Add-After]</span><br><span class="line"><span class="number">009664</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">1</span>-ReceiveFrom-S1[AppendEntries]</span><br><span class="line"><span class="number">009664</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">009664</span> INFO S2FromS1:[&#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">3</span> <span class="number">1</span> <span class="number">3</span>&#125;][Adding]</span><br><span class="line"><span class="number">009664</span> INFO S2FromS1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">3</span> <span class="number">1</span> <span class="number">3</span>&#125;][Add-After]</span><br><span class="line"><span class="number">010557</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">011250</span> INFO S3term:<span class="number">2</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">011250</span> INFO S3-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">011251</span> INFO S3-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">011251</span> INFO S3-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">011251</span> INFO S3-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">012070</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">012669</span> INFO S4term:<span class="number">2</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">012671</span> INFO S4-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">012671</span> INFO S4-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">012672</span> INFO S4-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">012673</span> INFO S4-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">013574</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass4</span><br><span class="line"><span class="number">014850</span> INFO S0term:<span class="number">2</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">014850</span> INFO S0-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">014851</span> INFO S0-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">014851</span> INFO S4:term:<span class="number">2</span> ==&gt; S0-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">014851</span> INFO S4 ==&gt; S0-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">014851</span> INFO S4:state:<span class="number">1</span>:term:<span class="number">2</span>-requestOther[RequestVote2]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">2</span>)</span><br><span class="line"><span class="number">014851</span> INFO S0-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">014852</span> INFO S0-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">014852</span> INFO S0-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">014853</span> INFO S3:term:<span class="number">2</span> ==&gt; S0-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">014853</span> INFO S3 ==&gt; S0-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">014853</span> INFO S3:state:<span class="number">1</span>:term:<span class="number">2</span>-requestOther[RequestVote2]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">2</span>)</span><br><span class="line"><span class="number">014853</span> INFO S0-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">015077</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">016561</span> INFO S3term:<span class="number">3</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">016561</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">016562</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">016562</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">016562</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">016562</span> INFO S0:term:<span class="number">2</span> ==&gt; S3-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">016562</span> INFO S0 ==&gt; S3-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">016563</span> INFO S0:state:<span class="number">1</span>:term:<span class="number">2</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">3</span>[RequestVote1]</span><br><span class="line"><span class="number">016563</span> INFO S0:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">016563</span> INFO S4:term:<span class="number">2</span> ==&gt; S3-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">016563</span> INFO S4 ==&gt; S3-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">016563</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">016563</span> INFO S4:state:<span class="number">1</span>:term:<span class="number">2</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">3</span>[RequestVote1]</span><br><span class="line"><span class="number">016563</span> TIMR S3Vote&lt;-<span class="number">-0</span>[Vote]</span><br><span class="line"><span class="number">016563</span> INFO S4:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">016563</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">016563</span> TIMR S3Vote&lt;-<span class="number">-4</span>[Vote]</span><br><span class="line"><span class="number">016563</span> INFO S3:state:<span class="number">1</span>-changeTo-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">016563</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">016563</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">016588</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">016589</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">016815</span> INFO S3command4[ReceiveLog]</span><br><span class="line"><span class="number">016815</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">016815</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Start-After]</span><br><span class="line"><span class="number">016815</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">016817</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">3</span>-ReceiveFrom-S3[AppendEntries]</span><br><span class="line"><span class="number">016817</span> INFO S4:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">016817</span> INFO S4FromS3:[&#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Adding]</span><br><span class="line"><span class="number">016817</span> INFO S4FromS3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Add-After]</span><br><span class="line"><span class="number">016817</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">3</span>-ReceiveFrom-S3[AppendEntries]</span><br><span class="line"><span class="number">016817</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">016817</span> INFO S0FromS3:[&#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Adding]</span><br><span class="line"><span class="number">016817</span> INFO S0FromS3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Add-After]</span><br><span class="line"><span class="number">016818</span> INFO S3[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">018025</span> INFO S2term:<span class="number">2</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">018030</span> INFO S2-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">018031</span> INFO S2-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">018032</span> INFO S2-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">018032</span> INFO S2-term:<span class="number">2</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">018106</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">018106</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">018234</span> INFO S3command5[ReceiveLog]</span><br><span class="line"><span class="number">018234</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">018235</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Start-After]</span><br><span class="line"><span class="number">018235</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">018237</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">3</span>-ReceiveFrom-S3[AppendEntries]</span><br><span class="line"><span class="number">018237</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">018237</span> INFO S0FromS3:[&#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Adding]</span><br><span class="line"><span class="number">018237</span> INFO S0FromS3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-After]</span><br><span class="line"><span class="number">018237</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">3</span>-ReceiveFrom-S3[AppendEntries]</span><br><span class="line"><span class="number">018237</span> INFO S4:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">018237</span> INFO S4FromS3:[&#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Adding]</span><br><span class="line"><span class="number">018237</span> INFO S4FromS3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-After]</span><br><span class="line"><span class="number">018238</span> INFO S3[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">019618</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">019618</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass6</span><br><span class="line"><span class="number">020674</span> INFO S0:term:<span class="number">3</span> ==&gt; S3-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">020675</span> INFO S0 ==&gt; S3-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">020678</span> INFO S3-term:<span class="number">3</span>-state:<span class="number">2</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">020796</span> INFO S2term:<span class="number">3</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">020805</span> INFO S2-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">020809</span> INFO S2-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">020811</span> INFO S2-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">020811</span> INFO S2-term:<span class="number">3</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">021126</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">021126</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">022630</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">022632</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">024076</span> INFO S2term:<span class="number">4</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">024077</span> INFO S2-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">024078</span> INFO S2-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">024078</span> INFO S2-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">024078</span> INFO S2-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">024141</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">024145</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">Pass==checkOneLeader()</span><br><span class="line">leader2: <span class="number">3</span></span><br><span class="line">other: <span class="number">4</span></span><br><span class="line">[TestBackup2B]==pass7</span><br><span class="line"><span class="number">024386</span> INFO S3command6[ReceiveLog]</span><br><span class="line"><span class="number">024386</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">024386</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125;][Start-After]</span><br><span class="line"><span class="number">024386</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">024386</span> INFO S3command7[ReceiveLog]</span><br><span class="line"><span class="number">024386</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">024386</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">7</span>&#125;][Start-After]</span><br><span class="line"><span class="number">024387</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass8</span><br><span class="line"><span class="number">024389</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">3</span>-ReceiveFrom-S3[AppendEntries]</span><br><span class="line"><span class="number">024389</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">024389</span> INFO S0FromS3:[&#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125;][Adding]</span><br><span class="line"><span class="number">024389</span> INFO S0FromS3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125;][Add-After]</span><br><span class="line"><span class="number">024390</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">3</span>-ReceiveFrom-S3[AppendEntries]</span><br><span class="line"><span class="number">024390</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">024390</span> INFO S0FromS3:[&#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">7</span>&#125;][Adding]</span><br><span class="line"><span class="number">024390</span> INFO S0FromS3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">7</span>&#125;][Add-After]</span><br><span class="line"><span class="number">025647</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">025653</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">026405</span> INFO S2term:<span class="number">5</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">026405</span> INFO S2-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">026406</span> INFO S2-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">026406</span> INFO S2-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">026406</span> INFO S2-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">027406</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">027408</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">028572</span> INFO S2term:<span class="number">6</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">028573</span> INFO S2-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">028573</span> INFO S2-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">028573</span> INFO S2-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">028573</span> INFO S2-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">028907</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">028918</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass9</span><br><span class="line"><span class="number">029388</span> INFO S1command8[ReceiveLog]</span><br><span class="line"><span class="number">029388</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">3</span> <span class="number">1</span> <span class="number">3</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">029388</span> INFO S1:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">3</span> <span class="number">1</span> <span class="number">3</span>&#125; &#123;<span class="number">4</span> <span class="number">1</span> <span class="number">8</span>&#125;][Start-After]</span><br><span class="line"><span class="number">029388</span> LEAD S1-term:<span class="number">1</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">029997</span> INFO S4term:<span class="number">4</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">029998</span> INFO S4-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">029998</span> INFO S4-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">029998</span> INFO S4-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">029998</span> INFO S4-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">030000</span> INFO S2:term:<span class="number">6</span> ==&gt; S4-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">030000</span> INFO S2 ==&gt; S4-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">030000</span> INFO S4-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">030000</span> INFO S1:term:<span class="number">3</span> ==&gt; S4-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">030000</span> INFO S1 ==&gt; S4-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">030001</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">3</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">4</span>[RequestVote1]</span><br><span class="line"><span class="number">030001</span> INFO S1:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">030001</span> INFO S4-term:<span class="number">6</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">030422</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">031050</span> INFO S2term:<span class="number">7</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">031051</span> INFO S2-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">031051</span> INFO S2-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">031052</span> INFO S2-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">031052</span> INFO S2-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">031052</span> INFO S4:term:<span class="number">6</span> ==&gt; S2-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">031053</span> INFO S4 ==&gt; S2-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">031053</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">6</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">7</span>[RequestVote1]</span><br><span class="line"><span class="number">031053</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">7</span>-LogFailOK[RequestVote3]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">7</span>)</span><br><span class="line"><span class="number">031055</span> INFO S1:term:<span class="number">4</span> ==&gt; S2-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">031055</span> INFO S1 ==&gt; S2-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">031055</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">4</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">7</span>[RequestVote1]</span><br><span class="line"><span class="number">031055</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">7</span>-LogFailOK[RequestVote3]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">7</span>)</span><br><span class="line"><span class="number">031056</span> INFO S2-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">031055</span> INFO S2-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">031879</span> INFO S0term:<span class="number">4</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">031880</span> INFO S0-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">031880</span> INFO S0-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">031880</span> INFO S0-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">031880</span> INFO S0-term:<span class="number">4</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">031927</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">033440</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">033468</span> INFO S4term:<span class="number">8</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">033469</span> INFO S4-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">033469</span> INFO S4-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">033470</span> INFO S4-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">033471</span> INFO S4-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">033471</span> INFO S2:term:<span class="number">7</span> ==&gt; S4-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">033472</span> INFO S2 ==&gt; S4-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">033472</span> INFO S2:state:<span class="number">1</span>:term:<span class="number">7</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">8</span>[RequestVote1]</span><br><span class="line"><span class="number">033472</span> INFO S2:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">033472</span> INFO S1:term:<span class="number">7</span> ==&gt; S4-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">033472</span> INFO S1 ==&gt; S4-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">033472</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">7</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">8</span>[RequestVote1]</span><br><span class="line"><span class="number">033472</span> INFO S1:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">033472</span> INFO S4-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">033472</span> TIMR S4Vote&lt;-<span class="number">-2</span>[Vote]</span><br><span class="line"><span class="number">033473</span> INFO S4-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">033473</span> TIMR S4Vote&lt;-<span class="number">-1</span>[Vote]</span><br><span class="line"><span class="number">033473</span> INFO S4:state:<span class="number">1</span>-changeTo-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">033473</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">033473</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">034551</span> INFO S0term:<span class="number">5</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">034552</span> INFO S0-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">034552</span> INFO S0-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">034552</span> INFO S0-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">034552</span> INFO S0-term:<span class="number">5</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">034951</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">034952</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">034954</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">034954</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">034954</span> INFO S1FromS4:[&#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Adding]</span><br><span class="line"><span class="number">034954</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-After]</span><br><span class="line"><span class="number">034955</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">034955</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">034955</span> INFO S2FromS4:[&#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Adding]</span><br><span class="line"><span class="number">034955</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-After]</span><br><span class="line"><span class="number">037185</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">037185</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">037201</span> INFO S1:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">037201</span> INFO S1 ==&gt; S2-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">037201</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">037740</span> INFO S1:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">037740</span> INFO S1 ==&gt; S2-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">037741</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">037938</span> INFO S1:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">037939</span> INFO S1 ==&gt; S2-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">037939</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">038691</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">038693</span> INFO S4:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">038694</span> INFO S4 ==&gt; S2-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">038692</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">038694</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">039984</span> INFO S0term:<span class="number">6</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">039985</span> INFO S0-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">039985</span> INFO S0-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">039986</span> INFO S0-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">039986</span> INFO S0-term:<span class="number">6</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">040203</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">040204</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">041708</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">041709</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">043219</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">043220</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">043885</span> INFO S0term:<span class="number">7</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">043886</span> INFO S0-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">043886</span> INFO S0-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">043887</span> INFO S0-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">043887</span> INFO S0-term:<span class="number">7</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">044733</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">044733</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">045684</span> INFO S4:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">045684</span> INFO S4 ==&gt; S2-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">045685</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">046235</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">046235</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">047741</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">047747</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">048161</span> INFO S0term:<span class="number">8</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">048162</span> INFO S0-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">048162</span> INFO S0-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">048162</span> INFO S0-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">048163</span> INFO S0-term:<span class="number">8</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">049254</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">049255</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">049426</span> INFO S4command8[ReceiveLog]</span><br><span class="line"><span class="number">049427</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">049427</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Start-After]</span><br><span class="line"><span class="number">049427</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">049430</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">049430</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">049430</span> INFO S1FromS4:[&#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Adding]</span><br><span class="line"><span class="number">049430</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Add-After]</span><br><span class="line"><span class="number">049430</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">049430</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">049430</span> INFO S2FromS4:[&#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Adding]</span><br><span class="line"><span class="number">049431</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Add-After]</span><br><span class="line"><span class="number">049432</span> INFO S4[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">050729</span> INFO S0term:<span class="number">9</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">050730</span> INFO S0-term:<span class="number">9</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">050730</span> INFO S0-term:<span class="number">9</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">050731</span> INFO S0-term:<span class="number">9</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">050731</span> INFO S0-term:<span class="number">9</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">050763</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">050763</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">050935</span> INFO S4command9[ReceiveLog]</span><br><span class="line"><span class="number">050935</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">050936</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Start-After]</span><br><span class="line"><span class="number">050936</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">050937</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">050937</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">050937</span> INFO S1FromS4:[&#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Adding]</span><br><span class="line"><span class="number">050937</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-After]</span><br><span class="line"><span class="number">050937</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">050937</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">050937</span> INFO S2FromS4:[&#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Adding]</span><br><span class="line"><span class="number">050937</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-After]</span><br><span class="line"><span class="number">050938</span> INFO S4[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">052268</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">052268</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">[TestBackup2B]==pass10</span><br><span class="line">[TestBackup2B]==pass11</span><br><span class="line"><span class="number">052400</span> INFO S3command10[ReceiveLog]</span><br><span class="line"><span class="number">052400</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">7</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">052400</span> INFO S3:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">3</span> <span class="number">6</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">7</span>&#125; &#123;<span class="number">6</span> <span class="number">3</span> <span class="number">10</span>&#125;][Start-After]</span><br><span class="line"><span class="number">052400</span> LEAD S3-term:<span class="number">3</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">052574</span> INFO S1:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">052574</span> INFO S1 ==&gt; S2-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">052575</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">053522</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">053522</span> INFO S3:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">053522</span> INFO S3FromS4:[&#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Adding]</span><br><span class="line"><span class="number">053522</span> INFO S3FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-After]</span><br><span class="line"><span class="number">053523</span> INFO S4:term:<span class="number">8</span> ==&gt; S2-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">053524</span> INFO S4 ==&gt; S2-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">053524</span> INFO S2-term:<span class="number">8</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">053777</span> LEAD S4-term:<span class="number">8</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">054829</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">8</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">054829</span> INFO S3:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">054829</span> INFO S3FromS4:[&#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Adding]</span><br><span class="line"><span class="number">054829</span> INFO S3FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125;][Add-After]</span><br><span class="line"><span class="number">055130</span> INFO S0term:<span class="number">10</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">055131</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote]</span><br><span class="line"><span class="number">055131</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">055131</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">055131</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">055132</span> INFO S1:term:<span class="number">8</span> ==&gt; S0-term:<span class="number">10</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S1 ==&gt; S0-term:<span class="number">10</span>[RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S2:term:<span class="number">8</span> ==&gt; S0-term:<span class="number">10</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">8</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">10</span>[RequestVote1]</span><br><span class="line"><span class="number">055132</span> INFO S2 ==&gt; S0-term:<span class="number">10</span>[RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">8</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">10</span>[RequestVote1]</span><br><span class="line"><span class="number">055132</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">10</span>-LogFailOK[RequestVote3]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">10</span>)</span><br><span class="line"><span class="number">055132</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">10</span>-LogFailOK[RequestVote3]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">10</span>)</span><br><span class="line"><span class="number">055132</span> INFO S3:term:<span class="number">8</span> ==&gt; S0-term:<span class="number">10</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S3 ==&gt; S0-term:<span class="number">10</span>[RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">8</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">10</span>[RequestVote1]</span><br><span class="line"><span class="number">055132</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">10</span>-LogFailOK[RequestVote3]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">10</span>)</span><br><span class="line"><span class="number">055132</span> INFO S4:term:<span class="number">9</span> ==&gt; S0-term:<span class="number">10</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055132</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055133</span> INFO S4 ==&gt; S0-term:<span class="number">10</span>[RequestVote]</span><br><span class="line"><span class="number">055133</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">9</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">10</span>[RequestVote1]</span><br><span class="line"><span class="number">055133</span> INFO S4:state:<span class="number">0</span>:term:<span class="number">10</span>-LogFailOK[RequestVote3]%!(EXTRA <span class="type">int</span>=<span class="number">0</span>, <span class="type">int</span>=<span class="number">10</span>)</span><br><span class="line"><span class="number">055133</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055133</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055133</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055467</span> INFO S1:term:<span class="number">10</span> ==&gt; S0-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055468</span> INFO S1 ==&gt; S0-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">055468</span> INFO S0-term:<span class="number">10</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055890</span> INFO S4term:<span class="number">11</span>=state:<span class="number">1</span>=[StartElect]</span><br><span class="line"><span class="number">055890</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote]</span><br><span class="line"><span class="number">055891</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote]</span><br><span class="line"><span class="number">055891</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">2</span>[RPC-Vote]</span><br><span class="line"><span class="number">055891</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote]</span><br><span class="line"><span class="number">055891</span> INFO S3:term:<span class="number">10</span> ==&gt; S4-term:<span class="number">11</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055891</span> INFO S3 ==&gt; S4-term:<span class="number">11</span>[RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S1:term:<span class="number">10</span> ==&gt; S4-term:<span class="number">11</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S2:term:<span class="number">10</span> ==&gt; S4-term:<span class="number">11</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S2 ==&gt; S4-term:<span class="number">11</span>[RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S1 ==&gt; S4-term:<span class="number">11</span>[RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">10</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">11</span>[RequestVote1]</span><br><span class="line"><span class="number">055892</span> INFO S1:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">055892</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">10</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">11</span>[RequestVote1]</span><br><span class="line"><span class="number">055892</span> INFO S0:term:<span class="number">10</span> ==&gt; S4-term:<span class="number">11</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S0 ==&gt; S4-term:<span class="number">11</span>[RequestVote]</span><br><span class="line"><span class="number">055892</span> INFO S0:state:<span class="number">1</span>:term:<span class="number">10</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">11</span>[RequestVote1]</span><br><span class="line"><span class="number">055892</span> INFO S0:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">055892</span> INFO S3:state:<span class="number">0</span>:term:<span class="number">10</span>-changeTo-state:<span class="number">0</span>:term:<span class="number">11</span>[RequestVote1]</span><br><span class="line"><span class="number">055892</span> INFO S3:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">055892</span> INFO S2:state:<span class="number">0</span>-changeTo-state:<span class="number">0</span>[RequestVote2]</span><br><span class="line"><span class="number">055892</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055892</span> TIMR S4Vote&lt;-<span class="number">-1</span>[Vote]</span><br><span class="line"><span class="number">055892</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055892</span> TIMR S4Vote&lt;-<span class="number">-0</span>[Vote]</span><br><span class="line"><span class="number">055892</span> INFO S4:state:<span class="number">1</span>-changeTo-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">055892</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BecomeLeader]</span><br><span class="line"><span class="number">055892</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">055892</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">1</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">055892</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">056796</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">056801</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">056802</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">056803</span> INFO S0FromS4:[&#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Adding]</span><br><span class="line"><span class="number">056803</span> INFO S0FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-After]</span><br><span class="line"><span class="number">057735</span> INFO S3:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">9</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">057736</span> INFO S3 ==&gt; S0-term:<span class="number">9</span>[RequestVote]</span><br><span class="line"><span class="number">057737</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">058299</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">059264</span> INFO S1:term:<span class="number">11</span> ==&gt; S3-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">059264</span> INFO S1 ==&gt; S3-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">059265</span> INFO S3-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">059439</span> INFO S1:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">059439</span> INFO S1 ==&gt; S0-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">059440</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">059806</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">060177</span> INFO S1:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">060177</span> INFO S1 ==&gt; S2-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">060178</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">060980</span> INFO S3:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">060980</span> INFO S3 ==&gt; S2-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">060980</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">061020</span> INFO S4:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">061020</span> INFO S4 ==&gt; S0-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">061020</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">061308</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">062475</span> INFO S3:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">062476</span> INFO S3 ==&gt; S2-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">062476</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">063105</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">063114</span> INFO S1:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">063114</span> INFO S1 ==&gt; S4-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">063114</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">064020</span> INFO S0:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">064020</span> INFO S0 ==&gt; S4-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">064020</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">064560</span> INFO S3:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">064560</span> INFO S3 ==&gt; S4-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">064561</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">064620</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">065309</span> INFO S3:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">065314</span> INFO S3 ==&gt; S0-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">065315</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">065345</span> INFO S0:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">065345</span> INFO S0 ==&gt; S2-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">065345</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">065898</span> INFO S4:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">065898</span> INFO S4 ==&gt; S0-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">065898</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">066130</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">067640</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">068029</span> INFO S0:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">068029</span> INFO S0 ==&gt; S4-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">068030</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">069037</span> INFO S2:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">069038</span> INFO S2 ==&gt; S4-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">069038</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">069151</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">069334</span> INFO S0:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">069335</span> INFO S0 ==&gt; S4-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">069335</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">069613</span> INFO S4:term:<span class="number">11</span> ==&gt; S3-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">069613</span> INFO S4 ==&gt; S3-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">069613</span> INFO S3-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">070473</span> INFO S0:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">070474</span> INFO S0 ==&gt; S2-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">070475</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">070665</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">071747</span> INFO S2:term:<span class="number">11</span> ==&gt; S3-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">071748</span> INFO S2 ==&gt; S3-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">071749</span> INFO S3-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">072169</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">073000</span> INFO S4command10[ReceiveLog]</span><br><span class="line"><span class="number">073001</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">073001</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-After]</span><br><span class="line"><span class="number">073001</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">073002</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">073002</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">073005</span> INFO S0FromS4:[&#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">073005</span> INFO S0FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">073006</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">073006</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">073006</span> INFO S1FromS4:[&#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">073006</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">073007</span> INFO S4[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">073022</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">073022</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">073022</span> INFO S2FromS4:[&#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">073022</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">073678</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">073815</span> INFO S4:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">073815</span> INFO S4 ==&gt; S0-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">073816</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">074216</span> INFO S3:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">074217</span> INFO S3 ==&gt; S4-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">074217</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">074328</span> INFO S4:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">074328</span> INFO S4 ==&gt; S2-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">074329</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">074448</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">074448</span> INFO S2 ==&gt; S0-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">074448</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">074986</span> INFO S3:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">074986</span> INFO S3 ==&gt; S2-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">074987</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">075181</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">075327</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">075327</span> INFO S2 ==&gt; S0-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">075328</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">075845</span> INFO S1:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">075845</span> INFO S1 ==&gt; S0-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">075848</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">076691</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">078192</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">078750</span> INFO S3:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">078750</span> INFO S3 ==&gt; S0-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">078750</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">079696</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">079874</span> INFO S2:term:<span class="number">11</span> ==&gt; S3-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">079875</span> INFO S2 ==&gt; S3-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">079876</span> INFO S3-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">081197</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">081264</span> INFO S1:term:<span class="number">11</span> ==&gt; S3-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">081264</span> INFO S1 ==&gt; S3-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">081265</span> INFO S3-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">081375</span> INFO S4:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">081375</span> INFO S4 ==&gt; S0-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">081376</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">082017</span> INFO S4:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">082017</span> INFO S4 ==&gt; S2-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">082018</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">082051</span> INFO S0:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">082051</span> INFO S0 ==&gt; S2-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">082052</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">082887</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">084393</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">085900</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">087402</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">087655</span> INFO S1:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">087656</span> INFO S1 ==&gt; S0-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">087657</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">088928</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">089334</span> INFO S3:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">089335</span> INFO S3 ==&gt; S2-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">089335</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">089791</span> INFO S0:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">089791</span> INFO S0 ==&gt; S2-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">089792</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">090443</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">091273</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">9</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">091274</span> INFO S2 ==&gt; S0-term:<span class="number">9</span>[RequestVote]</span><br><span class="line"><span class="number">091274</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">091532</span> INFO S0:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">091532</span> INFO S0 ==&gt; S2-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">091532</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">091651</span> INFO S3:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">3</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">091652</span> INFO S3 ==&gt; S2-term:<span class="number">3</span>[RequestVote]</span><br><span class="line"><span class="number">091652</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">092029</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">093068</span> INFO S4command10[ReceiveLog]</span><br><span class="line"><span class="number">093068</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">093068</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-After]</span><br><span class="line"><span class="number">093068</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">093070</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">093070</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">093070</span> INFO S0FromS4:[&#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">093070</span> INFO S0FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">093070</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">093071</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">093071</span> INFO S1FromS4:[&#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">093071</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">093071</span> INFO S4[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">093071</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">093071</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">093071</span> INFO S2FromS4:[&#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">093071</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">093341</span> INFO S4:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">093341</span> INFO S4 ==&gt; S0-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">093341</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">093532</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">093665</span> INFO S4:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">9</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">093665</span> INFO S4 ==&gt; S0-term:<span class="number">9</span>[RequestVote]</span><br><span class="line"><span class="number">093666</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">4</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">095038</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">095039</span> INFO S1:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">9</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">095039</span> INFO S1 ==&gt; S0-term:<span class="number">9</span>[RequestVote]</span><br><span class="line"><span class="number">095039</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">096159</span> INFO S3:term:<span class="number">11</span> ==&gt; S4-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">096160</span> INFO S3 ==&gt; S4-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">096161</span> INFO S4-term:<span class="number">11</span>-state:<span class="number">2</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">096549</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">097435</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">5</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">097435</span> INFO S2 ==&gt; S0-term:<span class="number">5</span>[RequestVote]</span><br><span class="line"><span class="number">097436</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">097546</span> INFO S1:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">097547</span> INFO S1 ==&gt; S0-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">097547</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">097991</span> INFO S0:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">097992</span> INFO S0 ==&gt; S2-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">097992</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">0</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">098062</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">098086</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">4</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">098087</span> INFO S2 ==&gt; S0-term:<span class="number">4</span>[RequestVote]</span><br><span class="line"><span class="number">098087</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">099568</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">101084</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">101391</span> INFO S3:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">8</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">101391</span> INFO S3 ==&gt; S0-term:<span class="number">8</span>[RequestVote]</span><br><span class="line"><span class="number">101392</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">102594</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">104103</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">105058</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">105058</span> INFO S2 ==&gt; S0-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">105059</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">105621</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">106396</span> INFO S3:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">106397</span> INFO S3 ==&gt; S0-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">106398</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">107135</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">107547</span> INFO S2:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">107548</span> INFO S2 ==&gt; S0-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">107550</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">2</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">108036</span> INFO S3:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">6</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">108036</span> INFO S3 ==&gt; S0-term:<span class="number">6</span>[RequestVote]</span><br><span class="line"><span class="number">108037</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">108644</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">110156</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">110392</span> INFO S3:term:<span class="number">11</span> ==&gt; S2-term:<span class="number">2</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">110392</span> INFO S3 ==&gt; S2-term:<span class="number">2</span>[RequestVote]</span><br><span class="line"><span class="number">110393</span> INFO S2-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">3</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">111658</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">112401</span> INFO S1:term:<span class="number">11</span> ==&gt; S0-term:<span class="number">7</span>[Enter-RequestVote]</span><br><span class="line"><span class="number">112401</span> INFO S1 ==&gt; S0-term:<span class="number">7</span>[RequestVote]</span><br><span class="line"><span class="number">112401</span> INFO S0-term:<span class="number">11</span>-state:<span class="number">0</span> =&gt; <span class="number">1</span>[RPC-Vote-Over]</span><br><span class="line"><span class="number">113164</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">113229</span> INFO S4command10[ReceiveLog]</span><br><span class="line"><span class="number">113229</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">113229</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-After]</span><br><span class="line"><span class="number">113230</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">113231</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">113231</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">113231</span> INFO S0FromS4:[&#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">113231</span> INFO S0FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">113232</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">113232</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">113232</span> INFO S1FromS4:[&#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">113232</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">113232</span> INFO S4[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">113232</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">113232</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">113232</span> INFO S2FromS4:[&#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">113232</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">114675</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">116176</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">117684</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">119194</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">120697</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">122202</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">123704</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">125206</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">126716</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">128226</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">129728</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">131244</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">132747</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">133387</span> INFO S4command10[ReceiveLog]</span><br><span class="line"><span class="number">133388</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-Before]</span><br><span class="line"><span class="number">133389</span> INFO S4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Start-After]</span><br><span class="line"><span class="number">133389</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">133396</span> INFO S1:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">133402</span> INFO S1:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">133403</span> INFO S1FromS4:[&#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">133403</span> INFO S1FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">133398</span> INFO S2:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">133406</span> INFO S2:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">133406</span> INFO S2FromS4:[&#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">133406</span> INFO S2FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">133407</span> INFO S4[Heartbeat]</span><br><span class="line">cnt,<span class="built_in">len</span>(rf.peers) <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">133401</span> INFO S0:state:<span class="number">0</span>:term:<span class="number">11</span>-ReceiveFrom-S4[AppendEntries]</span><br><span class="line"><span class="number">133408</span> INFO S0:term:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-Before]</span><br><span class="line"><span class="number">133408</span> INFO S0FromS4:[&#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Adding]</span><br><span class="line"><span class="number">133408</span> INFO S0FromS4:[&#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; &#123;<span class="number">3</span> <span class="number">3</span> <span class="number">5</span>&#125; &#123;<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">8</span> <span class="number">9</span>&#125; &#123;<span class="number">6</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">7</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">8</span> <span class="number">11</span> <span class="number">10</span>&#125; &#123;<span class="number">9</span> <span class="number">11</span> <span class="number">10</span>&#125;][Add-After]</span><br><span class="line"><span class="number">134252</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">135771</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">137283</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">138796</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">140300</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">141808</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">143324</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">144839</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">146339</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">147845</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">149381</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">150890</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line"><span class="number">152401</span> LEAD S4-term:<span class="number">11</span>-state:<span class="number">2</span>[BeginHeart]</span><br><span class="line">--- FAIL: TestBackupCopy2B (<span class="number">15.35</span>s)</span><br><span class="line">    config.<span class="keyword">go</span>:<span class="number">616</span>: [point2]one(<span class="number">10</span>) failed to reach agreement</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL<span class="number">6.824</span>/raft<span class="number">15.356</span>s</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240915145024791.png" alt="image-20240915145024791"></p><p>由于代码中少考虑了一个情况：如果当前节点提交的Index比传过来的还高，说明当前节点的日志已经超前,需返回过去</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240915144939007.png" alt="image-20240915144939007"><br>跑100echo</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240915144958097.png" alt="image-20240915144958097"></p><p>跑200echo</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240915145006201.png" alt="image-20240915145006201"></p><p>网络分区情况：</p><ul><li><a href="https://blog.csdn.net/zhou920786312/article/details/115457945">Raft协议–网络分区–07</a></li><li><a href="https://blog.csdn.net/Rose_DuanM/article/details/136284694">Raft 算法、分布式 KV 面试汇总</a></li></ul>]]></content>
    
    
    <summary type="html">Raft-lab2</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Raft-lab1</title>
    <link href="https://penge666.github.io/posts/d998e075.html"/>
    <id>https://penge666.github.io/posts/d998e075.html</id>
    <published>2024-09-04T02:01:04.000Z</published>
    <updated>2024-09-15T11:08:54.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：由于最近找工作战况严峻，不得以只能再掏个去年的项目，顺便温故一下之前学习分布式知识，commit就是最好的证明~PS：希望写这个Lab的不要太功利，bug才是真正提高自己水平的~</p><p>那段时光也是最能静下心来，算是研究生生涯中相对美好的时光~~~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914105627683.png" alt="image-20240914105627683"></p><p><strong>人生没有绝对的成功，以个人最舒服的姿态和最擅长的方式去活一生就已足够！</strong>摘自：<a href="https://tanxinyu.work/2022-internet-job-hunting-experience-sharing/">2022 互联网求职经验分享</a></p><h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>lab2 的内容是要实现一个除了节点变更功能外的 raft 算法，还是比较有趣的。 它被划分成了Lab2A、Lab2B、Lab2C和Lab2D四个子任务：</p><ol><li>Lab2A：实现 leader election、heartbeat。</li><li>Lab2B：实现 Log replication。</li><li>Lab2C：实现 state persistent。</li><li>Lab2D：实现 SnapShot</li></ol><p>实现的话建议先看官方文档，可以帮助我们避开很多的🕳，推荐：<a href="https://zhuanlan.zhihu.com/p/362257813">MIT6.824 来自己动手实现一个Raft协议吧(Lab2A)</a></p><p>剩下的只要严格根据论文的这张图实现，就可以完成了~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240604203937594.png" alt="image-20240604203937594"></p><p><strong>任务要求</strong></p><ul><li>实现Raft的leader选举和心跳机制（没有log entries的AppendEntriesRPCs）。</li><li>Part 2A的目标是：选出一个leader，在没有故障的情况下，这个leader仍然是leader；如果旧leader故障，或者旧leader的数据包丢失，那么新的leader接管。</li><li>运行go test -run 2A来测试你的Part 2A部分的代码。</li><li>路径切换到6.824/src/raft再执行测试go test -run 2A</li><li>若Part 2A全部通过，则显示如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line">$ <span class="keyword">go</span> test -run <span class="number">2</span>A</span><br><span class="line">Test (<span class="number">2</span>A): initial election ...</span><br><span class="line">... Passed -- <span class="number">4.0</span> <span class="number">3</span> <span class="number">32</span> <span class="number">9170</span> <span class="number">0</span></span><br><span class="line">Test (<span class="number">2</span>A): election after network failure ...</span><br><span class="line">... Passed -- <span class="number">6.1</span> <span class="number">3</span> <span class="number">70</span> <span class="number">13895</span> <span class="number">0</span></span><br><span class="line">PASS</span><br><span class="line">ok raft <span class="number">10.187</span>s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>每个”Passed”行包括5个数字，它们分别是：</p><ol><li>测试花费的时间（以秒为单位）</li><li>Raft peers的数量（通常是3或5）</li><li>在测试期间发送的RPC的数量</li><li>RPC消息中的总字节数</li><li>以及Raft报告提交的日志条目的数量。</li></ol><p><strong>任务提示</strong></p><ul><li>你不能直接运行你的Raft实现；相反，你应该通过tester来运行它，即运行<code>go test -run 2A</code></li><li>根据Raft论文中的Figure 2，此阶段，你关心的是发送和接收RequestVote RPCs、与选举相关的服务器规则以及与leader选举相关的状态</li></ul><p>在这个实验，只需要关注画红框的实现</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914101158374.png" alt="image-20240914101158374"></p><ul><li><p>将Figure 2中的leader选举的状态添加到<code>raft.go</code>中的Raft结构中。</p><p>你还需要定义一个结构来保存关于每个日志条目的信息。</p></li><li><p>填充RequestVoteArgs和RequestVoteReply结构体。修改Make()以创建一个后台groutine，当它有一段时间没有收到另一个peer的消息时，通过发送RequestVote RPCs周期性地启动leader选举。</p><p>通过这种方式，peer将了解谁是leader，如果已经有leader，或者自己成为leader。</p><p>实现RequestVote() RPC处理程序，以便服务器相互投票。</p></li><li><p>要实现心跳（heartbeats），定义一个AppendEntries RPC结构(尽管你可能还不需要所有参数)，并让leader定期发送它们。编写一个AppendEntries RPC处理方法，重置选举超时，以便当一个server已经当选时，其他servers不会仍想成为leader。</p></li><li><p>确保不同peers的选举超时不总是同时发生，否则所有peers只会为自己投票，没有人会成为leader。</p></li><li><p>tester要求leader每秒发送heartbeat RPCs不超过10次。</p></li><li><p>tester要求你的Raft在旧leader故障后的5秒内选出一个新的leader（如果大多数peer仍然可以通信）。</p><p>但是，请记住，如果出现分裂投票，leader选举可能需要多轮（如果数据包丢失或候选人不幸选择了相同的随机退出时间，则可能发生这种情况）。您必须选择足够短的选举超时设定（以及心跳间隔），以便即使需要多轮选举，也很可能在5秒内完成选举。</p></li><li><p>论文的5.2节提到了150到300毫秒范围内的选举超时设定。只有当leader发出的心跳频率大大超过每150毫秒一次时，这个范围才有意义。因为测试器将你的心跳限制为每秒10次，所以你必须使用比论文的150到300毫秒更大的选举超时设定的同时又不能太大，因为那样您可能无法在5秒内选出领导者。</p></li><li><p>你或许会发现Go的rand很有用。</p></li><li><p>你需要编写定期或延迟后执行操作的代码。要做到这一点，最简单的方法是创建一个带有调用了time.Sleep()的循环的goroutine。不要使用Go的time.Timer或 time.Ticker ，它们很难使用正确。</p></li><li><p>阅读关于locking和structure的建议（一定要读！！！否则Part 2A会遇到很多加锁不合理导致的死锁和DATA RACE！！！）。如果你的代码在通过测试时遇到困难，请再次阅读论文的Figure 2，leader选举的完整逻辑就分布在Figure的多个部分。</p></li><li><p>不要忘记实现GetState()</p></li><li><p>tester在永久关闭一个实例时会调用你的Raft的rf.Kill()。你可以使用rf.killed()检查Kill()是否已被调用。</p></li><li><p>你可能希望在所有循环中都这样做，以避免死亡的Raft实例打印令人困惑的消息。</p></li><li><p>调试代码的一个好方法是在peer发送或接收消息时插入print语句，并使用go test -run 2A &gt; out将输出收集到一个文件中。然后，通过研究out文件中的消息跟踪，你可以确定你的实现在哪里偏离了期望的协议。</p></li><li><p>你可能会发现util.go中的DPrintf在调试不同的问题时打开和关闭打印非常有用。</p></li><li><p>Go RPC只发送名称以大写字母开头的结构字段（导出的）。</p><p>子结构也必须有大写的字段名（例如数组中的日志记录字段）。<code>labgob</code>包会提醒你这一点，不要忽视警告。</p></li><li><p>用<code>go test -race</code>检查你的代码，并修复它报告的任何race。</p></li></ul><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>首先在<code>test_test.go</code>文件写了测试程序，通过<code>make_config</code> 函数创建一个配置对象 <code>config</code>，该对象管理一组 Raft 实例的测试环境。</p><p>这部分可以详细读一下。</p><p><strong>raft结构体数据</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line"><span class="comment">// 根据论文的要求定义</span></span><br><span class="line">currentTerm     <span class="type">int</span>         <span class="comment">// Server当前的term</span></span><br><span class="line">voteFor         <span class="type">int</span>         <span class="comment">// Server在选举阶段的投票给了谁</span></span><br><span class="line">voteGrantedNum  <span class="type">int</span>         <span class="comment">// 收集到的投票数量</span></span><br><span class="line">state           <span class="type">int</span>         <span class="comment">// 当前状态</span></span><br><span class="line">heartbeatTimer  *time.Timer <span class="comment">// 心跳超时时间</span></span><br><span class="line">electionTimeout *time.Timer <span class="comment">// 随机选举时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们通过raft.go中的Make函数初始化raft实例。</strong></p><ol><li>创建 Raft 实例：<ul><li><code>rf := &amp;Raft&#123;&#125;</code>：创建一个新的 Raft 实例 <code>rf</code>。</li></ul></li><li>设置Raft 实例的基本属性：<ul><li><code>rf.peers = peers</code>：设置 Raft 实例的 peers 列表，即与其他 Raft 实例的通信端点。</li><li><code>rf.persister = persister</code>：设置 Raft 实例的持久化对象，用于保存和恢复 Raft 状态。</li><li><code>rf.me = me</code>：设置 Raft 实例的 ID，标识当前实例。</li></ul></li><li>初始化 Raft 实例的参数：<ul><li><code>rf.currentTerm = 0</code>：初始化当前任期为 0。</li><li><code>rf.voteFor = -1</code>：初始化投票状态为未投票。</li><li><code>rf.voteGrantedNum = 0</code>：初始化获得的投票数为 0。</li><li><code>rf.state = StateFollower</code>：初始化状态为 Follower。</li><li><code>rf.electionTimeout = time.NewTimer(RandomizedElectionTimeout())</code>：设置随机选举超时定时器。</li><li><code>rf.heartbeatTimer = time.NewTimer(StableHeartbeatTimeout())</code>：设置稳定心跳定时器。</li></ul></li><li>从持久化状态中恢复 Raft 实例的状态：<ul><li><code>rf.readPersist(persister.ReadRaftState())</code>：从持久化对象中读取 Raft 状态，并恢复到当前 Raft 实例中。</li></ul></li><li>启动 ticker goroutine：<ul><li><code>go rf.ticker()</code>：启动一个 goroutine 来处理选举和心跳定时器，以开始选举过程。</li></ul></li><li>返回初始化完成的 Raft 实例：<ul><li><code>return rf</code>：返回初始化完成的 Raft 实例。</li></ul></li></ol><p>这里的超时时间设置如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">HeartbeatTimeout = <span class="number">50</span>  <span class="comment">//  心跳超时 针对leader</span></span><br><span class="line">ElectionTimeout  = <span class="number">150</span> <span class="comment">//  选举超时</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StableHeartbeatTimeout</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line"><span class="keyword">return</span> time.Duration(HeartbeatTimeout) * time.Millisecond</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandomizedElectionTimeout</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line"><span class="comment">// Note：RandomizedElectionTimeout between [T,2T]</span></span><br><span class="line"><span class="comment">// bug : not sure</span></span><br><span class="line"><span class="keyword">return</span> time.Duration(ElectionTimeout+rand.Intn(ElectionTimeout*<span class="number">2</span>)) * time.Millisecond</span><br><span class="line"><span class="comment">// return ElectionTimeout + (time.Duration(rand.Int63()) % ElectionTimeout)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>go rf.ticker()</code>函数启动 raft。</strong></p><p><code>ticker</code> 函数</p><p><code>ticker</code> 方法是 Raft 实例的一个 goroutine，用于处理选举超时和心跳定时器。以下是该方法的详细总结：</p><ol><li>无限循环：<ul><li><code>for !rf.killed() &#123; ... &#125;</code>：只要 Raft 实例没有被终止，就持续运行。</li></ul></li><li>选举超时处理：<ul><li><code>select &#123; case &lt;-rf.electionTimeout.C: ... &#125;</code>：等待选举超时定时器触发。<ul><li><code>rf.mu.Lock()</code>：加锁，确保线程安全。</li><li><code>if rf.state != StateLeader &#123; ... &#125;</code>：如果当前状态不是 Leader，则开始选举。<ul><li><code>rf.changeInfo()</code>：改变 Raft 实例的状态信息，准备选举。</li><li><code>rf.mu.Unlock()</code>：解锁，确保在请求投票过程中不持有锁。</li><li><code>PrettyDebug(dInfo, &quot;S%dterm:%d=state:%d=[StartElect]&quot;, rf.me, rf.currentTerm, rf.state)</code>：打印调试信息，表示开始选举。</li><li><code>rf.startElection()</code>：发起选举请求。</li></ul></li><li><code>else &#123; rf.mu.Unlock() &#125;</code>：如果当前状态是 Leader，则解锁并继续。</li></ul></li></ul></li><li>心跳定时器处理：<ul><li><code>case &lt;-rf.heartbeatTimer.C: ...</code>：等待心跳定时器触发。<ul><li><code>rf.mu.Lock()</code>：加锁，确保线程安全。</li><li><code>if rf.state == StateLeader &#123; ... &#125;</code>：如果当前状态是 Leader，则广播心跳。<ul><li><code>rf.BroadcastHeartbeat()</code>：向所有 Follower 发送心跳消息。</li><li><code>rf.heartbeatTimer.Reset(StableHeartbeatTimeout())</code>：重置心跳定时器。</li></ul></li><li><code>rf.mu.Unlock()</code>：解锁。</li></ul></li></ul></li></ol><p><strong>这里主要2个功能，超时选举和心跳机制。</strong></p><p>当选举时间超时的时候，那么就会改变自身状态变成候选者，然后开始拉选票。</p><p>【下面给出其逻辑，读者自行实现】</p><p><code>startElection</code> 函数的主要功能是发起选举，并向所有 peers 发送请求投票 RPC。它通过遍历所有 peers，并启动 goroutine 来处理每个 peer 的投票结果。如果获得的投票数超过半数，则当前 Raft 实例成为 Leader，并广播心跳消息。如果投票未被授予，则根据回复中的任期更新当前任期和状态。通过这种方式，<code>startElection</code> 方法确保 Raft 实例能够有效地发起选举并处理投票结果。</p><p>这里比较核心的就是RPC：RequestVote</p><p>【下面给出其逻辑，读者自行实现】</p><p><code>RequestVote</code> 函数的主要功能是处理请求投票 RPC。它首先检查请求的任期是否小于当前 Raft 实例的任期，如果是，则拒绝投票。如果请求的任期大于当前任期，则更新当前任期和状态。然后，检查是否已经投过票，并且是否投给当前请求的候选人，如果是，则拒绝投票。最后，投票给请求的候选人，并重置选举超时定时器。通过这种方式，<code>RequestVote</code> 方法确保 Raft 实例能够正确处理请求投票 RPC，并维护集群的一致性。</p><p>心跳机制的话也是一样的。根据论文实现即可。</p><h2 id="实验调试"><a href="#实验调试" class="headerlink" title="实验调试"></a>实验调试</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914105426791.png" alt="image-20240914105426791"></p><p>经验之谈：调试的话一般是通过日志，信息短的话通过可视化直接查看。</p><p><strong>bug1</strong></p><p>思考：你断开之后，别人向你发的请求你没有收到？<br>解决方案：改变超时时间<br>猜测原因：你还没起来或者阻塞了</p><p>错误的情况</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914105448848.png" alt="image-20240914105448848"></p><p>正确情况</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914105556426.png" alt="image-20240914105556426"></p><p><strong>bug2</strong></p><p>日志文件巨大，死循环了，貌似是活锁，猜的真准！</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914105823850.png" alt="image-20240914105823850"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240914105650414.png" alt="image-20240914105650414"></p><p>分析日志：从日志中可以看到，系统处于一个无限循环中，反复发送 <code>RequestVote</code> 请求，即 <code>SendRequestVote-loop</code> 不断重复，这表明某种操作在持续进行，但并没有实际进展。这种行为可能是由于多个节点在选举过程中不断请求投票，但始终无法成功进入到下一个状态。</p><p>可能原因：</p><ul><li>网络延迟或通信问题：节点之间的消息来回传递，但由于网络延迟、丢包等原因，选举过程无法完成，导致节点一直反复请求投票。</li><li>选举超时设置不佳：如果多个节点几乎同时进入选举状态并开始发送投票请求，它们可能会持续干扰彼此，导致活锁。</li><li>选举过程中的竞争：多个节点可能同时尝试成为领导者，彼此互相干扰，导致选举无法成功完成。</li></ul><p>解决方法：</p><ol><li>引入随机化超时：在分布式系统中，特别是在选举过程中，随机化超时是一种常见的处理活锁的策略。通过给选举超时设置一个随机范围，可以减少多个节点同时进入选举状态的概率，从而避免活锁的发生。</li><li>调整超时和重试机制：适当地增加超时的间隔时间，减少频繁的请求重发。</li><li>网络优化：如果是由于网络问题导致的活锁，可以考虑优化网络，减少延迟和丢包的情况。</li></ol><p><strong>活锁概念：</strong></p><p><strong>活锁</strong>（Livelock）是一种类似于死锁的情形，但不同的是，<strong>在活锁中，系统的各个进程或线程并没有完全停滞不前，而是一直在做一些操作（通常是尝试去解决冲突或问题），但由于相互干扰，系统无法取得任何实际进展</strong>。也就是说，活锁中的某些进程或线程仍在不断改变状态，但没有一个能够完成它们的任务。</p><p>在活锁中，进程或线程会：</p><ol><li>不断地做出响应并尝试解决问题。</li><li>由于每个进程都在做出响应，导致整体系统无法前进。</li></ol><p>最后，将选举超时时间设置成<code>RandomizedElectionTimeout() = (ElectionTimeout + rand.Intn(ElectionTimeout)) * time.Millisecond</code>即可解决。</p>]]></content>
    
    
    <summary type="html">Raft-lab1</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce</title>
    <link href="https://penge666.github.io/posts/bc1fb66d.html"/>
    <id>https://penge666.github.io/posts/bc1fb66d.html</id>
    <published>2024-09-01T14:55:07.000Z</published>
    <updated>2024-09-15T11:09:24.628Z</updated>
    
    <content type="html"><![CDATA[<p>我将玫瑰藏于身后，风起花落，从此鲜花赠自己，纵马踏花向自由。</p><p><strong>前言</strong>：由于最近找工作战况严峻，不得以只能再掏个去年的项目，顺便温故一下之前学习分布式知识，commit就是最好的证明~PS：希望写这个Lab的不要太功利，bug才是真正提高自己水平的~</p><p>那段时光也是最能静下心来，最美好的时光~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913225720099.png" alt="image-20240913225720099"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913225626631.png" alt="image-20240913225626631"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913233108338.png" alt="image-20240913233108338"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913233117386.png" alt="image-20240913233117386"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913233127922.png" alt="image-20240913233127922"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913233150876.png" alt="image-20240913233150876"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913233139291.png" alt="image-20240913233139291"></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>MapReduce学习请看这篇：<a href="https://www.cnblogs.com/fuzhe1989/p/3413457.html">MapReduce: Simplified Data Processing on Large Clusters</a></p><p>go-rpc的使用移步这篇：<a href="https://blog.csdn.net/weixin_42216109/article/details/125248083">【Golang | RPC】使用包net/rpc实现基于http协议的RPC服务</a></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p><strong>目标</strong></p><p>词频统计</p><p><strong>描述</strong></p><p>实现分布式mr,一个coordinator,一个worker（启动多个）,在这次实验都在一个机器上运行。worker通过rpc和coordinator交互。worker请求任务,进行运算,写出结果到文件。coordinator需要关心worker的任务是否完成，在超时情况下将任务重新分配给别的worker。</p><p><strong>规则</strong></p><ul><li>map阶段需要将中间keys分成nReduce个数, nReduce通过main/mrcoordinator.go传给MakeCoordinator()</li><li>worker需要将第X个reduce task结果放到mr-out-X中。</li><li>mr-out-X要一行一行生成,kv形式。main/mrsequential.go中有，拿来就完事了</li><li>main/mrcoordinator.go从mr/coordinator.go 的 Done()方法得知任务完成并关闭自己。</li><li>任务都完成后，worker也得关闭</li></ul><p><strong>提示</strong></p><ul><li>一开始可以从mr/worker.go的 Worker()方法做，发送rpc给coordinator请求任务，然后coordinator分配任务，然后worker读文件并且map函数处理。</li><li>map reduce函数都是通过go插件装载 (.so文件)</li><li>mr/ 文件变了就需要重新build</li><li>都在一个文件系统,worker天然实现文件共享，先凑合着起步</li><li>中间文件命名 mr-X-Y X是map任务号，y是reduce任务号</li><li>worker的map方法用json存储中间kv对，reduce再读回来，因为真正分布式worker都不在一个机器上，涉及网络传输，所以用json编码解码走个过场。</li><li>worker的map可以用 worker.go里面的ihash(key)得到特定key的reduce任务号</li><li>mrsequential.go 代码可以借鉴</li><li>coordinator里面的共享数据需要加锁</li><li>worker有时候需要等待,比如当map任务都分发出去了,有的worker完成后又来申请任务，此时还有map未完成,reduce不能开始，这个worker需要等待下</li><li>如果任务重试机制，记得不要生成重复任务</li><li>mrapps/crash.go 随机干掉map reduce,看crash.go的代码是有一定几率让worker直接退出或者长时间延迟,可以用来测试恢复功能。这个逻辑是整合在map reduce函数里面的，注意worker被干掉时候任务已经拿到手了。</li><li>确保没有人在出现崩溃时观察部分写入的文件，用ioutil.TempFile创建临时文件，用os.Rename重命名</li></ul><h2 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h2><p>摘自：<a href="https://juejin.cn/post/7224476641623556154">https://juejin.cn/post/7224476641623556154</a></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913230116525.png" alt="image-20240913230116525"></p><p>客户端通过运行一次<code>mrmaster.go</code>启动一个<code>master</code>进程，启动时，会进行以下操作：</p><ul><li>创建一个<code>Master</code>结构体</li><li>根据命令行传入的文件生成所有<code>map</code>任务并存放在<code>Master</code>的<code>MapChannel</code>中</li><li>开启一个新的线程不断循环判断有没有过期(分配出去但十秒内未完成)的<code>map</code>和<code>reduce</code>任务</li><li>开始监听来自<code>worker</code>的<code>RPC</code>调用</li></ul><p>客户端通过运行多次<code>mrworker.go</code>启动多个<code>worker</code>进程，每个<code>worker</code>启动时，都会进行以下操作：</p><ul><li>创建一个<code>AWorker</code>结构体</li><li>只要<code>master</code>进程没有通知<code>worker</code>进程所有任务都已经完成，<code>worker</code>进程就一直向<code>master</code>进程要任务</li></ul><p><code>master</code>接收到<code>worker</code>的要任务请求后，根据所有任务的完成情况给<code>worker</code>分配任务，分配规则是：所有<code>map</code>任务全部完成后才可以去分配<code>reduce</code>任务</p><p>当<code>worker</code>要到任务后，<code>worker</code>会首先判断这个任务是<code>map</code>任务还是<code>reduce</code>任务，并根据任务类型执行不同的逻辑</p><ul><li>如果是<code>map</code>任务，会执行<code>doMap</code>逻辑，全部执行完后会在<code>/var/tmp</code>目录下生成文件名为<code>mr-X-Y</code>的临时文件，其中<code>X</code>是当前<code>mapWorker</code>的<code>ID</code>，<code>Y</code>是通过<code>ihash</code>方法计算出来的</li><li>如果是<code>reduce</code>任务，会执行<code>doReduce</code>逻辑，<code>worker</code>会从 <code>src/main</code>中读取所有<code>mr-*-Y</code>文件，其中<code>Y</code>是当前<code>reduceWorker</code>的<code>reduce</code>任务的编号，最终会在<code>/var/tmp</code>目录下生成文件名为<code>mr-out-Y</code>的临时文件</li></ul><p><code>worker</code>执行完自己的任务后，会执行<code>mapTaskDone</code>或<code>reduceTaskDone</code>方法，告诉<code>master</code>自己的任务完成了，通知完之后会立马继续向<code>master</code>要新的任务</p><p><code>master</code>在接收到<code>worker</code>完成任务的通知后，会先判断这个<code>worker</code>完成这个任务有没有超时，具体就是判断这个任务的状态是不是<code>Running</code>，如果是就没有超时；否则，如果状态是<code>Ready</code>，就说明该任务已经被<code>master</code>中的循环检测任务过期的线程判定为过期并设为<code>Ready</code>状态；如果状态是<code>Finished</code>，说明这个任务被判定为超时后又被分配给其他<code>worker</code>并被那个<code>worker</code>按时完成</p><p>如果<code>master</code>判断<code>worker</code>在规定时间内完成了任务，则：</p><ul><li><code>worker</code>执行的是<code>map</code>任务：<code>master</code>会调用<code>generateMapFile</code>方法，将<code>worker</code>在<code>/var/tmp</code>中生成的临时文件<code>mr-X-Y</code>复制到 <code>src/main</code>中，作为正式的该<code>map</code>任务完成后产生的中间文件，表示<code>master</code>接受了该<code>worker</code>的成果</li><li><code>worker</code>执行的是<code>reduce</code>任务：<code>master</code>会调用<code>generateReduceFile</code>方法，将<code>worker</code>在<code>/var/tmp</code>中生成的临时文件<code>mr-out-Y</code>复制到 <code>src/main</code>中，作为正式的该<code>reduce</code>任务完成后产生的最终文件，表示<code>master</code>接受了该<code>worker</code>的成果</li></ul><p>当<code>master</code>的<code>MapChannel</code>中存储的所有任务都被完成后，<code>master</code>会将任务分配阶段由<code>MapPhase</code>调整为<code>ReducePhase</code>，在这之后，<code>master</code>就会给来请求任务的<code>worker</code>分配<code>reduce</code>任务</p><p>当<code>master</code>的<code>ReduceChannel</code>中存储的所有任务都被完成后，表示所有的<code>map</code>任务和<code>reduce</code>任务都已经完成，此时<code>master</code>会调用<code>finish</code>方法，准备终止<code>master</code>进程，并通知所有的<code>master</code>任务完成了，终止所有<code>worker</code></p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="master程序"><a href="#master程序" class="headerlink" title="master程序"></a>master程序</h3><p><strong>mrcoordinator.go</strong></p><p>命令：go run mrcoordinator.go pg*.txt</p><p>代码会调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := mr.MakeCoordinator(os.Args[<span class="number">1</span>:], <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><code>MakeCoordinator</code> 函数用于初始化一个 <code>Coordinator</code> 实例，包括初始化 Map 任务和 Reduce 任务的状态映射表，并启动 Coordinator 的服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeCoordinator</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Coordinator &#123;</span><br><span class="line"><span class="comment">// 创建一个 Coordinator 实例</span></span><br><span class="line">c := Coordinator&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Coordinator 的各个字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Map 任务的总数量</span></span><br><span class="line">c.MapTotNum = <span class="built_in">len</span>(files)</span><br><span class="line">fmt.Println(<span class="string">&quot;总文件数量:&quot;</span>, <span class="built_in">len</span>(files))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Map 任务的状态映射表</span></span><br><span class="line">c.MapFunc = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Map 任务的 ID 计数器</span></span><br><span class="line">c.MapId = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有文件，将文件名添加到 Map 任务的文件名列表中，并初始化每个 Map 任务的状态为 Undo</span></span><br><span class="line"><span class="keyword">for</span> map_id, filename := <span class="keyword">range</span> files &#123;</span><br><span class="line">c.MapFileName = <span class="built_in">append</span>(c.MapFileName, filename)</span><br><span class="line">c.MapFunc[map_id] = Undo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Reduce 任务的状态映射表</span></span><br><span class="line">c.ReduceFunc = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Reduce 任务的总数量</span></span><br><span class="line">c.ReduceNum = nReduce</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有 Reduce 任务，初始化每个 Reduce 任务的状态为 Undo</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line">c.ReduceFunc[i] = Undo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Coordinator 的服务</span></span><br><span class="line">c.server()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回初始化后的 Coordinator 实例</span></span><br><span class="line"><span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，Coordinator的数据结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line"><span class="comment">//map相关定义</span></span><br><span class="line">MapTotNum   <span class="type">int</span>      <span class="comment">// 记录总共有多少输入文件</span></span><br><span class="line">MapFileName []<span class="type">string</span> <span class="comment">// 文件名称</span></span><br><span class="line"><span class="comment">// MapContent  chan string  // 文件内容</span></span><br><span class="line">MapId   <span class="type">int</span>          <span class="comment">// map的编号</span></span><br><span class="line">Lock    sync.RWMutex <span class="comment">// 锁</span></span><br><span class="line">MapFunc <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>  <span class="comment">// 标记状态</span></span><br><span class="line"><span class="comment">// reduce相关定义</span></span><br><span class="line">ReduceNum <span class="type">int</span></span><br><span class="line"><span class="comment">// ReduceFileName []string</span></span><br><span class="line"><span class="comment">// ReduceContent  chan string</span></span><br><span class="line">ReduceId   []<span class="type">int</span></span><br><span class="line">ReduceFunc <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来开启监听</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> server() &#123;</span><br><span class="line"><span class="comment">// 注册 Coordinator 实例为 RPC 服务对象</span></span><br><span class="line">rpc.Register(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 RPC 服务使用 HTTP 协议进行通信</span></span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Coordinator 的 Unix 域套接字文件名</span></span><br><span class="line">sockname := coordinatorSock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除已存在的 Unix 域套接字文件（如果存在）</span></span><br><span class="line">os.Remove(sockname)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Unix 域套接字文件名</span></span><br><span class="line">fmt.Println(<span class="string">&quot;coordinator:sockname&quot;</span>, sockname)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Unix 域套接字监听器</span></span><br><span class="line">l, e := net.Listen(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果监听失败，记录错误并终止程序</span></span><br><span class="line">log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个 HTTP 服务器，监听 Unix 域套接字</span></span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Map阶段向master发送请求</strong></p></blockquote><p>【这里不给出代码啦，希望看到这篇博客的小伙伴自己实现下，不要太功利了~】算彩蛋吗~</p><p><strong>SuportMapTask函数</strong></p><p><code>SuportMapTask</code> 方法是 Coordinator 类的一个方法，用于处理 Worker 请求 Map 任务的逻辑。以下是对该方法的详细解释和总结：</p><ol><li><strong>加锁</strong>：<ul><li>使用互斥锁 <code>Lock</code> 确保并发安全，防止多个 Worker 同时请求任务时发生竞态条件。</li></ul></li><li><strong>初始化回复</strong>：<ul><li>初始化回复的标志位 <code>Flag</code> 为 <code>false</code>，表示没有找到可用的 Map 任务。</li><li>设置回复中的 <code>NumReduce</code> 字段为 Coordinator 的 <code>ReduceNum</code>，表示 Reduce 任务的数量。</li></ul></li><li><strong>遍历 Map 任务</strong>：<ul><li>遍历所有 Map 任务，检查是否有未完成的任务（状态为 <code>Undo</code>）。</li><li>如果找到一个未完成的 Map 任务：<ul><li>设置回复的 <code>Mapfilename</code> 为该任务对应的文件名。</li><li>设置回复的 <code>Flag</code> 为 <code>true</code>，表示找到了可用的 Map 任务。</li><li>设置回复的 <code>MapId</code> 为该任务的 ID。</li><li>将该任务的状态设置为 <code>Doing</code>，表示任务正在执行。</li><li>打印日志，记录 Worker 请求到的任务 ID。</li><li>启动一个协程，调用 <code>CheckTimeout</code> 方法检查任务是否超时。</li><li>跳出循环，返回任务。</li></ul></li></ul></li><li><strong>返回结果</strong>：<ul><li>如果没有找到未完成的 Map 任务，回复的 <code>Flag</code> 保持为 <code>false</code>，表示没有可用的 Map 任务。</li></ul></li></ol><p><strong>MasterCheckMapFinish函数</strong></p><blockquote><p><strong>Reduce阶段向master发送的请求</strong></p></blockquote><p>这个·和上面这个思路一致。</p><blockquote><p><strong>处理早退的Casew</strong></p></blockquote><p><code>CheckTimeout</code> 方法是 Coordinator 类的一个方法，用于检查任务是否超时。以下是该方法的详细流程总结：</p><ol><li><strong>等待超时时间</strong>：<ul><li>方法首先等待指定的超时时间（<code>timeout</code> 秒）。</li></ul></li><li><strong>加锁</strong>：<ul><li>使用互斥锁 <code>Lock</code> 确保并发安全，防止多个协程同时修改任务状态时发生竞态条件。</li></ul></li><li><strong>检查任务类型</strong>：<ul><li>根据传入的 <code>TaskType</code> 参数判断任务类型是 <code>Map</code> 还是 <code>Reduce</code>。</li></ul></li><li><strong>检查任务状态</strong>：<ul><li>如果任务类型是 <code>Map</code>：<ul><li>检查对应 <code>Map</code> 任务的状态是否为 <code>Finish</code>。</li><li>如果任务状态不是 <code>Finish</code>，则将其状态重置为 <code>Undo</code>，表示任务超时未完成。</li></ul></li><li>如果任务类型是 <code>Reduce</code>：<ul><li>检查对应 <code>Reduce</code> 任务的状态是否为 <code>Finish</code>。</li><li>如果任务状态不是 <code>Finish</code>，则将其状态重置为 <code>Undo</code>，表示任务超时未完成。</li></ul></li></ul></li><li><strong>解锁</strong>：<ul><li>释放互斥锁 <code>Lock</code>，允许其他协程访问任务状态。</li></ul></li></ol><h3 id="worker程序"><a href="#worker程序" class="headerlink" title="worker程序"></a>worker程序</h3><p>原先框架中给出了RPC的示例，照着写就行。</p><p>再学习这部分之前，先大致有个思路，那么之后就会更好的理解实现。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913232202672.png" alt="image-20240913232202672"></p><blockquote><p><strong>Map阶段举例说明：</strong></p></blockquote><p>我们先将txt文件变成<code>input.txt</code> 并返回一个 <code>[]KeyValue</code> 数组，其中每个 <code>KeyValue</code> 对表示一个单词和它的出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kva = [</span><br><span class="line">    &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>之后根据 <code>Key</code> 的哈希值将键值对分配到不同的 <code>reduce</code> 任务。<code>ihash(tkva.Key)</code> 计算 <code>Key</code> 的哈希值，然后通过取模操作 <code>% cur_reply.NumReduce</code> 来确定应该将键值对放在哪一个桶中。</p><p>比如，假设 <code>ihash</code> 函数得出的哈希值如下：</p><ul><li><code>ihash(&quot;apple&quot;) % 2 = 0</code></li><li><code>ihash(&quot;banana&quot;) % 2 = 1</code></li><li><code>ihash(&quot;orange&quot;) % 2 = 0</code></li></ul><p>那么 <code>kvaa</code> 的内容将变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kvaa[<span class="number">0</span>] = [</span><br><span class="line">    &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">]</span><br><span class="line">kvaa[<span class="number">1</span>] = [</span><br><span class="line">    &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>遍历 <code>NumReduce</code>，即 2 个桶，并将桶中的 <code>KeyValue</code> 对保存到文件中。文件名格式为 <code>mr-X-Y</code>，其中 <code>X</code> 是 <code>Map</code> 任务编号（<code>cur_reply.MapId</code>），<code>Y</code> 是 <code>reduce</code> 任务编号。</p><ul><li><p>对于第一个桶（<code>i=0</code>），生成文件 <code>mr-1-0</code>，内容是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;Value&quot;</span>:1&#125;</span><br><span class="line">&#123;<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;Value&quot;</span>:1&#125;</span><br><span class="line">&#123;<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;Value&quot;</span>:1&#125;</span><br><span class="line">&#123;<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;Value&quot;</span>:1&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于第二个桶（<code>i=1</code>），生成文件 <code>mr-1-1</code>，内容是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;Value&quot;</span>:1&#125;</span><br><span class="line">&#123;<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;Value&quot;</span>:1&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>Reduce阶段举例说明：</strong></p></blockquote><p><code>reduce</code>任务时只需要读取所有的<code>mr-*-reduce</code>文件并合并处理就可以实现所有相同的单词被同一个<code>reduce</code>任务处理的效果，最终经过<code>reduce</code>任务的处理，产生文件<code>mr-out-i</code>。</p><blockquote><p><strong>RPC通信</strong></p></blockquote><p>Map阶段与master的rpc函数</p><ul><li>worker向master请求任务</li><li>map告诉master已经完成任务</li><li>reduce告诉master已经完成任务</li></ul>]]></content>
    
    
    <summary type="html">MapReduce-Lab</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Lock-Manager</title>
    <link href="https://penge666.github.io/posts/a3f04a36.html"/>
    <id>https://penge666.github.io/posts/a3f04a36.html</id>
    <published>2024-08-18T08:36:16.000Z</published>
    <updated>2024-09-15T06:03:02.048Z</updated>
    
    <content type="html"><![CDATA[<p>不要说死亡的烛光何须倾倒</p><p>生命依然生长在忧愁的河水上</p><p>月光照着月光 月光普照</p><p>今夜美丽的月光合在一起流淌~</p><h2 id="Lock-Manager">Lock Manager</h2><p>为了保证事务们的操作的正确间隔，DBMs使用一个lock manager来控制何时事务被允许访问data items。<strong>LM的基本思想是维持一个内部的关于活跃的txns当前持有的locks的数据结构</strong>。<strong>txns在被允许访问一个data item之前向LM发出lock请求，然后LM会选择向请求的txn授予lock或者block txn或者abort txn</strong></p><p>在你的实现中，这里会有一个global Lock manager for the entire system（跟bpm一样）TableHeap和Executor classes会在一个事务想要访问/修改一个tuple时使用你的LM来获取locks on tuple records（by RID）</p><p>这个任务要求你实现一个tuple级别的LM，其支持三种常见的隔离级别，READ_UNCOMMITED, READ_COMMITTED, and REPEATABLE_READ. LM应该根据一个事务的隔离级别来授予和释放locks。</p><p>我们提供给你了一个 Transaction context(<code>include/concurrency/transaction.h</code>） 来处理隔离级别这一属性(i.e., READ_UNCOMMITED, READ_COMMITTED, and REPEATABLE_READ)以及其已经获得的锁的信息。LM需要检查事务的隔离级别并expose correct behavior on lock/unlock requests。<strong>任何失败的lock 操作都应该产生一个ABORTED 事务状态（隐式abort）并抛出异常</strong>(比如txn处于shrinking阶段时又尝试申请锁，又或者死锁了被aborted）。<strong>事务管理器txn manager应该之后捕获这个异常并将该事务已经执行的操作rollback</strong></p><h3 id="REQUIREMENTS-AND-HINTS"><strong>REQUIREMENTS AND HINTS</strong></h3><p>这个任务你唯一需要修改的文件就是LockManager class(<code>concurrency/lock_manager.cpp</code> and <code>concurrency/lock_manager.h</code>)。你会需要实现下列函数</p><ul><li>LockShared(Transaction, RID)：txn尝试获取一个shared lock on recoid id rid。这个应该阻塞等待并且在获得锁的授予时返回true。如果txn被回滚（aborts),返回false</li><li>LockExclusive(Transaction, RID)：txn尝试获取一个exclusive lock on record id rid。这个应该阻塞等待并且在获得锁的授予时返回true。如果txn被回滚（aborts),返回false</li><li>LockUpgrade(Transaction, RID)：txn尝试在一个record id rid上将一个shared 升级到exclusive lock。这个应该阻塞等待并且在获得锁的授予时返回true。如果txn被回滚（aborts),返回false。这个应该把txn abort并返回false，如果另一个事务已经在等待升级它们的锁<br><strong>之所以要有这个锁，是因为加了读锁以后就加不了写锁了，但是锁中途是不能释放的（2PL）</strong></li><li>Unlock(Transaction, RID): Unlock txn持有的rid指定的record上的锁</li></ul><p>lock manager采取的上锁机制依赖于事务的隔离级别。你应该首先看一下transaction.h和lock_manager.h，熟悉一下提供的api和成员变量。我们同样推荐复习下隔离级别的概念，因为这些函数的实现应该和提出lock/unlock请求的事务的隔离级别相兼容。你可以自由选择往lock_manager.h中增加任何需要的数据结构。你应该参考课本的15.1-15.2以及lecture中覆盖的隔离级别的概念以保证你的实现满足要求</p><h3 id="TA的建议">TA的建议</h3><ul><li>尽管你的lock manager需要使用死锁检测，我们建议先实现没有任何死锁处理的lcok manager，然后在你验证了在没有死锁发生时lock manager上锁和解锁的正确性后再增加死锁检测机制</li><li>你会需要一些方式记录哪些txn在等待一个lock。看一下<code>LockRequestQueue</code> class in <code>lock_manager.h</code>.</li><li>你需要一些方式来通知等待的txns当它们准备好获取锁时。我们建议使用std::condition_variable</li><li>尽管一些隔离级别是通过确保strict 二段锁的性质实现的，你的LM的实现只被要求保证二段锁的性质。strict 2PL的概念是通过你的executors和transaction manager中的逻辑实现的。看一眼Commit和Abort方法(这两个方法会把txn持有的所有锁都释放)</li><li>你应该维持事务的状态。比如事务的状态可能从<code>GROWING</code> phase转变为<code>SHRINKING</code> phase，因为unlock操作（hint:看一下transaction.h中的方法）</li><li>你同样需要使用 <code>shared_lock_set_</code> and <code>exclusive_lock_set_</code> 来记录一个事务获取的shared/exclusive lock，从而当TransactionManager想要commit/abort一个txn时，LM可以适当地释放它们</li><li>将一个事务的状态设为ABORTED 即隐式地abort it，但是该事务并没有被显式地abort直到TransactionManager::Abort被调用。你应该通读这个函数来理解它干了什么，以及你的lock manager在abort process中是如何被使用的（会调用lock_manager_-&gt;unlock()将txn的所有lock都释放）</li></ul><h3 id="实现思路">实现思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockManager handles transactions asking for locks on records.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockManager</span> &#123;</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">LockMode</span> &#123; SHARED, EXCLUSIVE &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LockRequest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockRequest</span>(<span class="type">txn_id_t</span> txn_id, LockMode lock_mode) : <span class="built_in">txn_id_</span>(txn_id), <span class="built_in">lock_mode_</span>(lock_mode), <span class="built_in">granted_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">txn_id_t</span> txn_id_;</span><br><span class="line">    LockMode lock_mode_;</span><br><span class="line">    <span class="type">bool</span> granted_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    std::list&lt;LockRequest&gt; request_queue_;</span><br><span class="line">    std::condition_variable cv_;  <span class="comment">// for notifying blocked transactions on this rid</span></span><br><span class="line">    <span class="comment">// 保护这个queue的锁</span></span><br><span class="line">    std::mutex queueLatch_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * [LOCK_NOTE]: For all locking functions, we:</span></span><br><span class="line"><span class="comment">   * 1. return false if the transaction is aborted; and</span></span><br><span class="line"><span class="comment">   * 2. block on wait, return true when the lock request is granted; and</span></span><br><span class="line"><span class="comment">   * 3. it is undefined behavior to try locking an already locked RID in the same transaction, i.e. the transaction</span></span><br><span class="line"><span class="comment">   *    is responsible for keeping track of its current locks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquire a lock on RID in shared mode. See [LOCK_NOTE] in header file.</span></span><br><span class="line"><span class="comment">   * @param txn the transaction requesting the shared lock</span></span><br><span class="line"><span class="comment">   * @param rid the RID to be locked in shared mode</span></span><br><span class="line"><span class="comment">   * @return true if the lock is granted, false otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">LockShared</span><span class="params">(Transaction *txn, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquire a lock on RID in exclusive mode. See [LOCK_NOTE] in header file.</span></span><br><span class="line"><span class="comment">   * @param txn the transaction requesting the exclusive lock</span></span><br><span class="line"><span class="comment">   * @param rid the RID to be locked in exclusive mode</span></span><br><span class="line"><span class="comment">   * @return true if the lock is granted, false otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">LockExclusive</span><span class="params">(Transaction *txn, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Upgrade a lock from a shared lock to an exclusive lock.</span></span><br><span class="line"><span class="comment">   * @param txn the transaction requesting the lock upgrade</span></span><br><span class="line"><span class="comment">   * @param rid the RID that should already be locked in shared mode by the requesting transaction</span></span><br><span class="line"><span class="comment">   * @return true if the upgrade is successful, false otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">LockUpgrade</span><span class="params">(Transaction *txn, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Release the lock held by the transaction.</span></span><br><span class="line"><span class="comment">   * @param txn the transaction releasing the lock, it should actually hold the lock</span></span><br><span class="line"><span class="comment">   * @param rid the RID that is locked by the transaction</span></span><br><span class="line"><span class="comment">   * @return true if the unlock is successful, false otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Unlock</span><span class="params">(Transaction *txn, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex latch_;</span><br><span class="line">  <span class="comment">/** Lock table for lock requests. */</span></span><br><span class="line">  std::unordered_map&lt;RID, LockRequestQueue&gt; lock_table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从实现角度来看怎么实现的吧~</p><p>这是最为关键的数据结构：</p><p>对于每个RID，也就是每个tuple，都有一个对应的锁请求队列LockRequestQueue。LockRequestQueue使用一个list&lt; LockRequest &gt; request_queue_来存储当前对该RID对应的tuple的请求。</p><p>一个请求LockRequest主要记录有发出该请求的txn_id, 请求的是哪类的锁，以及该请求是否已经被授予。一个LockRequestQueue中可能有一个或多个请求已经被授予锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Structure that holds lock requests for a given table oid */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">table_oid_t</span>, std::shared_ptr&lt;LockRequestQueue&gt;&gt; table_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex table_lock_map_latch_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Structure that holds lock requests for a given RID */</span></span><br><span class="line">std::unordered_map&lt;RID, std::shared_ptr&lt;LockRequestQueue&gt;&gt; row_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex row_lock_map_latch_;</span><br></pre></td></tr></table></figure><p>LockRequest和LockRequestQueue的数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">LockRequest</span>(<span class="type">txn_id_t</span> txn_id, LockMode lock_mode, <span class="type">table_oid_t</span> oid) <span class="comment">/** Table lock request */</span></span><br><span class="line">       : <span class="built_in">txn_id_</span>(txn_id), <span class="built_in">lock_mode_</span>(lock_mode), <span class="built_in">oid_</span>(oid) &#123;&#125;</span><br><span class="line">   <span class="built_in">LockRequest</span>(<span class="type">txn_id_t</span> txn_id, LockMode lock_mode, <span class="type">table_oid_t</span> oid, RID rid) <span class="comment">/** Row lock request */</span></span><br><span class="line">       : <span class="built_in">txn_id_</span>(txn_id), <span class="built_in">lock_mode_</span>(lock_mode), <span class="built_in">oid_</span>(oid), <span class="built_in">rid_</span>(rid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Txn_id of the txn requesting the lock */</span></span><br><span class="line">   <span class="type">txn_id_t</span> txn_id_;</span><br><span class="line">   <span class="comment">/** Locking mode of the requested lock */</span></span><br><span class="line">   LockMode lock_mode_;</span><br><span class="line">   <span class="comment">/** Oid of the table for a table lock; oid of the table the row belong to for a row lock */</span></span><br><span class="line">   <span class="type">table_oid_t</span> oid_;</span><br><span class="line">   <span class="comment">/** Rid of the row for a row lock; unused for table locks */</span></span><br><span class="line">   RID rid_;</span><br><span class="line">   <span class="comment">/** Whether the lock has been granted or not */</span></span><br><span class="line">   <span class="type">bool</span> granted_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/** List of lock requests for the same resource (table or row) */</span></span><br><span class="line">   std::list&lt;std::shared_ptr&lt;LockRequest&gt;&gt; request_queue_;</span><br><span class="line">   <span class="comment">/** For notifying blocked transactions on this rid */</span></span><br><span class="line">   std::condition_variable cv_;</span><br><span class="line">   <span class="comment">/** txn_id of an upgrading transaction (if any) */</span></span><br><span class="line">   <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">   <span class="comment">/** coordination */</span></span><br><span class="line">   std::mutex latch_;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p><strong>每个LockRequestQueue中我都增加了一个mutex来保护LockRequestQueue，one mutex per tuple的方案</strong></p><p>《数据库系统概念》</p><p>锁管理器( lock manager)可以实现为一个过程，它从事务接受消息并反馈消息。锁管理器过程针对锁请求消息返回授予锁消息，或者要求事务回滚的消息(发生死锁时)。解锁消息只需要得到一个确认回答，但可能引发为其他等待事务的授予锁消息。</p><p>锁管理器使用以下数据结构:锁管理器为目前已加锁的每个数据项维护一个链表，每一个请求为链表中一条记录，按请求到达的顺序排序。它使用一个以数据项名称为索引的散列表来查找链表中的数据项(如果有的话);这个表叫做锁表( locktable)。一个数据项的链表中每一条记录表示由哪个事务提出的请求,以及它请求什么类型的锁,该记录还表示该请求是否已授予锁。</p><p>图15-10是一个锁表的示例,该表包含5个不同数据项4、I7、123、44和I912的锁。锁表采用溢出链，因此对于锁表的每一个表项都有一个数据项的链表。每一个数据项都有一个已授予锁或等待授予锁的事务列表，已授予锁的事务用深色阴影方块表示，等待授予锁的事务则用浅色阴影方块表示。为了简化图形我们省略了锁的类型。举个例子，从图15-10中可以看到,T23在数据项1912和7上已被授予锁,并且正在等待在4上加锁。</p><p>虽然图15-10上没有标示出来,但锁表还应当维护一个基于事务标识符的索引,这样它可以有效地确定给定事务持有的锁集。</p><p>锁管理器这样处理请求:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828170430457.png" alt="image-20240828170430457"></p><ul><li>当一条锁请求消息到达时，如果相应数据项的链表存在，在该链表末尾增加一个记录;否则,新建一个仅包含该请求记录的链表。<ul><li>在当前没有加锁的数据项上总是授予第一次加锁请求，但当事务向已被加锁的数据项申请加锁时，只有当该请求与当前持有的锁相容，并且所有先前的请求都已授予锁的条件下，锁管理器才为该请求授予锁,否则,该请求只好等待。</li></ul></li><li>当锁管理器收到一个事务的解锁消息时，它将与该事务相对应的数据项链表中的记录删除，然后检查随后的记录，如果有，如前所述，就看该请求能否被授权，如果能，锁管理器授权该请求并处理其后记录，如果还有，类似地一个接一个地处理。</li><li>如果一个事务中止，锁管理器删除该事务产生的正在等待加锁的所有请求。一旦数据库系统采取适当动作撤销该事务(见16.3节)，该中止事务持有的所有锁将被释放。</li></ul><p><strong>这个算法保证了锁请求无饿死现象</strong>，因为在先前接收到的请求正在等待加锁时，后来者不可能获得授权。我们稍后将在15.2.2节学习检测和处理死锁。17.2.1节阐述另一个实现——在锁申请/授权上利用共享内存取代消息传递。</p><p><strong>同一个RID的多条锁请求按请求的先后次序存入request_queue_中。对于每个请求，只有该请求与当前持有的锁相容且队列中在它之前的所有请求都获取了锁的条件下才能授予该请求锁</strong>。这能保证没有饿死现象出现。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828184123074.png" alt="image-20240828184123074"></p><p>OK！有了上述的理论基础！</p><p>我们来看一下这个代码应该如何实现</p><blockquote><p><strong>LockTable</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步：判断事务状态[第一步保证了锁请求、事务状态、事务隔离级别的兼容]</span></span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::READ_UNCOMMITTED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock_mode == LockMode::SHARED || lock_mode == LockMode::INTENTION_SHARED ||</span><br><span class="line">        lock_mode == LockMode::SHARED_INTENTION_EXCLUSIVE) &#123;</span><br><span class="line">      txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TransactionAbortException</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), AbortReason::LOCK_SHARED_ON_READ_UNCOMMITTED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::SHRINKING &amp;&amp;</span><br><span class="line">        (lock_mode == LockMode::EXCLUSIVE || lock_mode == LockMode::INTENTION_EXCLUSIVE)) &#123;</span><br><span class="line">      txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TransactionAbortException</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), AbortReason::LOCK_ON_SHRINKING);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::READ_COMMITTED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::SHRINKING &amp;&amp; lock_mode != LockMode::INTENTION_SHARED &amp;&amp;</span><br><span class="line">        lock_mode != LockMode::SHARED) &#123;</span><br><span class="line">      txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TransactionAbortException</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), AbortReason::LOCK_ON_SHRINKING);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::REPEATABLE_READ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::SHRINKING) &#123;</span><br><span class="line">      txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TransactionAbortException</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), AbortReason::LOCK_ON_SHRINKING);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步，获取 table 对应的 lock request queue。</span></span><br><span class="line">  <span class="comment">// 获取共享队列</span></span><br><span class="line"></span><br><span class="line">  table_lock_map_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (!table_lock_map_[oid]) &#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    table_lock_map_[oid] = std::<span class="built_in">make_shared</span>&lt;LockRequestQueue&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> lock_request_queue = table_lock_map_.<span class="built_in">find</span>(oid)-&gt;second;</span><br><span class="line">  lock_request_queue-&gt;latch_.<span class="built_in">lock</span>();</span><br><span class="line">  table_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">  <span class="comment">// 第三步，检查此锁请求是否为一次锁升级。</span></span><br><span class="line">  <span class="comment">// 遍历队列，查看是否有当前事务</span></span><br><span class="line">  <span class="type">bool</span> is_update = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// std::cout&lt;&lt; lock_request_queue-&gt;request_queue_.size()&lt;&lt;std::endl;</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;查看此时指向共享指针的计数&quot;&lt;&lt;lock_request_queue.use_count() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : lock_request_queue-&gt;request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果当前事务与请求上锁一致，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (iter-&gt;lock_mode_ == lock_mode) &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock_request_queue-&gt;latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// check一下锁升级是否合法</span></span><br><span class="line">      <span class="comment">// 1.判断是否有其他事务再升级</span></span><br><span class="line">      <span class="comment">// 当前有其他事务在升级,不允许多个事务在同一资源上同时尝试锁升级</span></span><br><span class="line">      <span class="keyword">if</span> (lock_request_queue-&gt;upgrading_ != INVALID_TXN_ID) &#123;</span><br><span class="line">        <span class="comment">// 队列解锁</span></span><br><span class="line">        lock_request_queue-&gt;latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="comment">// 设置事务为中止</span></span><br><span class="line">        txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TransactionAbortException</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), AbortReason::UPGRADE_CONFLICT);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2.判断锁升级是否符合要求</span></span><br><span class="line">      <span class="keyword">if</span> (!(iter-&gt;lock_mode_ == LockMode::INTENTION_SHARED &amp;&amp;</span><br><span class="line">            (lock_mode == LockMode::SHARED || lock_mode == LockMode::EXCLUSIVE ||</span><br><span class="line">             lock_mode == LockMode::INTENTION_EXCLUSIVE || lock_mode == LockMode::SHARED_INTENTION_EXCLUSIVE)) &amp;&amp;</span><br><span class="line">          !(iter-&gt;lock_mode_ == LockMode::SHARED &amp;&amp;</span><br><span class="line">            (lock_mode == LockMode::EXCLUSIVE || lock_mode == LockMode::SHARED_INTENTION_EXCLUSIVE)) &amp;&amp;</span><br><span class="line">          !(iter-&gt;lock_mode_ == LockMode::INTENTION_EXCLUSIVE &amp;&amp;</span><br><span class="line">            (lock_mode == LockMode::EXCLUSIVE || lock_mode == LockMode::SHARED_INTENTION_EXCLUSIVE)) &amp;&amp;</span><br><span class="line">          !(iter-&gt;lock_mode_ == LockMode::SHARED_INTENTION_EXCLUSIVE &amp;&amp; (lock_mode == LockMode::EXCLUSIVE))) &#123;</span><br><span class="line">        lock_request_queue-&gt;latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TransactionAbortException</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), AbortReason::INCOMPATIBLE_UPGRADE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过上述的chenck -&gt; current 符合锁升级条件</span></span><br><span class="line">      <span class="comment">// 标记一下当前事务正在升级</span></span><br><span class="line">      lock_request_queue-&gt;upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">      is_update = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 1.从事务中对应的锁队列中删除</span></span><br><span class="line">      std::shared_ptr&lt;std::unordered_set&lt;<span class="type">table_oid_t</span>&gt;&gt; cur;</span><br><span class="line">      <span class="keyword">if</span> (iter-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">        cur = txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;lock_mode_ == LockMode::INTENTION_EXCLUSIVE) &#123;</span><br><span class="line">        cur = txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;lock_mode_ == LockMode::INTENTION_SHARED) &#123;</span><br><span class="line">        cur = txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;lock_mode_ == LockMode::SHARED) &#123;</span><br><span class="line">        cur = txn-&gt;<span class="built_in">GetSharedTableLockSet</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;lock_mode_ == LockMode::SHARED_INTENTION_EXCLUSIVE) &#123;</span><br><span class="line">        cur = txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      cur-&gt;<span class="built_in">erase</span>(oid);</span><br><span class="line">      <span class="comment">// 2.释放当前已经持有的锁,[在request_queue_队列中移除]</span></span><br><span class="line">      lock_request_queue-&gt;request_queue_.<span class="built_in">remove</span>(iter);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四步，将锁请求加入请求队列 , Note:new一个是否要释放的pro =&gt;改成智能指针的写法</span></span><br><span class="line">  <span class="keyword">auto</span> lock_request = std::<span class="built_in">make_shared</span>&lt;LockRequest&gt;(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid);</span><br><span class="line">  <span class="keyword">if</span> (is_update) &#123;</span><br><span class="line">    std::list&lt;std::shared_ptr&lt;LockRequest&gt;&gt;::iterator lr_iter;</span><br><span class="line">    <span class="keyword">for</span> (lr_iter = lock_request_queue-&gt;request_queue_.<span class="built_in">begin</span>(); lr_iter != lock_request_queue-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">         lr_iter++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*lr_iter)-&gt;granted_) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lock_request_queue-&gt;request_queue_.<span class="built_in">insert</span>(lr_iter, lock_request);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lock_request_queue-&gt;request_queue_.<span class="built_in">push_back</span>(lock_request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第五步，尝试获取锁。</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;transaction_ID&quot; &lt;&lt; txn-&gt;GetTransactionId() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lock_request_queue-&gt;latch_, std::adopt_lock)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">GrantLockForTable</span>(lock_request_queue, lock_request)) &#123;</span><br><span class="line">    lock_request_queue-&gt;cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="comment">// 如果当前事务是需要更新的话，就应该将其设置为初始化的值</span></span><br><span class="line">      <span class="keyword">if</span> (is_update) &#123;</span><br><span class="line">        lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">      &#125;</span><br><span class="line">      lock_request_queue-&gt;request_queue_.<span class="built_in">remove</span>(lock_request);</span><br><span class="line">      lock_request_queue-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// lock_request_queue-&gt;latch_.unlock();</span></span><br><span class="line">  <span class="comment">// 如果更新完成的话，标记一下  grant and upgrade function =&gt;  GrantLockForTable()</span></span><br><span class="line">  <span class="keyword">if</span> (is_update) &#123;</span><br><span class="line">    lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">  &#125;</span><br><span class="line">  lock_request-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 更新事务维护的锁集合</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lock_mode == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">insert</span>(oid);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lock_mode == LockMode::INTENTION_EXCLUSIVE) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">insert</span>(oid);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lock_mode == LockMode::INTENTION_SHARED) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">insert</span>(oid);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lock_mode == LockMode::SHARED) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">insert</span>(oid);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lock_mode == LockMode::SHARED_INTENTION_EXCLUSIVE) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">insert</span>(oid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// table_lock_map_.find(oid)-&gt;second = lock_request_queue ;</span></span><br><span class="line">  <span class="keyword">if</span> (lock_mode != LockMode::EXCLUSIVE) &#123;</span><br><span class="line">    lock_request_queue-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出上述GrantLockForTable函数代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::GrantLockForTable</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;LockRequestQueue&gt; &amp;lock_request_queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> std::shared_ptr&lt;LockRequest&gt; &amp;lock_request)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::cout&lt;&lt;&quot;================table lock check start!==============&quot;&lt;&lt;std::endl;</span></span><br><span class="line">  <span class="comment">// 判断兼容性</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; lock_request-&gt;txn_id_ &lt;&lt; &quot; &quot; &lt;&lt; lock_request_queue-&gt;request_queue_.size() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : lock_request_queue-&gt;request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;granted_) &#123;</span><br><span class="line">      <span class="comment">// std::cout &lt;&lt; &quot;current:tid&quot;&lt;&lt;iter-&gt;txn_id_&lt;&lt;&quot;:check==&gt;&quot;&lt;&lt;(int)(iter-&gt;lock_mode_)&lt;&lt;&quot;</span></span><br><span class="line">      <span class="comment">// &quot;&lt;&lt;(int)(lock_request-&gt;lock_mode_)&lt;&lt;std::endl;</span></span><br><span class="line">      <span class="comment">// std::cout&lt;&lt;&quot;current:tid&quot;&lt;&lt;iter-&gt;txn_id_&lt;&lt;&quot;:check==&gt;&quot;&lt;&lt;(int)(iter-&gt;lock_mode_)&lt;&lt;&quot;</span></span><br><span class="line">      <span class="comment">// &quot;&lt;&lt;(int)(lock_request-&gt;lock_mode_)&lt;&lt;&quot; &quot;; std::cout&lt;&lt;CheckTale(lock_request-&gt;lock_mode_,</span></span><br><span class="line">      <span class="comment">// iter-&gt;lock_mode_)&lt;&lt;std::endl;</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">CheckTale</span>(lock_request-&gt;lock_mode_, iter-&gt;lock_mode_)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// if (!CheckTale( lock_request-&gt;lock_mode_,iter-&gt;lock_mode_)) &#123;</span></span><br><span class="line">      <span class="comment">//   // std::cout &lt;&lt; &quot;CheckTaleFail~~~current:tid&quot;&lt;&lt;iter-&gt;txn_id_&lt;&lt;&quot;:check==&gt;&quot;&lt;&lt;(int)(lock_request-&gt;lock_mode_)&lt;&lt;&quot;</span></span><br><span class="line">      <span class="comment">//   &quot;&lt;&lt;(int)(iter-&gt;lock_mode_)&lt;&lt;std::endl; return false;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter.<span class="built_in">get</span>() != lock_request.<span class="built_in">get</span>() &amp;&amp; lock_request_queue-&gt;upgrading_ != lock_request-&gt;txn_id_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// std::cout&lt;&lt;&quot;fuck1&quot;&lt;&lt;std::endl;</span></span><br><span class="line">  <span class="comment">// 判断优先级</span></span><br><span class="line">  <span class="comment">// 存在锁升级</span></span><br><span class="line">  <span class="comment">// if (lock_request_queue-&gt;upgrading_ != INVALID_TXN_ID) &#123;</span></span><br><span class="line">  <span class="comment">//   // 并且就是当前锁</span></span><br><span class="line">  <span class="comment">//   if (lock_request_queue-&gt;upgrading_ == lock_request-&gt;txn_id_) &#123;</span></span><br><span class="line">  <span class="comment">//     // 授予锁，将grant标记为true</span></span><br><span class="line">  <span class="comment">//     // for(auto &amp;iter:lock_request_queue-&gt;request_queue_)&#123;</span></span><br><span class="line">  <span class="comment">//     //   if(iter-&gt;txn_id_ == lock_request-&gt;txn_id_)&#123;</span></span><br><span class="line">  <span class="comment">//     //     iter-&gt;granted_ = true;</span></span><br><span class="line">  <span class="comment">//     //     break;</span></span><br><span class="line">  <span class="comment">//     //   &#125;</span></span><br><span class="line">  <span class="comment">//     // &#125;</span></span><br><span class="line">  <span class="comment">//     lock_request-&gt;granted_ = true;</span></span><br><span class="line">  <span class="comment">//     // 由于是锁升级，升级完成置为初始化</span></span><br><span class="line">  <span class="comment">//     lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;</span></span><br><span class="line">  <span class="comment">//     return true;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   return false;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 不存在锁升级</span></span><br><span class="line">  <span class="comment">// 判断是否是第一个wait的[unused]</span></span><br><span class="line">  <span class="comment">// int num = 1;</span></span><br><span class="line">  <span class="comment">// for (auto &amp;iter : lock_request_queue-&gt;request_queue_) &#123;</span></span><br><span class="line">  <span class="comment">//   if (!iter-&gt;granted_) &#123;</span></span><br><span class="line">  <span class="comment">//     if (iter-&gt;txn_id_ == lock_request-&gt;txn_id_) &#123;</span></span><br><span class="line">  <span class="comment">//       break;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     num = 0;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   if (num == 0) &#123;</span></span><br><span class="line">  <span class="comment">//     break;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// if (num == 1) &#123;</span></span><br><span class="line">  <span class="comment">//   // 授予锁，将grant标记为true</span></span><br><span class="line">  <span class="comment">//   // for(auto iter:request_queue_)&#123;</span></span><br><span class="line">  <span class="comment">//   //   if(iter-&gt;txn_id_ == txn-&gt;GetTransactionId())&#123;</span></span><br><span class="line">  <span class="comment">//   //     iter-&gt;granted_ = true;</span></span><br><span class="line">  <span class="comment">//   //     break;</span></span><br><span class="line">  <span class="comment">//   //   &#125;</span></span><br><span class="line">  <span class="comment">//   // &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   lock_request-&gt;granted_ = true;</span></span><br><span class="line">  <span class="comment">//   if (lock_request_queue-&gt;upgrading_ == lock_request-&gt;txn_id_) &#123;</span></span><br><span class="line">  <span class="comment">//     lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   return true;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return false;</span></span><br><span class="line">  <span class="comment">// 判断是否和之前wait的锁是否兼容</span></span><br><span class="line">  <span class="comment">// bool flag = true;</span></span><br><span class="line">  <span class="comment">// for (auto &amp;iter : lock_request_queue-&gt;request_queue_) &#123;</span></span><br><span class="line">  <span class="comment">//   if (iter-&gt;txn_id_ == lock_request-&gt;txn_id_) &#123;</span></span><br><span class="line">  <span class="comment">//     break;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   if (!iter-&gt;granted_) &#123;</span></span><br><span class="line">  <span class="comment">//     if (!CheckTale( iter-&gt;lock_mode_,lock_request-&gt;lock_mode_)) &#123;</span></span><br><span class="line">  <span class="comment">//       flag = false;</span></span><br><span class="line">  <span class="comment">//       break;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// if (flag) &#123;</span></span><br><span class="line">  <span class="comment">//   // 授予锁，将grant标记为true</span></span><br><span class="line">  <span class="comment">//   // for(auto &amp;iter:lock_request_queue-&gt;request_queue_)&#123;</span></span><br><span class="line">  <span class="comment">//   //   if(iter-&gt;txn_id_ == lock_request-&gt;txn_id_)&#123;</span></span><br><span class="line">  <span class="comment">//   //     iter-&gt;granted_ = true;</span></span><br><span class="line">  <span class="comment">//   //     break;</span></span><br><span class="line">  <span class="comment">//   //   &#125;</span></span><br><span class="line">  <span class="comment">//   // &#125;</span></span><br><span class="line">  <span class="comment">//   lock_request-&gt;granted_ = true;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// // std::cout&lt;&lt;&quot;================table lock check end!==============&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return flag;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 事务状态判断与隔离级别检查</strong></p><p>首先，代码根据事务的隔离级别和当前状态，对锁请求进行初步的检查，以确保兼容性：</p><ul><li><strong>READ_UNCOMMITTED</strong>: 如果事务的隔离级别是未提交读（<code>READ_UNCOMMITTED</code>），则该事务不能申请共享锁（<code>SHARED</code>）或意向共享锁（<code>INTENTION_SHARED</code>）等。否则，事务会被中止（<code>ABORTED</code>），并抛出异常。</li><li><strong>SHRINKING 状态检查</strong>: 对于处于“收缩”（<code>SHRINKING</code>）状态的事务，不能再申请排他锁（<code>EXCLUSIVE</code>）或意向排他锁（<code>INTENTION_EXCLUSIVE</code>），否则会导致事务中止。</li><li><strong>READ_COMMITTED 和 REPEATABLE_READ</strong>: 对于提交读（<code>READ_COMMITTED</code>）和可重复读（<code>REPEATABLE_READ</code>）隔离级别的事务，代码检查如果事务处于收缩状态，并且请求了不兼容的锁类型，也会中止事务。</li></ul><p><strong>2. 获取表对应的锁请求队列</strong></p><ul><li><strong>锁请求队列的获取</strong>: 使用全局锁（<code>table_lock_map_latch_</code>）保护对<code>table_lock_map_</code>的访问。<code>table_lock_map_</code>用于存储表OID（对象ID）与锁请求队列之间的映射。如果对应的表还没有锁请求队列，则为其创建一个。</li><li><strong>队列锁定</strong>: 在获取或创建锁请求队列后，代码会锁定该队列（<code>latch_</code>），以防止其他事务在这个过程中修改队列。</li></ul><p><strong>3. 检查锁升级请求</strong></p><ul><li><strong>锁升级检查</strong>: 代码会检查当前事务是否已经持有锁，如果持有，则检查该锁是否与新的锁请求相同。如果相同，则直接返回<code>true</code>，表示锁请求成功。</li><li><strong>锁升级冲突处理</strong>: 如果当前有其他事务正在尝试升级同一资源上的锁，当前事务会被中止，因为不允许多个事务同时尝试升级锁。</li><li><strong>锁升级合法性检查</strong>: 检查锁升级是否符合规定，比如从共享锁（<code>SHARED</code>）升级到排他锁（<code>EXCLUSIVE</code>）是否允许等。如果不符合规定，事务也会被中止。</li><li><strong>锁升级流程</strong>: 如果检查通过，当前事务将被标记为正在升级锁，并移除事务原来持有的锁。</li></ul><p><strong>4. 将锁请求加入请求队列</strong></p><ul><li><strong>锁请求的创建和插入</strong>: 根据是否为锁升级，代码会将新的锁请求插入到锁请求队列中**。对于锁升级请求，新的锁请求会被插入到未被授予的锁请求之前；对于非升级请求，则直接加入队列末尾。**</li></ul><p><strong>5. 尝试获取锁</strong></p><ul><li><strong>锁的授予</strong>: 通过<code>GrantLockForTable</code>函数尝试授予锁。如果锁不能立即授予，当前线程会等待（使用条件变量<code>cv_</code>）。</li><li><strong>锁请求失败处理</strong>: 如果事务在等待期间被中止，代码会清除相应的锁请求，并唤醒等待中的其他事务。</li><li><strong>锁授予成功后</strong>: 如果锁请求成功，锁请求会被标记为已授予（<code>granted_</code>），并且事务对应的锁集合（根据锁类型）会被更新。</li></ul><p><strong>6. 通知其他等待中的事务</strong></p><ul><li><strong>通知机制</strong>: 如果当前锁请求是非排他锁，代码会在成功授予锁后通知其他等待中的事务（<code>cv_.notify_all()</code>），让它们有机会获取锁。</li></ul><blockquote><p><strong>UnlockTable</strong></p></blockquote><p><code>UnlockTable</code> 用于在事务中解锁表锁。详细步骤如下,有兴趣的·可以结合思路自己实现。</p><ol><li><strong>获取锁请求队列</strong>：<ul><li>通过 <code>table_lock_map_latch_</code> 锁住 <code>table_lock_map_</code>，以防止其他线程同时访问和修改这个锁映射表。</li><li>代码中的 <code>table_lock_map_</code> 是一个包含表锁请求队列的映射，它将表的 OID 映射到相应的锁请求队列。</li></ul></li><li><strong>检查表中的行锁状态</strong>：<ul><li>首先检查事务的 <code>SharedRowLockSet</code> 和 <code>ExclusiveRowLockSet</code>，确定是否存在行锁未被释放的情况。</li><li>如果事务中有尚未释放的行锁（即行锁集合中包含表 OID 或者集合非空），则解锁映射表，并将事务状态设置为 <code>ABORTED</code>（终止状态），然后抛出 <code>TransactionAbortException</code> 异常，原因是尝试在行锁解锁前解锁表锁。</li></ul></li><li><strong>检查表锁请求队列是否存在</strong>：<ul><li>如果 <code>table_lock_map_</code> 中并未找到对应的表锁请求队列（即没有表锁的记录），则同样解锁映射表，并将事务状态设置为 <code>ABORTED</code>，抛出 <code>TransactionAbortException</code> 异常，原因是尝试解锁时没有持有该表的锁。</li></ul></li><li><strong>遍历锁请求队列</strong>：<ul><li>找到表的锁请求队列后，获取队列的锁 <code>latch_</code>，然后解锁映射表 <code>table_lock_map_latch_</code>，以便其他线程访问。</li><li>遍历锁请求队列中的每个请求 <code>iter</code>，找到与当前事务 ID 相匹配的锁请求。</li></ul></li><li><strong>检查锁是否已授予</strong>：<ul><li>如果找到匹配的锁请求，且该锁请求尚未被授予（即 <code>granted_</code> 为 <code>false</code>），则解锁队列并将事务状态设置为 <code>ABORTED</code>，然后抛出 <code>TransactionAbortException</code> 异常，原因是试图解锁时没有持有该锁。</li></ul></li><li><strong>检查事务的隔离级别并更新事务状态</strong>：<ul><li>根据事务的隔离级别（如 <code>REPEATABLE_READ</code>、<code>READ_COMMITTED</code> 或 <code>READ_UNCOMMITTED</code>）以及锁模式（如共享锁 <code>SHARED</code> 或排他锁 <code>EXCLUSIVE</code>），更新事务状态为 <code>SHRINKING</code>。这通常意味着事务已进入减少锁范围的阶段，在某些隔离级别下解锁表时，事务会进入这个状态。</li></ul></li><li><strong>从锁集合和请求队列中删除锁</strong>：<ul><li>根据锁模式，将表 OID 从事务的相应表锁集合中删除（如 <code>ExclusiveTableLockSet</code>、<code>SharedTableLockSet</code> 等）。</li><li>然后从锁请求队列中删除该锁请求 <code>iter</code>。</li></ul></li><li><strong>唤醒等待线程</strong>：<ul><li>删除锁请求后，调用 <code>notify_all()</code> 唤醒等待该表锁的所有线程，以便其他事务可以尝试获取表锁。</li></ul></li><li><strong>解锁并返回</strong>：<ul><li>最后，解锁请求队列的锁 <code>latch_</code> 并返回 <code>true</code>，表示表锁成功解锁。</li></ul></li><li><strong>处理不存在锁的情况</strong>：</li></ol><ul><li>如果遍历锁请求队列后，发现没有与当前事务 ID 匹配的锁请求，则解锁队列，将事务状态设置为 <code>ABORTED</code>，并抛出 <code>TransactionAbortException</code> 异常，原因是试图解锁时没有持有该锁。</li></ul><blockquote><p><strong>LockRow</strong></p></blockquote><p>给出LockRow的实现思路，详细步骤如下,有兴趣的·可以结合思路自己实现。</p><p><strong>1. 初步检查事务状态和锁模式</strong></p><ul><li>首先，代码对事务的状态进行检查。如果事务已经处于<code>ABORTED</code>（中止）或<code>COMMITTED</code>（提交）状态，抛出一个异常，表示逻辑错误。</li><li>接着，代码检查行级别的锁类型。行级别的锁只支持共享锁（<code>SHARED</code>）和排他锁（<code>EXCLUSIVE</code>），如果请求的锁类型不符合条件，事务会被设置为<code>ABORTED</code>状态，并抛出一个<code>TransactionAbortException</code>异常，表示尝试在行级别申请无效的锁。</li></ul><p><strong>2. 检查表级别的锁是否存在</strong></p><ul><li>如果申请的是共享锁（<code>SHARED</code>），需要检查事务是否在表级别持有适当的锁（如<code>EXCLUSIVE</code>、<code>INTENTION_EXCLUSIVE</code>、<code>INTENTION_SHARED</code>等）。如果没有持有相应的表锁，事务将被中止，并抛出<code>TransactionAbortException</code>异常。</li><li>对于排他锁（<code>EXCLUSIVE</code>），要求事务在表级别至少持有<code>EXCLUSIVE</code>、<code>INTENTION_EXCLUSIVE</code>或<code>SHARED_INTENTION_EXCLUSIVE</code>锁，否则事务也会被中止并抛出异常。</li></ul><p><strong>3. 根据隔离级别判断事务状态</strong></p><ul><li>对于<code>READ_UNCOMMITTED</code>隔离级别，事务不能申请共享锁，且在处于“收缩阶段”（<code>SHRINKING</code>）时不能申请排他锁或意向锁。</li><li>对于<code>READ_COMMITTED</code>隔离级别，在“收缩阶段”只能申请共享锁或意向共享锁，其他锁申请会导致事务中止。</li><li>对于<code>REPEATABLE_READ</code>隔离级别，事务在“收缩阶段”不能申请任何锁，否则会导致事务中止。</li></ul><p><strong>4. 获取行的锁请求队列</strong></p><ul><li>使用一个全局互斥锁<code>row_lock_map_latch_</code>来保护<code>row_lock_map_</code>，确保在访问和修改行锁请求队列时的线程安全。</li><li>如果指定的行<code>rid</code>还没有锁请求队列，则为其创建一个新的锁请求队列，并将其插入到<code>row_lock_map_</code>中。</li><li>之后，锁定该行的锁请求队列以进一步处理锁请求。</li></ul><p><strong>5. 检查锁升级情况</strong></p><ul><li>遍历锁请求队列，检查当前事务是否已经在该行上申请了锁。如果发现已有锁：<ul><li>如果现有锁模式与请求的锁模式一致，则直接返回<code>true</code>，表示锁请求成功。</li><li>如果需要进行锁升级，则需要确保锁升级是合法的。例如，检查当前是否已有其他事务正在进行锁升级，如果有则中止当前事务。</li><li>锁升级还需要检查当前锁与目标锁模式的兼容性。如果不兼容，事务将被中止并抛出异常。</li></ul></li></ul><p><strong>6. 处理锁升级</strong></p><ul><li>如果需要进行锁升级，标记当前事务正在进行升级操作，并从事务的行锁集合中移除旧的锁。</li><li>在锁请求队列中删除旧的锁请求，并为事务创建新的锁请求，将其插入锁请求队列的合适位置。</li></ul><p><strong>7. 尝试获取锁</strong></p><ul><li>将新创建的锁请求添加到锁请求队列中后，尝试为事务授予锁。如果未能立即获取锁，则等待条件变量（<code>cv_</code>）的通知，直到锁被授予或事务被中止。</li><li>如果事务在等待过程中被中止，锁请求将被从队列中移除，通知其他等待的事务重新尝试获取锁，并返回<code>false</code>表示锁申请失败。</li></ul><p><strong>8. 更新事务的行锁集合</strong></p><ul><li>锁成功授予后，将锁请求标记为granted_，并更新事务管理的行锁集合：<ul><li>如果是排他锁（<code>EXCLUSIVE</code>），将行ID添加到事务的排他锁集合中。</li><li>如果是共享锁（<code>SHARED</code>），将行ID添加到事务的共享锁集合中。</li></ul></li></ul><p><strong>9. 释放锁和通知</strong></p><ul><li>如果成功授予的锁不是排他锁，通知其他等待该行锁的事务，尝试获取锁。</li></ul><p>最终，函数返回<code>true</code>表示锁申请成功。</p><p>由于在上述的过程中可能会出现死锁。死锁其实就是事务间彼此依赖成环，他们都在等待对面释放他们锁需要的锁。</p><blockquote><p><strong>补充：MySQL中的间隙锁</strong></p></blockquote><p>只是精简化的版本</p><p>InnoDB 的锁管理器会根据操作的类型决定是加行锁、间隙锁还是 Next-Key Lock。为了锁定区间，InnoDB 需要在 B+ 树索引中找到要锁定的前后记录，并在这两个记录之间加锁。</p><p><strong>3.1 <code>lock_rec_lock()</code> 函数</strong></p><p>InnoDB 中的 <code>lock_rec_lock()</code> 函数负责为指定的记录或区间加锁。这个函数会根据锁的类型（如 Gap Lock）决定锁定单个记录还是锁定区间。</p><p>以下是关键代码片段，展示了如何锁定区间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ulint <span class="title">lock_rec_lock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ulint          mode,    <span class="comment">/* 锁模式：LOCK_S, LOCK_X, ... */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ulint          type,    <span class="comment">/* 锁类型：LOCK_REC, LOCK_GAP, ... */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">dict_index_t</span>*  index,   <span class="comment">/* 要加锁的索引 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ulint          heap_no, <span class="comment">/* 记录在页中的位置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">page_t</span>*        page,    <span class="comment">/* 记录所在的页 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">trx_t</span>*         trx)</span>     <span class="comment">/* 请求锁的事务 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">lock_t</span>* lock;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">mutex_enter</span>(&amp;kernel_mutex);  <span class="comment">// 加锁以保护全局数据结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个新的锁对象 */</span></span><br><span class="line">    lock = <span class="built_in">lock_rec_create</span>(mode, type, index, heap_no, trx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是间隙锁，则锁定前后记录之间的区间 */</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp; LOCK_GAP) &#123;</span><br><span class="line">        <span class="type">rec_t</span>* prev_rec = <span class="built_in">btr_cur_prev_rec</span>(index, page, heap_no);</span><br><span class="line">        <span class="type">rec_t</span>* next_rec = <span class="built_in">btr_cur_next_rec</span>(index, page, heap_no);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 锁定区间 [prev_rec, next_rec) */</span></span><br><span class="line">        <span class="built_in">lock_gap</span>(prev_rec, next_rec, lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将锁添加到事务的锁列表和全局锁表中 */</span></span><br><span class="line">    <span class="built_in">lock_rec_add_to_trx_and_hash</span>(lock, trx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mutex_exit</span>(&amp;kernel_mutex);  <span class="comment">// 释放全局锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(DB_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>mode</code></strong>：指定锁的模式，如共享锁 (<code>LOCK_S</code>) 或排他锁 (<code>LOCK_X</code>)。</li><li><strong><code>type</code></strong>：指定锁的类型，如间隙锁 (<code>LOCK_GAP</code>)。</li><li><strong><code>heap_no</code></strong>：表示记录在页中的位置。</li><li><strong><code>page</code></strong>：记录所在的页，B+ 树索引记录存储在页中。</li><li><strong><code>trx</code></strong>：请求加锁的事务。</li></ul><p><strong>3.2 <code>btr_cur_prev_rec()</code> 和 <code>btr_cur_next_rec()</code> 函数</strong></p><p>这两个函数用于获取当前记录的前后记录。这对于锁定区间（间隙）非常重要，InnoDB 需要知道前后记录的位置，才能锁定它们之间的区间。</p><ul><li><code>btr_cur_prev_rec()</code>：返回当前记录的前一个记录。</li><li><code>btr_cur_next_rec()</code>：返回当前记录的后一个记录。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rec_t</span>* <span class="title function_">btr_cur_prev_rec</span><span class="params">(<span class="type">dict_index_t</span>* index, <span class="type">page_t</span>* page, ulint heap_no)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找前一个记录（逻辑上）</span></span><br><span class="line">    <span class="comment">// 实际代码会考虑页结构和 B+ 树局部性</span></span><br><span class="line">    <span class="keyword">return</span> page_get_prev_rec(index, page, heap_no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">rec_t</span>* <span class="title function_">btr_cur_next_rec</span><span class="params">(<span class="type">dict_index_t</span>* index, <span class="type">page_t</span>* page, ulint heap_no)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找后一个记录（逻辑上）</span></span><br><span class="line">    <span class="keyword">return</span> page_get_next_rec(index, page, heap_no);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.3 <code>lock_gap()</code> 函数</strong></p><p><code>lock_gap</code> 函数负责在前后记录之间的间隙加锁，以防止其他事务在该区间内插入新记录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock_gap</span><span class="params">(<span class="type">rec_t</span> *prev_rec, <span class="type">rec_t</span> *next_rec, <span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="comment">/* 锁定区间 [prev_rec, next_rec) */</span></span><br><span class="line">    lock-&gt;rec_lock_gap_start = prev_rec;</span><br><span class="line">    lock-&gt;rec_lock_gap_end = next_rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置锁的类型为间隙锁 */</span></span><br><span class="line">    lock-&gt;type_mode |= LOCK_GAP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将该锁信息加入到全局锁哈希表中 */</span></span><br><span class="line">    lock_add_to_hash(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>prev_rec</code></strong> 和 <strong><code>next_rec</code></strong>：分别表示前一个记录和下一个记录。</li><li><strong><code>lock_gap()</code></strong>：在这两个记录之间锁定区间。</li></ul><p><strong>死锁的产生需要满足四个必要条件</strong></p><ul><li><p>互斥条件：一个资源每次只能被一个进程使用。</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p>不剥夺条件：已分配给线程的资源，在未使用完之前，不能强行剥夺。</p></li><li><p>循环等待条件：在发生死锁时必然存在一个进程等待队列，其中每个进程都在等待下一个进程所占有的资源，形成一个进程等待环路。</p></li></ul><blockquote><p>核心就是如果事物Ti在等待事物Tj释放锁。则画一条从i–&gt;j的边。如果检测完所有的冲突事务。如果出现环则表示出现了死锁。如果没有环则表示没有死锁。</p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828184742148.png" alt="image-20240828184742148"></p><p>这样形成了一个环就发生了死锁，这个时候就需要abort。</p><p>终止哪些事务呢！</p><p>有以下四种策略判定：</p><p><strong>1. By Age (Lowest Timestamp)</strong></p><ul><li><strong>描述</strong>: 选择拥有最早时间戳的事务。这意味着越早开始的事务越有可能获得优先权。</li><li><strong>优点</strong>: 避免长期运行的事务被饿死，可以确保事务按启动顺序完成。</li></ul><p><strong>2. By Progress (Least/Most Queries Executed)</strong></p><ul><li><strong>描述</strong>: 根据事务已执行的查询数量来决定优先顺序。可以选择执行最少或最多查询的事务。</li><li>优点<ul><li><strong>Least Executed</strong>: 优先处理刚开始的事务，减少资源浪费。</li><li><strong>Most Executed</strong>: 优先完成几乎完成的事务，避免浪费已用的计算资源。</li></ul></li></ul><p><strong>3. By the Number of Items Already Locked</strong></p><ul><li><strong>描述</strong>: 根据事务已经锁定的资源数量来决定优先级。通常，锁定资源较少的事务更容易处理。</li><li><strong>优点</strong>: 减少锁争用，可能提高系统整体吞吐量。</li></ul><p><strong>4. By the Number of Transactions That We Have to Rollback With It</strong></p><ul><li><strong>描述</strong>: 考虑到如果回滚当前事务，需要回滚的其他事务数量。优先处理影响较小的事务。</li><li><strong>优点</strong>: 减少连锁回滚的影响，降低系统恢复的复杂性。</li></ul><p><strong>tip</strong></p><p>MySQL 发现死锁就立即报错，所以使用的是死锁避免方法。</p><p>Postgresql 发现死锁需要等一会儿，所以进行的死锁检测。</p><p><strong>参考资料：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/608324377">https://zhuanlan.zhihu.com/p/608324377</a></li></ul>]]></content>
    
    
    <summary type="html">Lock-Manager</summary>
    
    
    
    <category term="数据库" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Reactor</title>
    <link href="https://penge666.github.io/posts/f34818ed.html"/>
    <id>https://penge666.github.io/posts/f34818ed.html</id>
    <published>2024-08-15T14:26:42.000Z</published>
    <updated>2024-08-29T14:39:01.940Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/x_i_y_u_e/article/details/52301928">Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events</a></p><p>经典论文：《Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events》</p><h2 id="定义">定义</h2><p>有多个输入源，有多个不同的EventHandler（RequestHandler）来处理不同的请求，Initiation Dispatcher用于管理EventHander，EventHandler首先要注册到Initiation Dispatcher中，然后Initiation Dispatcher根据输入的Event分发给注册的EventHandler；然而Initiation Dispatcher并不监听Event的到来，这个工作交给Synchronous Event Demultiplexer来处理。</p><p><strong>补充：事件驱动概念</strong></p><p>事件驱动模式可以将线程与连接分开，连接仅使用线程来处理特定的回调或处理线程上的事件。事件驱动的体系结构由事件生产者和事件消费者组成，生产者是事件的来源，它只知道事件已经产生，而消费者则需要知道事件发生的实体。它们可能参与处理事件，或者它们可能只是受事件的影响。</p><p>事件循环是 Reactor 模式的核心组件，它不断检查事件源的状态，处理已就绪的事件。循环通常以阻塞方式运行，直到有事件发生。</p><h2 id="结构">结构</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828095833200.png" alt="image-20240828095833200"></p><p>**Handle：**即操作系统中的句柄，是操作系统对资源的一种抽象，可以是打开的文件、一个连接(Socket)、Timer等。在网络编程中，一般指Socket Handle，文件描述符（fd）。将这个Handle注册到Synchronous Event Demultiplexer中，就可以它发生的事件，如READ、WRITE、CLOSE等事件。</p><p>**Synchronous Event Demultiplexer：**同步事件多路分用器，本质上是系统调用。比如linux中的select、poll、epoll等。它会一直阻塞直在handle上，直到有事件发生时才会返回。</p><p>**Initiation Dispatcher：**初始分发器，它提供了注册、删除与转发event handler的方法。当Synchronous Event Demultiplexer检测到handle上有事件发生时，便会通知initiation dispatcher调用特定的event handler的回调（handle_event()）方法。</p><p>**Event Handler：事件处理器，**定义事件处理的回调方法：handle_event()，以供InitiationDispatcher回调使用。</p><p>**Concrete Event Handler：**具体的事件处理器，继承自Event Handler，在回调方法中会实现具体的业务逻辑。</p><h2 id="处理流程">处理流程</h2><p>上面说明了Reactor模式中各个角色的作用，他们之间是如何交互的呢？论文以日志服务器（Logging Server）为例，详细讲解了Reactor模式的工作流程。这里总结如下：</p><ol><li><p>注册Concrete Event Handler到Initiation Dispatcher中，当Initiation Dispatcher在某种类型的事件发生发生时向其通知，事件与handle关联。</p></li><li><p>Initiation Dispatcher调用每个Event Handler的get_handle接口获取其绑定的Handle。</p></li><li><p>Initiation Dispatcher调用handle_events开始事件处理循环。在这里，Initiation Dispatcher会将步骤2获取的所有Handle都收集起来，使用Synchronous Event Demultiplexer来等待这些Handle的事件发生。</p></li><li><p>当某个（或某几个）Handle的事件发生时，Synchronous Event Demultiplexer通知Initiation Dispatcher，select()根据发生事件的Handle找出对应的回调Handler。</p></li><li><p>Initiation Dispatcher调用特定的Concrete Event Handler的回调方法（handel_event()）来响应其关联的handle上发生的事件。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828095953099.png" alt="image-20240828095953099"></p><h2 id="优缺点">优缺点</h2><p>优点</p><ul><li>解耦</li><li>提升复用性，且弹性设置【根据任务的不同设置不同的CPU数量】</li><li>模块化【每个模块分工明确】</li><li>可移植性</li><li>事件驱动</li><li>细力度的并发控制【和线程池相比，减少锁的粒度】【我认为是一种以时间换取CPU资源的思想】</li></ul><p>缺点</p><ul><li>Reactor增加了一定的复杂性，不易于调试。</li><li>Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效</li><li>Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。</li></ul><h2 id="Reactor模式-vs-Proactor模式">Reactor模式 vs Proactor模式</h2><blockquote><p><strong>Proactor模式结构</strong></p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828101708484.png" alt="image-20240828101708484"></p><p>Proactor主动器模式包含如下角色：</p><p><strong>Handle</strong> 句柄；用来标识socket连接或是打开文件；</p><p><strong>Asynchronous Operation Processor</strong>：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</p><p><strong>Asynchronous Operation</strong>：异步操作</p><p><strong>Completion Event Queue</strong>：完成事件队列；异步操作完成的结果放到队列中等待后续使用</p><p><strong>Proactor</strong>：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</p><p><strong>Completion Handler</strong>：完成事件接口；一般是由回调函数组成的接口；</p><p><strong>Concrete Completion Handler</strong>：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</p><blockquote><p><strong>Proactor模式时序图</strong></p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828101741358.png" alt="image-20240828101741358"></p><ol><li><p>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行。</p></li><li><p>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来。</p></li><li><p>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列。</p></li><li><p>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中。</p></li></ol><blockquote><p><strong>区别</strong></p></blockquote><ul><li><p>在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。</p></li><li><p>而在Proactor模式中，处理器–或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。</p></li></ul><p><strong>在Reactor中实现读：</strong></p><p>– 注册读就绪事件和相应的事件处理器<br>– 事件分离器等待事件<br>– 事件到来，激活分离器，分离器调用事件对应的处理器。<br>– 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</p><p><strong>在Proactor中实现读：</strong></p><p>– 处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。<br>– 事件分离器等待操作完成事件<br>– 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。<br>– 事件分离器呼唤处理器。<br>– 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</p><p>**相同点：**都是对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；</p><p>**不同点：**异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(可读/可写)。如果采用通俗易懂的比喻，就是：</p><p><strong>reactor</strong>：能收了你跟俺说一声。</p><p><strong>proactor</strong>: 你给我收十个字节，收好了跟俺说一声。</p><blockquote><p><strong>2者的优点</strong></p></blockquote><p><strong>Reactor实现相对简单，对于耗时短的处理场景处理较高效。</strong></p><p>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；<br>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；<br>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</p><p><strong>Proactor性能更高，能够处理耗时长的并发场景；</strong></p><blockquote><p><strong>2者的缺点</strong></p></blockquote><p>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</p><p>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；</p><p><strong>两者都是I/O多路复用模式，Reactor采用同步I/O，而Proactor采用异步I/O</strong></p><p><strong>用Reactor 模拟 Proactor的方法：</strong></p><ol><li>主线程往epoll内核事件表中注册socket上的可读就绪事件；</li><li>主线程调用epoll_wait等待socket上有数据可读；</li><li>当fd上有数据可读时，epoll_wait通知主线程读取数据，然后将读取到的数据插入到请求队列之中；</li><li>请求队列的空闲工作线程被唤醒，它处理完请求事件后往epoll内核事件表中注册socket的可写就绪事件；</li><li>主线程调用epoll_wait等待socket可写，当可写时，epoll_wait通知主线程，主线程往socket上写入请求的结果。</li></ol><h3 id="ASIO">ASIO</h3><p><a href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/">《Boost.Asio C++ 网络编程》</a></p><p><a href="https://blog.csdn.net/crr411422/article/details/133358868">最好用的Boost.Asio：现代C++网络编程</a></p><p><a href="https://blog.csdn.net/yanerhao/article/details/82424065">boost::io_service解读</a></p><p><a href="https://www.cnblogs.com/mowwwcom/p/15998744.html">boost.asio系列——io_service</a></p><p><a href="https://mp.weixin.qq.com/s/PBrx6_iUwKSclaCng8yLlA">实例解读boost库中优秀的网络库asio</a></p><p>观点记录：</p><ul><li><strong>观点1</strong>：看了下boost的源码, Windows下完全就是用IOCP来实现的异步，非常简洁，因为Windows为IOCP做的事情太多了，包括建立完成事件队列，往完成队列里面添加事件等等，根本不需要额外增加其他的代码就可以完成所有的事情。<br>而在linux下就没有这么方便，第一linux下的epoll是reactor模型，系统只是做简单的通知，其他拿数据的操作，还是需要自己动手，而且也不清楚是否有接口可以向epoll的队列中添加其他的事件(像Windows中的PostQueuedCompletionStatus)。 所以boost又在epoll上面加了一层，相当于自己建立了一个完成事件队列，当epoll来事件通知后boost去把数据copy到用户的buffer中，然后再把完成事件push到队列中，让用户线程去处理，这样就实现了跟IOCP相同的proactor模型。</li></ul><h2 id="参考资料：">参考资料：</h2><p><a href="https://www.s0nnet.com/archives/deep-understanding-of-reactor-design-patterns">深入理解Reactor模式</a></p><p><a href="https://cloud.baidu.com/article/3287034">Redis中的Reactor模型：理解其工作机制</a></p><p><a href="https://blog.csdn.net/ldw201510803006/article/details/124365838">高性能网络编程之 Reactor 网络模型（彻底搞懂）</a></p><p>补充：</p><p>在网上的一些资料我看到reactor模式有单线程，多线程，主从线程模式。（比如redis就是单线程的模式）。但是论文的话只给出了一种模式范式。应该是根据这个范式自己去扩展的~</p>]]></content>
    
    
    <summary type="html">Reactor论文</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>多线程实战总结</title>
    <link href="https://penge666.github.io/posts/cb6fdc44.html"/>
    <id>https://penge666.github.io/posts/cb6fdc44.html</id>
    <published>2024-08-13T12:39:22.000Z</published>
    <updated>2024-09-15T11:22:34.035Z</updated>
    
    <content type="html"><![CDATA[<p>之前在503接触过些多线程编程。现在将其总结下！</p><p><strong>每个人在时代中都是一粒沙子</strong>~</p><h2 id="多线程注意事项">多线程注意事项</h2><h3 id="避免使用全局变量"><strong>避免使用全局变量</strong></h3><p><strong>原因</strong>：全局变量在多线程环境中是共享的，多个线程可能同时访问或修改它，导致数据竞争。</p><p><strong>解决方案</strong>：</p><ul><li>使用 <code>std::mutex</code> 来保护对全局变量的访问。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> global_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ++global_counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global counter: &quot;</span> &lt;&lt; global_counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进一步思考</strong>：全局变量在一个进程中修改，会影响到另一个进程吗？</p><p>答案：不会</p><p>在操作系统中，每个进程都有自己独立的内存空间。全局变量是定义在函数之外的变量，它们的作用域是整个文件，但在多进程环境中，每个进程都有自己的全局变量副本。因此，一个进程中修改全局变量不会影响到另一个进程。</p><p>验证：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        global_var = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process: global_var = %d\n&quot;</span>, global_var);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 等待子进程修改全局变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process: global_var = %d\n&quot;</span>, global_var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork 失败</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子操作"><strong>原子操作</strong></h3><p><strong>使用</strong>：使用 <code>std::atomic</code> 进行原子操作，避免使用锁。</p><p>1.自己不会被优化，相当于voliate（经验之谈：当两个线程都访问同一个变量，请使用atomic，防止优化产生逾期错误，因为atomic修饰的变量不会被优化）</p><p>2.使用内存序</p><p><strong>避免</strong>：直接操作共享变量没有加锁或使用不安全的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">atomic_counter</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++atomic_counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(increment)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(increment)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Atomic counter: &quot;</span> &lt;&lt; atomic_counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>std::atomic</code> 的底层原理</strong></p><ol><li><strong>原子指令</strong>：<ul><li>CPU 提供了专门的原子指令来保证操作的原子性。例如，Intel 的 <code>x86</code> 架构提供了 <code>LOCK</code> 前缀和 <code>CMPXCHG</code>（比较并交换）指令，ARM 架构提供了 <code>LDREX</code> 和 <code>STREX</code> 指令。</li><li>这些原子指令确保在执行操作时，其他线程或进程不能干扰当前操作，从而避免数据竞争和一致性问题。</li></ul></li><li><strong>内存屏障</strong>：<ul><li>内存屏障（Memory Barriers）或内存顺序（Memory Order）用于确保指令执行的顺序和可见性。<code>std::atomic</code> 提供了不同的内存顺序选项（如 <code>memory_order_relaxed</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>、<code>memory_order_seq_cst</code>）来控制这些屏障。</li><li>内存屏障可以确保在多线程环境下对原子变量的操作按预期顺序执行。例如，<code>memory_order_acquire</code> 确保在读取原子变量后，所有后续操作的读写在该线程中都不会被重排到读取之前。</li></ul></li><li><strong>CAS（比较并交换）</strong>：<ul><li><code>std::atomic</code> 中许多原子操作（如 <code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code>）基于 CAS 操作。CAS 操作的基本原理是：比较当前值和期望值，如果它们相等，则将变量更新为新值。</li><li>这个操作是原子的，确保在更新过程中不会被其他线程的操作干扰。</li></ul></li></ol><p><strong><code>std::atomic</code> 的常见操作</strong></p><ol><li><strong>原子加载和存储</strong>：<ul><li><code>std::atomic</code> 提供了 <code>load()</code> 和 <code>store()</code> 方法【load()和store()是重载函数】来进行原子读取和写入。底层这些操作会利用 CPU 提供的原子指令来保证操作的原子性。</li></ul></li><li><strong>原子交换</strong>：<ul><li><code>std::atomic</code> 提供了 <code>exchange()</code> 方法来进行原子交换操作。它会将原子变量的当前值替换为新值，并返回旧值。</li></ul></li><li><strong>原子加法和减法</strong>：<ul><li><code>std::atomic</code> 提供了 <code>fetch_add()</code> 和 <code>fetch_sub()</code> 方法来进行原子加法和减法操作。这些操作保证了对变量的增加或减少是原子的。</li></ul></li><li><strong>原子比较和交换</strong>：<ul><li><code>std::atomic</code> 提供了 <code>compare_exchange_weak()</code> 和 <code>compare_exchange_strong()</code> 方法来进行原子比较和交换操作。它们允许在某个值等于期望值时进行原子更新。</li></ul></li></ol><p>简单问题：++i和i++是否是原子操作？</p><p>答案：不是</p><p>无论是 <code>++i</code> 还是 <code>i++</code>，它们都涉及以下步骤：</p><ol><li><strong>读取变量值</strong>：从内存中读取变量的当前值。</li><li><strong>修改值</strong>：将读取的值加 1。</li><li><strong>写回变量</strong>：将修改后的值写回内存中的变量。</li></ol><p>【可以防止被编译器优化】</p><h3 id="线程本地存储（TLS）"><strong>线程本地存储（TLS）</strong></h3><p><strong>使用</strong>：如果每个线程需要独立的数据副本，可以使用 <code>thread_local</code> 关键字。</p><p><strong>避免</strong>：共享变量不适用于每个线程需要独立的数据场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_local_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_local_variable++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread-local variable: &quot;</span> &lt;&lt; thread_local_variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层原理</strong></p><ol><li><strong>线程本地存储（TLS）</strong>：<ul><li><code>thread_local</code> 变量的底层实现通常利用<strong>操作系统提供的 TLS 机制</strong>。线程本地存储允许线程在其自身的地址空间中拥有私有的数据区域，这些数据区域对其他线程是不可见的。</li><li>在 Windows 上，TLS 由线程局部存储的 API（如 <code>TlsAlloc</code>、<code>TlsSetValue</code> 和 <code>TlsGetValue</code>）提供支持。在 POSIX 系统（如 Linux）上，通常通过线程控制块（Thread Control Block，TCB）或线程局部存储段（Thread-Local Storage Segment）实现。</li></ul></li><li><strong>编译器支持</strong>：<ul><li>编译器为 <code>thread_local</code> 变量生成特定的代码，以确保每个线程都有独立的数据副本。编译器会将 <code>thread_local</code> 变量的数据存储在专门的线程本地存储区域，并使用操作系统提供的机制来分配和管理这些区域。【<strong><code>thread_local</code> 变量通常被存储在线程本地存储区域（Thread-Local Storage, TLS）</strong>】</li><li>在编译时，编译器通常会为每个 <code>thread_local</code> 变量生成额外的代码，以处理变量的初始化、销毁和访问。</li></ul></li><li><strong>线程局部存储的访问</strong>：<ul><li>访问 <code>thread_local</code> 变量时，编译器生成的代码会根据当前线程的标识符（Thread ID）从线程本地存储区域中检索变量的值。这通常涉及到查询线程控制块或其他线程本地数据结构。</li><li>线程本地存储机制可能会在变量首次被访问时初始化变量，并在线程结束时销毁变量。</li></ul></li></ol><h3 id="锁的使用"><strong>锁的使用</strong></h3><h4 id="锁粒度优化">锁粒度优化</h4><p><strong>使用</strong>：在访问共享资源时使用 <code>std::mutex</code> 或 <code>std::shared_mutex</code>。使用 RAII 的锁类（如 <code>std::lock_guard</code>）以确保锁的正确释放。</p><p><strong>避免</strong>：使用过多或不恰当的锁导致性能低下或死锁。</p><h5 id="读写锁">读写锁</h5><p><strong>读写锁</strong></p><p><strong>读写锁</strong>允许多个线程同时读取数据，但在写数据时会对所有读线程和其他写线程加锁。这种锁适用于读操作远多于写操作的场景，可以显著减少锁竞争。</p><p><strong>示例</strong>（使用 <code>std::shared_mutex</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::shared_mutex rw_lock;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title function_">lock</span><span class="params">(rw_lock)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read data: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : data) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_data</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title function_">lock</span><span class="params">(rw_lock)</span>;</span><br><span class="line">    data.push_back(value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Added value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">writer1</span><span class="params">(write_data, <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">writer2</span><span class="params">(write_data, <span class="number">2</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">reader1</span><span class="params">(read_data)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">reader2</span><span class="params">(read_data)</span>;</span><br><span class="line"></span><br><span class="line">    writer1.join();</span><br><span class="line">    writer2.join();</span><br><span class="line">    reader1.join();</span><br><span class="line">    reader2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是如何保证线程安全的呢？</p><p>在 <code>write_data</code> 函数中使用 <code>std::unique_lock</code> 来锁定 <code>std::shared_mutex</code>，确保在写入数据时，其他线程不能持有共享锁（读操作），从而保证写操作的线程安全。具体机制如下：</p><ol><li><strong>写操作的独占锁</strong>：<ul><li>当一个线程调用 <code>write_data</code> 函数并尝试获取 <code>std::unique_lock</code> 时，它会尝试获取 <code>std::shared_mutex</code> 的独占锁。</li><li>如果存在其他线程持有共享锁或独占锁，当前线程会被阻塞，直到这些锁被释放。</li><li>一旦独占锁成功获取，所有其他线程（无论是持有共享锁还是独占锁）都会被阻塞。</li></ul></li><li><strong>读操作的共享锁</strong>：<ul><li>当线程调用 <code>read_data</code> 函数并尝试获取 <code>std::shared_lock</code> 时，它会尝试获取 <code>std::shared_mutex</code> 的共享锁。</li><li>如果没有线程持有独占锁，线程可以成功获取共享锁。</li><li>如果有线程持有独占锁，获取共享锁的线程会被阻塞，直到独占锁被释放。</li></ul></li></ol><p>我们也可以自己实现下share_mutex【本质：条件变量，锁机制和引用计数来实现！】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedMutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedMutex</span>() : <span class="built_in">readers</span>(<span class="number">0</span>), <span class="built_in">writer_waiting</span>(<span class="literal">false</span>), <span class="built_in">writer_active</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock_shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        reader_cv.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !writer_active &amp;&amp; !writer_waiting;</span><br><span class="line">        &#125;);</span><br><span class="line">        ++readers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock_shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (--readers == <span class="number">0</span> &amp;&amp; writer_waiting) &#123;</span><br><span class="line">            writer_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        writer_waiting = <span class="literal">true</span>;</span><br><span class="line">        writer_cv.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> readers == <span class="number">0</span> &amp;&amp; !writer_active;</span><br><span class="line">        &#125;);</span><br><span class="line">        writer_active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        writer_active = <span class="literal">false</span>;</span><br><span class="line">        writer_waiting = <span class="literal">false</span>;</span><br><span class="line">        reader_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex;</span><br><span class="line">    std::condition_variable reader_cv;</span><br><span class="line">    std::condition_variable writer_cv;</span><br><span class="line">    <span class="type">int</span> readers;</span><br><span class="line">    <span class="type">bool</span> writer_waiting;</span><br><span class="line">    <span class="type">bool</span> writer_active;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="死锁">死锁</h4><p><strong>死锁</strong>：通过锁排序和分层锁来避免。</p><h5 id="分层锁">分层锁</h5><p><strong>分层锁的原理</strong></p><ul><li><strong>层次结构</strong>：将锁分为多个层次，每个层次的锁都有一个固定的优先级。例如，层次 1 是最基础的锁，层次 2 是中级锁，层次 3 是高级锁。</li><li><strong>固定顺序</strong>：线程在获取多个锁时，必须按照从低层到高层的顺序获取锁。这可以确保在任意情况下，所有线程都遵循相同的顺序来获取锁，从而避免了循环等待条件。</li></ul><p><strong>为什么分层锁可以防止死锁？</strong></p><p>死锁发生的四个必要条件是：</p><ol><li><strong>互斥条件</strong>：至少有一个资源被一个线程持有，并且其他线程不能获取。</li><li><strong>请求和保持条件</strong>：持有资源的线程正在等待其他线程持有的资源。</li><li><strong>不可剥夺条件</strong>：已获得的资源不能被强制剥夺。</li><li><strong>循环等待条件</strong>：存在一种资源的循环等待关系。</li></ol><p>分层锁通过确保线程在获取多个锁时始终按照相同的顺序进行，可以避免循环等待条件，从而防止死锁。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁的层次</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LockLevel</span> &#123;</span><br><span class="line">    LEVEL_1,</span><br><span class="line">    LEVEL_2,</span><br><span class="line">    LEVEL_3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁类，包含层次信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HierarchicalMutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HierarchicalMutex</span><span class="params">(LockLevel level)</span> : level_(level) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁时，确保按层次顺序</span></span><br><span class="line">        <span class="built_in">check_lock_order</span>();</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_lock_order</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查当前锁的层次是否低于之前获取的锁的层次</span></span><br><span class="line">        <span class="comment">// 这部分可以根据实际需求实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    LockLevel level_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁的层次</span></span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level1</span><span class="params">(LEVEL_1)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level2</span><span class="params">(LEVEL_2)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level3</span><span class="params">(LEVEL_3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    level1.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level2.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level3.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread1 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    level3.<span class="built_in">unlock</span>();</span><br><span class="line">    level2.<span class="built_in">unlock</span>();</span><br><span class="line">    level1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    level1.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level3.<span class="built_in">lock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    level2.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread2 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    level2.<span class="built_in">unlock</span>();</span><br><span class="line">    level3.<span class="built_in">unlock</span>();</span><br><span class="line">    level1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好的学习例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁的层次</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LockLevel</span> &#123;</span><br><span class="line">    LEVEL_1,</span><br><span class="line">    LEVEL_2,</span><br><span class="line">    LEVEL_3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁类，包含层次信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HierarchicalMutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HierarchicalMutex</span><span class="params">(LockLevel level)</span> : level_(level) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁时，确保按层次顺序</span></span><br><span class="line">        <span class="built_in">check_lock_order</span>();</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 更新当前线程持有的最大锁层次</span></span><br><span class="line">        max_lock_level = std::<span class="built_in">max</span>(max_lock_level.<span class="built_in">load</span>(), level_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁时，更新当前线程持有的最大锁层次</span></span><br><span class="line">        max_lock_level = std::<span class="built_in">max_element</span>(lock_levels.<span class="built_in">begin</span>(), lock_levels.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_lock_order</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查当前锁的层次是否低于之前获取的锁的层次</span></span><br><span class="line">        LockLevel held_lock_level = max_lock_level.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">if</span> (level_ &lt; held_lock_level) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Lock order violation detected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    LockLevel level_;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::atomic&lt;LockLevel&gt; max_lock_level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程本地变量</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> std::atomic&lt;LockLevel&gt; <span class="title">HierarchicalMutex::max_lock_level</span><span class="params">(LEVEL_1 - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁的层次</span></span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level1</span><span class="params">(LEVEL_1)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level2</span><span class="params">(LEVEL_2)</span></span>;</span><br><span class="line"><span class="function">HierarchicalMutex <span class="title">level3</span><span class="params">(LEVEL_3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        level1.<span class="built_in">lock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level2.<span class="built_in">lock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level3.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread1 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        level3.<span class="built_in">unlock</span>();</span><br><span class="line">        level2.<span class="built_in">unlock</span>();</span><br><span class="line">        level1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread1: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        level1.<span class="built_in">lock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level3.<span class="built_in">lock</span>();  <span class="comment">// This will cause a lock order violation</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        level2.<span class="built_in">lock</span>();  <span class="comment">// This will also cause a lock order violation</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread2 acquired all locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        level2.<span class="built_in">unlock</span>();</span><br><span class="line">        level3.<span class="built_in">unlock</span>();</span><br><span class="line">        level1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread2: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="scoped-lock">scoped_lock</h5><p><code>std::scoped_lock</code> 是 C++17 引入的一个锁管理类，用于简化多互斥量的加锁过程并防止死锁。它在构造时会尝试锁定所有提供的互斥量，并在析构时自动解锁，确保了加锁和解锁的正确性和异常安全性。</p><p><strong>主要特点</strong></p><ul><li><strong>自动加锁和解锁</strong>：<code>std::scoped_lock</code> 在构造时加锁，在析构时解锁，确保锁的正确管理。</li><li><strong>支持多个互斥量</strong>：可以同时锁定多个 <code>std::mutex</code> 或其他同步原语，防止死锁。</li><li><strong>异常安全</strong>：即使在加锁后抛出异常，析构函数也会保证锁被正确释放。</li></ul><p><strong>示例代码</strong></p><p>下面是一个使用 <code>std::scoped_lock</code> 的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个互斥量</span></span><br><span class="line"><span class="built_in">std</span>::mutex mutex1;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，演示如何使用 std::scoped_lock</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; attempting to acquire locks...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::scoped_lock 同时锁定两个互斥量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::scoped_lock <span class="title function_">lock</span><span class="params">(mutex1, mutex2)</span>; <span class="comment">// 自动加锁</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; acquired both locks!\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟工作</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; releasing locks...\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished execution.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        threads.emplace_back(thread_function, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释</p><ol><li><strong><code>std::scoped_lock</code></strong>：<ul><li>在构造时，<code>std::scoped_lock</code> 会尝试锁定 <code>mutex1</code> 和 <code>mutex2</code>。它会按照一定的顺序加锁这些互斥量，避免死锁问题。</li><li>当 <code>std::scoped_lock</code> 对象离开作用域时，它的析构函数会自动解锁这些互斥量。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>多个互斥量的加锁</strong>：当一个操作需要同时锁定多个互斥量时，使用 <code>std::scoped_lock</code> 可以简化代码，避免手动管理锁的复杂性。</li><li><strong>死锁预防</strong>：<code>std::scoped_lock</code> 通过确保按照固定的顺序加锁多个互斥量，可以减少死锁的风险。</li><li><strong>异常安全</strong>：<code>std::scoped_lock</code> 确保即使在持锁期间发生异常，锁也能被正确释放。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><strong>锁顺序</strong>：<code>std::scoped_lock</code> 会自动处理锁的顺序，但在某些复杂的应用场景下，仍然需要确保设计上的锁顺序一致性。</li><li><strong>性能</strong>：虽然 <code>std::scoped_lock</code> 简化了锁管理，但在性能要求极高的场景下，仍然需要考虑锁的开销和锁的竞争。</li></ul><p>通过使用 <code>std::scoped_lock</code>，可以提高代码的可读性和可靠性，简化多互斥量加锁的管理。</p><h4 id="活锁">活锁</h4><p>举个有意思的例子吧</p><p><strong>例子：两个自动门</strong></p><p>想象一下，两个自动门（A和B）在同一条走廊的两侧，门上装有传感器。如果有人靠近一扇门，门会自动打开。门的设计是这样的：当两扇门同时检测到有人接近时，它们都会尝试打开。假设门的逻辑是这样的：</p><ul><li>如果门A检测到门B正在打开，它会等待并重新检测，如果门B打开得足够久，门A就会尝试打开。</li><li>如果门B检测到门A正在打开，它会等待，并重新检测，如果门A打开得足够久，门B就会尝试打开。</li></ul><p><strong>活锁的发生</strong></p><ol><li><strong>状态检测</strong>：门A和门B都检测到对方正在尝试打开。</li><li><strong>状态改变</strong>：门A和门B都决定等待并重新检测。</li><li><strong>不断改变</strong>：由于它们在不断检测对方的状态并改变自己的状态，它们永远不会真正打开。</li></ol><p><strong>实际结果</strong>：两个门不断检测对方，尝试解决冲突，但没有任何一个门能够完全打开，因为它们始终在等待对方完成操作，造成了一个典型的活锁情形。</p><p>概念：</p><p><strong>活锁</strong>发生在系统中的线程一直在改变状态，但是系统并没有向前推进，所有线程都在忙碌地试图解决冲突。活锁通常发生在设计上不是很合理的重试逻辑中。</p><p><strong>活锁</strong>：通过合理的重试机制和退出条件来避免。</p><p><strong>示例：活锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; <span class="title function_">flag1</span><span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; <span class="title function_">flag2</span><span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag1 &amp;&amp; !flag2) &#123;</span><br><span class="line">            flag1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">            flag2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread1 finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag1 &amp;&amp; !flag2) &#123;</span><br><span class="line">            flag2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">            flag1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread2 finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(thread1)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(thread2)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：两个线程不断地尝试切换 <code>flag1</code> 和 <code>flag2</code>，但由于没有充分的条件，始终在重试而没有进展。</p><p><strong>避免活锁</strong></p><p>要避免活锁，需要设计合理的重试机制和退出条件，确保线程能够在某些情况下放弃重试，从而避免无限循环。</p><h4 id="递归锁">递归锁</h4><p><strong>适用场景</strong></p><ul><li><strong>递归调用</strong>: <code>std::recursive_mutex</code> 允许在同一线程中多次调用 <code>lock()</code> 而不会导致死锁，因此在递归函数中可以安全地锁定和解锁。</li><li><strong>适用场景</strong>: 当需要在同一线程中递归地访问共享资源时，使用 <code>std::recursive_mutex</code> 可以避免常规互斥量带来的死锁问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex rMutex; <span class="comment">// 声明一个递归互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rMutex.<span class="built_in">lock</span>(); <span class="comment">// 锁定互斥量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    rMutex.<span class="built_in">unlock</span>(); <span class="comment">// 解锁互斥量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(recursiveFunction, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(recursiveFunction, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRecursiveMutex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; count; <span class="comment">// 计数器</span></span><br><span class="line">    std::thread::id owner;  <span class="comment">// 当前持有锁的线程 ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyRecursiveMutex</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::thread::id this_id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (owner == this_id) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程已经持有锁，增加计数器</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，尝试获取锁</span></span><br><span class="line">        <span class="comment">// 这里使用一个简单的自旋锁示例</span></span><br><span class="line">        <span class="keyword">while</span> (count.<span class="built_in">load</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        owner = this_id; <span class="comment">// 设置当前线程为持有者</span></span><br><span class="line">        count = <span class="number">1</span>;       <span class="comment">// 初始化计数器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--; <span class="comment">// 减少计数器</span></span><br><span class="line">            <span class="keyword">if</span> (count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                owner = std::thread::<span class="built_in">id</span>(); <span class="comment">// 重置持有者</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="strand库">strand库</h3><p>在Boost.Asio中，<code>strand</code>（即<code>boost::asio::strand</code>）是一种用于同步处理的机制，确保在多线程环境中，提交到同一<code>strand</code>的事件或回调函数不会同时执行。<code>strand</code>的主要作用是避免数据竞争，简化对共享资源的并发访问控制。</p><p><strong><code>strand</code>的作用</strong></p><ul><li><strong>串行化事件处理</strong>：<code>strand</code> 保证了通过它提交的所有事件或回调函数将按提交的顺序被串行执行，即使它们是在不同的线程中执行的。</li><li><strong>避免数据竞争</strong>：<code>strand</code> 允许开发者在不显式使用锁的情况下，安全地访问共享资源。它确保在一个<code>strand</code>上的操作不会与其他并发操作相冲突。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建strand对象，关联到io_context</span></span><br><span class="line">    boost::<span class="function">asio::strand&lt;boost::asio::io_context::executor_type&gt; <span class="title">strand</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向strand提交两个任务，它们将按顺序执行</span></span><br><span class="line">    strand.<span class="built_in">post</span>([&amp;]()&#123; <span class="built_in">print_message</span>(<span class="string">&quot;Hello from strand&quot;</span>, <span class="number">1</span>); &#125;);</span><br><span class="line">    strand.<span class="built_in">post</span>([&amp;]()&#123; <span class="built_in">print_message</span>(<span class="string">&quot;Strand ensures order&quot;</span>, <span class="number">2</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动两个线程来处理io_context中的任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123; io_context.run(); &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123; io_context.run(); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>io_context</strong>：<code>boost::asio::io_context</code>是Asio库中的I/O服务提供者，用于分发事件和执行异步操作。</li><li><strong>strand</strong>：<code>boost::asio::strand</code>与<code>io_context</code>关联，用于确保提交给它的任务在同一时间只能有一个线程执行。</li><li><strong>post</strong>：使用<code>strand.post()</code>将任务提交到<code>strand</code>中，确保这些任务按照提交顺序执行，即使是在多线程环境中。</li></ul><p>再来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string &amp;message, <span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在独立的 strand 中并行执行任务</span></span><br><span class="line">    boost::asio::<span class="function">io_context::strand <span class="title">strand1</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    boost::asio::<span class="function">io_context::strand <span class="title">strand2</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    strand1.<span class="built_in">post</span>([&amp;]()</span><br><span class="line">                 &#123; <span class="built_in">print_message</span>(<span class="string">&quot;Task 1 in strand 1&quot;</span>, <span class="number">1</span>); &#125;);</span><br><span class="line">    strand1.<span class="built_in">post</span>([&amp;]()</span><br><span class="line">                 &#123; <span class="built_in">print_message</span>(<span class="string">&quot;Task 2 in strand 2&quot;</span>, <span class="number">2</span>); &#125;);</span><br><span class="line">    strand2.<span class="built_in">post</span>([&amp;]()</span><br><span class="line">                 &#123; <span class="built_in">print_message</span>(<span class="string">&quot;Task 3 in strand 3&quot;</span>, <span class="number">3</span>); &#125;);</span><br><span class="line">    <span class="comment">// 启动两个线程处理 io_context 中的任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">                   &#123; io_context.run(); &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">                   &#123; io_context.run(); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我的理解是可以将strand1提交的任务看成一个整体，这个整体里面执行的顺序和post顺序是一致的。</p><p>io_context可以分成不同的包，每个包类似strand1,strand2这样，就可以起多个线程去执行里面的内容！</p><p>补充：上述代码中，我们可以使用1个线程或者3个以及以上的线程同时去运行，都是可以实现正常执行的。</p><p>因此，在一个strand里面运行的任务是单线程执行的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/test  ./main</span><br><span class="line">Thread 3: Task 3 <span class="keyword">in</span> strand 3</span><br><span class="line">Thread 1: Task 1 <span class="keyword">in</span> strand 1</span><br><span class="line">Thread 2: Task 2 <span class="keyword">in</span> strand 2</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/test  ./main</span><br><span class="line">Thread 3: Task 3 <span class="keyword">in</span> strand 3</span><br><span class="line">Thread 1: Task 1 <span class="keyword">in</span> strand 1</span><br><span class="line">Thread 2: Task 2 <span class="keyword">in</span> strand 2</span><br></pre></td></tr></table></figure><p><strong>asio中strand的post和dispatch的区别</strong></p><ul><li><p><code>post</code>: 将任务添加到 <code>strand</code> 的队列中,异步执行。</p></li><li><p><code>dispatch</code>: 立即在当前 <code>strand</code> 中执行任务,阻塞当前线程。</p></li><li><p><code>wrap()</code> 函数用于将一个执行器绑定到一个处理程序上。这样可以确保该处理程序在指定的执行器上执行,而不是在默认的执行器上执行。</p><ul><li><p>在较新版本的 Boost.Asio 中，<code>wrap</code> 函数已经被移除，取而代之的是使用 <code>bind_executor</code> 函数来绑定回调函数到指定的 <code>strand</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::io_context;</span><br><span class="line"><span class="keyword">using</span> boost::asio::strand;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_operation</span><span class="params">(strand&lt;io_context::executor_type&gt; &amp;my_strand, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::<span class="built_in">post</span>(my_strand, [value]()</span><br><span class="line">                      &#123; <span class="built_in">print</span>(<span class="string">&quot;Processing value: &quot;</span> + std::<span class="built_in">to_string</span>(value)); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_context io;</span><br><span class="line">    <span class="function">strand&lt;io_context::executor_type&gt; <span class="title">my_strand</span><span class="params">(io.get_executor())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind_executor 函数绑定回调到 strand</span></span><br><span class="line">    <span class="keyword">auto</span> bound_callback = boost::asio::<span class="built_in">bind_executor</span>(my_strand, [&amp;]()</span><br><span class="line">                                                     &#123; <span class="built_in">print</span>(<span class="string">&quot;Bound callback executed&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交绑定的回调到 io_context</span></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(io, bound_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一些异步操作到 strand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">async_operation</span>(my_strand, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><a href="https://www.cnblogs.com/my_life/articles/5331789.html">boost asio 介绍 关于strand的介绍不错</a></p><h3 id="线程池"><strong>线程池</strong></h3><p><strong>使用</strong>：使用线程池来管理线程资源，避免频繁创建和销毁线程。可以使用 <code>std::thread</code> 结合 <code>std::future</code> 和 <code>std::promise</code> 实现简单的线程池。</p><p><strong>避免</strong>：直接使用裸线程增加管理难度和资源泄漏风险。</p><h3 id="无锁编程"><strong>无锁编程</strong></h3><p><strong>使用</strong>：在高性能场景下，可以考虑使用无锁数据结构（如无锁队列）。</p><p><strong>避免</strong>：无锁编程复杂且容易出错，仅在必要时使用。</p><h3 id="线程安全的数据结构"><strong>线程安全的数据结构</strong></h3><p>tbb</p><h3 id="C-11的std-call-once">C++11的std::call_once</h3><p><code>std::call_once</code> 是 C++11 引入的一种机制，用于确保某段代码在多线程环境中只被执行一次。这对于初始化操作或需要保证单一执行的场景特别有用。例如，在单例模式实现中，我们可以使用 <code>std::call_once</code> 来保证初始化代码只执行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization code executed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread finished executing.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>std::once_flag flag</code></strong>: 这是用于控制 <code>std::call_once</code> 的标志，确保初始化代码只会执行一次。</p><p><strong><code>initialize</code> 函数</strong>: 这是我们希望只执行一次的初始化代码。在多线程环境中，确保 <code>initialize</code> 只被执行一次是关键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="type">static</span> Singleton&amp; <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(initFlag, initSingleton);</span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值操作符，防止拷贝</span></span><br><span class="line">    Singleton(<span class="type">const</span> Singleton&amp;) = delete;</span><br><span class="line">    Singleton&amp; operator=(<span class="type">const</span> Singleton&amp;) = delete;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化单例实例的函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">initSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="built_in">std</span>::once_flag initFlag;</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line"><span class="built_in">std</span>::once_flag Singleton::initFlag;</span><br><span class="line">Singleton* Singleton::instance = nullptr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadFunc</span><span class="params">()</span> &#123;</span><br><span class="line">    Singleton&amp; singleton = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; got the singleton instance.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(threadFunc)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(threadFunc)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常捕获">异常捕获</h3><p>异常处理：合理处理线程中的异常，避免异常导致线程终止或整个应用崩溃。可以使用 try-catch 块捕获异常，并根据具体情况选择合适的处理方式，例如记录日志、重新抛出异常或进行适当的回滚操作。</p><h3 id="异步回调加锁">异步回调加锁</h3><p>异步回调（Asynchronous Callback）是指在异步操作完成后，系统或库调用的回调函数。由于异步回调通常在不同的线程或事件循环中执行，因此加锁是为了避免多个回调同时访问共享资源而引发竞态条件。</p><p>可以学习陈硕大佬的swap机制，加速以及防止死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stats</span> &#123;</span><br><span class="line">    <span class="type">int</span> request_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> total_response_time = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源的锁</span></span><br><span class="line">std::mutex stats_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_response</span><span class="params">(<span class="type">double</span> response_time, Stats&amp; stats)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保护共享资源</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(stats_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新共享资源</span></span><br><span class="line">    stats.request_count++;</span><br><span class="line">    stats.total_response_time += response_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁后可以继续处理其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Response handled. Count: &quot;</span> &lt;&lt; stats.request_count</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Total Time: &quot;</span> &lt;&lt; stats.total_response_time &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异步网络请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simulate_request</span><span class="params">(Stats&amp; stats)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个网络延迟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设收到响应，调用回调函数</span></span><br><span class="line">    <span class="type">double</span> simulated_response_time = (<span class="built_in">rand</span>() % <span class="number">1000</span>) / <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">on_response</span>(simulated_response_time, stats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stats stats;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程模拟并发请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(simulate_request, std::<span class="built_in">ref</span>(stats)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final Count: &quot;</span> &lt;&lt; stats.request_count</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Final Total Time: &quot;</span> &lt;&lt; stats.total_response_time &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile">volatile</h3><p>在多线程编程中，<code>volatile</code> 关键字的主要用途是告诉编译器该变量可能会被异步修改，从而防止编译器优化该变量的访问。然而，在现代 C++ 编程中，更推荐使用 <code>std::atomic</code> 来处理多线程中的共享数据访问，因为 <code>std::atomic</code> 不仅提供了防止优化的功能，还确保了操作的原子性和线程安全性。</p><p>这个示例演示了如何使用 <code>volatile</code> 变量来标记一个线程的停止标志。请注意，这种做法在多线程编程中并不是最佳实践，仅用于演示 <code>volatile</code> 的使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 volatile 关键字声明停止标志</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> stop_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop_flag) &#123;</span><br><span class="line">        <span class="comment">// 模拟做一些工作</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread stopped.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待一段时间，然后设置停止标志</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    stop_flag = <span class="literal">true</span>; <span class="comment">// 设置标志以停止线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sleep">sleep</h3><p><strong>Note</strong>：<code>sleep</code> 函数会将调用它的线程挂起（暂停执行）指定的时间。在这段时间内，线程不会进行任何操作，系统会将 CPU 时间分配给其他线程或进程。</p><p><strong>定时任务调度</strong>: 使用 <code>sleep</code> 实现周期性任务调度。</p><p><strong>模拟长时间运行的任务</strong>: 在测试中模拟任务的延迟。</p><p><strong>等待外部事件</strong>: 使用 <code>sleep</code> 轮询条件，避免忙等待。</p><p><strong>限流和节流</strong>: 控制请求或任务的处理频率。</p><p><strong>模拟延迟网络请求</strong>: 测试应用程序对网络延迟的响应能力。</p><h3 id="yield">yield</h3><p>在多线程环境下，如果一个线程在等待某个条件时采取 busy waiting 的方式，这意味着线程会不断地占用 CPU 资源来检查条件是否满足。这种做法的缺点包括：</p><ul><li><strong>浪费 CPU 资源</strong>：线程不断地循环检查条件，而不做有意义的工作，浪费了宝贵的 CPU 时间。</li><li><strong>阻碍其他线程</strong>：由于 CPU 被忙等待的线程占用，其他可能有更高优先级或更重要任务的线程无法及时执行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(UTaskWrapper&amp;&amp; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mutex_.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">            <span class="comment">// 可能出现⻓期⽆法抢到锁的情况</span></span><br><span class="line">            queue_.<span class="built_in">emplace_front</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">            mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 让出cpu执⾏权</span></span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：多个线程往 <code>queue_</code> 中 push 任务时，可能遇到 <code>mutex_</code> 被其他线程占用的情况。</li><li><strong>问题</strong>：如果线程在无法获取锁的情况下，持续尝试获取锁而不让出 CPU，就会导致 busy waiting。</li><li><strong>解决方法</strong>：使用 <code>std::this_thread::yield()</code> 函数来避免 busy waiting。</li></ul><p><strong><code>std::this_thread::yield()</code> 的作用</strong></p><p><code>std::this_thread::yield()</code> 是 C++ 标准库中的一个函数，它的作用是在当前线程无法继续执行时，主动让出 CPU 执行权，让操作系统调度其他线程执行。当前线程会被重新放入就绪队列中，等待下一次被调度执行。</p><p>在上述代码中：</p><ul><li>当 <code>mutex_.try_lock()</code> 失败时，表示锁被其他线程占用，当前线程无法继续执行任务。</li><li>这时，调用 <code>std::this_thread::yield()</code>，让当前线程暂时停止执行，给其他线程机会运行。</li><li>过一段时间后，当前线程会再次被调度，继续尝试获取锁。</li></ul><p><strong>好处</strong></p><p>避免 busy waiting 的主要原因是为了<strong>提高系统的整体性能和资源利用率</strong>：</p><ul><li><strong>降低 CPU 占用率</strong>：让出 CPU 时间片给其他线程执行，可以更高效地利用 CPU 资源。</li><li><strong>提高系统响应性</strong>：通过合理的线程调度，系统能够更快响应其他重要任务。</li><li><strong>减少功耗</strong>：忙等待会导致 CPU 高负载运行，增加功耗和温度。</li></ul><h3 id="exit">exit</h3><p><strong><code>exit()</code> 在多线程环境中是不安全的</strong></p><p><code>exit()</code> 是一个用于终止进程的标准库函数。当你在多线程程序中调用 <code>exit()</code> 时，它会导致整个进程的所有线程都立即终止。这种行为在多线程环境下存在风险，因此被认为是“线程不安全的”。</p><p><code>exit()</code></p><ul><li><strong>终止进程</strong>：<code>exit()</code> 终止调用它的进程，并释放进程占用的所有资源。这包括关闭打开的文件、释放内存等。</li><li><strong>调用清理函数</strong>：<code>exit()</code> 会调用通过 <code>atexit()</code> 注册的清理函数，例如数据刷新、文件关闭等操作。</li><li><strong>返回状态码</strong>：<code>exit()</code> 接受一个整数参数作为状态码，用于向操作系统返回进程的退出状态。</li></ul><p><strong>为什么 <code>exit()</code> 在多线程环境中是不安全的？</strong></p><p><strong>理由1. 强制终止所有线程</strong></p><p>当一个线程调用 <code>exit()</code> 时，整个进程中的所有线程都会立即停止执行。这意味着：</p><ul><li><strong>未完成的操作被中断</strong>：如果其他线程正在执行文件写入、数据库操作、锁定资源等关键任务，这些操作将被强制中断，可能导致数据丢失或系统状态不一致。</li><li><strong>资源未释放</strong>：某些资源可能需要其他线程来释放，比如动态分配的内存、网络连接等。由于这些线程被突然终止，资源可能无法正常释放，导致资源泄露。</li></ul><p><strong>理由2. 导致竞态条件</strong></p><p>多线程程序中的竞态条件是指多个线程并发执行，且执行的顺序或时机不确定，可能引发不正确的行为。<code>exit()</code> 的突然调用可能导致以下竞态条件：</p><ul><li><strong>资源竞争</strong>：如果一个线程在使用某个资源（如文件或内存）时，另一个线程调用了 <code>exit()</code>，正在使用的资源可能不会被正确释放或保存。</li><li><strong>未完成的事务</strong>：如果一个线程在执行一个事务（如数据库操作）时被中断，事务可能无法正常完成，导致数据不一致。</li></ul><p><strong>理由3. 清理函数的执行顺序不确定</strong></p><p><code>exit()</code> 会调用通过 <code>atexit()</code> 注册的清理函数，但这些函数是在单线程环境下设计的。在多线程环境中，清理函数的执行顺序可能与预期不一致，特别是当不同线程依赖于这些清理函数时。</p><p><strong>举例</strong>：</p><p>假设你有一个多线程程序，其中一个线程负责读取文件，另一个线程负责写入文件。突然调用 <code>exit()</code> 可能导致以下问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *file;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">write_thread</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;Writing line %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 模拟写入操作的延迟</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">read_thread</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 等待写入线程完成几次操作</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">// 直接调用 exit()，试图终止程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> writer, reader;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;writer, <span class="literal">NULL</span>, write_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;reader, <span class="literal">NULL</span>, read_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(writer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(reader, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能结果：</p><ol><li><strong>文件未完全写入</strong>：<code>write_thread</code> 线程正在写入文件，而 <code>read_thread</code> 线程在 2 秒后调用 <code>exit()</code>。这会导致 <code>write_thread</code> 突然停止，文件未完全写入，结果可能是一个损坏的文件。</li><li><strong>资源未正确释放</strong>：<code>exit()</code> 会导致进程立即终止，因此文件描述符 <code>file</code> 可能不会被正确关闭，这会导致数据未写入到磁盘，或者文件被锁定。</li><li><strong>不可预测的行为</strong>：由于 <code>exit()</code> 强制终止进程，导致程序的终止行为不可预测，可能在不同的运行中，表现出不同的结果。</li></ol><p><strong>解决方法</strong></p><p><strong>1. 使用 <code>pthread_exit()</code></strong></p><p>如果你只想终止当前线程，可以使用 <code>pthread_exit()</code>，它只会终止调用它的线程，不会影响其他线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">thread_func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    global_state += <span class="number">2</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);  <span class="comment">// 仅终止当前线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用标志位或条件变量</strong></p><p>通过使用标志位或条件变量来控制线程的退出，而不是直接调用 <code>exit()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> should_exit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    global_state += <span class="number">2</span>;</span><br><span class="line">    should_exit = <span class="literal">true</span>;  <span class="comment">// 设置标志位，通知其他线程退出</span></span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 使用信号处理机制</strong></p><p>在需要终止进程的场景中，可以通过信号处理机制来安全地终止进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行清理操作</span></span><br><span class="line">    <span class="built_in">exit</span>(signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, signal_handler);</span><br><span class="line">    <span class="comment">// 程序运行，等待信号处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 程序的主要循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充">补充</h3><p><strong>补充：std::thread::hardware_concurrency</strong></p><p><code>std::thread::hardware_concurrency()</code> 是 C++11 标准库中 <code>std::thread</code> 类的一个静态成员函数。这个函数返回一个 <code>unsigned int</code> 类型的值，表示当前系统支持的并发线程数，即硬件线程数或处理器核心数。</p><p>这个值可以用来帮助程序员决定在多线程程序中创建多少个线程，以充分利用系统资源，避免创建过多的线程导致资源浪费和上下文切换开销。</p><p><strong>补充：CPU核心绑定</strong></p><p>在 Linux 上，可以使用 <code>sched_setaffinity</code> 函数来设置进程或线程的 CPU 亲和性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的 ID</span></span><br><span class="line">    <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 cpu_set_t 对象</span></span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpuset); <span class="comment">// 清空 CPU 集合</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;cpuset); <span class="comment">// 将第一个 CPU 核心添加到集合中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的 CPU 亲和性</span></span><br><span class="line">    <span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread running on CPU core: &quot;</span> &lt;&lt; <span class="built_in">sched_getcpu</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><ol><li><strong>CPU 亲和性</strong>: 通过将线程绑定到特定核心，可以减少上下文切换，提高缓存利用率，从而提高性能。</li><li><strong>适用场景</strong>: 在高性能计算、实时系统和需要高一致性的应用中，CPU 绑定可以显著提高效率。</li><li><strong>注意事项</strong>: 过度绑定可能会导致 CPU 资源利用不均衡，因此需要根据具体情况进行调整。</li></ol><p>经典例题：</p><p>程序执行过程中，有60%的部分是串行处理的，其余为并行处理;如果我们将处理器的数量从2个提升到16个，理论上整个程序的执行时间能减少多少(为了简单，直接使用两者的speedUp差值)?</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240913151324072.png" alt="image-20240913151324072"></p><h2 id="线程安全的模板库">线程安全的模板库</h2><h3 id="Boost">Boost</h3><p><strong>描述</strong>: Boost.Lockfree 提供了无锁的数据结构，如无锁队列、无锁栈等。它们利用原子操作实现了高效的并发访问。</p><p><strong>使用场景</strong>: 适用于需要高并发且性能敏感的场景，如任务队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/lockfree/queue.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">boost::<span class="function">lockfree::queue&lt;<span class="type">int</span>&gt; <span class="title">queue</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    queue.<span class="built_in">push</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">if</span> (queue.<span class="built_in">pop</span>(value)) &#123;</span><br><span class="line">        <span class="comment">// Process value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TBB-Threading-Building-Blocks"><strong>TBB (Threading Building Blocks)</strong></h3><p><strong>描述</strong>: TBB 是一个用于并行编程的模板库，提供了线程安全的容器（如 <code>tbb::concurrent_queue</code>、<code>tbb::concurrent_vector</code>），以及并行算法和任务调度器。</p><p><strong>使用场景</strong>: 适用于需要并行算法、线程安全容器的复杂多线程应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/concurrent_vector.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">tbb::concurrent_vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>了解</strong></p><p><code>tbb::concurrent_queue</code></p><ul><li><strong>描述</strong>：<code>tbb::concurrent_queue</code> 是一个线程安全的队列，支持多线程的入队和出队操作。</li><li>底层机制<ul><li><strong>锁-free 技术</strong>：<code>tbb::concurrent_queue</code> 通常使用基于锁-free 的技术来实现线程安全，例如使用 CAS（Compare-And-Swap）操作来避免锁的使用。</li><li><strong>分段锁</strong>：为了减少锁的竞争，有时会使用分段锁（Segmented Locking），将队列分成多个段，每个段有自己的锁。</li></ul></li></ul><p><code>tbb::concurrent_vector</code></p><ul><li><strong>描述</strong>：<code>tbb::concurrent_vector</code> 是一个线程安全的动态数组，支持并发插入和访问。</li><li>底层机制<ul><li><strong>分段锁</strong>：<code>tbb::concurrent_vector</code> 使用分段锁来保护其内部的数据结构。每个段有自己的锁，这样可以减少线程竞争，允许多个线程同时操作不同的段。</li><li><strong>无锁设计</strong>：在某些情况下，使用无锁算法（如乐观锁）来进一步减少锁的开销和线程竞争。</li></ul></li></ul><p><code>tbb::concurrent_hash_map</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Segment</span>(<span class="type">size_t</span> size) : <span class="built_in">data</span>(size, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定位置的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            data[index] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定位置的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 代表无效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentedArray</span>(<span class="type">size_t</span> segment_count, <span class="type">size_t</span> segment_size)</span><br><span class="line">        : <span class="built_in">segments</span>(segment_count, <span class="built_in">Segment</span>(segment_size)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定段和位置的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> segment_index, <span class="type">size_t</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment_index &lt; segments.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            segments[segment_index].<span class="built_in">set</span>(index, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定段和位置的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> segment_index, <span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment_index &lt; segments.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> segments[segment_index].<span class="built_in">get</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 代表无效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Segment&gt; segments;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试分段锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(SegmentedArray&amp; array, <span class="type">size_t</span> segment, <span class="type">size_t</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    array.<span class="built_in">set</span>(segment, index, value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; set segment &quot;</span> &lt;&lt; segment</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> num_segments = <span class="number">4</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> segment_size = <span class="number">10</span>;</span><br><span class="line">    <span class="function">SegmentedArray <span class="title">array</span><span class="params">(num_segments, segment_size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动线程</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_segments; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; segment_size; ++j) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(array), i, j, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q：TBB 的 tbb::concurrent_vector 底层实现采用了结合无锁和分段锁的策略来优化性能。是以什么策略结合的呢</strong></p><ol><li><strong>数据分段</strong></li></ol><ul><li>分段锁：tbb::concurrent_vector 将内部存储的数据分成多个段（segments），每个段使用独立的锁来保护。这种方法减少了线程间的竞争，因为多个线程可以同时操作不同的段，而不需要竞争同一个锁。<ul><li><strong>锁粒度</strong>：通过将数据分成多个段，每个段有自己独立的锁，从而实现更细粒度的锁控制，减少了锁竞争。</li></ul></li></ul><ol start="2"><li><strong>无锁操作</strong></li></ol><ul><li>无锁机制：在某些操作中，如向数组末尾追加元素，tbb::concurrent_vector使用无锁机制来提高性能。例如，可能会使用无锁队列或其他无锁数据结构来管理并发插入操作。<ul><li><strong>原子操作</strong>：在处理简单的并发操作时，使用原子操作（如 CAS，Compare-And-Swap）来管理元素的插入和删除，从而避免传统的锁操作。</li></ul></li></ul><ol start="3"><li><strong>策略结合</strong></li></ol><ul><li>分段锁 + 无锁操作tbb::concurrent_vector 的实际实现结合了分段锁和无锁操作，根据不同操作的性质和并发模式来选择合适的策略。<ul><li><strong>分段锁</strong>：主要用于保护和管理内部数据的不同部分，例如在进行扩展容量或删除元素时使用。</li><li><strong>无锁操作</strong>：用于优化一些简单的并发操作，例如在数组末尾追加元素时使用，以减少锁的开销。</li></ul></li></ul><h3 id="Folly-Facebook-Open-source-Library"><strong>Folly (Facebook Open-source Library)</strong></h3><p><strong>描述</strong>: Folly 提供了高性能的并发数据结构和工具，特别是在高并发的场景下表现出色。例如，<code>folly::ProducerConsumerQueue</code> 是一种高效的单生产者-单消费者队列。</p><p><strong>使用场景</strong>: 适用于高并发的生产者-消费者模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/ProducerConsumerQueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">folly::ProducerConsumerQueue&lt;<span class="type">int</span>&gt; <span class="title">pc_queue</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!pc_queue.<span class="built_in">write</span>(value)) &#123;</span><br><span class="line">        <span class="comment">// wait or try again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">while</span> (!pc_queue.<span class="built_in">read</span>(value)) &#123;</span><br><span class="line">        <span class="comment">// wait or try again</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发编程支持">并发编程支持</h4><p>Folly 提供了一系列高性能的并发工具和数据结构，其中包括 <code>ForkJoinPool</code> 和 <code>MPMCQueue</code>。</p><p><a href="https://blog.csdn.net/mars21/article/details/128579392">folly库安装</a></p><p><a href="https://blog.csdn.net/haokan123456789/article/details/139759621">Folly，一个强大的C++库</a></p><h5 id="ForkJoinPool"><strong>ForkJoinPool</strong></h5><p><strong>概述</strong></p><p><code>ForkJoinPool</code> 是一个并行执行框架，允许将大任务拆分成更小的子任务，然后并行执行这些子任务。最终，子任务的结果会被合并，形成整体的结果。</p><p><strong>特点</strong></p><ul><li><strong>任务分解与并行执行</strong>: 可以递归地将任务分解成子任务，并将这些子任务分配给多个线程并行执行。</li><li><strong>工作窃取机制</strong>: 实现了工作窃取机制，空闲线程可以从忙碌线程的任务队列中窃取任务，从而平衡负载，提高性能。</li><li><strong>灵活的线程池管理</strong>: 可以配置线程池的大小，并灵活地管理线程的生命周期。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/experimental/ThreadedExecutor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/experimental/ForkJoinPool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个递归计算斐波那契数列的任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程池执行器</span></span><br><span class="line">    folly::ThreadedExecutor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 ForkJoinPool，指定线程池大小为4</span></span><br><span class="line">    <span class="function">folly::ForkJoinPool <span class="title">forkJoinPool</span><span class="params">(executor, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ForkJoinPool 来执行任务</span></span><br><span class="line">    <span class="keyword">auto</span> result = forkJoinPool.<span class="built_in">run</span>([](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> task) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务足够小，直接计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (task &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fib</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，分割任务并行执行</span></span><br><span class="line">        <span class="keyword">auto</span> left = self.fork(task - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = self.fork(task - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子任务完成并合并结果</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">join</span>(left) + self.<span class="built_in">join</span>(right);</span><br><span class="line">    &#125;, <span class="number">30</span>);  <span class="comment">// 计算 Fibonacci(30)</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>ForkJoinPool Initialization</strong>:<ul><li><code>folly::ForkJoinPool</code> 被初始化为一个有 4 个线程的池。这意味着最多可以并行执行 4 个任务。</li></ul></li><li><strong>Task Decomposition</strong>:<ul><li>在 <code>forkJoinPool.run</code> 中，我们递归地分解了计算斐波那契数列的任务。如果任务小于或等于 10，直接计算结果；否则，将任务分解为两个子任务，并行执行。</li></ul></li><li><strong>Work Stealing</strong>:<ul><li>在 <code>ForkJoinPool</code> 中，每个线程维护一个任务队列。空闲线程会从其他线程的任务队列中窃取任务，这就是所谓的工作窃取机制。通过这种机制，可以确保所有线程都尽可能保持忙碌，从而提高整体性能。</li></ul></li><li><strong>Fork and Join</strong>:<ul><li><code>self.fork()</code> 用于分解任务并将其放入队列中，而 <code>self.join()</code> 用于等待子任务完成并获取结果。</li></ul></li></ol><p><strong>在这个例子中，我们将 <code>fib(30)</code> 的计算分割为 <code>fib(29)</code> 和 <code>fib(28)</code> 两个子任务。每次分割都递归地创建更多子任务，这些子任务会被分配给线程池中的不同线程执行。</strong></p><p>接下来，简单写份代码说明任务窃取的原理！</p><p><strong>工作窃取机制简介</strong></p><p>在 <code>ForkJoinPool</code> 中，每个工作线程都维护一个双端队列（deque）。当线程有任务要执行时，它会将任务推送到自己的任务队列中，通常是从双端队列的末端入队。线程从队列的末端取任务执行。如果某个线程的任务队列为空，它会尝试从其他线程的任务队列头部窃取任务来执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkStealingQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向队列中添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        deque_.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取任务</span></span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (deque_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> task = deque_.<span class="built_in">back</span>();</span><br><span class="line">        deque_.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列头部窃取任务</span></span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">steal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (deque_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> task = deque_.<span class="built_in">front</span>();</span><br><span class="line">        deque_.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程执行的工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(WorkStealingQueue&amp; myQueue, std::vector&lt;WorkStealingQueue&gt;&amp; allQueues, <span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 尝试从自己的队列中获取任务</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> task = myQueue.<span class="built_in">pop</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; is processing task &quot;</span> &lt;&lt; *task &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 窃取其他线程的任务</span></span><br><span class="line">            <span class="type">bool</span> stolen = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; allQueues.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (&amp;allQueues[i] != &amp;myQueue) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> stolenTask = allQueues[i].<span class="built_in">steal</span>()) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; stole task &quot;</span> &lt;&lt; *stolenTask &lt;&lt; <span class="string">&quot; from thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                        stolen = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stolen) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; has no tasks left and can&#x27;t steal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">4</span>;</span><br><span class="line">    <span class="function">std::vector&lt;WorkStealingQueue&gt; <span class="title">queues</span><span class="params">(numThreads)</span></span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        queues[i % numThreads].<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(queues[i]), std::<span class="built_in">ref</span>(queues), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建一个新线程并传递参数时，参数通常是按值复制的。<strong>如果你想传递一个对象的引用给线程，可以使用 <code>std::ref</code>。</strong></p><h5 id="Folly-MPMCQueue-Multi-Producer-Multi-Consumer-Queue"><strong>Folly MPMCQueue (Multi-Producer Multi-Consumer Queue)</strong></h5><p><strong>概述</strong></p><p><code>MPMCQueue</code> 是一个高性能的多生产者多消费者队列，设计用于在多线程环境下进行高效的数据传递。它允许多个线程同时向队列中添加和取出元素，而不会引起数据竞争或锁的争用。</p><p><strong>特点</strong></p><ul><li><strong>无锁设计</strong>: 使用无锁算法实现，高效且线程安全。</li><li><strong>高并发支持</strong>: 支持多生产者和多消费者同时进行操作，适用于需要高吞吐量的场景。</li><li><strong>固定容量</strong>: 队列的容量是固定的，可以在初始化时指定。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;folly/MPMCQueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">folly::MPMCQueue&lt;<span class="type">int</span>&gt; <span class="title">queue</span><span class="params">(<span class="number">1024</span>)</span></span>;  <span class="comment">// 创建一个容量为1024的MPMC队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        queue.<span class="built_in">write</span>(i);  <span class="comment">// 向队列中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="built_in">read</span>(value)) &#123;  <span class="comment">// 从队列中取出元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">prod1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">prod2</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">cons1</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">cons2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    prod1.<span class="built_in">join</span>();</span><br><span class="line">    prod2.<span class="built_in">join</span>();</span><br><span class="line">    cons1.<span class="built_in">join</span>();</span><br><span class="line">    cons2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Moodycamel">Moodycamel</h3><p>MoodyCamel的无锁队列（MoodyCamel’s Lock-Free Queue），也叫做ConcurrentQueue，是一个用于高性能多线程环境的多生产者多消费者（MPMC，Multi-Producer Multi-Consumer）无锁队列。这个队列旨在提供高效且线程安全的并发访问，而不需要传统的锁机制，从而避免了锁竞争带来的性能瓶颈。</p><p><strong>主要特点</strong></p><ol><li><strong>无锁设计</strong>: 使用无锁算法来实现高效的队列操作，避免了锁竞争，提高了并发性能。</li><li><strong>多生产者多消费者</strong>: 支持多个生产者线程同时向队列中插入元素，以及多个消费者线程同时从队列中取出元素。</li><li><strong>高性能</strong>: 队列采用了缓存行对齐、无伪共享（false sharing）等技术优化，最大程度减少了CPU缓存冲突和内存访问延迟。</li><li><strong>支持单生产者单消费者优化</strong>: 虽然是多生产者多消费者队列，但在只有一个生产者或一个消费者的情况下，队列会自动优化以进一步提高性能。</li><li><strong>有界与无界版本</strong>: 提供了有界队列（bounded queue）和无界队列（unbounded queue）的实现。前者在容量满时会阻塞插入操作，而后者会自动扩展容量。</li></ol><p><strong>工作原理</strong></p><ol><li><p>原子操作 (Atomic Operations)<br>MoodyCamel 的无锁队列依赖于原子操作，如比较并交换（Compare-And-Swap, CAS），来保证多个线程之间的同步。CAS 是一种硬件级别的原子操作，能够在多个线程试图同时更新某个变量时，确保只有一个线程成功修改了该变量，从而避免竞态条件（Race Condition）。</p></li><li><p>分段缓存（Chunk-Based Buffering）<br>队列内部使用了一种分段的缓存机制，将队列划分为多个独立的“块”（chunks）。每个块是一个固定大小的环形缓冲区。生产者线程和消费者线程各自操作不同的块，从而减少了线程之间的直接竞争。块的大小通常是固定的，并根据队列的负载动态分配。</p></li><li><p>无伪共享 (False Sharing)<br>为了避免伪共享，队列通过缓存行对齐（Cache Line Alignment）技术，确保每个线程操作的数据位于不同的缓存行上。伪共享是指多个线程访问同一缓存行中的不同变量时，导致缓存一致性协议频繁触发，从而降低性能。通过缓存行对齐，MoodyCamel 队列最大限度地减少了这种冲突。</p></li></ol><p>Moodycamel 会对队列的关键成员变量进行特殊的内存布局,确保它们被分布在不同的缓存行上.</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(CACHE_LINE_SIZE) ProducerIndex &#123;</span><br><span class="line">    std::atomic&lt;std::<span class="type">uint32_t</span>&gt; value;</span><br><span class="line">    <span class="comment">// ... other producer-specific data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(CACHE_LINE_SIZE) ConsumerIndex &#123;</span><br><span class="line">    std::atomic&lt;std::<span class="type">uint32_t</span>&gt; value;</span><br><span class="line">    <span class="comment">// ... other consumer-specific data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheAlignedPadding</span> &#123;</span><br><span class="line">    <span class="type">char</span> padding[CACHE_LINE_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    ProducerIndex enqueue_index;</span><br><span class="line">    CacheAlignedPadding pad0;</span><br><span class="line">    ConsumerIndex dequeue_index;</span><br><span class="line">    CacheAlignedPadding pad1;</span><br><span class="line">    <span class="type">char</span>* <span class="keyword">volatile</span> buffer;</span><br><span class="line">    <span class="comment">// ... other queue-specific data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>环形缓冲区 (Ring Buffer)<br>每个块内部使用环形缓冲区来管理元素的位置。环形缓冲区允许生产者和消费者以固定大小的数组形式存储元素，并且通过原子索引递增操作，确保多个线程可以安全地访问和更新队列。</p></li><li><p>无锁入队和出队操作 (Lock-Free Enqueue/Dequeue)<br>入队操作 (Enqueue): 生产者线程首先通过原子操作获取一个块中的空闲位置，然后在该位置插入新元素。使用 CAS 操作，确保在高并发情况下多个生产者不会同时插入到同一个位置。</p></li></ol><p>出队操作 (Dequeue): 消费者线程通过原子操作获取一个块中已有元素的位置，然后从该位置取出元素。类似地，使用 CAS 操作确保多个消费者不会同时访问同一个位置。</p><ol start="6"><li><p>进退策略 (Backoff Strategy)<br>为了提高性能，当一个线程发现它无法立即完成某个操作时（如因为另一个线程正在执行相关操作），它可能会采取一种“退避策略”。这意味着线程会短暂地放弃 CPU，以减少对其他线程的干扰，然后稍后重试。这种策略避免了忙等待的资源浪费。</p></li><li><p>内存模型 (Memory Model)<br>MoodyCamel 队列的实现高度依赖于 C++ 内存模型中的内存序（Memory Order）语义，特别是 memory_order_acquire 和 memory_order_release，这些语义用于保证操作的可见性和顺序性。它们帮助在无锁队列中实现线程安全，确保在一个线程发布的数据对另一个线程可见。</p></li></ol><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;concurrentqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">moodycamel::ConcurrentQueue&lt;<span class="type">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.enqueue(i + id * <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; enqueued &quot;</span> &lt;&lt; i + id * <span class="number">100</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">queue</span>.try_dequeue(item)) &#123;</span><br><span class="line">            <span class="comment">// busy-wait until an item is available</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; dequeued &quot;</span> &lt;&lt; item &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; producers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; consumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create producer threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        producers.emplace_back(producer, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create consumer threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        consumers.emplace_back(consumer, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Join threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : producers) &#123;</span><br><span class="line">        p.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : consumers) &#123;</span><br><span class="line">        c.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无锁并发测试效率：moodycamel &gt; tbb &gt; boost</p><h2 id="底层剖析">底层剖析</h2><h3 id="mutex机制">mutex机制</h3><p>先来看下linux-mutex底层结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mutex</span> &#123;</span><br><span class="line">    <span class="type">atomic_long_t</span> owner;         <span class="comment">// 锁的拥有者</span></span><br><span class="line">    <span class="type">spinlock_t</span> wait_lock;        <span class="comment">// 保护等待队列的自旋锁</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> wait_list;  <span class="comment">// 等待线程的队列</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;          <span class="comment">// 锁的状态（锁定为0，未锁定为1）</span></span><br><span class="line">    <span class="type">void</span> *dep_map;               <span class="comment">// 用于死锁检测的依赖映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过点开mutex源码我们可以发现，C++ std::mutex是对glibc-nptl库pthread_mutex的封装；而nptl库在用户态完成了futex机制的一部分；最后在以linux为内核的操作系统中，又提供了futex系统调用给glibc-nptl给与底层支撑。</p><p>glibc：通过底层OS封装出C库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">mutex</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">mutex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mutex</span>(<span class="type">const</span> mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="type">int</span> __e = __gthread_mutex_lock(&amp;_M_mutex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)</span></span><br><span class="line">      <span class="keyword">if</span> (__e)</span><br><span class="line">__throw_system_error(__e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">    <span class="type">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">try_lock</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// XXX EINVAL, EAGAIN, EBUSY</span></span><br><span class="line">      <span class="keyword">return</span> !__gthread_mutex_trylock(&amp;_M_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// XXX EINVAL, EAGAIN, EPERM</span></span><br><span class="line">      __gthread_mutex_unlock(&amp;_M_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">native_handle_type</span></span><br><span class="line"><span class="function">    <span class="title">native_handle</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> &amp;_M_mutex; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在用户空间，互斥锁通常通过 POSIX 线程库（<code>pthread</code>）提供。典型的互斥锁包含两种情况：</p><ol><li><strong>快速路径</strong>：当锁是空闲时，线程可以直接通过原子操作获取锁。</li><li><strong>慢速路径</strong>：如果锁已经被其他线程持有，线程会进入内核，通过 <code>futex</code> 等机制等待锁的释放。</li></ol><p>以下是 <code>pthread_mutex_lock</code> 的简化伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__sync_bool_compare_and_swap(&amp;mutex-&gt;state, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Lock acquired successfully</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the lock is already held, go to the slow path</span></span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_lock_slow(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>__sync_bool_compare_and_swap</code> 是一个原子操作，它尝试将 <code>mutex-&gt;state</code> 从 <code>0</code> 改为 <code>1</code>，表示尝试获取锁。如果成功，则锁定成功；否则，进入慢速路径。</p><h4 id="内核的Futex机制"><strong>内核的Futex机制</strong></h4><p><code>futex</code>（fast userspace mutex）是一种混合的同步原语，它结合了用户态和内核态的机制来实现高效的线程同步。<code>futex</code> 的主要思想是：尽量在用户态完成锁操作，只有在需要阻塞或唤醒线程时才陷入内核态，从而减少系统调用的开销。</p><p><strong>举例说明</strong></p><p><strong>多进程下futex机制</strong></p><p>当 <code>futex</code> 用于多进程同步时，多个进程需要协同访问同一个共享内存区域。这种情况下，各个进程中的虚拟地址可能不同，但它们指向的是同一个物理地址。</p><p>假设有两个进程 <strong>A</strong> 和 <strong>B</strong>，它们通过共享内存区域进行通信和同步。该共享内存区域映射到两个进程不同的虚拟地址上，例如：</p><ul><li>在进程 A 中，共享内存区域的起始地址是 <code>0x7fff0000</code>。</li><li>在进程 B 中，共享内存区域的起始地址是 <code>0x7fff1000</code>。</li></ul><p>尽管虚拟地址不同，但它们都映射到相同的物理内存，比如物理地址 <code>0x12345000</code>。</p><p>现在，假设共享内存区域中的某个整数变量 <code>shared_var</code> 的偏移量为 <code>0x0</code>，那么：</p><ul><li>在进程 A 中，<code>shared_var</code> 的虚拟地址是 <code>0x7fff0000</code>。</li><li>在进程 B 中，<code>shared_var</code> 的虚拟地址是 <code>0x7fff1000</code>。</li></ul><p>但在物理内存中，它们实际指向的是同一个物理地址 <code>0x12345000</code>。</p><p><strong><code>futex_wait</code> 和 <code>futex_wake</code> 的工作机制</strong></p><ol><li><strong>进程 A 调用 <code>futex_wait</code></strong>：<ul><li>进程 A 试图对 <code>shared_var</code> 进行操作，发现它的值不符合预期，于是调用 <code>futex_wait</code>，请求挂起自己。</li><li><code>futex_wait</code> 需要传递一个指针（即 <code>uaddr</code>）给内核，这个指针在进程 A 中是 <code>0x7fff0000</code>。</li><li>内核接收到这个指针后，会通过进程 A 的页表将该虚拟地址 <code>0x7fff0000</code> 转换为物理地址 <code>0x12345000</code>。</li><li>内核使用这个物理地址作为键，将进程 A 插入到对应的等待队列中。</li></ul></li><li><strong>进程 B 调用 <code>futex_wake</code></strong>：<ul><li>进程 B 在某个操作后希望唤醒挂起的进程，所以调用 <code>futex_wake</code>。</li><li>进程 B 传递的 <code>uaddr</code> 是 <code>0x7fff1000</code>，这是它在自己虚拟地址空间中对 <code>shared_var</code> 的地址。</li><li>内核将 <code>0x7fff1000</code> 转换为物理地址 <code>0x12345000</code>。</li><li>内核查找与 <code>0x12345000</code> 相关联的等待队列，将进程 A 唤醒。</li></ul></li></ol><p><strong>多线程下 <code>futex</code> 机制</strong></p><p>在多线程环境中，所有线程共享同一个虚拟地址空间。<code>futex</code> 利用这个特性，使得所有线程可以直接使用共享的内存地址（即虚拟地址）来进行同步操作。</p><p><strong><code>futex</code> 基本操作</strong></p><ul><li><strong><code>futex_wait(int *uaddr, int val)</code></strong>：当前线程检查 <code>*uaddr</code> 是否等于 <code>val</code>，如果相等则将线程挂起，等待其他线程来唤醒它。</li><li><strong><code>futex_wake(int *uaddr, int n)</code></strong>：唤醒最多 <code>n</code> 个正在 <code>uaddr</code> 上等待的线程。</li></ul><p><strong>详细的 <code>futex</code> 流程说明</strong></p><p>假设我们有两个线程 <code>Thread A</code> 和 <code>Thread B</code>，它们使用一个共享的整数变量 <code>lock_var</code> 来进行同步：</p><ol><li><strong>共享变量 <code>lock_var</code> 的初始化</strong>：<ul><li><code>lock_var</code> 是一个全局变量或在堆上分配的变量，所有线程共享它。</li><li>初始状态下，<code>lock_var</code> 的值为 <code>0</code>，表示锁是空闲的。</li></ul></li><li><strong>线程 A 尝试获取锁</strong>：<ul><li><code>Thread A</code> 尝试获取锁。它使用原子操作 <code>compare_exchange</code> 来检查 <code>lock_var</code> 是否为 <code>0</code>，如果是，则将 <code>lock_var</code> 的值设置为 <code>1</code>，表示锁已被占用。</li><li>如果 <code>Thread A</code> 成功设置 <code>lock_var</code> 为 <code>1</code>，它就进入临界区（critical section）执行任务。</li></ul></li><li><strong>线程 A 发现锁已被占用</strong>：<ul><li>如果 <code>Thread A</code> 发现 <code>lock_var</code> 已经是 <code>1</code> （即锁被占用），它调用 <code>futex_wait(&amp;lock_var, 1)</code> 来挂起自己。</li><li>内核会检查 <code>lock_var</code> 是否仍然是 <code>1</code>。如果是，内核将 <code>Thread A</code> 挂起并将其放入与 <code>lock_var</code> 关联的等待队列中。</li></ul></li><li><strong>线程 B 释放锁</strong>：<ul><li><code>Thread B</code> 持有锁并完成了它的任务，准备释放锁。</li><li><code>Thread B</code> 将 <code>lock_var</code> 设置为 <code>0</code>，表示锁已空闲。</li><li>然后 <code>Thread B</code> 调用 <code>futex_wake(&amp;lock_var, 1)</code>，唤醒一个正在等待该锁的线程。</li></ul></li><li><strong>线程 A 被唤醒</strong>：<ul><li>内核唤醒 <code>Thread A</code>，并将它从等待队列中移除。</li><li><code>Thread A</code> 被唤醒后，重新尝试获取锁。如果 <code>lock_var</code> 已经被设置为 <code>0</code>，<code>Thread A</code> 通过 <code>compare_exchange</code> 成功获取锁，并进入临界区执行任务。</li></ul></li><li><strong>线程 A 释放锁</strong>：<ul><li><code>Thread A</code> 完成任务后，将 <code>lock_var</code> 设置为 <code>0</code>，并调用 <code>futex_wake(&amp;lock_var, 1)</code>，以便唤醒其他可能等待的线程。</li></ul></li></ol><h4 id="两个关键函数"><strong>两个关键函数</strong></h4><p><strong>futex_wait</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">futex_wait</span><span class="params">(u32 __user *uaddr, <span class="type">unsigned</span> <span class="type">int</span> flags, u32 val,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">ktime_t</span> *abs_time, u32 bitset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">futex_hash_bucket</span> *hb;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">futex_q</span> q;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 futex 锁，确保在 futex 操作期间内核态的同步</span></span><br><span class="line">    hb = <span class="built_in">hash_futex</span>(uaddr);</span><br><span class="line">    <span class="built_in">spin_lock</span>(&amp;hb-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户态地址 uaddr 所指向的值是否等于 val</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">futex_atomic_cmpxchg_inatomic</span>(uaddr, val, val)) &#123;</span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 futex_q 结构体</span></span><br><span class="line">    ret = <span class="built_in">futex_queue</span>(uaddr, flags, abs_time, bitset, hb, &amp;q);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程挂起，等待 futex_wake 唤醒</span></span><br><span class="line">    ret = <span class="built_in">futex_wait_queue_me</span>(hb, &amp;q, flags, abs_time);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="built_in">spin_unlock</span>(&amp;hb-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下 <code>futex_wait</code> 流程：</p><ol><li>加自旋锁</li><li>检测*uaddr是否等于val，如果不相等则会立即返回<ul><li><strong><code>*uaddr</code></strong>：指向用户态中某个共享变量的指针，该变量通常用于表示锁的状态。这个共享变量可以是一个整数类型（比如 <code>int</code>），它的值通常用于表示锁的当前状态（如空闲或被占用）。</li></ul></li><li>将进程状态设置为 <code>TASK_INTERRUPTIBLE</code></li><li>将当期进程插入到等待队列中</li><li>释放自旋锁</li><li>创建定时任务：当超过一定时间还没被唤醒时，将进程唤醒</li><li>挂起当前进程</li></ol><p><strong>futex_wake</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">futex_wake</span><span class="params">(u32 __user *uaddr, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">int</span> nr_wake, u32 bitset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">futex_hash_bucket</span> *hb;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">futex_q</span> *<span class="keyword">this</span>, *next;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">futex_key</span> key = FUTEX_KEY_INIT;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="built_in">DEFINE_WAKE_Q</span>(wake_q); <span class="comment">// 申明一个wake_up队列，所有满足条件的线程都存放于此</span></span><br><span class="line"><span class="comment">// hash处理得到某个hahs链表</span></span><br><span class="line">ret = <span class="built_in">get_futex_key</span>(uaddr, flags &amp; FLAGS_SHARED, &amp;key, VERIFY_READ);</span><br><span class="line">hb = <span class="built_in">hash_futex</span>(&amp;key);</span><br><span class="line"></span><br><span class="line"><span class="built_in">spin_lock</span>(&amp;hb-&gt;lock);</span><br><span class="line"><span class="comment">// 遍历链表查找匹配的key</span></span><br><span class="line"><span class="built_in">plist_for_each_entry_safe</span>(<span class="keyword">this</span>, next, &amp;hb-&gt;chain, list) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">match_futex</span> (&amp;<span class="keyword">this</span>-&gt;key, &amp;key)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pi_state || <span class="keyword">this</span>-&gt;rt_waiter) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Check if one of the bits is set in both bitsets */</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">this</span>-&gt;bitset &amp; bitset))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">mark_wake_futex</span>(&amp;wake_q, <span class="keyword">this</span>); <span class="comment">// 将符合条件的task_struct放入wake_up队列</span></span><br><span class="line"><span class="keyword">if</span> (++ret &gt;= nr_wake) <span class="comment">// 达到唤醒的最大总数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">spin_unlock</span>(&amp;hb-&gt;lock);</span><br><span class="line"><span class="built_in">wake_up_q</span>(&amp;wake_q); <span class="comment">// 遍历wake_up队列, 将其中所有的线程唤醒（将他们的进程状态改为TASK_RUNNING）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>futex_wake</code> 流程如下：</p><ol><li>找到uaddr对应的 <code>futex_hash_bucket</code> ，即代码中的hb</li><li>对hb加自旋锁</li><li>遍历fb的链表，找到uaddr对应的节点</li><li>调用 <code>wake_futex</code> 唤起等待的进程</li><li>释放自旋锁</li></ol><p><strong>补充一个有意思的问题：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">int</span> lockval)</span> </span>&#123;</span><br><span class="line"><span class="comment">//trylock是用户级的自旋锁</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">trylock</span>(lockval)) &#123;</span><br><span class="line"><span class="built_in">wait</span>();<span class="comment">//释放cpu，并将当期线程加入等待队列，是系统调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">trylock</span><span class="params">(<span class="type">int</span> lockval)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>; </span><br><span class="line"><span class="comment">//localval=1代表上锁成功</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">compareAndSet</span>(lockval,<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(++i&gt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">int</span> lockval)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">compareAndSet</span>(lockval,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题是trylock和wait两个调用之间存在一个窗口：如果一个线程trylock失败，在调用wait时持有锁的线程释放了锁，当前线程还是会调用wait进行等待，但之后就没有人再将该线程唤醒了。</p><p>看完上述的内容，其实上述的问题在于wait和判断不是原子操作。那么futex怎么解决这个问题呢？</p><p>答案就是底层已经帮助我们实现，通过加自旋锁，保证了判断锁状态和挂起线程原子性。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/weixin_71478434/article/details/126591798">面试常用：Linux内核级同步机制–futex</a></li><li><a href="https://github.com/farmerjohngit/myblog/issues/6">关于同步的一点思考-上 #6</a></li><li><a href="https://www.cnblogs.com/HeyLUMouMou/p/17481385.html">从std::mutex到futex机制</a></li></ul><h3 id="condition-variable机制">condition_variable机制</h3><p><strong>Q1：C++的std::condition_variable实现</strong></p><p><code>condition_variable_t</code> 在其内部实现中<strong>通常使用 <code>futex</code> 来实现高效的等待和通知机制</strong>。具体来说，<code>std::condition_variable</code>（C++ 标准库中的条件变量）在使用时可能会依赖于 <code>futex</code>，特别是在 Linux 等支持 <code>futex</code> 的系统上。</p><p>C++ 条件变量（<code>std::condition_variable</code>）通常依赖于操作系统提供的同步原语，如 POSIX 线程（pthreads）在 Linux 中的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">    thread_queue wait_queue; <span class="comment">// 等待队列</span></span><br><span class="line">&#125; <span class="type">condition_variable_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv_wait</span><span class="params">(<span class="type">condition_variable_t</span> *cv, <span class="type">pthread_mutex_t</span> *mtx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程加入等待队列</span></span><br><span class="line">    <span class="built_in">enqueue</span>(&amp;cv-&gt;wait_queue, current_thread);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解锁互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(mtx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻塞当前线程，等待条件满足</span></span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;cv-&gt;cond, mtx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新获取互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv_notify_one</span><span class="params">(<span class="type">condition_variable_t</span> *cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;cv-&gt;cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv_notify_all</span><span class="params">(<span class="type">condition_variable_t</span> *cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_broadcast</span>(&amp;cv-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_cond_wait</code> 的实现的简化示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    pthread_mutex_unlock(mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 futex 进入等待状态</span></span><br><span class="line">    <span class="type">int</span> result = syscall(SYS_futex, &amp;cond-&gt;__data, FUTEX_WAIT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新获取互斥锁</span></span><br><span class="line">    pthread_mutex_lock(mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，<code>SYS_futex</code> 是 Linux 提供的 <code>futex</code> 系统调用，通过它可以在用户态和内核态之间切换，并将线程挂起。</p><p>有这个<code>pthread_cond_wait</code>，当然有<code>pthread_cond_signal</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 futex 唤醒一个等待线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">syscall</span>(SYS_futex, &amp;cond-&gt;__data, FUTEX_WAKE, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于唤醒等待队列中的线程。</p><p><code>futex</code> ：<code>futex</code> 是一种混合锁机制，主要在用户态工作，但在需要时会借助内核态进行线程管理。它的基本思想是：大部分情况下，线程的同步操作都在用户态完成，只有在竞争激烈或需要挂起/唤醒线程时才进入内核态处理。这样可以减少上下文切换，从而提高性能。</p><h3 id="Semaphore机制">Semaphore机制</h3><p>在 Linux 中，信号量的实现通常依赖于 <code>futex</code>（“fast userspace mutex”）机制。<code>futex</code> 是 Linux 内核提供的一种高效的同步原语，它允许大多数情况下的操作在用户态完成，而只有在需要等待或唤醒线程时才会进入内核态。</p><p>linux下Semaphore数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line">    <span class="type">atomic_t</span> count;                <span class="comment">// 信号量的计数器</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span> wait_lock;      <span class="comment">// 自旋锁，保护等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> wait_list;    <span class="comment">// 等待队列，用于存储等待获取信号量的进程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>futex</code> 与信号量的关系</strong></p><p>信号量的实现可以通过 <code>futex</code> 来管理等待和唤醒操作。<code>futex</code> 的核心思想是：<strong>在用户态通过共享内存中的一个整数变量进行快速的检查和更新，当需要阻塞或唤醒线程时，才通过 <code>futex</code> 系统调用进入内核态处理。</strong></p><p><strong>典型的信号量实现流程</strong></p><ol><li><p><strong>初始化</strong>：</p><ul><li>信号量通常包含一个计数器变量<code>count</code>，表示当前可用资源的数量。</li><li><code>count</code> 的初始值由创建信号量时指定。</li></ul></li><li><p><strong>P 操作</strong>（<code>wait</code> 或 <code>down</code>）：</p><ul><li>尝试将 <code>count</code> 减 1。如果减 1 后 <code>count &gt;= 0</code>，表示有可用资源，线程可以继续执行。</li><li>如果减 1 后 <code>count &lt; 0</code>，表示没有可用资源。此时，线程需要进入等待状态，等待其他线程释放资源。此时，<code>futex_wait</code> 系统调用会被用来将线程挂起。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> val = sem-&gt;count;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__sync_bool_compare_and_swap(&amp;sem-&gt;count, val, val - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 资源获取成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 资源不可用，使用 futex 挂起线程</span></span><br><span class="line">            syscall(SYS_futex, &amp;sem-&gt;count, FUTEX_WAIT, val, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>__sync_bool_compare_and_swap</code> 是一个原子操作，尝试将 <code>sem-&gt;count</code> 从 <code>val</code> 更新到 <code>val - 1</code>。如果 <code>count</code> 值在操作期间没有改变，则更新成功，线程获取资源。</li><li>如果 <code>count</code> 小于或等于 0，线程会调用 <code>futex_wait</code> 将自己挂起，直到信号量的值被其他线程增加并唤醒它。</li></ul></li><li><p><strong>V 操作</strong>（<code>signal</code> 或 <code>up</code>）：</p><ul><li>将信号量的 <code>count</code> 加 1。</li><li>如果 <code>count</code> 加 1 后结果大于 0 且有线程因为等待资源而阻塞，则需要唤醒一个等待的线程。此时，<code>futex_wake</code> 系统调用会被用来唤醒等待的线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old_value = __sync_fetch_and_add(&amp;sem-&gt;count, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (old_value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 唤醒挂起的线程</span></span><br><span class="line">        syscall(SYS_futex, &amp;sem-&gt;count, FUTEX_WAKE, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>__sync_fetch_and_add</code> 是一个原子操作，它将 <code>sem-&gt;count</code> 增加 1，并返回增加前的值。</li><li>如果增加前的 <code>count</code> 小于 0（表示有线程在等待），则调用 <code>futex_wake</code> 唤醒一个等待的线程。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">多线程实战总结</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>改善网络程序的44个技巧</title>
    <link href="https://penge666.github.io/posts/bfaa091a.html"/>
    <id>https://penge666.github.io/posts/bfaa091a.html</id>
    <published>2024-08-12T01:46:36.000Z</published>
    <updated>2024-09-15T11:12:49.453Z</updated>
    
    <content type="html"><![CDATA[<p>《不要慌太阳下山有月光》</p><p>《不要慌太阳下山有月光》</p><p>《不要慌太阳下山有月光》</p><p>安利一首好听的歌儿~</p><p>也许你身处黑暗之中</p><p>快记不清当初的梦</p><p>低下头两手空空</p><p>怅然若失般心痛</p><p>世上每个人花期不同</p><p>你也会和美好相逢</p><p>张开双臂迎向风</p><p>那时你一定更好更勇更从容</p><p>不要迷茫 不要慌张</p><p>太阳下山 还有月光</p><p>它会把人生路照亮</p><p>陪你到想去的地方</p><p>月亮睡了 还有朝阳</p><p>抬头看天一定会亮</p><h2 id="技巧1-理解面向链接和无连接协议之间的区别"><a href="#技巧1-理解面向链接和无连接协议之间的区别" class="headerlink" title="技巧1:理解面向链接和无连接协议之间的区别"></a>技巧1:理解面向链接和无连接协议之间的区别</h2><ul><li>对于无连接协议来说，每个分组的处理都独立于所有其他分组，而对于面向连接的协议来说，协议实现维护了与后继分组有关的状态信息。</li><li>对TCP来说，连接完全是想象的，它是由端点所记忆的状态组成的， 并不存在“物理”连接。</li></ul><p><strong>面向链接</strong></p><p><strong>定义</strong>: 面向连接的协议在数据传输之前，需要建立一个稳定的连接，并在数据传输完成后拆除这个连接。它确保数据在传输过程中不会丢失、重复、乱序或损坏。</p><p><strong>示例</strong>:</p><ul><li><p>TCP（传输控制协议）</p><p>: 用于互联网中的许多应用，如网页浏览、电子邮件、文件传输等。</p><ul><li><strong>连接建立</strong>: 通过三次握手（SYN, SYN-ACK, ACK）建立连接。</li><li><strong>可靠性</strong>: 确保数据包的可靠传输和顺序。</li></ul></li></ul><p><strong>无连接协议</strong></p><p><strong>定义</strong>: 无连接的协议在数据传输过程中不需要建立连接，每个数据包（或称为数据报）都是独立的。它不保证数据的到达、顺序或完整性，接收方可能需要处理数据丢失或乱序的问题。</p><p><strong>示例</strong>:</p><ul><li><p>UDP（用户数据报协议）</p><p>: 用于需要低延迟和高吞吐量的应用，如视频流、在线游戏、DNS 查询等。</p><ul><li><strong>无连接</strong>: 发送数据包时不需要建立连接。</li><li><strong>不可靠</strong>: 数据包可能会丢失、重复或乱序。</li></ul></li></ul><p><strong>以下是一个简单的 UDP 客户端和服务器示例，展示了如何使用 UDP 进行数据传输。</strong></p><p><strong>UDP 服务器（C++）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 UDP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    servaddr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> n = recvfrom(sockfd, (<span class="type">char</span>*)buffer, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, (<span class="type">socklen_t</span>*)&amp;len);</span><br><span class="line">    buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Client: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">    sendto(sockfd, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP 客户端（C++）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 UDP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(PORT);</span><br><span class="line">    servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line">    sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(servaddr);</span><br><span class="line">    <span class="type">int</span> n = recvfrom(sockfd, (<span class="type">char</span>*)buffer, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, (<span class="type">socklen_t</span>*)&amp;len);</span><br><span class="line">    buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Server: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧2-理解子网和CIDR的概念"><a href="#技巧2-理解子网和CIDR的概念" class="headerlink" title="技巧2:理解子网和CIDR的概念"></a>技巧2:理解子网和CIDR的概念</h2><p><strong>A、B、C、D、E类网络，网络ID和主机ID</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240822100022842.png" alt="image-20240822100022842"></p><p>D类地址用于多播编址，E类地址留作未来使用。剩下的A、B和C类地址是用于标识单个网络和主机的主要地址类型。</p><p>地址类别是由前导1比特的个数标识的。A类有零个前导1比特，B类有一个,C类有两个，以此类推。标识地址的类型是非常重要的，因为对其余比特的解释都取决于地址的类型。</p><p><strong>子网划分</strong></p><ul><li><p>概念：<strong>子网划分</strong>是通过修改 IP 地址和子网掩码来创建多个逻辑上的子网络。每个子网都是原始网络的一部分，但它们在逻辑上是分开的。子网划分的核心是调整 IP 地址中的网络部分和主机部分，以便将一个大的网络拆分成多个小的网络。</p></li><li><p>例子：</p><p>192.168.1.0/26 (地址范围：192.168.1.0 到 192.168.1.63)<br>192.168.1.64/26 (地址范围：192.168.1.64 到 192.168.1.127)<br>192.168.1.128/26 (地址范围：192.168.1.128 到 192.168.1.191)<br>192.168.1.192/26 (地址范围：192.168.1.192 到 192.168.1.255)</p></li><li><p>好处：</p><ul><li><p><strong>提高网络性能</strong>:</p><ul><li>将大型网络划分为多个子网可以减少广播风暴的范围。广播仅在子网内部传播，从而降低了网络的负荷和拥塞。</li></ul></li><li><p><strong>增强网络安全</strong>:</p><ul><li>子网划分可以隔离网络中的不同部门或功能，使得安全策略可以在每个子网中独立应用。这可以限制潜在的安全威胁和数据泄露。</li></ul><p><strong>优化地址空间使用</strong>:</p><ul><li>子网划分可以有效地利用 IP 地址空间，避免了地址浪费。例如，将一个大型网络划分为多个小网络可以更精确地分配 IP 地址。</li></ul></li></ul></li></ul><p><strong>CIDR——Classless Inter Domain Routing，无类别域间路由</strong></p><p>CIDR（Classless Inter-Domain Routing，无类别域间路由）是一种用于 IP 地址分配和路由选择的方法，旨在解决传统分类地址（Classful Addressing）中的一些限制。CIDR 通过引入更灵活的子网掩码和更有效的路由聚合方法来提高 IP 地址的利用率和路由效率。</p><p><strong>CIDR 的主要特点</strong></p><ol><li><strong>无类别地址分配</strong>:<ul><li><strong>传统分类地址</strong>: IP 地址分为 A、B、C 类等，每类有固定的子网掩码（如 A 类是 8 位，B 类是 16 位，C 类是 24 位）。</li><li><strong>CIDR</strong>: <strong>IP 地址和子网掩码的长度不再受到固定分类的限制</strong>。CIDR 允许使用任意长度的子网掩码，使得地址分配更灵活和高效。</li></ul></li><li><strong>前缀长度表示法</strong>:<ul><li>CIDR 使用前缀长度来表示子网掩码的大小，例如 <code>192.168.0.0/24</code>。</li><li><code>192.168.0.0/24</code> 表示前 24 位是网络部分，剩余的 8 位是主机部分。<strong>这种表示方法比传统的 IP 地址和子网掩码形式更加直观。</strong></li></ul></li><li><strong>路由聚合（Prefix Aggregation）</strong>:<ul><li>CIDR 支持路由聚合，<strong>即将多个连续的 IP 地址块聚合为一个更大的路由前缀</strong>，从而减少路由表的大小和复杂性。</li><li>例如，将 <code>192.168.0.0/24</code> 和 <code>192.168.1.0/24</code> 聚合为 <code>192.168.0.0/23</code>。</li></ul></li><li><strong>改进了路由表的可扩展性</strong>:<ul><li>由于路由聚合的能力，CIDR 减少了需要在网络路由器中存储的路由条目数量，从而减轻了路由器的负担，提高了网络的可扩展性。</li></ul></li></ol><p><strong>CIDR 的示例</strong></p><p><strong>1. IP 地址和前缀长度</strong></p><ul><li><strong>地址</strong>: <code>192.168.1.0</code></li><li>前缀长度/24<ul><li><strong>子网掩码</strong>: <code>255.255.255.0</code></li></ul></li></ul><p>这表示 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 的所有地址属于同一网络。</p><p><strong>2. 路由聚合</strong></p><ul><li>原始网络<ul><li><code>192.168.0.0/24</code></li><li><code>192.168.1.0/24</code></li><li><code>192.168.2.0/24</code></li></ul></li><li>聚合后的网络<ul><li><code>192.168.0.0/22</code></li></ul></li></ul><p><code>192.168.0.0/22</code> 覆盖了从 <code>192.168.0.0</code> 到 <code>192.168.3.255</code> 的地址范围，可以将多个小的网络聚合为一个更大的网络，从而减少路由条目。</p><h2 id="技巧3-理解私有地址和NAT"><a href="#技巧3-理解私有地址和NAT" class="headerlink" title="技巧3:理解私有地址和NAT"></a>技巧3:理解私有地址和NAT</h2><p><strong>NAT（Network Address Translation）</strong> 和 <strong>PAT（Port Address Translation）</strong> 是两种在网络中常见的地址转换技术，用于处理 IP 地址的分配和管理。</p><ul><li>NAT——Network Address Translation，网络地址翻译</li><li>PAT——Port Address Translation，端口地址转换</li></ul><h3 id="NAT（网络地址翻译）"><a href="#NAT（网络地址翻译）" class="headerlink" title="NAT（网络地址翻译）"></a>NAT（网络地址翻译）</h3><p><strong>NAT</strong> 是一种技术，用于将私有网络中的 IP 地址转换为公共网络中的 IP 地址，允许多个设备共享一个公共 IP 地址。这主要用于解决 IP 地址短缺问题以及提供网络安全性。</p><p><strong>NAT 的工作原理</strong>:</p><ol><li><strong>内部网络（私有网络）</strong>:<ul><li>在本地网络中，设备使用私有 IP 地址（例如 <code>192.168.1.0/24</code>）。</li><li>这些私有地址在互联网上是不可路由的。</li></ul></li><li><strong>NAT 设备（通常是路由器或防火墙）</strong>:<ul><li>NAT 设备将内部网络中的私有 IP 地址转换为公共 IP 地址。</li><li>内部设备发出的数据包在离开本地网络时，源 IP 地址被替换为 NAT 设备的公共 IP 地址。</li></ul></li><li><strong>外部网络（公共网络）</strong>:<ul><li>返回的数据包通过 NAT 设备，将公共 IP 地址和端口号转换回原始的私有 IP 地址和端口号。</li></ul></li></ol><p><strong>NAT 示例</strong>:</p><ul><li><strong>私有 IP 地址</strong>: <code>192.168.1.10</code></li><li><strong>公共 IP 地址</strong>: <code>203.0.113.1</code></li><li>转换过程<ul><li>内部设备 <code>192.168.1.10</code> 发出请求到互联网。</li><li>NAT 设备将源 IP 地址 <code>192.168.1.10</code> 替换为公共 IP 地址 <code>203.0.113.1</code>。</li><li>外部服务器看到的请求来源是 <code>203.0.113.1</code>。</li><li>响应返回时，NAT 设备将目标 IP 地址 <code>203.0.113.1</code> 转换回 <code>192.168.1.10</code>，并将数据包送回内部设备。</li></ul></li></ul><h3 id="PAT（端口地址转换）"><a href="#PAT（端口地址转换）" class="headerlink" title="PAT（端口地址转换）"></a>PAT（端口地址转换）</h3><p><strong>PAT</strong>，也称为 <strong>NAT Overloading</strong>，是 NAT 的一种扩展，允许多个内部设备通过同一个公共 IP 地址访问互联网。它通过使用不同的端口号来区分不同的会话。</p><p><strong>PAT 的工作原理</strong>:</p><ol><li><strong>内部网络（私有网络）</strong>:<ul><li>多个设备使用私有 IP 地址。</li></ul></li><li><strong>PAT 设备（通常是路由器或防火墙）</strong>:<ul><li>PAT 设备将内部设备的 IP 地址和端口号映射到一个公共 IP 地址的不同端口号上。</li><li>例如，两个内部设备的流量都可以通过公共 IP 地址的不同端口号进行区分。</li></ul></li><li><strong>外部网络（公共网络）</strong>:<ul><li>外部服务器看到的是公共 IP 地址和端口号。</li><li>响应数据包通过 PAT 设备，将公共 IP 地址和端口号映射回内部设备的 IP 地址和端口号。</li></ul></li></ol><p><strong>PAT 示例</strong>:</p><ul><li>私有 IP 地址和端口号<ul><li><code>192.168.1.10:12345</code></li><li><code>192.168.1.11:54321</code></li></ul></li><li><strong>公共 IP 地址</strong>: <code>203.0.113.1</code></li><li>PAT 映射<ul><li><code>192.168.1.10:12345</code> → <code>203.0.113.1:10001</code></li><li><code>192.168.1.11:54321</code> → <code>203.0.113.1:10002</code></li></ul></li><li>转换过程<ul><li>内部设备 <code>192.168.1.10</code> 通过端口 <code>12345</code> 发出请求。</li><li>PAT 设备将请求的源地址 <code>192.168.1.10:12345</code> 转换为 <code>203.0.113.1:10001</code>。</li><li>内部设备 <code>192.168.1.11</code> 通过端口 <code>54321</code> 发出请求。</li><li>PAT 设备将请求的源地址 <code>192.168.1.11:54321</code> 转换为 <code>203.0.113.1:10002</code>。</li><li>外部服务器响应时，返回的目标地址 <code>203.0.113.1:10001</code> 和 <code>203.0.113.1:10002</code> 被 PAT 设备映射回内部设备的 IP 地址和端口号。</li></ul></li></ul><p><strong>总结</strong></p><ul><li><strong>NAT</strong> 用于将私有 IP 地址转换为公共 IP 地址，以便多个设备可以共享一个公共 IP 地址进行互联网访问。</li><li><strong>PAT</strong> 是 NAT 的一种形式，通过不同的端口号来区分不同的内部会话，允许多个内部设备共享同一个公共 IP 地址。</li></ul><p><strong>补充</strong>：</p><p><strong>私有 IP 地址范围</strong>：</p><ol><li><strong><code>10.0.0.0/8</code></strong>:<ul><li>范围：<code>10.0.0.0</code> 到 <code>10.255.255.255</code></li><li>这个范围支持 1677 万个地址。</li></ul></li><li><strong><code>172.16.0.0/12</code></strong>:<ul><li>范围：<code>172.16.0.0</code> 到 <code>172.31.255.255</code></li><li>这个范围支持 1048 万个地址。</li></ul></li><li><strong><code>192.168.0.0/16</code></strong>:<ul><li>范围：<code>192.168.0.0</code> 到 <code>192.168.255.255</code></li><li>这个范围支持 65,536 个地址。</li></ul></li></ol><h2 id="技巧4-开发并使用应用程序“框架”"><a href="#技巧4-开发并使用应用程序“框架”" class="headerlink" title="技巧4:开发并使用应用程序“框架”"></a>技巧4:开发并使用应用程序“框架”</h2><ul><li>TCP服务端：socket-&gt;bind-&gt;listen-&gt;accept</li><li>TCP客户端：socket-&gt;connect</li><li>UDP服务端：socket-&gt;bind</li><li>UDP客户端：socket</li></ul><h2 id="技巧5-套接字接口比XTI-TLI更好用"><a href="#技巧5-套接字接口比XTI-TLI更好用" class="headerlink" title="技巧5:套接字接口比XTI/TLI更好用"></a>技巧5:套接字接口比XTI/TLI更好用</h2><p>略</p><h2 id="技巧6-记住，TCP是一种流协议"><a href="#技巧6-记住，TCP是一种流协议" class="headerlink" title="技巧6:记住，TCP是一种流协议"></a>技巧6:记住，TCP是一种流协议</h2><ul><li>TCP是一种流协议,数据以字节流的形式传递给接收者的，没有固有的“报文”或“报文边界”的概念</li></ul><h2 id="技巧7-不要低估TCP的性能"><a href="#技巧7-不要低估TCP的性能" class="headerlink" title="技巧7:不要低估TCP的性能"></a>技巧7:不要低估TCP的性能</h2><p>可以查看原书中的性能对比</p><h2 id="技巧8-避免重新编写TCP"><a href="#技巧8-避免重新编写TCP" class="headerlink" title="技巧8:避免重新编写TCP"></a>技巧8:避免重新编写TCP</h2><p>假设你正在开发一个需要可靠数据传输的网络应用程序：</p><ul><li><strong>正确做法</strong>: 使用操作系统提供的 TCP 协议栈，通过 <code>socket</code> 创建 TCP 连接，使用 <code>send</code> 和 <code>recv</code> 函数进行数据传输。这样，你可以利用 TCP 的流量控制、拥塞控制等特性，确保数据的可靠传输。</li><li><strong>错误做法</strong>: 重新实现 TCP 协议的所有功能，例如手动实现数据重传、顺序保证、流量控制等，这将是一个非常复杂且容易出错的任务。</li></ul><h2 id="技巧9-要认识到TCP是一个可靠的，但并不绝对可靠的协议"><a href="#技巧9-要认识到TCP是一个可靠的，但并不绝对可靠的协议" class="headerlink" title="技巧9:要认识到TCP是一个可靠的，但并不绝对可靠的协议"></a>技巧9:要认识到TCP是一个可靠的，但并不绝对可靠的协议</h2><p><strong>（1) 永久或临时的网络中断</strong></p><p><strong>背景</strong>:</p><ul><li><strong>场景</strong>: 一个分布式应用程序在不同地理位置的数据中心之间传输数据。连接依赖于互联网或广域网，这些网络可能会遭遇临时或永久的中断。</li></ul><p><strong>解释</strong>:</p><ul><li><strong>临时网络中断</strong>: 网络中断可能是暂时的，例如由于网络设备重启或维护。TCP 会尝试重新连接和重传数据，但可能会引入延迟。</li><li><strong>永久网络中断</strong>: 如果网络中断是永久性的，例如由于物理链路断裂或网络设备故障，TCP 连接将无法恢复，应用程序需要检测连接中断并采取适当措施，如尝试重新建立连接或通知用户。</li></ul><p><strong>示例</strong>:</p><ul><li>在一个跨国企业的文件同步应用中，如果两地之间的网络链路出现故障，TCP 可能会重试连接，但长时间的中断可能导致数据同步失败。</li></ul><p><strong>(2) 对等的应用程序崩溃</strong></p><p><strong>背景</strong>:</p><ul><li><strong>场景</strong>: 一个客户端-服务器应用程序，其中客户端和服务器通过 TCP 连接进行通信。服务器应用程序崩溃或退出时，连接将被中断。</li></ul><p><strong>解释</strong>:</p><ul><li><strong>应用程序崩溃</strong>: 如果服务器端应用程序崩溃或异常退出，TCP 连接将被断开。虽然 TCP 会尝试重连，但在应用程序崩溃的情况下，重新建立连接可能无法进行，且数据丢失或未处理的数据需要应用层进行补救。</li></ul><p><strong>示例</strong>:</p><ul><li>在一个实时聊天应用中，如果服务器端的聊天服务崩溃，客户端会失去连接。TCP 会检测到连接丢失，但客户端需要能够处理连接丢失，重新连接或通知用户。</li></ul><p><strong>(3) 运行对等应用程序的主机崩溃</strong></p><p><strong>背景</strong>:</p><ul><li><strong>场景</strong>: 一个分布式系统，其中某些应用程序运行在主机上。这些主机可能会因为硬件故障或操作系统崩溃而宕机。</li></ul><p><strong>解释</strong>:</p><ul><li><strong>主机崩溃</strong>: 如果运行 TCP 应用程序的主机崩溃或关闭，TCP 连接会被断开。虽然 TCP 连接的另一端可能会检测到连接中断并尝试重连，但主机崩溃的情况通常需要应用层处理，以便在主机恢复后能够继续操作或重启服务。</li></ul><p><strong>示例</strong>:</p><ul><li>在一个分布式数据库系统中，如果存储节点的主机崩溃，数据传输会中断。数据库系统需要实现机制来检测节点故障、重新分配任务，并在节点恢复时重新同步数据。</li></ul><h2 id="技巧10-记住，TCP-IP不是轮询的"><a href="#技巧10-记住，TCP-IP不是轮询的" class="headerlink" title="技巧10:记住，TCP/IP不是轮询的"></a>技巧10:记住，TCP/IP不是轮询的</h2><ul><li>TCP没有提供将连接丢失即时通知给应用程序的方法。<ul><li>TCP 协议本身并不会主动或立即通知应用程序某个连接已经断开或失效。TCP 提供了可靠的数据传输保证，但它不会即时地将连接状态的变化（如连接丢失）反馈给应用程序。</li></ul></li><li>保持活跃(keep-alive)</li><li>心跳信号(epoll, pthread)</li></ul><h2 id="技巧11-提防对等实体的不友好动作"><a href="#技巧11-提防对等实体的不友好动作" class="headerlink" title="技巧11:提防对等实体的不友好动作"></a>技巧11:提防对等实体的不友好动作</h2><h2 id="技巧12-成功的LAN策略不一定能推广到WAN中"><a href="#技巧12-成功的LAN策略不一定能推广到WAN中" class="headerlink" title="技巧12:成功的LAN策略不一定能推广到WAN中"></a>技巧12:成功的LAN策略不一定能推广到WAN中</h2><p><strong>核心思想</strong></p><ol><li><strong>网络特性差异</strong>:<ul><li><strong>局域网（LAN）</strong>: 通常具有较低的延迟和较高的带宽，网络环境相对稳定，数据传输速度较快。</li><li><strong>广域网（WAN）</strong>: 包括多个网络环境，通常存在较高的延迟和较低的带宽，网络波动和丢包率可能较高。</li></ul></li><li><strong>策略和优化</strong>:<ul><li><strong>LAN 策略</strong>: 在 LAN 环境中，应用程序和网络策略可能会基于高速连接和低延迟的假设进行设计和优化。</li><li><strong>WAN 环境</strong>: 这些策略在 WAN 环境中可能不再适用，因为 WAN 的网络条件较差，可能需要不同的策略和优化手段。</li></ul></li></ol><ul><li><strong>Example 1</strong>: <strong>实时视频会议</strong>:<ul><li><strong>LAN</strong>: 在企业内部的局域网中，视频会议可以实现高质量的视频和音频流，因为网络延迟低且带宽充足。</li><li><strong>WAN</strong>: 当视频会议扩展到广域网时，需要考虑网络延迟和带宽限制，可能会导致视频质量下降或出现卡顿现象。需要使用更高效的视频压缩技术和自适应码率调整策略。</li></ul></li><li><strong>Example 2</strong>: <strong>文件同步应用</strong>:<ul><li><strong>LAN</strong>: 内部文件同步可以实现快速的实时同步。</li><li><strong>WAN</strong>: 在跨区域同步文件时，需要处理更大的延迟和带宽波动，采用增量同步和数据压缩等策略来提高性能。</li></ul></li></ul><h2 id="技巧13-了解协议是怎样工作的"><a href="#技巧13-了解协议是怎样工作的" class="headerlink" title="技巧13:了解协议是怎样工作的"></a>技巧13:了解协议是怎样工作的</h2><ul><li>RFC是TCP/IP的官方规范</li></ul><h2 id="技巧14-不要把OSI七层参考模型太当回事"><a href="#技巧14-不要把OSI七层参考模型太当回事" class="headerlink" title="技巧14:不要把OSI七层参考模型太当回事"></a>技巧14:不要把OSI七层参考模型太当回事</h2><ul><li>OSI和TCP/IP</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240822103343607.png" alt="image-20240822103343607"></p><h2 id="技巧15-理解TCP的写操作"><a href="#技巧15-理解TCP的写操作" class="headerlink" title="技巧15:理解TCP的写操作"></a>技巧15:理解TCP的写操作</h2><ul><li>从应用程序的角度来看，最好把写操作当作是一项将数据从用户空间拷贝到内核发送缓冲区，然后就返回的操作。</li><li>如果发送端应用程序崩溃了，TCP会继续尝试着将数据传递给对等实体。</li></ul><h2 id="技巧16-理解TCP的有序释放操作"><a href="#技巧16-理解TCP的有序释放操作" class="headerlink" title="技巧16:理解TCP的有序释放操作"></a>技巧16:理解TCP的有序释放操作</h2><ul><li><p>有序释放是在确保没有数据丢失的情况下拆除n连接的一个过程。</p></li><li><p>shutdown与close的区别</p><ul><li><strong><code>shutdown</code></strong>:<ul><li>用于部分关闭 socket（如停止发送或接收数据），允许对端继续操作，但不能再使用指定的方向进行通信。</li><li>并没有释放套接字及其资源</li><li>调用shutdown时，会影响到所有打开了那个套接字的进程。</li><li>FIN发送：用how =1来调用shutdown 时，不管其他进程是否打开了这个套接字，都可以保证对等实体会收到一个EOF。</li></ul></li><li><strong><code>close</code></strong><ul><li>用于完全关闭 socket，释放所有资源，断开连接，对端会收到连接关闭的通知。</li><li>释放套接字及其资源</li><li>调用close或closesocket，套接字的其他持有者仍然能够像什么事情都没有发生一样使用它。</li><li>调用close或closesocket就无法确保这一点，因为在套接字的引用计数减少到零之前，它都不会将FIN发送给对等实体。也就是说，所有进程关闭套接字后，它才将FIN发送给对等实体。</li></ul></li></ul><p><strong>总结：<code>shutdown</code> 是通过操作系统内核直接影响套接字的状态的。<code>close</code> 只是释放了当前进程的套接字描述符，并不会立即影响其他进程或线程的套接字描述符。</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240822105203975.png" alt="image-20240822105203975"></p><p>Q：<strong>可以用 <code>shutdown</code> 释放资源吗？</strong></p><p>A：不可以，<code>shutdown</code> 专注于数据流控制，而不是资源管理。必须使用 <code>close</code> 函数释放资源。</p></li></ul><h2 id="技巧17-考虑用inetd来装载应用程序"><a href="#技巧17-考虑用inetd来装载应用程序" class="headerlink" title="技巧17:考虑用inetd来装载应用程序"></a>技巧17:考虑用inetd来装载应用程序</h2><p><strong><code>inetd</code> 介绍</strong>:</p><ul><li><strong><code>inetd</code></strong>（Internet Daemon）是一个服务守护进程，负责监听指定的网络端口，并根据配置文件中的规则启动相应的服务程序处理请求。</li><li>通过配置文件 (<code>/etc/inetd.conf</code>)，<code>inetd</code> 可以决定哪些服务应该由哪些程序处理，并在接收到连接请求时启动相应的程序。</li></ul><p><strong>使用 <code>inetd</code> 的优点</strong>:</p><ol><li><strong>资源节省</strong>: <code>inetd</code> 只有在收到连接请求时才启动相应的服务程序，而不是让服务程序常驻内存。这样可以节省系统资源。</li><li><strong>简化管理</strong>: 通过集中管理配置文件，减少了对多个守护进程的管理负担。只需编辑 <code>inetd.conf</code> 配置文件即可添加或修改服务。</li><li><strong>灵活配置</strong>: 可以灵活配置哪些服务由 <code>inetd</code> 处理，并轻松调整服务程序的路径或参数。</li></ol><p><strong>举例说明</strong></p><p>假设你希望在系统上提供 FTP 和 Telnet 服务，但不希望这些服务程序一直运行，从而节省系统资源。可以使用 <code>inetd</code> 来管理这些服务。</p><ol><li><p><strong>安装和配置 <code>inetd</code></strong>:</p><ul><li><p>确保系统上安装了 <code>inetd</code>。在许多现代 Linux 系统上，<code>inetd</code> 被 <code>xinetd</code> 替代，你可以使用 <code>xinetd</code> 进行类似的配置。</p></li><li><p>编辑 <code>/etc/inetd.conf</code> 文件，添加以下配置来定义 FTP 和 Telnet 服务：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp     stream  tcp     nowait  root  /usr/sbin/<span class="keyword">in</span><span class="selector-class">.ftpd</span>   <span class="keyword">in</span><span class="selector-class">.ftpd</span></span><br><span class="line">telnet  stream  tcp     nowait  root  /usr/sbin/<span class="keyword">in</span><span class="selector-class">.telnetd</span> <span class="keyword">in</span>.telnetd</span><br></pre></td></tr></table></figure><ul><li><code>ftp</code>: 服务名。</li><li><code>stream</code>: 套接字类型（流式）。</li><li><code>tcp</code>: 使用的协议。</li><li><code>nowait</code>: 表示服务程序不会并发处理多个连接。</li><li><code>root</code>: 服务程序的用户身份。</li><li><code>/usr/sbin/in.ftpd</code>: 服务程序的路径。</li><li><code>in.ftpd</code>: 服务程序的名称。</li></ul></li></ul></li><li><p><strong>启动 <code>inetd</code></strong>:</p><ul><li>启动 <code>inetd</code> 守护进程（如果未运行）。通常，<code>inetd</code> 会在系统启动时自动启动。</li></ul></li><li><p><strong>测试配置</strong>:</p><ul><li>连接到指定的端口（如 FTP 的 21 端口或 Telnet 的 23 端口），<code>inetd</code> 会启动相应的服务程序来处理请求。</li></ul></li></ol><p><strong>示例操作</strong></p><p>假设我们在 <code>/etc/inetd.conf</code> 中配置了 Telnet 服务。连接到 Telnet 的 23 端口时，<code>inetd</code> 会启动 <code>in.telnetd</code> 程序来处理连接。</p><p><strong>启动 <code>inetd</code></strong>:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service inetd <span class="literal">start</span></span><br></pre></td></tr></table></figure><p><strong>连接 Telnet</strong>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">telnet localhost</span></span><br></pre></td></tr></table></figure><p>在连接到 Telnet 端口时，<code>inetd</code> 会自动启动 <code>in.telnetd</code> 程序，并处理该连</p><h2 id="技巧18-考虑用tcpmux为服务器“分配”知名端口"><a href="#技巧18-考虑用tcpmux为服务器“分配”知名端口" class="headerlink" title="技巧18:考虑用tcpmux为服务器“分配”知名端口"></a>技巧18:考虑用tcpmux为服务器“分配”知名端口</h2><p><strong><code>tcpmux</code></strong> 用于在一个知名端口上复用多个服务。它允许多个不同的网络服务共享一个端口，通过接收服务请求并根据请求内容将连接转发到对应的服务程序，从而简化端口管理和配置。</p><p><strong><code>tcpmux</code> 介绍</strong></p><ul><li><strong><code>tcpmux</code></strong>（TCP Port Multiplexer）是一种协议，用于在单个端口上复用多个服务。它通过 TCP 端口复用允许多个服务共享一个知名端口（通常是 1-1023 端口范围内的端口）。</li><li><code>tcpmux</code> 协议使用一个预定义的端口（通常是端口 1）来接收请求，并根据请求内容决定将连接转发到哪个实际服务程序。</li></ul><p><strong><code>tcpmux</code> 的优点</strong></p><ol><li><strong>简化端口管理</strong>: 可以通过一个端口管理多个服务，减少对知名端口的占用。</li><li><strong>减少冲突</strong>: 减少服务程序之间的端口冲突，尤其是当系统上有多个服务需要运行时。</li><li><strong>提高安全性</strong>: 通过集中管理端口，可以简化防火墙配置，并对外提供统一的入口。</li></ol><p><strong>举例说明</strong></p><p>假设你有多个服务需要运行，如 FTP、Telnet 和 HTTP。你希望将它们集中在一个知名端口上，以简化管理和配置。可以使用 <code>tcpmux</code> 来实现这一点。</p><p><strong>1. 配置 <code>tcpmux</code></strong></p><p><strong>步骤 1: 安装和配置 <code>tcpmux</code></strong></p><ul><li>在现代系统上，<code>tcpmux</code> 可能不再广泛使用，或者其实现方式可能有所不同。如果使用 <code>tcpmux</code> 的传统实现，你可以在 <code>/etc/tcpmuxd.conf</code> 或类似的配置文件中设置服务。</li></ul><p><strong>步骤 2: 编辑配置文件</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 tcpmuxd.conf 文件中配置服务</span></span><br><span class="line">ftp     stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.ftpd   <span class="keyword">in</span>.ftpd</span><br><span class="line">telnet  stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.telnetd <span class="keyword">in</span>.telnetd</span><br><span class="line">http    stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.httpd   <span class="keyword">in</span>.httpd</span><br></pre></td></tr></table></figure><ul><li>上述配置将 FTP、Telnet 和 HTTP 服务与 <code>tcpmux</code> 绑定，并使用 <code>tcpmux</code> 端口（通常是端口 1）来复用这些服务。</li></ul><p><strong>步骤 3: 启动 <code>tcpmux</code></strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tcpmuxd <span class="literal">start</span></span><br></pre></td></tr></table></figure><p><strong>步骤 4: 测试 <code>tcpmux</code></strong></p><ul><li>连接到端口 1，并发送服务请求。例如，使用 telnet 连接到端口 1，发送相应的服务名称来选择所需的服务：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">telnet</span> localhost <span class="number">1</span></span><br></pre></td></tr></table></figure><p>补充·：<strong>Telnet</strong> 使用 <strong>Telnet 协议</strong>，这是一种基于 <strong>TCP</strong> 的应用层协议。它通过 TCP 的端口 23 进行通信，允许用户在远程计算机上进行交互式命令行会话。</p><p>在 <code>tcpmux</code> 接收到请求后，它会解析请求并将连接转发到正确的服务程序，如 FTP、Telnet 或 HTTP 服务。</p><p><strong>示例操作</strong></p><p>假设你配置了以下服务:</p><ul><li>FTP 通过端口 21</li><li>Telnet 通过端口 23</li><li>HTTP 通过端口 80</li></ul><p>你可以使用 <code>tcpmux</code> 监听端口 1，根据请求的内容将连接转发到相应的服务程序。</p><p><strong>简化配置</strong></p><p><strong>通过 <code>tcpmux</code> 管理的网络服务配置示例:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 tcpmux 管理多个服务</span></span><br><span class="line"><span class="number">1</span>   stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/tcpmuxd  tcpmuxd</span><br></pre></td></tr></table></figure><p><strong>在配置文件中定义服务:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置服务程序</span></span><br><span class="line">ftp     stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.ftpd   <span class="keyword">in</span>.ftpd</span><br><span class="line">telnet  stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.telnetd <span class="keyword">in</span>.telnetd</span><br><span class="line">http    stream  tcp     nowait  root  <span class="regexp">/usr/</span>sbin/<span class="keyword">in</span>.httpd   <span class="keyword">in</span>.httpd</span><br></pre></td></tr></table></figure><h2 id="技巧19-考虑使用两条TCP连接"><a href="#技巧19-考虑使用两条TCP连接" class="headerlink" title="技巧19:考虑使用两条TCP连接"></a>技巧19:考虑使用两条TCP连接</h2><p><strong>使用两条 TCP 连接的好处</strong>:</p><ol><li><strong>分离控制和数据流</strong>: 在某些应用场景中，分离控制信息和数据传输可以提高通信的效率和可靠性。例如，一个连接专用于控制命令和管理操作，而另一个连接用于数据传输，这样可以减少数据和控制信息之间的干扰。</li><li><strong>提高性能</strong>: 通过将控制和数据流分开，应用程序可以更好地优化每条连接的性能。例如，控制连接可以保持较低的延迟，而数据连接可以处理大量数据传输，提高整体效率。</li><li><strong>增强可靠性</strong>: 使用两条连接可以提高系统的容错能力。如果一个连接出现问题，另一个连接仍然可以继续工作，减少服务中断的风险。</li></ol><p><strong>举例说明</strong></p><p><strong>1. 文件传输与控制命令</strong></p><p>在某些文件传输协议中，如 FTP（文件传输协议），使用两条 TCP 连接的设计是典型的例子：</p><ul><li><strong>控制连接</strong>: 用于发送命令和接收服务器的响应。通常使用端口 21。</li><li><strong>数据连接</strong>: 用于实际传输文件数据。通常在建立控制连接后动态分配端口。</li></ul><p><strong>示例操作</strong>:</p><ul><li><strong>FTP 控制连接</strong>: 客户端通过端口 21 连接到 FTP 服务器，发送命令如 <code>LIST</code>、<code>RETR</code>（取回文件）、<code>STOR</code>（存储文件），服务器响应这些命令。</li><li><strong>FTP 数据连接</strong>: 当客户端请求文件列表时，服务器在另一条数据连接上传输文件列表数据。数据连接在不同的端口上建立，用于传输实际的文件数据或目录列表。</li></ul><p><strong>2. 聊天应用程序</strong></p><p>在聊天应用程序中，可以使用两条 TCP 连接来分离聊天消息和控制信号：</p><ul><li><strong>聊天消息连接</strong>: 用于传输聊天消息内容，确保消息的高效传输。</li><li><strong>控制信号连接</strong>: 用于传输控制信号，如用户状态更新、连接管理等。</li></ul><p><strong>示例操作</strong>:</p><ul><li><strong>聊天消息连接</strong>: 客户端和服务器通过一个专用的连接传输用户的聊天消息。</li><li><strong>控制信号连接</strong>: 另一个连接处理用户登录、注销、状态更新等控制信息，确保这些操作不会干扰实际的聊天消息传输。</li></ul><h2 id="技巧20-使应用程序成为事件驱动的-1"><a href="#技巧20-使应用程序成为事件驱动的-1" class="headerlink" title="技巧20:使应用程序成为事件驱动的(1)"></a>技巧20:使应用程序成为事件驱动的(1)</h2><p><strong>高效资源使用</strong>: 事件驱动模型可以减少资源的消耗，通过在事件发生时处理任务而不是不断轮询或等待，这样可以提高应用程序的整体效率。</p><p><strong>更好的响应性</strong>: 应用程序可以即时响应事件（如网络请求、用户输入等），从而提供更快的用户体验。</p><p><strong>处理高并发</strong>: 事件驱动编程特别适合处理大量并发事件，通过异步处理和非阻塞 I/O 操作来支持大规模并发用户。</p><p><strong>简化设计</strong>: 通过将事件处理逻辑与业务逻辑分离，可以使程序设计更加清晰和可维护。</p><h2 id="技巧21-使应用程序成为事件驱动的-2"><a href="#技巧21-使应用程序成为事件驱动的-2" class="headerlink" title="技巧21:使应用程序成为事件驱动的(2)"></a>技巧21:使应用程序成为事件驱动的(2)</h2><p><strong>1. 异步 I/O 操作</strong></p><p>在事件驱动编程中，异步 I/O 操作是关键，允许程序在等待 I/O 操作完成的同时继续执行其他任务。</p><p><strong>示例</strong>:</p><ul><li><strong>Linux AIO</strong>: 使用 Linux 的异步 I/O 接口（如 <code>io_uring</code> 或 <code>libaio</code>）来进行非阻塞文件 I/O 操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">io_context_t</span> ctx;</span><br><span class="line">    io_setup(<span class="number">10</span>, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line"></span><br><span class="line">    io_prep_pread(&amp;cb, fd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    io_submit(ctx, <span class="number">1</span>, &amp;cb);</span><br><span class="line"></span><br><span class="line">    io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, events, nullptr);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用异步编程库</strong></p><p>现代 C++ 提供了多种异步编程库，如 Boost.Asio 和 C++20 的协程（coroutines），这些库和语言特性可以更简洁地实现事件驱动编程。</p><p><strong>示例</strong>:</p><ul><li><strong>Boost.Asio</strong>: 用于实现异步网络通信。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_accept</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Connection accepted!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    tcp::acceptor <span class="title function_">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">12345</span>))</span>;</span><br><span class="line">    tcp::socket <span class="title function_">socket</span><span class="params">(io_context)</span>;</span><br><span class="line"></span><br><span class="line">    acceptor.async_accept(socket, handle_accept);</span><br><span class="line">    io_context.run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧22-不要用TIME-WAIT暗杀来关闭一条连接"><a href="#技巧22-不要用TIME-WAIT暗杀来关闭一条连接" class="headerlink" title="技巧22:不要用TIME-WAIT暗杀来关闭一条连接"></a>技巧22:不要用TIME-WAIT暗杀来关闭一条连接</h2><ul><li><p>通常只有一端——主动关闭的那一端会进入TIME-WAIT状态</p></li><li><p>使用TIME-WAIT状态主要由两个目的：<br>1) 维护连接状态，以防主动关闭连接的那段发送的最后一条ACK丢失后造成另一端重新发送FIN信号</p><p>2) 为耗尽网络中所有此连接的“走失段”提供时间</p></li><li><p>暗杀</p><p><strong>TIME-WAIT 暗杀</strong>是指通过不适当的方法关闭 TIME-WAIT 状态中的连接，可能会导致以下问题：</p><ol><li><strong>端口资源浪费</strong>: 在高负载的系统中，大量的 TIME-WAIT 状态连接可能会消耗系统的端口资源，导致端口耗尽问题。</li><li><strong>连接重用问题</strong>: 如果在 TIME-WAIT 状态期间重新使用相同的端口号，可能会导致数据包混淆，进而影响连接的稳定性和数据完整性。</li><li><strong>网络流量问题</strong>: 不正确的处理可能导致网络中的包丢失或重复，从而引发更多的网络流量问题和性能下降。</li></ol></li></ul><h2 id="技巧23-服务器应该设置SO-REUSERADDR选项"><a href="#技巧23-服务器应该设置SO-REUSERADDR选项" class="headerlink" title="技巧23:服务器应该设置SO_REUSERADDR选项"></a>技巧23:服务器应该设置SO_REUSERADDR选项</h2><h2 id="技巧24-可能的话，使用一个大规模的写操作，而不是多个小规模的写操作"><a href="#技巧24-可能的话，使用一个大规模的写操作，而不是多个小规模的写操作" class="headerlink" title="技巧24:可能的话，使用一个大规模的写操作，而不是多个小规模的写操作"></a>技巧24:可能的话，使用一个大规模的写操作，而不是多个小规模的写操作</h2><ul><li>上下文的切换耗时</li><li>Nagle算法影响</li></ul><h2 id="技巧25-理解如何使connect调用超时"><a href="#技巧25-理解如何使connect调用超时" class="headerlink" title="技巧25:理解如何使connect调用超时"></a>技巧25:理解如何使connect调用超时</h2><p><strong><code>connect</code> 调用的超时</strong></p><p>在 TCP 网络编程中，<code>connect</code> 系统调用用于建立一个到远程主机的连接。然而，如果远程主机无法在合理的时间内响应，<code>connect</code> 调用可能会导致程序阻塞，直到连接建立或者超时。设置超时可以防止这种情况，并提高程序的可靠性和响应性。</p><p><strong>设置 <code>connect</code> 超时的步骤</strong></p><ol><li><strong>使用 <code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项</strong>: 这些选项可以设置接收和发送的超时时间，适用于 TCP 连接，但它们不会直接影响 <code>connect</code> 调用的超时。</li><li><strong>使用 <code>select</code> 或 <code>poll</code> 函数</strong>: 通过将套接字文件描述符传递给 <code>select</code> 或 <code>poll</code>，可以设置超时，帮助实现 <code>connect</code> 超时。</li><li><strong>使用 <code>fcntl</code> 函数设置非阻塞模式</strong>: 通过将套接字设置为非阻塞模式，可以使用非阻塞的 <code>connect</code> 调用，然后利用 <code>select</code> 或 <code>poll</code> 来等待连接的完成或超时。</li></ol><p><strong>补充：</strong></p><p><strong><code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项</strong> 是用于设置套接字的接收和发送操作的超时时间的选项。这些选项对 <code>connect</code> 调用的超时没有直接影响，但对于套接字在连接成功后如何处理接收和发送超时非常有用。</p><p><strong><code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项概述</strong></p><ul><li><strong><code>SO_RCVTIMEO</code></strong>: 设置接收操作的超时时间。</li><li><strong><code>SO_SNDTIMEO</code></strong>: 设置发送操作的超时时间。</li></ul><p>这两个选项通常用于控制套接字的接收和发送操作的超时，而不是 <code>connect</code> 调用本身。它们可以帮助处理由于网络问题导致的接收或发送延迟。</p><p><strong>示例代码</strong></p><p>以下示例演示了如何使用 <code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code> 选项来设置套接字的接收和发送超时时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_TIMEOUT 5  <span class="comment">// 接收超时时间（秒）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEND_TIMEOUT 5  <span class="comment">// 发送超时时间（秒）</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接收超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">recv_timeout</span>;</span></span><br><span class="line">    recv_timeout.tv_sec = RECV_TIMEOUT;</span><br><span class="line">    recv_timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;recv_timeout, <span class="keyword">sizeof</span>(recv_timeout)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_RCVTIMEO&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置发送超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">send_timeout</span>;</span></span><br><span class="line">    send_timeout.tv_sec = SEND_TIMEOUT;</span><br><span class="line">    send_timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;send_timeout, <span class="keyword">sizeof</span>(send_timeout)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_SNDTIMEO&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;server_addr.sin_addr);  <span class="comment">// example.com 的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接成功，尝试发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (send(sockfd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_received = recv(sockfd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_received &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[bytes_received] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received data:\n%s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧26-避免数据复制"><a href="#技巧26-避免数据复制" class="headerlink" title="技巧26:避免数据复制"></a>技巧26:避免数据复制</h2><p><strong>避免数据复制的策略</strong></p><ol><li><p><strong>使用零拷贝技术</strong>:</p><ul><li>零拷贝是一种技术，旨在减少数据在内存中被复制的次数。操作系统和网络库提供了一些机制来实现零拷贝。</li><li><strong>示例</strong>: 使用 <code>sendfile()</code> 函数可以直接将文件的数据从内核缓冲区发送到网络连接中，而不需要将数据先复制到用户空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">e<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> src_fd = open(<span class="string">&quot;source_file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> dest_fd = <span class="comment">/* 目标套接字描述符 */</span>;</span><br><span class="line">    <span class="keyword">if</span> (src_fd &lt; <span class="number">0</span> || dest_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    fstat(src_fd, &amp;file_stat);</span><br><span class="line">    <span class="type">ssize_t</span> bytes_sent = sendfile(dest_fd, src_fd, &amp;offset, file_stat.st_size);</span><br><span class="line">    <span class="keyword">if</span> (bytes_sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendfile&quot;</span>);</span><br><span class="line">        close(src_fd);</span><br><span class="line">        close(dest_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(src_fd);</span><br><span class="line">    close(dest_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用内存映射 (Memory Mapping)</strong>:</p><ul><li>通过内存映射文件 (<code>mmap</code>) 将文件直接映射到进程的地址空间，避免了显式的读写操作。</li><li><strong>示例</strong>: 使用 <code>mmap</code> 映射文件并在内存中直接操作数据，减少了内存复制操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> file_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* file_data = mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_data == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作映射的内存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    munmap(file_data, file_size);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用共享内存</strong>:</p><ul><li>共享内存允许不同的进程访问同一块物理内存区域，从而避免了数据在进程之间的复制。</li><li><strong>示例</strong>: 使用 POSIX 共享内存 (<code>shm_open</code>) 或 System V 共享内存 (<code>shmget</code>) 来实现进程间的数据共享。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shm_fd = shm_open(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ftruncate(shm_fd, size);</span><br><span class="line">    <span class="type">void</span>* shm_ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        close(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作共享内存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    munmap(shm_ptr, size);</span><br><span class="line">    close(shm_fd);</span><br><span class="line">    shm_unlink(shm_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用高效的序列化和反序列化方法</strong>:</p><ul><li>避免不必要的数据转换，使用高效的序列化方法来减少数据复制。</li><li><strong>示例</strong>: 使用 Google 的 Protocol Buffers 或 FlatBuffers，这些库提供了高效的序列化机制。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Protocol Buffers 库示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_proto.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SerializeToString</span><span class="params">(<span class="type">const</span> your::proto::Message&amp; msg, <span class="built_in">std</span>::<span class="built_in">string</span>* output)</span> &#123;</span><br><span class="line">    msg.SerializeToString(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseFromString</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; input, your::proto::Message* msg)</span> &#123;</span><br><span class="line">    msg-&gt;ParseFromString(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p><strong>避免数据复制</strong> 通过以下几种方式来提升性能：</p><ul><li>使用零拷贝技术，如 <code>sendfile</code>。</li><li>使用内存映射，如 <code>mmap</code>。</li><li>使用共享内存来避免进程间的数据复制。</li><li>使用高效的序列化库来减少数据转换开销。</li></ul><p>这些技术有助于减少延迟和内存消耗，提高应用程序的性能。</p><h2 id="技巧27-使用前将结构sockaddr-in清零"><a href="#技巧27-使用前将结构sockaddr-in清零" class="headerlink" title="技巧27:使用前将结构sockaddr_in清零"></a>技巧27:使用前将结构sockaddr_in清零</h2><p><strong>避免未定义行为</strong>:</p><ul><li><code>sockaddr_in</code> 结构体在未初始化时可能包含随机值，这些随机值可能会导致未定义的行为。</li><li>在函数如 <code>bind</code>、<code>connect</code> 或 <code>sendto</code> 中使用未初始化的结构体可能导致意外错误或不确定的结果。</li></ul><h2 id="技巧28-不要忘记字节的“性别”"><a href="#技巧28-不要忘记字节的“性别”" class="headerlink" title="技巧28:不要忘记字节的“性别”"></a>技巧28:不要忘记字节的“性别”</h2><p><strong>技巧28: 不要忘记字节的“性别”</strong> 是网络编程中的一个重要注意事项，尤其是在处理数据的序列化和反序列化时。这个技巧强调了在网络编程中需要处理数据的字节顺序（字节序），并确保数据在不同系统之间的一致性。</p><h2 id="技巧29-不要将IP地址或端口号硬编入应用程序中"><a href="#技巧29-不要将IP地址或端口号硬编入应用程序中" class="headerlink" title="技巧29:不要将IP地址或端口号硬编入应用程序中"></a>技巧29:不要将IP地址或端口号硬编入应用程序中</h2><h2 id="技巧30-理解已连接的UDP套接字"><a href="#技巧30-理解已连接的UDP套接字" class="headerlink" title="技巧30:理解已连接的UDP套接字"></a>技巧30:理解已连接的UDP套接字</h2><p><strong>Q：UDP可以用connect函数操作吗？</strong></p><p>A：可以，目的就是为了简化编程。不影响UDP的无连接特性，UDP的无连接特性仍然存在，套接字仍然可以接收来自不同地址的数据。</p><p>使用connect</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>); <span class="comment">// 目标端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;server_addr.sin_addr); <span class="comment">// 目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, UDP!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (send(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目标地址和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.sin_family = AF_INET;</span><br><span class="line">    dest_addr.sin_port = htons(<span class="number">12345</span>); <span class="comment">// 目标端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;dest_addr.sin_addr); <span class="comment">// 目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, UDP!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(recv_addr);</span><br><span class="line">    <span class="type">ssize_t</span> recv_len = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;recv_addr, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (recv_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buffer[recv_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received message: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="技巧31-记住，并不是所有程序都是用C编写的"><a href="#技巧31-记住，并不是所有程序都是用C编写的" class="headerlink" title="技巧31:记住，并不是所有程序都是用C编写的"></a>技巧31:记住，并不是所有程序都是用C编写的</h2><h2 id="技巧32-理解缓冲区长度带来的影响"><a href="#技巧32-理解缓冲区长度带来的影响" class="headerlink" title="技巧32:理解缓冲区长度带来的影响"></a>技巧32:理解缓冲区长度带来的影响</h2><ul><li><strong>发送缓冲区长度</strong>:<ul><li><strong>网络拥塞</strong>: 如果发送缓冲区过小，可能会导致频繁的阻塞，尤其是在网络拥塞或高负载时。应用程序可能会因为缓冲区满而被阻塞，直到缓冲区有空间可用。</li><li><strong>吞吐量</strong>: 较大的发送缓冲区可以提高数据的吞吐量，减少由于等待缓冲区空间不足而导致的阻塞时间。尤其在高数据速率的应用中，合理设置发送缓冲区长度有助于提高性能。</li></ul></li><li><strong>接收缓冲区长度</strong>:<ul><li><strong>数据丢失</strong>: 如果接收缓冲区过小，可能会导致接收到的数据包被丢弃，尤其是在高数据速率的情况下。当接收缓冲区满时，新的数据包可能会被丢弃，导致数据丢失。</li><li><strong>延迟</strong>: 较大的接收缓冲区可以减少因缓冲区满而导致的丢包概率，从而减少数据丢失的情况。它还可以降低延迟，因为应用程序可以在接收缓冲区中存储更多的数据。</li></ul></li></ul><p><strong>[发送：小，阻塞。接收：小，丢包]</strong></p><ul><li>设置缓冲区大小<ul><li>可以使用 <code>setsockopt()</code> 函数来调整套接字的缓冲区大小。例如，设置发送缓冲区大小可以使用 <code>SO_SNDBUF</code> 选项，设置接收缓冲区大小可以使用 <code>SO_RCVBUF</code> 选项。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">65536</span>; <span class="comment">// 64KB</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_RCVBUF&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt SO_SNDBUF&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer sizes set successfully.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧33-熟悉ping使用工具"><a href="#技巧33-熟悉ping使用工具" class="headerlink" title="技巧33:熟悉ping使用工具"></a>技巧33:熟悉ping使用工具</h2><ul><li>ping没有使用TCP或UDP，因此没有相关的知名端口，使用ICMP</li></ul><h2 id="技巧34-学习使用tcpdump或类似的工具"><a href="#技巧34-学习使用tcpdump或类似的工具" class="headerlink" title="技巧34:学习使用tcpdump或类似的工具"></a>技巧34:学习使用tcpdump或类似的工具</h2><p><code>tcpdump</code> 通过使用 <code>libpcap</code> 库来捕获网络上的数据包。<code>libpcap</code> 是一个提供跨平台的网络数据包捕获功能的库，支持多种操作系统。<code>tcpdump</code> 实际上是一个基于 <code>libpcap</code> 的命令行工具。</p><p><code>tcpdump</code> 的工作原理包括：</p><ol><li><strong>通过 <code>libpcap</code> 捕获网络数据包</strong>。</li><li><strong>使用过滤表达式选择性捕获数据包</strong>。</li><li><strong>解析和展示数据包的详细信息</strong>。</li><li><strong>支持将数据保存到文件中以供后续分析</strong>。</li></ol><h2 id="技巧35-学习使用traceroute"><a href="#技巧35-学习使用traceroute" class="headerlink" title="技巧35:学习使用traceroute"></a>技巧35:学习使用traceroute</h2><ul><li>traceroute是诊断网络问题，学习网络路由以及探查网络拓扑的非常游泳的工具。</li></ul><h2 id="技巧36-学习使用ttcp"><a href="#技巧36-学习使用ttcp" class="headerlink" title="技巧36:学习使用ttcp"></a>技巧36:学习使用ttcp</h2><p><code>ttcp</code> 是一个用于网络性能测试的工具，可以用来测量 TCP 和 UDP 网络连接的吞吐量和延迟。它通常用于评估网络带宽和性能，并测试网络在不同条件下的响应能力。以下是有关 <code>ttcp</code> 工具的一些详细信息和使用示例：</p><p><strong>1. <code>ttcp</code> 的功能</strong></p><ul><li><strong>性能测试</strong>：<code>ttcp</code> 可以用来测试网络带宽、吞吐量和延迟等性能指标。</li><li><strong>TCP/UDP 测试</strong>：它支持 TCP 和 UDP 协议的测试，能够分别测试这两种协议在网络中的表现。</li><li><strong>简单易用</strong>：<code>ttcp</code> 是一个简单的工具，适合快速测量网络性能和进行基本的网络测试。</li></ul><p><strong>2. <code>ttcp</code> 的工作原理</strong></p><ul><li><strong>客户端/服务器模式</strong>：<code>ttcp</code> 运行在客户端和服务器模式下，客户端发起数据传输请求，服务器接收数据并返回结果。</li><li><strong>数据传输</strong>：客户端生成一定量的数据并发送到服务器，服务器接收数据并计算吞吐量。</li><li><strong>性能评估</strong>：<code>ttcp</code> 根据传输的数据量和传输时间来计算网络性能指标，如吞吐量和延迟。</li></ul><p><strong>3. 使用示例</strong></p><p><strong>1. 安装 <code>ttcp</code></strong></p><p>在大多数 Linux 系统上，<code>ttcp</code> 可以通过软件包管理工具安装。例如，在 Debian 或 Ubuntu 上可以使用：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install ttcp</span><br></pre></td></tr></table></figure><p>在 Red Hat 或 CentOS 上可以使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> ttcp</span><br></pre></td></tr></table></figure><p><strong>2. 启动服务器</strong></p><p>首先，在目标机器上启动 <code>ttcp</code> 服务器进程：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ttcp -r</span></span><br></pre></td></tr></table></figure><p><strong>3. 启动客户端</strong></p><p>在源机器上，使用 <code>ttcp</code> 客户端来测试网络性能。假设服务器的 IP 地址是 <code>192.168.1.100</code>，可以使用以下命令进行 TCP 测试：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ttcp</span> -t -s <span class="number">192.168.1.100</span></span><br></pre></td></tr></table></figure><ul><li><code>-t</code>：表示进行 TCP 测试。</li><li><code>-s</code>：表示服务器的 IP 地址。</li></ul><p><strong>4. 解析结果</strong></p><p><code>ttcp</code> 会输出测试结果，包括传输的总数据量、传输时间、吞吐量等。例如，输出可能包括类似下面的内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sent</span> <span class="number">10000000</span> bytes in <span class="number">1</span>.<span class="number">5</span> seconds = <span class="number">6</span>.<span class="number">67</span> MB/sec</span><br></pre></td></tr></table></figure><p>这表示客户端在 1.5 秒内发送了 10,000,000 字节的数据，吞吐量为 6.67 MB/sec。</p><p><strong>4. 应用场景</strong></p><ul><li><strong>网络性能评估</strong>：用于评估网络连接的实际带宽和性能。</li><li><strong>故障排除</strong>：帮助诊断网络瓶颈和性能问题。</li><li><strong>比较测试</strong>：测试不同网络配置或硬件对性能的影响。</li></ul><h2 id="技巧37-学习使用lsof"><a href="#技巧37-学习使用lsof" class="headerlink" title="技巧37:学习使用lsof"></a>技巧37:学习使用lsof</h2><p><strong><code>lsof</code> 的功能</strong>（List Open Files）</p><ul><li><strong>列出打开的文件</strong>：显示当前系统上所有被进程打开的文件，包括普通文件、目录、设备文件等。</li><li><strong>显示网络连接</strong>：提供当前系统上所有网络连接的信息，包括 TCP 和 UDP 连接。</li><li><strong>查看文件描述符</strong>：列出与文件描述符相关的详细信息，如文件句柄和设备。</li><li><strong>诊断工具</strong>：帮助查找占用文件或端口的进程，进行故障排除。</li></ul><p><strong>2. 常见用法</strong></p><p><strong>1. 列出所有打开的文件</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span></span><br></pre></td></tr></table></figure><p>此命令会列出当前系统上所有被打开的文件，包括网络连接、设备文件等。</p><p><strong>2. 查找特定文件的使用情况</strong></p><p>要查找特定文件被哪些进程打开：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /path/<span class="keyword">to</span>/<span class="built_in">file</span></span><br></pre></td></tr></table></figure><p>例如，查看 <code>/etc/passwd</code> 文件被哪些进程打开：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><strong>3. 查找某个进程打开的文件</strong></p><p>要列出特定进程（例如 PID 为 1234）打开的所有文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">Copy <span class="selector-tag">code</span></span><br><span class="line">lsof -<span class="selector-tag">p</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure><p><strong>4. 查找特定用户的文件</strong></p><p>要列出特定用户（例如用户 <code>john</code>）打开的所有文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof -u john</span></span><br></pre></td></tr></table></figure><p><strong>5. 查找特定端口的使用情况</strong></p><p>要查找特定端口（例如端口 80）被哪些进程占用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i :<span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>6. 列出所有网络连接</strong></p><p>要列出所有网络连接（包括 TCP 和 UDP）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -<span class="selector-tag">i</span></span><br></pre></td></tr></table></figure><p>可以结合 <code>-i</code> 选项的不同参数来进一步过滤，例如 <code>-i tcp</code> 或 <code>-i udp</code>。</p><p><strong>7. 查找某个命令打开的文件</strong></p><p>要查找正在运行的特定命令（例如 <code>nginx</code>）打开的文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof -c nginx</span></span><br></pre></td></tr></table></figure><p><strong>8. 列出被某个设备或文件系统占用的文件</strong></p><p>要列出挂载点（例如 <code>/mnt</code>）下所有打开的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof +D /mnt</span><br></pre></td></tr></table></figure><h2 id="技巧38-学习使用netstat"><a href="#技巧38-学习使用netstat" class="headerlink" title="技巧38:学习使用netstat"></a>技巧38:学习使用netstat</h2><p><code>netstat</code>（Network Statistics）是一个用于显示网络连接、路由表、接口统计信息等网络相关数据的命令行工具。它可以帮助用户诊断网络问题、监控网络流量，并提供关于网络接口和连接状态的详细信息。</p><p><strong>1. <code>netstat</code> 的功能</strong></p><ul><li><strong>显示网络连接</strong>：列出系统上所有的网络连接，包括 TCP、UDP 连接。</li><li><strong>显示路由表</strong>：提供系统的路由表信息，包括网络路由的目的地、网关等。</li><li><strong>显示网络接口统计信息</strong>：提供每个网络接口的统计信息，如传输的字节数、接收的字节数等。</li><li><strong>显示监听的端口</strong>：列出正在监听的网络端口，帮助识别开放的端口和运行的服务。</li></ul><p><strong>2. 常见用法</strong></p><p><strong>1. 显示所有网络连接</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>此命令会列出所有活动的网络连接（包括 TCP 和 UDP）。</p><p><strong>2. 显示所有监听的端口</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -l</span></span><br></pre></td></tr></table></figure><p><code>-l</code> 选项显示正在监听的端口，帮助识别开放的服务端口。</p><p><strong>3. 显示 TCP 连接</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="keyword">at</span></span><br></pre></td></tr></table></figure><p><code>-t</code> 选项过滤出 TCP 连接。加上 <code>-a</code> 选项可以显示所有 TCP 连接。</p><p><strong>4. 显示 UDP 连接</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -au</span></span><br></pre></td></tr></table></figure><p><code>-u</code> 选项过滤出 UDP 连接。加上 <code>-a</code> 选项可以显示所有 UDP 连接。</p><p><strong>5. 显示路由表</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -r</span></span><br></pre></td></tr></table></figure><p><code>-r</code> 选项显示系统的路由表，帮助了解数据包的转发路径。</p><p><strong>6. 显示网络接口统计信息</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="selector-tag">i</span></span><br></pre></td></tr></table></figure><p><code>-i</code> 选项显示网络接口的统计信息，包括接收和发送的字节数、数据包数等。</p><p><strong>7. 显示进程信息</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><p><code>-p</code> 选项显示与每个连接相关的进程 ID 和名称，帮助识别哪个进程正在使用特定端口。</p><p><strong>8. 显示每秒数据统计</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -s</span></span><br></pre></td></tr></table></figure><p><code>-s</code> 选项显示每种协议的统计信息，包括错误、丢包等。</p><p><strong>3. 使用示例</strong></p><p><strong>1. 查找开放的端口</strong></p><p>要检查系统上哪些端口处于监听状态，可以使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -tuln</span></span><br></pre></td></tr></table></figure><ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-l</code>：只显示监听状态的端口。</li><li><code>-n</code>：以数字形式显示端口号和 IP 地址。</li></ul><p><strong>2. 查看进程和端口的关系</strong></p><p>要查看每个连接的进程信息，可以使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -tulnp</span></span><br></pre></td></tr></table></figure><ul><li><code>-p</code>：显示与连接相关的进程信息</li></ul><h2 id="技巧39-学习使用系统中的调用追踪工具-strace"><a href="#技巧39-学习使用系统中的调用追踪工具-strace" class="headerlink" title="技巧39:学习使用系统中的调用追踪工具(strace)"></a>技巧39:学习使用系统中的调用追踪工具(strace)</h2><h2 id="技巧40-构建并使用捕获ICMP报文的工具"><a href="#技巧40-构建并使用捕获ICMP报文的工具" class="headerlink" title="技巧40:构建并使用捕获ICMP报文的工具"></a>技巧40:构建并使用捕获ICMP报文的工具</h2><h2 id="技巧41-读Stevens的书"><a href="#技巧41-读Stevens的书" class="headerlink" title="技巧41:读Stevens的书"></a>技巧41:读Stevens的书</h2><h2 id="技巧42-阅读代码"><a href="#技巧42-阅读代码" class="headerlink" title="技巧42:阅读代码"></a>技巧42:阅读代码</h2><h2 id="技巧43-访问RFC编辑者的页面"><a href="#技巧43-访问RFC编辑者的页面" class="headerlink" title="技巧43:访问RFC编辑者的页面"></a>技巧43:访问RFC编辑者的页面</h2><h2 id="技巧44-经常访问新闻组"><a href="#技巧44-经常访问新闻组" class="headerlink" title="技巧44:经常访问新闻组"></a>技巧44:经常访问新闻组</h2><h2 id="Pro：TCP为什么不可靠"><a href="#Pro：TCP为什么不可靠" class="headerlink" title="Pro：TCP为什么不可靠"></a>Pro：TCP为什么不可靠</h2><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="补充1：TCP的最大负载和最小负载的意义"><a href="#补充1：TCP的最大负载和最小负载的意义" class="headerlink" title="补充1：TCP的最大负载和最小负载的意义"></a><strong>补充1：TCP的最大负载和最小负载的意义</strong></h3><p>TCP（传输控制协议）的最大负载和最小负载是指TCP连接中可以传输的数据量的上限和下限。这些概念在TCP的性能调优和网络设计中具有重要意义。</p><p><strong>最大负载（Maximum Load）</strong></p><p>最大负载通常指的是TCP连接中可以传输的最大数据量，这主要与TCP的拥塞控制机制有关。TCP通过拥塞窗口（Congestion Window, CWND）来控制一次可以发送的数据量。拥塞窗口的大小会根据网络的拥塞程度动态调整。</p><p>意义：</p><ol><li><strong>网络利用率</strong>：最大负载决定了网络的最大吞吐量。通过调整拥塞窗口的大小，可以最大化网络的利用率，从而提高数据传输的效率。</li><li><strong>拥塞控制</strong>：最大负载是TCP拥塞控制机制的核心。通过动态调整拥塞窗口，TCP可以在网络拥塞时减少数据发送量，避免网络拥塞进一步加剧。</li><li><strong>性能优化</strong>：了解和调整最大负载可以帮助优化TCP连接的性能，特别是在高延迟或高带宽的网络环境中。</li></ol><p><strong>最小负载（Minimum Load）</strong></p><p>最小负载通常指的是TCP连接中可以传输的最小数据量，这主要与TCP的慢启动和超时重传机制有关。TCP在建立连接时会从较小的拥塞窗口开始，逐渐增加直到达到网络的拥塞窗口上限。</p><p>意义：</p><ol><li><strong>启动速度</strong>：最小负载决定了TCP连接的启动速度。较小的最小负载可以加快TCP连接的启动，从而减少连接建立的时间。</li><li><strong>超时重传</strong>：最小负载也与TCP的超时重传机制有关。在网络不稳定或丢包率较高的情况下，较小的最小负载可以减少重传的数据量，从而提高TCP的可靠性。</li><li><strong>资源利用</strong>：了解和调整最小负载可以帮助更好地利用网络资源，特别是在低带宽或高延迟的网络环境中。</li></ol><p><strong>总结</strong></p><p>TCP的最大负载和最小负载是TCP性能调优和网络设计中的重要参数。通过合理调整这些参数，可以提高TCP连接的性能、可靠性和网络资源的利用率。在实际应用中，需要根据具体的网络环境和应用需求来调整这些参数，以达到最佳的网络性能。</p><h3 id="补充2：linux创建1个socket内存开销多少"><a href="#补充2：linux创建1个socket内存开销多少" class="headerlink" title="补充2：linux创建1个socket内存开销多少"></a><strong>补充2：linux创建1个socket内存开销多少</strong></h3><p>文件系统inode + socket结构 是固定大小的，大约为1K。 理想情况下：每个socket占用的内存为<strong>2~3K</strong>。 以2K计算，内核空间实际可用内存约在800M，那么800M/2K = 400K. 粗略估计，Linux下，32位系统，能支持40万tcp并发连接差不多就到极限了。=</p><h3 id="补充3："><a href="#补充3：" class="headerlink" title="补充3："></a><strong>补充3：</strong></h3><p><strong>int confd = accept(curfd, (sockaddr *)&amp;client_addr, &amp;client_len); 这个TCPSocket confd使用的端口号和curfd是一致的，那么客户端往这个ip+port上发送信息的时候怎么知道交给哪个描述符处理，说重点 举例说明</strong></p><p>看这个例子你就理解啦</p><p>假设有一个服务器在 IP 地址 <code>192.168.1.10</code> 上监听端口 <code>8080</code>，并且客户端的 IP 地址是 <code>192.168.1.20</code>，客户端的端口号是 <code>12345</code>。</p><ol><li><strong>客户端连接</strong>:<ul><li>客户端使用其 IP 地址 <code>192.168.1.20</code> 和端口 <code>12345</code> 连接到服务器的 IP 地址 <code>192.168.1.10</code> 上的端口 <code>8080</code>。</li><li>服务器的监听套接字 <code>curfd</code> 接收到这个连接请求，并通过 <code>accept()</code> 创建一个新的套接字描述符 <code>confd</code>。</li></ul></li><li><strong>数据发送</strong>:<ul><li>客户端向 <code>192.168.1.10:8080</code> 发送数据包，数据包中包含目标 IP 地址和端口号 <code>192.168.1.10:8080</code>。</li><li>操作系统内核会使用这些信息将数据包路由到 <code>192.168.1.10</code> 上的监听套接字 <code>curfd</code>。</li></ul></li><li><strong>内核处理</strong>:<ul><li>内核根据客户端的 IP 地址和端口号（<code>192.168.1.20:12345</code>）和服务器的 IP 地址和端口号（<code>192.168.1.10:8080</code>）唯一标识连接。</li><li>内核知道这个连接对应于 <code>confd</code>，因为这是由 <code>accept()</code> 返回的专用描述符。</li></ul></li><li><strong>数据接收</strong>:<ul><li>数据到达服务器后，内核将数据包传递到正确的套接字描述符 <code>confd</code>，因为 <code>confd</code> 对应于客户端与服务器之间的唯一连接。</li></ul></li></ol><h3 id="补充4：都是TCPSocket？"><a href="#补充4：都是TCPSocket？" class="headerlink" title="补充4：都是TCPSocket？"></a><strong>补充4：都是TCPSocket？</strong></h3><p>int confd = accept(curfd, (sockaddr <em>)&amp;client_addr, &amp;client_len);confd和curfd都是TCPSocket是吗？*</em></p><p>是的，<code>confd</code> 和 <code>curfd</code> 都是 TCP 套接字（<code>TCPSocket</code>）。</p><h3 id="补充5：sleep勿用"><a href="#补充5：sleep勿用" class="headerlink" title="补充5：sleep勿用"></a><strong>补充5：sleep勿用</strong></h3><p>使用sleep()来假定其他线程的事件已经发生，是错误的。</p><p>因为线程卡死的时候，是可以拖过sleep()这个时间的。</p><p><strong>举例说明</strong></p><p>在多线程编程中，你可能会希望等待某个线程完成一项任务，然后再继续执行主线程或其他线程的操作。有人可能会错误地使用 <code>sleep()</code> 来假定此时其他线程已经完成了它的任务，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker thread is starting...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟工作任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker thread has finished its task.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并启动一个线程</span></span><br><span class="line">thread = threading.Thread(target=worker)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程休眠3秒，假设worker线程已经完成</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设worker已经完成，继续执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Assuming worker thread is done, continuing with main thread.&quot;</span>)</span><br></pre></td></tr></table></figure><p>在上面的例子中，主线程启动了 <code>worker</code> 线程，并用 <code>time.sleep(3)</code> 暂停了3秒，假设 <code>worker</code> 线程应该在这段时间内完成其任务。</p><p>问题：为什么这是错误的？</p><ol><li><strong>线程执行时间无法预测</strong>：<ul><li>即使你设置了 <code>worker</code> 线程中的 <code>time.sleep(2)</code> 来模拟任务执行时间，实际执行时间可能会因多种因素而延长，比如系统资源不足、线程调度延迟等。<code>worker</code> 线程可能需要超过 2 秒才能完成任务，因此主线程在 3 秒后假定 <code>worker</code> 线程已完成的假设可能不成立。</li></ul></li><li><strong><code>sleep()</code> 不能确保线程完成任务</strong>：<ul><li><code>sleep(3)</code> 只是让当前线程（主线程）暂停运行 3 秒，并不保证其他线程在这 3 秒内完成任何特定的任务。线程的调度由操作系统管理，<code>worker</code> 线程可能在主线程 <code>sleep()</code> 的期间受到影响，甚至可能完全没有运行。</li></ul></li><li><strong>系统负载和线程卡死</strong>：<ul><li>假设系统负载非常高，<code>worker</code> 线程可能在 2 秒内只获得了极少的 CPU 时间，甚至可能还没开始执行。主线程的 <code>sleep()</code> 时间结束后，<code>worker</code> 线程可能还没有完成任务。此时，主线程继续执行时，假设 <code>worker</code> 线程已经完成任务是错误的。</li></ul></li></ol><p><strong>替代方案：使用线程同步机制</strong></p><p>正确的方法是使用线程同步机制，如 <code>join()</code>、事件（<code>Event</code>）、信号量（<code>Semaphore</code>）、锁（<code>Lock</code>）等，来确保一个线程等待另一个线程完成任务。</p><p>以下是使用 <code>join()</code> 的例子，它可以确保主线程等待 <code>worker</code> 线程完成任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker thread is starting...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟工作任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker thread has finished its task.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并启动一个线程</span></span><br><span class="line">thread = threading.Thread(target=worker)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 join() 等待 worker 线程完成</span></span><br><span class="line">thread.join()  <span class="comment"># 等待 worker 线程完成</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Worker thread is done, continuing with main thread.&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>thread.join()</code> 会阻塞主线程的执行，直到 <code>worker</code> 线程完成任务。这样就不会依赖 <code>sleep()</code> 来猜测 <code>worker</code> 线程是否已经完成，这种方法更可靠。</p><p><strong>总结</strong></p><p>使用 <code>sleep()</code> 来假定其他线程的事件已经发生是错误的，因为：</p><ul><li><strong>线程执行顺序和时间不可预测</strong>：<code>sleep()</code> 不能保证其他线程在某个时间内完成任务。</li><li><strong>系统调度的不确定性</strong>：其他线程可能因为系统负载或者调度问题而延迟执行。</li><li><strong>更好的选择是使用同步机制</strong>：如 <code>join()</code>、事件、条件变量等，这些机制可以确保线程之间的正确协调和同步。</li></ul><p><a href="https://www.cnblogs.com/yizhinantian/archive/2011/04/03/2004340.html#:~:text=文件系统inode %2B socket结构 是固定大小的，大约为1K。,理想情况下：每个socket占用的内存为2~3K。 以2K计算，内核空间实际可用内存约在800M，那么800M%2F2K %3D 400K. 粗略估计，Linux下，32位系统，能支持40万tcp并发连接差不多就到极限了。">对Linux下socket限制的理解 - YZG - 博客园</a></p><p><a href="https://mp.weixin.qq.com/s/sgmPGUUg6TZ1T4vNY-mvGg">深入分析网络编程中容易踩的坑</a></p><p><a href="https://mp.weixin.qq.com/s/E0Ks5i-D7YgMiWvmZRcw_Q">一文掌握网络编程精华</a></p>]]></content>
    
    
    <summary type="html">TCP/IP高效编程</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>asio机制</title>
    <link href="https://penge666.github.io/posts/7e8ef575.html"/>
    <id>https://penge666.github.io/posts/7e8ef575.html</id>
    <published>2024-08-08T13:43:09.000Z</published>
    <updated>2024-09-18T13:51:34.719Z</updated>
    
    <content type="html"><![CDATA[<p>一个人可以走的很快，一群人可以走的很远！</p><p>Boost.Asio 的核心组件包括：</p><ul><li>io_context：事件调度器，管理所有的异步操作。</li><li>I/O 对象（如 tcp::socket、serial_port 等）：用于执行异步 I/O 操作。</li><li>strand：用于保证回调函数的顺序执行。</li><li>异步操作函数（如 async_read、async_write）：发起异步 I/O 操作。【目前我认为是通过·回调机制以及用户线程池保证的】</li><li>定时器（如 steady_timer）：用于管理定时事件。</li></ul><h2 id="io-context">io_context</h2><h3 id="io-service">io_service</h3><p>[这个部分感兴趣看看就好，也可以跳过io_service这节]</p><p><strong>io_service的作用</strong></p><p>io_servie 实现了一个任务队列，这里的任务就是void(void)的函数。Io_servie最常用的两个接口是post和run，post向任务队列中投递任务，run是执行队列中的任务，直到全部执行完毕，并且run可以被N个线程调用。Io_service是完全线程安全的队列。</p><p><strong>Io_servie的接口</strong></p><p>提供的接口有run、run_one、poll、poll_one、stop、reset、dispatch、post，最常用的是run、post、stop</p><p><strong>Io_servie 实现代码的基本类结构：</strong></p><ul><li><p>Io_servie是接口类，为实现跨平台，采用了策略模式，所有接口均有impl_type实现。根据平台不同impl_type分为</p></li><li><p>win_iocp_io_service Win版本的实现，这里主要分析Linux版本。</p><ul><li>task_io_service 非win平台下的实现，其代码结构为：</li><li>detail/task_io_service_fwd.hpp 简单声明task_io_service名称</li><li>detail/task_io_service.hpp 声明task_io_service的方法和属性</li><li>detail/impl/task_io_service.ipp 具体实现文件</li><li>队列中的任务类型为opertioan，原型其实是typedef task_io_service_operation operation，其实现文件在detail/task_io_service_operation.hpp中，当队列中的任务被执行时，就是task_io_service_operation:: complete被调用的时候。</li></ul></li></ul><p><strong>Io_servie::Post方法的实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">operation</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">completion_handler</span> : <span class="keyword">public</span> operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">completion_handler</span><span class="params">(Handler h)</span> : handler_(std::move(h)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">handler_</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Handler handler_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">io_service</span>() : <span class="built_in">outstanding_work_</span>(<span class="number">0</span>), <span class="built_in">first_idle_thread_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个任务</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> op = std::make_shared&lt;completion_handler&lt;Handler&gt;&gt;(std::<span class="built_in">move</span>(handler));</span><br><span class="line">        <span class="built_in">post_immediate_completion</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_immediate_completion</span><span class="params">(std::shared_ptr&lt;operation&gt; op)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加未完成任务计数</span></span><br><span class="line">        ++outstanding_work_;</span><br><span class="line">        <span class="built_in">post_deferred_completion</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_deferred_completion</span><span class="params">(std::shared_ptr&lt;operation&gt; op)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务加入队列</span></span><br><span class="line">        task_queue_.<span class="built_in">push</span>(op);</span><br><span class="line">        <span class="comment">// 尝试唤醒一个空闲线程</span></span><br><span class="line">        <span class="built_in">wake_one_thread_and_unlock</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wake_one_thread_and_unlock</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有空闲线程，将其唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (first_idle_thread_) &#123;</span><br><span class="line">            std::thread* idle_thread = first_idle_thread_;</span><br><span class="line">            first_idle_thread_ = <span class="literal">nullptr</span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            idle_thread-&gt;<span class="built_in">detach</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理阻塞在 epoll_wait 上的线程</span></span><br><span class="line">            <span class="comment">// 在实际实现中，这将涉及更多复杂的逻辑</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// 假设 epoll_wait 被中断并从任务队列中取出任务执行</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No idle thread, handling epoll_wait interruption&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">handle_epoll_wait_interruption</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_epoll_wait_interruption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟从任务队列中取出任务并执行</span></span><br><span class="line">        std::shared_ptr&lt;operation&gt; op;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!task_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                op = task_queue_.<span class="built_in">front</span>();</span><br><span class="line">                task_queue_.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            op-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续阻塞在 epoll_wait 上</span></span><br><span class="line">        <span class="built_in">epoll_wait_simulation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">epoll_wait_simulation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟 epoll_wait 的阻塞和等待</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simulating epoll_wait&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在实际实现中，这将是调用 epoll_wait 系统调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;operation&gt;&gt; task_queue_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cond_var_;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; outstanding_work_;</span><br><span class="line">    std::thread* first_idle_thread_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li><code>post</code> 方法：<ul><li><code>post</code> 方法接收一个 <code>handler</code>（实际是一个仿函数），并将其包装为 <code>completion_handler</code> 对象。</li><li><code>completion_handler</code> 继承自 <code>operation</code>，并实现了 <code>execute</code> 方法，将 <code>handler</code> 作为任务执行。</li></ul></li><li><code>post_immediate_completion</code> 方法：<ul><li><code>post_immediate_completion</code> 增加未完成任务计数 <code>outstanding_work_</code>，然后调用 <code>post_deferred_completion</code>。</li></ul></li><li><code>post_deferred_completion</code> 方法：<ul><li><code>post_deferred_completion</code> 方法首先加锁，然后将任务入列到 <code>task_queue_</code> 中。</li><li>然后它调用 <code>wake_one_thread_and_unlock</code> 尝试唤醒一个空闲线程。</li></ul></li><li><code>wake_one_thread_and_unlock</code> 方法：<ul><li>该方法首先检查是否有空闲线程（通过 <code>first_idle_thread_</code> 指针维护）。</li><li>如果有空闲线程，则将其唤醒（在此示例中，使用 <code>detach</code> 模拟唤醒）。</li><li>如果没有空闲线程，但有线程可能正在阻塞于 <code>epoll_wait</code>，则模拟中断 <code>epoll_wait</code> 并在中断后执行任务队列中的任务。</li></ul></li><li><code>handle_epoll_wait_interruption</code> 方法：<ul><li>该方法模拟从 <code>epoll_wait</code> 中断后处理任务队列中的任务。</li><li>执行任务后，它再次模拟调用 <code>epoll_wait</code>。在实际实现中，这将是一个真正的 <code>epoll_wait</code> 系统调用。</li></ul></li></ol><p><strong>Io_servie::run方法的实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个操作基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">operation</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定任务的操作类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">completion_handler</span> : <span class="keyword">public</span> operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">completion_handler</span><span class="params">(Handler h)</span> : handler_(std::move(h)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">handler_</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Handler handler_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于管理线程的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">idle_thread_info</span> &#123;</span><br><span class="line">    idle_thread_info* next;</span><br><span class="line">    std::thread::id thread_id;</span><br><span class="line">    std::condition_variable cond_var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版的 io_service 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">io_service</span>() : <span class="built_in">outstanding_work_</span>(<span class="number">0</span>), <span class="built_in">first_idle_thread_</span>(<span class="literal">nullptr</span>), <span class="built_in">stopped_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 epoll 文件描述符</span></span><br><span class="line">        epoll_fd_ = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">init_interrupt_fd</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">io_service</span>() &#123;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个任务</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> op = std::make_shared&lt;completion_handler&lt;Handler&gt;&gt;(std::<span class="built_in">move</span>(handler));</span><br><span class="line">        <span class="built_in">post_immediate_completion</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idle_thread_info this_thread_info;</span><br><span class="line">        this_thread_info.thread_id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        this_thread_info.next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">do_one</span>(lock, this_thread_info)) &#123;</span><br><span class="line">            <span class="comment">// Loop until do_one returns false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">do_one</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, idle_thread_info&amp; this_thread_info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 将当前线程标记为空闲</span></span><br><span class="line">            this_thread_info.next = first_idle_thread_;</span><br><span class="line">            first_idle_thread_ = &amp;this_thread_info;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞等待新任务到来或被唤醒</span></span><br><span class="line">            this_thread_info.cond_var.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">return</span> !task_queue_.<span class="built_in">empty</span>() || stopped_;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stopped_) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中取出一个任务</span></span><br><span class="line">        <span class="keyword">auto</span> op = task_queue_.<span class="built_in">front</span>();</span><br><span class="line">        task_queue_.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">wake_one_thread_and_unlock</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        op-&gt;<span class="built_in">execute</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_immediate_completion</span><span class="params">(std::shared_ptr&lt;operation&gt; op)</span> </span>&#123;</span><br><span class="line">        ++outstanding_work_;</span><br><span class="line">        <span class="built_in">post_deferred_completion</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_deferred_completion</span><span class="params">(std::shared_ptr&lt;operation&gt; op)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务加入队列</span></span><br><span class="line">        task_queue_.<span class="built_in">push</span>(op);</span><br><span class="line">        <span class="comment">// 尝试唤醒一个空闲线程</span></span><br><span class="line">        <span class="built_in">wake_one_thread_and_unlock</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wake_one_thread_and_unlock</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first_idle_thread_) &#123;</span><br><span class="line">            idle_thread_info* idle_thread = first_idle_thread_;</span><br><span class="line">            first_idle_thread_ = idle_thread-&gt;next;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            idle_thread-&gt;cond_var.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">interrupt_epoll_wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interrupt_epoll_wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">write</span>(interrupt_fd_, &amp;one, <span class="built_in">sizeof</span>(one));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_interrupt_fd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interrupt_fd_ = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK);</span><br><span class="line">        epoll_event ev = &#123;&#125;;</span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">        ev.data.fd = interrupt_fd_;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(epoll_fd_, EPOLL_CTL_ADD, interrupt_fd_, &amp;ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">epoll_wait_simulation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        epoll_event events[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd_, events, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.fd == interrupt_fd_) &#123;</span><br><span class="line">                <span class="type">uint64_t</span> count;</span><br><span class="line">                <span class="built_in">read</span>(interrupt_fd_, &amp;count, <span class="built_in">sizeof</span>(count));</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;epoll_wait interrupted!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;operation&gt;&gt; task_queue_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cond_var_;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; outstanding_work_;</span><br><span class="line">    idle_thread_info* first_idle_thread_;</span><br><span class="line">    <span class="type">bool</span> stopped_;</span><br><span class="line">    <span class="type">int</span> epoll_fd_;</span><br><span class="line">    <span class="type">int</span> interrupt_fd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li><code>run</code> 方法：<ul><li><code>run</code> 方法是 <code>io_service</code> 的核心循环，负责执行所有任务，直到任务执行完毕或服务停止。</li><li>它首先创建一个 <code>idle_thread_info</code> 对象，用于管理当前线程的状态。</li><li>进入循环，不断调用 <code>do_one</code> 方法来处理任务。</li></ul></li><li><code>do_one</code> 方法：<ul><li><code>do_one</code> 方法每次执行一个任务。</li><li>如果任务队列为空，当前线程被标记为空闲，并进入等待状态，直到有新任务到来或服务停止。</li><li>如果有任务，<code>do_one</code> 从任务队列中取出一个任务并执行。如果队列中还有其他任务，会尝试唤醒其他空闲线程来执行剩余的任务。</li></ul></li><li><code>post_immediate_completion</code> 和 <code>post_deferred_completion</code> 方法：<ul><li>这两个方法负责将任务加入任务队列，并尝试唤醒空闲线程执行任务。</li><li><code>post_immediate_completion</code> 增加未完成任务计数，然后调用 <code>post_deferred_completion</code>。</li><li><code>post_deferred_completion</code> 将任务加入任务队列后，调用 <code>wake_one_thread_and_unlock</code> 尝试唤醒空闲线程。</li></ul></li><li><code>wake_one_thread_and_unlock</code> 方法：<ul><li>该方法尝试唤醒一个空闲线程。如果没有空闲线程，那么会调用 <code>interrupt_epoll_wait</code> 来中断阻塞在 <code>epoll_wait</code> 上的线程。</li><li><code>interrupt_epoll_wait</code> 方法通过写入 <code>eventfd</code> 文件描述符来触发 <code>epoll_wait</code> 的中断。</li></ul></li><li><code>epoll_wait_simulation</code> 和 <code>init_interrupt_fd</code> 方法：<ul><li><code>epoll_wait_simulation</code> 模拟 <code>epoll_wait</code> 的阻塞和处理中断的过程。</li><li><code>init_interrupt_fd</code> 初始化一个 <code>eventfd</code>，并将其添加到 <code>epoll</code> 实例中，用于中断 <code>epoll_wait</code>。</li></ul></li></ol><p><strong>Io_servie::stop的实现</strong></p><ol><li><strong>加锁</strong>：确保在多线程环境中对共享资源的访问是安全的。</li><li>调用 <code>stop_all_threads</code>：唤醒所有空闲线程，确保它们能够检测到 <code>io_service</code> 已经停止。</li><li>设置 <code>stopped_</code> 标志：标记 <code>io_service</code> 已经停止，阻止新任务的执行，并通知所有正在等待的线程。</li><li>调用 <code>task_</code> 的 <code>interrupt</code> 方法：中断正在运行的 <code>epoll_wait</code> 或其他阻塞操作，以确保所有线程都能及时退出。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个操作基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">operation</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定任务的操作类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">completion_handler</span> : <span class="keyword">public</span> operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">completion_handler</span><span class="params">(Handler h)</span> : handler_(std::move(h)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">handler_</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Handler handler_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于管理线程的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">idle_thread_info</span> &#123;</span><br><span class="line">    idle_thread_info* next;</span><br><span class="line">    std::thread::id thread_id;</span><br><span class="line">    std::condition_variable cond_var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版的 io_service 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">io_service</span>() : <span class="built_in">outstanding_work_</span>(<span class="number">0</span>), <span class="built_in">first_idle_thread_</span>(<span class="literal">nullptr</span>), <span class="built_in">stopped_</span>(<span class="literal">false</span>), <span class="built_in">task_interrupted_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 epoll 文件描述符</span></span><br><span class="line">        epoll_fd_ = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">init_interrupt_fd</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">io_service</span>() &#123;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个任务</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> op = std::make_shared&lt;completion_handler&lt;Handler&gt;&gt;(std::<span class="built_in">move</span>(handler));</span><br><span class="line">        <span class="built_in">post_immediate_completion</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止 io_service</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="built_in">stop_all_threads</span>();</span><br><span class="line">        stopped_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒所有空闲线程</span></span><br><span class="line">        idle_thread_info* idle_thread = first_idle_thread_;</span><br><span class="line">        <span class="keyword">while</span> (idle_thread) &#123;</span><br><span class="line">            idle_thread-&gt;cond_var.<span class="built_in">notify_one</span>();</span><br><span class="line">            idle_thread = idle_thread-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断 task_ 的运行</span></span><br><span class="line">        task_interrupted_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">interrupt_task</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop_all_threads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在实际实现中，这里可能涉及更多的线程管理逻辑</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stopping all threads...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interrupt_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中断 epoll_wait 或其他阻塞操作</span></span><br><span class="line">        <span class="built_in">interrupt_epoll_wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interrupt_epoll_wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">write</span>(interrupt_fd_, &amp;one, <span class="built_in">sizeof</span>(one));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_interrupt_fd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interrupt_fd_ = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK);</span><br><span class="line">        epoll_event ev = &#123;&#125;;</span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">        ev.data.fd = interrupt_fd_;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(epoll_fd_, EPOLL_CTL_ADD, interrupt_fd_, &amp;ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行和线程唤醒的相关方法（省略，见前面部分代码）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_immediate_completion</span><span class="params">(std::shared_ptr&lt;operation&gt; op)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加未完成任务计数</span></span><br><span class="line">        ++outstanding_work_;</span><br><span class="line">        <span class="built_in">post_deferred_completion</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_deferred_completion</span><span class="params">(std::shared_ptr&lt;operation&gt; op)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务加入队列</span></span><br><span class="line">        task_queue_.<span class="built_in">push</span>(op);</span><br><span class="line">        <span class="comment">// 尝试唤醒一个空闲线程</span></span><br><span class="line">        <span class="built_in">wake_one_thread_and_unlock</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wake_one_thread_and_unlock</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first_idle_thread_) &#123;</span><br><span class="line">            idle_thread_info* idle_thread = first_idle_thread_;</span><br><span class="line">            first_idle_thread_ = idle_thread-&gt;next;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            idle_thread-&gt;cond_var.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">interrupt_epoll_wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;operation&gt;&gt; task_queue_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cond_var_;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; outstanding_work_;</span><br><span class="line">    idle_thread_info* first_idle_thread_;</span><br><span class="line">    <span class="type">bool</span> stopped_;</span><br><span class="line">    <span class="type">bool</span> task_interrupted_;</span><br><span class="line">    <span class="type">int</span> epoll_fd_;</span><br><span class="line">    <span class="type">int</span> interrupt_fd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zhiranok/archive/2011/09/04/boost_asio_io_service_CPP.html"> Boost::asio io_service 实现分析</a>对这篇文章的扩充</p><h3 id="易理解">易理解</h3><p><code>io_context</code> 实际上是一个事件循环，它通过与操作系统的 I/O 多路复用机制（如 <code>epoll</code>、<code>select</code> 等）及任务队列配合使用，以实现高效的异步编程。</p><p><code>io_context</code> 使用了以下几个关键的数据结构：</p><ul><li><strong>任务队列（Task Queue）</strong>：存储需要执行的任务。</li><li><strong>调度器（Scheduler）</strong>：负责管理任务队列，并与操作系统的 I/O 多路复用机制（如 <code>epoll</code>、<code>select</code>）进行交互。</li><li><strong>执行器（Executor）</strong>：用于调度任务的执行。</li></ul><p>简易单线程版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// 简化版的 io_context 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">io_context</span>() : <span class="built_in">stopped_</span>(<span class="literal">false</span>), <span class="built_in">epoll_fd_</span>(::<span class="built_in">epoll_create1</span>(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd_ == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create epoll file descriptor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">io_context</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">close</span>(epoll_fd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post 方法将任务添加到任务队列中</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(CompletionHandler handler)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">            task_queue_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(handler));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wake_up</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopped_)</span><br><span class="line">        &#123;</span><br><span class="line">            std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (!task_queue_.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    task = std::<span class="built_in">move</span>(task_queue_.<span class="built_in">front</span>());</span><br><span class="line">                    task_queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">wait_for_events</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stopped_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">wake_up</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置停止状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stopped_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册文件描述符到 epoll</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_to_epoll</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        epoll_event event;</span><br><span class="line">        event.events = events;</span><br><span class="line">        event.data.fd = fd;</span><br><span class="line">        <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to add file descriptor to epoll&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 等待 I/O 事件的发生</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_for_events</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        epoll_event events[MAX_EVENTS];</span><br><span class="line">        <span class="type">int</span> num_events = ::<span class="built_in">epoll_wait</span>(epoll_fd_, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (num_events == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_events; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">handle_event</span>(events[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 I/O 事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_event</span><span class="params">(epoll_event &amp;event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理可读事件</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handle read event on fd: &quot;</span> &lt;&lt; event.data.fd &lt;&lt; std::endl;</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(event.data.fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(buffer, n) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Connection closed on fd: &quot;</span> &lt;&lt; event.data.fd &lt;&lt; std::endl;</span><br><span class="line">                ::<span class="built_in">close</span>(event.data.fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Read error on fd: &quot;</span> &lt;&lt; event.data.fd &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wake_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 在真正的实现中，可能会使用 eventfd 或管道来唤醒 epoll_wait</span></span><br><span class="line">        <span class="comment">// 这里为了简化，假设其他线程的 post 操作已唤醒 epoll_wait</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_EVENTS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> stopped_;</span><br><span class="line">    <span class="type">int</span> epoll_fd_;</span><br><span class="line">    std::deque&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">    std::mutex queue_mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 I/O 任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_read</span><span class="params">(io_context &amp;io_ctx, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_ctx.<span class="built_in">add_to_epoll</span>(fd, EPOLLIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_context io_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟异步 I/O 操作</span></span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    ::<span class="built_in">pipe</span>(pipe_fds);</span><br><span class="line">    <span class="built_in">fcntl</span>(pipe_fds[<span class="number">0</span>], F_SETFL, O_NONBLOCK); <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">    io_ctx.<span class="built_in">post</span>([&amp;io_ctx, pipe_fds]()</span><br><span class="line">                &#123; <span class="built_in">async_read</span>(io_ctx, pipe_fds[<span class="number">0</span>]); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在另一个线程写入数据，模拟异步事件</span></span><br><span class="line">    <span class="function">std::thread <span class="title">writer</span><span class="params">([pipe_fds]()</span></span></span><br><span class="line"><span class="params"><span class="function">                       &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ::sleep(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;Hello from the other side!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        ::write(pipe_fds[<span class="number">1</span>], msg, strlen(msg));</span></span></span><br><span class="line"><span class="params"><span class="function">        ::close(pipe_fds[<span class="number">1</span>]); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    io_ctx.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    writer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以用多线程版本的io_context来实现啦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// 多线程版的 io_context 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">io_context</span>() : <span class="built_in">stopped_</span>(<span class="literal">false</span>), <span class="built_in">work_count_</span>(<span class="number">0</span>), <span class="built_in">epoll_fd_</span>(::<span class="built_in">epoll_create1</span>(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd_ == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create epoll file descriptor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">io_context</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">close</span>(epoll_fd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post 方法将任务添加到任务队列中</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(CompletionHandler handler)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">            task_queue_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(handler));</span><br><span class="line">            ++work_count_;</span><br><span class="line">        &#125;</span><br><span class="line">        queue_condition_.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">                queue_condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                                      &#123; <span class="keyword">return</span> stopped_ || !task_queue_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (stopped_ &amp;&amp; task_queue_.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                task = std::<span class="built_in">move</span>(task_queue_.<span class="built_in">front</span>());</span><br><span class="line">                task_queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">            --work_count_;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">wait_for_events</span>(); <span class="comment">// 处理 I/O 事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">            stopped_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue_condition_.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有等待的线程以终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置停止状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stopped_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册文件描述符到 epoll</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_to_epoll</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        epoll_event event;</span><br><span class="line">        event.events = events;</span><br><span class="line">        event.data.fd = fd;</span><br><span class="line">        <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to add file descriptor to epoll&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 等待 I/O 事件的发生</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_for_events</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        epoll_event events[MAX_EVENTS];</span><br><span class="line">        <span class="type">int</span> num_events = ::<span class="built_in">epoll_wait</span>(epoll_fd_, events, MAX_EVENTS, <span class="number">0</span>); <span class="comment">// Non-blocking wait</span></span><br><span class="line">        <span class="keyword">if</span> (num_events == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_events; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">handle_event</span>(events[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 I/O 事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_event</span><span class="params">(epoll_event &amp;event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理可读事件</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handle read event on fd: &quot;</span> &lt;&lt; event.data.fd &lt;&lt; std::endl;</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(event.data.fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(buffer, n) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Connection closed on fd: &quot;</span> &lt;&lt; event.data.fd &lt;&lt; std::endl;</span><br><span class="line">                ::<span class="built_in">close</span>(event.data.fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Read error on fd: &quot;</span> &lt;&lt; event.data.fd &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_EVENTS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stopped_;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; work_count_;</span><br><span class="line">    <span class="type">int</span> epoll_fd_;</span><br><span class="line">    std::deque&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_queue_;</span><br><span class="line">    std::mutex queue_mutex_;</span><br><span class="line">    std::condition_variable queue_condition_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_context io_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    std::vector&lt;std::thread&gt; thread_pool;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = std::thread::<span class="built_in">hardware_concurrency</span>(); <span class="comment">// 根据硬件并发数设置线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        thread_pool.<span class="built_in">emplace_back</span>([&amp;io_ctx]()</span><br><span class="line">                                 &#123; io_ctx.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟异步 I/O 操作</span></span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    ::<span class="built_in">pipe</span>(pipe_fds);</span><br><span class="line">    <span class="built_in">fcntl</span>(pipe_fds[<span class="number">0</span>], F_SETFL, O_NONBLOCK); <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">    io_ctx.<span class="built_in">post</span>([&amp;io_ctx, pipe_fds]()</span><br><span class="line">                &#123; io_ctx.<span class="built_in">add_to_epoll</span>(pipe_fds[<span class="number">0</span>], EPOLLIN); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在另一个线程写入数据，模拟异步事件</span></span><br><span class="line">    <span class="function">std::thread <span class="title">writer</span><span class="params">([pipe_fds]()</span></span></span><br><span class="line"><span class="params"><span class="function">                       &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ::sleep(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;Hello from the other side!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        ::write(pipe_fds[<span class="number">1</span>], msg, strlen(msg));</span></span></span><br><span class="line"><span class="params"><span class="function">        ::close(pipe_fds[<span class="number">1</span>]); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : thread_pool)</span><br><span class="line">    &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-O-对象">I/O 对象</h2><p>这是一个简化版的 I/O 对象类（<code>basic_socket</code>），它模拟了 <code>boost::asio::basic_socket</code> 的一些基本功能。这个类将展示如何通过 <code>io_context</code> 实现异步 I/O 操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版的 basic_socket 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basic_socket</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">basic_socket</span>(boost::asio::io_context&amp; io_context)</span><br><span class="line">        : <span class="built_in">io_context_</span>(io_context), <span class="built_in">socket_fd_</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，关闭 socket</span></span><br><span class="line">    ~<span class="built_in">basic_socket</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket_fd_ != <span class="number">-1</span>) &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(socket_fd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span> </span>&#123;</span><br><span class="line">        socket_fd_ = ::<span class="built_in">socket</span>(domain, type, protocol);</span><br><span class="line">        <span class="keyword">if</span> (socket_fd_ == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create socket&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">        <span class="built_in">fcntl</span>(socket_fd_, F_SETFL, O_NONBLOCK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">async_connect</span><span class="params">(<span class="type">const</span> sockaddr_in&amp; remote, std::function&lt;<span class="type">void</span>(<span class="type">const</span> boost::system::error_code&amp;)&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = ::<span class="built_in">connect</span>(socket_fd_, (sockaddr*)&amp;remote, <span class="built_in">sizeof</span>(remote));</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 立即成功</span></span><br><span class="line">            <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">            <span class="comment">// 连接正在进行中，注册到 io_context 的 epoll 中</span></span><br><span class="line">            io_context_.<span class="built_in">add_to_epoll</span>(socket_fd_, EPOLLOUT);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在异步连接操作完成后，使用 getsockopt 函数检查套接字的错误状态。</span></span><br><span class="line"><span class="comment">                如果连接成功（即没有错误），则通过调用 handler 回调函数通知调用者操作成功。</span></span><br><span class="line"><span class="comment">                如果连接失败，则通过 handler 将错误码传递给调用者，以便进行错误处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            <span class="comment">// 将回调函数包装为一个 lambda 并 post 到 io_context</span></span><br><span class="line">            io_context_.<span class="built_in">post</span>([<span class="keyword">this</span>, handler]() &#123;</span><br><span class="line">                <span class="type">int</span> so_error;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(so_error);</span><br><span class="line">                <span class="built_in">getsockopt</span>(socket_fd_, SOL_SOCKET, SO_ERROR, &amp;so_error, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> (so_error == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(so_error, boost::asio::error::<span class="built_in">get_system_category</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 立即失败</span></span><br><span class="line">            <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(errno, boost::asio::error::<span class="built_in">get_system_category</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步读</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">async_read</span><span class="params">(<span class="type">char</span>* buffer, std::<span class="type">size_t</span> length, std::function&lt;<span class="type">void</span>(<span class="type">const</span> boost::system::error_code&amp;, std::<span class="type">size_t</span>)&gt; handler)</span> </span>&#123;</span><br><span class="line">        io_context_.<span class="built_in">add_to_epoll</span>(socket_fd_, EPOLLIN);</span><br><span class="line"></span><br><span class="line">        io_context_.<span class="built_in">post</span>([<span class="keyword">this</span>, buffer, length, handler]() &#123;</span><br><span class="line">            <span class="type">ssize_t</span> bytes_read = ::<span class="built_in">read</span>(socket_fd_, buffer, length);</span><br><span class="line">            <span class="keyword">if</span> (bytes_read &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(), bytes_read);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(errno, boost::asio::error::<span class="built_in">get_system_category</span>()), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">async_write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buffer, std::<span class="type">size_t</span> length, std::function&lt;<span class="type">void</span>(<span class="type">const</span> boost::system::error_code&amp;, std::<span class="type">size_t</span>)&gt; handler)</span> </span>&#123;</span><br><span class="line">        io_context_.<span class="built_in">add_to_epoll</span>(socket_fd_, EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        io_context_.<span class="built_in">post</span>([<span class="keyword">this</span>, buffer, length, handler]() &#123;</span><br><span class="line">            <span class="type">ssize_t</span> bytes_written = ::<span class="built_in">write</span>(socket_fd_, buffer, length);</span><br><span class="line">            <span class="keyword">if</span> (bytes_written &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(), bytes_written);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(errno, boost::asio::error::<span class="built_in">get_system_category</span>()), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket_fd_ != <span class="number">-1</span>) &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(socket_fd_);</span><br><span class="line">            socket_fd_ = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::asio::io_context&amp; io_context_;  <span class="comment">// 关联的 io_context</span></span><br><span class="line">    <span class="type">int</span> socket_fd_;  <span class="comment">// 套接字文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 I/O 对象</span></span><br><span class="line">    <span class="function">basic_socket <span class="title">socket</span><span class="params">(io_ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个 IPv4 TCP 套接字</span></span><br><span class="line">    socket.<span class="built_in">open</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程地址</span></span><br><span class="line">    sockaddr_in remote_addr;</span><br><span class="line">    remote_addr.sin_family = AF_INET;</span><br><span class="line">    remote_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;remote_addr.sin_addr); <span class="comment">// example.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步连接</span></span><br><span class="line">    socket.<span class="built_in">async_connect</span>(remote_addr, [&amp;socket](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Connected successfully!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步写入数据</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;</span>;</span><br><span class="line">            socket.<span class="built_in">async_write</span>(msg, <span class="built_in">strlen</span>(msg), [&amp;socket](<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;Sent &quot;</span> &lt;&lt; bytes_transferred &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 异步读取响应</span></span><br><span class="line">                    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                    socket.<span class="built_in">async_read</span>(buffer, <span class="built_in">sizeof</span>(buffer), [](<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_read) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;Received &quot;</span> &lt;&lt; bytes_read &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">                            std::cout &lt;&lt; std::<span class="built_in">string</span>(buffer, bytes_read) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            std::cerr &lt;&lt; <span class="string">&quot;Read error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;Write error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Connect error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 事件循环</span></span><br><span class="line">    io_ctx.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步操作函数">异步操作函数</h2><p><a href="https://www.cnblogs.com/my_life/articles/5329955.html">https://www.cnblogs.com/my_life/articles/5329955.html</a></p><p><strong>asio在linux下是模拟Proactor模式，在win下是真正的Proactor</strong></p><p>这2部分代码结合起来看就更容易理解。</p><p>代码1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_read</span><span class="params">(io_context&amp; io_ctx, <span class="type">int</span> socket_fd, <span class="type">char</span>* buffer, <span class="type">size_t</span> buffer_size, std::function&lt;<span class="type">void</span>(<span class="type">const</span> boost::system::error_code&amp;, <span class="type">size_t</span>)&gt; handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 socket_fd 注册到 epoll 中，监听可读事件</span></span><br><span class="line">    io_ctx.<span class="built_in">add_to_epoll</span>(socket_fd, EPOLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将读取任务 post 到 io_context 中</span></span><br><span class="line">    io_ctx.<span class="built_in">post</span>([socket_fd, buffer, buffer_size, handler]() &#123;</span><br><span class="line">        <span class="type">ssize_t</span> bytes_read = ::<span class="built_in">read</span>(socket_fd, buffer, buffer_size);</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(), bytes_read);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>(errno, boost::asio::error::<span class="built_in">get_system_category</span>()), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码2.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_read_some_example</span><span class="params">(boost::asio::ip::tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    socket.<span class="built_in">async_read</span>(boost::asio::<span class="built_in">buffer</span>(data), </span><br><span class="line">        [&amp;socket, &amp;data](<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; bytes_transferred &lt;&lt; <span class="string">&quot; bytes: &quot;</span> </span><br><span class="line">                          &lt;&lt; std::<span class="built_in">string</span>(data, bytes_transferred) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 可以继续进行异步读取</span></span><br><span class="line">                <span class="built_in">async_read_some_example</span>(socket);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;example.com&quot;</span>, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">    boost::asio::<span class="built_in">connect</span>(socket, endpoints);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">async_read_some_example</span>(socket);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>(); <span class="comment">// 启动事件循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Boost.Asio 中，异步操作是通过事件驱动机制实现的，操作完成后回调函数被调用处理结果。</p><p><strong>问题：linux下start_async_read函数中的data[1024]数据是由谁读取的，是内核还是用户态线程?</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_read_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; bytes_transferred &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_async_read</span><span class="params">(tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">    socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), async_read_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assume connection is established</span></span><br><span class="line">    <span class="built_in">start_async_read</span>(socket);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();  <span class="comment">// Starts the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>start_async_read</code> 函数中的 <code>data[1024]</code> 数据是由谁读取的？是内核还是用户态线程？</strong></p><ul><li><strong>内核负责接收数据</strong>：最初的数据是由内核从网络接口接收，并存储在内核态的 socket 缓冲区中。</li><li><strong>用户态线程负责拷贝数据</strong>：当异步读取操作完成时，<code>io_context</code> 线程会将数据从内核缓冲区拷贝到 <code>data[1024]</code> 这个用户态缓冲区中。</li></ul><p>因此，<strong>读取数据的过程是由用户态线程完成的</strong>，但数据最初是由内核接收并存储的。内核完成数据的接收工作，而用户态线程负责将这些数据从内核缓冲区中拷贝到用户态的 <code>data[1024]</code> 缓冲区中。<strong>这个负责将数据从内核缓冲区拷贝到用户态 <code>data[1024]</code> 缓冲区中的线程，通常就是 <code>io_context</code> 线程池中的一个线程</strong>。</p><p>真正能实现异步的需要使用win下的api:IOCP。<a href="https://mp.weixin.qq.com/s/39GChVQVvljaEt_9ra_alA">深入理解Windows异步机制：IOCP的工作原理与应用</a></p><p>**这里其实遗留了一个问题：**通常会有多个文件描述符（如套接字）监听不同的事件（如可读、可写等）。当这些事件发生时，如何将事件与相应的任务（即处理这些事件的回调函数）对应起来呢？</p><p>感兴趣的可以看看源码部分！</p><h2 id="结合协程">结合协程</h2><p><code>Boost.Asio</code> 与协程结合起来可以提高效率，主要原因在于协程使得异步操作的代码看起来更像同步代码，从而更易于编写、理解和维护，同时减少了回调地狱（callback hell）的复杂性。</p><p>优势</p><ul><li><strong>代码简化</strong>：协程使得异步代码更容易理解，因为它消除了大量的回调函数和状态管理代码。</li><li><strong>自然的控制流</strong>：协程允许你使用 <code>await</code> 或类似的操作来等待异步操作完成，代码结构更直观。</li><li><strong>减少上下文切换</strong>：协程在同一个线程内执行，不需要像线程那样频繁切换上下文，从而提高了性能。</li></ul><blockquote><p>对比</p></blockquote><p>需求：</p><p>我们要实现一个简单的 TCP 服务器，它需要依次执行以下操作：</p><ul><li>接受客户端连接。</li><li>从客户端读取数据。</li><li>处理数据（假设只是简单的回显）。</li><li>返回处理后的数据给客户端。</li></ul><p><strong>不使用协程的实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>(tcp::socket socket) : <span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">do_read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">self</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">        socket_.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data_, max_length),</span><br><span class="line">            [<span class="keyword">this</span>, self](boost::system::error_code ec, std::<span class="type">size_t</span> length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    <span class="built_in">do_write</span>(length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_write</span><span class="params">(std::<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">self</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(socket_, boost::asio::<span class="built_in">buffer</span>(data_, length),</span><br><span class="line">            [<span class="keyword">this</span>, self](boost::system::error_code ec, std::<span class="type">size_t</span> <span class="comment">/*length*/</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    <span class="built_in">do_read</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp::socket socket_;</span><br><span class="line">    <span class="keyword">enum</span> &#123; max_length = <span class="number">1024</span> &#125;;</span><br><span class="line">    <span class="type">char</span> data_[max_length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port)</span><br><span class="line">        : <span class="built_in">acceptor_</span>(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">        <span class="built_in">do_accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acceptor_.<span class="built_in">async_accept</span>(</span><br><span class="line">            [<span class="keyword">this</span>](boost::system::error_code ec, tcp::socket socket) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    std::<span class="built_in">make_shared</span>&lt;Session&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">start</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">do_accept</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp::acceptor acceptor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line">        <span class="function">Server <span class="title">s</span><span class="params">(io_context, <span class="number">12345</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的数量</p><p>在这个例子中，你可以看到：</p><ul><li><code>do_read()</code>：读取数据时使用了一个回调函数。</li><li><code>do_write()</code>：写入数据时使用了一个回调函数。</li><li><code>do_accept()</code>：接受连接时使用了一个回调函数。</li></ul><p><strong>使用协程的实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/awaitable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/co_spawn.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/detached.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::awaitable;</span><br><span class="line"><span class="keyword">using</span> boost::asio::co_spawn;</span><br><span class="line"><span class="keyword">using</span> boost::asio::detached;</span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"><span class="keyword">using</span> boost::asio::use_awaitable;</span><br><span class="line"></span><br><span class="line"><span class="function">awaitable&lt;<span class="type">void</span>&gt; <span class="title">session</span><span class="params">(tcp::socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 异步读取数据</span></span><br><span class="line">            std::<span class="type">size_t</span> n = <span class="keyword">co_await</span> socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), use_awaitable);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步写入数据</span></span><br><span class="line">            <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_write</span>(socket, boost::asio::<span class="built_in">buffer</span>(data, n), use_awaitable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Session exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">awaitable&lt;<span class="type">void</span>&gt; <span class="title">listener</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), port))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 异步接受连接</span></span><br><span class="line">        tcp::socket socket = <span class="keyword">co_await</span> acceptor.<span class="built_in">async_accept</span>(use_awaitable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动处理 session 的协程</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(io_context, <span class="built_in">session</span>(std::<span class="built_in">move</span>(socket)), detached);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动监听协程</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(io_context, <span class="built_in">listener</span>(io_context, <span class="number">12345</span>), detached);</span><br><span class="line"></span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Main exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的数量</p><p>在这个版本中，你可以看到：</p><ul><li><code>session()</code>：协程函数内使用 <code>co_await</code> 关键字等待异步操作完成，代码看起来像同步代码，但实际上在每个 <code>co_await</code> 点都让出了执行权。</li><li><code>listener()</code>：同样通过 <code>co_await</code> 来等待异步接受连接。</li></ul><p>总共只有 <strong>1 个回调函数</strong>，那就是 <code>co_spawn</code> 的回调，但这个回调是为了启动协程并不直接参与异步 I/O 操作。</p><h2 id="扩展">扩展</h2><h3 id="coost">coost</h3><p><a href="https://coostdocs.github.io/cn/about/co/">https://coostdocs.github.io/cn/about/co/</a></p><p><strong>coost v3.0.0 (微型boost库)</strong></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/idealvin/coost">coost-A tiny boost library in C++11github.com/idealvin/coost</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/idealvin/coost">coost</a> 是一个<strong>兼具性能与易用性</strong>的跨平台 C++ 基础库，原名为 co，后改为 cocoyaxi，前者过短，后者过长，取中庸之道，又改为 coost。</p><p>为什么叫 coost 呢？以前有朋友称之为小型 <a href="https://link.zhihu.com/?target=https%3A//www.boost.org/">boost</a> 库，比 boost 小一点，那就叫 coost 好了。它有多小呢？在 <strong>linux 与 mac 上编译出来的静态库仅 1M 左右大小</strong>。虽然小，却提供了足够强大的功能：</p><ul><li>命令行参数与配置文件解析库(flag)</li><li>高性能日志库(log)</li><li>单元测试框架(unitest)</li><li><strong>go-style 协程</strong></li><li>基于协程的网络编程框架</li><li>高效 JSON 库</li><li><strong>基于 JSON 的 RPC 框架</strong></li><li>面向玄学编程</li><li>原子操作(atomic)</li><li>随机数生成器(random)</li><li>高效字符流(fastream)</li><li>高效字符串(fastring)</li><li>字符串操作(str)</li><li>时间库(time)</li><li>线程库(thread)</li><li>定时任务调度器</li><li><strong>高性能内存分配器</strong></li><li>LruMap</li><li>hash 库</li><li>path 库</li><li>文件系统操作(fs)</li><li>系统操作(os)</li></ul><p>本次发布的版本，直接从 v2.0.3 跳到了 v3.0.0，跨度非常之大，它在<strong>性能</strong>、<strong>易用性</strong>、<strong>稳定性</strong>等方面均有全面的提升。</p><blockquote><p><strong>协程</strong></p></blockquote><h3 id="协程">协程</h3><p>coost 实现了类似 golang 中 goroutine 的协程机制，它有如下特性：</p><ul><li>支持多线程调度，默认线程数为系统 CPU 核数。</li><li>共享栈，同一线程中的协程共用若干个栈(大小默认为 1MB)，内存占用低。</li><li>各协程之间为平级关系，可以在任何地方(包括在协程中)创建新的协程。</li><li>支持协程同步事件、协程锁、channel、waitgroup 等协程同步机制。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co/co.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    flag::<span class="built_in">parse</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    co::wait_group wg;</span><br><span class="line">    wg.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">go</span>([wg]()&#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        wg.<span class="built_in">done</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">go</span>([wg]()&#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;hello again&quot;</span>;</span><br><span class="line">        wg.<span class="built_in">done</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    wg.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>go()</code> 创建的协程会分配到不同的调度线程中。用户也可以自行控制协程的调度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run f1 and f2 in the same scheduler</span></span><br><span class="line"><span class="keyword">auto</span> s = co::<span class="built_in">next_sched</span>();</span><br><span class="line">s-&gt;<span class="built_in">go</span>(f1);</span><br><span class="line">s-&gt;<span class="built_in">go</span>(f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// run f in all schedulers</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : co::<span class="built_in">scheds</span>()) &#123;</span><br><span class="line">    s-&gt;<span class="built_in">go</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>网络编程</strong></p></blockquote><p>coost 提供了一套基于协程的网络编程框架:</p><ul><li><strong><a href="https://coostdocs.github.io/cn/co/net/sock/">协程化的 socket API</a></strong>，形式上与系统 socket API 类似，熟悉 socket 编程的用户，可以轻松的用同步的方式写出高性能的网络程序。</li><li><a href="https://coostdocs.github.io/cn/co/net/tcp/">TCP</a>、<a href="https://coostdocs.github.io/cn/co/net/http/">HTTP</a>、<a href="https://coostdocs.github.io/cn/co/net/rpc/">RPC</a> 等高层网络编程组件，兼容 IPv6，同时支持 SSL，用起来比 socket API 更方便。</li></ul><p><strong>RPC server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co/co.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co/rpc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co/time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    flag::<span class="built_in">parse</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    rpc::<span class="built_in">Server</span>()</span><br><span class="line">        .<span class="built_in">add_service</span>(<span class="keyword">new</span> xx::HelloWorldImpl)</span><br><span class="line">        .<span class="built_in">start</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7788</span>, <span class="string">&quot;/xx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) sleep::<span class="built_in">sec</span>(<span class="number">80000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rpc::Server 同时支持 HTTP 协议，可以用 HTTP 的 POST 方法调用 RPC 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:7788/xx --request POST --data <span class="string">&#x27;&#123;&quot;api&quot;:&quot;ping&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Boost::Asio机制</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Glibc-ptmalloc</title>
    <link href="https://penge666.github.io/posts/3707fe10.html"/>
    <id>https://penge666.github.io/posts/3707fe10.html</id>
    <published>2024-08-06T15:25:18.000Z</published>
    <updated>2024-09-21T11:51:00.615Z</updated>
    
    <content type="html"><![CDATA[<p>比赛的第一分钟和最后一分钟要保存一样的心态~</p><p>在Unix和类Unix系统中，glibc（GNU C Library）扮演着至关重要的角色。它作为系统调用和库函数的桥梁，使得程序员能够方便地利用底层系统资源。<code>ptmalloc</code> 是 <code>malloc</code> 在 GNU C Library（glibc）中的一个具体实现。</p><p><strong>32</strong> <strong>位模式下进程内存经典布局</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806233656259.png" alt="image-20240806233656259"></p><p>着重关注两个区：<strong>heap</strong>（堆区） <strong>memory mapping</strong>（内存映射区）</p><ul><li><p>brk函数其实就是在heap分配空间，在ptmalloc的设计中有start_brk和brk两个标志，他们两个的差值标记着堆区的大小。一开始这两个值是相同的，但是随着ptmalloc去调用brk函数，brk标记不断向高地址区域偏移，标记着heap堆区被分配出去了。</p></li><li><p>mmap函数则是在memory mapping区域分配空间，memory mapping区域除了我们常知道的映射动态库对象或者文件，其空间还可以被mmap映射至物理内存。</p></li></ul><h2 id="分配区">分配区</h2><p>在 Doug Lea 实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在 SMP 多线程环境下，对主分配区的锁的争用很激烈，严重影响了 malloc 的分配效率。<strong>于是 Wolfram Gloger 在 Doug Lea 的基础上改进使得Glibc 的 malloc 可以支持多线程，增加了非主分配区（non main arena）支持，主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</strong>【有点分段锁的味道】</p><p>每个进程只有一个主分配区，但可能存在多个非主分配区，ptmalloc 根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。**主分配区可以访问进程的 heap 区域和 mmap 映射区域，也就是说主分配区可以使用 sbrk 和 mmap向操作系统申请虚拟内存。而非主分配区只能访问进程的 mmap 映射区域，非主分配区每次使用 mmap()向操作系统“发”HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统默认为 64MB）大小的虚拟内存，**当用户向非主分配区请求分配内存时再切割成小块“零售”出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap()函数向操作系统申请虚拟内存。</p><p>主分配区可以访问 heap 区域，如果用户不调用 brk()或是 sbrk()函数，分配程序就可以保证分配到连续的虚拟地址空间，因为每个进程只有一个主分配区使用 sbrk()分配 heap 区域的虚拟内存。内核对 brk 的实现可以看着是 mmap 的一个精简版，相对高效一些。如果主分配区的内存是通过 mmap()向系统分配的，当 free 该内存时，主分配区会直接调用 munmap()将该内存归还给系统。</p><p>**当某一线程需要调用 malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。**在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。申请小块内存时会产生很多内存碎片，ptmalloc 在整理时也需要对分配区做加锁操作。每个加锁操作大概需要 5～10 个 cpu 指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致 malloc 性能下降。一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc在多线程竞争情况下性能远远落后于 tcmalloc。最新版的 ptmalloc 对锁进行了优化，加入了PER_THREAD 和 ATOMIC_FASTBINS 优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。</p><p><strong>代码角度理解</strong></p><p><strong>主分配区（Main Arena）</strong></p><p>主分配区是唯一的，它与进程的主线程相关联。主分配区使用进程的堆（heap）来分配内存，并且在进程启动时创建，始终存在。以下是主分配区的一些关键代码实现细节：</p><ol><li><p><strong><code>malloc_state</code> 结构体</strong>：</p><ul><li><p>这是主分配区的核心数据结构，包含了所有用于管理内存的字段，例如 <code>bins</code> 数组、<code>top</code> 指针（指向当前未分配的内存区域）、<code>last_remainder</code> 指针（指向最后一个分割的内存块）等。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    <span class="type">binmap_t</span> binmap;          <span class="comment">// 用于快速查找非空 bin 的位图</span></span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *last_remainder; <span class="comment">// 指向最后一个分割的内存块</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><p>主分配区通常是一个全局变量，例如在 <code>glibc</code> 中，主分配区可以通过 <code>main_arena</code> 变量访问。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> malloc_state main_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化</strong>：</p><ul><li><p>主分配区在进程启动时初始化，通常在 <code>ptmalloc</code> 的初始化函数中完成。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ptmalloc_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化主分配区</span></span><br><span class="line">    <span class="built_in">init_arena</span>(&amp;main_arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>从分配区（Thread Arena）</strong></p><p>从分配区是为每个线程独立创建的分配区，它允许线程独立地管理内存，从而减少锁竞争，提高并发性能。以下是从分配区的一些关键代码实现细节：</p><ol><li><p><strong>线程局部存储（Thread Local Storage, TLS）</strong>：</p><ul><li><p>每个线程可以通过线程局部存储（TLS）来访问自己的分配区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread malloc_state *thread_arena;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>创建从分配区</strong>：</p><ul><li><p>当一个线程第一次调用 <code>malloc</code> 时，如果还没有分配区，<code>ptmalloc</code> 会为该线程创建一个新的从分配区。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> malloc_state *<span class="title">arena_get</span><span class="params">(mstate *ar_ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *a;</span><br><span class="line">    <span class="comment">// 尝试获取现有的分配区或创建新的分配区</span></span><br><span class="line">    a = <span class="built_in">get_free_list</span>(); <span class="comment">// 从空闲列表中获取分配区</span></span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        a = _int_new_arena(size); <span class="comment">// 创建新的分配区</span></span><br><span class="line">    &#125;</span><br><span class="line">    *ar_ptr = a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配和释放</strong>：</p><ul><li><p>当线程请求内存时，<code>ptmalloc</code> 会从相应的分配区中查找合适的内存块。如果找到合适的内存块，则将其从 <code>bins</code> 中移除并返回给调用者。</p></li><li><p>示例代码（简化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line">    <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="built_in">arena_get</span>(&amp;ar_ptr, size);</span><br><span class="line">    <span class="comment">// 从分配区中查找合适的内存块</span></span><br><span class="line">    victim = _int_malloc(ar_ptr, size);</span><br><span class="line">    <span class="keyword">if</span> (!victim) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些代码片段，可以看到主分配区和从分配区的基本结构和操作。</p><h2 id="关键数据结构">关键数据结构</h2><p>在 <code>ptmalloc</code> 内存分配器中，<code>unsorted bin</code>、<code>Fast Bins</code>、<code>top chunk</code>、<code>bins</code> 和 <code>mmaped chunk</code> 是用于管理内存块的关键数据结构。它们之间的关系和作用如下：</p><ol><li><code>unsorted bin</code></li></ol><p><code>unsorted bin</code> 是一个双向链表，用于临时存储最近释放的内存块。这些内存块在下次分配请求时会被重新整理并放入相应的 <code>bins</code> 中。</p><ol start="2"><li><code>Fast Bins</code></li></ol><p><code>Fast Bins</code> 是一个单链表数组，用于存储较小的空闲内存块（通常小于64或128字节）。<code>Fast Bins</code> 中的内存块不会被合并，这样可以快速地进行分配和释放。</p><ol start="3"><li><code>top chunk</code></li></ol><p><code>top chunk</code> 是分配区中未分配的内存区域。当 <code>bins</code> 中没有合适的内存块时，<code>ptmalloc</code> 会从 <code>top chunk</code> 中分割出所需的内存块。</p><ol start="4"><li><code>bins</code></li></ol><p><code>bins</code> 是一个双向链表数组，用于存储具有相同大小的空闲内存块。<code>bins</code> 分为 <code>small bins</code> 和 <code>large bins</code>，分别用于存储较小的和较大的内存块。</p><ol start="5"><li><code>mmaped chunk</code></li></ol><p><code>mmaped chunk</code> 是通过 <code>mmap</code> 系统调用分配的内存块。当请求的内存大小超过某个阈值时，<code>ptmalloc</code> 会使用 <code>mmap</code> 来分配内存，而不是从堆中分配。</p><p><strong>代码解读</strong></p><p>以下是一个简化的代码示例，展示了这些数据结构之间的关系和作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> prev_size;  <span class="comment">// 前一个内存块的大小</span></span><br><span class="line">    <span class="type">size_t</span> size;       <span class="comment">// 当前内存块的大小</span></span><br><span class="line">    malloc_chunk *fd;  <span class="comment">// 指向链表中下一个内存块</span></span><br><span class="line">    malloc_chunk *bk;  <span class="comment">// 指向链表中前一个内存块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    malloc_chunk *top;        <span class="comment">// 指向 top chunk</span></span><br><span class="line">    malloc_chunk *fastbinsY[NFASTBINS]; <span class="comment">// Fast Bins 数组</span></span><br><span class="line">    malloc_chunk *bins[NBINS]; <span class="comment">// bins 数组</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    malloc_state *ar_ptr = <span class="built_in">get_arena</span>(); <span class="comment">// 获取当前线程的分配区</span></span><br><span class="line">    <span class="type">size_t</span> nb = <span class="built_in">request2size</span>(size);     <span class="comment">// 将请求的大小转换为实际分配的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 Fast Bins 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt;= <span class="built_in">get_max_fast</span>()) &#123;</span><br><span class="line">        idx = <span class="built_in">fastbin_index</span>(nb);</span><br><span class="line">        fb = &amp;fastbinsY[idx];</span><br><span class="line">        victim = *fb;</span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 unsorted bin 中分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unsorted_chunks</span>(ar_ptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        victim = <span class="built_in">unsorted_chunks</span>(ar_ptr);</span><br><span class="line">        <span class="built_in">unsorted_chunks</span>(ar_ptr) = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (victim-&gt;size == nb) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 bins 中分配内存</span></span><br><span class="line">    idx = <span class="built_in">bin_index</span>(nb);</span><br><span class="line">    bin = <span class="built_in">bin_at</span>(ar_ptr, idx);</span><br><span class="line">    victim = <span class="built_in">first</span>(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin) &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(victim, bk, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从 top chunk 中分配内存</span></span><br><span class="line">    victim = ar_ptr-&gt;top;</span><br><span class="line">    size = <span class="built_in">chunksize</span>(victim);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">        ar_ptr-&gt;top = remainder;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 mmap 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (nb &amp; MMAP_THRESHOLD) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, nb, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>获取分配区</strong>：<ul><li><code>get_arena()</code> 函数获取当前线程的分配区。</li></ul></li><li><strong>Fast Bins</strong>：<ul><li>如果请求的大小小于 <code>get_max_fast()</code> 返回的值，尝试从 <code>Fast Bins</code> 中分配内存。</li><li><code>fastbin_index(nb)</code> 计算 <code>Fast Bins</code> 的索引，<code>fastbinsY[idx]</code> 获取相应的 <code>Fast Bin</code>。</li><li>如果找到合适的内存块，将其从 <code>Fast Bin</code> 中移除并返回。</li></ul></li><li><strong>unsorted bin</strong>：<ul><li>如果 <code>unsorted bin</code> 不为空，尝试从中分配内存。</li><li>如果找到合适大小的内存块，直接返回。</li></ul></li><li><strong>bins</strong>：<ul><li>计算请求大小的 <code>bin</code> 索引，尝试从相应的 <code>bin</code> 中分配内存。</li><li>如果找到合适的内存块，将其从 <code>bin</code> 中移除并返回。</li></ul></li><li><strong>top chunk</strong>：<ul><li>如果 <code>top chunk</code> 的大小足够，从 <code>top chunk</code> 中分割出所需的内存块，并更新 <code>top chunk</code> 的指针。</li></ul></li><li><strong>mmaped chunk</strong>：<ul><li>如果请求的大小超过某个阈值，使用 <code>mmap</code> 系统调用分配内存。</li></ul></li></ol><h2 id="分配释放策略">分配释放策略</h2><p><strong>ptmalloc 的分配策略</strong></p><ul><li>获取分配区锁，加锁成功则使用该分配区分配内存，否则就遍历分配区的环形链表。如果链表中没有空闲的，就开辟一个新的分配区，把其加入线程私有实例并且加入到环形链表。</li><li>将用户请求的字节向上对齐到bins中的最近字节。</li><li>如果小于64B就在fast bin中分配内存，如果大于再去判断是否小于512B，如果小于就去small bin中分配大小，如果大于就说明此时分配的是大内存。</li><li>首先会将fast bin中的chunk进行合并，然后链接至unsorted bin，再将其链接到相应的bin中。</li><li>然后去large bins中进行寻找，如果够用结束，不够下一步。</li><li>这个时候就需要判断top chunk是否够用，不够用下一步。</li><li>有两种选择，判断分配的字节大小是否大于等于mmap分配阈值，如果小于根据分配区去选择brk还是mmap去增加top chunk的大小；如果大于就直接调用mmap去映射。</li></ul><p><strong>ptmalloc 的释放策略</strong></p><ul><li>获取分配区的锁</li><li>判断free参数是否位nullptr，如果为nullptr则什么都不做</li><li>如果释放空间为mmaped chunk，直接使用munmap释放</li><li>如果size &lt; 64B且不和top chunk相邻，放入fast bin</li><li>判断前一个块是否空闲，空闲则合并</li><li>判断下一个是否空闲，空闲则合并放入unsorted bin，然后放入相应的bin中</li><li>判读合并后是否大于64kb，如果大于fast bin中chunk进行合并，放入unsorted bin，然后下一步。</li><li>判读top chunk是否大于128kb，如果大于就会归还给操作系统。注意：如果为非主分配区，就只会归还一部部分。</li></ul><p>学习自：glibc内存管理ptmalloc源代码分析</p><p>补充：</p><ul><li><p><strong>libc</strong>：C 语言标准库的统称，提供 C 语言标准定义的函数和工具。</p></li><li><p><strong>glibc</strong>：GNU 实现的 C 语言标准库，广泛用于 Linux 系统。</p></li></ul>]]></content>
    
    
    <summary type="html">ptmalloc内存池</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>探索LRU算法</title>
    <link href="https://penge666.github.io/posts/e4a919c6.html"/>
    <id>https://penge666.github.io/posts/e4a919c6.html</id>
    <published>2024-08-05T03:02:01.000Z</published>
    <updated>2024-09-15T11:31:27.410Z</updated>
    
    <content type="html"><![CDATA[<p><strong>有太多能力可以提升，不要只看到技术</strong></p><p>开始之前，先上一道经典的面试题，LRU【🐕】</p><h2 id="热身">热身</h2><p><strong><a href="https://leetcode.cn/problems/lru-cache-lcci/">LRU 缓存</a></strong></p><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p><p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> <span class="built_in">LRUCache</span>( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key,value;</span><br><span class="line">    Node *pre,*next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k=<span class="number">0</span>,<span class="type">int</span> v=<span class="number">0</span>):<span class="built_in">key</span>(k),<span class="built_in">value</span>(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    Node* head;</span><br><span class="line">    map&lt;<span class="type">int</span>,Node*&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node *node)</span></span>&#123;</span><br><span class="line">        node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        node-&gt;pre=head;</span><br><span class="line">        node-&gt;next=head-&gt;next;</span><br><span class="line">        node-&gt;pre-&gt;next=node;</span><br><span class="line">        node-&gt;next-&gt;pre=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node=mp[key];</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        len=capacity;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        head=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        head-&gt;next=head;</span><br><span class="line">        head-&gt;pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node=<span class="built_in">getNode</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node=<span class="built_in">getNode</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            node-&gt;value=value;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* now=<span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">        mp[key]=now;</span><br><span class="line">        <span class="built_in">push_front</span>(now);</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&gt;len)&#123;</span><br><span class="line">            <span class="keyword">auto</span> last=head-&gt;pre;</span><br><span class="line">            mp.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(last);</span><br><span class="line">            <span class="keyword">delete</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="存在问题">存在问题</h2><p>学习自：<a href="https://blog.csdn.net/weixin_73077810/article/details/136197115">探索 LRU 算法的缺陷与解决方案</a></p><p>学习完了LRU算法，接下来看看是否存在什么问题呢？</p><p>传统的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><h3 id="预读失效">预读失效</h3><p>在 Linux 操作系统中，为了优化基于 Page Cache 的读缓存机制，提供了预读（read-ahead）机制。这个机制的工作原理可以通过以下例子来说明：</p><p>假设应用程序需要读取磁盘上文件 A 中 offset 为 0-3KB 的数据。由于磁盘的基本读写单位是块（通常为 4KB），操作系统会至少读取 0-4KB 范围内的内容，将其加载到内存中的一个 page 中。</p><p>然而，操作系统会基于空间局部性原则（即与当前访问的数据相邻的数据在未来有很大可能会被访问到），进一步优化读操作。为了提高后续读操作的效率，操作系统会预先将文件 A 的其他部分也加载到内存中，例如 offset [4KB,8KB)、[8KB,12KB)、以及 [12KB,16KB) 范围内的数据。这意味着操作系统会在内存中额外分配 3 个 page 来存储这些数据块，以便在应用程序需要访问这些范围的数据时，可以直接从内存中获取，而无需再次访问磁盘。</p><p>通过这种预读机制，操作系统能显著提高数据访问的效率，减少磁盘 I/O 的次数，提升整体性能。</p><p><strong>问题：</strong></p><p>预读失效会带来什么问题？</p><p>如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。</p><p>如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率 。</p><p><strong>Linux方案</strong></p><p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表和非活跃 LRU 链表；</p><p>有了这两个 LRU 链表后，预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。如果预读的页一直没有被访问，就会从 inactive list 移除，这样不会影响 active list 中的热点数据。active list 淘汰的数据就会被降级到 inactive list ，作为 inactive list 头部。</p><h3 id="缓冲污染">缓冲污染</h3><p>当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了。</p><p><strong>以 MySQL 举例子</strong></p><p>某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。</p><h2 id="LRU-K">LRU-K</h2><p>针对上述问题，之前在数据库实践专门针对这种情况使用另外的LRU-K算法。</p><p><strong>LRU-K 算法的核心</strong>是根据每个页面的最近 <code>K</code> 次访问记录来决定哪个页面应该被淘汰。访问次数越多，页面在缓存中存活的时间就越长。简单来说，LRU-K 提供了一种更精细的页面替换策略，与普通的 LRU 不同，它考虑了更深层次的访问历史。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/lru_k_replacer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，初始化替换器大小和K值</span></span><br><span class="line">LRUKReplacer::<span class="built_in">LRUKReplacer</span>(<span class="type">size_t</span> num_frames, <span class="type">size_t</span> k) : <span class="built_in">replacer_size_</span>(num_frames), <span class="built_in">k_</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱逐一个frame，选择最久未被访问的</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 先从历史队列(hist_)中选择可驱逐的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!hist_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : hist_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mp_[it]) &#123; <span class="comment">// 判断是否可以驱逐</span></span><br><span class="line">        <span class="type">frame_id_t</span> num = it;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置frame的访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        hist_.<span class="built_in">remove</span>(num); <span class="comment">// 从历史队列中移除</span></span><br><span class="line">        *frame_id = num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果历史队列中没有可驱逐的frame，则从当前缓存队列(cur_)中选择</span></span><br><span class="line">  <span class="keyword">if</span> (!cur_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : cur_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mp_[it]) &#123; <span class="comment">// 判断是否可以驱逐</span></span><br><span class="line">        <span class="type">frame_id_t</span> num = it;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置frame的访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        cur_.<span class="built_in">remove</span>(num); <span class="comment">// 从当前缓存队列中移除</span></span><br><span class="line">        *frame_id = num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有可驱逐的frame，则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一个frame的访问，更新其在LRU-K队列中的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 忽略无效的frame_id</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果frame是第一次被访问或者计数为0</span></span><br><span class="line">  <span class="keyword">if</span> (frame_num_.<span class="built_in">find</span>(frame_id) == frame_num_.<span class="built_in">end</span>() || frame_num_[frame_id] == <span class="number">0</span>) &#123;</span><br><span class="line">    frame_num_[frame_id]++; <span class="comment">// 增加访问计数</span></span><br><span class="line">    <span class="keyword">if</span> (frame_num_[frame_id] &gt;= k_) &#123;</span><br><span class="line">      cur_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 如果访问次数达到k，加入当前缓存队列</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hist_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 否则加入历史队列</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果frame已经被访问过</span></span><br><span class="line">    frame_num_[frame_id]++; <span class="comment">// 增加访问计数</span></span><br><span class="line">    <span class="keyword">if</span> (frame_num_[frame_id] &lt; k_) &#123;</span><br><span class="line">      <span class="comment">// 如果还未达到k次访问，保持在历史队列中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame_num_[frame_id] == k_) &#123;</span><br><span class="line">      hist_.<span class="built_in">remove</span>(frame_id); <span class="comment">// 从历史队列中移除</span></span><br><span class="line">      cur_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 加入当前缓存队列</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur_.<span class="built_in">remove</span>(frame_id); <span class="comment">// 从当前缓存队列中移除</span></span><br><span class="line">      cur_.<span class="built_in">push_back</span>(frame_id); <span class="comment">// 再次加入当前缓存队列，保持LRU顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个frame是否可以被驱逐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 忽略无效的frame_id</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  mp_[frame_id] = set_evictable; <span class="comment">// 设置可驱逐标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从替换器中移除一个frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 忽略无效的frame_id</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从历史队列中移除</span></span><br><span class="line">  <span class="keyword">if</span> (!hist_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : hist_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it == frame_id) &#123;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hist_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从当前缓存队列中移除</span></span><br><span class="line">  <span class="keyword">if</span> (!cur_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : cur_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it == frame_id) &#123;</span><br><span class="line">        frame_num_[it] = <span class="number">0</span>; <span class="comment">// 重置访问计数</span></span><br><span class="line">        mp_[it] = <span class="literal">false</span>; <span class="comment">// 标记为不可驱逐</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前可驱逐的frame数量</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Size</span><span class="params">()</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 统计历史队列中的可驱逐frame数量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : hist_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_[i]) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 统计当前缓存队列中的可驱逐frame数量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : cur_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_[i]) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例场景</strong></p><p>假设 <code>k=2</code>，即我们在使用 LRU-2 算法，<code>num_frames=3</code>，即缓存最多可以存储3个页面。</p><ol><li><strong>访问顺序</strong>：<code>A, B, C, A, B, D, A</code></li><li><strong>过程说明</strong>：<ul><li>初始状态：缓存为空。</li><li><strong>访问A</strong>：将 <code>A</code> 添加到历史队列 <code>hist_</code>，因为 <code>A</code> 的访问次数为1。</li><li><strong>访问B</strong>：将 <code>B</code> 添加到历史队列 <code>hist_</code>，因为 <code>B</code> 的访问次数为1。</li><li><strong>访问C</strong>：将 <code>C</code> 添加到历史队列 <code>hist_</code>，因为 <code>C</code> 的访问次数为1。</li><li><strong>再次访问A</strong>：<code>A</code> 的访问次数增加到2，将 <code>A</code> 从历史队列 <code>hist_</code> 移动到当前缓存队列 <code>cur_</code>。</li><li><strong>再次访问B</strong>：<code>B</code> 的访问次数增加到2，将 <code>B</code> 从历史队列 <code>hist_</code> 移动到当前缓存队列 <code>cur_</code>。</li><li><strong>访问D</strong>：此时缓存已满（<code>cur_</code> 中有 <code>A</code> 和 <code>B</code>），需要驱逐一个页面。算法会先检查历史队列中的页面，发现 <code>C</code> 只被访问过1次，可以被驱逐。<code>C</code> 被移除，将 <code>D</code> 加入历史队列 <code>hist_</code>。</li><li><strong>再次访问A</strong>：<code>A</code> 的访问次数增加到3，仍然保持在当前缓存队列 <code>cur_</code> 中。</li></ul></li><li><strong>最终状态</strong>：<ul><li>历史队列 <code>hist_</code>：<code>D</code></li><li>当前缓存队列 <code>cur_</code>：<code>A, B</code></li></ul></li></ol><p>LRU-K 算法有效地平衡了频繁访问页面和较久未访问页面之间的替换策略，使得那些在较长时间内多次被访问的页面能够留在缓存中，而那些仅在短时间内频繁被访问的页面则容易被淘汰。</p><p><strong>总结：</strong></p><ul><li>历史队列 (hist_) 存储那些访问次数未达到 K 次的缓存块。</li><li>当前队列 (cur_) 存储那些访问次数达到 K 次的缓存块。</li><li>当缓存块的访问次数达到 K 次时，会从历史队列移动到当前队列。</li><li>当缓存空间不足时，优先淘汰历史队列中的缓存块，如果历史队列为空，则淘汰当前队列中的缓存块。</li></ul><p><strong>数据库中的Buffer pool Manage选用什么算法比较好呢？</strong></p><p>LRU-K</p><ul><li>LRU的考量：</li></ul><p>存在两个用户，一个用户需要进行一次扫描操作，而另一个用户进行正常的随机访问操作。扫描操作其实很简单，例如遍历一张数据表等，但其带来的后果却是灾难的。扫描操作会快速引用大量页面，这对于传统 <code>LRU</code> 而言将迅速驱逐所有随机访问页面，但是扫描操作引用的页面几乎在之后很长一段时间内不再被引用，而随机访问页面才是真正需要被缓存的，这几乎使传统的 <code>LRU</code> 失效。对于这个问题 <code>LRU-2</code> 就能很好的解决。</p><ul><li><p>LFU的考量：</p></li><li><p><code>LFU</code> 只考虑频率，而实际最近访问时间依然是一个重要因素。</p></li><li><p><code>LFU</code> 过渡考虑频率，带来的开销巨大，它是这么做的：考虑最近 T 秒内，页面访问的次数。这将记录最近 T 分钟内的所有访问，如果页面访问次数非常频繁，带来的开销就是极其巨大的。</p></li></ul><p><a href="https://blog.csdn.net/Sihang_Xie/article/details/128919122">【Caffeine缓存】Caffeine缓存淘汰算法Window-TinyLFU详解</a></p>]]></content>
    
    
    <summary type="html">LRU...算法</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络编程常见问题</title>
    <link href="https://penge666.github.io/posts/f132b19e.html"/>
    <id>https://penge666.github.io/posts/f132b19e.html</id>
    <published>2024-08-02T07:38:28.000Z</published>
    <updated>2024-09-17T11:46:25.166Z</updated>
    
    <content type="html"><![CDATA[<p>他强任他强，清风拂山岗；他横由他横，明月照大江。</p><h2 id="FAQ">FAQ</h2><h3 id="短链接和长链接对比">短链接和长链接对比</h3><p><strong>短连接</strong></p><p><strong>优点</strong>：</p><ul><li><strong>简单实现</strong>：每次请求都是独立的连接，不需要管理复杂的连接状态。</li><li><strong>负载均衡</strong>：短连接天然适合负载均衡，每次请求都可以随机分配给不同的服务器。</li><li><strong>避免脏数据</strong>：连接短暂，数据不会残留在连接中，减少了处理脏数据的复杂性。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>效率较低</strong>：建立和关闭连接需要时间，通常在 50µs 到 200µs 之间，频繁的连接操作增加了开销。</li><li><strong>产生大量 <code>TIME_WAIT</code></strong>：每次关闭连接后，TCP 连接进入 <code>TIME_WAIT</code> 状态，占用系统资源，可能导致端口耗尽。</li><li><strong>资源消耗</strong>：频繁的连接建立和断开会消耗更多的系统资源，尤其是在高并发场景下，可能导致性能瓶颈。</li></ul><p><strong>处理措施</strong>：</p><ol><li><strong>优化连接建立速度</strong>：<ul><li>调整 TCP 参数，如减少握手时间，可以通过调整 <code>TCP_QUICKACK</code> 和 <code>TCP_NODELAY</code> 来减少延迟。</li><li>使用连接池技术，即使使用短连接，也可以在客户端维护一组预先建立的连接，用于快速复用。</li></ul></li><li><strong>管理 <code>TIME_WAIT</code> 状态</strong>：<ul><li><strong>调整端口范围</strong>：通过修改 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 增加可用端口范围。</li><li><strong>缩短 <code>TIME_WAIT</code> 时长</strong>：通过设置 <code>tcp_tw_recycle</code> 和 <code>tcp_tw_reuse</code> 参数加速 <code>TIME_WAIT</code> 状态的回收（注意，这些选项在某些情况下会导致 NAT 问题，因此要谨慎使用）。</li><li><strong>使用 SO_REUSEADDR</strong>：允许端口在 <code>TIME_WAIT</code> 状态下被重新使用。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>采用硬件或软件负载均衡器（如 Nginx、HAProxy）来分发短连接请求，确保各服务器的负载均衡。</li></ul></li></ol><p><strong>长连接</strong></p><p><strong>优点</strong>：</p><ul><li><strong>高效</strong>：避免了频繁的连接建立和关闭，减少了时间和资源消耗。</li><li><strong>适合高并发</strong>：在高并发场景下，可以承载更多的请求，减少了系统的开销。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>脏数据处理</strong>：长连接中，如果出现异常或逻辑错误，可能会有不需要的数据残留在连接中。</li><li><strong>连接管理复杂</strong>：需要处理连接的生命周期、异常恢复、连接池管理等问题。</li><li><strong>延迟问题</strong>：长连接可能会出现数据传输延迟或连接长时间无响应的问题。</li></ul><p><strong>处理措施</strong>：</p><ol><li><strong>脏数据处理</strong>：<ul><li><strong>主动检测脏数据</strong>：在每次发送请求前，可以使用 <code>recv()</code> 检查连接中是否有残留的数据。如果检测到脏数据（例如意外的响应数据），可以选择直接关闭连接。</li><li><strong>安全断开连接</strong>：当发现脏数据时，最简单的方式是直接关闭连接并重新建立连接，而不是尝试清除脏数据。</li><li><strong>逻辑处理</strong>：如果逻辑允许，可以通过读取到 <code>EAGAIN</code> 或类似信号来清除连接中的残留数据，但这种方法依赖于程序逻辑，会增加代码复杂度。</li></ul></li><li><strong>连接池管理</strong>：<ul><li><strong>使用连接池</strong>：通过连接池管理长连接，可以减少连接建立的开销，并在多个线程之间共享连接。连接池还可以优化资源分配，使得每个线程能够高效地获取和释放连接。</li><li><strong>连接池的规模管理</strong>：通过压力测试确定合理的连接池大小，避免过度占用资源。</li></ul></li><li><strong>并发处理</strong>：<ul><li><strong>线程池管理</strong>：在长连接的情况下，建议使用线程池来管理连接的并发处理。通过异步队列和线程池，可以有效地调度请求，避免线程数过多导致的上下文切换开销。</li><li><strong>异步 I/O 模型</strong>：在高并发场景下，可以使用异步 I/O 模型如 <code>epoll</code>、<code>kqueue</code> 等，减少对线程数量的依赖，提高系统的并发处理能力。</li></ul></li><li><strong>延迟问题</strong>：<ul><li><strong>心跳检测</strong>：在长连接中，定期发送心跳包检测连接的存活状态。如果发现连接不可用，及时关闭并重新建立连接。</li><li><strong>超时管理</strong>：设置合理的读写超时时间，避免长时间无响应导致的资源浪费。</li><li><strong>拥塞控制</strong>：监控网络的拥塞状态，并根据实际情况调整 TCP 的参数，以减少延迟。</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>短连接</strong> 适合简单的系统设计，尤其是在请求频率低或负载均衡复杂的场景下。但是它的效率较低，会产生大量的 <code>TIME_WAIT</code> 状态，需要有效地管理系统资源。</li><li><strong>长连接</strong> 适合高并发、高效率的场景，减少了连接建立和关闭的开销。但是它需要更复杂的连接管理策略，包括处理脏数据、管理连接池、应对延迟等问题。</li></ul><h3 id="读和写操作">读和写操作</h3><blockquote><p><strong>读操作 (<code>read</code>/<code>recv</code>)</strong></p></blockquote><p><strong>1. 读操作的本质</strong></p><ul><li><strong>缓冲区复制</strong>：<code>read</code> 和 <code>recv</code> 操作的本质是将数据从内核缓冲区复制到用户指定的缓冲区。这意味着数据在到达用户程序之前已经被操作系统接收并存储在内核缓冲区中。</li></ul><p><strong>2. 阻塞模式下的读操作</strong></p><ul><li><p><strong>行为</strong>：在阻塞模式下，如果内核缓冲区中没有数据，<code>read</code> 或 <code>recv</code> 会阻塞等待，直到数据到达并复制到用户缓冲区中。</p></li><li><p><strong>返回条件</strong>：当内核缓冲区有数据时，<code>read</code> 或 <code>recv</code> 会将数据复制到用户缓冲区并立即返回，即使复制的数据量小于请求的长度。</p></li><li><p><strong>循环读取</strong>：由于 <code>read</code> 和 <code>recv</code> 并不保证一次调用就能读取到指定长度的数据，因此在读取数据时通常需要使用循环读取的方式，直到读取到所需的完整数据或达到终止条件。</p><p><strong>示例代码：循环读取</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> total_bytes = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> bytes_read;</span><br><span class="line"><span class="type">size_t</span> to_read = buffer_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (total_bytes &lt; buffer_size) &#123;</span><br><span class="line">    bytes_read = <span class="built_in">read</span>(sockfd, buffer + total_bytes, to_read);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error or EOF</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    total_bytes += bytes_read;</span><br><span class="line">    to_read -= bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. 非阻塞模式下的读操作</strong></p><ul><li><p><strong>行为</strong>：在非阻塞模式下，如果没有数据可读，<code>read</code> 或 <code>recv</code> 会立即返回，而不是等待数据的到来。如果有数据，它们会读取尽可能多的数据并返回。</p></li><li><p><strong>返回值</strong>：如果没有数据，<code>read</code> 或 <code>recv</code> 会返回 <code>-1</code>，并将 <code>errno</code> 设置为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p></li><li><p><strong>循环读取</strong>：由于非阻塞模式下 <code>read</code> 或 <code>recv</code> 可能只读取到部分或没有数据，因此在需要读取完整的数据时，也必须采用循环读取。</p><p><strong>示例代码：非阻塞读取</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    bytes_read = <span class="built_in">read</span>(sockfd, buffer, buffer_size);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Process the data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123;</span><br><span class="line">        <span class="comment">// No data available, continue or sleep</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Handle error or EOF</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>写操作</strong></p></blockquote><p><strong>阻塞模式下的写操作：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_file</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">char</span> *file_buffer, <span class="type">size_t</span> file_size)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> total_bytes_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total_bytes_sent &lt; file_size) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> bytes_sent = write(sockfd, file_buffer + total_bytes_sent, file_size - total_bytes_sent);</span><br><span class="line">        <span class="keyword">if</span> (bytes_sent &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            perror(<span class="string">&quot;Error writing to socket&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total_bytes_sent += bytes_sent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非阻塞模式下的写操作：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_file_nonblocking</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">char</span> *file_buffer, <span class="type">size_t</span> file_size)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> total_bytes_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total_bytes_sent &lt; file_size) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> bytes_sent = write(sockfd, file_buffer + total_bytes_sent, file_size - total_bytes_sent);</span><br><span class="line">        <span class="keyword">if</span> (bytes_sent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            total_bytes_sent += bytes_sent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_sent == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123;</span><br><span class="line">            <span class="comment">// 网络拥塞，稍后重试</span></span><br><span class="line">            usleep(<span class="number">1000</span>);  <span class="comment">// 暂停一段时间再重试</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            perror(<span class="string">&quot;Error writing to socket&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么网络程序会没有任何预兆的就退出了">为什么网络程序会没有任何预兆的就退出了</h3><p>网络程序在没有预兆的情况下退出，通常是因为遇到了某些特定的情况，导致程序收到了某个信号并执行了默认的处理行为。其中，一个常见的情况就是 <code>SIGPIPE</code> 信号。</p><p><strong><code>SIGPIPE</code> 信号</strong></p><p><code>SIGPIPE</code> 信号是在以下情况下产生的：</p><ul><li>当一个进程向一个已经关闭读取端的套接字（socket）写入数据时，内核会向该进程发送 <code>SIGPIPE</code> 信号。</li><li>这种情况通常发生在网络通信中，当一方已经关闭连接，而另一方仍然尝试写入数据时。</li></ul><p><strong>默认行为</strong></p><p>默认情况下，<code>SIGPIPE</code> 信号的处理行为是终止进程。这意味着，如果程序没有显式地处理这个信号，当它收到 <code>SIGPIPE</code> 信号时，程序会立即退出。</p><p>忽略 <code>SIGPIPE</code> 信号</p><p>为了避免程序因为 <code>SIGPIPE</code> 信号而意外退出，可以在程序启动时显式地忽略这个信号。这可以通过调用 <code>signal</code> 函数来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略 SIGPIPE 信号</span></span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序的其他初始化代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主程序逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>signal(SIGPIPE, SIG_IGN)</code> 告诉系统忽略 <code>SIGPIPE</code> 信号。这样，即使程序在写入一个已经关闭读取端的套接字时，也不会因为收到 <code>SIGPIPE</code> 信号而退出。</p><p>处理 <code>SIGPIPE</code> 信号的其他方法</p><p>除了忽略 <code>SIGPIPE</code> 信号，还可以通过其他方式来处理这种情况：</p><ol><li><strong>检查返回值</strong>：<ul><li>在写入操作后检查返回值，如果返回 <code>-1</code> 并且 <code>errno</code> 设置为 <code>EPIPE</code>，则表示发生了 <code>SIGPIPE</code> 错误。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> n = write(fd, buffer, length);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EPIPE) &#123;</span><br><span class="line">        <span class="comment">// 处理 EPIPE 错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理其他错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>使用 <code>send</code> 函数的 <code>MSG_NOSIGNAL</code> 标志</strong>：<ul><li>在调用 <code>send</code> 函数时，可以使用 <code>MSG_NOSIGNAL</code> 标志来避免产生 <code>SIGPIPE</code> 信号。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> n = send(fd, buffer, length, MSG_NOSIGNAL);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EPIPE) &#123;</span><br><span class="line">        <span class="comment">// 处理 EPIPE 错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理其他错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>网络程序在没有预兆的情况下退出，通常是因为遇到了 <code>SIGPIPE</code> 信号。为了避免这种情况，可以在程序启动时忽略 <code>SIGPIPE</code> 信号，或者在写入操作后检查返回值来处理 <code>EPIPE</code> 错误。这样可以确保程序在遇到 <code>SIGPIPE</code> 错误时不会意外退出，而是能够进行适当的错误处理。</p><h3 id="write出去的数据-read的时候知道长度吗">write出去的数据, read的时候知道长度吗?</h3><p><strong>TCP 数据传输的特点</strong></p><ol><li><strong><code>write</code> 操作的长度不一定等于一次性发送的数据量</strong>：<ul><li>虽然在应用层你可能一次性调用了 <code>write(fd, buf, n)</code>，但是底层的 TCP 可能不会在一次操作中将这 <code>n</code> 字节的数据全部发送出去。特别是在网络拥塞或缓冲区不够的情况下，可能需要多次 <code>write</code> 才能将所有数据发送完毕。</li></ul></li><li><strong>接收端无法直接知道发送端每次 <code>write</code> 的数据长度</strong>：<ul><li>TCP 是一种流式协议，这意味着接收端在调用 <code>read(fd, buf, n)</code> 时，可能会接收到一部分、全部或多次 <code>write</code> 发送的数据。接收端无法直接通过 <code>read</code> 的返回值确定发送端在一次 <code>write</code> 中究竟发送了多少字节。</li></ul></li><li><strong>TCP 数据在网络中可能被分片</strong>：<ul><li>即使发送端一次性 <code>write</code> 了大块数据，这些数据在传输过程中可能被拆成多个 TCP 包。接收端在调用 <code>read</code> 时，可能会读取到部分的 TCP 包或者多个包拼接在一起的数据。</li></ul></li><li><strong>TCP 将接收到的数据放入缓冲区后再供 <code>read</code> 使用</strong>：<ul><li>TCP 协议会将接收到的数据放入内核缓冲区，当应用层调用 <code>read</code> 时，就会从这个缓冲区中读取数据。因此，接收端的 <code>read</code> 操作与发送端的 <code>write</code> 操作在时间上并不需要同步。</li></ul></li></ol><p><strong>如何确保正确的数据交互</strong></p><p>由于上述 TCP 的特性，简单地依赖 <code>read</code> 的返回值来判断发送端传输的数据长度是不可靠的。下面是一些常用的策略来确保正确的数据交互：</p><p><strong>1. 约定固定长度的数据包</strong></p><ul><li><strong>概念</strong>：双方约定每次传递的数据包长度是固定的，比如每次传输的数据包固定为 1024 字节。</li><li>示例：假设双方约定每次发送 1024 字节的数据包，那么接收端每次调用read时，也读取 1024 字节。<ul><li>优点：实现简单，不需要额外的逻辑来处理数据长度问题。</li><li>缺点：不灵活，对于大小不一的数据包，这种方式会导致浪费带宽（填充数据）或无法灵活处理数据。</li></ul></li></ul><p><strong>2. 使用特殊的结束符</strong></p><ul><li><strong>概念</strong>：在数据的结尾使用一个特殊的结束符来标识数据包的结束。</li><li>示例：在 HTTP 协议中，头部结束是由\r\n\r\标识的。接收端可以通过查找这个结束符来确定数据包的结束位置。<ul><li>优点：适用于长度不定的数据包，灵活且常用于文本协议。</li><li>缺点：需要确保数据中不会误包含结束符，否则会导致解析错误。</li></ul></li></ul><p><strong>3. 定长头部 + 变长数据</strong></p><ul><li><p><strong>概念</strong>：数据包前面有一个固定长度的头部，头部包含数据的长度信息，接收端先读取头部，再根据头部信息读取实际数据。</p></li><li><p>示例</p><p>：在很多协议中，前 4 字节可能用于表示接下来数据的长度。接收端首先读取这 4 字节，然后根据这个长度信息读取后续的数据。</p><ul><li>优点：灵活且适用于各种数据长度，特别是大数据传输。</li><li>缺点：需要处理两次 <code>read</code> 操作，先读头部，再读数据。</li></ul></li></ul><h3 id="如何查看和观察句柄泄露问题">如何查看和观察句柄泄露问题</h3><p><strong>句柄泄漏</strong> 指的是程序在运行时打开了文件或套接字等资源，但没有在不需要时关闭它们，导致文件描述符表中的项逐渐耗尽。如果不解决这个问题，程序最终会无法打开新的文件或套接字，导致崩溃或其他异常行为。</p><p><strong>1. 通过 <code>/proc</code> 文件系统来观察</strong></p><p>Linux 提供了 <code>/proc</code> 文件系统，它是一个虚拟文件系统，用于访问内核和进程的信息。每个进程在 <code>/proc</code> 下都有一个对应的目录，命名为进程的 PID（进程 ID）。</p><ul><li><p><strong>查看进程的文件描述符</strong>：</p><ul><li>你可以通过查看 <code>/proc/&lt;PID&gt;/fd</code> 目录，来观察一个进程当前打开的所有文件描述符。这个目录列出了所有打开的文件描述符，每个文件描述符对应一个符号链接，指向实际打开的文件或套接字。</li></ul></li><li><p><strong>实际操作</strong>：</p><ul><li><p>假设你有一个进程的 PID 是 1234，你可以通过以下命令查看它的文件描述符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /proc/1234/fd</span><br></pre></td></tr></table></figure></li><li><p>这将列出进程 1234 当前打开的所有文件描述符。如果你发现这个目录中的文件描述符数量不断增加，或者在程序应该关闭文件描述符的地方没有减少，这可能表明程序有句柄泄漏问题。</p></li></ul></li></ul><p><strong>2. 使用 <code>valgrind</code> 检查句柄泄漏</strong></p><p><code>valgrind</code> 是一个强大的工具，主要用于检测内存泄漏和内存管理问题。但是，它也可以用于检测文件描述符泄漏。</p><ul><li><p><strong><code>valgrind</code> 的工作原理</strong>：</p><ul><li><code>valgrind</code> 可以跟踪程序运行过程中打开的文件描述符，并在程序退出时报告哪些文件描述符在程序结束时仍然未关闭。</li></ul></li><li><p><strong>启用文件描述符跟踪</strong>：</p><ul><li>你可以使用 <code>valgrind</code> 的 <code>--track-fds=yes</code> 参数来启用文件描述符的跟踪。当程序退出时，<code>valgrind</code> 会报告哪些文件描述符仍然打开，以及它们是在哪里被打开的。</li></ul></li><li><p><strong>实际操作</strong>：</p><ul><li><p>假设你有一个程序example，你可以使用以下命令来运行它，并检查文件描述符泄漏：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --track-fds=<span class="built_in">yes</span> ./example</span><br></pre></td></tr></table></figure></li><li><p>如果程序有未关闭的文件描述符，<code>valgrind</code> 会在输出中显示这些文件描述符的详细信息，包括它们是在哪个文件的哪一行被打开的，以及具体的调用栈。</p></li></ul></li></ul><h3 id="为什么socket写错误-但用recv检查依然成功">为什么socket写错误,但用recv检查依然成功?</h3><p><strong>1. TCP 是双向通信的</strong></p><p>TCP 是全双工的协议，这意味着发送和接收是相互独立的。即使在发送数据时（通过 <code>write</code> 或 <code>send</code>），出现了错误（如发送超时或网络问题），接收数据（通过 <code>recv</code>）的通道可能依然是正常的。换句话说，发送方向出现的问题不一定会立即影响接收方向的状态。</p><p><strong>2. <code>recv</code> 的检查方式</strong></p><p>在非阻塞模式下，如果网络中没有数据到达，<code>recv</code> 返回 <code>-1</code> 并设置 <code>errno</code> 为 <code>EAGAIN</code>，这表示当前没有数据可读，但连接仍然是正常的。这种检查方式的假设前提是：在请求-响应模型中，客户端在发起新请求前，网络中不应该有上一次请求的残留数据；如果有数据到达，<code>recv</code> 应该能够读取到正确的数据。</p><p><strong>3. 服务端的响应行为</strong></p><p>在请求-响应模式中，客户端发送请求后，接收服务端的响应。如果 <code>recv</code> 成功读取到数据（<code>ret &gt; 0</code>），则说明连接是正常的，并且服务端正常响应了请求。</p><p><strong>4. 写操作失败的原因</strong></p><p>写操作失败的原因可能是多种多样的，比如网络拥堵、数据量过大、或者远程服务器出现问题。这些问题不一定意味着连接已经断开。因此，即使写操作失败，<code>recv</code> 仍然可能在短时间内读取到之前发送的请求的响应。</p><h3 id="为什么接收端失败，但客户端仍然是write成功">为什么接收端失败，但客户端仍然是write成功</h3><p>这个是正常现象，write数据成功不能表示数据已经被接收端接收导致，只能表示数据已经被复制到系统底层的缓冲(不一定发出),　这个时候的网络异常都是会造成接收端接收失败的．</p><h3 id="长连接的情况下出现了不同程度的延时">长连接的情况下出现了不同程度的延时</h3><p><strong>长连接与短连接的区别</strong></p><ul><li><strong>长连接</strong>：在长连接中，客户端和服务器之间的连接在多个请求和响应之间保持打开状态。这种方式减少了频繁建立和关闭连接的开销，适用于需要多次交互的场景。</li><li><strong>短连接</strong>：每次请求-响应都独立进行，完成后立即关闭连接。短连接虽然简单，但在频繁请求的场景下，连接的建立和关闭会增加开销。</li></ul><p><strong>问题描述：长连接中的延时</strong></p><p>在长连接的情况下，可能会出现一种现象：发送一个小的数据包后，虽然 <code>write</code> 操作成功，但接收端却需要等待一段时间（例如 40ms）才能接收到数据。而当改用短连接时，这种延时消失了。这种延时可能由以下几个原因导致：</p><p><strong>1. Nagle 算法与 TCP_NODELAY</strong></p><p><strong>Nagle 算法的作用</strong></p><ul><li><strong>Nagle 算法</strong>：Nagle 算法是一种优化传输的小数据包的算法。它将多个小数据包合并成一个更大的数据包，以减少网络中的包数量，避免网络拥塞。<ul><li><strong>优点</strong>：在一些场景下，减少了网络中小包的数量，提高了网络利用率。</li><li><strong>缺点</strong>：对于一些实时性要求高的应用（如游戏、即时通讯），Nagle 算法会导致延迟，因为它可能会等待更多小包组合成一个大包再发送。</li></ul></li></ul><p><strong>TCP_NODELAY 选项</strong></p><ul><li><p><strong>TCP_NODELAY</strong>：禁用 Nagle 算法的选项。设置了 <code>TCP_NODELAY</code> 后，数据会立即发送，不会等待更多数据包的到来。</p><ul><li><p><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;flag, <span class="keyword">sizeof</span>(<span class="built_in">int</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：在长连接中，如果发送的数据包非常小，启用 <code>TCP_NODELAY</code> 可以避免延时，数据会立即发送。</p></li></ul></li></ul><p><strong>为什么需要 TCP_NODELAY？</strong></p><p>在长连接中，如果发送小数据包时未设置 <code>TCP_NODELAY</code>，Nagle 算法可能会导致数据包的发送延时，典型的就是 40ms。这是因为 Nagle 算法会等待更多的数据包，以便合并成一个更大的包再发送，这对于交互性强的应用（如即时消息）是不利的。</p><p><strong>2. TCP_CORK 和 TCP_QUICKACK</strong></p><p><strong>TCP_CORK</strong></p><ul><li><p><strong>TCP_CORK</strong>：一种更加精细控制数据发送的选项。启用 <code>TCP_CORK</code> 后，数据不会立即发送，而是会等到应用程序明确关闭 <code>TCP_CORK</code> 或数据达到一定大小时才发送。通常用于需要发送多个小数据包并希望它们被合并成一个大包的场景。</p><ul><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_CORK, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// write data ...</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_CORK, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：在发送多个小数据包时，可以将它们合并发送，减少网络延时。</p></li></ul></li></ul><p><strong>TCP_QUICKACK</strong></p><ul><li><p>在默认情况下，TCP 协议栈可能会延迟发送确认（ACK）包，以等待更多的数据包到达，从而可以一起确认，这种机制称为延迟确认（Delayed ACK）。延迟确认可以减少网络中的 ACK 包数量，但会增加数据传输的延迟。</p></li><li><p><strong>TCP_QUICKACK</strong>：控制接收方何时发送 ACK（确认）包。启用 <code>TCP_QUICKACK</code> 可以使接收方立即发送 ACK，而不是等待默认的延时（通常是 40ms）。</p><ul><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_QUICKACK, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：减少发送端等待 ACK 的时间，从而减少延时。</p></li></ul></li></ul><p><strong>3. 延时的原因分析与解决办法</strong></p><p><strong>长连接中的 40ms 延时</strong></p><ul><li>如果在长连接中出现固定的 40ms 延时，通常是由于 Nagle 算法未被禁用（即未设置 <code>TCP_NODELAY</code>）。在没有设置 <code>TCP_NODELAY</code> 的情况下，Nagle 算法会等待更多数据包来组合成一个大包发送，这会导致延时。</li><li>如果设置了 <code>TCP_NODELAY</code> 但仍然有延时，可能是由于 TCP 协议栈中的拥塞控制机制（如拥塞窗口控制），导致数据包发送延迟。</li></ul><p><strong>解决办法</strong></p><ol><li><strong>设置 <code>TCP_NODELAY</code></strong>：在长连接中，启用 <code>TCP_NODELAY</code>，禁用 Nagle 算法，确保小数据包能够立即发送，减少延时。</li><li><strong>使用 <code>TCP_CORK</code> 控制数据包发送</strong>：在需要发送多个小数据包时，启用 <code>TCP_CORK</code> 以合并数据包，发送完毕后关闭 <code>TCP_CORK</code>，确保数据立即发送。</li><li><strong>设置 <code>TCP_QUICKACK</code></strong>：在服务端启用 <code>TCP_QUICKACK</code>，减少 ACK 的延迟发送，确保发送方尽快收到 ACK，从而减少整体延时。</li><li><strong>协议栈和内核调整</strong>：如果上述方法仍然无法完全消除延时，可能需要通过调整 Linux 内核参数或使用定制的内核版本来优化 TCP 协议栈的行为。</li></ol><p><strong>实际例子说明</strong></p><p>假设你开发了一个即时通讯应用，客户端和服务端之间使用长连接来保持通信。你发现客户端发送小消息时，服务端收到消息的时间总是比预期延迟了大约 40ms。</p><p><strong>步骤 1：设置 <code>TCP_NODELAY</code></strong></p><p>为了避免 Nagle 算法引入的延时，你在客户端和服务端都设置了 <code>TCP_NODELAY</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p><strong>步骤 2：使用 <code>TCP_CORK</code> 合并小数据包</strong></p><p>如果你需要在一次通信中发送多个小数据包，希望它们作为一个大包发送，你可以使用 <code>TCP_CORK</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_CORK, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// send multiple small messages...</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_CORK, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 取消TCP_CORK，立即发送数据</span></span><br></pre></td></tr></table></figure><p><strong>步骤 3：启用 <code>TCP_QUICKACK</code></strong></p><p>为了确保服务端能够尽快发送 ACK，减少客户端等待时间，你在服务端设置了 <code>TCP_QUICKACK</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_QUICKACK, &amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><h3 id="TIME-WAIT有什么样的影响">TIME_WAIT有什么样的影响?</h3><p>在 TCP 协议中，当一个连接的任意一方（通常是主动关闭连接的一方）关闭连接后，连接的端口将进入 <code>TIME_WAIT</code> 状态。这个状态的主要目的是确保所有的传输数据包都能被正确处理，防止旧连接的数据包干扰新连接。</p><ul><li><strong><code>TIME_WAIT</code> 状态</strong>：这是 TCP 连接在关闭后进入的一个等待状态，目的是确保连接的最后一个 ACK（确认）包能够安全发送并被对方接收，以及防止延迟的数据包影响后续的连接。</li></ul><p><strong><code>TIME_WAIT</code> 的影响</strong></p><p><strong>1. 端口占用问题</strong></p><ul><li><strong>主动关闭连接的端口进入 <code>TIME_WAIT</code></strong>：当一个端口进入 <code>TIME_WAIT</code> 状态时，它会保持一段时间（通常是 60 秒，在一些系统中是 2 * MSL，MSL 是最大报文生存时间）。在这个时间段内，端口不会立即释放。</li><li><strong>端口被占用，导致端口耗尽</strong>：如果有大量的短连接（即连接建立后很快关闭），并且这些连接都是由客户端主动关闭的，那么这些连接的端口将会进入 <code>TIME_WAIT</code> 状态。由于端口在 <code>TIME_WAIT</code> 状态下无法立即重新使用，频繁的短连接会导致系统的可用端口耗尽。这种情况下，新连接将无法建立，并且会出现 <code>Cannot assign requested address</code> 错误。<ul><li><strong>示例</strong>：假设系统的可用端口范围是 <code>32768</code> 到 <code>61000</code>，总共有不到 3 万个端口。如果每秒有 500 个短连接请求，那么在一分钟内就会有 3 万个端口进入 <code>TIME_WAIT</code> 状态，这将导致端口耗尽，新的连接无法建立。</li></ul></li></ul><p><strong>2. 解决方法</strong></p><ul><li><p><strong>增大可用端口范围</strong>：可以通过修改 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 来增大系统分配给客户端的本地端口范围，从而减少端口耗尽的可能性。</p><ul><li><p>示例：将端口范围从默认的32768-61000增加到1024-65535，可以通过以下命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1024 65535&quot;</span> &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>设置 <code>SO_LINGER</code> 选项</strong>：通过 <code>SO_LINGER</code> 选项可以控制套接字关闭时的行为。如果设置了 <code>SO_LINGER</code>，可以使套接字在关闭时立即释放资源，而不进入 <code>TIME_WAIT</code> 状态。不过，这种做法在高负载情况下可能会导致数据包丢失。</p><ul><li><p>示例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> linger linger_option = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">// 开启SO_LINGER，立即关闭连接</span></span><br><span class="line">setsockopt(sock, SOL_SOCKET, SO_LINGER, &amp;linger_option, <span class="keyword">sizeof</span>(linger_option));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>启用 <code>tcp_tw_reuse</code></strong>：这个内核参数允许 TCP 端口在 <code>TIME_WAIT</code> 状态下被复用。启用 <code>tcp_tw_reuse</code> 后，客户端可以在新连接时复用那些处于 <code>TIME_WAIT</code> 状态的端口，从而避免端口耗尽。</p><ul><li><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>启用 <code>tcp_tw_recycle</code></strong>：这个参数可以动态调整 <code>TIME_WAIT</code> 状态的持续时间，允许端口更快地从 <code>TIME_WAIT</code> 状态中释放。不过，这个选项在 NAT 环境中可能会导致连接问题，因此使用时需谨慎。</p><ul><li><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>3. 服务器端的 <code>TIME_WAIT</code> 状态</strong></p><ul><li><p><strong>服务器端通常不会出现端口耗尽问题</strong>：服务器端通常使用固定的端口来监听连接请求，所有的连接都是通过这个固定的端口建立的，因此不会因为 <code>TIME_WAIT</code> 状态而导致端口耗尽。然而，大量的 <code>TIME_WAIT</code> 状态可能会占用系统资源（如内存）。</p></li><li><p><strong><code>TIME_WAIT</code> 槽位溢出</strong>：在高负载情况下，服务器端可能会出现 “TCP: time wait bucket table overflow” 的情况。这意味着系统中用于存储 <code>TIME_WAIT</code> 状态的内存槽位已满，系统将直接跳过 <code>TIME_WAIT</code> 状态，发送 RST（重置）包来关闭连接。</p><ul><li><p><strong>示例</strong>：<br>在服务器日志中看到类似以下的警告：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP: <span class="selector-tag">time</span> wait bucket <span class="selector-tag">table</span> <span class="attribute">overflow</span></span><br></pre></td></tr></table></figure><p>这表示系统正在丢弃一些 <code>TIME_WAIT</code> 状态的连接，但一般情况下，这不会对系统造成太大的负面影响。</p></li></ul></li></ul><p><strong>4. 其他应对措施</strong></p><ul><li><strong>优化应用程序</strong>：减少短连接的数量，尽量使用长连接或连接池来管理连接，减少因为频繁关闭连接而导致的 <code>TIME_WAIT</code> 状态。</li><li><strong>分析 <code>TIME_WAIT</code> 过多的原因</strong>：如果在服务器端观察到大量的 <code>TIME_WAIT</code> 状态，可能需要分析是否有异常的短连接行为，或者系统在短时间内是否处理了过多的连接请求。</li></ul><h3 id="什么情况下会出现CLOSE-WAIT状态？">什么情况下会出现CLOSE_WAIT状态？</h3><p>在 TCP 协议中，<code>CLOSE_WAIT</code> 状态表示一方已经接收到对方发送的 <code>FIN</code> 包（表明对方请求关闭连接），但本方尚未完全关闭连接。这种状态通常出现在被动关闭的情况下，也就是对方主动关闭连接，而自己还未关闭连接。</p><p><strong><code>CLOSE_WAIT</code> 状态出现的原因</strong></p><p><strong>1. 被动关闭连接</strong></p><ul><li><strong>被动关闭</strong>：当对方（主动关闭的一方）调用 <code>close()</code> 函数时，会发送一个 <code>FIN</code> 包给本方。这时，本方的 TCP 连接进入 <code>CLOSE_WAIT</code> 状态，表示它已经知道对方要关闭连接，但还没有完成自己的关闭操作。</li><li><strong>典型流程</strong>：<ol><li>客户端和服务器之间有一个 TCP 连接。</li><li>客户端决定关闭连接，调用 <code>close()</code>，此时发送一个 <code>FIN</code> 包。</li><li>服务器接收到 <code>FIN</code> 包，进入 <code>CLOSE_WAIT</code> 状态。</li><li>服务器需要调用 <code>close()</code> 来释放连接资源，完成整个关闭过程。</li></ol></li></ul><p><strong>2. <code>CLOSE_WAIT</code> 状态持续时间过长的原因</strong></p><p>通常情况下，<code>CLOSE_WAIT</code> 状态只是短暂的，因为在大多数应用逻辑中，接收到 <code>FIN</code> 包后会立即关闭连接。但在某些情况下，<code>CLOSE_WAIT</code> 状态可能会持续较长时间，甚至大量积累，导致系统资源紧张。这通常是由于以下几个原因：</p><p><strong>(1) 没有正确处理网络异常</strong></p><ul><li><p><strong>未处理 <code>read()</code> 返回值为 0 的情况</strong>：当网络连接被对方关闭时，调用 <code>read()</code> 函数会返回 0，表示对方已经关闭连接并且没有更多数据发送过来。如果此时程序没有正确处理这种情况（例如没有调用 <code>close()</code> 关闭连接），就会导致连接处于 <code>CLOSE_WAIT</code> 状态。</p><ul><li><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 对方关闭了连接，应该关闭本方连接</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>(2) 句柄泄露</strong></p><ul><li><strong>资源泄露</strong>：如果程序中出现了文件描述符或套接字句柄的泄露，意味着程序没有正确关闭或释放这些资源。当对方主动关闭连接后，本方未能及时关闭连接，这些连接就会停留在 <code>CLOSE_WAIT</code> 状态。【exit关键字！】<ul><li><strong>示例</strong>：程序中没有调用 <code>close()</code> 来释放已经不再使用的文件描述符，导致资源泄露。</li></ul></li></ul><p><strong>(3) 连接池的使用</strong></p><ul><li><strong>连接池技术</strong>：在一些应用中，为了提高连接的复用率，可能会使用连接池技术来维护多个长连接。连接池中的连接在需要时被复用，而不是每次请求都重新建立连接。</li><li><strong>服务端主动断开空闲连接</strong>：某些服务器有机制会主动断开长时间空闲的连接。当服务端断开连接时，客户端可能并未意识到连接已经断开，这时这些连接会停留在 <code>CLOSE_WAIT</code> 状态。<ul><li><strong>示例</strong>：假设一个客户端使用连接池管理多个长连接，而服务端在一定时间内主动断开空闲连接。如果客户端没有主动检查连接的状态（例如通过心跳机制），这些连接可能会一直处于 <code>CLOSE_WAIT</code> 状态。</li></ul></li></ul><p><strong>解决方案</strong></p><ol><li><p><strong>正确处理网络异常</strong>：在应用程序中，确保正确处理 <code>read()</code> 返回值为 0 的情况，并在发现连接已被对方关闭时，及时调用 <code>close()</code> 函数关闭连接。</p></li><li><p><strong>避免句柄泄露</strong>：在程序中，确保所有的文件描述符和套接字句柄都能正确关闭，防止资源泄露导致连接停留在 <code>CLOSE_WAIT</code> 状态。</p></li><li><p><strong>优化连接池的管理</strong>：如果使用了连接池技术，确保在每次使用连接前检查其状态。如果服务器可能会主动断开空闲连接，可以在客户端实现健康检查机制（如定期发送心跳包），确保发现连接断开后及时关闭。</p><ul><li><p>示例：在连接池中，定期检查连接的状态，如果发现连接已经断开，主动调用close()</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (connection_is_broken(sock)) &#123;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用健康检查线程</strong>：在连接池中，可以引入健康检查线程定期检查连接的状态，发现无效连接时主动关闭。这可以避免大量的 <code>CLOSE_WAIT</code> 状态积累。</p><ul><li><strong>示例</strong>：假设有一个连接池管理多个连接，通过一个健康检查线程定期检查每个连接的状态，发现无效连接（处于 <code>CLOSE_WAIT</code> 状态的连接）时主动关闭它们。</li></ul></li></ol><h3 id="顺序发送数据，接收端出现乱序接收到的情况">顺序发送数据，接收端出现乱序接收到的情况</h3><p>在网络压力大的情况下（如高并发连接），虽然发送端是按顺序发送数据，但接收端可能会乱序接收到数据。这种情况通常不会发生，但在某些异常情况下确实可能出现。</p><p><strong>队列满导致的异常情况</strong></p><ul><li><strong>队列满的情况</strong>：如果完成队列已经满了，而未完成队列还有空间，新的连接请求会被放入未完成队列。对于客户端来说，它可能已经认为连接建立成功，但实际上三次握手并未完成。</li><li><strong>异常情况导致乱序接收</strong>：<ol><li><strong>客户端错误地发起数据传输</strong>：客户端认为连接已经建立（即使三次握手未完成），于是开始发送数据。服务器端由于连接未完成，无法立即响应这些数据。</li><li><strong>后续的处理</strong>：如果服务器端稍后处理了其他连接，释放了队列中的一些位置，未完成的连接可能会继续完成三次握手，并进入完成队列。</li><li><strong>重传机制</strong>：由于客户端发送的数据未得到及时响应，TCP 会进行重传。当连接最终建立后，服务器可能会接收到这些重传的数据包，而这些数据包可能会被乱序接收。</li></ol></li><li><strong>举例</strong>：<br>假设你有一个服务器在高并发下处理连接请求。连接队列已满，客户端 A 认为连接已经建立，于是发送了数据包 1 和数据包 2。由于服务器未完成三次握手，这些数据包暂时没有得到处理。稍后，服务器释放了一些资源，完成了三次握手，并接收了这些数据包。然而，由于网络延迟或重传机制的影响，服务器可能先接收到数据包 2，再接收到数据包 1，从而导致乱序。</li></ul><p><strong>解决乱序接收的方案</strong></p><ul><li><strong>增加 <code>backlog</code> 值</strong>：调整 <code>listen()</code> 函数的 <code>backlog</code> 参数，确保队列有足够的空间来处理高并发连接。</li><li><strong>调整系统参数</strong>：通过修改 <code>/proc/sys/net/core/somaxconn</code> 来增加队列的总长度，减少未完成队列满的情况。</li></ul><p>【个人理解：上述的乱序问题，TCPSocket会有流重排机制保证有序！！！】</p><h3 id="连接偶尔出现超时有哪些可能">连接偶尔出现超时有哪些可能</h3><p><strong>1. 服务端处理能力有限</strong></p><ul><li><strong>描述</strong>：当服务器的 CPU 使用率过高（<code>CPU idle</code> 太低），服务器可能无法及时处理所有传入的请求。这种情况下，服务器可能会变得非常慢，甚至无法响应新的连接请求，最终导致客户端出现连接超时。</li><li><strong>示例</strong>：假设你有一台服务器在高峰时段处理大量请求，CPU 使用率达到了 100%。此时，服务器可能无法在规定时间内处理新的连接请求，导致客户端连接超时。</li><li><strong>解决方案</strong>：优化服务器的性能，增加服务器的计算资源，或者通过负载均衡将请求分发到多台服务器上，减轻单台服务器的压力。</li></ul><p><strong>2. <code>accept</code> 队列设置过小</strong></p><ul><li><strong>描述</strong>：<code>accept</code> 队列用于存放已经完成三次握手但还未被应用程序处理的连接。如果 <code>accept</code> 队列太小，且短时间内有大量连接请求，队列会被填满，导致新的连接请求被拒绝，客户端可能因此超时。</li><li><strong>示例</strong>：一个服务器的 <code>backlog</code> 设置为 5，但在高并发场景下，短时间内有数百个客户端同时尝试连接服务器。由于队列太小，很多连接请求会被拒绝或延迟处理，导致客户端超时。</li><li><strong>解决方案</strong>：通过增大 <code>backlog</code> 参数来增加 <code>accept</code> 队列的大小。可以通过调整 <code>/proc/sys/net/core/somaxconn</code> 系统参数来提高队列的最大值。例如，将 <code>somaxconn</code> 设置为 2048，以允许更多的连接排队等待处理。</li></ul><p><strong>3. 程序逻辑问题导致 <code>accept</code> 处理不过来</strong></p><ul><li><strong>描述</strong>：如果服务器程序的逻辑设计不合理，例如使用简单的线程模型（每个线程一个 <code>accept</code> 调用），但线程被其它耗时操作（如阻塞 I/O）占用，导致 <code>accept</code> 队列中的连接得不到及时处理，最终队列被填满，新的连接请求被丢弃，导致客户端超时。</li><li><strong>示例</strong>：一个服务器使用单线程模型来处理所有 I/O 操作，包括 <code>accept</code>。由于某个线程被一个长时间的文件操作占用，无法及时处理新的连接请求，导致队列中的连接增多，最终队列溢出，客户端连接超时。</li><li><strong>解决方案</strong>：优化服务器的并发模型，例如使用多线程或异步 I/O 模型，确保 <code>accept</code> 能够及时处理新的连接请求。还可以通过开启 <code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code> 开关，让服务器在队列溢出时立即返回连接失败，避免客户端长时间等待。</li></ul><p><strong>4. 读超时导致的连接关闭和重试</strong></p><ul><li><strong>描述</strong>：在一些情况下，客户端可能由于读超时而关闭连接并尝试重新连接。如果这种重试行为频繁发生，可能会导致服务器的 <code>accept</code> 队列处理不过来，进一步加剧超时问题。</li><li><strong>示例</strong>：一个客户端在读取数据时发生超时，关闭连接并立即发起新的连接请求。如果大量客户端都这样操作，服务器的 <code>accept</code> 队列可能会被迅速填满，导致新的连接无法及时处理，客户端再次超时。</li><li><strong>解决方案</strong>：优化客户端的重试机制，避免频繁的重试操作。此外，服务器可以通过增加 <code>backlog</code> 值或优化处理模型来应对高并发连接。</li></ul><p><strong>5. <code>SO_LINGER</code> 设置导致 ACK 丢失</strong></p><ul><li><strong>描述</strong>：在某些情况下，如果使用了 <code>SO_LINGER</code> 选项关闭连接，可能会导致最后一个 ACK 包丢失，进而导致连接的关闭过程出现问题。虽然这种情况非常罕见，但在高压力环境下可能会导致连接超时。</li><li><strong>示例</strong>：一个客户端在关闭连接时使用了 <code>SO_LINGER</code> 选项，但由于网络拥堵，最后一个 ACK 包未能到达服务器，导致服务器继续等待 ACK，而客户端则认为连接已经关闭，出现超时现象。</li><li><strong>解决方案</strong>：在高负载或不稳定的网络环境中，慎用 <code>SO_LINGER</code> 选项，以防止这种极端情况的发生。</li></ul><p><strong>6. <code>epoll</code> 使用不当</strong></p><ul><li><strong>描述</strong>：有些程序使用 <code>epoll</code> 进行事件驱动的 I/O 操作，但没有将 I/O 操作异步化，而是使用阻塞 I/O。这会导致事件循环被阻塞，无法及时处理新的 I/O 事件，进而导致连接超时。</li><li><strong>示例</strong>：一个服务器使用了 <code>epoll</code> 来监听多个连接的 I/O 事件，但在接收到读写事件后，使用了阻塞式 I/O 操作。由于某个 I/O 操作阻塞了较长时间，其他连接无法及时处理，导致客户端超时。</li><li><strong>解决方案</strong>：确保在使用 <code>epoll</code> 时，所有 I/O 操作都是非</li></ul><h3 id="混用长连接和短连接可能出现的问题"><strong>混用长连接和短连接可能出现的问题</strong></h3><p><strong>1. 只要有一端采用短连接，总体可以认为是短连接模式</strong></p><p><strong>解释</strong>：如果客户端使用短连接，而服务器使用长连接，那么连接的生命周期实际上由客户端控制，因为客户端在完成请求后会主动关闭连接。这种情况下，服务器即使想保持长连接，也无法实现，因为客户端已经关闭了连接。</p><p><strong>示例</strong>：</p><ul><li>客户端：发送一个请求后立即关闭连接。</li><li>服务器：希望保持连接以便处理后续请求，但由于连接已被客户端关闭，服务器只能重新等待新的连接。</li></ul><p><strong>潜在问题</strong>：服务器可能在短时间内频繁处理建立和关闭连接的过程，增加了开销。</p><p><strong>2. 服务端长连接，客户端短连接</strong></p><p>当服务端使用长连接，而客户端使用短连接时，会导致以下问题：</p><ul><li><p><strong>服务器端维护不必要的连接状态</strong>：客户端关闭连接后，服务端需要等待接收到关闭信号（<code>FIN</code> 包）后才能知道连接已关闭。在此期间，服务器端资源依然被占用。</p><p><strong>示例</strong>：</p><ul><li>客户端发送完请求后立即关闭连接。</li><li>服务器端未立即收到关闭信号（<code>FIN</code> 包），继续保持连接，导致资源浪费。</li></ul></li><li><p><strong>线程模型可能导致资源浪费</strong>：如果服务器端使用同步阻塞模式处理连接（如每个线程处理一个连接），那么这个线程在等待关闭信号期间无法处理其他业务逻辑，浪费了系统资源。</p><p><strong>示例</strong>：</p><ul><li>服务器使用同步阻塞模型，每个线程处理一个连接。</li><li>客户端关闭连接后，线程被阻塞在等待关闭信号的状态，无法处理其他任务。</li></ul></li><li><p><strong><code>backlog</code> 设置不足的问题</strong>：如果服务器在测试时使用长连接，<code>backlog</code> 设置较小（例如 5），可能不会出现问题。但如果实际运行中被大量短连接访问，<code>backlog</code> 可能不够用，导致连接请求被拒绝。</p><p><strong>示例</strong>：</p><ul><li>测试时服务器设置了 <code>backlog</code> 为 5，处理长连接没有问题。</li><li>实际运行过程中，数百个客户端使用短连接频繁连接和断开，导致 <code>backlog</code> 队列被填满，新的连接请求被拒绝。</li></ul></li><li><p><strong>客户端端口耗尽</strong>：如果客户端频繁关闭连接，而没有设置 <code>SO_LINGER</code> 或调整系统参数，客户端可能会进入 <code>TIME_WAIT</code> 状态，导致可用端口耗尽。</p><p><strong>示例</strong>：</p><ul><li>客户端频繁建立和关闭连接，每次关闭后进入 <code>TIME_WAIT</code> 状态。</li><li>由于端口资源有限，客户端可能无法再分配新的端口，导致连接失败。</li></ul></li></ul><p><strong>3. 服务端短连接，客户端长连接</strong></p><p>如果服务器端使用短连接，而客户端使用长连接，主要问题是：</p><ul><li><p><strong>数据传输失败</strong>：客户端可能会试图在同一个连接上发送多个请求，但服务器端关闭了连接，导致客户端的写操作失败。</p><p><strong>示例</strong>：</p><ul><li>客户端使用长连接，想在同一个连接上发送多次请求。</li><li>服务器在处理完第一个请求后关闭连接，导致客户端的后续请求发送失败。</li></ul></li><li><p><strong>资源浪费</strong>：客户端在发送请求或读取响应时，如果服务器已经关闭连接，客户端可能会尝试进行无用的操作（如写入已经关闭的连接），浪费系统资源。</p><p><strong>示例</strong>：</p><ul><li>客户端在连接被服务器关闭后仍然尝试发送数据，导致写操作失败并抛出异常。</li></ul></li></ul><p><strong>建议与解决方案</strong></p><ul><li><p><strong>两端保持一致</strong>：一般建议客户端和服务器都使用相同的连接策略（即都使用长连接或都使用短连接），以避免上述问题。</p></li><li><p><strong>配置灵活性</strong>：在设计网络应用时，不建议仅通过配置来决定使用长连接或短连接。相反，可以通过协议或数据包的头部信息来指示连接类型，服务器可以根据客户端的连接类型做出相应的处理。</p><p><strong>示例</strong>：</p><ul><li>客户端在发送数据包时，标记自己使用的连接类型（长连接或短连接）。</li><li>服务器根据这个标记决定是否保持连接或立即关闭。</li></ul></li><li><p><strong>日志记录影响</strong>：一些框架或库在处理 <code>read()</code> 返回 0（表明连接关闭）时可能会记录大量日志。在高并发场景下，大量日志记录会对性能产生负面影响。因此，使用这些框架时要特别注意日志记录的设置。</p><p><strong>示例</strong>：</p><ul><li>服务器在处理大量短连接时，每次 <code>read()</code> 返回 0 都会记录日志，导致日志文件迅速增大，影响性能。</li></ul></li></ul><h3 id="对于一个不存在的ip建立连接是超时还是马上返回？">对于一个不存在的ip建立连接是超时还是马上返回？</h3><ul><li><strong>连接不存在的 IP 地址</strong>：通常会经历一段超时时间，因为系统会等待 TCP 连接的响应。<ul><li><strong>标准情况</strong>：当试图连接一个不存在的 IP 地址时，操作系统会尝试通过网络发送 TCP SYN 包来建立连接。因为这个 IP 地址不存在，网络上不会有对应的主机来响应这个 SYN 请求，因此发起连接的系统会一直等待响应，直到连接超时为止。这种情况下，连接请求会经历一个超时时间，最终返回一个超时错误。</li></ul></li><li><strong>连接存在的 IP 地址但端口无服务</strong>：会立即返回 <code>ECONNREFUSED</code> 错误。</li><li><strong>网络不可达</strong>：在网络限制的情况下，可能会立即返回 <code>ENETUNREACH</code> 错误。</li></ul><h3 id="各种超时怎么设置">各种超时怎么设置?</h3><ul><li><strong>连接超时</strong>：通过设置 socket 为非阻塞模式，并使用 <code>select()</code> 或 <code>poll()</code> 来控制连接超时时间。</li><li><strong>写超时</strong>：使用 <code>SO_SNDTIMEO</code> socket 选项来设置写操作的超时时间，通常在内网中可设置为 <code>50ms</code> 到 <code>200ms</code>。</li><li><strong>读超时</strong>：使用 <code>SO_RCVTIMEO</code> socket 选项来设置读操作的超时时间，根据后端处理时间和数据量选择合适的时间，例如 <code>3s</code> 以上。</li></ul><h3 id="程序启动监听端口报端口被占用怎么回事？">程序启动监听端口报端口被占用怎么回事？</h3><p><strong>1. 端口已经被其他程序占用</strong></p><p>这是最常见的情况。某个程序已经在该端口上监听，因此你的程序无法再使用这个端口。你可以使用 <code>lsof</code> 或 <code>netstat</code> 等工具查看哪个进程在使用该端口。</p><p><strong>解决方法</strong>：</p><ul><li><p><strong>查找占用端口的进程</strong>：使用以下命令查看哪个进程占用了端口。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i <span class="symbol">:&lt;port_number&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep <span class="symbol">:&lt;port_number&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>&lt;port_number&gt;</code> 是你要监听的端口号。</p></li><li><p><strong>处理进程</strong>：查看是否可以终止占用端口的进程，或者选择其他未占用的端口来启动你的程序。</p></li></ul><p><strong>2. <code>TIME_WAIT</code> 状态导致端口暂时不可用</strong></p><p>当一个 TCP 连接关闭后，连接的端口会进入 <code>TIME_WAIT</code> 状态，通常持续 60 秒。在此期间，系统会保留该端口，以确保延迟到达的 TCP 包不会被误认为是新连接的一部分。如果你在 <code>TIME_WAIT</code> 状态结束之前试图重新使用同一个端口，并且没有设置 <code>SO_REUSEADDR</code> 选项，系统会拒绝绑定该端口。</p><p><strong>解决方法</strong>：</p><ul><li><p><strong>设置 <code>SO_REUSEADDR</code> 选项</strong>：在绑定端口之前设置 <code>SO_REUSEADDR</code> 选项，允许端口在 <code>TIME_WAIT</code> 状态时被重新绑定。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> <span class="meta">opt</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;<span class="meta">opt</span>, sizeof(<span class="meta">opt</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>等待 <code>TIME_WAIT</code> 状态结束</strong>：也可以简单地等待 <code>TIME_WAIT</code> 状态结束后再重新启动服务。</p></li></ul><p><strong>3. 端口冲突与 <code>SO_REUSEADDR</code> 的使用</strong></p><p>即使你已经设置了 <code>SO_REUSEADDR</code>，仍可能出现端口被占用的情况。原因可能是其他程序在服务退出时，使用了相同的端口来发起外部连接（作为客户端），并且这些连接没有设置 <code>SO_REUSEADDR</code>。这种情况下，当你尝试重新启动服务时，可能会出现端口被占用的错误。</p><p><strong>解决方法</strong>：</p><ul><li><p><strong>更改监听端口</strong>：如果可能，修改服务的监听端口，避免与系统的本地端口范围冲突。你可以通过查看 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 来确认本地端口范围。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/ip_local_port_range</span><br></pre></td></tr></table></figure></li><li><p><strong>避免监听端口在本地端口范围内</strong>：确保你的服务监听的端口不在系统的本地端口范围内，这样可以减少与其他程序的端口冲突。</p></li><li><p><strong>避免设置 <code>SO_REUSEADDR</code> 在客户端</strong>：虽然在客户端设置 <code>SO_REUSEADDR</code> 可以解决部分端口占用问题，但可能会引入“自连接”问题，即服务程序可能会不小心连接到自己。因此，最好通过调整端口范围或选择不同的端口来解决冲突。</p></li></ul><h3 id="RST情况总结">RST情况总结</h3><blockquote><p><strong>场景 1：对端在接收到数据后未读取完毕就关闭连接</strong></p></blockquote><p><strong>描述：</strong></p><p>假设你有一个客户端和服务器之间的 TCP 连接，客户端发送数据到服务器。服务器接收到数据，但在未完全读取数据的情况下直接关闭了连接。此时，服务器可能会发送一个 RST 包给客户端。在这种情况下，客户端在后续的 <code>write()</code> 或 <code>read()</code> 操作中可能会收到 <code>ECONNRESET</code> 错误。</p><p><strong>示例代码：</strong></p><p><strong>服务器端：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    conn_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只读取部分数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(conn_fd, buffer, <span class="number">512</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes\n&quot;</span>, bytes_read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前关闭连接，未读取完所有数据</span></span><br><span class="line">    close(conn_fd);</span><br><span class="line"></span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello, Server!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(sockfd, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent %zd bytes\n&quot;</span>, bytes_written);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可能会收到 ECONNRESET 错误</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connection reset by peer\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes\n&quot;</span>, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理方法：</strong></p><ul><li><strong>检查脏数据</strong>：在关闭连接前确保对端数据已经读取完毕。服务器端程序应在关闭连接前读取所有数据，避免发送 RST 包。</li><li><strong>延迟关闭连接</strong>：在服务器端读取到部分数据后，可以通过使用 <code>shutdown()</code> 函数来优雅地关闭连接，这样可以给对端一个信号，指示它不再发送数据，但仍可以读取剩余的数据。</li></ul><blockquote><p><strong>场景 2：使用 <code>SO_LINGER</code> 选项后立即关闭连接</strong></p></blockquote><p><strong>描述：</strong></p><p><code>SO_LINGER</code> 是一个套接字选项，它决定了在 <code>close()</code> 调用后，TCP 连接的处理方式。如果启用了 <code>SO_LINGER</code> 并设置了一个非零超时时间，<code>close()</code> 将会等待，直到所有未发送的数据都被发送出去或超时。如果 <code>SO_LINGER</code> 设定为立即生效，未发送的数据将被丢弃，并发送 RST 包给对端。</p><p><strong>示例代码：</strong></p><p><strong>服务器端：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    conn_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SO_LINGER选项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">    so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">    so_linger.l_linger = <span class="number">0</span>;  <span class="comment">// 立即发送RST包</span></span><br><span class="line">    setsockopt(conn_fd, SOL_SOCKET, SO_LINGER, &amp;so_linger, <span class="keyword">sizeof</span>(so_linger));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前关闭连接</span></span><br><span class="line">    close(conn_fd);</span><br><span class="line"></span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello, Server!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(sockfd, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent %zd bytes\n&quot;</span>, bytes_written);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可能会收到 ECONNRESET 错误</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(sockfd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connection reset by peer\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes\n&quot;</span>, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理方法：</strong></p><ul><li><strong>避免使用 <code>SO_LINGER</code> 的立即关闭选项</strong>：除非有特殊需求，一般不建议使用 <code>SO_LINGER</code> 的立即关闭选项，因为这会导致未完成的数据传输被丢弃。</li><li><strong>优雅地关闭连接</strong>：使用 <code>shutdown()</code> 函数优雅地关闭连接，确保所有数据都被正确地发送和接收。</li></ul><p><strong>shutdown() 函数为啥能优雅关闭，而close不能优雅关闭呢?</strong></p><ul><li><code>close()</code> 函数立即结束所有与套接字相关的操作。如果套接字的接收缓冲区中仍有未读取的数据，或者发送缓冲区中有未发送的数据，<code>close()</code> 并不会等待这些数据被处理完毕，再去关闭连接，这就可能导致对端收到 RST 包，连接被“粗暴”地终止。</li><li><code>shutdown()</code> 的 <code>SHUT_WR</code> 选项可以实现一个“半关闭”状态，即仅关闭写操作而保留读取功能。这允许本端在发送完所有数据后，通知对端自己不再发送数据（通过发送 FIN 包），但仍然可以继续接收对端的数据。</li></ul><p>【使用shutdown更能保证粒度】</p><blockquote><p><strong>场景 3：客户端或服务器在对方未响应的情况下强制关闭连接</strong></p></blockquote><p><strong>描述：</strong></p><p>当一方在等待数据时，另一方强制关闭连接（例如使用 <code>kill -9</code> 强制终止进程），那么对端会收到 RST 包，并且可能会遇到 <code>ECONNRESET</code> 错误。</p><p><strong>示例代码：</strong></p><p><strong>客户端：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello, Server!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(sockfd, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent %zd bytes\n&quot;</span>, bytes_written);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟等待服务器响应</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试读取服务器响应</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(sockfd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connection reset by peer\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes\n&quot;</span>, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    conn_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里故意不进行任何操作，模拟服务器进程被杀</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制终止进程</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理方法：</strong></p><ul><li><strong>超时检测</strong>：在客户端设置合理的超时时间，如果长时间未收到数据，可以主动关闭连接并重新连接。</li><li><strong>错误处理</strong>：在 <code>read()</code> 或 <code>write()</code> 调用中检查是否发生了 <code>ECONNRESET</code> 错误，并根据需要进行重新连接或其他处理。</li></ul><blockquote><p><strong>场景 4：连接过程中遇到 <code>ECONNRESET</code></strong></p></blockquote><p><strong>描述：</strong></p><p>在 TCP 的三次握手过程中，尤其是在 <code>SYN-ACK</code> 之后，客户端可能会收到 RST 包，这通常是由于服务器的 <code>listen</code> 队列已满或服务器突然关闭了连接引起的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"></span><br><span class="line">sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection reset by peer during handshake\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理方法：</strong></p><ul><li><strong>重试连接</strong>：在 <code>connect()</code> 返回 <code>ECONNRESET</code> 错误时，可以尝试重新连接，或者在合理的时间后再次尝试。</li><li><strong>增加 <code>listen</code> 队列长度</strong>：服务器端可以通过增加 <code>listen()</code> 中的 <code>backlog</code> 参数来增加 <code>SYN</code> 队列的长度，减少因队列满而导致的 RST 包。</li></ul><h3 id="对一些常见错误号的分析">对一些常见错误号的分析</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240902163228800.png" alt="image-20240902163228800"></p><h3 id="socket可写就表示连接成功吗">socket可写就表示连接成功吗</h3><p>答案当然是不是啦</p><p><a href="https://gitee.com/balloonwj/CppGuide/blob/master/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/connect%E5%87%BD%E6%95%B0%E5%9C%A8%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%A1%8C%E4%B8%BA.md">connect 函数在阻塞和非阻塞模式下的行为</a></p><p>我们先用 <strong>nc</strong> 命令启动一个服务器程序：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nc</span> -v -l <span class="number">0.0.0.0</span> port</span><br></pre></td></tr></table></figure><p>然后编译客户端程序并执行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~<span class="regexp">/Desktop/</span>test  ./main  </span><br><span class="line">[<span class="keyword">select</span>] <span class="keyword">connect</span> to server successfully.</span><br></pre></td></tr></table></figure><p>我们把服务器程序关掉，再重新启动一下客户端，这个时候应该会连接失败，程序输出结果如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~<span class="regexp">/Desktop/</span>test  ./main  </span><br><span class="line">[<span class="keyword">select</span>] <span class="keyword">connect</span> to server successfully.</span><br></pre></td></tr></table></figure><p>怎么回事呢？</p><p>章节博客给出了答案：</p><ul><li>在 Linux 系统上一个 socket 没有建立连接之前，用 select 函数检测其是否可写，你也会得到可写得结果，所以上述流程并不适用于 Linux 系统。正确的做法是，connect 之后，不仅要用 <strong>select</strong> 检测可写，还要检测此时 socket 是否出错，通过错误码来检测确定是否连接上，错误码为 0 表示连接上，反之为未连接上。</li></ul><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_ADDRESS <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 3000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEND_DATA <span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 socket 为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fcntl</span>(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 socket</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置 socket 为非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set_nonblocking</span>(clientfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;set socket to nonblock error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(SERVER_ADDRESS);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果连接立即成功，则直接返回</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;connect to server successfully (immediately).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno != EINPROGRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果连接失败，并且错误不是 EINPROGRESS，则直接退出</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;connect error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建 epoll 实例</span></span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;epoll_create1 error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将 socket 注册到 epoll 实例中，监听可写事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev, events[EPOLL_MAX_EVENTS];</span><br><span class="line">    ev.events = EPOLLOUT; <span class="comment">// 关注可写事件，表示连接完成</span></span><br><span class="line">    ev.data.fd = clientfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, clientfd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;epoll_ctl error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="built_in">close</span>(epollfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 等待 epoll 事件</span></span><br><span class="line">    <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epollfd, events, EPOLL_MAX_EVENTS, <span class="number">3000</span>); <span class="comment">// 3 秒超时</span></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;epoll_wait error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="built_in">close</span>(epollfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nfds == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果超时</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;connection timeout.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="built_in">close</span>(epollfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 检查 epoll 返回的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == clientfd &amp;&amp; (events[i].events &amp; EPOLLOUT))</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 当 socket 可写时，而不应该直接默认连接成功!</span></span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">// 当 socket 可写时，检查连接是否成功</span></span><br><span class="line">            <span class="comment">// int error = 0;</span></span><br><span class="line">            <span class="comment">// socklen_t len = sizeof(error);</span></span><br><span class="line">            <span class="comment">// if (getsockopt(clientfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) == -1)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     std::cerr &lt;&lt; &quot;getsockopt error.&quot; &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">//     close(clientfd);</span></span><br><span class="line">            <span class="comment">//     close(epollfd);</span></span><br><span class="line">            <span class="comment">//     return -1;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (error == 0)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     // 连接成功</span></span><br><span class="line">            <span class="comment">//             &#125;</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     // 连接失败</span></span><br><span class="line">            <span class="comment">//     std::cerr &lt;&lt; &quot;connection failed with error: &quot; &lt;&lt; strerror(error) &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 关闭 socket 和 epoll 实例</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">    <span class="built_in">close</span>(epollfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端发数据时，如果对端一直不收，怎么办？">服务器端发数据时，如果对端一直不收，怎么办？</h3><ol><li><strong>设置发送缓冲区大小上限</strong>：<ul><li>在将数据放入发送缓冲区之前，先检查缓冲区的剩余空间。如果剩余空间不足以容纳新数据，则认为连接出现问题，关闭该连接并回收资源。</li></ul></li><li><strong>定时检查发送缓冲区</strong>：<ul><li>设置定时器，定期检查各连接的发送缓冲区。如果发现某个连接的发送缓冲区中有数据积压超过一定时间（如3秒），则认为该连接出现问题，关闭该连接并回收资源。</li></ul></li></ol><h3 id="客户端程序中的-socket-是否可以调用-bind-函数">客户端程序中的 socket 是否可以调用 bind 函数</h3><ul><li><a href="https://gitee.com/balloonwj/CppGuide/blob/master/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.md">bind 函数重难点解析</a></li></ul><p>很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然，在一些特殊的应用中，我们需要客户端程序以指定的端口号去连接服务器，此时我们就可以在客户端程序中调用 bind 函数绑定一个具体的端口。</p><p><strong>一般情况下：</strong></p><p>客户端程序通常不需要显式地调用 <code>bind()</code> 函数。原因如下：</p><ol><li><strong>隐式绑定</strong>：<ul><li>当客户端调用 <code>connect()</code> 函数时，如果没有显式调用 <code>bind()</code>，操作系统会自动选择一个临时的本地 IP 地址和一个临时的本地端口，并隐式地绑定到 socket。这样，客户端就可以通过该 socket 与服务器进行通信。</li><li>这对于大多数客户端应用程序来说是足够的，客户端通常不关心使用哪个本地端口，只要能成功连接服务器即可。</li></ul></li><li><strong>动态端口分配</strong>：<ul><li>如果客户端不调用 <code>bind()</code>，操作系统会在客户端发起连接时自动分配一个空闲的动态端口。这种方式对客户端来说是最常见的，因为客户端通常只需要知道服务器的 IP 和端口，而不关心自己使用的端口。</li></ul></li></ol><p><strong>特殊情况：</strong></p><p>尽管通常不需要，但在某些特殊情况下，客户端可能需要显式地调用 <code>bind()</code> 函数。以下是一些可能的场景：</p><ol><li><p><strong>指定本地 IP 地址或端口</strong>：</p><ul><li><p>如果客户端有多个网卡（网络接口），或者绑定了多个 IP 地址（例如物理网卡和虚拟网卡），并且希望使用特定的本地 IP 地址或特定的本地端口进行通信，则需要使用 <code>bind()</code> 来绑定 socket 到该特定的本地 IP 地址或端口。</p></li><li><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> localAddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;localAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(localAddr));</span><br><span class="line">localAddr.sin_family = AF_INET;</span><br><span class="line">localAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.1.100&quot;</span>); <span class="comment">// 本地 IP 地址</span></span><br><span class="line">localAddr.sin_port = <span class="built_in">htons</span>(<span class="number">12345</span>); <span class="comment">// 本地端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(clientfd, (<span class="keyword">struct</span> sockaddr*)&amp;localAddr, <span class="built_in">sizeof</span>(localAddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>如果端口被占用则不行。</p><ul><li><strong>端口冲突</strong>：如果客户端显式调用 <code>bind()</code> 绑定到一个特定的端口，并且该端口已经被其他进程占用，<code>bind()</code> 会失败，从而导致连接失败。特别是在高并发的网络环境下，动态端口分配是更好的选择，因为操作系统会自动选择一个未使用的端口。</li></ul><h3 id="网络通信中收发数据的正确姿势">网络通信中收发数据的正确姿势</h3><ul><li><a href="https://gitee.com/balloonwj/CppGuide/blob/master/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF.md">网络通信中收发数据的正确姿势</a></li></ul><p>和muduo一致。</p><p>本篇博客根据[<a href="https://www.cnblogs.com/tangr206/articles/3269508.html">网络编程常见问题总结 </a>]问题进行扩展学习！</p>]]></content>
    
    
    <summary type="html">网络编程常见问题梳理</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Epoll经典问题</title>
    <link href="https://penge666.github.io/posts/8ff0cebc.html"/>
    <id>https://penge666.github.io/posts/8ff0cebc.html</id>
    <published>2024-07-28T13:23:30.000Z</published>
    <updated>2024-09-19T11:07:42.476Z</updated>
    
    <content type="html"><![CDATA[<p>我无法改变对你的喜欢，即使我讨厌那种感觉~</p><p>本文学习自：<a href="https://cloud.tencent.com/developer/article/1831360">十个问题理解Linux epoll工作原理</a> 并加上自己的心得</p><p>epoll 是 linux 特有的一个 I/O 事件通知机制。很久以来对 epoll 如何能够高效处理数以百万记的文件描述符很有兴趣。近期学习、研究了 epoll 源码，在这个过程中关于 epoll 数据结构和作者的实现思路产生出不少疑惑，在此总结为了 10 个问题并逐个加以解答和分析。本文基于的内核源码版本是<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Freleases%2Ftag%2Fv2.6.39&amp;source=article&amp;objectId=1831360"><strong>2.6.39 版本</strong></a> 。</p><h2 id="Question-1：是否所有的文件类型都可以被-epoll-监视？"><strong>Question 1：是否所有的文件类型都可以被 epoll 监视？</strong></h2><p>答案：不是。看下面这个实验代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    epfd = epoll_create(<span class="number">100</span>); <span class="comment">/* 创建epoll实例，预计监听100个fd */</span></span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">    <span class="type">int</span> nr_events, i;</span><br><span class="line">    events = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (!events) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开一个普通文本文件 */</span></span><br><span class="line">    <span class="type">int</span> target_fd = open (<span class="string">&quot;./11.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target_fd %d\n&quot;</span>, target_fd);</span><br><span class="line">    <span class="type">int</span> target_listen_type = EPOLLIN;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        events[i].data.fd = target_fd; <span class="comment">/* epoll调用返回后，返回给应用进程的fd号 */</span></span><br><span class="line">        events[i].events = target_listen_type; <span class="comment">/* 需要监听的事件类型 */</span></span><br><span class="line">        ret = epoll_ctl (epfd, EPOLL_CTL_ADD, target_fd, &amp;events[i]); <span class="comment">/* 注册fd到epoll实例上 */</span></span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ret %d, errno %d\n&quot;</span>, ret, errno);</span><br><span class="line">            perror (<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 应用进程阻塞在epoll上，超时时长置为-1表示一直等到有目标事件才会返回 */</span></span><br><span class="line">    nr_events = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr_events &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_events; i++) &#123;</span><br><span class="line">        <span class="comment">/* 打印出处于就绪状态的fd及其事件 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event=%d on fd=%d\n&quot;</span>, events[i].events, events[i].data.fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span> (events);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译、运行上面的代码，会打印出下列信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc epoll_test.<span class="property">c</span> -o epdemo</span><br><span class="line">./epdemo</span><br><span class="line">target_fd <span class="number">4</span></span><br><span class="line">ret -<span class="number">1</span>, errno <span class="number">1</span></span><br><span class="line"><span class="attr">epoll_ctl</span>: <span class="title class_">Operation</span> not permitted</span><br></pre></td></tr></table></figure><p>正常打开了&quot;txt&quot;文件 fd=4, 但调用 epoll_ctl 监视这个 fd 时却 ret=-1 失败了, 并且错误码为 1，错误信息为&quot;Operation not permitted&quot;。错误码指明这个 fd 不能够被 epoll 监视。</p><p><strong>那什么样的 fd 才可以被 epoll 监视呢？</strong></p><p>只有底层驱动实现了 file_operations 中 poll 函数的文件类型才可以被 epoll 监视！<strong>socket 类型的文件驱动是实现了 poll 函数的，因此才可以被 epoll 监视</strong>。struct file_operations 声明位置是在 include/linux/fs.h 中。</p><p><strong>补充：</strong></p><p>在 Linux 内核中，<code>epoll</code> 可以用来监视多种类型的文件描述符（文件、套接字、管道等），<strong>这需要底层的驱动实现了 <code>file_operations</code> 结构中的 <code>poll</code> 函数</strong>。下面详细说明这方面的区别以及 <code>epoll</code> 与 <code>file_operations</code> 的关系。</p><p><strong><code>file_operations</code> 结构体</strong></p><p><code>file_operations</code> 结构体定义了文件操作接口。它声明在 <code>include/linux/fs.h</code> 中，通常包括文件操作所需的一些函数指针，例如 <code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, <code>poll</code> 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>epoll</code> 与 <code>poll</code> 函数</strong></p><ul><li><p><strong><code>poll</code> 函数</strong>: 这是 <code>file_operations</code> 结构体中的一个函数指针。<code>poll</code> 函数用于检查文件描述符的状态，判断是否可以读写，或是否发生了某种事件。文件类型的驱动实现了这个函数，<code>epoll</code> 可以用来监视这些文件描述符的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>epoll</code> 监视</strong>: <code>epoll</code> 通过调用底层驱动的 <code>poll</code> 函数来检测文件描述符的状态变化。如果底层驱动实现了 <code>poll</code> 函数，<code>epoll</code> 就可以监视这个文件描述符。</p></li></ul><p><strong>普通文件与套接字的区别</strong></p><ul><li><strong>普通文件</strong>:<ul><li><strong>文件系统接口</strong>: 普通文件的 <code>file_operations</code> 实现通常包括 <code>read</code>, <code>write</code>, <code>llseek</code> 等基本操作。</li><li><strong><code>poll</code> 函数</strong>: 普通文件的 <code>poll</code> 实现会根据文件的状态（是否可以读写）来返回相应的事件。</li></ul></li><li><strong>套接字</strong>:<ul><li><strong>网络接口</strong>: 套接字的 <code>file_operations</code> 实现包括网络相关的操作，比如 <code>recv</code>, <code>send</code> 等。</li><li><strong><code>poll</code> 函数</strong>: 套接字的 <code>poll</code> 函数会根据网络事件（如数据可读、连接关闭等）返回相应的事件。</li></ul></li></ul><h2 id="Question-2：ep-wq-的作用是什么？"><strong>Question 2：ep-&gt;wq 的作用是什么？</strong></h2><p><strong>答案：wq 是一个等待队列，用来保存对某一个 epoll 实例调用 epoll_wait()的所有进程。</strong></p><p>一个进程调用 epoll_wait()后，如果当前还没有任何事件发生，需要让当前进程挂起等待（放到 ep-&gt;wq 里）；当 epoll 实例监视的文件上有事件发生后，需要唤醒 ep-&gt;wq 上的进程去继续执行用户态的业务逻辑。之所以要用一个等待队列来维护关注这个 epoll 的进程，是因为有时候调用 epoll_wait()的不只一个进程，当多个进程都在关注同一个 epoll 实例时，休眠的进程们通过这个等待队列就可以逐个被唤醒了。</p><p><strong>多个进程关注同一个 epoll 实例，那么有事件发生后先唤醒谁？后唤醒谁？还是一起全唤醒？这涉及到一个称为“惊群效应”的问题。</strong></p><h2 id="Question-3：什么是-epoll-惊群？"><strong>Question 3：什么是 epoll 惊群？</strong></h2><p>答案：多个进程等待在 ep-&gt;wq 上，事件触发后所有进程都被唤醒，但只有其中 1 个进程能够成功继续执行的现象。其他被白白唤起的进程等于做了无用功，可能会造成系统负载过高的问题。下面这段代码能够直观感受什么是 epoll 惊群：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 10</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_and_bind</span> <span class="params">(<span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(port));</span><br><span class="line">    bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">make_socket_non_blocking</span> <span class="params">(<span class="type">int</span> sfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags, s;</span><br><span class="line"></span><br><span class="line">    flags = fcntl (sfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror (<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    s = fcntl (sfd, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror (<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd, s;</span><br><span class="line">    <span class="type">int</span> efd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">    sfd = create_and_bind(<span class="string">&quot;8001&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">    s = make_socket_non_blocking (sfd);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">    s = listen(sfd, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror (<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(MAXEVENTS);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.data.fd = sfd;</span><br><span class="line">    <span class="comment">//event.events = EPOLLIN | EPOLLET;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span> event);</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; PROCESS_NUM; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The event loop */</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> n, i;</span><br><span class="line">                n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process %d return from epoll_wait!\n&quot;</span>, getpid());</span><br><span class="line">             <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp; EPOLLIN)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */</span></span><br><span class="line">                        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                        close (events[i].data.fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* We have a notification on the listening socket, which means one or more incoming connections. */</span></span><br><span class="line">                        <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                        <span class="type">socklen_t</span> in_len;</span><br><span class="line">                        <span class="type">int</span> infd;</span><br><span class="line">                        <span class="type">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">                        in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">                        infd = accept(sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">                        <span class="keyword">if</span> (infd == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;process %d accept failed!\n&quot;</span>, getpid());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d accept successed!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Make the incoming socket non-blocking and add it to the list of fds to monitor. */</span></span><br><span class="line">                        close(infd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">free</span> (events);</span><br><span class="line">    close (sfd);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将服务端的监听 socket fd 加入到 epoll_wait 的监视集合中，这样当有客户端想要建立连接，就会事件触发 epoll_wait 返回。此时如果 10 个进程同时在 epoll_wait 同一个 epoll 实例就出现了惊群效应。所有 10 个进程都被唤起，但只有一个能成功 accept。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212514596.png" alt="image-20240815212514596"></p><p>为了解决 epoll 惊群，内核后续的高版本又提供了 EPOLLEXCLUSIVE 选项和 SO_REUSEPORT 选项，<strong>我个人理解两种解决方案思路上的不同点在于：EPOLLEXCLUSIVE 是在唤起进程阶段起作用，只唤起排在队列最前面的 1 个进程；而 SO_REUSEPORT 是在分配连接时起作用，相当于每个进程自己都有一个独立的 epoll 实例，内核来决策把连接分配给哪个 epoll。</strong></p><h2 id="Question-4：ep-poll-wait-的作用是什么？"><strong>Question 4：ep-&gt;poll_wait 的作用是什么？</strong></h2><p><strong>答案：ep-&gt;poll_wait 是 epoll 实例中另一个等待队列。当被监视的文件是一个 epoll 类型时，需要用这个等待队列来处理递归唤醒。</strong></p><p>在阅读内核代码过程中，ep-&gt;wq 还算挺好理解，但我发现伴随着 ep-&gt;wq 唤醒， 还有一个 ep-&gt;poll_wait 的唤醒过程。比如下面这段代码，在 eventpoll.c 中出现了很多次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !<span class="title function_">ep_is_linked</span>(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="title function_">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">            <span class="title function_">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">atomic_long_inc</span>(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="title function_">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br></pre></td></tr></table></figure><p>查阅很多资料后才搞明白其实 epoll 也是一种文件类型，其底层驱动也<strong>实现了 file_operations 中的 poll 函数</strong>，因此一个 epoll 类型的 fd 可以被其他 epoll 实例监视。而 epoll 类型的 fd 只会有“读就绪”的事件。当 epoll 所监视的非 epoll 类型文件有“读就绪”事件时，当前 epoll 也会进入“读就绪”状态。</p><p>因此如果一个 epoll 实例监视了另一个 epoll 就会出现递归。举个例子，如图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212524313.png" alt="image-20240815212524313"></p><ol><li>epollfd1 监视了 2 个“非 epoll”类型的 fd</li><li>epollfd2 监视了 epollfd1 和 2 个“非 epoll”类型的 fd</li></ol><p>如果 epollfd1 所监视的 2 个 fd 中有可读事件触发，fd 的 ep_poll_callback 回调函数会触发将 fd 放到 epollfd1 的 rdllist 中。此时 epollfd1 本身的可读事件也会触发，就需要从 epollfd1 的 poll_wait 等待队列中找到 epollfd2，调用 epollfd1 的 ep_poll_callback(将 epollfd1 放到 epollfd2 的 rdllist 中)。<strong>因此 ep-&gt;poll_wait 是用来处理 epoll 间嵌套监视的情况的。</strong></p><h2 id="Question-5：ep-rdllist-的作用是什么？"><strong>Question 5：ep-&gt;rdllist 的作用是什么？</strong></h2><p>答案：epoll 实例中包含就绪事件的 fd 组成的链表。</p><p>通过扫描 ep-&gt;rdllist 链表，内核可以轻松获取当前有事件触发的 fd。而不是像 select()/poll() 那样全量扫描所有被监视的 fd，再从中找出有事件就绪的。因此可以说这一点决定了 epoll 的性能是远高于 select/poll 的。</p><p>看到这里你可能又产生了一个小小的疑问：<strong>为什么 epoll 中事件就绪的 fd 会“主动”跑到 rdllist 中去，而不用全量扫描就能找到它们呢？</strong> 这是因为每当调用 epoll_ctl 新增一个被监视的 fd 时，都会注册一下这个 fd 的回调函数 ep_poll_callback， 当网卡收到数据包会触发一个中断，中断处理函数再回调 ep_poll_callback 将这个 fd 所属的“epitem”添加至 epoll 实例中的 rdllist 中。</p><h2 id="Question-6：ep-ovflist-的作用是什么？"><strong>Question 6：ep-&gt;ovflist 的作用是什么？</strong></h2><p><strong><code>ep-&gt;ovflist</code> 是 <code>epoll</code> 的溢出列表，用于在 <code>epoll</code> 的事件队列满载时存放多余的待处理事件，确保即使在高并发场景下，所有触发的事件都不会丢失，而是有序处理。</strong></p><p>答案：在 rdllist 被占用时，用来在不持有 ep-&gt;lock 的情况下收集有就绪事件的 fd。</p><p>当 epoll 上已经有了一些就绪事件的时候，内核需要扫描 rdllist 将就绪的 fd 返回给用户态。这一步通过 ep_scan_ready_list 函数来实现。其中 sproc 是一个回调函数(也就是 ep_send_events_proc 函数)，来处理数据从内核态到用户态的复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for the scan code, to call f_op-&gt;poll(). Also allows for O(NumReady) performance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ep</span>: Pointer to the epoll private data structure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sproc</span>: Pointer to the scan callback.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@priv</span>: Private opaque data passed to the <span class="doctag">@sproc</span> callback.</span></span><br><span class="line"><span class="comment"> * Returns: The same integer error code returned by the <span class="doctag">@sproc</span> callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> int <span class="title function_">ep_scan_ready_list</span>(struct eventpoll *ep,</span><br><span class="line">                  int (*sproc)(struct eventpoll *,</span><br><span class="line">                       struct list_head *, <span class="keyword">void</span> *),</span><br><span class="line">                  <span class="keyword">void</span> *priv)</span><br></pre></td></tr></table></figure><p>由于 rdllist 链表业务非常繁忙（epoll 增加监视文件、修改监视文件、有事件触发…等情况都需要操作 rdllist)，所以在复制数据到用户空间时，加了一个 ep-&gt;mtx 互斥锁来保护 epoll 自身数据结构线程安全，此时其他执行流程里有争抢 ep-&gt;mtx 的操作都会因命中 ep-&gt;mtx 进入休眠。</p><p>但加锁期间很可能有新事件源源不断地产生，进而调用 ep_poll_callback(ep_poll_callback 不用争抢 ep-&gt;mtx 所以不会休眠)，新触发的事件需要一个地方来收集，不然就丢事件了。这个用来临时收集新事件的链表就是 ovflist。我的理解是：引入 ovflist 后新产生的事件就不用因为想向 rdllist 里写而去和 ep_send_events_proc 争抢自旋锁(ep-&gt;lock), 同时 ep_send_events_proc 也可以放心大胆地在无锁(不持有 ep-&gt;lock)的情况下修改 rdllist。</p><p>看代码时会发现，还有一个 txlist 链表，这个链表用来最后向用户态复制数据，rdllist 要先把自己的数据全部转移到 txlist，然后 rdllist 自己被清空。ep_send_events_proc 遍历 txlist 处理向用户空间复制，复制成功后如果是水平触发(LT)还要把这个事件还回 rdllist，等待下一次 epoll_wait 来获取它。</p><p>ovflist 上的 fd 会合入 rdllist 上等待下一次扫描；如果 txlist 上的 fd 没有处理完，最后也会合入 rdllist。这 3 个链表的关系是这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212534725.png" alt="image-20240815212534725"></p><h2 id="Question-7：epitem-pwqlist-队列的作用是什么？"><strong>Question 7：epitem-&gt;pwqlist 队列的作用是什么？</strong></h2><p><strong><code>epitem-&gt;pwqlist</code> 队列用于跟踪和管理 <code>epitem</code> 关联的等待队列，以便在监视的文件描述符上事件触发时，能够正确地将等待的进程唤醒并将事件添加到 <code>epoll</code> 的就绪队列中。</strong></p><p>答案：用来保存这个 epitem 的 poll 等待队列。</p><p>首先介绍下什么是 epitem。epitem 是 epoll 中很重要的一种数据结构， 是红黑树和 rdllist 的基本组成元素。需要监听的文件和事件信息，都被包装在 epitem 结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;  <span class="comment">// 用于加入红黑树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink; <span class="comment">// 用于加入rdllist</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd; <span class="comment">// 包含被监视文件的文件指针和fd信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist; <span class="comment">// poll等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep; <span class="comment">// 所属的epoll实例</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;  <span class="comment">// 关注的事件</span></span><br><span class="line">    <span class="comment">/* 其他成员省略 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回忆一下上文说到，每当用户调用 epoll_ctl()新增一个监视文件，都要给这个文件注册一个回调函数 ep_poll_callback, 当网卡收到数据后软中断会调用这个 ep_poll_callback 把这个 epitem 加入到 ep-&gt;rdllist 中。</p><p><strong>pwdlist 就是跟 ep_poll_callback 注册相关的</strong>。</p><p>当调用 epoll_ctl()新增一个监视文件后，内核会为这个 epitem 创建一个 eppoll_entry 对象，通过 eppoll_entry-&gt;wait_queue_t-&gt;wait_queue_func_t 来设置 ep_poll_callback。pwdlist 为什么要做成一个队列呢，直接设置成 eppoll_entry 对象不就行了吗？实际上不同文件类型实现 file_operations-&gt;poll 用到等待队列数量可能不同。虽然大多数都是 1 个，但也有例外。比如“scullpipe”类型的文件就用到了 2 个等待队列。</p><p>pwqlist、epitem、fd、epoll_entry、ep_poll_callback 间的关系是这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212540347.png" alt="image-20240815212540347"></p><h2 id="Question-8：epmutex、ep-mtx、ep-lock-3-把锁的区别是？"><strong>Question 8：epmutex、ep-&gt;mtx、ep-&gt;lock 3 把锁的区别是？</strong></h2><p>答案：锁的粒度和使用目的不同。</p><ol><li>epmutex 是一个全局互斥锁，epoll 中一共只有 3 个地方用到这把锁。分别是 ep_free() 销毁一个 epoll 实例时、eventpoll_release_file() 清理从 epoll 中已经关闭的文件时、epoll_ctl() 时避免 epoll 间嵌套调用时形成死锁。我的理解是 epmutex 的锁粒度最大，用来处理跨 epoll 实例级别的同步操作。</li><li>ep-&gt;mtx 是一个 epoll 内部的互斥锁，在 ep_scan_ready_list() 扫描就绪列表、eventpoll_release_file() 中执行 ep_remove()删除一个被监视文件、ep_loop_check_proc()检查 epoll 是否有循环嵌套或过深嵌套、还有 epoll_ctl() 操作被监视文件增删改等处有使用。可以看出上述的函数里都会涉及对 epoll 实例中 rdllist 或红黑树的访问，因此我的理解是 ep-&gt;mtx 是一个 epoll 实例内的互斥锁，用来保护 epoll 实例内部的数据结构的线程安全。</li><li>ep-&gt;lock 是一个 epoll 实例内部的自旋锁，用来保护 ep-&gt;rdllist 的线程安全。自旋锁的特点是得不到锁时不会引起进程休眠，所以在 ep_poll_callback 中只能使用 ep-&gt;lock，否则就会丢事件。</li></ol><h2 id="Question-9：epoll-使用红黑树的目的是什么？"><strong>Question 9：epoll 使用红黑树的目的是什么？</strong></h2><p>答案：用来维护一个 epoll 实例中所有的 epitem。</p><p>用户态调用 epoll_ctl()来操作 epoll 的监视文件时，需要增、删、改、查等动作有着比较高的效率。尤其是当 epoll 监视的文件数量达到百万级的时候，选用不同的数据结构带来的效率差异可能非常大。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212550835.png" alt="image-20240815212550835"></p><p>从时间(增、删、改、查、按序遍历)、空间(存储空间大小、扩展性)等方面考量，红黑树都是非常优秀的数据结构(当然这以红黑树比较高的实现复杂度作为代价)。epoll 红黑树中的 epitem 是按什么顺序组织的。阅读代码可以发现是先比较 2 个文件指针的地址大小，如果相同再比较文件 fd 的大小。</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare RB tree keys */</span></span><br><span class="line"><span class="keyword">static</span> inline int <span class="title function_">ep_cmp_ffd</span>(<span class="params">struct epoll_filefd *p1, struct epoll_filefd *p2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1-&gt;file &gt; p2-&gt;file ? +<span class="number">1</span> : (p1-&gt;file &lt; p2-&gt;file ? -<span class="number">1</span> : p1-&gt;fd - p2-&gt;fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll、epitem、和红黑树间的组织关系是这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212555333.png" alt="image-20240815212555333"></p><h2 id="Question-10：什么是水平触发、边缘触发？"><strong>Question 10：什么是水平触发、边缘触发？</strong></h2><p>答案：水平触发(LT)和边缘触发(ET)是 epoll_wait 的 2 种工作模式。水平触发：关注点是数据（读操作缓冲区不为空，写操作缓冲区不为满），epoll_wait 总会返回就绪。LT 是 epoll 的默认工作模式。</p><p>边缘触发：关注点是变化，只有监视的文件上有数据变化发生（读操作关注有数据写进缓冲区，写操作关注数据从缓冲区取走），epoll_wait 才会返回。</p><p>看一个<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fcheerfuldustin%2Ftest_epoll_lt_and_et&amp;source=article&amp;objectId=1831360"><strong>实验</strong></a> ,直观感受下 2 种模式的区别, 客户端都是输入“abcdefgh” 8 个字符，服务端每次接收 2 个字符。</p><p>水平触发时，客户端输入 8 个字符触发了一次读就绪事件，由于被监视文件上还有数据可读故一直返回读就绪，服务端 4 次循环每次都能取到 2 个字符，直到 8 个字符全部读完。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212602516.png" alt="image-20240815212602516"></p><p>边缘触发时，客户端同样输入 8 个字符但服务端一次循环读到 2 个字符后这个读就绪事件就没有了。等客户端再输入一个字符串后，服务端关注到了数据的“变化”继续从缓冲区读接下来的 2 个字符“c”和”d”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212608947.png" alt="image-20240815212608947"></p><h4 id="小结"><strong>小结</strong></h4><p>本文通过 10 个问题，其实也是从 10 个不同的视角去观察 epoll 这间宏伟的殿堂。至此也基本介绍完了 epoll 从监视事件，到内部数据结构组织、事件处理，最后到 epoll_wait 返回的整体工作过程。最后附上一张 epoll 相关数据结构间的关系图，在学习 epoll 过程中它曾解答了我心中不少的疑惑，我愿称之为灯塔~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240815212620217.png" alt="image-20240815212620217"></p><p>补充：<a href="https://cloud.tencent.com/developer/article/2420478">20种不同并发模型示例，带你深入理解并发模型</a></p><p><strong>参考资料</strong></p><ol><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Ffd3kyt.github.io%2Fposts%2Fimplementation-of-epoll%2F&amp;source=article&amp;objectId=1831360"><strong>Implementation of Epoll</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Flatest%2Fcore-api%2Frbtree.html&amp;source=article&amp;objectId=1831360"><strong>Red-black Trees (rbtree) in Linux</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F9162712%2Fwhat-is-the-purpose-of-epolls-edge-triggered-option&amp;source=article&amp;objectId=1831360"><strong>What is the purpose of epoll’s edge triggered option?</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Ficoty.github.io%2F2019%2F06%2F03%2Fepoll-source%2F&amp;source=article&amp;objectId=1831360"><strong>epoll 源码分析(基于 linux-5.1.4)</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F81610605e623&amp;source=article&amp;objectId=1831360"><strong>epoll 实现原理</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.programmersought.com%2Farticle%2F73753380894%2F&amp;source=article&amp;objectId=1831360"><strong>epoll (2) source code analysis</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fblog.csdn.net%2Fwallwind%2Farticle%2Fdetails%2F8981641&amp;source=article&amp;objectId=1831360"><strong>epoll 的内核实现</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fprogramming.vip%2Fdocs%2Flinux-kernel-notes-epoll-implementation-principle.html&amp;source=article&amp;objectId=1831360"><strong>Linux Kernel Notes: epoll Implementation Principle</strong></a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fpureage.info%2F2015%2F12%2F22%2Fthundering-herd.html&amp;source=article&amp;objectId=1831360"><strong>accept 与 epoll 惊群</strong></a></li></ol>]]></content>
    
    
    <summary type="html">Epoll经典十问</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux接收网络数据包</title>
    <link href="https://penge666.github.io/posts/6ee3891.html"/>
    <id>https://penge666.github.io/posts/6ee3891.html</id>
    <published>2024-07-26T12:22:07.000Z</published>
    <updated>2024-09-16T11:42:58.756Z</updated>
    
    <content type="html"><![CDATA[<p>有些事，我能相通，也能接受，但是还是会难过好一阵子</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202324226.png" alt="image-20240828202324226"></p><p>整体流程：</p><ul><li>系统初始化时，网卡驱动程序会向内核申请一块内存「ring buffer」，用于存储未来到达的网络数据包；</li><li>网卡驱动程序将上一步申请的「ring buffer」地址告诉网卡；</li><li>当数据包从网络上通过网线到达网卡后，网卡会通过DMA将数据拷贝到ring buffer中（这个过程不需要cpu参与）；</li><li>同时网卡会产生CPU硬中断，告诉CPU现在有数据来了，你必须最高优先级处理，否则数据待会存不下了；</li><li>CPU看到网卡产生的硬中断后，调用对应的网卡驱动硬中断处理程序；</li><li>网卡驱动被调用后，首先禁用网卡的硬中断，然后启动对应的软中断函数；</li><li>软中断函数开始从ring buffer中进行循环取包，并且封装为sk_buff，然后投递给网络协议栈进行处理；</li><li>协议栈处理完成后数据就进入用户态的对应进程，进程就可以操作数据了。</li></ul><h2 id="中断"><strong>中断</strong></h2><p>当硬件设备完成属于自己部分的操作后，需要CPU帮忙完成剩下的操作时，它需要有一个机制通知CPU。这个机制就叫中断。</p><p>中断本质上是一种特殊的电信号，由硬件设备发向CPU，CPU接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据。</p><p>不同的硬件设备对应的中断不同，他们通过一个唯一的数字进行区分。因此，操作系统就可以区分中断是来自键盘还是硬盘，还是网卡。这样，操作系统才能给不同的中断提供对应的中断处理程序。</p><p>每种类型的中断都对应一个中断程序，当中断发生时，CPU就会找到对应的中断程序然后执行。中断在整个操作系统中拥有最高优先级，当一个中断到来后，CPU必须马上停止当前正在执行的程序，转而执行中断程序。</p><p>这里可以发现如果中断程序是一段耗时长的逻辑那么就会导致CPU无法释放，效率低下。为了解决这个问题，于是设计了软中断。那么硬件发出信号，CPU响应我们称为硬中断。</p><p>有了软中断后，CPU响应中断的逻辑变为了：硬件发出中断信号，CPU收到后调用对应的中断程序（中断程序必须逻辑简单，耗时短），然后中断程序对硬件进行复位或者禁用中断，然后调用软中断函数进行数据处理，而软中断对应的函数就可以让CPU按照自己的调度策略去执。</p><blockquote><p>Linux设计为硬中断在哪个CPU上被响应，那么软中断也是在这个 CPU 上处理的。如果你发现你的 Linux 软中断 CPU 消耗都集中在一个核 上的话，做法是要把调整硬中断的CPU亲和性，来将硬中断打散到不同的 CPU 核上去。</p></blockquote><p>Linux网卡注册中断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __igb_open(<span class="keyword">struct</span> net_device *netdev, <span class="type">bool</span> resuming) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分配多 TX 队列的内存空间 */</span></span><br><span class="line">    err = <span class="built_in">igb_setup_all_tx_resources</span>(adapter);</span><br><span class="line">    <span class="comment">/* 分配多 RX 队列的内存空间 */</span></span><br><span class="line">    err = <span class="built_in">igb_setup_all_rx_resources</span>(adapter);</span><br><span class="line">    <span class="comment">/* 给网卡配置 RX/TX 队列，给 RX 申请 DMA 空间 */</span></span><br><span class="line">    <span class="built_in">igb_configure</span>(adapter);</span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    err = <span class="built_in">igb_request_irq</span>(adapter);</span><br><span class="line">    <span class="comment">/* 打开 NAPI */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_q_vectors; i++)</span><br><span class="line">        <span class="built_in">napi_enable</span>(&amp;(adapter-&gt;q_vector[i]-&gt;napi));</span><br><span class="line">    <span class="comment">/* 打开硬中断 */</span></span><br><span class="line">    <span class="built_in">igb_irq_enable</span>(adapter);</span><br><span class="line">    <span class="comment">/* 启动所有 TX 队列 */</span></span><br><span class="line">    <span class="built_in">netif_tx_start_all_queues</span>(netdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">igb_open</span><span class="params">(<span class="keyword">struct</span> net_device *netdev)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __igb_open(netdev, <span class="literal">false</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>igb网卡软中断处理</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 软中断，处理数据包，放进 socket buffer，数据包处理完后，开启硬中断。</span><br><span class="line">__do_softirq</span><br><span class="line">|-- net_rx_action</span><br><span class="line">    |-- igb_poll # 遍历 softnet_data.poll_list</span><br><span class="line">        |-- igb_clean_rx_irq #调用 igb_clean_rx_irq 循环处理数据包，直到处理完</span><br><span class="line">            |-- napi_gro_receive #数据包合并</span><br><span class="line">                |--napi_skb_finish</span><br><span class="line">                   |-- netif_receive_skb</span><br><span class="line">                      |-- ip_rcv <span class="meta">#ip层处理数据包</span></span><br><span class="line">                          |-- tcp_v4_rcv <span class="meta">#tcp处理数据包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DMA"><strong>DMA</strong></h2><p>DMA 全称是 Direct Memory Access，它可以在CPU不参与的情况下，完成外部硬件设备和存储器之间或者存储器和存储器之间的高速数据传输。</p><p>数据可以直接通过DMA进行快速拷贝，节省 CPU 的资源去做其他工作。</p><p>目前，大部分的计算机都配备了 DMA 控制器。借助于 DMA 机制，计算机的 I/O 过程就能更加高效。</p><blockquote><p>介绍</p></blockquote><p>DMA（直接内存访问）是一种计算机系统特性，允许外部设备直接访问内存而无需经过CPU。这种机制可以提高数据传输效率，减轻CPU负担。以下是关于DMA的详细介绍：</p><p><strong>工作原理</strong></p><ol><li><strong>初始化</strong>：CPU配置DMA控制器，设定数据源地址、目的地址和传输数据的大小。</li><li><strong>请求</strong>：外设请求DMA传输。</li><li><strong>传输</strong>：DMA控制器接管总线，直接读写内存数据。</li><li><strong>完成</strong>：传输完成后，DMA控制器向CPU发送中断信号，通知传输结束。</li></ol><h2 id="Ring-Buffer">Ring Buffer</h2><p>Ring Buffer是一个环形缓冲区，但是他的底层是个 FIFO 的队列。他提供了一种免加锁的方式去解决数据竞争问题。同时也可以避免频繁的申请/释放内存，避免内存碎片的产生。</p><p>本文提到的Ring Buffer，位于网卡和协议栈之间，用于两者之间进行数据传递。</p><p>前面我们提到系统初始化时，网卡驱动程序会向内核申请ring buffer，其实除了ring buffer外还需要额外申请一块内存用于存储数据包，这片内存由skb_buffer链表组成。</p><blockquote><p>需要注意的是：Ring Buffer 中存储的是 sk_buff 的 Descriptor，而不是 sk_buff 本身，本质是一个指针，也称为 Packet Descriptor。</p></blockquote><p>Packet Descriptor 有 Ready 和 Used 这 2 种状态。初始时 Descriptor 指向一个预先分配好且是空的 sk_buff 空间，处在 Ready 状态。当有 Frame 到达时，DMA Controller 从 Rx Ring Buffer 中按顺序找到下一个 Ready 的 Descriptor，将 Frame 的数据 Copy 到该 Descriptor 指向的 sk_buff 空间中，最后标记为 Used 状态。</p><p>以下为e1000_rx_ring的结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">e1000_rx_ring</span> &#123;</span><br><span class="line"> <span class="comment">/* pointer to the descriptor ring memory */</span></span><br><span class="line"> <span class="type">void</span> *desc; <span class="comment">/* 内存描述符（e1000_rx_desc）数组。 */</span></span><br><span class="line"> <span class="comment">/* physical address of the descriptor ring */</span></span><br><span class="line"> <span class="type">dma_addr_t</span> dma;</span><br><span class="line"> <span class="comment">/* length of descriptor ring in bytes */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">/* number of descriptors in the ring */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line"> <span class="comment">/* next descriptor to associate a buffer with */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> next_to_use;</span><br><span class="line"> <span class="comment">/* next descriptor to check for DD status bit */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> next_to_clean;</span><br><span class="line"> <span class="comment">/* array of buffer information structs */</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">e1000_rx_buffer</span> *buffer_info;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *rx_skb_top;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* cpu for rx queue */</span></span><br><span class="line"> <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line"> u16 rdh;</span><br><span class="line"> u16 rdt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述符指向的内存块。*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e1000_rx_buffer</span> &#123;</span><br><span class="line"> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page; <span class="comment">/* jumbo: alloc_page */</span></span><br><span class="line">  u8 *data; <span class="comment">/* else, netdev_alloc_frag */</span></span><br><span class="line"> &#125; rxbuf;</span><br><span class="line"> <span class="type">dma_addr_t</span> dma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive Descriptor - 内存描述符。*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e1000_rx_desc</span> &#123;</span><br><span class="line"> __le64 buffer_addr; <span class="comment">/* Address of the descriptor&#x27;s data buffer */</span></span><br><span class="line"> __le16 length;  <span class="comment">/* Length of data DMAed into data buffer */</span></span><br><span class="line"> __le16 csum;  <span class="comment">/* Packet checksum */</span></span><br><span class="line"> u8 status;  <span class="comment">/* Descriptor status */</span></span><br><span class="line"> u8 errors;  <span class="comment">/* Descriptor Errors */</span></span><br><span class="line"> __le16 special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="sk-buff">sk_buff</h2><p>sk_buff 是最重要的数据结构，用来表示已接收或将要传输的数据。</p><h3 id="sk-buff双向链表">sk_buff双向链表</h3><p>​    sk_buff是由双向链表组成的，和传统的双向链表类似，sk_buff 链表的每个节点也通过 next 和 prev 分别指向后继和前驱节点。同时为了可以快速找到 整个链表的头节点，于是额外定义了一个数据结构(sk_buff_head)作为链表的头部节点。然后要求每个sk_buff节点都预留一个字段指向sk_buff_head，这样就可以保证无论当前访问的是哪个节点都可以快速找到链表头。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202606579.png" alt="image-20240828202606579"></p><h3 id="sk-buff数据结构">sk_buff数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> &#123;</span></span><br><span class="line"> <span class="comment">/* These two members must be first. */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">next</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"> __u32  qlen;   <span class="comment">//表示链表中的节点数</span></span><br><span class="line"> <span class="type">spinlock_t</span> lock; <span class="comment">//用作多线程同步</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="comment">/* These two members must be first to match sk_buff_head. */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>  *<span class="title">next</span>;</span> <span class="comment">//后续节点</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>  *<span class="title">prev</span>;</span> <span class="comment">//前序节点</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span> <span class="comment">//记录接受或发送报文的网络设备</span></span><br><span class="line">    <span class="comment">/* Some protocols might use this space to store information,</span></span><br><span class="line"><span class="comment">     * while device pointer would be NULL.</span></span><br><span class="line"><span class="comment">     * UDP receive path is one user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  dev_scratch;</span><br><span class="line">   &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">//指向头节点</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>  *<span class="title">sk</span>;</span> <span class="comment">//报文所属的套接字</span></span><br><span class="line">  <span class="type">int</span>   ip_defrag_offset;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">ktime_t</span>  tstamp; <span class="comment">//报文时间戳</span></span><br><span class="line">  u64  skb_mstamp_ns; <span class="comment">/* earliest departure time */</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">  __u16   transport_header; <span class="comment">//指向传输层协议首部的起始。</span></span><br><span class="line"> __u16   network_header; <span class="comment">//指向网络层协议首部的开始。</span></span><br><span class="line"> __u16   mac_header; <span class="comment">//指向 MAC 协议首部的开始。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">sk_buff_data_t</span>  tail;</span><br><span class="line"> <span class="type">sk_buff_data_t</span>  end;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span>    *head,*data;</span><br></pre></td></tr></table></figure><h3 id="sk-buff分段"><strong>sk_buff分段</strong></h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202634290.png" alt="image-20240828202634290"></p><p>sk_buff 通过head，data，tail，end 将缓存空间分成不同的部分。</p><ul><li>head，end指向已经分配的缓存空间的头和尾。</li><li>data，tail指向实际数据的头和尾。</li></ul><p>其中每层(数据链路、网络、传输。。。)data，tail 之间设置自己对应的协议头，然后可以在对应的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__<span class="type">u16</span>   transport_header; <span class="comment">//指向传输层协议首部的起始。</span></span><br><span class="line">__<span class="type">u16</span>   network_header; <span class="comment">//指向网络层协议首部的开始。</span></span><br><span class="line">__<span class="type">u16</span>   mac_header; <span class="comment">//指向 MAC 协议首部的开始。</span></span><br></pre></td></tr></table></figure><p>字段中设置对应起始位置。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202652321.png" alt=""></p><h3 id="sk-buff初始化时">sk_buff初始化时</h3><p>linux使用 alloc_skb初始化sk_buff，函数定义在 net/core/skbuff.c 中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202721247.png" alt="image-20240828202721247"></p><p>head、data、tail初始化的时候都是重合的，指向缓存区开头。</p><h3 id="发送数据时sk-buff变化"><strong>发送数据时sk_buff变化</strong></h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202740246.png" alt="image-20240828202740246"></p><ol><li>当要求 TCP 传输某些数据时，它会按照某些条件（TCP Max Segment Size(mss)，对分散收集 I/O 支持等）分配一个缓冲区。</li><li>TCP 在缓冲区的头部保留（通过调用 skb_reserve）足够的空间，以容纳所有层（TCP，IP，Link 层）的所有协议头。参数 MAX_TCP_HEADER 是所有级别的所有协议头的总和。</li><li>TCP 的 payload （应用层传输的数据）被复制到缓冲区中。</li><li>TCP 层添加它的协议头。</li><li>TCP 层将缓冲区移交给 IP 层，IP层也添加协议头。</li><li>IP 层将缓冲区移交给下一层，下一层也添加它的协议头。</li></ol><p>再添加报文协议头时，也会同时对</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__<span class="type">u16</span>   transport_header; <span class="comment">//指向传输层协议首部的起始。</span></span><br><span class="line">__<span class="type">u16</span>   network_header; <span class="comment">//指向网络层协议首部的开始。</span></span><br><span class="line">__<span class="type">u16</span>   mac_header; <span class="comment">//指向 MAC 协议首部的开始。</span></span><br></pre></td></tr></table></figure><p>赋予对应的值</p><h3 id="接收数据时sk-buff变化">接收数据时sk_buff变化</h3><p>由于直接移动指针比复制数据更加高效，所以当数据报文从下往上传递时，只需要移动对应指针就可以丢弃上一层的协议头。例如：报文从L2(数据链路层)-&gt;L3(IP层)时，只需要移动data指针就可以丢弃数据链路层的协议头，更加高效。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828202759006.png" alt="image-20240828202759006"></p><ul><li>深入理解Linux网络技术内幕（文中的图大部分来自该书）</li><li>Linux 内核源码剖析:TCP/IP实现</li></ul><p>本文转载自：<a href="https://mp.weixin.qq.com/s/gVYdRWCoQwpFtsKXMyIHRg">Linux是怎么从网络上接收数据包的</a></p><p>补充：io_uring</p><p><a href="https://arthurchiao.art/blog/intro-to-io-uring-zh/">[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）</a></p><p><a href="https://arthurchiao.art/blog/intro-to-io-uring-zh/">https://arthurchiao.art/blog/intro-to-io-uring-zh/</a></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240828205345500.png" alt="image-20240828205345500"></p><ul><li>应用程序提交的IO 请求会直接进入submission queue 队列的尾部，内核进程会不断的从SQ 队列的头部消费请求</li><li>内核处理完的SQ后会更新CQ  tail 部分 ，应用程序读取到CQ 的head时，会更新CQ的head</li><li>SQ 中的任务称之为 SQE（entry）, CQ中的任务称之为CQE</li></ul><p><strong>三种工作模式</strong></p><p><strong>内核轮询模式</strong></p><ol><li><strong>内核线程</strong>：当使用 <code>io_uring</code> 时，系统会创建一个内核线程来处理提交的 I/O 请求（SQE），并轮询新的请求。</li><li><strong>轮询工作</strong>：应用程序无需切换到内核态，就能触发 I/O 操作。应用通过 <code>mmap</code> 映射共享内存区，更新提交队列（SQ）以提交请求。</li><li><strong>提交和收割</strong>：应用程序通过更新 SQE 来提交 I/O，请求完成后，内核会将结果放入完成队列（CQ）。应用程序可以通过轮询 CQ 来收割 I/O 结果，而无需进行系统调用。【io_uring 的提交和收割过程确实是通过 mmap 实现的】</li><li><strong>空闲状态</strong>：如果内核线程在处理 I/O 请求时空闲时间超过用户定义的阈值，它会通知应用程序，然后进入空闲状态。这时，应用程序需要调用 <code>io_uring_enter()</code> 来唤醒内核线程。</li><li><strong>忙碌状态</strong>：如果 I/O 请求一直较为繁忙，内核线程将持续运行，并不会进入休眠状态。</li></ol><p><strong>优势：</strong></p><ol><li>Mmap 机制减少了 内存复制</li><li>内核轮询模式下，没有用户态和内核态的切换降低了损耗</li><li>基于SQ和CQ 机制下的数据竞争消除，即没有并发竞争损</li></ol>]]></content>
    
    
    <summary type="html">Linux接收网络数据包全过程</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>动态库搜索路径</title>
    <link href="https://penge666.github.io/posts/7c160fcc.html"/>
    <id>https://penge666.github.io/posts/7c160fcc.html</id>
    <published>2024-07-25T09:10:51.000Z</published>
    <updated>2024-08-24T08:26:51.484Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：之前在503的时候经常因为动态库找不到而烦恼，今天这篇文章就对其查找顺序简单梳理下 ~~~</p><p>在 Linux 系统中，指定动态库搜索路径有多种方法，以下是五种常用的方法及它们的优先级顺序（从高到低）</p><p>针对一个程序想知道使用 <code>ldd</code> 命令来查看一个可执行文件或共享库的依赖库，并检查这些库是否能够正确加载。</p><h2 id="动态库路径">动态库路径</h2><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">✘ ⚙ penge@penge-virtual-machine  ~/Desktop/test  ldd ./main</span><br><span class="line">       linux-vdso.so.1 (0x00007ffc160f8000)</span><br><span class="line">       libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f4855d57000)</span><br><span class="line">       libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f4855d32000)</span><br><span class="line">       libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4855d0f000)</span><br><span class="line">       libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4855b1d000)</span><br><span class="line">       libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f48559ce000)</span><br><span class="line">       /lib64/ld-linux-x86-64.so.2 (0x00007f4855fe6000)</span><br></pre></td></tr></table></figure><p>这些动态库的信息在**<code>.dynamic</code> 段**。</p><p><strong>在程序启动时指定（<code>LD_PRELOAD</code> 环境变量）</strong></p><ul><li>优先级最高。使用 <code>LD_PRELOAD</code> 可以强制程序优先加载指定的动态库，而不是使用程序默认链接的库。这对于调试或替换特定库非常有用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=/path/to/custom/library.so ./your_program</span><br></pre></td></tr></table></figure><p><strong>在程序启动时指定（<code>LD_LIBRARY_PATH</code> 环境变量）</strong></p><ul><li><code>LD_LIBRARY_PATH</code> 环境变量指定了动态链接器在运行时应该优先搜索的动态库路径。它覆盖默认路径，但低于 <code>LD_PRELOAD</code> 的优先级。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/custom/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./your_program</span><br></pre></td></tr></table></figure><p>【特别注意】：</p><p><strong><code>LD_LIBRARY_PATH</code> 的设置只对当前 shell 会话以及从这个 shell 启动的子进程有效</strong>。如果你在一个新的终端或 shell 会话中，需要重新设置 <code>LD_LIBRARY_PATH</code>，或者将其设置到用户的环境配置文件中（如 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code>）以使其永久生效。</p><blockquote><p><strong>.bashrc文件介绍</strong></p></blockquote><p>.bashrc，属于一种系统隐藏文件，.bashrc就是这个终端里面指令运行的<strong>配置脚本</strong>。</p><p>当我们要配置.bashrc时，可以通过 nano 或者 vi / vim指令对.bashrc进行编辑，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br><span class="line">vim ~/.bashrc</span><br><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure><p>对bashrc做出任何的修改，都<strong>将会在下一次启动终端时候生效</strong>。如果希望<strong>立即生效</strong>，可以执行source指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>在链接时指定（<code>-rpath</code> 编译选项）</strong></p><ul><li><code>-rpath</code> 是在编译时指定的选项，用于指定程序在运行时搜索动态库的路径。<code>-rpath</code> 的优先级高于默认路径和 <code>/etc/ld.so.conf</code> 配置的路径，但低于 <code>LD_LIBRARY_PATH</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -Wl,-rpath,/path/to/custom/libs</span><br></pre></td></tr></table></figure><p><strong>在系统配置中指定（<code>/etc/ld.so.conf</code> 和 <code>/etc/ld.so.conf.d/</code>）</strong></p><ul><li>通过修改 <code>/etc/ld.so.conf</code> 文件或在 <code>/etc/ld.so.conf.d/</code> 目录中添加配置文件，可以指定系统全局的动态库搜索路径。<strong>需要在修改配置后运行 <code>ldconfig</code> 命令来更新缓存。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/path/to/custom/libs&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/ld.so.conf.d/custom.conf</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><ol><li><p><strong>默认搜索路径</strong></p><ul><li><p>如果没有通过上述方法指定，系统会按照默认路径来搜索动态库，通常包括 <code>/lib</code>, <code>/usr/lib</code>, <code>/lib64</code>, <code>/usr/lib64</code> 等目录。</p></li><li><p>直接运行程序即可，系统会根据默认路径加载动态库。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./your_program</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>/etc/ld.so.conf</strong></p></blockquote><p><code>/etc/ld.so.conf</code> 是系统全局配置文件，通常位于 <code>/etc/</code> 目录下。它由系统管理员或安装包的脚本配置，用来为所有用户和进程设置额外的动态库搜索路径。</p><p>文件的内容是由每行一个路径组成的列表，每个路径代表一个要添加到动态链接器搜索路径中的目录。路径可以是绝对路径，也可以是包含变量的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib</span><br><span class="line">/opt/custom/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br></pre></td></tr></table></figure><p>上面的示例将 <code>/usr/local/lib</code>、<code>/opt/custom/lib</code> 和 <code>/usr/lib/x86_64-linux-gnu</code> 添加到系统的动态库搜索路径中。</p><p><strong>包含其他配置文件</strong></p><p><code>/etc/ld.so.conf</code> 文件还可以包含对其他配置文件的引用，这通常通过 <code>include</code> 关键字实现。这允许将不同的路径配置分离到多个文件中，便于管理。</p><p><strong>示例</strong>：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span>.<span class="keyword">d</span><span class="comment">/*.conf</span></span><br></pre></td></tr></table></figure><p>这行配置会将 <code>/etc/ld.so.conf.d/</code> 目录下所有以 <code>.conf</code> 结尾的文件中的路径添加到动态链接器的搜索路径中。</p><p><strong>补充：</strong></p><p>动态链接库的大致过程介绍</p><p><strong>1.ELF 文件与 <a href="http://ld.so">ld.so</a> 的启动</strong></p><p>用户执行一个使用动态库的程序时，内核通过解析 ELF 文件的 Program Header 表来找到并启动 <code>ld.so</code> 动态链接器。</p><p>使用 <code>readelf</code> 工具查看 ELF 文件中的 Program Header</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l /bin/ls</span><br></pre></td></tr></table></figure><p>在输出中，可以看到包含动态段的入口，如 <code>.interp</code> 段，该段指定了动态链接器的位置（如 <code>/lib64/ld-linux-x86-64.so.2</code>）。</p><p><strong>2.动态库的查找过程</strong></p><p>去.dymaic查看所需的动态库！</p><p><code>ld.so</code> 在加载可执行文件后，会根据多种方式查找所依赖的动态库，具体顺序如下：</p><ul><li><strong><code>LD_PRELOAD</code></strong>: 优先加载由 <code>LD_PRELOAD</code> 环境变量指定的库。</li><li><strong><code>LD_LIBRARY_PATH</code></strong>: 然后查找由 <code>LD_LIBRARY_PATH</code> 环境变量指定的路径。</li><li><strong><code>rpath</code> 和 <code>runpath</code></strong>: ELF 文件中指定的库搜索路径。</li><li><strong><code>/etc/ld.so.conf</code> 和 <code>ld.so.cache</code></strong>: 全局配置的库路径。</li><li><strong>默认路径</strong>: 系统默认的 <code>/lib</code>、<code>/usr/lib</code> 等路径。</li></ul><p><strong>3. 符号解析与重定位</strong></p><p><code>ld.so</code> 在加载库后，负责解析这些库中的符号（如函数和全局变量），并进行重定位，使得程序可以正确调用库中的函数或访问库中的数据。</p><ul><li><strong>符号表</strong>：<code>ld.so</code> 从 ELF 文件中的 <code>.dynsym</code> 段加载符号表，并根据符号名在所有加载的库中查找对应的符号地址。</li><li><strong>重定位</strong>：对于未确定的地址（符号位置），<code>ld.so</code> 根据实际加载库的内存地址对其进行重定位。</li></ul><p><strong>例子</strong>：使用 GDB 查看符号表和重定位条目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb /usr/bin/curl</span><br><span class="line">(gdb) info <span class="built_in">functions</span>  <span class="comment"># 查看所有函数符号</span></span><br><span class="line">(gdb) info variables  <span class="comment"># 查看所有变量符号</span></span><br></pre></td></tr></table></figure><p><strong>4. 延迟绑定（Lazy Binding）</strong></p><p>为了提升性能，<code>ld.so</code> 采用延迟绑定机制，只有在函数首次调用时才进行符号解析。这种方式减少了程序启动时的开销。</p><ul><li><strong>PLT（Procedure Linkage Table）</strong>：用于实现延迟绑定的表，每次函数调用时，先跳转到 PLT 表中的入口，该入口再调用动态链接器解析函数的实际地址。</li><li><strong>GOT（Global Offset Table）</strong>：保存已解析的函数地址，当再次调用时，直接从 GOT 中获取函数地址，避免重复解析。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d -j .plt /usr/bin/curl</span><br></pre></td></tr></table></figure><p><strong>objdump命令</strong>是用查看目标文件或者可执行的目标文件的构成的gcc工具。</p><p><strong>补充：linux程序启动</strong></p><p>Linux操作系统下应用程序的启动过程和Win32有类似之处，在 Linux 下应用程序加载和执行的具体步骤如下。</p><p>第1步:用户在 linux命令终端中输入运行程序的命令，然后按回车键。</p><p>第2步:首先接管的是 exec系统调用，它会为应用程序的运行准备一些环境变量等，并且为运行的命令找到相应的解释器。</p><p>第3步:通常应用程序的解释器就是ld (loader/加载器)，ld接管控制权后首先需要读入这个可执行程序的文件的一部分，包括文件头及共享对象(so，对应于Windows下的动态链接库）区等。然后检查这个可执行文件所依赖的共享对象so（这些信息都在可执行文件中)，并且在 LD_LIBRARY_PATH和系统默认库文件夹的位置查找这些库是否存在。如果不存在，则报告错误并退出执行。</p><p>第4步:针对每一个依赖的库，ld需要首先读入这个so的一部分文件头和相关信息。然后递归查找该共享对象所依赖的其他共享对象，直到最底层。在这个过程中，ld 会在内部维护一个数据结构用来记录所有这些共享对象之间的相互依赖关系。最终，ld会确认所有的该可执行程序直接或间接依赖的so都存在。</p><p>第5步:ld会把所有依赖的so映射到该程序的进程空间的虚拟内存中(只是映射，并不是把全部 so文件的内容读入内存)。显然，每一个共享对象在该进程的虚拟内存空间中占据不同的连续区域。它们的“基地址”各不相同，从而其内部的一些用绝对地址表示的符号需要做出相应的修改。这个过程称为“relocation过程”。</p><p>第6步:初始化应用程序的全局变量，对于全局对象自动调用构造函数。第7步:进入main函数开始执行。</p><h2 id="优化动态库">优化动态库</h2><h3 id="减少动态链接库的数量">减少动态链接库的数量</h3><p>减少动态链接库的数量是提高程序启动性能的一个重要原则，是构造大型应用程序时需要考虑的首要问题。例如<strong>微软的Office 套件程序启动时只需要两个动态链接库</strong>。根据实践经验，如果一个应用程序启动时需要加载的动态链接库达到数十个，则把这些动态库的数量减少到10个以内，至少可以提高启动性能达15%。在性能优化工程实践中，减少应用程序启动时需要加载的动态链接库数量可以通过如下两种方法来实现。</p><p>1.修改代码</p><p>2.合并动态库</p><p>把功能相近或者依赖关系密切的动态库合并成一个库。我认为是减少读盘次数</p><h3 id="减小动态链接库尺寸">减小动态链接库尺寸</h3><p>使用 <code>strip</code> 命令:</p><ul><li><p><code>strip</code> 命令可以从目标文件或者可执行文件中<strong>删除符号表信息</strong>,从而减小文件大小。</p></li><li><p>示例命令:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strip -s libfoo.so</span><br></pre></td></tr></table></figure></li><li><p>这将从 <code>libfoo.so</code> 动态库中删除符号表信息,从而缩小文件大小。</p></li></ul><p>原理</p><ol><li>可执行程序在链接时,只需要使用动态库中的符号信息,而不需要完整的符号表信息。</li><li>当可执行程序在运行时,需要动态加载动态库并解析其中的符号信息。即使动态库中没有完整的符号表信息,但仍然可以正确解析所需的符号。</li></ol><p>所以通常情况下,使用 <code>strip -s</code> 命令删除动态库中的符号表信息,不会影响该动态库的正常使用。这种方式可以有效地减小动态库的文件大小,而不会影响应用程序的正常运行。</p>]]></content>
    
    
    <summary type="html">动态库搜索路径</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议学习</title>
    <link href="https://penge666.github.io/posts/61c8c4f5.html"/>
    <id>https://penge666.github.io/posts/61c8c4f5.html</id>
    <published>2024-07-22T09:01:48.000Z</published>
    <updated>2024-09-15T11:18:35.855Z</updated>
    
    <content type="html"><![CDATA[<p>人之生也，与忧患俱来，知其无可奈何，而安之若命。</p><h3 id="1、QUIC-简介"><strong>1、QUIC 简介</strong></h3><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171232702.png" alt="image-20240722171232702"></p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h3 id="2、QUIC-实现原理"><strong>2、QUIC 实现原理</strong></h3><h4 id="2-1、数据格式"><strong>2.1、数据格式</strong></h4><p>一个 QUIC 数据包的格式如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171314750.png" alt="image-20240722171314750"></p><p>由 header 和 data 两部分组成。</p><p>header 是明文的，包含 4 个字段：Flags、Connection ID、QUIC Version、Packet Number；</p><p>data 是加密的，可以包含 1 个或多个 frame，每个 frame 又分为 type 和 payload，其中 payload 就是应用数据；</p><p>数据帧有很多类型：Stream、ACK、Padding、Window_Update、Blocked 等，这里重点介绍下用于传输应用数据的 Stream 帧。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171320083.png" alt="image-20240722171320083"></p><p><strong>Frame Type：</strong> 帧类型，占用 1 个字节</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171324906.png" alt="image-20240722171324906"></p><p>（1）Bit7：必须设置为 1，表示 Stream 帧</p><p>（2）Bit6：如果设置为 1，表示发送端在这个 stream 上已经结束发送数据，流将处于半关闭状态</p><p>（3）Bit5：如果设置为 1，表示 Stream 头中包含 Data length 字段</p><p>（4）Bit432：表示 offset 的长度。000 表示 0 字节，001 表示 2 字节，010 表示 3 字节，以此类推</p><p>（5）Bit10：表示 Stream ID 的长度。00 表示 1 字节，01 表示 2 字节，10 表示 3 字节，11 表示 4 字节</p><p><strong>Stream ID：</strong> 流 ID，用于标识数据包所属的流。后面的流量控制和多路复用会涉及到</p><p>**Offset：**偏移量，表示该数据包在整个数据中的偏移量，用于数据排序。</p><p><strong>Data Length：</strong> 数据长度，占用 2 个字节，表示实际应用数据的长度</p><p><strong>Data：</strong> 实际的应用数据</p><h4 id="2-2、建立连接"><strong>2.2、建立连接</strong></h4><p>先分析下 HTTPS 的握手过程，包含 TCP 握手和 TLS 握手，TCP 握手：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171428707.png" alt="image-20240722171428707"></p><p>从图中可以看出，TCP 握手需要 2 个 RTT。</p><p>TLS 握手：密钥协商（1.3 版本）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171450629.png" alt="image-20240722171450629"></p><p>从图中可以看出，TLS 握手需要 1 个 RTT，也就是 1 次 RTT 就把通信密钥协商好了，这是怎么做到的？</p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）服务器：生成随机数 b，计算 B=b*G%P，将 B 发送给客户端，也就是 Server Hello 消息</p><p>（3）客户端：使用 ECDH 算法生成通信密钥 KEY = a * B = a * b * G%P</p><p>（4）服务器：使用 ECDH 算法生成通信密钥 KEY = b * A = b * a * G%P</p><p>所以，这里的关键就是 ECDH 算法，a 和 b 是客户端和服务器的私钥，是不公开的，而其他参数是公开的。ECDH 算法有个非常重要的特征：即使知道 A、G、P，通过 A = a*G%P 公式也是无法推到出 a 的，保证了私钥的安全性。</p><p>综上所述，HTTPS 建立连接需要 3 个 RTT，由于 QUIC 的握手是基于 TLS1.3 实现的，所以首次建立连接时也是需要 1 次 RTT，那 QUIC 是如何做到 0-RTT 握手的呢？</p><h5 id="2-2-1、0-RTT-握手"><strong>2.2.1、0-RTT 握手</strong></h5><p>其实原理很简单：客户端缓存了 ServerConfig（B=b*G%P），下次建连直接使用缓存数据计算通信密钥：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171543971.png" alt="image-20240722171543971"></p><p>（1）客户端：生成随机数 c，选择公开的大数 G 和 P，计算 A=c*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算通信密钥 KEY = c <em>B =  c * b</em>G%P，加密发送应用数据</p><p>（3）服务器：根据 Client Hello 消息计算通信密钥 KEY = b * A = b * c*G%P</p><p>也就是说，客户端不需要经过握手就可以发送应用数据，这就是 0-RTT 握手。再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数（A1=a * G%P，A2=c * G%P，…），一旦服务器的随机数 b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。</p><p>为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性</p><h5 id="2-2-2、前向安全"><strong>2.2.2、前向安全</strong></h5><p>前向安全：是指用来产生会话密钥的长期密钥泄露出去，不会泄漏以前的通讯内容。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171728670.png" alt="image-20240722171728670"></p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算初始密钥 initKey = a<em>B = a</em>b*G%P，加密发送应用数据 1</p><p>（3）服务器：根据 Client Hello 消息计算初始密钥 initKey = b<em>A = b</em>a*G%P</p><p>（4）服务器：生成随机数 c，计算 C=c*G%P，使用 initKey 加密 C，发送给客户端，也就是 Server Hello 消息</p><p>（5）客户端：使用 initKey 解码获取 C，计算会话密钥 sessionKey = a<em>C = a</em>c*G%P，加密发送应用数据 2</p><p>（6）服务器：计算会话密钥 sessionKey = c<em>A = c</em>a*G%P，解密获取应用数据 2</p><p>客户端缓存的 ServerConfig 是服务器静态配置的，是可以长期使用的。客户端通过 ServerConfig 实现 0-RTT 握手，使用会话密钥 sessionKey 保证通信数据的前向安全。</p><p><strong>详细解释：</strong></p><p>为了让前向安全的过程更加通俗易懂，我们可以将它与一个简单的比喻结合起来。这种机制可以确保即使某个时刻的密钥泄露，也不会影响之前的通信安全。我们可以将这个过程想象成两个朋友（客户端和服务器）在通信时进行的秘密交换：</p><ol><li><p><strong>客户端生成随机数a，选择公开的大数G和P，计算A=a*G%P，并将A和G发送给服务器，这相当于Client Hello消息</strong>：</p><p>想象两个朋友A（客户端）和B（服务器）想要交换秘密信息。A生成了一个随机数a，并选择了一个共同使用的公开的“大数”G和P。A计算了一个值A=a*G%P，并将这个值A和大数G发送给B。这就像A告诉B：“这是我的公开信息。”</p></li><li><p><strong>客户端使用缓存的ServerConfig计算初始密钥initKey=aB=ab*G%P，并加密发送应用数据1</strong>：</p><p>A使用之前存储的服务器配置信息（ServerConfig）计算一个初始密钥initKey=a*B，其中B是服务器的公开信息。然后，A使用这个初始密钥来加密一些信息，并将其发送给B。</p></li><li><p><strong>服务器根据Client Hello消息计算初始密钥initKey=bA=ba*G%P</strong>：</p><p>B收到A的公开信息后，也生成了一个随机数b。B使用这个随机数和A发送的公开信息计算了同样的初始密钥initKey=b*A。这样，A和B现在都有了一个相同的初始密钥。</p></li><li><p><strong>服务器生成随机数c，计算C=c*G%P，使用initKey加密C，发送给客户端，即Server Hello消息</strong>：</p><p>B生成另一个随机数c，并计算一个新的值C=c*G%P。B使用之前计算的初始密钥initKey加密这个新值C，然后将加密后的C发送给A。这就像B告诉A：“这是我生成的新秘密信息，但你需要用我们的初始密钥来解密它。”</p></li><li><p><strong>客户端使用initKey解码获取C，计算会话密钥sessionKey=aC=ac*G%P，并加密发送应用数据2</strong>：</p><p>A使用初始密钥解密B发送的C，然后计算一个新的会话密钥sessionKey=a*C。A使用这个会话密钥来加密新的信息，并将其发送给B。</p></li><li><p><strong>服务器计算会话密钥sessionKey=cA=ca*G%P，解密获取应用数据2</strong>：</p><p>B也使用C和A发送的公开信息计算同样的会话密钥sessionKey=c*A。然后，B使用这个会话密钥来解密A发送的加密信息。</p></li></ol><p>通过这个过程，客户端和服务器能够在不暴露各自秘密的情况下生成相同的会话密钥，从而确保通信的前向安全。这意味着即使未来某个密钥被泄露，也不会影响之前的通信内容的安全性。</p><h4 id="2-3、可靠传输"><strong>2.3、可靠传输</strong></h4><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171841278.png" alt="image-20240722171841278"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN = 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN=4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN=2）和重传的数据包（PKN=4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171905289.png" alt="image-20240722171905289"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h4 id="2-4、流量控制"><strong>2.4、流量控制</strong></h4><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171922763.png" alt="image-20240722171922763"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171935952.png" alt="image-20240722171935952"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722171947478.png" alt="image-20240722171947478"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 = 60</p><h4 id="2-5、拥塞控制"><strong>2.5、拥塞控制</strong></h4><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd = min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h5 id="2-5-1、慢启动"><strong>2.5.1、慢启动</strong></h5><p>初始拥塞窗口大小 cwnd=1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS = 1500（MTU）- 20（IP 首部）- 8（UDP 首部） = 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets <span class="operator">=</span> <span class="number">2000</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;= ssthresh</strong> 时，使用拥塞避免算法</li></ul><h5 id="2-5-2、拥塞避免"><strong>2.5.2、拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1/cwnd</p><p>假设现在的 cwnd=8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h5 id="2-5-3、拥塞发生"><strong>2.5.3、拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = 1</li></ul><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd = cwnd / 2</li><li>ssthresh = cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h5 id="2-5-4、快速恢复"><strong>2.5.4、快速恢复</strong></h5><p>快速恢复算法：cwnd = ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><h5 id="2-5-5、常见算法"><strong>2.5.5、常见算法</strong></h5><ul><li>New Reno：基于丢包检测</li><li>CUBIC：基于丢包检测</li><li>BBR：基于网络带宽</li></ul><p>和 TCP 不同的是，QUIC 是在用户空间实现的拥塞控制，可以非常灵活的设置，甚至可以为每一个请求都设置一种拥塞控制算法。</p><h4 id="2-6、多路复用"><strong>2.6、多路复用</strong></h4><p>多路复用是 HTTP/2 的主要特性之一。</p><p>概念：单条 TCP 连接上可以同时发送多个 HTTP 请求，解决了 HTTP1.1 中单个连接 1 次只能发送 1 个请求的性能瓶颈。<strong>HTTP/2 能实现多路复用的根本原因是采用了二进制帧格式的数据结构</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172100507.png" alt="image-20240722172100507"></p><ul><li>Length：表示 Payload 的长度</li><li>Type：表示帧类型</li><li>Flags：帧标识</li><li>Stream ID：数据帧所属的流</li><li>Payload：应用数据，长度由 Length 字段指定</li></ul><p>一个请求就对应一条流，通过 Stream ID 就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID 分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172118432.png" alt="image-20240722172118432"></p><p>虽然在 HTTP 应用层，可以同时发送多个请求，但是在 TCP 传输层，仍然只有 1 个滑动窗口来发送这些数据包，考虑下面的情形：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172132726.png" alt="image-20240722172132726"></p><p>客户端发送的 5 个数据包（56789）服务器都收到了，并且回应了 5 个 ACK，但是第 5 个数据包的 ACK 丢失了，导致客户端的发送窗口无法向前移动，也就无法发送新的数据，这就是 TCP 层的队头阻塞问题。</p><p>HTTP/2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞。那 QUIC 是如何解决 TCP 层的队头阻塞问题的呢？其实很简单，HTTP/2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口**，那如果给每个请求流都分配一个独立的滑动窗口**，是不是就可以解决这个问题了？</p><p>QUIC 就是这么做的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172143472.png" alt="image-20240722172143472"></p><p>A 请求流上的丢包不会影响 B 请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然 QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC 声明的无队头阻塞的多路复用。</p><h4 id="2-7、连接迁移"><strong>2.7、连接迁移</strong></h4><p>连接迁移：<strong>当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信</strong>，对于 TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源 IP、源端口、目的 IP、目的端口，只要其中 1 个发生变化，就需要重新建立连接。但 QUIC 的连接是基于 64 位的 Connection ID，网络切换并不会影响 Connection ID 的变化，连接在逻辑上仍然是通的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240722172203987.png" alt="image-20240722172203987"></p><p>假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为 IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID 字段可以判断这 4 个包是来自于同一个客户端。QUIC 能实现连接迁移的根本原因是底层使用 UDP 协议就是面向无连接的。</p><p>补充：<strong>Connection ID</strong>：每个QUIC连接都有一个唯一的Connection ID。当客户端和服务器建立连接时，它们交换并存储彼此的Connection ID！</p><h3 id="3、QUIC-小结"><strong>3、QUIC 小结</strong></h3><p>本文尽量用通俗易懂的语言介绍了 QUIC 协议实现原理，目的是让大家对 QUIC 有一个基本的了解，当然，这只是 QUIC 协议的冰山一角，更详细具体的内部实现还需要深入研究标准文档和源码，如果文中有描述不对的地方，欢迎批评指正，多多交流</p><p>本文学习自:<a href="https://zhuanlan.zhihu.com/p/405387352">QUIC 协议详解</a></p>]]></content>
    
    
    <summary type="html">QUIC 协议详解</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-多级反馈队列</title>
    <link href="https://penge666.github.io/posts/40ab952d.html"/>
    <id>https://penge666.github.io/posts/40ab952d.html</id>
    <published>2024-07-18T14:04:26.000Z</published>
    <updated>2024-09-21T11:53:23.336Z</updated>
    
    <content type="html"><![CDATA[<p>春秋时期 远近知名伯牙琴艺</p><p>沉鱼也出水 马儿仰秣聆听</p><p>聆听 寂寞 的声音</p><p>举世知名 不如 一个知音</p><p>直到子期 闻琴解开伯牙心境</p><p>高山流水 风景似有灵悉</p><p>高山青 流水静 如镜</p><p>无言却胜过有言的天地</p><p>-《伯牙绝弦》</p><p>致一位十年的好友，兄弟，哥们。一路走好！</p><p>进程调度有一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。</p><blockquote><p><strong>提示：从历史中学习</strong></p><p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。</p></blockquote><h2 id="MLFQ：基本规则">MLFQ：基本规则</h2><p>MLFQ 中有许多独立的<code>队列</code>（queue），每个队列有不同的<code>优先级</code>（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是<strong>优先执行较高优先级</strong>的工作（即在<strong>较高级队列</strong>中的工作）。对于同一个队列中的任务，采用<code>轮转调度</code>。</p><p><code>MLFQ</code>中工作优先级并不是固定的，而是会根据进程的行为<code>动态调整优先级</code>。例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是<strong>交互型进程</strong>的可能行为，MLFQ 因此会让它保持<strong>高优先级</strong>。相反，如果一个工作<strong>长时间地占用</strong> CPU，MLFQ 会<strong>降低其优先级</strong>。</p><p>MLFQ 的两条基本规则:</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</li><li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B 。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806222225344.png" alt="image-20240806222225344"></p><h2 id="尝试-1：如何改变优先级">尝试 1：如何改变优先级</h2><p>我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有<strong>运行时间很短</strong>、<strong>频繁放弃 CPU</strong> 的<code>交互型工作</code>，也有需要<strong>很多 CPU 时间</strong>、<strong>响应时间却不重要</strong>的长时间<code>计算密集型工作</code>。下面是我们第一次尝试优先级调整算法。</p><ul><li><strong>规则 3</strong> ：工作进入系统时，放在最高优先级（最上层队列）。</li><li><strong>规则 4a</strong>：工作用完整个时间片后，降低其优先级（移入下一个队列）。</li><li><strong>规则 4b</strong>：如果工作在其时间片以内主动释放 CPU，则优先级不变。</li></ul><h3 id="实例-1：单个长工作">实例 1：单个长工作</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221138198.png" alt="image-20240806221138198"></p><p>从这个例子可以看出，该工作首先进入最高优先级（Q2）。执行一个 10ms 的时间片后，调度程序将工作的优先级减 1，因此进入 Q1。在 Q1 执行一个时间片后，最终降低优先级进入系统的最低优先级（Q0），并一直留在那里。</p><h3 id="实例-2：加入一个短工作">实例 2：加入一个短工作</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221310794.png" alt="image-20240806221310794"></p><p>B 在 T=100 时到达</p><p>如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，<strong>MLFQ 近似于 SJF</strong>(最短任务优先)。</p><h3 id="实例-3：如果有-I-O-呢">实例 3：如果有 I/O 呢</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221321021.png" alt="image-20240806221321021"></p><p>交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O 操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交互型工作快速运行</p><h3 id="当前-MLFQ-的一些问题">当前 MLFQ 的一些问题</h3><ol><li>饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。</li><li>愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。</li><li>一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间需要作为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。因为优先级一旦下降就无法提升</li></ol><h2 id="尝试-2：提升优先级">尝试 2：提升优先级</h2><p>为解决[1]饥饿问题</p><ul><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221329792.png" alt="image-20240806221329792"></p><ol><li><strong>左边没有优先级提升</strong>，长工作在两个短工作到达后被饿死。</li><li><strong>右边每 50ms 就有一次优先级提升</strong>（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 50ms 就被提升到最高优先级，从而定期获得执行。</li></ol><p>添加时间段 S 导致了明显的问题：S 的值应该如何设置？德高望重的系统研究员 John Ousterhout 曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。</p><h2 id="尝试-3：更好的计时方式">尝试 3：更好的计时方式</h2><p>为解决[2]愚弄调度程序问题</p><p>起因是规则 4a 和 4b 不合理，调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。</p><p>重写规则 4：</p><ul><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221337806.png" alt="image-20240806221337806"></p><p>没有<strong>规则 4</strong>的保护时，进程可以在每个时间片结束前发起一次 I/O 操作，从而垄断 CPU 时间。有了这样的保护后，不论进程的 I/O 行为如何，都会慢慢地降低优先级，因而无法获得超过公平的 CPU 时间比例。同时由于<strong>规则 5</strong>的存在，原来的交互性进程还是可以在之后提升优先级。</p><h2 id="MLFQ-调优及其他问题">MLFQ 调优及其他问题</h2><p>关于 MLFQ 调度算法还有一些问题。其中一个大问题是<strong>如何配置</strong>一个调度程序，例如：</p><ol><li>配置多少队列？</li><li>每一层队列的时间片配置多大？</li><li>为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</li></ol><p>这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240806221345717.png" alt="image-20240806221345717"></p><p>例如，大多数的 MLFQ 变体都支持不同队列可变的时间片长度。<strong>高优先级队列通常只有较短的时间片</strong>（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，<strong>低优先级队列</strong>中更多的是 CPU 密集型工作，配置<strong>更长的时间片</strong>会取得更好的效果。图 8.7 展示了一个例子，两个长工作在高优先级队列执行 10ms，中间队列执行 20ms，最后在最低优先级队列执行 40ms。</p><p><code>Solaris</code> 的 MLFQ 实现（<code>时分调度类 TS</code>）很容易配置。它提供了<code>一组表</code>来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级。管理员可以通过这些表，让调度程序的行为方式不同。该表默认有 60 层队列，时间片长度从 20ms（最高优先级），到几百 ms（最低优先级），每一秒左右提升一次进程的优先级。</p><p>其他一些 MLFQ 调度程序没用表，甚至没用本章中讲到的规则，有些采用数学公式来调整优先级。例如，<code>FreeBSD</code> 调度程序（4.3 版本），会基于当前进程使用了多少 CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升，但与这里描述方式不同。阅读 Epema 的论文，他漂亮地概括了这种使用量衰减（decay-usage）算法及其特征</p><p>最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的<code>建议</code>（advice），比如通过命令行工具 <code>nice</code>，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看 man 手册。</p><blockquote><p><strong>提示：尽可能多地使用建议</strong></p><p>操作系统很少知道什么策略对系统中的单个进程和每个进程算是好的，因此提供接口并允许用户或管理员给操作系统一些提示（hint）常常很有用。我们通常称之为建议（advice），因为操作系统不一定要关注它，但是可能会将建议考虑在内，以便做出更好的决定。这种用户建议的方式在操作系统中的各个领域经常十分有用，包括调度程序（通过 nice）、内存管理（madvise），以及文件系统（通知预取和缓存[P+95]）</p></blockquote><h2 id="MLFQ：小结">MLFQ：小结</h2><p>本章介绍了一种调度方式，名为<code>多级反馈队列</code>（MLFQ）。</p><p>本章包含了一组优化的 MLFQ 规则。为了方便查阅，我们重新列在这里。</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</li><li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</li><li><strong>规则 3</strong>：工作进入系统时，放在最高优先级（最上层队列）。</li><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul><p>MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ 可以同时满足各种工作的需求：<strong>对于短时间运行的交互型工作，获得类似于 SJF/STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前</strong>。因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括<code>类 BSD UNIX 系统</code>、<code>Solaris</code>以及 <code>Windows NT</code> 和其后的 <code>Window 系列操作系统</code>。</p><p>最后，关于抢占式问题总结：</p><ol><li><strong>先来先服务（First-Come, First-Served, FCFS）</strong>：<ul><li>通常是非抢占式的。进程一旦获得CPU，就会一直运行直到完成或阻塞。</li></ul></li><li><strong>短作业优先（Shortest Job First, SJF）</strong>：<ul><li>可以是抢占式的，也可以是非抢占式的。抢占式的SJF称为最短剩余时间优先（Shortest Remaining Time First, SRTF），它会在新到达的进程比当前运行进程的剩余时间更短时抢占CPU。</li></ul></li><li><strong>时间片轮转（Round Robin, RR）</strong>：<ul><li>是抢占式的。每个进程被分配一个固定的时间片，当时间片用完时，当前进程被抢占，CPU分配给队列中的下一个进程。</li></ul></li><li><strong>多级反馈队列（Multilevel Feedback Queue, MFQ）</strong>：<ul><li>是抢占式的。进程可以在不同优先级的队列之间移动，高优先级的队列中的进程可以抢占低优先级队列中的进程。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">OS-多级反馈队列MLFQ</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.081-Lab1&amp;&amp;2</title>
    <link href="https://penge666.github.io/posts/c952f7a6.html"/>
    <id>https://penge666.github.io/posts/c952f7a6.html</id>
    <published>2024-07-16T12:08:55.000Z</published>
    <updated>2024-09-20T13:22:26.322Z</updated>
    
    <content type="html"><![CDATA[<p>回过头来发现，其实人生中发生的每一件事情就和面试一样，有优点，有缺点，如果是缺点的话我们快速的将这个bug补足，不就没有这个漏洞了~</p><p>也是人生发生每一件事情的意义~</p><p>简单来说，一件事情可以让你更完完善，也就是这件事情的意义!</p><h2 id="前言">前言</h2><p>之前阅读过Linux0.11的源码，但是还是觉得远远还不够，随后入坑了这门mit6.s081. 享受lab带来的快乐~</p><h3 id="环境配置">环境配置</h3><p>网页：<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">https://pdos.csail.mit.edu/6.828/2021/tools.html</a></p><p>先说环境，笔者直接在VMWare上的Ubuntu22.04上实验的，废话少说，开干~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure><p>直接克隆即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ <span class="built_in">ls</span></span><br><span class="line">conf            gradelib.py  LICENSE   mkfs    user</span><br><span class="line">grade-lab-util  kernel       Makefile  README</span><br><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ git checkout util</span><br><span class="line">Already on <span class="string">&#x27;util&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/util&#x27;</span>.</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  make clean</span><br><span class="line"><span class="built_in">rm</span> -f *.tex *.dvi *.idx *.aux *.<span class="built_in">log</span> *.ind *.ilg \</span><br><span class="line">*/*.o */*.d */*.asm */*.sym \</span><br><span class="line">user/initcode user/initcode.out kernel/kernel fs.img \</span><br><span class="line">mkfs/mkfs .gdbinit \</span><br><span class="line">        user/usys.S \</span><br><span class="line">user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_alarmtest  user/_call user/_bttest \</span><br><span class="line">ph barrier</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  make      </span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/kalloc.o kernel/kalloc.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/string.o kernel/string.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/main.o kernel/main.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/vm.o kernel/vm.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/proc.o kernel/proc.c</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/swtch.o kernel/swtch.S</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/trampoline.o kernel/trampoline.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/trap.o kernel/trap.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/syscall.o kernel/syscall.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sysproc.o kernel/sysproc.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/bio.o kernel/bio.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/fs.o kernel/fs.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/log.o kernel/log.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sleeplock.o kernel/sleeplock.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/file.o kernel/file.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/pipe.o kernel/pipe.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/exec.o kernel/exec.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/sysfile.o kernel/sysfile.c</span><br><span class="line">riscv64-linux-gnu-gcc    -c -o kernel/kernelvec.o kernel/kernelvec.S</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/plic.o kernel/plic.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/virtio_disk.o kernel/virtio_disk.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/start.o kernel/start.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/console.o kernel/console.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/printf.o kernel/printf.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/uart.o kernel/uart.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie  -c -o kernel/spinlock.o kernel/spinlock.c</span><br><span class="line">riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_TRAPS -DLAB_TRAPS -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -march=rv64g -nostdinc -I. -Ikernel -c user/initcode.S -o user/initcode.o</span><br><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -N -e start -Ttext 0 -o user/initcode.out user/initcode.o</span><br><span class="line">riscv64-linux-gnu-objcopy -S -O binary user/initcode.out user/initcode</span><br><span class="line">riscv64-linux-gnu-objdump -S user/initcode.o &gt; user/initcode.asm</span><br><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -T kernel/kernel.ld -o kernel/kernel kernel/entry.o kernel/kalloc.o kernel/string.o kernel/main.o kernel/vm.o kernel/proc.o kernel/swtch.o kernel/trampoline.o kernel/trap.o kernel/syscall.o kernel/sysproc.o kernel/bio.o kernel/fs.o kernel/log.o kernel/sleeplock.o kernel/file.o kernel/pipe.o kernel/exec.o kernel/sysfile.o kernel/kernelvec.o kernel/plic.o kernel/virtio_disk.o kernel/start.o kernel/console.o kernel/printf.o kernel/uart.o kernel/spinlock.o</span><br><span class="line">riscv64-linux-gnu-objdump -S kernel/kernel &gt; kernel/kernel.asm</span><br><span class="line">riscv64-linux-gnu-objdump -t kernel/kernel | sed <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27;</span> &gt; kernel/kernel.sym</span><br></pre></td></tr></table></figure><p>离谱的操作</p><p><code>ctrl + p </code>可以查看当前进程</p><p><code>ctrl-a  x</code>可以退出sh（是按住ctrl还有a，松开手，再按下x，然后回车）</p><p>※ Note：退出 <code>ctrl + a 放开后，再按下x</code></p><h3 id="调试">调试</h3><p>这个方式有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch kernel/kernel</span><br><span class="line">（gdb）<span class="built_in">set</span> architecture riscv:rv64</span><br><span class="line">(gdb)target remote localhost:25000</span><br></pre></td></tr></table></figure><p>因此使用<code>riscv-unknown-elf-gdb</code>这条命令~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805213407210.png" alt="image-20240805213407210"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine:~/Desktop/OS/xv6-labs-2021$ sudo vim .gdbinit</span><br></pre></td></tr></table></figure><p>将画红框的内容加入到<code>.gdbinit</code>隐藏文件。</p><blockquote><p><strong>调试的话</strong></p></blockquote><p>一个终端开启调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  sudo make qemu-gdb</span><br><span class="line"> *** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br></pre></td></tr></table></figure><p>一个终端远程连接即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  riscv64-unknown-elf-gdb kernel/kernel</span><br><span class="line">GNU gdb (GDB) 13.1</span><br><span class="line">(gdb) target remote localhost:25000</span><br><span class="line">Remote debugging using localhost:25000</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) b main</span><br><span class="line">Note: breakpoint 1 also <span class="built_in">set</span> at pc 0x8000032e.</span><br><span class="line">Breakpoint 2 at 0x8000032e: file kernel/main.c, line 13.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at kernel/main.c:1</span><br></pre></td></tr></table></figure><p>然后就可用快乐的调试了~</p><p>Note：由于这个实验是多线程的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> CPUS</span><br><span class="line">CPUS := 1</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LAB)</span>,fs)</span><br><span class="line">CPUS := 1</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>为了调试方便，就先将这个设置成1了。</p><ul><li><a href="https://blog.csdn.net/yihuajack/article/details/116571913">xv6 2020版使用gdb调试debug的方法</a></li><li><a href="https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/">优雅的调试—在vscode上完美调试xv6（完结</a></li><li><a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">MIT 6.S081 xv6调试不完全指北</a></li><li><a href="https://github.com/monifeng/6.s081/blob/main/MIT6.s081%20gdb%E8%B0%83%E8%AF%95.md">mit6.s081 GDB调试</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># b <span class="comment">//设置断点（breakpoint）</span></span></span><br><span class="line"><span class="meta"># c <span class="comment">//继续运行（Continue）--到断点处就会停止</span></span></span><br><span class="line"><span class="meta"># n <span class="comment">//单步调试 </span></span></span><br><span class="line"><span class="meta"># p <span class="comment">//打印变量内容</span></span></span><br><span class="line"><span class="meta"># si <span class="comment">//断点定位</span></span></span><br><span class="line"><span class="meta"># display/i $pc <span class="comment">//每次停止时，都可以显示下一条指令的反汇编</span></span></span><br><span class="line"><span class="meta"># layout asm <span class="comment">//可以显示当前的汇编指令</span></span></span><br><span class="line"><span class="meta"># display /3i $pc <span class="comment">//如果您希望在单步执行程序时自动显示下3条指令,可以使用display命令</span></span></span><br><span class="line"><span class="meta"># p *path@6 <span class="comment">//这里是打印path指向的内容，打印长度为6（如果不写@6那么只能打印一个char）</span></span></span><br></pre></td></tr></table></figure><p><strong>闲话</strong>：闲着看看项目行数</p><p>统计当前目录下的所有文件行数： wc -l *</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/OS/xv6-labs-2021   traps ±  <span class="built_in">wc</span> -l *</span><br><span class="line"></span><br><span class="line">      4 answers-traps.txt</span><br><span class="line"><span class="built_in">wc</span>: conf: Is a directory</span><br><span class="line">      0 conf</span><br><span class="line">   3418 fs.img</span><br><span class="line">     70 grade-lab-traps</span><br><span class="line">    611 gradelib.py</span><br><span class="line"><span class="built_in">wc</span>: kernel: Is a directory</span><br><span class="line">      0 kernel</span><br><span class="line">     24 LICENSE</span><br><span class="line">    410 Makefile</span><br><span class="line"><span class="built_in">wc</span>: mkfs: Is a directory</span><br><span class="line">      0 mkfs</span><br><span class="line"><span class="built_in">wc</span>: __pycache__: Is a directory</span><br><span class="line">      0 __pycache__</span><br><span class="line">     47 README</span><br><span class="line"><span class="built_in">wc</span>: user: Is a directory</span><br><span class="line">      0 user</span><br><span class="line">     62 xv6.out</span><br><span class="line">   4646 total</span><br></pre></td></tr></table></figure><p>当前目录以及子目录的所有文件行数： find  . * | xargs wc -l</p><h2 id="Lab1">Lab1</h2><p>lab1就是简单的linux下编程，了解命令的含义编程即可。</p><h3 id="Boot-xv6-easy">Boot xv6 (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><p>这个就不截图了，能跑起了就好啦~</p><h3 id="sleep-easy">sleep (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><blockquote><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p></blockquote><p>简单来讲就是实现一个睡眠的程序，需要自己写在 <code>user/sleep.c</code> 里，一定要读一读实验手册里的hints，非常有用并且涉及到一些细节问题！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;args wrong!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> num = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">sleep</span>(num);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><ul><li>考虑输入为空或其他</li><li>将字符串转换为int类型</li><li>头文件的引用</li></ul><h3 id="pingpong-easy">pingpong (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">easy</a>)</h3><p>这个也不是很难</p><p><strong>实验要求</strong></p><blockquote><p>Write a program that uses UNIX system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p></blockquote><p>大义就是：用两个管道接收父子进程的数据，父进程发送一个byte，然后子进程接收后打印，然后子进程发送父进程一个byte，最后父进程打印输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> q[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(p),<span class="built_in">pipe</span>(q);</span><br><span class="line">    <span class="comment">// child </span></span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buff_child[<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// === child  first stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(p[WRITE]);</span><br><span class="line">        <span class="built_in">read</span>(p[READ],buff_child,<span class="number">6</span>);</span><br><span class="line">        <span class="type">int</span> child_pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,child_pid);</span><br><span class="line">        <span class="built_in">close</span>(p[READ]);</span><br><span class="line">        <span class="comment">// === second stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(q[READ]);</span><br><span class="line">        <span class="built_in">write</span>(q[WRITE], <span class="string">&quot;father\n&quot;</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="built_in">close</span>(q[WRITE]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> buff_fa[<span class="number">6</span>];</span><br><span class="line">        <span class="comment">// ===fa  first stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(p[READ]);</span><br><span class="line">        <span class="built_in">write</span>(p[WRITE], <span class="string">&quot;child\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">close</span>(p[WRITE]);</span><br><span class="line">        <span class="comment">// === second stage ===</span></span><br><span class="line">        <span class="built_in">close</span>(q[WRITE]);</span><br><span class="line">        <span class="built_in">read</span>(q[READ],buff_fa,<span class="number">7</span>);</span><br><span class="line">        <span class="type">int</span> fa_pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,fa_pid);</span><br><span class="line">        <span class="built_in">close</span>(q[READ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="primes-moderate-hard">primes (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">hard</a>)</h3><p><strong>实验要求</strong></p><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p></blockquote><p>用管道编写一个筛选质数的筛选器，可以参考超链接和下图：</p><p>目标是使用pipe和fork来设置管道。第一个进程将数字2到35输入到管道中。对于每个素数，您将安排创建一个进程，该进程通过一个管道从左边的邻居读取数据，并通过另一个管道向右边的邻居写入数据。由于 xv6的文件描述符和进程数量有限，因此第一个进程可以停留在35个。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805214744151.png" alt="image-20240805214744151"></p><p><strong>思路</strong></p><p>因为稍微有一点复杂，建议理一理思路后再动手。</p><p>每次将符合要求的全部传入管道中，第一个传的一定是素数，直接打印，然后将其他符合要求的再次传入管道并传给子进程。我自己的方法是递归处理，并没有完全利用到多进程的性能，如果有改进的办法，可以提出来讨论一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL (int*)0</span></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个管道</span></span><br><span class="line">    <span class="type">int</span> pipe_fa[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(pipe_fa);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> main_pid=fork();</span><br><span class="line">    <span class="comment">// 子线程</span></span><br><span class="line">    <span class="keyword">if</span>(main_pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[WRITE]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 定义子线程</span></span><br><span class="line">            <span class="type">int</span> pipe_child[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">pipe</span>(pipe_child); </span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num;</span><br><span class="line">            <span class="type">int</span> res_read = <span class="built_in">read</span>(pipe_fa[READ],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            <span class="keyword">if</span>(res_read==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            ans[cnt++]=num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,num);</span><br><span class="line">            <span class="comment">// printf(&quot;debug:answer generate%d\n&quot;,num);</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> res_read_ = <span class="built_in">read</span>(pipe_fa[READ],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                <span class="comment">// printf(&quot;debug:read num:%d res_read_:%d\n&quot;,num,res_read_);</span></span><br><span class="line">                <span class="keyword">if</span>(res_read_==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num%ans[cnt<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="built_in">write</span>(pipe_child[WRITE],&amp;num,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(pipe_child[WRITE]);</span><br><span class="line">            <span class="comment">// printf(&quot;debug:finish %d\n&quot;,num);</span></span><br><span class="line">            <span class="comment">// 循环迭代</span></span><br><span class="line">            <span class="type">int</span> pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 子线程</span></span><br><span class="line">                pipe_fa[READ] = <span class="built_in">dup</span>(pipe_child[READ]);</span><br><span class="line">                <span class="built_in">close</span>(pipe_child[READ]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 父线程</span></span><br><span class="line">                <span class="built_in">close</span>(pipe_child[READ]);</span><br><span class="line">                <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[READ]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">write</span>(pipe_fa[WRITE],&amp;i,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fa[WRITE]);</span><br><span class="line">        <span class="comment">// printf(&quot;debug:main input[2~35]\n&quot;);</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);       <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;cnt;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;,ans[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805214107322.png" alt="image-20240805214107322"></p><h2 id="Lab2">Lab2</h2><h3 id="System-call-tracing-moderate">System call tracing (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)</h3><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>在这个作业中，您将添加一个系统调用跟踪特性，它可以帮助您调试以后的实验室。您将创建一个新的跟踪系统调用来控制跟踪。它应该采用一个参数，一个整数“掩码”，其位指定哪个系统调用跟踪。例如，为了跟踪 fork 系统调用，程序调用 trace (1 &lt; &lt; SYS _ fork) ，其中 SYS _ fork 是 kernel/syscall.h 中的系统调用号。如果在掩码中设置了系统调用的编号，则必须修改 xv6内核，以便在每个系统调用即将返回时输出一行。这一行应该包含进程 id、系统调用的名称和返回值; 您不需要打印系统调用参数。跟踪系统调用应该能够跟踪调用它的进程及其随后分支的任何子进程，但不应影响其他进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ trace 2147483647 grep hello README</span><br><span class="line">4: syscall trace -&gt; 0</span><br><span class="line">4: syscall <span class="built_in">exec</span> -&gt; 3</span><br><span class="line">4: syscall open -&gt; 3</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">4: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">4: syscall close -&gt; 0</span><br><span class="line">$</span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408</span><br><span class="line">408: syscall fork -&gt; 409</span><br><span class="line">409: syscall fork -&gt; 410</span><br><span class="line">410: syscall fork -&gt; 411</span><br><span class="line">409: syscall fork -&gt; 412</span><br><span class="line">410: syscall fork -&gt; 413</span><br><span class="line">409: syscall fork -&gt; 414</span><br><span class="line">411: syscall fork -&gt; 415</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先聊下添加系统调用的步骤：</p><p>添加系统调用主要有以下几步：</p><ul><li>在user/user.h中添加系统调用函数的定义。</li><li>在user/usys.pl中添加入口，这个文件将会在make后生成user/usys.S文件，在该汇编文件中，每个函数就只有三行，将系统调用号通过li(load imm)存入a7寄存器，之后使用ecall进入内核态，最后返回。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exit</span><br></pre></td></tr></table></figure><ul><li><p>在kernel/syscall.h中定义系统调用号。</p></li><li><p>在kernel/syscall.c的syscalls函数指针数组中添加对应的函数。在syscall函数中，先读取trapframe-&gt;a7获取系统调用号，之后根据该系统调用号查找syscalls数组中的对应的处理函数并调用。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805235021773.png" alt="image-20240805235021773"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">initlock</span>(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)<span class="built_in">PGROUNDUP</span>((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    <span class="built_in">kfree</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kfree</code> 函数的主要功能是将一个内存页标记为空闲，并将其添加到空闲内存链表中。它首先检查传入的地址是否有效，然后填充内存页以捕获悬空引用，最后将内存页添加到空闲链表中，并确保操作是线程安全的。这样可以确保内存页在后续的内存分配中可以被重新使用。</p><p>整个详细流程可见：</p><ul><li><p><a href="https://juejin.cn/user/2392979529797981/posts">[mit6.s081] 笔记 Lab2: System calls | 系统调用</a></p></li><li><p><a href="https://blog.csdn.net/ahundredmile/article/details/125512247">6.S081 Lab00 xv6启动过程（从代码出发，了解操作系统启动过程）</a></p></li><li><p><a href="https://leenjewel.github.io/blog/2015/11/11/%5B%28xue-xi-xv6%29%5D-nei-he-gai-lan/">【学习Xv6】 内核概览</a></p></li><li><p><a href="https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#25-lab-2-system-calls">MIT 6.S081 Lecture Notes</a></p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240805234706950.png" alt="image-20240805234706950"></p>]]></content>
    
    
    <summary type="html">XV6-热身环节</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>32位的int和32位的float，谁能表示的数多</title>
    <link href="https://penge666.github.io/posts/7b5b2d72.html"/>
    <id>https://penge666.github.io/posts/7b5b2d72.html</id>
    <published>2024-07-15T11:58:22.000Z</published>
    <updated>2024-08-06T14:59:44.768Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://www.cnblogs.com/any91/p/14784786.html">同样是占32个坑，凭啥你float就比int的范围更大？</a></h1><p>原文出处：<a href="https://zhuanlan.zhihu.com/p/84453627?from_voters_page=true">https://zhuanlan.zhihu.com/p/84453627?from_voters_page=true</a></p><p>ok，这里先说明一下，假设是在32位的机器上，int是32位。而float使用的是IEEE 754标准的单精度浮点数格式也是占用32位。</p><p>这时候float和int都是占用32位，占用同样的空间，但float范围是更大的，那我们为啥还要int呢？为啥不节省空间，只用float？我们来一探究竟！他们在计算机的大脑里是如何记忆的？</p><p><strong>ok，这里先说明一下，假设是在32位的机器上，int是32位。而float使用的是IEEE 754标准的单精度浮点数格式也是占用32位。</strong></p><p>这时候float和int都是占用32位，占用同样的空间，但float范围是更大的，那我们为啥还要int呢？为啥不节省空间，只用float？我们来一探究竟！他们在计算机的大脑里是如何记忆的？</p><h2 id="1、int对32个坑是如何使用的？">1、int对32个坑是如何使用的？</h2><p>int类型的使用方法，大多学过计算机的，应该都是非常清楚的。二进制存储即可。</p><p><strong>例1：请写出165(10进制)使用32位int型存储在计算机中的形式。</strong></p><p>10进制转换为2进制，我个人喜欢先转为16进制，再写成2进制。</p><p>如下： 16510⇒10×16+5×1⇒A516⇒10100101</p><p>那么165在32位int型中是这样存储的（中间的0，我省略了）：</p><p><img src="https://pic4.zhimg.com/80/v2-d275288a53e69f37d8d1a1e4842da7cb_720w.webp" alt="img"></p><p>165在计算机中的int存储</p><p>非常简单明了，好理解。把10进制转换2进制，直接存进去就ok，前面空位补0。</p><p><strong>例2：请写出-165(10进制)使用32位int型存储在计算机中的形式。</strong></p><p>这是一个负数，按照惯例int型首位为符号位。0表示在正数，1表示负数。</p><p>如下： −16510⇒−(10×16+5×1)⇒100⋅⋅⋅10100101</p><p>但在计算机中，负数存储的是补码，不是原码。</p><p>他们之间按照如下转换：</p><p><strong>原码：1000 0000 1010 0101</strong></p><p><strong>反码：1111 1111 0101 1010</strong> （除了符号位，其它取反）</p><p><strong>补码：1111 1111 0101 1011</strong> （在反码的基础上加1即可）</p><p>那么-165在32位int型中是这样存储的（中间的1，我省略了）：</p><p><img src="https://pic2.zhimg.com/80/v2-d08661c3d813990cdcff8a7e728be789_720w.webp" alt="img"></p><p>-165在计算机中的int存储</p><p>比正数复杂了一点，但是还是可以很容易算出来的。</p><p>问题来了？为啥负数要用补码？这不是挑事吗？原码不好吗？</p><p><img src="https://pic4.zhimg.com/80/v2-6972d84f8d2fb7e050c16bf77b3743f7_720w.webp" alt="img"></p><p>原因之一在于，我们计算： 165+(−165)=0 ，在计算机中存储的是二进制，</p><p>如果使用原码进行计算，需要单独把符号位拿出来，再做减法运算，而把符号位区分出来是需要额外的硬件电路支撑的，这很不方便。</p><p>如果使用补码，如下所示（这里按照16位进行举例）：</p><p>0000 0000 1010 0101 + 1111 1111 0101 1011=0000 0000 0000 0000；</p><p>使用补码参与运算后，无需再管符号位，可以让符号位直接参与运算。这就是使用补码的最大的好处。到这里大家有没有发现，int型的这种存储方案是没有考虑小数的，所以这是整型的。关于int型的存储，不再赘述，整体来说还是清晰明了的一种方案。</p><hr><h2 id="2、float对32个坑是如何使用的？">2、float对32个坑是如何使用的？</h2><p>同样也是占用32个坑，float型的范围比int就大很多，而且还能表示小数，那么它到底是如何利用这32个坑的呢？</p><p><strong>例3：请写出165.25(10进制)使用float型存储在计算机中的形式。</strong></p><p>同样我们还是先转换为2进制：165.2510⇒ <strong>1010 0101 . 0100</strong></p><p>那么如何把上面的二进制小数存到32个坑里呢？</p><p>在填坑之前，我们先要规范二进制小数的表示形式，就和我们的科学计数法一样的道理。</p><p>（就像 123.6 要写成 1.236×102 这个样子，把所有的小数换成统一的格式）</p><p>IEEE754标准做了这样的规定：当尾数(小数)不为0时，<strong>尾数域的最高有效位为1</strong>，这称为浮点数的规格化。</p><p>例如： 10100101.0100⇒1.01001010100×27</p><p>规格化后的二进制小数，有了统一的规格，可以发现这样规格化之后，我们只需要存储一个尾数（即小数部分，整数部分恒为1）和指数部分。</p><p>IEEE754标准把float型的32个坑做了如下划分：</p><p><img src="https://pic3.zhimg.com/80/v2-ab70e3260e17f51f27b53bb45cca0a7a_720w.webp" alt="img"></p><p>其中包含了1位符号位S，8位阶码E和23位尾数M。</p><p>1.01001010100×27 ，要存储这个二进制小数；</p><p>首先符号位S，<strong>0</strong>表示正数，<strong>1</strong>表示负数。<strong>S=0</strong>；</p><p>再写出尾数M，即：<strong>M=0100 1010 1000 0000 0000 000</strong>；</p><p>然后算出阶码E，这里指数为：<strong>e=7=0000 0111</strong>，根据标准要求，E=e+127；</p><p>即：<strong>E=7+127=134=1000 0110</strong>；</p><p>那么把这三个数都填进坑里，就ok啦。</p><p><img src="https://pic2.zhimg.com/80/v2-5a112a8353f2050f65eae389780a5579_720w.webp" alt="img"></p><p>165.25在计算机中的float储存</p><p>这个计算过程稍微复杂点，但也还可以手算出来。</p><p><img src="https://pic3.zhimg.com/80/v2-34f77d9cdabf5cf49b28d2c78a3a812a_720w.webp" alt="img"></p><p>但是问题又来了：</p><p>1、浮点数的表示范围有多大？</p><p>2、为什么要用指数加上127，才是阶码E，而不是直接用指数存进去？</p><p>3、这个过程可以看出float有效位是尾数M加1也就是24位，阶码E只是我们规范科学计数法记录指数的，但int有效位是32位，float实际有效位比int少，那么在相互转换的过程中会出现什么问题？</p><p>我依次解释这3个问题：</p><p><strong>1、浮点数的表示范围有多大？</strong></p><p><img src="https://pic4.zhimg.com/80/v2-c357fa1691ded5da725e94d29bfad20f_720w.webp" alt="img"></p><p>float型定义的正无穷大</p><p><img src="https://pic2.zhimg.com/80/v2-6a52c35f1cb54f1d56993818a127b95d_720w.webp" alt="img"></p><p>float型定义的负无穷大</p><p>可以得出当<strong>E= 1111 1111</strong>时，指数为255-127=128，但这并不是表示这个数是： 1×2128 ，在IEEE754把这种情况定义为无穷大，此时尾数必须全部为0，不能有其他值，否则就认为无效数字。</p><p>那么除了无穷大这个特殊的、人为定义的情况，float型能表示的最大的正整数是多少？最小的负整数是多少？当<strong>E= 1111 1111</strong>时，是IEEE754定义的特殊值即为无穷大，那么除此之外的最大值就是：<strong>E= 1111 1110</strong>，M也取最大值，即得到如下结果：</p><p><img src="https://pic4.zhimg.com/80/v2-5954a5358cec9a68e62eed2b8f98f433_720w.webp" alt="img"></p><p>float型能存储的最大正整数</p><p>此时阶码E为254，指数即为e=254-127=127。这个数即为：</p><p>1.11111111111111111111111×2127 ；</p><p>对于尾数我们可以换一个写法：</p><p><strong>1.1111 1111 1111 1111 1111 111=10-0.0000 0000 0000 0000 0000 001</strong></p><p>这样尾数可以写成： 2−2−23 ；</p><p>那么float能够表示的最大正整数就是： (2−2−23)×2127 ，即为 2128−2104 。</p><p>那么float能够表示的最小负整数就是： 2104−2128 。</p><p><strong>2、为什么要用指数加上127，才是阶码E，而不是直接用指数存进去？</strong></p><p>这就很容易说明了，我们举个例子：</p><p><strong>例4：请写出0.75(10进制)使用float型存储在计算机中的形式。</strong></p><p>写成二进制：0.7510=0.11 。再写成规划化的计数法： 1.1×2−1 ；</p><p>发现问题了没有？这次的指数是个负数啦，而我们希望存储到机器里的阶码永远都是正值，因为我们不希望再浪费一个坑去保存阶码的正负号，于是乎，干脆把指数加上127，而指数能取到的最小值就是-127，这样就可以保证阶码<strong>E</strong>永远都是正数啦，我们就不用再考虑指数正负号的问题了。</p><p><strong>E=-1+127=126=0111 1110；</strong></p><p><strong>M=1000 0000 0000 0000 0000 000；</strong></p><p><img src="https://pic3.zhimg.com/80/v2-c6bb9c6bfd42cf2bfc7b805214ce8bfe_720w.webp" alt="img"></p><p>0.75在计算机中的float储存</p><p><strong>3、这个过程可以看出float有效位是尾数M加1也就是24位，阶码E只是我们用于规范科学计数法记录指数的，但int有效位是32位，float实际有效位比int少，那么在相互转换的过程中会出现什么问题？</strong></p><p>通过问题1知道，float型的表示范围是比int大很多的，但有效位确实只有24位。既然float范围大，那么所有的int型都是可以转换为float型的，这是不会产生溢出报错的。但因为int型有效位是32位，是比float型的24位大的，是有可能发生舍入的，即当一个int型数字，转成float型后，可能就不再是原本数字了，损失了一定的精度。</p><p>例如2进制int型正数：<strong>0111 1111 1111 1111 1111 1111 1111 1111</strong>；</p><p>写成科学计数法即为： 1.11111111111111111111111111111111×230</p><p>小数点后面有30个1，但是我们知道float种尾数M只有23个坑。</p><p>则转化为float型后，阶码<strong>E=30+127=157=1001 1101</strong></p><p><img src="https://pic2.zhimg.com/80/v2-b77b9dbf319006623f273cfc1542c485_720w.webp" alt="img"></p><p>可以发现，我们对原int型中存储的数字只保留了小数点后23个1，而后面7个，直接忽视了，这就是发生了舍入。</p>]]></content>
    
    
    <summary type="html">32位的int和32位的float，谁能表示的数多</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核:OOM-killer打分机制</title>
    <link href="https://penge666.github.io/posts/1f41a9c6.html"/>
    <id>https://penge666.github.io/posts/1f41a9c6.html</id>
    <published>2024-07-14T15:53:57.000Z</published>
    <updated>2024-09-21T11:56:50.392Z</updated>
    
    <content type="html"><![CDATA[<p>人生在世，被喜欢和被讨厌各占50%；自己喜欢自己，喜欢你的人占比就超过了50%。</p><p>Linux 内核中的 OOM (Out-Of-Memory) 机制是当系统内存耗尽时，用来杀死某些进程以释放内存的机制。为了决定应该杀死哪个进程，内核使用了一套复杂的打分系统，这个过程称为 OOM 打分机制。</p><h2 id="基本概述">基本概述</h2><h3 id="OOM-机制的触发">OOM 机制的触发</h3><p>当系统内存耗尽，无法满足进程分配内存的需求时，内核会触发 OOM 杀手（OOM Killer）。OOM 杀手会选中一个进程并终止它，以释放内存。整个过程大致分为以下几个步骤：</p><ol><li><strong>检测内存不足</strong>：当系统内存不足且无法通过释放缓存、回收页面等方式缓解时，触发 OOM 机制。</li><li><strong>选择目标进程</strong>：通过打分机制选定一个进程作为目标。</li><li><strong>杀死目标进程</strong>：终止目标进程并释放其占用的内存资源。</li></ol><h3 id="OOM-打分机制">OOM 打分机制</h3><p>内核通过为每个进程打分来决定哪个进程应被杀死。打分机制主要依据进程对系统资源的占用情况，打分越高，越有可能被杀死。打分过程涉及多个因素：</p><ol><li><strong>进程的内存占用</strong>：占用内存越多的进程，得分越高。这是最重要的因素。<ul><li>通过 <code>mm-&gt;total_vm</code> (虚拟内存总量) 计算，值越大，打分越高。</li></ul></li><li><strong>进程的优先级 (nice 值)</strong>：进程的优先级也影响得分。优先级越低（nice 值越高），得分越低。<ul><li>通过进程的 <code>oom_score_adj</code> 进一步调整。用户可以通过 <code>/proc/[pid]/oom_score_adj</code> 来手动调节这个值，使某些进程更容易或更不容易被杀。</li></ul></li><li><strong>进程年龄</strong>：某些情况下，运行时间越长的进程得分越低，内核倾向于保留长期运行的服务进程。</li><li><strong>子进程数</strong>：如果进程有大量子进程，意味着它可能是一个服务进程，内核可能降低它的得分。</li><li><strong>CAP_SYS_ADMIN 权限</strong>：具有此权限的进程通常得分较低，除非没有其他选择，因为这些进程通常是系统管理进程。</li><li><strong>用户调整</strong>：用户可以通过调整 <code>oom_score_adj</code> 或者 <code>oom_adj</code>（旧版本）来影响某个进程的 OOM 分数。这些值允许用户通过 <code>/proc/[pid]/oom_score_adj</code> 对某个进程的 OOM 得分进行加权。</li></ol><h3 id="具体打分公式">具体打分公式</h3><p>在 Linux 3.8 及更高版本中，内核使用了一个计算公式来评估进程的 OOM 分数：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cCopy</span> codepoints = mm-&gt;</span><span class="function"><span class="title">total_vm</span> + (mm-&gt;</span><span class="function"><span class="title">hiwater_rss</span> - mm-&gt;</span>rss);</span><br><span class="line"><span class="function"><span class="title">points</span> += mm-&gt;</span>hiwater_rss * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="title">points</span> += mm-&gt;</span>rss;</span><br><span class="line"><span class="function"><span class="title">points</span> += task_struct-&gt;</span>oom_score_adj;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>total_vm</code> 是进程的虚拟内存总量。</li><li><code>hiwater_rss</code> 是进程历史上消耗内存的最高点。</li><li><code>rss</code> 是当前实际驻留在内存中的页数。</li><li><code>oom_score_adj</code> 是用户自定义的调整值。</li></ul><h3 id="OOM-优先级与保护机制">OOM 优先级与保护机制</h3><ul><li><strong>oom_score</strong>: 每个进程的 OOM 分数可以在 <code>/proc/[pid]/oom_score</code> 中查看。分数越高，进程越有可能被杀死。</li><li><strong>oom_adj 和 oom_score_adj</strong>：用户和管理员可以通过 <code>/proc/[pid]/oom_adj</code> 或 <code>/proc/[pid]/oom_score_adj</code> 文件调整进程的 OOM 优先级。例如，将 <code>oom_score_adj</code> 设置为 <code>-1000</code> 可以保护进程不被 OOM 杀手杀死，而设置为 <code>1000</code> 会让它优先被杀。</li></ul><h3 id="OOM-杀手的执行">OOM 杀手的执行</h3><p>一旦 OOM 打分完成，内核会选择得分最高的进程进行杀死。杀死进程时，会发送 <code>SIGKILL</code> 信号给目标进程，强制终止它。杀死目标进程后，内核会重新评估系统内存，如果仍然不足，可能继续杀死其他进程，直到内存压力缓解。</p><h3 id="具体的系统配置">具体的系统配置</h3><p>管理员可以通过 <code>/proc/sys/vm/oom_kill_allocating_task</code> 来配置是否优先杀死当前触发 OOM 的进程。此外，还可以通过 <code>/proc/sys/vm/panic_on_oom</code> 配置系统在 OOM 时是否直接崩溃而不是杀死进程。</p><h2 id="源码">源码</h2><h3 id="1-OOM-Killer-触发机制">1. OOM Killer 触发机制</h3><p>当系统内存耗尽且无法回收更多内存时，OOM Killer 会被触发。这个过程通常发生在内存管理的页面分配过程中，如果内核无法满足内存分配请求且所有回收机制（如文件系统缓存回收、页面交换等）均失败，就会调用 OOM Killer。</p><p>代码位置：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux 内核 进程内存管理代码</span></span><br><span class="line"><span class="comment">// 文件：mm/page_alloc.c</span></span><br><span class="line"><span class="keyword">if</span> (should_alloc_retry(gfp_mask, <span class="keyword">order</span>, <span class="keyword">ac</span>))</span><br><span class="line">    goto retry;</span><br><span class="line">...</span><br><span class="line">out_of_memory(gfp_mask, <span class="keyword">order</span>, <span class="keyword">ac</span>);</span><br></pre></td></tr></table></figure><h3 id="2-out-of-memory-函数">2. <code>out_of_memory()</code> 函数</h3><p><code>out_of_memory()</code> 是 OOM Killer 的入口函数，它决定是否需要触发 OOM Killer，以及后续的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">out_of_memory</span><span class="params">(<span class="keyword">struct</span> zonelist *zonelist, <span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">int</span> *ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!oom_killer_disabled &amp;&amp; !<span class="built_in">mutex_trylock</span>(&amp;oom_lock))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前系统状态，如果已经在 OOM 处理中，返回</span></span><br><span class="line">    <span class="keyword">if</span> (oom_killer_disabled)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择要杀死的进程</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p = <span class="built_in">select_bad_process</span>();</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行杀死操作</span></span><br><span class="line">    <span class="built_in">oom_kill_process</span>(p, <span class="string">&quot;Out of memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择被杀进程：select-bad-process">3. 选择被杀进程：<code>select_bad_process()</code></h3><p><code>select_bad_process()</code> 函数会遍历系统中的所有进程，并为每个进程计算一个 OOM 分数，根据分数决定哪个进程应该被杀死。分数越高的进程越可能被杀死。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">select_bad_process</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *tsk, *selected = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> points = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each_process(tsk) &#123;</span><br><span class="line">        <span class="comment">// 检查进程是否可杀</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_oom_unkillable</span>(tsk))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 OOM 分数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> totalpoints = <span class="built_in">oom_badness</span>(tsk, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择得分最高的进程</span></span><br><span class="line">        <span class="keyword">if</span> (totalpoints &gt; points) &#123;</span><br><span class="line">            selected = tsk;</span><br><span class="line">            points = totalpoints;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算-OOM-分数：oom-badness">4. 计算 OOM 分数：<code>oom_badness()</code></h3><p><code>oom_badness()</code> 函数根据多个因素计算进程的 OOM 分数，包括内存占用、优先级、进程年龄等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">oom_badness</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="keyword">struct</span> mem_cgroup *mem, <span class="type">const</span> <span class="type">nodemask_t</span> *nodemask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> points = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存占用分数</span></span><br><span class="line">    points += p-&gt;mm-&gt;total_vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑优先级调整</span></span><br><span class="line">    points += p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程是一个长期运行的服务，降低其分数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">has_capability_noaudit</span>(p, CAP_SYS_ADMIN))</span><br><span class="line">        points /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-杀死进程：oom-kill-process">5. 杀死进程：<code>oom_kill_process()</code></h3><p><code>oom_kill_process()</code> 函数负责最终的杀死操作。它向选中的进程发送 <code>SIGKILL</code> 信号，强制终止该进程。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：mm/oom_kill.c</span></span><br><span class="line">void <span class="built_in">oom_kill_process</span>(struct task_struct *p, const char *message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pr_err</span>(&quot;%s: Kill process %d (%s) score %lu or sacrifice child\n&quot;,</span><br><span class="line">           message, <span class="built_in">task_pid_nr</span>(p), <span class="selector-tag">p</span>-&gt;comm, <span class="selector-tag">p</span>-&gt;signal-&gt;oom_score_adj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 SIGKILL 信号</span></span><br><span class="line">    <span class="built_in">do_send_sig_info</span>(SIGKILL, SEND_SIG_FORCED, p, true);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 OOM 锁</span></span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;oom_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-相关数据结构">6. 相关数据结构</h3><p><code>task_struct</code> 是进程的核心数据结构，<code>mm_struct</code> 则用于描述进程的内存使用情况。<code>oom_score_adj</code> 则是用户可以调整的一个参数，用于影响进程的 OOM 打分。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">task_struct</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">mm_struct</span> *mm;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">signal_struct</span> *signal;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">mm_struct</span> &#123;</span><br><span class="line">    unsigned long total_vm;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">signal_struct</span> &#123;</span><br><span class="line">    int oom_score_adj;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>Linux 内核中的 OOM Killer 是一个复杂但高效的机制，用于在系统内存耗尽时自动释放内存资源。通过 <code>out_of_memory()</code> 函数触发，选择打分最高的进程并执行杀死操作，以保持系统的稳定性。用户还可以通过调整 <code>oom_score_adj</code> 等参数影响 OOM Killer 的行为。</p><p><a href="http://blog.chinaunix.net/uid-20671208-id-4440249.html">kernel 3.10代码分析–Out Of Memory(OOM)处理流程</a></p>]]></content>
    
    
    <summary type="html">OOM-killer打分机制</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Web服务器-心跳机制</title>
    <link href="https://penge666.github.io/posts/fd78cff0.html"/>
    <id>https://penge666.github.io/posts/fd78cff0.html</id>
    <published>2024-07-14T13:28:27.000Z</published>
    <updated>2024-09-13T15:35:18.050Z</updated>
    
    <content type="html"><![CDATA[<p>心跳机制作用：</p><ul><li>死链是指在网络通信中，由于底层网络问题导致数据无法正常传输，但连接状态仍然保持的一种异常情况。通过心跳检测和超时机制，可以有效检测和处理死链，确保连接的可靠性和资源的有效利用。</li><li>保活</li></ul><h3 id="传输层-keepalive">传输层 keepalive</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 keepalive 选项</span></span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, <span class="built_in">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt SO_KEEPALIVE&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP_KEEPIDLE 为 3600 秒（1 小时）</span></span><br><span class="line">    <span class="type">int</span> keepidle = <span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;keepidle, <span class="built_in">sizeof</span>(keepidle)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt TCP_KEEPIDLE&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP_KEEPINTVL 为 60 秒（1 分钟）</span></span><br><span class="line">    <span class="type">int</span> keepintvl = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;keepintvl, <span class="built_in">sizeof</span>(keepintvl)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt TCP_KEEPINTVL&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP_KEEPCNT 为 5 次</span></span><br><span class="line">    <span class="type">int</span> keepcnt = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;keepcnt, <span class="built_in">sizeof</span>(keepcnt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt TCP_KEEPCNT&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印设置后的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Keepalive settings:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP_KEEPIDLE: %d seconds\n&quot;</span>, keepidle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP_KEEPINTVL: %d seconds\n&quot;</span>, keepintvl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP_KEEPCNT: %d\n&quot;</span>, keepcnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>启用 keepalive 选项</strong>：<ul><li><code>setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))</code>：启用 keepalive 选项。</li></ul></li><li><strong>设置 TCP_KEEPIDLE</strong>：<ul><li><code>setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;keepidle, sizeof(keepidle))</code>：设置发送 keepalive 报文的时间间隔为 3600 秒（1 小时）。</li></ul></li><li><strong>设置 TCP_KEEPINTVL</strong>：<ul><li><code>setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;keepintvl, sizeof(keepintvl))</code>：设置两次重试报文的时间间隔为 60 秒（1 分钟）。</li></ul></li><li><strong>设置 TCP_KEEPCNT</strong>：<ul><li><code>setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;keepcnt, sizeof(keepcnt))</code>：设置重试次数为 5 次。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-<span class="keyword">virtual</span>-machine  ~/Desktop/mymuduo  sudo sysctl -a | grep keepalive</span><br><span class="line">[sudo] password <span class="keyword">for</span> penge: </span><br><span class="line">net.ipv4.tcp_keepalive_intvl = <span class="number">75</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes = <span class="number">9</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">7200</span></span><br></pre></td></tr></table></figure><h3 id="应用层-心跳包">应用层 心跳包</h3><p>从技术来讲，心跳包其实就是一个预先规定好格式的数据包，在程序中启动一个定时器，定时发送即可，这是最简单的实现思路。但是，如果通信的两端有频繁的数据来往，此时到了下一个发心跳包的时间点了，此时发送一个心跳包。这其实是一个流量的浪费，既然通信双方不断有正常的业务数据包来往，这些数据包本身就可以起到保活作用，为什么还要浪费流量去发送这些心跳包呢？所以，对于用于保活的心跳包，我们最佳做法是，设置一个上次包时间，每次收数据和发数据时，都更新一下这个包时间，而心跳检测计时器每次检测时，将这个包时间与当前系统时间做一个对比，如果时间间隔大于允许的最大时间间隔（实际开发中根据需求设置成 15 ~ 45 秒不等），则发送一次心跳包。<strong>总而言之，就是在与对端之间，没有数据来往达到一定时间间隔时才发送一次心跳包。</strong><a href="https://gitee.com/balloonwj/CppGuide/blob/master/articles/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/%E5%BF%83%E8%B7%B3%E5%8C%85%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3.md">心跳包机制设计详解</a></p><p>keep-alive无法做到这点，因此，应用层的心跳·机制有优势，但是应用层的心跳机需要新开辟线程完成心跳机制，因此这是缺点。</p><p>实现代码</p><p>客户端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送心跳包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendHeartBeat</span><span class="params">(<span class="type">int</span> clientSock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>)); <span class="comment">// 每5秒发送一次心跳</span></span><br><span class="line">        std::string alive_msg = <span class="string">&quot;ALIVE&quot;</span>;</span><br><span class="line">        <span class="built_in">send</span>(clientSock, alive_msg.<span class="built_in">c_str</span>(), alive_msg.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sent heartbeat to server.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> clientSock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端 socket</span></span><br><span class="line">    clientSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientSock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;serverAddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Invalid address&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(clientSock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clientSock, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(clientSock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Connected to the server.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动心跳发送线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">heartBeatThread</span><span class="params">(sendHeartBeat, clientSock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 接收来自服务器的消息</span></span><br><span class="line">        <span class="type">int</span> recvBytes = <span class="built_in">recv</span>(clientSock, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (recvBytes &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Disconnected from server.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">message</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="string">&quot;HEARTBEAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received heartbeat request from server.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::string alive_msg = <span class="string">&quot;ALIVE&quot;</span>;</span><br><span class="line">            <span class="built_in">send</span>(clientSock, alive_msg.<span class="built_in">c_str</span>(), alive_msg.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    <span class="built_in">close</span>(clientSock);</span><br><span class="line">    heartBeatThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIVE_TIME_OUT 3    <span class="comment">// 心跳超时次数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIVE_TIME_SPACE 10 <span class="comment">// 心跳间隔时间（秒）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ISvrNetEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onHeartReq</span><span class="params">(<span class="type">int</span> clientSock)</span> </span>= <span class="number">0</span>; <span class="comment">// 发送心跳请求</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onNetClose</span><span class="params">(<span class="type">int</span> clientSock)</span> </span>= <span class="number">0</span>; <span class="comment">// 网络关闭事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 心跳检测类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeartBeat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeartBeat</span>(ISvrNetEvent *pAdapter, <span class="type">int</span> clientSock)</span><br><span class="line">        : <span class="built_in">m_pNetAdapter</span>(pAdapter), <span class="built_in">m_timeOutCount</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">m_sendHearBeatCount</span>(ALIVE_TIME_OUT), <span class="built_in">m_bIsVisible</span>(<span class="literal">true</span>),</span><br><span class="line">          <span class="built_in">m_clientSock</span>(clientSock) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (m_timeOutCount &lt; ALIVE_TIME_SPACE &amp;&amp; m_bIsVisible)</span><br><span class="line">        &#123;</span><br><span class="line">            m_timeOutCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_timeOutCount &gt;= ALIVE_TIME_SPACE &amp;&amp; m_bIsVisible)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_pNetAdapter)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pNetAdapter-&gt;<span class="built_in">onHeartReq</span>(m_clientSock);</span><br><span class="line">            &#125;</span><br><span class="line">            m_timeOutCount = <span class="number">0</span>;</span><br><span class="line">            m_sendHearBeatCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_sendHearBeatCount &lt;= <span class="number">0</span> &amp;&amp; m_bIsVisible &amp;&amp; m_pNetAdapter)</span><br><span class="line">        &#123;</span><br><span class="line">            m_bIsVisible = <span class="literal">false</span>;</span><br><span class="line">            m_pNetAdapter-&gt;<span class="built_in">onNetClose</span>(m_clientSock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到心跳包时重置心跳计数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">onRecvAlive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_sendHearBeatCount = ALIVE_TIME_OUT;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ISvrNetEvent *m_pNetAdapter;</span><br><span class="line">    <span class="type">int</span> m_timeOutCount;</span><br><span class="line">    <span class="type">int</span> m_sendHearBeatCount;</span><br><span class="line">    <span class="type">bool</span> m_bIsVisible;</span><br><span class="line">    <span class="type">int</span> m_clientSock;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器处理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> : <span class="keyword">public</span> ISvrNetEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(<span class="type">int</span> port) : <span class="built_in">serverSock</span>(<span class="number">-1</span>), <span class="built_in">port</span>(port) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建服务器 socket</span></span><br><span class="line">        serverSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (serverSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置服务器地址</span></span><br><span class="line">        serverAddr.sin_family = AF_INET;</span><br><span class="line">        serverAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">        serverAddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定服务器 socket</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(serverSock, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(serverSock);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(serverSock, MAX_CLIENTS) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(serverSock);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server listening on port &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line">            <span class="type">socklen_t</span> clientLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line">            <span class="type">int</span> clientSock = <span class="built_in">accept</span>(serverSock, (<span class="keyword">struct</span> sockaddr *)&amp;clientAddr, &amp;clientLen);</span><br><span class="line">            <span class="keyword">if</span> (clientSock &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;New client connected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                std::<span class="built_in">thread</span>(&amp;Server::handleClient, <span class="keyword">this</span>, clientSock).<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClient</span><span class="params">(<span class="type">int</span> clientSock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">HeartBeat <span class="title">heartbeat</span><span class="params">(<span class="keyword">this</span>, clientSock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">heartbeatThread</span><span class="params">([&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">                                    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                heartbeat.onLoop();</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收来自客户端的消息</span></span><br><span class="line">            <span class="type">int</span> recvBytes = <span class="built_in">recv</span>(clientSock, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (recvBytes &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Client disconnected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">std::string <span class="title">message</span><span class="params">(buffer)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="string">&quot;ALIVE&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Received heartbeat from client.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                heartbeat.<span class="built_in">onRecvAlive</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientSock);</span><br><span class="line">        heartbeatThread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送心跳请求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onHeartReq</span><span class="params">(<span class="type">int</span> clientSock)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string heartReq = <span class="string">&quot;HEARTBEAT&quot;</span>;</span><br><span class="line">        <span class="built_in">send</span>(clientSock, heartReq.<span class="built_in">c_str</span>(), heartReq.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sent heartbeat request to client.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理网络关闭事件（超时）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onNetClose</span><span class="params">(<span class="type">int</span> clientSock)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Client disconnected due to heartbeat timeout.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientSock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> serverSock;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Server <span class="title">server</span><span class="params">(PORT)</span></span>;</span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质就是开启线程，睡眠1s，然后取检测是否是否超时。我认为是需要维护个全局的时间轮才行。</p>]]></content>
    
    
    <summary type="html">心跳机制</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
