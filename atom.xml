<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-05-23T08:05:21.092Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模块4:应用层</title>
    <link href="https://penge666.github.io/posts/1dfac2eb.html"/>
    <id>https://penge666.github.io/posts/1dfac2eb.html</id>
    <published>2024-05-23T08:04:29.000Z</published>
    <updated>2024-05-23T08:05:21.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第14讲-HTTP协议：看个新闻原来这么麻烦">第14讲 | HTTP协议：看个新闻原来这么麻烦</h2><p>前面讲述完传输层，接下来开始讲应用层的协议。从哪里开始讲呢，就从咱们最常用的 HTTP 协议开始。</p><p>HTTP 协议，几乎是每个人上网用的第一个协议，同时也是很容易被人忽略的协议。</p><p>既然说看新闻，咱们就先登录 <a href="http://www.163.com/">http://www.163.com</a> 。</p><p><a href="http://www.163.com/">http://www.163.com</a> 是个 URL，叫作统一资源定位符。之所以叫统一，是因为它是有格式的。HTTP 称为协议，<a href="http://www.163.com">www.163.com</a> 是一个域名，表示互联网上的一个位置。有的 URL 会有更详细的位置标识，例如 <a href="http://www.163.com/index.html">http://www.163.com/index.html</a> 。正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。</p><h3 id="14-1-HTTP-请求的准备">14.1 HTTP 请求的准备</h3><p>浏览器会将 <a href="http://www.163.com">www.163.com</a> 这个域名发送给 DNS 服务器，让它解析为 IP 地址。有关 DNS 的过程，其实非常复杂，这个在后面专门介绍 DNS 的时候，我会详细描述，这里我们先不管，反正它会被解析成为 IP 地址。那接下来是发送 HTTP 请求吗？</p><p>不是的，HTTP 是基于 TCP 协议的，当然是要先建立 TCP 连接了，怎么建立呢？还记得第 11 节讲过的三次握手吗？</p><p>目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。</p><p>学习了 TCP 之后，你应该知道，TCP 的三次握手和四次挥手，还是挺费劲的。如果好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。</p><h3 id="14-2-HTTP-请求的构建">14.2 HTTP 请求的构建</h3><p>建立了连接以后，浏览器就要发送 HTTP 的请求。</p><p>请求的格式就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150326073.png" alt="image-20240523150326073"></p><p>HTTP 的报文大概分为三大部分。第一部分是<strong>请求行</strong>，第二部分是请求的<strong>首部</strong>，第三部分才是请求的<strong>正文实体</strong>。</p><ol><li><p>第一部分：请求行</p><p>在请求行中，URL 就是 <a href="http://www.163.com/">http://www.163.com</a> ，版本为 HTTP 1.1。这里要说一下的，就是方法。方法有几种类型。</p><p>对于访问网页来讲，最常用的类型就是<strong>GET</strong>。顾名思义，GET 就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 JSON 字符串，到底要返回什么，是由服务器端的实现决定的。</p><p>例如，在云计算中，如果我们的服务器端要提供一个基于 HTTP 协议的 API，获取所有云主机的列表，这就会使用 GET 方法得到，返回的可能是一个 JSON 字符串。字符串里面是一个列表，列表里面是一项的云主机的信息。</p><p>另外一种类型叫做<strong>POST</strong>。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON。</p><p>例如，我们下一节要讲的支付场景，客户端就需要把”我是谁？我要支付多少？我要买啥？”告诉服务器，这就需要通过 POST 方法。</p><p>再如，在云计算里，如果我们的服务器端，要提供一个基于 HTTP 协议的创建云主机的 API，也会用到 POST 方法。这个时候往往需要将”我要创建多大的云主机？多少 CPU 多少内存？多大硬盘？”这些信息放在 JSON 字符串里面，通过 POST 的方法告诉服务器端。</p><p>还有一种类型叫<strong>PUT</strong>，就是向指定资源位置上传最新内容。但是，HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 就都变成了要传给服务器东西的方法。</p><p>在实际使用过程中，这两者还会有稍许的区别。POST 往往是用来创建一个资源的，而 PUT 往往是用来修改一个资源的。</p><p>例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用 PUT 方法。</p><p>再有一种常见的就是<strong>DELETE</strong>。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用 DELETE 方法。</p></li><li><p>第二部分：首部字段</p><p>请求行下面就是我们的首部字段。首部是 key value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。</p><p>例如，<strong>Accept-Charset</strong>，表示<strong>客户端可以接受的字符集</strong>。防止传过来的是另外的字符集，从而导致出现乱码。</p><p>再如，<strong>Content-Type</strong>是指<strong>正文的格式</strong>。例如，我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。</p><p>这里需要重点说一下的就是缓存。为啥要使用<strong>缓存</strong>呢？那是因为一个非常大的页面有很多东西。</p><p>例如，我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等。商品的展示图片会保持较长时间不变，而库存会根据用户购买的情况经常改变。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。</p><p>对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。</p><p>这个架构的图就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150519760.png" alt="image-20240523150519760"></p><p>其中 DNS、CDN 我在后面的章节会讲。和这一节关系比较大的就是 Nginx 这一层，它如何处理 HTTP 协议呢？对于静态资源，有 Vanish 缓存层。当缓存过期的时候，才会访问真正的 Tomcat 应用集群。</p><p>在 HTTP 头里面，Cache-control是用来控制缓存的。当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。</p><p>另外，If-Modified-Since也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回”304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。</p><p>到此为止，我们仅仅是拼凑起了 HTTP 请求的报文格式，接下来，浏览器会把它交给下一层传输层。怎么交给传输层呢？其实也无非是用 Socket 这些东西，只不过用的浏览器里，这些程序不需要你自己写，有人已经帮你写好了。</p></li></ol><h3 id="14-3-HTTP-请求的发送">14.3 HTTP 请求的发送</h3><p>HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。当然，到了 TCP 层，它会把二进制流变成一个的报文段发送给服务器。</p><p>在发送给每个报文段的时候，都需要对方有一个回应 ACK，来保证报文可靠地到达了对方。如果没有回应，那么 TCP 这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是 HTTP 这一层不需要知道这一点，因为是 TCP 这一层在埋头苦干。</p><p>TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 IP 层进行传输。</p><p>IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。</p><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。</p><p>这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去。</p><p>目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。</p><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。</p><h3 id="14-4-HTTP-返回的构建">14.4 HTTP 返回的构建</h3><p>HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150716333.png" alt="image-20240523150716333"></p><p>状态码会反应 HTTP 请求的结果。”200”意味着大吉大利；而我们最不想见的，就是”404”，也就是”服务端无法响应这个请求”。然后，短语会大概说一下原因。</p><p>接下来是返回首部的<strong>key value</strong>。</p><p>这里面，<strong>Retry-After</strong>表示，告诉客户端应该在多长时间以后再次尝试一下。”503 错误”是说”服务暂时不再和这个值配合使用”。</p><p>在返回的头部里面也会有<strong>Content-Type</strong>，表示返回的是 HTML，还是 JSON。</p><p>构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去。还是交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达。</p><p>这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。</p><p>客户端发现 MAC 地址符合、IP 地址符合，于是就会交给 TCP 层。根据序列号看是不是自己要的报文段，如果是，则会根据 TCP 头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。</p><p>当浏览器拿到了 HTTP 的报文。发现返回”200”，一切正常，于是就从正文中将 HTML 拿出来。HTML 是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。</p><p>这就是一个正常的 HTTP 请求和返回的完整过程。</p><h3 id="14-5-HTTP-2-0">14.5 HTTP 2.0</h3><p>当然 HTTP 协议也在不断地进化过程中，在 HTTP1.1 基础上便有了 HTTP 2.0。</p><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。</p><p>为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</p><p>另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。</p><p>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有<strong>Header 帧</strong>，用于传输 Header 内容，并且会开启一个新的流。再就是<strong>Data 帧</strong>，用来传输正文实体。多个 Data 帧属于同一个流。</p><p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p><p>我们来举一个例子。</p><p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150832889.png" alt="image-20240523150832889"></p><p>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150855992.png" alt="image-20240523150855992"></p><p>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p><h3 id="14-6-QUIC-协议的”城会玩”">14.6 QUIC 协议的”城会玩”</h3><p>HTTP 2.0 虽然大大增加了并发性，但还是有问题的。因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。</p><p>当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。</p><p>于是，就又到了从 TCP 切换到 UDP，进行”城会玩”的时候了。这就是 Google 的 QUIC 协议，接下来我们来看它是如何”城会玩”的。</p><ol><li><p>机制一：自定义连接机制</p><p>我们都知道，一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的 IP、目的端口。一旦一个元素发生变化时，就需要断开重连，重新连接。在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延。</p><p>这在 TCP 是没有办法的，但是基于 UDP，就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。</p></li><li><p>机制二：自定义重传机制</p><p>前面我们讲过，TCP 为了保证可靠性，通过使用<strong>序号</strong>和<strong>应答</strong>机制，来解决顺序问题和丢包问题。</p><p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包。那怎么样才算超时呢？还记得我们提过的<strong>自适应重传算法</strong>吗？这个超时是通过<strong>采样往返时间 RTT</strong>不断调整的。</p><p>其实，在 TCP 里面超时的采样存在不准确的问题。例如，发送一个包，序号为 100，发现没有返回，于是再发送一个 100，过一阵返回一个 ACK101。这个时候客户端知道这个包肯定收到了，但是往返时间是多少呢？是 ACK 到达的时间减去后一个 100 发送的时间，还是减去前一个 100 发送的时间呢？事实是，第一种算法把时间算短了，第二种算法把时间算长了。</p><p>QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK 100，就是对第一个包的响应。如果返回 ACK 101 就是对第二个包的响应，RTT 计算相对准确。</p><p>但是这里有一个问题，就是怎么知道包 100 和包 101 发送的是同样的内容呢？QUIC 定义了一个 offset 概念。QUIC 既然是面向连接的，也就像 TCP 一样，是一个数据流，发送的数据在这个数据流里面有个偏移量 offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发；如果来了，按照 offset 拼接，还是能够拼成一个流。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523153054377.png" alt="image-20240523153054377"></p><ol start="3"><li>机制三：无阻塞的多路复用</li></ol><p>有了自定义的连接和重传机制，我们就可以解决上面 HTTP 2.0 的多路复用问题。</p><p>同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。</p><ol start="4"><li><p>机制四：自定义流量控制</p><p>TCP 的流量控制是通过滑动窗口协议。QUIC 的流量控制也是通过 window_update，来告诉对端它可以接受的字节数。但是 QUIC 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。</p><p>还记得吗？在 TCP 协议中，接收端的窗口的起始点是下一个要接收并且 ACK 的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为 TCP 的 ACK 机制是基于序列号的累计应答，一旦 ACK 了一个系列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能 ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。</p><p>QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523153744155.png" alt="image-20240523153744155"></p><ol><li>另外，还有整个连接的窗口，需要对于所有的 stream 的窗口做一个统计。</li></ol><h3 id="14-7-小结">14.7 小结</h3><p>总结一下：</p><ul><li>HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；</li><li>HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；</li><li>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</li></ul><h2 id="第15讲-HTTPS协议：点外卖的过程原来这么复杂">第15讲 | HTTPS协议：点外卖的过程原来这么复杂</h2><p>用 HTTP 协议，看个新闻还没有问题，但是换到更加严肃的场景中，就存在很多的安全风险。例如，你要下单做一次支付，如果还是使用普通的 HTTP 协议，那你很可能会被黑客盯上。</p><p>你发送一个请求，说我要点个外卖，但是这个网络包被截获了，于是在服务器回复你之前，黑客先假装自己就是外卖网站，然后给你回复一个假的消息说：”好啊好啊，来来来，银行卡号、密码拿来。”如果这时候你真把银行卡密码发给它，那你就真的上套了。</p><p>那怎么解决这个问题呢？当然一般的思路就是<strong>加密</strong>。加密分为两种方式一种是<strong>对称加密</strong>，一种是<strong>非对称加密</strong>。</p><p>在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。</p><p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。</p><p>因为对称加密算法相比非对称加密算法来说，效率要高得多，性能也好，所以交互的场景下多用对称加密。</p><h3 id="15-1-对称加密">15.1 对称加密</h3><p>假设你和外卖网站约定了一个密钥，你发送请求的时候用这个密钥进行加密，外卖网站用同样的密钥进行解密。这样就算中间的黑客截获了你的请求，但是它没有密钥，还是破解不了。</p><p>这看起来很完美，但是中间有个问题，你们两个怎么来约定这个密钥呢？如果这个密钥在互联网上传输，也是很有可能让黑客截获的。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。</p><p>我们在谍战剧里面经常看到这样的场景，就是特工破译的密码会有个密码本，截获无线电台，通过密码本就能将原文破解出来。怎么把密码本给对方呢？只能通过线下传输。</p><p>比如，你和外卖网站偷偷约定时间地点，它给你一个纸条，上面写着你们两个的密钥，然后说以后就用这个密钥在互联网上定外卖了。当然你们接头的时候，也会先约定一个口号，什么”天王盖地虎”之类的，口号对上了，才能把纸条给它。但是，”天王盖地虎”同样也是对称加密密钥，同样存在如何把”天王盖地虎”约定成口号的问题。而且在谍战剧中一对一接头可能还可以，在互联网应用中，客户太多，这样是不行的。</p><h3 id="15-2-非对称加密">15.2 非对称加密</h3><p>所以，只要是对称加密，就会永远在这个死循环里出不来，这个时候，就需要非对称加密介入进来。</p><p>非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。但是，对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。</p><p>比如说你用公钥加密，说”我要定外卖”，黑客在中间就算截获了这个报文，因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站，外卖网站用私钥把这个报文解出来，然后回复，”那给我银行卡和支付密码吧”。</p><p>先别太乐观，这里还是有问题的。回复的这句话，是外卖网站拿私钥加密的，互联网上人人都可以把它打开，当然包括黑客。那外卖网站可以拿公钥加密吗？当然不能，因为它自己的私钥只有它自己知道，谁也解不开。</p><p>另外，这个过程还有一个问题，黑客也可以模拟发送”我要定外卖”这个过程的，因为它也有外卖网站的公钥。</p><p>为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥，并且客户端要把自己的公钥，给外卖网站。</p><p>这样，客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候，使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。</p><h3 id="15-3-数字证书">15.3 数字证书</h3><p>不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。</p><p>这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。</p><p>例如，我自己搭建了一个网站 cliu8site，可以通过这个命令先创建私钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out cliu8siteprivate.key 1024</span><br></pre></td></tr></table></figure><p>然后，再根据这个私钥，创建对应的公钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> cliu8siteprivate.key -pubout -outcliu8sitepublic.pem</span><br></pre></td></tr></table></figure><p>这个时候就需要权威部门的介入了，就像每个人都可以打印自己的简历，说自己是谁，但是有公安局盖章的，就只有户口本，这个才能证明你是你。这个由权威部门颁发的称为<strong>证书（Certificate）</strong>。</p><p>证书里面有什么呢？当然应该有<strong>公钥</strong>，这是最重要的；还有证书的<strong>所有者</strong>，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的<strong>发布机构</strong>和证书的<strong>有效期</strong>，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。</p><p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为<strong>CA（ Certificate Authority）</strong>。</p><p>证书请求可以通过这个命令生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req</span><br></pre></td></tr></table></figure><p>将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为 <strong>签名算法</strong> 。 问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。</p><p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。</p><p>权威机构给证书签名的命令是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem</span><br></pre></td></tr></table></figure><p>这个命令会返回 Signature ok，而 cliu8sitecertificate.pem 就是签过名的证书。CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。</p><p>我们来查看这个证书的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cliu8sitecertificate.pem -noout -text</span><br></pre></td></tr></table></figure><p>这里面有个 Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity 是证书期限；Public-key 是公钥内容；Signature Algorithm 是签名算法。</p><p>这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。</p><p>你有没有发现，又有新问题了。要想验证证书，需要 CA 的公钥，问题是，你怎么确定 CA 的公钥就是对的呢？</p><p>所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大 CA，称为<strong>root CA</strong>，做最后的背书。通过这种<strong>层层授信背书</strong>的方式，从而保证了非对称加密模式的正常运转。</p><p>除此之外，还有一种证书，称为<strong>Self-Signed Certificate</strong>，就是自己给自己签名。这个给人一种”我就是我，你爱信不信”的感觉。这里我就不多说了。</p><h3 id="15-4-HTTPS-的工作模式">15.4 HTTPS 的工作模式</h3><p>我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。</p><p>当然是可以的。这就是 HTTPS 协议的总体思路。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523154846962.png" alt="image-20240523154846962"></p><p>当你登录一个外卖网站的时候，由于是 HTTPS，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有一个随机数，在协商对称密钥的时候使用。</p><p>这就类似在说：”您好，我想定外卖，但你要保密我吃的是什么。这是我的加密套路，再给你个随机数，你留着。”</p><p>然后，外卖网站返回 Server Hello 消息, 告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。</p><p>这就类似在说：”您好，保密没问题，你的加密套路还挺多，咱们就按套路 2 来吧，我这里也有个随机数，你也留着。”</p><p>然后，外卖网站会给你一个服务器端的证书，然后说：”Server Hello Done，我这里就这些信息了。”</p><p>你当然不相信这个证书，于是你从自己信任的 CA 仓库中，拿 CA 的证书里面的公钥去解密外卖网站的证书。如果能够成功，则说明外卖网站是可信的。这个过程中，你可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，反正直到一个授信的 CA，就可以了。</p><p>证书验证完毕之后，觉得这个外卖网站可信，于是客户端计算产生随机数字 Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密出来。</p><p>到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。</p><p>有了对称密钥，客户端就可以说：”Change Cipher Spec，咱们以后都采用协商的通信密钥和加密算法进行加密通信了。”</p><p>然后发送一个 Encrypted Handshake Message，将已经商定好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。</p><p>同样，服务器也可以发送 Change Cipher Spec，说：”没问题，咱们以后都采用协商的通信密钥和加密算法进行加密通信了”，并且也发送 Encrypted Handshake Message 的消息试试。当双方握手结束之后，就可以通过对称密钥进行加密传输了。</p><p>这个过程除了加密解密之外，其他的过程和 HTTP 是一样的，过程也非常复杂。</p><p>上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。</p><h3 id="15-5-重放与篡改">15.5 重放与篡改</h3><p>其实，这里还有一些没有解决的问题，例如重放和篡改的问题。</p><p>没错，有了加密和解密，黑客截获了包也打不开了，但是它可以发送 N 次。这个往往通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。</p><p>Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的，请求只接受一次，于是服务器多次受到相同的 Timestamp 和 Nonce，则视为无效即可。</p><p>如果有人想篡改 Timestamp 和 Nonce，还有签名保证不可篡改性，如果改了用签名算法解出来，就对不上了，可以丢弃了。</p><h3 id="15-6-小结">15.6 小结</h3><p>总结一下。</p><ul><li>加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。</li><li>非对称加密需要通过证书和权威机构来验证公钥的合法性。</li><li>HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。</li></ul><h2 id="第16讲-流媒体协议：如何在直播里看到美女帅哥？">第16讲 | 流媒体协议：如何在直播里看到美女帅哥？</h2><h3 id="16-1-三个名词系列">16.1 三个名词系列</h3><p>我这里列三个名词系列，你先大致有个印象。</p><ul><li><strong>名词系列一</strong>：AVI、MPEG、RMVB、MP4、MOV、FLV、WebM、WMV、ASF、MKV。例如 RMVB 和 MP4，看着是不是很熟悉？</li><li><strong>名词系列二</strong>：H.261、 H.262、H.263、H.264、H.265。这个是不是就没怎么听过了？别着急，你先记住，要重点关注 H.264。</li><li><strong>名词系列三</strong>：MPEG-1、MPEG-2、MPEG-4、MPEG-7。MPEG 好像听说过，但是后面的数字是怎么回事？是不是又熟悉又陌生？</li></ul><p>这里，我想问你个问题，视频是什么？我说，其实就是快速播放一连串连续的图片。</p><p>每一张图片，我们称为一<strong>帧</strong>。只要每秒钟帧的数据足够多，也即播放得足够快。比如每秒 30 帧，以人的眼睛的敏感程度，是看不出这是一张张独立的图片的，这就是我们常说的<strong>帧率（FPS）</strong>。</p><p>每一张图片，都是由<strong>像素</strong>组成的，假设为 1024*768（这个像素数不算多）。每个像素由 RGB 组成，每个 8 位，共 24 位。</p><p>我们来算一下，每秒钟的视频有多大？</p><p>30 帧 × 1024 × 768 × 24 = 566,231,040Bits = 70,778,880Bytes</p><p>如果一分钟呢？4,246,732,800Bytes，已经是 4 个 G 了。</p><p>是不是不算不知道，一算吓一跳？这个数据量实在是太大，根本没办法存储和传输。如果这样存储，你的硬盘很快就满了；如果这样传输，那多少带宽也不够用啊！</p><p>怎么办呢？人们想到了<strong>编码</strong>，就是看如何用尽量少的 Bit 数保存视频，使播放的时候画面看起来仍然很精美。<strong>编码是一个压缩的过程</strong>。</p><h3 id="16-2-视频和图片的压缩过程有什么特点？">16.2 视频和图片的压缩过程有什么特点？</h3><ol><li>空间冗余：图像的相邻像素之间有较强的相关性，一张图片相邻像素往往是渐变的，不是突变的，没必要每个像素都完整地保存，可以隔几个保存一个，中间的用算法计算出来。</li><li>时间冗余：视频序列的相邻图像之间内容相似。一个视频中连续出现的图片也不是突变的，可以根据已有的图片进行预测和推断。</li><li>视觉冗余：人的视觉系统对某些细节不敏感，因此不会每一个细节都注意到，可以允许丢失一些数据。</li><li>编码冗余：不同像素值出现的概率不同，概率高的用的字节少，概率低的用的字节多，类似霍夫曼编码（Huffman Coding）的思路。</li></ol><p>总之，用于编码的算法非常复杂，而且多种多样，但是编码过程其实都是类似的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155047425.png" alt="image-20240523155047425"></p><h3 id="16-3-视频编码的两大流派">16.3 视频编码的两大流派</h3><p>能不能形成一定的标准呢？要不然开发视频播放的人得累死了。当然能，我这里就给你介绍，视频编码的两大流派。</p><ul><li>流派一：ITU（International Telecommunications Union）的 VCEG（Video Coding Experts Group），这个称为<strong>国际电联下的 VCEG</strong>。既然是电信，可想而知，他们最初做视频编码，主要侧重传输。名词系列二，就是这个组织制定的标准。</li><li>流派二：ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），这个是<strong>ISO 旗下的 MPEG</strong>，本来是做视频存储的。例如，编码后保存在 VCD 和 DVD 中。当然后来也慢慢侧重视频传输了。名词系列三，就是这个组织制定的标准。</li></ul><p>后来，ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC，这才是我们这一节要重点关注的。</p><h3 id="16-4-如何在直播里看到帅哥美女？">16.4 如何在直播里看到帅哥美女？</h3><p>网络协议将<strong>编码</strong>好的视频流，从主播端推送到服务器，在服务器上有个运行了同样协议的服务端来接收这些网络包，从而得到里面的视频流，这个过程称为<strong>接流</strong>。</p><p>服务端接到视频流之后，可以对视频流进行一定的处理，例如<strong>转码</strong>，也即从一个编码格式，转成另一种格式。因为观众使用的客户端千差万别，要保证他们都能看到直播。</p><p><strong>流处理</strong>完毕之后，就可以等待观众的客户端来请求这些视频流。观众的客户端请求的过程称为<strong>拉流</strong>。</p><p>如果有非常多的观众，同时看一个视频直播，那都从一个服务器上<strong>拉流</strong>，压力太大了，因而需要一个视频的<strong>分发</strong>网络，将视频预先加载到就近的边缘节点，这样大部分观众看的视频，是从边缘节点拉取的，就能降低服务器的压力。</p><p>当观众的客户端将视频流拉下来之后，就需要进行<strong>解码</strong>，也即通过上述过程的逆过程，将一串串看不懂的二进制，再转变成一帧帧生动的图片，在客户端<strong>播放</strong>出来，这样你就能看到美女帅哥啦。</p><p>整个直播过程，可以用这个的图来描述。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155206978.png" alt="image-20240523155206978"></p><h3 id="16-5-编码：如何将丰富多彩的图片变成二进制流？">16.5 编码：如何将丰富多彩的图片变成二进制流？</h3><p>虽然我们说视频是一张张图片的序列，但是如果每张图片都完整，就太大了，因而会将视频序列分成三种帧。</p><ul><li><strong>I 帧</strong>，也称关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。</li><li><strong>P 帧</strong>，前向预测编码帧。P 帧表示的是这一帧跟之前的一个关键帧（或 P 帧）的差别，解码时需要用之前缓存的画面，叠加上和本帧定义的差别，生成最终画面。</li><li><strong>B 帧</strong>，双向预测内插编码帧。B 帧记录的是本帧与前后帧的差别。要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据与本帧数据的叠加，取得最终的画面。</li></ul><p>可以看出，I 帧最完整，B 帧压缩率最高，而压缩后帧的序列，应该是在 IBBP 的间隔出现的。这就是<strong>通过时序进行编码</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155222287.png" alt="image-20240523155222287"></p><p>在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，可以方便进行<strong>空间上的编码</strong>。</p><p>尽管时空非常立体的组成了一个序列，但是总归还是要压缩成一个二进制流。这个流是有结构的，是一个个的<strong>网络提取层单元（NALU，Network Abstraction Layer Unit）</strong>。变成这种格式就是为了传输，因为网络上的传输，默认的是一个个的包，因而这里也就分成了一个个的单元。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155235317.png" alt="image-20240523155235317"></p><p>每一个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔；然后是 NALU 的头，里面主要配置了 NALU 的类型；最终 Payload 里面是 NALU 承载的数据。</p><p>在 NALU 头里面，主要的内容是类型<strong>NAL Type</strong>。</p><ul><li>0x07 表示 SPS，是序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。</li><li>0x08 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。</li></ul><p>在传输视频流之前，必须要传输这两类参数，不然无法解码。为了保证容错性，每一个 I 帧前面，都会传一遍这两个参数集合。</p><p>如果 NALU Header 里面的表示类型是 SPS 或者 PPS，则 Payload 中就是真正的参数集的内容。</p><p>如果类型是帧，则 Payload 中才是正的视频数据，当然也是一帧一帧存放的，前面说了，一帧的内容还是挺多的，因而每一个 NALU 里面保存的是一片。对于每一片，到底是 I 帧，还是 P 帧，还是 B 帧，在片结构里面也有个 Header，这里面有个类型，然后是片的内容。</p><p>这样，整个格式就出来了，<strong>一个视频，可以拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个 NALU 里面，NALU 之间都是通过特殊的起始标识符分隔，在每一个 I 帧的第一片前面，要插入单独保存 SPS 和 PPS 的 NALU，最终形成一个长长的 NALU 序列</strong>。</p><h3 id="16-6-推流：如何把数据流打包传输到对端？">16.6 推流：如何把数据流打包传输到对端？</h3><p>那这个格式是不是就能够直接在网上传输到对端，开始直播了呢？其实还不是，还需要将这个二进制的流打包成网络包进行发送，这里我们使用<strong>RTMP 协议</strong>。这就进入了第二个过程，<strong>推流</strong>。</p><p>RTMP 是基于 TCP 的，因而肯定需要双方建立一个 TCP 的连接。在有 TCP 的连接的基础上，还需要建立一个 RTMP 的连接，也即在程序里面，你需要调用 RTMP 类库的 Connect 函数，显示创建一个连接。</p><p>RTMP 为什么需要建立一个单独的连接呢？</p><p>因为它们需要商量一些事情，保证以后的传输能正常进行。主要就是两个事情，一个是<strong>版本号</strong>，如果客户端、服务器的版本号不一致，则不能工作。另一个就是<strong>时间戳</strong>，视频播放中，时间是很重要的，后面的数据流互通的时候，经常要带上时间戳的差值，因而一开始双方就要知道对方的时间戳。</p><p>未来沟通这些事情，需要发送六条消息：客户端发送 C0、C1、 C2，服务器发送 S0、 S1、 S2。</p><p>首先，客户端发送 C0 表示自己的版本号，不必等对方的回复，然后发送 C1 表示自己的时间戳。</p><p>服务器只有在收到 C0 的时候，才能返回 S0，表明自己的版本号，如果版本不匹配，可以断开连接。</p><p>服务器发送完 S0 后，也不用等什么，就直接发送自己的时间戳 S1。客户端收到 S1 的时候，发一个知道了对方时间戳的 ACK C2。同理服务器收到 C1 的时候，发一个知道了对方时间戳的 ACK S2。</p><p>于是，握手完成。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155252712.png" alt="image-20240523155252712"></p><p>握手之后，双方需要互相传递一些控制信息，例如 Chunk 块的大小、窗口大小等。</p><p>真正传输数据的时候，还是需要创建一个流 Stream，然后通过这个 Stream 来推流 publish。</p><p>推流的过程，就是将 NALU 放在 Message 里面发送，这个也称为<strong>RTMP Packet 包</strong>。Message 的格式就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155302680.png" alt="image-20240523155302680"></p><p>发送的时候，去掉 NALU 的起始标识符。因为这部分对于 RTMP 协议来讲没有用。接下来，将 SPS 和 PPS 参数集封装成一个 RTMP 包发送，然后发送一个个片的 NALU。</p><p>RTMP 在收发数据的时候并不是以 Message 为单位的，而是把 Message 拆分成 Chunk 发送，而且必须在一个 Chunk 发送完成之后，才能开始发送下一个 Chunk。每个 Chunk 中都带有 Message ID，表示属于哪个 Message，接收端也会按照这个 ID 将 Chunk 组装成 Message。</p><p>前面连接的时候，设置的 Chunk 块大小就是指这个 Chunk。将大的消息变为小的块再发送，可以在低带宽的情况下，减少网络拥塞。</p><p>这有一个分块的例子，你可以看一下。</p><p>假设一个视频的消息长度为 307，但是 Chunk 大小约定为 128，于是会拆分为三个 Chunk。</p><ul><li>第一个 Chunk 的 Type＝0，表示 Chunk 头是完整的；头里面 Timestamp 为 1000，总长度 Length 为 307，类型为 9，是个视频，Stream ID 为 12346，正文部分承担 128 个字节的 Data。</li><li>第二个 Chunk 也要发送 128 个字节，Chunk 头由于和第一个 Chunk 一样，因此采用 Chunk Type＝3，表示头一样就不再发送了。</li><li>第三个 Chunk 要发送的 Data 的长度为 307-128-128=51 个字节，还是采用 Type＝3。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155314600.png" alt="image-20240523155314600"></p><p>就这样数据就源源不断到达流媒体服务器，整个过程就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155326858.png" alt="image-20240523155326858"></p><p>这个时候，大量观看直播的观众就可以通过 RTMP 协议从流媒体服务器上拉取，但是这么多的用户量，都去同一个地方拉取，服务器压力会很大，而且用户分布在全国甚至全球，如果都去统一的一个地方下载，也会时延比较长，需要有分发网络。</p><p>分发网络分为<strong>中心</strong>和<strong>边缘</strong>两层。边缘层服务器部署在全国各地及横跨各大运营商里，和用户距离很近。中心层是流媒体服务集群，负责内容的转发。智能负载均衡系统，根据用户的地理位置信息，就近选择边缘服务器，为用户提供推 / 拉流服务。中心层也负责转码服务，例如，把 RTMP 协议的码流转换为 HLS 码流。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155351892.png" alt="image-20240523155351892"></p><p>这套机制在后面的 DNS、HTTPDNS、CDN 的章节会更有详细的描述。</p><h3 id="16-7-拉流：观众的客户端如何看到视频？">16.7 拉流：观众的客户端如何看到视频？</h3><p>接下来，我们再来看观众的客户端通过 RTMP 拉流的过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155422589.png" alt="image-20240523155422589"></p><p>先读到的是 H.264 的解码参数，例如 SPS 和 PPS，然后对收到的 NALU 组成的一个个帧，进行解码，交给播发器播放，一个绚丽多彩的视频画面就出来了。</p><h3 id="16-8-小结">16.8 小结</h3><p>总结一下：</p><ul><li>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</li><li>压缩好的数据，为了传输组成一系列 NALU，按照帧和片依次排列；</li><li>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成 Chunk 进行传输；</li><li>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。</li></ul><h2 id="第17讲-P2P协议：我下小电影，99-急死你">第17讲 | P2P协议：我下小电影，99%急死你</h2><p>如果你想下载一个电影，一般会通过什么方式呢？</p><p>当然，最简单的方式就是通过<strong>HTTP</strong>进行下载。但是相信你有过这样的体验，通过浏览器下载的时候，只要文件稍微大点，下载的速度就奇慢无比。</p><p>还有种下载文件的方式，就是通过<strong>FTP</strong>，也即<strong>文件传输协议</strong>。FTP 采用两个 TCP 连接来传输一个文件。</p><ul><li><strong>控制连接</strong>：服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将命令从客户端传给服务器，并传回服务器的应答。常用的命令有：list——获取文件目录；reter——取一个文件；store——存一个文件。</li><li><strong>数据连接</strong>：每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。</li></ul><h3 id="17-1-FTP-的两种工作模式">17.1 FTP 的两种工作模式</h3><p>每传输一个文件，都要建立一个全新的数据连接。FTP 有两种工作模式，分别是<strong>主动模式（PORT）<strong>和</strong>被动模式（PASV）</strong>，这些都是站在 FTP 服务器的角度来说的。</p><p>主动模式下，客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1。</p><p>被动模式下，当开启一个 FTP 连接时，客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回”227 entering passive mode”消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。</p><h3 id="17-2-P2P-是什么？">17.2 P2P 是什么？</h3><p>但是无论是 HTTP 的方式，还是 FTP 的方式，都有一个比较大的缺点，就是<strong>难以解决单一服务器的带宽压力</strong>， 因为它们使用的都是传统的客户端服务器的方式。</p><p>后来，一种创新的、称为 P2P 的方式流行起来。<strong>P2P</strong>就是<strong>peer-to-peer</strong>。资源开始并不集中地存储在某些设备上，而是分散地存储在多台设备上。这些设备我们姑且称为 peer。</p><p>想要下载一个文件的时候，你只要得到那些已经存在了文件的 peer，并和这些 peer 之间，建立点对点的连接，而不需要到中心服务器上，就可以就近下载文件。一旦下载了文件，你也就成为 peer 中的一员，你旁边的那些机器，也可能会选择从你这里下载文件，所以当你使用 P2P 软件的时候，例如 BitTorrent，往往能够看到，既有下载流量，也有上传的流量，也即你自己也加入了这个 P2P 的网络，自己从别人那里下载，同时也提供给其他人下载。可以想象，这种方式，参与的人越多，下载速度越快，一切完美。</p><h3 id="17-3-种子（-torrent）文件">17.3 种子（.torrent）文件</h3><p>但是有一个问题，当你想下载一个文件的时候，怎么知道哪些 peer 有这个文件呢？</p><p>这就用到<strong>种子</strong>啦，也即咱们比较熟悉的**.torrent** 文件。.torrent 文件由两部分组成，分别是：<strong>announce（tracker URL）<strong>和</strong>文件信息</strong>。</p><p>文件信息里面有这些内容。</p><ul><li><strong>info 区</strong>：这里指定的是该种子有几个文件、文件有多长、目录结构，以及目录和文件的名字。</li><li><strong>Name 字段</strong>：指定顶层目录名字。</li><li><strong>每个段的大小</strong>：BitTorrent（简称 BT）协议把一个文件分成很多个小段，然后分段下载。</li><li><strong>段哈希值</strong>：将整个种子中，每个段的 SHA-1 哈希值拼在一起。</li></ul><p>下载时，BT 客户端首先解析.torrent 文件，得到 tracker 地址，然后连接 tracker 服务器。tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者。下载者再连接其他下载者，根据.torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。</p><p>下载者每得到一个块，需要算出下载块的 Hash 验证码，并与.torrent 文件中的对比。如果一样，则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。</p><p>从这个过程也可以看出，这种方式特别依赖 tracker。tracker 需要收集下载者信息的服务器，并将此信息提供给其他下载者，使下载者们相互连接起来，传输数据。虽然下载的过程是非中心化的，但是加入这个 P2P 网络的时候，都需要借助 tracker 中心服务器，这个服务器是用来登记有哪些用户在请求哪些资源。</p><p>所以，这种工作方式有一个弊端，一旦 tracker 服务器出现故障或者线路遭到屏蔽，BT 工具就无法正常工作了。</p><h3 id="17-4-去中心化网络（DHT）">17.4 去中心化网络（DHT）</h3><p>于是，后来就有了一种叫作**DHT（Distributed Hash Table）**的去中心化网络。每个加入这个 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。</p><p>有一种著名的 DHT 协议，叫<strong>Kademlia 协议</strong>。这个和区块链的概念一样，很抽象，我来详细讲一下这个协议。</p><p>任何一个 BitTorrent 启动之后，它都有两个角色。一个是<strong>peer</strong>，监听一个 TCP 端口，用来上传和下载文件，这个角色表明，我这里有某个文件。另一个角色<strong>DHT node</strong>，监听一个 UDP 的端口，通过这个角色，这个节点加入了一个 DHT 的网络。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523160112112.png" alt="image-20240523160112112"></p><p>在 DHT 网络里面，每一个 DHT node 都有一个 ID。这个 ID 是一个很长的串。每个 DHT node 都有责任掌握一些知识，也就是<strong>文件索引</strong>，也即它应该知道某些文件是保存在哪些节点上。它只需要有这些知识就可以了，而它自己本身不一定就是保存这个文件的节点。</p><h3 id="17-5-哈希值">17.5 哈希值</h3><p>当然，每个 DHT node 不会有全局的知识，也即不知道所有的文件保存在哪里，它只需要知道一部分。那应该知道哪一部分呢？这就需要用哈希算法计算出来。</p><p>每个文件可以计算出一个哈希值，而<strong>DHT node 的 ID 是和哈希值相同长度的串</strong>。</p><p>DHT 算法是这样规定的：<strong>如果一个文件计算出一个哈希值，则和这个哈希值一样的那个 DHT node，就有责任知道从哪里下载这个文件，即便它自己没保存这个文件</strong>。</p><p>当然不一定这么巧，总能找到和哈希值一模一样的，有可能一模一样的 DHT node 也下线了，所以 DHT 算法还规定：除了一模一样的那个 DHT node 应该知道，ID 和这个哈希值非常接近的 N 个 DHT node 也应该知道。</p><p>什么叫和哈希值接近呢？例如只修改了最后一位，就很接近；修改了倒数 2 位，也不远；修改了倒数 3 位，也可以接受。总之，凑齐了规定的 N 这个数就行。</p><p>刚才那个图里，文件 1 通过哈希运算，得到匹配 ID 的 DHT node 为 node C，当然还会有其他的，我这里没有画出来。所以，node C 有责任知道文件 1 的存放地址，虽然 node C 本身没有存放文件 1。</p><p>同理，文件 2 通过哈希运算，得到匹配 ID 的 DHT node 为 node E，但是 node D 和 E 的 ID 值很近，所以 node D 也知道。当然，文件 2 本身没有必要一定在 node D 和 E 里，但是碰巧这里就在 E 那有一份。</p><p>接下来一个新的节点 node new 上线了。如果想下载文件 1，它首先要加入 DHT 网络，如何加入呢？</p><p>在这种模式下，种子.torrent 文件里面就不再是 tracker 的地址了，而是一个 list 的 node 的地址，而所有这些 node 都是已经在 DHT 网络里面的。当然随着时间的推移，很可能有退出的，有下线的，但是我们假设，不会所有的都联系不上，总有一个能联系上。</p><p>node new 只要在种子里面找到一个 DHT node，就加入了网络。</p><p>node new 会计算文件 1 的哈希值，并根据这个哈希值了解到，和这个哈希值匹配，或者很接近的 node 上知道如何下载这个文件，例如计算出来的哈希值就是 node C。</p><p>但是 node new 不知道怎么联系上 node C，因为种子里面的 node 列表里面很可能没有 node C，但是它可以问，DHT 网络特别像一个社交网络，node new 只有去它能联系上的 node 问，你们知道不知道 node C 的联系方式呀？</p><p>在 DHT 网络中，每个 node 都保存了一定的联系方式，但是肯定没有 node 的所有联系方式。DHT 网络中，节点之间通过互相通信，也会交流联系方式，也会删除联系方式。和人们的方式一样，你有你的朋友圈，你的朋友有它的朋友圈，你们互相加微信，就互相认识了，过一段时间不联系，就删除朋友关系。</p><p>有个理论是，社交网络中，任何两个人直接的距离不超过六度，也即你想联系比尔盖茨，也就六个人就能够联系到了。</p><p>所以，node new 想联系 node C，就去万能的朋友圈去问，并且求转发，朋友再问朋友，很快就能找到。如果找不到 C，也能找到和 C 的 ID 很像的节点，它们也知道如何下载文件 1。</p><p>在 node C 上，告诉 node new，下载文件 1，要去 B、D、 F，于是 node new 选择和 node B 进行 peer 连接，开始下载，它一旦开始下载，自己本地也有文件 1 了，于是 node new 告诉 node C 以及和 node C 的 ID 很像的那些节点，我也有文件 1 了，可以加入那个文件拥有者列表了。</p><p>但是你会发现 node new 上没有文件索引，但是根据哈希算法，一定会有某些文件的哈希值是和 node new 的 ID 匹配上的。在 DHT 网络中，会有节点告诉它，你既然加入了咱们这个网络，你也有责任知道某些文件的下载地址。</p><p>好了，一切都分布式了。</p><p>这里面遗留几个细节的问题。</p><ol><li><p>DHT node ID 以及文件哈希是个什么东西？</p><p>节点 ID 是一个随机选择的 160bits（20 字节）空间，文件的哈希也使用这样的 160bits 空间。</p></li><li><p>所谓 ID 相似，具体到什么程度算相似？</p><p>在 Kademlia 网络中，距离是通过异或（XOR）计算的。我们就不以 160bits 举例了。我们以 5 位来举例。</p><p>01010 与 01000 的距离，就是两个 ID 之间的异或值，为 00010，也即为 2。 01010 与 00010 的距离为 01000，也即为 8,。01010 与 00011 的距离为 01001，也即 8+1=9 。以此类推，高位不同的，表示距离更远一些；低位不同的，表示距离更近一些，总的距离为所有的不同的位的距离之和。</p><p>这个距离不能比喻为地理位置，因为在 Kademlia 网络中，位置近不算近，ID 近才算近，所以我把这个距离比喻为社交距离，也即在朋友圈中的距离，或者社交网络中的距离。这个和你住的位置没有关系，和人的经历关系比较大。</p><p>还是以 5 位 ID 来举例，就像在领英中，排第一位的表示最近一份工作在哪里，第二位的表示上一份工作在哪里，然后第三位的是上上份工作，第四位的是研究生在哪里读，第五位的表示大学在哪里读。</p><p>如果你是一个猎头，在上面找候选人，当然最近的那份工作是最重要的。而对于工作经历越丰富的候选人，大学在哪里读的反而越不重要。</p></li></ol><h3 id="17-6-DHT-网络中的朋友圈是怎么维护的？">17.6 DHT 网络中的朋友圈是怎么维护的？</h3><p>就像人一样，虽然我们常联系人的只有少数，但是朋友圈里肯定是远近都有。DHT 网络的朋友圈也是一样，远近都有，并且按<strong>距离分层</strong>。</p><p>假设某个节点的 ID 为 01010，如果一个节点的 ID，前面所有位数都与它相同，只有最后 1 位不同。这样的节点只有 1 个，为 01011。与基础节点的异或值为 00001，即距离为 1；对于 01010 而言，这样的节点归为”k-bucket 1”。</p><p>如果一个节点的 ID，前面所有位数都相同，从倒数第 2 位开始不同，这样的节点只有 2 个，即 01000 和 01001，与基础节点的异或值为 00010 和 00011，即距离范围为 2 和 3；对于 01010 而言，这样的节点归为”k-bucket 2”。</p><p>如果一个节点的 ID，前面所有位数相同，从倒数第 i 位开始不同，这样的节点只有 2^(i-1) 个，与基础节点的距离范围为 [2^(i-1), 2^i)；对于 01010 而言，这样的节点归为”k-bucket i”。</p><p>最终到从倒数 160 位就开始都不同。</p><p>你会发现，差距越大，陌生人越多，但是朋友圈不能都放下，所以每一层都只放 K 个，这是参数可以配置。</p><h3 id="17-7-DHT-网络是如何查找朋友的？">17.7 DHT 网络是如何查找朋友的？</h3><p>假设，node A 的 ID 为 00110，要找 node B ID 为 10000，异或距离为 10110，距离范围在 [2^4, 2^5)，所以这个目标节点可能在”k-bucket 5”中，这就说明 B 的 ID 与 A 的 ID 从第 5 位开始不同，所以 B 可能在”k-bucket 5”中。</p><p>然后，A 看看自己的 k-bucket 5 有没有 B。如果有，太好了，找到你了；如果没有，在 k-bucket 5 里随便找一个 C。因为是二进制，C、B 都和 A 的第 5 位不同，那么 C 的 ID 第 5 位肯定与 B 相同，即它与 B 的距离会小于 2^4，相当于比 A、B 之间的距离缩短了一半以上。</p><p>再请求 C，在它自己的通讯录里，按同样的查找方式找一下 B。如果 C 知道 B，就告诉 A；如果 C 也不知道 B，那 C 按同样的搜索方法，可以在自己的通讯录里找到一个离 B 更近的 D 朋友（D、B 之间距离小于 2^3），把 D 推荐给 A，A 请求 D 进行下一步查找。</p><p>Kademlia 的这种查询机制，是通过折半查找的方式来收缩范围，对于总的节点数目为 N，最多只需要查询 log2(N) 次，就能够找到。</p><p>例如，图中这个最差的情况。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523160146516.png" alt="image-20240523160146516"></p><p>A 和 B 每一位都不一样，所以相差 31，A 找到的朋友 C，不巧正好在中间。和 A 的距离是 16，和 B 距离为 15，于是 C 去自己朋友圈找的时候，不巧找到 D，正好又在中间，距离 C 为 8，距离 B 为 7。于是 D 去自己朋友圈找的时候，不巧找到 E，正好又在中间，距离 D 为 4，距离 B 为 3，E 在朋友圈找到 F，距离 E 为 2，距离 B 为 1，最终在 F 的朋友圈距离 1 的地方找到 B。当然这是最最不巧的情况，每次找到的朋友都不远不近，正好在中间。</p><p>如果碰巧了，在 A 的朋友圈里面有 G，距离 B 只有 3，然后在 G 的朋友圈里面一下子就找到了 B，两次就找到了。</p><h3 id="17-8-在-DHT-网络中，朋友之间怎么沟通呢？">17.8 在 DHT 网络中，朋友之间怎么沟通呢？</h3><ul><li>PING：测试一个节点是否在线，还活着没，相当于打个电话，看还能打通不。</li><li>STORE：要求一个节点存储一份数据，既然加入了组织，有义务保存一份数据。</li><li>FIND_NODE：根据节点 ID 查找一个节点，就是给一个 160 位的 ID，通过上面朋友圈的方式找到那个节点。</li><li>FIND_VALUE：根据 KEY 查找一个数据，实则上跟 FIND_NODE 非常类似。KEY 就是文件对应的 160 位的 ID，就是要找到保存了文件的节点。</li></ul><h3 id="17-9-DHT-网络中，朋友圈如何更新呢？">17.9 DHT 网络中，朋友圈如何更新呢？</h3><ul><li>每个 bucket 里的节点，都按最后一次接触的时间倒序排列，这就相当于，朋友圈里面最近联系过的人往往是最熟的。</li><li>每次执行四个指令中的任意一个都会触发更新。</li><li>当一个节点与自己接触时，检查它是否已经在 k-bucket 中，也就是说是否已经在朋友圈。如果在，那么将它挪到 k-bucket 列表的最底，也就是最新的位置，刚联系过，就置顶一下，方便以后多联系；如果不在，新的联系人要不要加到通讯录里面呢？假设通讯录已满的情况，PING 一下列表最上面，也即最旧的一个节点。如果 PING 通了，将旧节点挪到列表最底，并丢弃新节点，老朋友还是留一下；如果 PING 不通，删除旧节点，并将新节点加入列表，这人联系不上了，删了吧。</li></ul><p>这个机制保证了任意节点加入和离开都不影响整体网络。</p><h3 id="17-10-小结">17.10 小结</h3><p>总结一下：</p><ul><li>下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；</li><li>P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散</li></ul><p><strong>Note：</strong></p><p><strong>FTP 采用两个 TCP 连接来传输一个文件。这是为什么呢?</strong></p><p>FTP（文件传输协议）使用两个TCP连接进行文件传输的原因是为了隔离命令交流和数据传输。这两个连接分别是命令连接（也称为控制连接）和数据连接。</p><ol><li>命令连接：在FTP客户端和服务器之间建立的持久连接，用于发送控制信息，比如登陆认证、改变远程目录、获取文件列表等命令。这个连接在FTP会话期间始终保持打开状态。</li><li>数据连接：用于实际的文件传输。每次需要传输文件或文件列表时，FTP服务器会建立一个新的数据连接。文件传输完成后，这个数据连接就会被关闭。</li></ol><p>这种设计的好处是，命令连接和数据连接可以并行工作，提高了效率。例如，在传输大文件的过程中，用户仍然可以通过命令连接发送其他命令，比如暂停当前的文件传输，或者请求另一个文件的传输。这就需要两个独立的TCP连接来实现。</p><p><strong>P2P协议原理</strong></p><p>P2P（Peer-to-Peer）协议是一种网络通信模型，其中每一个节点（Peer）既是客户端又是服务器，可以直接与其他节点进行数据交换，而无需通过中间服务器。这种协议的核心思想是资源共享，每个节点都可以提供和接受服务。</p><p>下面是P2P协议的工作原理的解释：</p><ol><li><strong>资源发现</strong>：首先，当一个节点需要某个资源时，它会在网络中广播一个请求，寻找拥有这个资源的其他节点。</li><li><strong>连接建立</strong>：当一个节点接收到资源请求后，如果它拥有所请求的资源，它会与请求节点建立直接的连接。</li><li><strong>资源共享</strong>：一旦连接建立，资源就可以直接从拥有资源的节点传输到请求节点。这种传输是对等的，也就是说，任何节点都可以成为数据的发送者或接收者。</li><li><strong>动态性</strong>：P2P网络是动态的，节点可以随时加入和离开网络，资源的位置也可能随时改变。因此，P2P协议需要能够处理这种动态性，例如通过实时更新资源的位置信息。</li></ol><p>总的来说，P2P协议利用了网络中每个节点的资源，通过去中心化的方式实现了高效的数据传输。它在文件分享、流媒体传输、分布式存储等领域有广泛的应用。</p>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块3:传输层</title>
    <link href="https://penge666.github.io/posts/e4f4b13d.html"/>
    <id>https://penge666.github.io/posts/e4f4b13d.html</id>
    <published>2024-05-23T03:40:28.000Z</published>
    <updated>2024-05-23T03:41:30.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第10讲-UDP协议：因性善而简单，难免碰到”城会玩”">第10讲 | UDP协议：因性善而简单，难免碰到”城会玩”</h2><h3 id="10-1-TCP-和-UDP-有哪些区别？">10.1 TCP 和 UDP 有哪些区别？</h3><p>一般面试的时候我问这两个协议的区别，大部分人会回答，TCP 是面向连接的，UDP 是面向无连接的。</p><p>什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会。为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？</p><p><strong>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</strong></p><p>例如，<strong>TCP 提供可靠交付</strong>。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。我们都知道 IP 包是没有任何可靠性保证的，一旦发出去，就像西天取经，走丢了、被妖怪吃了，都只能随它去。但是 TCP 号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。而<strong>UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达</strong>。</p><p>再如，<strong>TCP 是面向字节流的</strong>。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而<strong>UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</strong>。</p><p>还有<strong>TCP 是可以有拥塞控制的</strong>。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。<strong>UDP 就不会，应用让我发，我就发，管它洪水滔天</strong>。</p><p>因而<strong>TCP 其实是一个有状态服务</strong>，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 <strong>UDP 则是无状态服务。</strong> 通俗地说是没脑子的，天真无邪的，发出去就发出去了。</p><p>我们可以这样比喻，如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p><h3 id="10-2-UDP-包头是什么样的？">10.2 UDP 包头是什么样的？</h3><p>前面章节我已经讲过包的传输过程，这里不再赘述。当我发送的 UDP 包到达目标机器后，发现 MAC 地址匹配，于是就取下来，将剩下的包传给处理 IP 层的代码。把 IP 头取下来，发现目标 IP 匹配，接下来呢？这里面的数据包是给谁呢？</p><p>发送的时候，我知道我发的是一个 UDP 的包，收到的那台机器咋知道的呢？所以在 IP 头里面有个 8 位协议，这里会存放，数据里面到底是 TCP 还是 UDP，当然这里是 UDP。于是，如果我们知道 UDP 头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？</p><p>处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？</p><p>无论应用程序写的使用 TCP 传数据，还是 UDP 传数据，都要监听一个端口。正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？所以，按理说，无论是 TCP 还是 UDP 包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523105421463.png" alt="image-20240523105421463"></p><p>当我们看到 UDP 包头的时候，发现的确有端口号，有源端口号和目标端口号。因为是两端通信嘛，这很好理解。但是你还会发现，UDP 除了端口号，再没有其他的了。和下两节要讲的 TCP 头比起来，这个简直简单得一塌糊涂啊！</p><h3 id="10-3-UDP-的三大特点">10.3 UDP 的三大特点</h3><p>第一，<strong>沟通简单</strong>，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。</p><p>第二，<strong>轻信他人</strong>。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。</p><p>第三，<strong>愣头青</strong>，做事不懂权变。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</p><h3 id="10-4-UDP-的三大使用场景">10.4 UDP 的三大使用场景</h3><p>基于 UDP 这种”小孩子”的特点，我们可以考虑在以下的场景中使用。</p><p>第一，<strong>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</strong>。这很好理解，就像如果你是领导，你会让你们组刚毕业的小朋友去做一些没有那么难的项目，打一些没有那么难的客户，或者做一些失败了也能忍受的实验性项目。</p><p>我们在第四节讲的 <strong>DHCP 就是基于 UDP 协议的</strong>。一般的获取 IP 地址都是内网请求，而且一次获取不到 IP 又没事，过一会儿还有机会。我们讲过 PXE 可以在启动的时候自动安装操作系统，操作系统镜像的下载使用的 TFTP，这个也是基于 UDP 协议的。在还没有操作系统的时候，客户端拥有的资源很少，不适合维护一个复杂的状态机，而是因为是内网，一般也没啥问题。</p><p>第二，<strong>不需要一对一沟通，建立连接，而是可以广播的应用</strong>。咱们小时候人都很简单，大家在班级里面，谁成绩好，谁写作好，应该表扬谁惩罚谁，谁得几个小红花都是当着全班的面讲的，公平公正公开。长大了人心复杂了，薪水、奖金要背靠背，和员工一对一沟通。</p><p>UDP 的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP 就是一种广播的形式，就是基于 UDP 协议的，而广播包的格式前面说过了。</p><p>对于多播，我们在讲 IP 地址的时候，讲过一个 D 类地址，也即组播地址，使用这个地址，可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送 IGMP 包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。</p><p>在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。</p><p>第三，<strong>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong>。记得曾国藩建立湘军的时候，专门招出生牛犊不怕虎的新兵，而不用那些”老油条”的八旗兵，就是因为八旗兵经历的事情多，遇到敌军不敢舍死忘生。</p><p>同理，UDP 简单、处理速度快，不像 TCP 那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而 TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。</p><p>当前很多应用都是要求低时延的，它们可不想用 TCP 如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于 TCP。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达。</p><p>由于 UDP 十分简单，基本啥都没做，也就给了应用”城会玩”的机会。就像在和平年代，每个人应该有独立的思考和行为，应该可靠并且礼让；但是如果在战争年代，往往不太需要过于独立的思考，而需要士兵简单服从命令就可以了。</p><p>曾国藩说哪支部队需要诱敌牺牲，也就牺牲了，相当于包丢了就丢了。两军狭路相逢的时候，曾国藩说上，没有带宽也要上，这才给了曾国藩运筹帷幄，城会玩的机会。同理如果你实现的应用需要有自己的连接策略，可靠保证，时延要求，使用 UDP，然后再应用层实现这些是再好不过了。</p><h3 id="10-5-基于-UDP-的”城会玩”的五个例子">10.5 基于 UDP 的”城会玩”的五个例子</h3><ol><li><p>“城会玩”一：网页或者 APP 的访问</p><p>原来访问网页和手机 APP 都是基于 HTTP 协议的。HTTP 协议是基于 TCP 的，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，TCP 可能还会断了重连，也是很耗时的。而且目前的 HTTP 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。</p><p>而QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</p><p>QUIC 在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制，是应用层”城会玩”的代表。这一节主要是讲 UDP，QUIC 我们放到应用层去讲。</p></li><li><p>“城会玩”二：流媒体的协议</p><p>现在直播比较火，直播协议多使用 RTMP，这个协议我们后面的章节也会讲，而这个 RTMP 协议也是基于 TCP 的。TCP 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。对于直播来讲，这显然是不合适的，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，新的也看不了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。</p><p>另外，对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。</p><p>还有就是当网络不好的时候，TCP 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。</p></li><li><p>“城会玩”三：实时游戏</p><p>游戏有一个特点，就是实时性比较高。快一秒你干掉别人，慢一秒你被别人爆头，所以很多职业玩家会买非常专业的鼠标和键盘，争分夺秒。</p><p>因而，实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护 TCP 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 TCP 连接数目是有限的，然后 UDP 由于是没有连接的，在异步 IO 机制引入之前，常常是应对海量客户端连接的策略。</p><p>另外还是 TCP 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。</p><p>如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。</p><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p></li><li><p>“城会玩”四：IoT 物联网</p><p>一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大；另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的。</p></li><li><p>“城会玩”五：移动通信领域</p><p>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的。因为移动网络协议比较复杂，而 GTP 协议本身就包含复杂的手机上线下线的通信协议。如果基于 TCP，TCP 的机制就显得非常多余，这部分协议我会在后面的章节单独讲解。</p></li></ol><h3 id="10-6-小结">10.6 小结</h3><p>总结一下：</p><ol><li>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；</li><li>UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</li></ol><h2 id="第11讲-TCP协议（上）：因性恶而复杂，先恶后善反轻松">第11讲 | TCP协议（上）：因性恶而复杂，先恶后善反轻松</h2><h3 id="11-1-TCP-包头格式">11.1 TCP 包头格式</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110216648.png" alt="image-20240523110216648"></p><p>首先，源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。</p><p>接下来是包的序号。为什么要给包编号呢？当然是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。既然是社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。</p><p>还应该有的就是确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。</p><p>TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。</p><p>这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。</p><p>接下来有一些状态位。例如 <strong>SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等</strong>。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>作为老司机，做事情要有分寸，待人要把握尺度，既能适当提出自己的要求，又不强人所难。除了做流量控制以外，TCP 还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：</p><ul><li>顺序问题，稳重不乱；</li><li>丢包问题，承诺靠谱；</li><li>连接维护，有始有终；</li><li>流量控制，把握分寸；</li><li>拥塞控制，知进知退。</li></ul><h3 id="11-2-TCP-的三次握手">11.2 TCP 的三次握手</h3><p>TCP 的连接建立，我们常常称为三次握手。</p><ul><li>A：您好，我是 A。</li><li>B：您好 A，我是 B。</li><li>A：您好 B。</li></ul><p>我们也常称为”请求 -&gt; 应答 -&gt; 应答之应答”的三个回合。这个看起来简单，其实里面还是有很多的学问，很多的细节。</p><p>首先，为什么要三次，而不是两次？按说两个人打招呼，一来一回就可以了啊？为了可靠，为什么不是四次？</p><p>我们还是假设这个通路是非常不可靠的，A 要发起一个连接，当发了第一个请求杳无音信的时候，会有很多的可能性，比如第一个请求包丢了，再如没有丢，但是绕了弯路，超时了，还有 B 没有响应，不想和我连接。</p><p>A 不能确认结果，于是再发，再发。终于，有一个请求包到了 B，但是请求包到了 B 的这个事情，目前 A 还是不知道的，A 还有可能再发。</p><p>B 收到了请求包，就知道了 A 的存在，并且知道 A 要和它建立连接。如果 B 不乐意建立连接，则 A 会重试一阵后放弃，连接建立失败，没有问题；如果 B 是乐意建立连接的，则会发送应答包给 A。</p><p>当然对于 B 来说，这个应答包也是一入网络深似海，不知道能不能到达 A。这个时候 B 自然不能认为连接是建立好了，因为应答包仍然会丢，会绕弯路，或者 A 已经挂了都有可能。</p><p>而且这个时候 B 还能碰到一个诡异的现象就是，A 和 B 原来建立了连接，做了简单通信后，结束了连接。还记得吗？A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了，B 会认为这也是一个正常的的请求的话，因此建立了连接，可以想象，这个连接不会进行下去，也没有个终结的时候，纯属单相思了。因而两次握手肯定不行。</p><p>B 发送的应答可能会发送多次，但是只要一次到达 A，A 就认为连接已经建立了，因为对于 A 来讲，他的消息有去有回。A 会给 B 发送应答之应答，而 B 也在等这个消息，才能确认连接的建立，只有等到了这个消息，对于 B 来讲，才算它的消息有去有回。</p><p>当然 A 发给 B 的应答之应答也会丢，也会绕路，甚至 B 挂了。按理来说，还应该有个应答之应答之应答，这样下去就没底了。所以四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。</p><p>好在大部分情况下，A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决。例如 A 发给 B 的应答丢了，当 A 后续发送的数据到达的时候，B 可以认为这个连接已经建立，或者 B 压根就挂了，A 发送的数据，会报错，说 B 不可达，A 就知道 B 出事情了。</p><p>当然你可以说 A 比较坏，就是不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启 keepalive 机制，即使没有真实的数据包，也有探活包。</p><p>另外，你作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。</p><p>三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是<strong>TCP 包的序号的问题</strong>。</p><p>A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。</p><p>例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。</p><p>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4ms 加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 TTL，也即生存时间。</p><p>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110514867.png" alt="image-20240523110514867"></p><p>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。然后客户端主动发起连接 SYN，之后处于 <code>SYN-SENT</code> 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 <code>SYN-RCVD</code> 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</p><h3 id="11-3-TCP-四次挥手">11.3 TCP 四次挥手</h3><p>好了，说完了连接，接下来说一说”拜拜”，好说好散。这常被称为四次挥手。</p><ul><li>A：B 啊，我不想玩了。</li><li>B：哦，你不想玩了啊，我知道了。</li></ul><p>这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢？当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为半关闭的状态。</p><p>这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。</p><ul><li>B：A 啊，好吧，我也不玩了，拜拜。</li><li>A：好的，拜拜。</li></ul><p>这样整个连接就关闭了。但是这个过程有没有异常情况呢？当然有，上面是和平分手的场面。</p><p>A 开始说”不玩了”，B 说”知道了”，这个回合，是没什么问题的，因为在此之前，双方还处于合作的状态，如果 A 说”不玩了”，没有收到回复，则 A 会重新发送”不玩了”。但是这个回合结束之后，就有可能出现异常情况了，因为已经有一方率先撕破脸。</p><p>一种情况是，A 说完”不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了。另一种情况是，A 说完”不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束。</p><p>那怎么解决这些问题呢？TCP 协议专门设计了几个状态来处理这些问题。我们来看断开连接的时候的<strong>状态时序图</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110917507.png" alt="image-20240523110917507"></p><p>断开的时候，我们可以看到，当 A 说”不玩了”，就进入 FIN_WAIT_1 的状态，B 收到”A 不玩”的消息后，发送知道了，就进入 CLOSE_WAIT 的状态。</p><p>A 收到”B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p><p>如果 B 没有跑路，发送了”B 也不玩了”的请求到达 A 时，A 发送”知道 B 也不玩了”的 ACK 后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一个”B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而 TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，”B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。</p><p>A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。</p><p>等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</p><p>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p><h3 id="11-4-TCP-状态机">11.4 TCP 状态机</h3><p>将连接建立和连接断开的两个时序状态图综合起来，就是这个著名的 TCP 的状态机。学习的时候比较建议将这个状态机和时序状态机对照着看，不然容易晕。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110956241.png" alt="image-20240523110956241"></p><p>在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是连接过程中的顺序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端 A 的状态变迁，加粗的虚线是服务端 B 的状态变迁。</p><h3 id="11-5-小结">11.5 小结</h3><p>总结：</p><ul><li>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</li><li>连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。</li></ul><h2 id="第12讲-TCP协议（下）：西行必定多妖孽，恒心智慧消磨难">第12讲 | TCP协议（下）：西行必定多妖孽，恒心智慧消磨难</h2><p>我们前面说到玄奘西行，要出网关。既然出了网关，那就是在公网上传输数据，公网往往是不可靠的，因而需要很多的机制去保证传输的可靠性，这里面需要恒心，也即各种<strong>重传的策略</strong>，还需要有智慧，也就是说，这里面包含着<strong>大量的算法</strong>。</p><h3 id="12-1-如何做个靠谱的人？">12.1 如何做个靠谱的人？</h3><p>TCP 想成为一个成熟稳重的人，成为一个靠谱的人。那一个人怎么样才算靠谱呢？咱们工作中经常就有这样的场景，比如你交代给下属一个事情以后，下属到底能不能做到，做到什么程度，什么时候能够交付，往往就会有应答，有回复。这样，处理事情的过程中，一旦有异常，你也可以尽快知道，而不是交代完之后就石沉大海，过了一个月再问，他说，啊我不记得了。</p><p>对应到网络协议上，就是客户端每发送的一个包，服务器端都应该有个回复，如果服务器端超过一定的时间没有回复，客户端就会重新发送这个包，直到有回复。</p><p>这个发送应答的过程是什么样呢？可以是<strong>上一个收到了应答，再发送下一个</strong>。这种模式有点像两个人直接打电话，你一句，我一句。但是这种方式的缺点是效率比较低。如果一方在电话那头处理的时间比较长，这一头就要干等着，双方都没办法干其他事情。咱们在日常工作中也不是这样的，不能你交代你的下属办一件事情，就一直打着电话看着他做，而是应该他按照你的安排，先将事情记录下来，办完一件回复一件。在他办事情的过程中，你还可以同时交代新的事情，这样双方就并行了。</p><p>如果使⽤这种模式，其实需要你和你的下属就不能靠脑⼦了，⽽是要都准备⼀个本⼦，你每交代下属⼀个事情，双方的本子都要记录⼀下。</p><p>当你的下属做完⼀件事情，就回复你，做完了，你就在你的本⼦上将这个事情划去。同时你的本⼦上每件事情都有时限，如果超过了时限下属还没有回复，你就要主动重新交代⼀下：上次那件事情，你还没回复我，咋样啦？</p><p>既然多件事情可以一起处理，那就需要给每个事情编个号，防止弄错了。例如，程序员平时看任务的时候，都会看 JIRA 的 ID，而不是每次都要描述一下具体的事情。在大部分情况下，对于事情的处理是按照顺序来的，先来的先处理，这就给应答和汇报工作带来了方便。等开周会的时候，每个程序员都可以将 JIRA ID 的列表拉出来，说以上的都做完了，⽽不⽤⼀个个说</p><h3 id="12-2-如何实现一个靠谱的协议？">12.2 如何实现一个靠谱的协议？</h3><p>TCP 协议使用的也是同样的模式。为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为<strong>累计确认</strong>或者<strong>累计应答（cumulative acknowledgment）</strong>。</p><p>为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。</p><ul><li>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的。</li><li>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。</li><li>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的。</li><li>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。</li></ul><p>这里面为什么要区分第三部分和第四部分呢？没交代的，一下子全交代了不就完了吗？</p><p>这就是我们上一节提到的十个词口诀里的”流量控制，把握分寸”。作为项目管理人员，你应该根据以往的工作情况和这个员工反馈的能力、抗压力等，先在心中估测一下，这个人一天能做多少工作。如果工作布置少了，就会不饱和；如果工作布置多了，他就会做不完；如果你使劲逼迫，人家可能就要辞职了。</p><p>到底一个员工能够同时处理多少事情呢？在 TCP 里，接收端会给发送端报一个窗口的大小，叫<strong>Advertised window</strong>。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。</p><p>于是，<strong>发送端</strong>需要保持下面的数据结构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523111205217.png" alt="image-20240523111205217"></p><ul><li>LastByteAcked：第一部分和第二部分的分界线</li><li>LastByteSent：第二部分和第三部分的分界线</li><li>LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线</li></ul><p>对于接收端来讲，它的缓存里记录的内容要简单一些。</p><ul><li>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的。</li><li>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。</li><li>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523111221657.png" alt="image-20240523111221657"></p><ul><li>MaxRcvBuffer：最大缓存的量；</li><li>LastByteRead 之后是已经接收了，但是还没被应用层读取的；</li><li>NextByteExpected 是第一部分和第二部分的分界线。</li></ul><p>第二部分的窗口有多大呢？</p><p>NextByteExpected 和 LastByteRead 的差其实是还没被应用层读取的部分占用掉的 MaxRcvBuffer 的量，我们定义为 A。</p><p>AdvertisedWindow 其实是 MaxRcvBuffer 减去 A。</p><p>也就是：AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead)。</p><p>那第二部分和第三部分的分界线在哪里呢？NextByteExpected 加 AdvertisedWindow 就是第二部分和第三部分的分界线，其实也就是 LastByteRead 加上 MaxRcvBuffer。</p><p>其中第二部分里面，由于受到的包可能不是顺序的，会出现空挡，只有和第一部分连续的，可以马上进行回复，中间空着的部分需要等待，哪怕后面的已经来了</p><h3 id="12-3-顺序问题与丢包问题">12.3 顺序问题与丢包问题</h3><p>接下来我们结合一个例子来看。</p><p>还是刚才的图，在发送端来看，1、2、3 已经发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p><p>在接收端来看，1、2、3、4、5 是已经完成 ACK，但是没读取的；6、7 是等待接收的；8、9 是已经接收，但是没有 ACK 的。</p><p>发送端和接收端当前的状态如下：</p><ul><li>1、2、3 没有问题，双方达成了一致。</li><li>4、5 接收方说 ACK 了，但是发送方还没收到，有可能丢了，有可能在路上。</li><li>6、7、8、9 肯定都发了，但是 8、9 已经到了，但是 6、7 没到，出现了乱序，缓存着但是没办法 ACK。</li></ul><p>根据这个例子，我们可以知道，顺序问题和丢包问题都有可能发生，所以我们先来看<strong>确认与重发的机制</strong>。</p><p>假设 4 的确认到了，不幸的是，5 的 ACK 丢了，6、7 的数据包丢了，这该怎么办呢？</p><p>一种方法就是<strong>超时重试</strong>，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。</p><p>估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为<strong>自适应重传算法（Adaptive Retransmission Algorithm）</strong>。</p><p>如果过一段时间，5、6、7 都超时了，就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，有需要重传的时候，TCP 的策略是<strong>超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</strong>。</p><p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><p>有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。</p><p>例如，接收方发现 6、8、9 都已经接收了，就是 7 没来，那肯定是丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p><p>还有一种方式称为<strong>Selective Acknowledgment （SACK）</strong>。这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。</p><h3 id="12-4-流量控制问题">12.4 流量控制问题</h3><p>我们再来看流量控制机制，在对于包的确认中，同时会携带一个窗口的大小。</p><p>我们先假设窗口不变的情况，窗口始终为 9。4 的确认来的时候，会右移一个，这个时候第 13 个包也可以发送了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523111544852.png" alt="image-20240523111544852"></p><p>这个时候，假设发送端发送过猛，会将第三部分的 10、11、12、13 全部发送完毕，之后就停止发送了，未发送可发送部分为 0。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112548130.png" alt="image-20240523112548130"></p><p>当对于包 5 的确认到达的时候，在客户端相当于窗口再滑动了一格，这个时候，才可以有更多的包可以发送了，例如第 14 个包才可以发送。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112603538.png" alt="image-20240523112603538"></p><p>如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小，甚至可以设置为 0，则发送方将暂时停止发送。</p><p>我们假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口大小就不能再是 9 了，就要缩小一个变为 8。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112620635.png" alt="image-20240523112620635"></p><p>这个新的窗口 8 通过 6 的确认消息到达发送端的时候，你会发现窗口没有平行右移，而是仅仅左面的边右移了，窗口的大小从 9 改成了 8。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112641760.png" alt="image-20240523112641760"></p><p>如果接收端还是一直不处理数据，则随着确认的包越来越多，窗口越来越小，直到为 0。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112659501.png" alt="image-20240523112659501"></p><p>当这个窗口通过包 14 的确认到达发送端的时候，发送端的窗口也调整为 0，停止发送。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112714826.png" alt="image-20240523112714826"></p><p>如果这样的话，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。</p><p>这就是我们常说的流量控制。</p><h3 id="12-5-拥塞控制问题">12.5 拥塞控制问题</h3><p>最后，我们看一下拥塞控制的问题，也是通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。</p><p>那发送方怎么判断网络是不是满呢？这其实是个挺难的事情，因为对于 TCP 协议来讲，他压根不知道整个网络路径都会经历什么，对他来讲就是一个黑盒。TCP 发送包常被比喻为往一个水管里面灌水，而 TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p><p>水管有粗细，网络有带宽，也即每秒钟能够发送多少数据；水管有长度，端到端有时延。在理想状态下，水管里面水的量 = 水管粗细 x 水管长度。对于到网络上，通道的容量 = 带宽 × 往返延迟。</p><p>如果我们设置发送窗口，使得发送但未确认的包为为通道的容量，就能够撑满整个管道。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113009361.png" alt="image-20240523113009361"></p><p>如图所示，假设往返时间为 8s，去 4s，回 4s，每秒发送一个包，每个包 1024byte。已经过去了 8s，则 8 个包都发出去了，其中前 4 个包已经到达接收端，但是 ACK 还没有返回，不能算发送成功。5-8 后四个包还在路上，还没被接收。这个时候，整个管道正好撑满，在发送端，已发送未确认的为 8 个包，正好等于带宽，也即每秒发送 1 个包，乘以来回时间 8s。</p><p>如果我们在这个基础上再调大窗口，使得单位时间内更多的包可以发送，会出现什么现象呢？</p><p>我们来想，原来发送一个包，从一端到达另一端，假设一共经过四个设备，每个设备处理一个包时间耗费 1s，所以到达另一端需要耗费 4s，如果发送的更加快速，则单位时间内，会有更多的包到达这些中间设备，这些设备还是只能每秒处理一个包的话，多出来的包就会被丢弃，这是我们不想看到的。</p><p>这个时候，我们可以想其他的办法，例如这个四个设备本来每秒处理一个包，但是我们在这些设备上加缓存，处理不过来的在队列里面排着，这样包就不会丢失，但是缺点是会增加时延，这个缓存的包，4s 肯定到达不了接收端了，如果时延达到一定程度，就会超时重传，也是我们不想看到的。</p><p>于是 TCP 的拥塞控制主要来避免两种现象，<strong>包丢失</strong>和<strong>超时重传</strong>。一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？</p><p>如果我们通过漏斗往瓶子里灌水，我们就知道，不能一桶水一下子倒进去，肯定会溅出来，要一开始慢慢的倒，然后发现总能够倒进去，就可以越倒越快。这叫作慢启动。</p><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是<strong>指数性的增长</strong>。</p><p>涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。</p><p>每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。</p><p>但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。</p><p>拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。</p><p>前面我们讲过<strong>快速重传算法</strong>。当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113026917.png" alt="image-20240523113026917"></p><p>就像前面说的一样，正是这种知进退，使得时延很重要的情况下，反而降低了速度。但是如果你仔细想一下，TCP 的拥塞控制主要来避免的两个现象都是有问题的。</p><p><strong>第一个问题</strong>是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。</p><p><strong>第二个问题</strong>是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。</p><p>为了优化这两个问题，后来有了<strong>TCP BBR 拥塞算法</strong>。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113049881.png" alt="image-20240523113049881"></p><h3 id="12-6-小结">12.6 小结</h3><p>总结一下：</p><ul><li>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；</li><li>拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。</li></ul><h2 id="第13讲-套接字Socket：Talk-is-cheap-show-me-the-code">第13讲 | 套接字Socket：Talk is cheap, show me the code</h2><p>前面讲完了 TCP 和 UDP 协议，还没有上手过，这一节咱们讲讲基于 TCP 和 UDP 协议的 Socket 编程。</p><p>在讲 TCP 和 UDP 协议的时候，我们分客户端和服务端，在写程序的时候，我们也同样这样分。</p><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。</p><p>在建立 Socket 的时候，应该设置什么参数呢？Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。</p><p>在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><h3 id="13-1-基于-TCP-协议的-Socket-程序函数调用过程">13.1 基于 TCP 协议的 Socket 程序函数调用过程</h3><p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。</p><p>当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p><p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p><p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p><p>这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作<strong>监听 Socket</strong>，一个叫作<strong>已连接 Socket</strong>。</p><p>连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><p>这个图就是基于 TCP 协议的 Socket 程序函数调用过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113217980.png" alt="image-20240523113217980"></p><p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>在内核中，Socket 是一个文件，那对应就有文件描述符。<strong>每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标</strong>。</p><p><strong>这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构</strong>。</p><p>在这个结构里面，主要的是两个队列，一个是<strong>发送队列</strong>，一个是<strong>接收队列</strong>。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？</p><p>整个数据结构我也画了一张图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113422498.png" alt="image-20240523113422498"></p><h3 id="13-2-基于-UDP-协议的-Socket-程序函数调用过程">13.2 基于 UDP 协议的 Socket 程序函数调用过程</h3><p>对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。</p><p>这个图的内容就是基于 UDP 协议的 Socket 程序函数调用过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113604974.png" alt="image-20240523113604974"></p><h3 id="13-3-服务器如何接更多的项目？">13.3 服务器如何接更多的项目？</h3><p>会了这几个基本的 Socket 函数之后，你就可以轻松地写一个网络交互的程序了。就像上面的过程一样，在建立连接后，进行一个 while 循环。客户端发了收，服务端收了发。</p><p>当然这只是万里长征的第一步，因为如果使用这种方法，基本上只能一对一沟通。如果你是一个服务器，同时只能服务一个客户，肯定是不行的。这就相当于老板成立一个公司，只有自己一个人，自己亲自上来服务客户，只能干完了一家再干下一家，这样赚不来多少钱。</p><p>那作为老板你就要想了，我最多能接多少项目呢？当然是越多越好。</p><p>我们先来算一下理论值，也就是<strong>最大连接数</strong>，系统会用一个四元组来标识一个 TCP 连接。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;本机 <span class="built_in">IP</span>, 本机端口, 对端 <span class="built_in">IP</span>, 对端端口&#125;</span><br></pre></td></tr></table></figure><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，服务端端 TCP 连接四元组中只有对端 IP, 也就是客户端的 IP 和对端的端口，也即客户端的端口是可变的，因此，最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是<strong>文件描述符限制</strong>，按照上面的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是<strong>内存</strong>，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p><p>所以，作为老板，在资源有限的情况下，要想接更多的项目，就需要降低每个项目消耗的资源数目。</p><ol><li><p>方式一：将项目外包给其他公司（多进程方式）</p><p>这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，就会有一个已连接 Socket，这时候你可以创建一个子进程，然后将基于已连接 Socket 的交互交给这个新的子进程来做。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司，招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。</p><p>这里有一个问题是，如何创建子公司，并如何将项目移交给子公司呢？</p><p>在 Linux 下，创建子进程使用 fork 函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。显然，复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>进程复制过程我画在这里。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113622262.png" alt="image-20240523113622262"></p></li><li><p>因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。</p><p>接下来，子进程就可以通过这个已连接 Socket 和客户端进行互通了，当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？还记得 fork 返回的时候，如果是整数就是父进程吗？这个整数就是子进程的 ID，父进程可以通过这个 ID 查看子进程是否完成项目，是否需要退出。</p></li><li><p>方式二：将项目转包给独立的项目组（多线程方式）</p><p>上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司，实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。</p><p>于是你应该想到了，我们可以使用<strong>线程</strong>。相比于进程来讲，这样要轻量级的多。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。</p><p>在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113638212.png" alt="image-20240523113638212"></p></li><li><p>新的线程也可以通过已连接 Socket 处理请求，从而达到并发处理的目的。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。有个C10K，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了。</p><p>其实 C10K 问题就是，你接项目接的太多了，如果每个项目都成立单独的项目组，就要招聘 10 万人，你肯定养不起，那怎么办呢？</p></li><li><p>方式三：一个项目组支撑多个项目（IO 多路复用，一个线程维护多个 Socket）</p><p>当然，一个项目组可以看多个项目了。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度，一旦某个项目有了进展，就派人去盯一下。</p><p>由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，这就是项目进度墙，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。</p></li><li><p>方式四：一个项目组支撑多个项目（IO 多路复用，从”派人盯着”到”有事通知”）</p><p>上面 select 函数还是有问题的，因为每次 Socket 所在的文件描述符集合中有 Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量。因而使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。</p><p>如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目，而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。</p><p>能完成这件事情的函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113701157.png" alt="image-20240523113701157"></p><ol><li><p>如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过 epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。</p><p>当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。</p><p>这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p></li></ol><h3 id="13-4-小结">13.4 小结</h3><p>总结一下：</p><ul><li>你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；</li><li>写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。</li></ul>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块2:物链层</title>
    <link href="https://penge666.github.io/posts/e4170501.html"/>
    <id>https://penge666.github.io/posts/e4170501.html</id>
    <published>2024-05-22T13:26:01.000Z</published>
    <updated>2024-05-22T13:35:34.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第5讲-从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？">第5讲 | 从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？</h2><p>上一节，我们见证了 IP 地址的诞生，或者说是整个操作系统的诞生。一旦机器有了 IP，就可以在网络的环境里和其他的机器展开沟通了。</p><p>故事就从我的大学宿舍开始讲起吧。作为一个八零后，我要暴露年龄了。</p><p>我们宿舍四个人，大一的时候学校不让上网，不给开通网络。但是，宿舍有一个人比较有钱，率先买了一台电脑。那买了电脑干什么呢？</p><p>首先，有单机游戏可以打，比如说《拳皇》。两个人用一个键盘，照样打得火热。后来有第二个人买了电脑，那两台电脑能不能连接起来呢？你会说，当然能啊，买个路由器不就行了。</p><p>现在一台家用路由器非常便宜，一百多块的事情。那时候路由器绝对是奢侈品。一直到大四，我们宿舍都没有买路由器。可能是因为那时候技术没有现在这么发达，导致我对网络技术的认知是逐渐深入的，而且每一层都是实实在在接触到的。</p><h3 id="5-1-第一层（物理层）">5.1 第一层（物理层）</h3><p>使用路由器，是在第三层上。我们先从第一层物理层开始说。</p><p>物理层能折腾啥？现在的同学可能想不到，我们当时去学校配电脑的地方买网线，卖网线的师傅都会问，你的网线是要电脑连电脑啊，还是电脑连网口啊？</p><p>我们要的是电脑连电脑。这种方式就是一根网线，有两个头。一头插在一台电脑的网卡上，另一头插在另一台电脑的网卡上。但是在当时，普通的网线这样是通不了的，所以水晶头要做交叉线，用的就是所谓的<strong>1－3、2－6 交叉接法</strong>。</p><p>当然电脑连电脑，除了网线要交叉，还需要配置这两台电脑的 IP 地址、子网掩码和默认网关。这三个概念上一节详细描述过了。要想两台电脑能够通信，这三项必须配置成为一个网络，可以一个是 192.168.0.1/24，另一个是 192.168.0.2/24，否则是不通的。</p><p>这里我想问你一个问题，两台电脑之间的网络包，包含 MAC 层吗？当然包含，要完整。IP 层要封装了 MAC 层才能将包放入物理层。</p><p>到此为止，两台电脑已经构成了一个最小的<strong>局域网</strong>，也即<strong>LAN</strong>。可以玩联机局域网游戏啦！</p><p>等到第三个哥们也买了一台电脑，怎么把三台电脑连在一起呢？</p><p>先别说交换机，当时交换机也贵。有一个叫作<strong>Hub</strong>的东西，也就是<strong>集线器</strong>。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p><p><strong>集线器的概念</strong></p><p>当一台计算机通过网络线向集线器发送数据时，集线器会接收到这些数据，然后将这些数据转发到其它所有连接到这个集线器的网络线上。也就是说，所有连接到集线器的设备都会收到这些数据。然后，这些设备会检查数据是否是发送给自己的，如果是，就会接收和处理这些数据；如果不是，就会忽略这些数据。</p><h3 id="5-2-第二层（数据链路层）">5.2 第二层（数据链路层）</h3><p>你可能已经发现问题了。Hub 采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都能收到，那就麻烦了。这就需要解决几个问题：</p><ul><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ul><p>这几个问题，都是第二层，数据链路层，也即 MAC 层要解决的问题。<strong>MAC</strong>的全称是<strong>Medium Access Control</strong>，即<strong>媒体访问控制</strong>。控制什么呢？其实就是控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱。这解决的是第二个问题。这个问题中的规则，学名叫<strong>多路访问</strong>。有很多算法可以解决这个问题。就像车管所管束马路上跑的车，能想的办法都想过了。</p><p>比如接下来这三种方式：</p><ul><li>方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作<strong>信道划分</strong>；</li><li>方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作<strong>轮流协议</strong>；</li><li>方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作<strong>随机接入协议</strong>。著名的以太网，用的就是这个方式。</li></ul><p><strong>补充</strong></p><p><strong>这里为了理解MAC层解决多路访问的堵车问题的。我举个常见的例子。</strong></p><p>假设我们有一个家庭网络，其中包括多个设备，如电脑、手机、智能电视等，这些设备都连接到一个路由器，希望通过路由器访问互联网。</p><p>如果所有的设备都在同一时间尝试发送数据（比如浏览网页、下载文件等），那么这些数据会在网络中产生冲突，就像是一个拥堵的交通路口，每个设备都试图在同一时间通过同一条路。这就是我们所说的&quot;堵车问题&quot;。</p><p>MAC层就像是一个交通警察，它的任务是管理这些设备发送数据的时机，以避免发生冲突。例如，它可能会让一个设备在一段时间内发送数据，然后再让另一个设备发送数据。这种方法称为时分多路访问（Time-Division Multiple Access，TDMA）。就像是交通警察轮流让每个方向的交通流通过一样。</p><p><strong>over</strong></p><p>解决了第二个问题，就是解决了媒体接入控制的问题，MAC 的问题也就解决好了。这和 MAC 地址没什么关系。</p><p>接下来要解决第一个问题：发给谁，谁接收？这里用到一个物理地址，叫作<strong>链路层地址</strong>。但是因为第二层主要解决媒体接入控制的问题，所以它常被称为<strong>MAC 地址</strong>。</p><p>解决第一个问题就牵扯到第二层的网络包<strong>格式</strong>。对于以太网，第二层的最开始，就是目标的 MAC 地址和源的 MAC 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153040214.png" alt="image-20240522153040214"></p><p>接下来是<strong>类型</strong>，大部分的类型是 IP 数据包，然后 IP 里面包含 TCP、UDP，以及 HTTP 等，这都是里层封装的事情。</p><p>有了这个目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80。</p><p>于是将请求提交给 nginx，nginx 返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。</p><p>对于以太网，第二层的最后面是<strong>CRC</strong>，也就是<strong>循环冗余检测</strong>。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误，主要解决第三个问题。</p><p>这里还有一个没有解决的问题，当源机器知道目标机器的时候，可以将目标地址放入包里面，如果不知道呢？一个广播的网络里面接入了 N 台机器，我怎么知道每个 MAC 地址是谁呢？这就是<strong>ARP 协议</strong>，也就是已知 IP 地址，求 MAC 地址的协议。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153054610.png" alt="image-20240522153054610"></p><p>在一个局域网里面，当知道了 IP 地址，不知道 MAC 怎么办呢？靠”吼”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153110268.png" alt="image-20240522153110268"></p><p>广而告之，发送一个广播包，谁是这个 IP 谁来回答。具体询问和回答的报文就像下面这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153123004.png" alt=""></p><p>为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。</p><h3 id="5-3-局域网">5.3 局域网</h3><p>好了，至此我们宿舍四个电脑就组成了一个局域网。用 Hub 连接起来，就可以玩局域网版的《魔兽争霸》了。</p><p>这种组网的方法，对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了。因为 Hub 是广播的，不管某个接口是否需要，所有的 Bit 都会被发送出去，然后让主机来判断是不是需要。这种方式路上的车少就没问题，车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。看来 Hub 这种不管三七二十一都转发的设备是不行了，需要点儿智能的。因为每个口都只连接一台电脑，这台电脑又不怎么换 IP 和 MAC 地址，只要记住这台电脑的 MAC 地址，如果目标 MAC 地址不是这台电脑的，这个口就不用转发了。</p><p>谁能知道目标 MAC 地址是否就是连接某个口的电脑的 MAC 地址呢？这就需要一个能把 MAC 头拿下来，检查一下目标 MAC 地址，然后根据策略转发的设备，按第二节课中讲过的，这个设备显然是个二层设备，我们称为<strong>交换机</strong>。</p><p>交换机怎么知道每个口的电脑的 MAC 地址呢？这需要交换机会学习。</p><p>一台 MAC1 电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2 的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的，直接发送到这个口就可以了。</p><p>当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为<strong>转发表</strong>，是有一个过期时间的。</p><p>有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题。你可以组个战队了。能上网了，就可以玩网游了。</p><h3 id="5-4-小结">5.4 小结</h3><p>总结：</p><ul><li>第一，MAC 层是用来解决多路访问的堵车问题的；</li><li>第二，ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存；【本地缓存】</li><li>第三，交换机是有 MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。【我认为就是聪明的中间的缓存，hhh】</li></ul><h2 id="第6讲-交换机与VLAN：办公室太复杂，我要回学校">第6讲 | 交换机与VLAN：办公室太复杂，我要回学校</h2><p>上一次，我们在宿舍里组建了一个本地的局域网 LAN，可以愉快地玩游戏了。这是一个非常简单的场景，因为只有一台交换机，电脑数目很少。今天，让我们切换到一个稍微复杂一点的场景，办公室。</p><h3 id="6-1-拓扑结构是怎么形成的？">6.1 拓扑结构是怎么形成的？</h3><p>我们常见到的办公室大多是一排排的桌子，每个桌子都有网口，一排十几个座位就有十几个网口，一个楼层就会有几十个甚至上百个网口。如果算上所有楼层，这个场景自然比你宿舍里的复杂多了。具体哪里复杂呢？我来给你具体讲解。</p><p>首先，这个时候，一个交换机肯定不够用，需要多台交换机，交换机之间连接起来，就形成一个稍微复杂的<strong>拓扑结构</strong>。</p><p>我们先来看<strong>两台交换机</strong>的情形。两台交换机连接着三个局域网，每个局域网上都有多台机器。如果机器 1 只知道机器 4 的 IP 地址，当它想要访问机器 4，把包发出去的时候，它必须要知道机器 4 的 MAC 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522155237730.png" alt="image-20240522155237730"></p><p>于是机器 1 发起广播，机器 2 收到这个广播，但是这不是找它的，所以没它什么事。交换机 A 一开始是不知道任何拓扑信息的，在它收到这个广播后，采取的策略是，除了广播包来的方向外，它还要转发给其他所有的网口。于是机器 3 也收到广播信息了，但是这和它也没什么关系。</p><p>当然，交换机 B 也是能够收到广播信息的，但是这时候它也是不知道任何拓扑信息的，因而也是进行广播的策略，将包转发到局域网三。这个时候，机器 4 和机器 5 都收到了广播信息。机器 4 主动响应说，这是找我的，这是我的 MAC 地址。于是一个 ARP 请求就成功完成了。</p><p>在上面的过程中，交换机 A 和交换机 B 都是能够学习到这样的信息：机器 1 是在左边这个网口的。当了解到这些拓扑信息之后，情况就好转起来。当机器 2 要访问机器 1 的时候，机器 2 并不知道机器 1 的 MAC 地址，所以机器 2 会发起一个 ARP 请求。这个广播消息会到达机器 1，也同时会到达交换机 A。这个时候交换机 A 已经知道机器 1 是不可能在右边的网口的，所以这个广播信息就不会广播到局域网二和局域网三。</p><p>当机器 3 要访问机器 1 的时候，也需要发起一个广播的 ARP 请求。这个时候交换机 A 和交换机 B 都能够收到这个广播请求。交换机 A 当然知道主机 A 是在左边这个网口的，所以会把广播消息转发到局域网一。同时，交换机 B 收到这个广播消息之后，由于它知道机器 1 是不在右边这个网口的，所以不会将消息广播到局域网三。</p><h3 id="6-2-如何解决常见的环路问题？">6.2 如何解决常见的环路问题？</h3><p>这样看起来，两台交换机工作得非常好。随着办公室越来越大，交换机数目肯定越来越多。当整个拓扑结构复杂了，这么多网线，绕过来绕过去，不可避免地会出现一些意料不到的情况。其中常见的问题就是<strong>环路问题</strong>。</p><p>例如这个图，当两个交换机将两个局域网同时连接起来的时候。你可能会觉得，这样反而有了高可用性。但是却不幸地出现了环路。出现了环路会有什么结果呢？</p><p>【简单来说，成环就会一直发】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522155638828.png" alt="image-20240522155638828"></p><p>我们来想象一下机器 1 访问机器 2 的过程。一开始，机器 1 并不知道机器 2 的 MAC 地址，所以它需要发起一个 ARP 的广播。广播到达机器 2，机器 2 会把 MAC 地址返回来，看起来没有这两个交换机什么事情。</p><p>但是问题来了，这两个交换机还是都能够收到广播包的。交换机 A 一开始是不知道机器 2 在哪个局域网的，所以它会把广播消息放到局域网二，在局域网二广播的时候，交换机 B 右边这个网口也是能够收到广播消息的。交换机 B 会将这个广播息信息发送到局域网一。局域网一的这个广播消息，又会到达交换机 A 左边的这个接口。交换机 A 这个时候还是不知道机器 2 在哪个局域网，于是将广播包又转发到局域网二。左转左转左转，好像是个圈哦。</p><p>可能有人会说，当两台交换机都能够逐渐学习到拓扑结构之后，是不是就可以了？</p><p>别想了，压根儿学不会的。机器 1 的广播包到达交换机 A 和交换机 B 的时候，本来两个交换机都学会了机器 1 是在局域网一的，但是当交换机 A 将包广播到局域网二之后，交换机 B 右边的网口收到了来自交换机 A 的广播包。根据学习机制，这彻底损坏了交换机 B 的三观，刚才机器 1 还在左边的网口呢，怎么又出现在右边的网口呢？哦，那肯定是机器 1 换位置了，于是就误会了，交换机 B 就学会了，机器 1 是从右边这个网口来的，把刚才学习的那一条清理掉。同理，交换机 A 右边的网口，也能收到交换机 B 转发过来的广播包，同样也误会了，于是也学会了，机器 1 从右边的网口来，不是从左边的网口来。</p><p>然而当广播包从左边的局域网一广播的时候，两个交换机再次刷新三观，原来机器 1 是在左边的，过一会儿，又发现不对，是在右边的，过一会，又发现不对，是在左边的。</p><p>这还是一个包转来转去，每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走。所以，必须有一个方法解决环路的问题，怎么破除环路呢？</p><h3 id="6-3-STP-协议中那些难以理解的概念">6.3 STP 协议中那些难以理解的概念</h3><p>在数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为<strong>图</strong>。将图中的环破了，就生成了<strong>树</strong>。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称<strong>Spanning Tree Protocol</strong>。</p><p>STP 协议比较复杂，一开始很难看懂，但是其实这是一场血雨腥风的武林比武或者华山论剑，最终决出五岳盟主的方式。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194202439.png" alt="image-20240522194202439"></p><p>在 STP 协议里面有很多概念，译名就非常拗口，但是我一作比喻，你很容易就明白了。</p><ul><li><strong>Root Bridge</strong>，也就是根交换机。这个比较容易理解，可以比喻为”掌门”交换机，是某棵树的老大，是掌门，最大的大哥。</li><li><strong>Designated Bridges</strong>，有的翻译为指定交换机。这个比较难理解，可以想像成一个”小弟”，对于树来说，就是一棵树的树枝。所谓”指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥。这里注意是树枝，不是叶子，因为叶子往往是主机。</li><li><strong>Bridge Protocol Data Units （BPDU）</strong> ，网桥协议数据单元。可以比喻为”相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。BPDU 只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。</li><li><strong>Priority Vector</strong>，优先级向量。可以比喻为实力 （值越小越牛）。实力是啥？就是一组 ID 数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。为什么这样设计呢？这是因为要看怎么来比实力。先看 Root Bridge ID。拿出老大的 ID 看看，发现掌门一样，那就是师兄弟；再比 Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；最后比 Bridge ID，比我自己的 ID，拿自己的本事比。</li></ul><h3 id="6-4-STP-的工作过程是怎样的？">6.4 STP 的工作过程是怎样的？</h3><p>一开始，江湖纷争，异常混乱。大家都觉得自己是掌门，谁也不服谁。于是，所有的交换机都认为自己是掌门，每个网桥都被分配了一个 ID。这个 ID 里有管理员分配的优先级，当然网络管理员知道哪些交换机贵，哪些交换机好，就会给它们分配高的优先级。这种交换机生下来武功就很高，起步就是乔峰。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194227099.png" alt="image-20240522194227099"></p><p>既然都是掌门，互相都连着网线，就互相发送 BPDU 来比功夫呗。这一比就发现，有人是岳不群，有人是封不平，赢的接着当掌门，输的就只好做小弟了。当掌门的还会继续发 BPDU，而输的人就没有机会了。它们只有在收到掌门发的 BPDU 的时候，转发一下，表示服从命令。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194243194.png" alt="image-20240522194243194"></p><p>数字表示优先级。就像这个图，5 和 6 碰见了，6 的优先级低，所以乖乖做小弟。于是一个小门派形成，5 是掌门，6 是小弟。其他诸如 1-7、2-8、3-4 这样的小门派，也诞生了。于是江湖出现了很多小的门派，小的门派，接着合并。</p><p>合并的过程会出现以下四种情形，我分别来介绍。</p><ol><li><p>情形一：掌门遇到掌门</p><p>当 5 碰到了 1，掌门碰见掌门，1 觉得自己是掌门，5 也刚刚跟别人 PK 完成为掌门。这俩掌门比较功夫，最终 1 胜出。于是输掉的掌门 5 就会率领所有的小弟归顺。结果就是 1 成为大掌门。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194309348.png" alt="image-20240522194309348"></p><ol start="2"><li>情形二：同门相遇</li></ol><p>同门相遇可以是掌门与自己的小弟相遇，这说明存在”环”了。这个小弟已经通过其他门路拜在你门下，结果你还不认识，就 PK 了一把。结果掌门发现这个小弟功夫不错，不应该级别这么低，就把它招到门下亲自带，那这个小弟就相当于升职了。</p><p>我们再来看，假如 1 和 6 相遇。6 原来就拜在 1 的门下，只不过 6 的上司是 5，5 的上司是 1。1 发现，6 距离我才只有 2，比从 5 这里过来的 5（=4+1）近多了，那 6 就直接汇报给我吧。于是，5 和 6 分别汇报给 1。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194329985.png" alt="image-20240522194329985"></p><ol><li>同门相遇还可以是小弟相遇。这个时候就要比较谁和掌门的关系近，当然近的当大哥。刚才 5 和 6 同时汇报给 1 了，后来 5 和 6 再比较功夫的时候发现，5 你直接汇报给 1 距离是 4，如果 5 汇报给 6 再汇报给 1，距离只有 2+1=3，所以 5 干脆拜 6 为上司。</li></ol><p>3.情形三：掌门与其他帮派小弟相遇</p><p>小弟拿本帮掌门和这个掌门比较，赢了，这个掌门拜入门来。输了，会拜入新掌门，并且逐渐拉拢和自己连接的兄弟，一起弃暗投明。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194430951.png" alt="image-20240522194430951"></p><ol><li>例如，2 和 7 相遇，虽然 7 是小弟，2 是掌门。就个人武功而言，2 比 7 强，但是 7 的掌门是 1，比 2 牛，所以没办法，2 要拜入 7 的门派，并且连同自己的小弟都一起拜入。</li></ol><p>4.情形四：不同门小弟相遇</p><p>各自拿掌门比较，输了的拜入赢的门派，并且逐渐将与自己连接的兄弟弃暗投明</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194459243.png" alt="image-20240522194459243"></p><ol><li>例如，5 和 4 相遇。虽然 4 的武功好于 5，但是 5 的掌门是 1，比 4 牛，于是 4 拜入 5 的门派。后来当 3 和 4 相遇的时候，3 发现 4 已经叛变了，4 说我现在老大是 1，比你牛，要不你也来吧，于是 3 也拜入 1。</li></ol><p>最终，生成一棵树，武林一统，天下太平。但是天下大势，分久必合，合久必分，天下统一久了，也会有相应的问题。</p><h3 id="6-5-如何解决广播问题和安全问题？">6.5 如何解决广播问题和安全问题？</h3><p>毕竟机器多了，交换机也多了，就算交换机比 Hub 智能一些，但是还是难免有广播的问题，一大波机器，相关的部门、不相关的部门，广播一大堆，性能就下来了。就像一家公司，创业的时候，一二十个人，坐在一个会议室，有事情大家讨论一下，非常方便。但是如果变成了 50 个人，全在一个会议室里面吵吵，就会乱的不得了。</p><p>你们公司有不同的部门，有的部门需要保密的，比如人事部门，肯定要讨论升职加薪的事儿。由于在同一个广播域里面，很多包都会在一个局域网里面飘啊飘，碰到了一个会抓包的程序员，就能抓到这些包，如果没有加密，就能看到这些敏感信息了。还是上面的例子，50 个人在一个会议室里面七嘴八舌的讨论，其中有两个 HR，那他们讨论的问题，肯定被其他人偷偷听走了。</p><p>那咋办，分部门，分会议室呗。那我们就来看看怎么分。</p><p>有两种分的方法，一个是<strong>物理隔离</strong>。每个部门设一个单独的会议室，对应到网络方面，就是每个部门有单独的交换机，配置单独的子网，这样部门之间的沟通就需要路由器了。路由器咱们还没讲到，以后再说。这样的问题在于，有的部门人多，有的部门人少。人少的部门慢慢人会变多，人多的部门也可能人越变越少。如果每个部门有单独的交换机，口多了浪费，少了又不够用。</p><p>另外一种方式是<strong>虚拟隔离</strong>，就是用我们常说的VLAN，或者叫虚拟局域网。使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194517360.png" alt="image-20240522194517360"></p><p>我们只需要在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共 12 位。为什么是 12 位呢？因为 12 位可以划分 4096 个 VLAN。这样是不是还不够啊。现在的情况证明，目前云计算厂商里面绝对不止 4096 个用户。当然每个用户需要一个 VLAN 了啊，怎么办呢，这个我们在后面的章节再说。</p><p>如果我们买的交换机是支持 VLAN 的，当这个交换机把二层的头取下来的时候，就能够识别这个 VLAN ID。这样只有相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的。这样广播问题和安全问题就都能够解决了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194531328.png" alt="image-20240522194531328"></p><p>我们可以设置交换机每个口所属的 VLAN。如果某个口坐的是程序员，他们属于 VLAN 10；如果某个口坐的是人事，他们属于 VLAN 20；如果某个口坐的是财务，他们属于 VLAN 30。这样，财务发的包，交换机只会转发到 VLAN 30 的口上。程序员啊，你就监听 VLAN 10 吧，里面除了代码，啥都没有。</p><p>而且对于交换机来讲，每个 VLAN 的口都是可以重新设置的。一个财务走了，把他所在的作为的口从 VLAN 30 移除掉，来了一个程序员，坐在财务的位置上，就把这个口设置为 VLAN 10，十分灵活。</p><p>有人会问交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么 VLAN 呢？对于支持 VLAN 的交换机，有一种口叫作Trunk 口。它可以转发属于任何 VLAN 的口。交换机之间可以通过这种口相互连接。</p><p>好了，解决这么多交换机连接在一起的问题，办公室的问题似乎搞定了。然而这只是一般复杂的场景，因为你能接触到的网络，到目前为止，不管是你的台式机，还是笔记本所连接的网络，对于带宽、高可用等都要求不高。就算出了问题，一会儿上不了网，也不会有什么大事。</p><p>我们在宿舍、学校或者办公室，经常会访问一些网站，这些网站似乎永远不会”挂掉”。那是因为这些网站都生活在一个叫做数据中心的地方，那里的网络世界更加复杂。在后面的章节，我会为你详细讲解。</p><h3 id="6-6-小结">6.6 小结</h3><p>总结：</p><ul><li>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</li><li>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</li></ul><h2 id="第7讲-ICMP与ping：投石问路的侦察兵">第7讲 | ICMP与ping：投石问路的侦察兵</h2><h3 id="7-1-ICMP-协议的格式">7.1 ICMP 协议的格式</h3><p>ping 是基于 ICMP 协议工作的。<strong>ICMP</strong>全称<strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>。这里面的关键词是”控制”，那具体是怎么控制的呢？</p><p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。当遇到问题的时候，总不能”死个不明不白”，要传出消息来，报告情况，这样才可以调整传输策略。这就相当于我们经常看到的电视剧里，古代行军的时候，为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局。</p><p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194735874.png" alt="image-20240522194735874"></p><p>ICMP 报文有很多的类型，不同的类型有不同的代码。<strong>最常用的类型是主动请求为 8，主动请求的应答为 0</strong>。</p><h3 id="7-2-查询报文类型">7.2 查询报文类型</h3><p>我们经常在电视剧里听到这样的话：主帅说，来人哪！前方战事如何，快去派人打探，一有情况，立即通报！</p><p>这种是主帅发起的，主动查看敌情，对应 ICMP 的<strong>查询报文类型</strong>。例如，常用的<strong>ping 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议</strong>。所以，ping 发的包也是符合 ICMP 协议格式的，只不过它在后面增加了自己的格式。</p><p>对 ping 的主动请求，进行网络抓包，称为<strong>ICMP ECHO REQUEST</strong>。同理主动请求的回复，称为<strong>ICMP ECHO REPLY</strong>。比起原生的 ICMP，这里面多了两个字段，一个是<strong>标识符</strong>。这个很好理解，你派出去两队侦查兵，一队是侦查战况的，一队是去查找水源的，要有个标识才能区分。另一个是<strong>序号</strong>，你派出去的侦查兵，都要编个号。如果派出去 10 个，回来 10 个，就说明前方战况不错；如果派出去 10 个，回来 2 个，说明情况可能不妙。</p><p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><h3 id="7-3-差错报文类型">7.3 差错报文类型</h3><p>当然也有另外一种方式，就是差错报文。</p><p>主帅骑马走着走着，突然来了一匹快马，上面的小兵气喘吁吁的：报告主公，不好啦！张将军遭遇埋伏，全军覆没啦！这种是异常情况发起的，来报告发生了不好的事情，对应 ICMP 的<strong>差错报文类型</strong>。</p><p>我举几个 ICMP 差错报文的例子：<strong>终点不可达为 3，源抑制为 4，超时为 11，重定向为 5</strong>。这些都是什么意思呢？我给你具体解释一下。</p><p><strong>第一种是终点不可达</strong>。小兵：报告主公，您让把粮草送到张将军那里，结果没有送到。</p><p>如果你是主公，你肯定会问，为啥送不到？具体的原因在代码中表示就是，网络不可达代码为 0，主机不可达代码为 1，协议不可达代码为 2，端口不可达代码为 3，需要进行分片但设置了不分片位代码为 4。</p><p>具体的场景就像这样：</p><ul><li>网络不可达：主公，找不到地方呀？</li><li>主机不可达：主公，找到地方没这个人呀？</li><li>协议不可达：主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说 12345！</li><li>端口不可达：主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。</li><li>需要进行分片但设置了不分片位：主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了。</li></ul><p><strong>第二种是源站抑制</strong>，也就是让源站放慢发送速度。小兵：报告主公，您粮草送的太多了吃不完。</p><p><strong>第三种是时间超时</strong>，也就是超过网络包的生存时间还是没到。小兵：报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。</p><p><strong>第四种是路由重定向</strong>，也就是让下次发给另一个路由器。小兵：报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。</p><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><p>而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。</p><p>侦察兵：报告主公，张将军已经战死沙场，这是张将军的印信和佩剑。<br>主公：神马？张将军是怎么死的（可以查看 ICMP 的前 8 字节）？没错，这是张将军的剑，是他的剑（IP 数据包的头及正文前 8 字节）。</p><h3 id="7-4-ping：查询报文类型的使用">7.4 ping：查询报文类型的使用</h3><p>接下来，我们重点来看 ping 的发送和接收过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522200017978.png" alt="image-20240522200017978"></p><p>假定主机 A 的 IP 地址是 192.168.1.1，主机 B 的 IP 地址是 192.168.1.2，它们都在同一个子网。那当你在主机 A 上运行”ping 192.168.1.2”后，会发生什么呢?</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是<strong>类型字段</strong>，对于请求数据包而言该字段为 8；另外一个是<strong>顺序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。</p><p>接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。这个过程后面几节会详细描述，这里暂时不多说。</p><p>如果在自己的可控范围之内，当遇到网络不通的问题的时候，除了直接 ping 目标的 IP 地址之外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过 tcpdump -i eth0 icmp，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。</p><p>经常会遇到一个问题，如果不在我们的控制范围内，很多中间设备都是禁止 ping 的，但是 ping 不通不代表网络不通。这个时候就要使用 telnet，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。</p><p>说了这么多，你应该可以看出 ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST 和 ECHO REPLY 类型的</p><h3 id="7-5-Traceroute：差错报文类型的使用">7.5 Traceroute：差错报文类型的使用</h3><p>那其他的类型呢？是不是只有真正遇到错误的时候，才能收到呢？那也不是，有一个程序 Traceroute，是个”大骗子”。它会使用 ICMP 的规则，故意制造一些能够产生错误的场景。</p><p>所以，<strong>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</strong>。**Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。**将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它”牺牲”了。</p><p>如果中间的路由器不止一个，当然碰到第一个就”牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。那大军前行就带一顿饭，试一试走多远会被饿死，然后找个哨探回来报告，那我就知道大军只带一顿饭能走多远了。</p><p>接下来，将 TTL 设置为 2。第一关过了，第二关就”牺牲”了，那我就知道第二关有多远。如此反复，直到到达目的主机。这样，Traceroute 就拿到了所有的路由器 IP。当然，有的路由器压根不会回这个 ICMP。这也是 Traceroute 一个公网的地址，看不到中间路由的原因。</p><p><strong>怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份”端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。</strong></p><p>这就相当于故意派人去西天如来那里去请一本《道德经》，结果人家信佛不信道，消息就会被打出来。被打的消息传回来，你就知道西天是能够到达的。为什么不去取《心经》呢？因为 UDP 是无连接的。也就是说这人一派出去，你就得不到任何音信。你无法区别到底是半路走丢了，还是真的信佛遁入空门了，只有让人家打出来，你才会得到消息。</p><p><strong>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU</strong>。要做的工作首先是发送分组，并设置”不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，类型为”需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到 ICMP”不能分片”差错时就减小分组的长度，直到到达目标主机。</p><h3 id="7-6-小结">7.6 小结</h3><p>总结一下：</p><ul><li>ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；</li><li>ping 使用查询报文，Traceroute 使用差错报文。</li></ul><h2 id="第8讲-世界这么大，我想出网关：欧洲十国游与玄奘西行">第8讲 | 世界这么大，我想出网关：欧洲十国游与玄奘西行</h2><h3 id="8-1-怎么在宿舍上网？">8.1 怎么在宿舍上网？</h3><p>还记得咱们在宿舍的时候买了台交换机，几台机器组了一个局域网打游戏吗？可惜啊，只能打局域网的游戏，不能上网啊！盼啊盼啊，终于盼到大二，允许宿舍开通网络了。学校给每个宿舍的网口分配了一个 IP 地址。这个 IP 是校园网的 IP，完全由网管部门控制。宿舍网的 IP 地址多为 192.168.1.x。校园网的 IP 地址，假设是 10.10.x.x。</p><p>补充：为什么一个网卡只能连一个IP？</p><p>A：想想ifconfig，里面的网卡信息，如果配置多个IP，那可能就不知道socket和谁绑定了！</p><p>这个时候，你要在宿舍上网，有两个办法：</p><p>第一个办法，让你们宿舍长再买一个网卡。这个时候，你们宿舍长的电脑里就有两张网卡。一张网卡的线插到你们宿舍的交换机上，另一张网卡的线插到校园网的网口。而且，这张新的网卡的 IP 地址要按照学校网管部门分配的配置，不然上不了网。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着宿舍长的电脑</strong>。</p><p>第二个办法，你们共同出钱买个家庭路由器（反正当时我们买不起）。家庭路由器会有内网网口和外网网口。把外网网口的线插到校园网的网口上，将这个外网网口配置成和网管部的一样。内网网口连上你们宿舍的所有的电脑。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着路由器</strong>。</p><p>这两种方法其实是一样的。只不过第一种方式，让你的宿舍长的电脑，变成一个有多个口的路由器而已。而你买的家庭路由器，里面也跑着程序，和你宿舍长电脑里的功能一样，只不过是一个嵌入式的系统。</p><p>当你的宿舍长能够上网之后，接下来，就是其他人的电脑怎么上网的问题。这就需要配置你们的<strong>网卡</strong>。当然 DHCP 是可以默认配置的。在进行网卡配置的时候，除了 IP 地址，还需要配置一个<strong>Gateway</strong>的东西，这个就是<strong>网关</strong>。</p><h3 id="8-2-你了解-MAC-头和-IP-头的细节吗？">8.2 你了解 MAC 头和 IP 头的细节吗？</h3><p>一旦配置了 IP 地址和网关，往往就能够指定目标地址进行访问了。由于在跨网关访问的时候，牵扯到 MAC 地址和 IP 地址的变化，这里有必要详细描述一下 MAC 头和 IP 头的细节。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522203523058.png" alt="image-20240522203523058"></p><p>在 MAC 头里面，先是目标 MAC 地址，然后是源 MAC 地址，然后有一个协议类型，用来说明里面是 IP 协议。IP 头里面的版本号，目前主流的还是 IPv4，服务类型 TOS 在第三节讲 ip addr 命令的时候讲过，TTL 在第 7 节讲 ICMP 协议的时候讲过。另外，还有 8 位标识协议。这里到了下一层的协议，也就是，是 TCP 还是 UDP。最重要的就是源 IP 和目标 IP。先是源 IP 地址，然后是目标 IP 地址。</p><p>在任何一台机器上，当要访问另一个 IP 地址的时候，都会先判断，这个目标 IP 地址，和当前机器的 IP 地址，是否在同一个网段。怎么判断同一个网段呢？需要 CIDR 和子网掩码，这个在第三节的时候也讲过了。</p><p><strong>如果是同一个网段</strong>，例如，你访问你旁边的兄弟的电脑，那就没网关什么事情，直接将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。</p><p><strong>如果不是同一网段</strong>，例如，你要访问你们校园网里面的 BBS，该怎么办？这就需要发往默认网关 Gateway。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个。例如 192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24 或者 192.168.1.2/24。</p><p>如何发往默认网关呢？网关不是和源 IP 地址是一个网段的么？这个过程就和发往同一个网段的其他机器是一样的：将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关的 MAC 放入 MAC 头中，发送出去。网关所在的端口，例如 192.168.1.1/24 将网络包收进来，然后接下来怎么做，就完全看网关的了。</p><p><strong>网关往往是一个路由器，是一个三层转发的设备</strong>。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。</p><p>在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。</p><p>很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：<strong>路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关</strong>。</p><p>任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。</p><h3 id="8-3-静态路由是什么？">8.3 静态路由是什么？</h3><p>这个时候，问题来了，该选择哪一只手？IP 头和 MAC 头加什么内容，哪些变、哪些不变呢？这个问题比较复杂，大致可以分为两类，一个是<strong>静态路由</strong>，一个是<strong>动态路由</strong>。动态路由下一节我们详细地讲。这一节我们先说静态路由。</p><p><strong>静态路由，其实就是在路由器上，配置一条一条规则</strong>。这些规则包括：想访问 BBS 站（它肯定有个网段），从 2 号口出去，下一跳是 IP2；想访问教学视频站（它也有个自己的网段），从 3 号口出去，下一跳是 IP3，然后保存在路由器里。</p><p>每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳 IPX。</p><h3 id="8-4-IP-头和-MAC-头哪些变、哪些不变？">8.4 IP 头和 MAC 头哪些变、哪些不变？</h3><p>对于 IP 头和 MAC 头哪些变、哪些不变的问题，可以分两种类型。我把它们称为 <strong>“欧洲十国游”型</strong> 和 <strong>“玄奘西行”型</strong> 。</p><p>之前我说过，MAC 地址是一个局域网内才有效的地址。因而，MAC 地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于 IP 地址是否改变。不改变 IP 地址的网关，我们称为<strong>转发网关</strong>；改变 IP 地址的网关，我们称为<strong>NAT 网关</strong>。</p><ol><li><p>“欧洲十国游”型</p><p>结合这个图，我们先来看”欧洲十国游”型。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522203650916.png" alt="image-20240522203650916"></p><p>服务器 A 要访问服务器 B。首先，服务器 A 会思考，192.168.4.101 和我不是一个网段的，因而需要先发给网关。那网关是谁呢？已经静态配置好了，网关是 192.168.1.1。网关的 MAC 地址是多少呢？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：服务器 A 的 MAC</p></li><li><p>目标 MAC：192.168.1.1 这个网口的 MAC</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p><p>包到达 192.168.1.1 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 A 中配置了静态路由之后，要想访问 192.168.4.0/24，要从 192.168.56.1 这个口出去，下一跳为 192.168.56.2。</p><p>于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2，那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址，然后发送包。包的内容是这样的：</p></li><li><p>源 MAC：192.168.56.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.56.2 的 MAC 地址</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p><p>包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 B 中配置了静态路由，要想访问 192.168.4.0/24，要从 192.168.4.1 这个口出去，没有下一跳了。因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.4.1 这个口发出去，发给 192.168.4.101。那 192.168.4.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取 192.168.4.101 的 MAC 地址，然后发送包。包的内容是这样的：</p></li><li><p>源 MAC：192.168.4.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.4.101 的 MAC 地址</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p><p>包到达服务器 B，MAC 地址匹配，将包收进来。</p><p>通过这个过程可以看出，每到一个新的局域网，MAC 都是要变的，但是 IP 地址都不变。在 IP 头里面，不会保存任何网关的 IP 地址。<strong>所谓的下一跳是，某个 IP 要将这个 IP 地址转换为 MAC 放入 MAC 头</strong>。</p><p>之所以将这种模式比喻称为欧洲十国游，是因为在整个过程中，IP 头里面的地址都是不变的。IP 地址在三个局域网都可见，在三个局域网之间的网段都不会冲突。在三个网段之间传输包，IP 头不改变。这就像在欧洲各国之间旅游，一个签证就能搞定。</p></li></ul><ol start="2"><li>“玄奘西行”型</li></ol></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522203721417.png" alt="image-20240522203721417"></p><ol><li><p>这里遇见的第一个问题是，局域网之间没有商量过，各定各的网段，因而 IP 段冲突了。最左面大唐的地址是 192.168.1.101，最右面印度的地址也是 192.168.1.101，如果单从 IP 地址上看，简直是自己访问自己，其实是大唐的 192.168.1.101 要访问印度的 192.168.1.101。</p><p>怎么解决这个问题呢？既然局域网之间没有商量过，你们各管各的，那到国际上，也即中间的局域网里面，就需要使用另外的地址。就像出国，不能用咱们自己的身份证，而要改用护照一样，玄奘西游也要拿着专门取经的通关文牒，而不能用自己国家的身份证。</p><p>首先，目标服务器 B 在国际上要有一个国际的身份，我们给它一个 192.168.56.2。在网关 B 上，我们记下来，国际身份 192.168.56.2 对应国内身份 192.168.1.101。凡是要访问 192.168.56.2，都转成 192.168.1.101。</p><p>于是，源服务器 A 要访问目标服务器 B，要指定的目标地址为 192.168.56.2。这是它的国际身份。服务器 A 想，192.168.56.2 和我不是一个网段的，因而需要发给网关，网关是谁？已经静态配置好了，网关是 192.168.1.1，网关的 MAC 地址是多少？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：服务器 A 的 MAC</p></li><li><p>目标 MAC：192.168.1.1 这个网口的 MAC</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.56.2</p><p>包到达 192.168.1.1 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 A 中配置了静态路由：要想访问 192.168.56.2/24，要从 192.168.56.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2。那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址。</p><p>当网络包发送到中间的局域网的时候，服务器 A 也需要有个国际身份，因而在国际上，源 IP 地址也不能用 192.168.1.101，需要改成 192.168.56.1。发送包的内容是这样的：</p></li><li><p>源 MAC：192.168.56.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.56.2 的 MAC 地址</p></li><li><p>源 IP：192.168.56.1</p></li><li><p>目标 IP：192.168.56.2</p><p>包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>路由器 B 是一个 NAT 网关，它上面配置了，要访问国际身份 192.168.56.2 对应国内身份 192.168.1.101，于是改为访问 192.168.1.101。</p><p>在路由器 B 中配置了静态路由：要想访问 192.168.1.0/24，要从 192.168.1.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.1.1 这个口发出去，发给 192.168.1.101。</p><p>那 192.168.1.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取 192.168.1.101 的 MAC 地址，然后发送包。内容是这样的：</p></li><li><p>源 MAC：192.168.1.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.1.101 的 MAC 地址</p></li><li><p>源 IP：192.168.56.1</p></li><li><p>目标 IP：192.168.1.101</p><p>包到达服务器 B，MAC 地址匹配，将包收进来。</p><p>从服务器 B 接收的包可以看出，源 IP 为服务器 A 的国际身份，因而发送返回包的时候，也发给这个国际身份，由路由器 A 做 NAT，转换为国内身份。</p><p>从这个过程可以看出，IP 地址也会变。这个过程用英文说就是<strong>Network Address Translation</strong>，简称<strong>NAT</strong>。</p><p><strong>其实这第二种方式我们经常见</strong>，现在大家每家都有家用路由器，家里的网段都是 192.168.1.x，所以你肯定访问不了你邻居家的这个私网的 IP 地址的。所以，当我们家里的包发出去的时候，都被家用路由器 NAT 成为了运营商的地址了。</p><p>很多办公室访问外网的时候，也是被 NAT 过的，因为不可能办公室里面的 IP 也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口 IP 地址。你可以通过 <a href="https://www.whatismyip.com/">https://www.whatismyip.com/</a> 查看自己的出口 IP 地址。</p></li></ul></li></ol><h3 id="8-5-小结">8.5 小结</h3><p>总结一下：</p><ul><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则；</li><li>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</li></ul><h2 id="第9讲-路由协议：西出网关无故人，敢问路在何方">第9讲 | 路由协议：西出网关无故人，敢问路在何方</h2><p>俗话说得好，在家千日好，出门一日难。网络包一旦出了网关，就像玄奘西行一样踏上了江湖漂泊的路。</p><p>上一节我们描述的是一个相对简单的情形。出了网关之后，只有一条路可以走。但是，网络世界复杂得多，一旦出了网关，会面临着很多路由器，有很多条道路可以选。如何选择一个更快速的道路求取真经呢？这里面还有很多门道可以讲。</p><h3 id="9-1-如何配置路由？">9.1 如何配置路由？</h3><p>通过上一节的内容，你应该已经知道，路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为<strong>路由表</strong>。</p><p>一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。</p><ul><li>目的网络：这个包想去哪儿？</li><li>出口设备：将包从哪个口扔出去？</li><li>下一跳网关：下一个路由器的地址。</li></ul><p>通过 route 命令和 ip route 命令都可以进行查询或者配置。</p><p>例如，我们设置 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p><p>上一节的例子中，网关上的路由策略就是按照这三项配置信息进行配置的。这种配置方式的一个核心思想是：<strong>根据目的 IP 地址来配置路由</strong>。</p><h3 id="9-2-如何配置策略路由？">9.2 如何配置策略路由？</h3><p>当然，在真实的复杂的网络环境中，除了可以根据目的 ip 地址配置路由外，还可以根据多个参数来配置路由，这就称为<strong>策略路由</strong>。</p><p>可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。</p><p>例如，我们设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 10</span><br><span class="line">ip rule add from 192.168.2.0/24 table 20</span><br></pre></td></tr></table></figure><p>表示从 192.168.1.10/24 这个网段来的，使用 table 10 中的路由表，而从 192.168.2.0/24 网段来的，使用 table20 的路由表。</p><p>在一条路由规则中，也可以走多条路径。例如，在下面的路由规则中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2</span><br></pre></td></tr></table></figure><p>下一跳有两个地方，分别是 100.100.100.1 和 200.200.200.1，权重分别为 1 比 2。</p><p>在什么情况下会用到如此复杂的配置呢？我来举一个现实中的例子。</p><p>我是房东，家里从运营商那儿拉了两根网线。这两根网线分别属于两个运行商。一个带宽大一些，一个带宽小一些。这个时候，我就不能买普通的家用路由器了，得买个高级点的，可以接两个外网的。</p><p>家里的网络呢，就是普通的家用网段 192.168.1.x/24。家里有两个租户，分别把线连到路由器上。IP 地址为 192.168.1.101/24 和 192.168.1.102/24，网关都是 192.168.1.1/24，网关在路由器上。</p><p>就像上一节说的一样，家里的网段是私有网段，出去的包需要 NAT 成公网的 IP 地址，因而路由器是一个 NAT 路由器。</p><p>两个运营商都要为这个网关配置一个公网的 IP 地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212124077.png" alt="image-20240522212124077"></p><p>运行商里面也有一个 IP 地址，在运营商网络里面的网关。不同的运营商方法不一样，有的是 /32 的，也即一个一对一连接。</p><p>例如，运营商 1 给路由器分配的地址是 183.134.189.34/32，而运营商网络里面的网关是 183.134.188.1/32。有的是 /30 的，也就是分了一个特别小的网段。运营商 2 给路由器分配的地址是 60.190.27.190/30，运营商网络里面的网关是 60.190.27.189/30。</p><p>根据这个网络拓扑图，可以将路由配置成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip route list table main</span><br><span class="line">60.190.27.189/30 dev eth3  proto kernel  scope <span class="built_in">link</span>  src 60.190.27.190</span><br><span class="line">183.134.188.1 dev eth2  proto kernel  scope <span class="built_in">link</span>  src 183.134.189.34</span><br><span class="line">192.168.1.0/24 dev eth1  proto kernel  scope <span class="built_in">link</span>  src 192.168.1.1</span><br><span class="line">127.0.0.0/8 dev lo  scope <span class="built_in">link</span></span><br><span class="line">default via 183.134.188.1 dev eth2</span><br></pre></td></tr></table></figure><p>当路由这样配置的时候，就告诉这个路由器如下的规则：</p><ul><li>如果去运营商二，就走 eth3；</li><li>如果去运营商一呢，就走 eth2；</li><li>如果访问内网，就走 eth1；</li><li>如果所有的规则都匹配不上，默认走运营商一，也即走快的网络。</li></ul><p>但是问题来了，租户 A 不想多付钱，他说我就上上网页，从不看电影，凭什么收我同样贵的网费啊？没关系，咱有技术可以解决。</p><p>下面我添加一个 Table，名字叫<strong>chao</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 200 chao &gt;&gt; /etc/iproute2/rt_tables</span><br></pre></td></tr></table></figure><p>添加一条规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip rule add from 192.168.1.101 table chao</span><br><span class="line">$ ip rule <span class="built_in">ls</span></span><br><span class="line">0:    from all lookup <span class="built_in">local</span></span><br><span class="line">32765:    from 192.168.1.101 lookup chao</span><br><span class="line">32766:    from all lookup main</span><br><span class="line">32767:    from all lookup default</span><br></pre></td></tr></table></figure><p>设定规则为：从 192.168.1.101 来的包都查看个 chao 这个新的路由表。</p><p>在 chao 路由表中添加规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add default via 60.190.27.189 dev eth3 table chao</span><br><span class="line">ip route flush cache</span><br></pre></td></tr></table></figure><p>默认的路由走慢的，谁让你不付钱。</p><p>上面说的都是静态的路由，一般来说网络环境简单的时候，在自己的可控范围之内，自己捣鼓还是可以的。但是有时候网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。</p><h3 id="9-3-动态路由算法">9.3 动态路由算法</h3><p>使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。那路由算法是什么样的呢？</p><p>我们可以想象唐僧西天取经，需要解决两大问题，一个是在每个国家如何找到正确的路，去换通关文牒、吃饭、休息；一个是在国家之间，野外行走的时候，如何找到正确的路、水源的问题。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212214388.png" alt="image-20240522212214388"></p><p>无论是一个国家内部，还是国家之间，我们都可以将复杂的路径，抽象为一种叫作图的数据结构。至于唐僧西行取经，肯定想走得路越少越好，道路越短越好，因而这就转化成为<strong>如何在途中找到最短路径</strong>的问题。</p><p>咱们在大学里面学习计算机网络与数据结构的时候，知道求最短路径常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。在计算机网络中基本也是用这两种方法计算的。</p><ol><li><p><strong>距离矢量路由算法</strong></p><p>第一大类的算法称为<strong>距离矢量路由（distance vector routing）</strong>。它是基于 Bellman-Ford 算法的。</p><p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p><p>由此可以看出，每个路由器都是知道全局信息的。那这个信息如何更新呢？每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。</p><p>每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。</p><p>这个算法比较简单，但是还是有问题。</p><p><strong>第一个问题就是好消息传得快，坏消息传得慢</strong>。如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去。要不了多久，整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212237934.png" alt="image-20240522212237934"></p></li><li><p>原来的网络包括两个节点，B 和 C。A 加入了网络，它的邻居 B 很快就发现 A 启动起来了。于是它将自己和 A 的距离设为 1，同样 C 也发现 A 起来了，将自己和 A 的距离设置为 2。但是如果 A 挂掉，情况就不妙了。B 本来和 A 是邻居，发现连不上 A 了，但是 C 还是能够连上，只不过距离远了点，是 2，于是将自己的距离设置为 3。殊不知 C 的距离 2 其实是基于原来自己的距离为 1 计算出来的。C 发现自己也连不上 A，并且发现 B 设置为 3，于是自己改成距离 4。依次类推，数越来越大，直到超过一个阈值，我们才能判定 A 真的挂了。</p><p>这个道理有点像有人走丢了。当你突然发现找不到这个人了。于是你去学校问，是不是在他姨家呀？找到他姨家，他姨说，是不是在他舅舅家呀？他舅舅说，是不是在他姥姥家呀？他姥姥说，是不是在学校呀？总归要问一圈，或者是超过一定的时间，大家才会认为这个人的确走丢了。如果这个人其实只是去见了一个谁都不认识的网友去了，当这个人回来的时候，只要他随便见到其中的一个亲戚，这个亲戚就会拉着他到他的家长那里，说你赶紧回家，你妈都找你一天了。</p><p><strong>这种算法的第二个问题是，每次发送的时候，要发送整个全局路由表</strong>。网络大了，谁也受不了，所以最早的路由协议 RIP 就是这个算法。它适用于小型网络（小于 15 跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了。</p><p>所以上面的两个问题，限制了距离矢量路由的网络规模。</p></li><li><p><strong>链路状态路由算法</strong></p><p>第二大类算法是<strong>链路状态路由（link state routing）</strong>，基于 Dijkstra 算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。</p><p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p></li></ol><h3 id="9-4-动态路由协议">9.4 动态路由协议</h3><ol><li><p><strong>基于链路状态路由算法的 OSPF</strong></p><p><strong>OSPF（Open Shortest Path First，开放式最短路径优先）<strong>就是这样一个基于链路状态路由协议，广泛应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为</strong>内部网关协议（Interior Gateway Protocol，简称IGP）</strong>。</p><p>内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候 OSPF 可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为<strong>等价路由</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212256171.png" alt="image-20240522212256171"></p><ol><li><p>这一点非常重要。有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。这个在后面我们讲数据中心的网络的时候，一般应用的接入层会有负载均衡 LVS。它可以和 OSPF 一起，实现高吞吐量的接入层设计。</p><p>有了内网的路由协议，在一个国家内，唐僧可以想怎么走怎么走了，两条路选一条也行。</p></li><li><p><strong>基于距离矢量路由算法的 BGP</strong></p><p>但是外网的路由协议，也即国家之间的，又有所不同。我们称为<strong>外网路由协议（Border Gateway Protocol，简称BGP）</strong>。</p><p>在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。例如，唐僧去西天取经，有的路近。但是路过的国家看不惯僧人，见了僧人就抓。例如灭法国，连光头都要抓。这样的情况即便路近，也最好绕远点走。</p><p>对于网络包同样，每个数据中心都设置自己的 Policy。例如，哪些外部的 IP 可以让内部知晓，哪些内部的 IP 可以让外部知晓，哪些可以通过，哪些不能通过。这就好比，虽然从我家里到目的地最近，但是不能谁都能从我家走啊！</p><p>在网络世界，这一个个国家成为<strong>自治系统AS（Autonomous System）</strong>。自治系统分几种类型。</p><ul><li><p>Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。</p></li><li><p>Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。</p></li><li><p>Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。</p><p>每个自治系统都有边界路由器，通过它和外面的世界建立联系。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212314796.png" alt="image-20240522212314796"></p></li></ol></li></ol><p><strong>BGP 又分为两类，eBGP 和 iBGP</strong>。自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。</p><p>BGP 协议使用的算法是<strong>路径矢量路由协议（path-vector protocol）</strong>。它是距离矢量路由协议的升级版。</p><p>前面说了距离矢量路由协议的缺点。其中一个是收敛慢。在 BGP 里面，除了下一跳 hop 之外，还包括了自治系统 AS 的路径，从而可以避免坏消息传的慢的问题，也即上面所描述的，B 知道 C 原来能够到达 A，是因为通过自己，一旦自己都到达不了 A 了，就不用假设 C 还能到达 A 了。</p><p>另外，在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。就像大家都能记住出去玩，从中国出发先到韩国然后到日本，只要不计算细到具体哪一站，就算是发送全局信息，也是没有问题的。</p><ul><li><a href="https://www.nowcoder.com/discuss/574150608358313984?sourceSSR=search">什么是静态路由、OSPF、BGP</a></li></ul><h3 id="9-5-小结">9.5 小结</h3><p>总结：</p><ul><li>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</li><li>动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。</li></ul>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块1:通信协议综述</title>
    <link href="https://penge666.github.io/posts/db38782f.html"/>
    <id>https://penge666.github.io/posts/db38782f.html</id>
    <published>2024-05-22T06:39:38.000Z</published>
    <updated>2024-05-22T06:58:15.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1讲-为什么要学习网络协议？">第1讲 | 为什么要学习网络协议？</h2><h3 id="1-1-协议三要素">1.1 协议三要素</h3><p>机器不能直接读懂代码，需要进行翻译，翻译的工作教给编译器，也就是程序员常说的 compile。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144110722.png" alt="image-20240522144110722"></p><p>可以看得出，计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。</p><ul><li>语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。</li><li>语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。</li><li>顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。</li></ul><p>当你想要买一个商品，常规的做法就是打开浏览器，输入购物网站的地址。浏览器就会给你显示一个缤纷多彩的页面。它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自 HTTP 协议的”东西”。我拿网易考拉来举例，格式就像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 27 Mar 2018 16:50:26 GMT</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Language: zh-CN</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://pages.kaola.com/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span> 网易考拉 3 周年主会场 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-我们常用的网络协议有哪些？">1.2 我们常用的网络协议有哪些？</h3><p>接下来揭秘我要说的大事情，”双十一”。这和我们要讲的网络协议有什么关系呢？</p><p>在经济学领域，有个伦纳德·里德（Leonard E. Read）创作的《铅笔的故事》。这个故事通过一个铅笔的诞生过程，来讲述复杂的经济学理论。这里，我也用一个下单的过程，看看互联网世界的运行过程中，都使用了哪些网络协议。</p><p>你先在浏览器里面输入 <a href="https://www.kaola.com/">https://www.kaola.com</a> ，这是一个<strong>URL</strong>。浏览器只知道名字是”<a href="http://www.kaola.com">www.kaola.com</a>”，但是不知道具体的地点，所以不知道应该如何访问。于是，它打开地址簿去查找。可以使用一般的地址簿协议<strong>DNS</strong>去查找，还可以使用另一种更加精准的地址簿查找协议<strong>HTTPDNS</strong>。</p><p>无论用哪一种方法查找，最终都会得到这个地址：106.114.138.24。这个是<strong>IP</strong>地址，是互联网世界的”门牌号”。</p><p>知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览请求，往往会使用<strong>HTTP</strong>协议；但是对于购物的请求，往往需要进行加密传输，因而会使用<strong>HTTPS</strong>协议。无论是什么协议，里面都会写明”你要买什么和买多少”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144203779.png" alt="image-20240522144203779"></p><p>DNS、HTTP、HTTPS 所在的层我们称为<strong>应用层</strong>。经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过 socket 编程来实现。下一层是<strong>传输层</strong>。传输层有两种协议，一种是无连接的协议<strong>UDP</strong>，一种是面向连接的协议<strong>TCP</strong>。对于支付来讲，往往使用 TCP 协议。所谓的面向连接就是，TCP 会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。</p><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144218240.png" alt="image-20240522144218240"></p><p>传输层封装完毕后，浏览器会将包交给操作系统的<strong>网络层</strong>。网络层的协议是 IP 协议。在 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144233303.png" alt="image-20240522144233303"></p><p>操作系统既然知道了目标 IP 地址，就开始想如何根据这个门牌号找到目标机器。操作系统往往会判断，这个目标 IP 地址是本地人，还是外地人。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本地，而在遥远的地方。</p><p>操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海关，去外地就要去<strong>网关</strong>。而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址 192.168.1.1。</p><p>操作系统如何将 IP 地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 192.168.1.1 啊？网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是<strong>MAC</strong>地址，而大吼的那一声是<strong>ARP</strong>协议。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144248330.png" alt="image-20240522144248330"></p><p>于是操作系统将 IP 包交给了下一层，也就是<strong>MAC 层</strong>。网卡再将包发出去。由于这个包里面是有 MAC 地址的，因而它能够到达网关。</p><p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。</p><p>路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址 MAC 进行通信。</p><p>一旦跨越城关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（就是源 IP 地址），欲往西天拜佛求经（指的是目标 IP 地址）。路过宝地，借宿一晚，明日启行，请问接下来该怎么走啊？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144301759.png" alt="image-20240522144301759"></p><p>城关往往是知道这些”知识”的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为路由协议，常用的有<strong>OSPF</strong>和<strong>BGP</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144316590.png" alt="image-20240522144316590"></p><p>城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的 MAC 地址，通过下一个城关的 MAC 地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。</p><p>最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标 IP 啊？目标服务器就会回复一个 MAC 地址。网络包过关后，通过这个 MAC 地址就能找到目标服务器。</p><p>目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP 也对上了，就取下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即<strong>TCP 层</strong>。</p><p>在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。</p><p>因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，例如进了大沙漠，或者被强盗抢劫杀害怎么办呢？因而到了要报个平安。</p><p>如果过一段时间还是没到，发送端的 TCP 层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。<strong>这个重试绝非你的浏览器重新将下单这个动作重新请求一次</strong>。对于浏览器来讲，就发送了一次下单请求，TCP 层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。</p><p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144330863.png" alt="image-20240522144330863"></p><p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。</p><p>如何告诉相关的进程呢？往往通过 RPC 调用，即远程过程调用的方式来实现。远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间的网络互连问题，会由 RPC 框架统一处理。RPC 框架有很多种，有基于 HTTP 协议放在 HTTP 的报文里面的，有直接封装在 TCP 报文里面的。</p><p>当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。</p><h3 id="1-3-小结">1.3 小结</h3><p>列一下之后要讲的网络协议：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144350426.png" alt="image-20240522144350426"></p><h2 id="第2讲-网络分层的真实含义是什么？">第2讲 | 网络分层的真实含义是什么？</h2><h3 id="2-1-这四个问题你真的懂了吗？">2.1 这四个问题你真的懂了吗？</h3><ol><li>TCP 在进行三次握手的时候，IP 层和 MAC 层对应都有什么操作呢？</li><li>A 知道自己的下一个中转站是 B，那从 A 发出来的包，应该把 B 的 IP 地址放在哪里呢？B 知道自己的下一个中转站是 C，从 B 发出来的包，应该把 C 的 IP 地址放在哪里呢？如果放在 IP 协议中的目标地址，那包到了中转站，怎么知道最终的目的地址是 D 呢？</li><li>二层设备处理的通常是 MAC 层的东西。那我发送一个 HTTP 的包，是在第七层工作的，那是不是不需要经过二层设备？或者即便经过了，二层设备也不处理呢？或者换一种问法，二层设备处理的包里，有没有 HTTP 层的内容呢？</li><li>从你的电脑，通过 SSH 登录到公有云主机里面，都需要经历哪些过程？或者说你打开一个电商网站，都需要经历哪些过程？</li></ol><p>上面的这些问题，有的在这一节就会有一个解释，有的则会贯穿我们整个课程。好在后面一节中我会举一个贯穿的例子，将很多层的细节讲过后，你很容易就能把这些知识点串起来。</p><h3 id="2-2-网络为什么要分层？">2.2 网络为什么要分层？</h3><p>因为，是个复杂的程序都要分层。</p><p>理解计算机网络中的概念，一个很好的角度是，想象网络包就是一段 Buffer，或者一块内存，是有格式的。同时，想象自己是一个处理网络包的程序，而且这个程序可以跑在电脑上，可以跑在服务器上，可以跑在交换机上，也可以跑在路由器上。你想象自己有很多的网口，从某个口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。</p><p>当然网络包的格式很复杂，这个程序也很复杂。<strong>复杂的程序都要分层，这是程序设计的要求</strong>。比如，复杂的电商还会分数据库层、缓存层、Compose 层、Controller 层和接入层，每一层专注做本层的事情。</p><h3 id="2-3-程序是如何工作的？">2.3 程序是如何工作的？</h3><p>我们可以简单地想象”你”这个程序的工作过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144538716.png" alt="image-20240522144538716"></p><p>当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了混杂模式，凡是经过的，全部拿进来。</p><p>拿进来以后，就要交给一段程序来处理。于是，你调用<code>process_layer2(buffer)</code>。当然，这是一个假的函数。但是你明白其中的意思，知道肯定是有这么个函数的。那这个函数是干什么的呢？从 Buffer 中，摘掉二层的头，看一看，应该根据头里面的内容做什么操作。</p><p>假设你发现这个包的 MAC 地址和你的相符，那说明就是发给你的，于是需要调用<code>process_layer3(buffer)</code>。这个时候，Buffer 里面往往就没有二层的头了，因为已经在上一个函数的处理过程中拿掉了，或者将开始的偏移量移动了一下。在这个函数里面，摘掉三层的头，看看到底是发送给自己的，还是希望自己转发出去的。</p><p>如何判断呢？如果 IP 地址不是自己的，那就应该转发出去；如果 IP 地址是自己的，那就是发给自己的。根据 IP 头里面的标示，拿掉三层的头，进行下一层的处理，到底是调用 <code>process_tcp(buffer)</code> 呢，还是调用 <code>process_udp(buffer)</code> 呢？</p><p>假设这个地址是 TCP 的，则会调用<code>process_tcp(buffer)</code>。这时候，Buffer 里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 <code>process_http(buffer)</code> 函数呢？</p><p>没有的，如果你是一个网络包处理程序，你不需要有 <code>process_http(buffer)</code>，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。</p><p>浏览器自然是解析 HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 HTTP 请求了，于是使用端口号，将请求发给了你。</p><p>你应该调用<code>send_tcp(buffer)</code>。不用说，Buffer 里面就是 HTTP 请求的内容。这个函数里面加一个 TCP 的头，记录下源端口号。浏览器会给你目的端口号，一般为 80 端口。</p><p>然后调用<code>send_layer3(buffer)</code>。Buffer 里面已经有了 HTTP 的头和内容，以及 TCP 的头。在这个函数里面加一个 IP 的头，记录下源 IP 的地址和目标 IP 的地址。</p><p>然后调用<code>send_layer2(buffer)</code>。Buffer 里面已经有了 HTTP 的头和内容、TCP 的头，以及 IP 的头。这个函数里面要加一下 MAC 的头，记录下源 MAC 地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。</p><p>万事俱备，只要 Buffer 里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了。</p><h3 id="2-4-揭秘层与层之间的关系">2.4 揭秘层与层之间的关系</h3><p>知道了这个过程之后，我们再来看一下原来困惑的问题。</p><p>首先是分层的比喻。<strong>所有不能表示出层层封装含义的比喻，都是不恰当的</strong>。总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧，但是网络世界不是这样的。正确的应该是，总经理之间沟通的时候，经理将总经理放在自己兜里，然后组长把经理放自己兜里，员工把组长放自己兜里，像套娃娃一样。那员工直接沟通，不带上总经理，就不恰当了。</p><p>现实生活中，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句。但是在网络世界，应该是总经理说话，经理补充两句，组长补充两句，员工再补充两句。</p><p>那 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？当然是 TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍。而你只看到 TCP 三次握手了，其实，IP 层和 MAC 层为此也忙活好久了。</p><p>这里要记住一点：<strong>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层</strong>。</p><p>所以，<strong>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的</strong>。</p><p>经常有人会问这样一个问题，我都知道那台机器的 IP 地址了，直接发给他消息呗，要 MAC 地址干啥？这里的关键就是，没有 MAC 地址消息是发不出去的。</p><p>所以如果一个 HTTP 协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。</p><p>所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个 HTTP 协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面 HTTP、TCP、 IP、 MAC 都有。什么叫二层设备呀，就是只把 MAC 头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着。</p><h3 id="2-5-小结">2.5 小结</h3><p>理解网络协议的工作模式，有两个小窍门：</p><ul><li>始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；</li><li>始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</li></ul><h2 id="第3讲-ifconfig：最熟悉又陌生的命令行">第3讲 | ifconfig：最熟悉又陌生的命令行</h2><p>在 Windows 上是 ipconfig，在 Linux 上是 ifconfig。在 Linux 上 ip addr 也可以。</p><p>那你知道 ifconfig 和 ip addr 的区别吗？这是一个有关 net-tools 和 iproute2 的”历史”故事，你刚来到第三节，暂时不用了解这么细，但这也是一个常考的知识点。</p><p>运行一下 ip addr ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f816:3eff:fec7:7975/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这个命令显示了这台机器上所有的网卡。大部分的网卡都会有一个 IP 地址，当然，这不是必须的。在后面的分享中，我们会遇到没有 IP 地址的情况。</p><p><strong>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码</strong>。既然是门牌号码，不能大家都一样，不然就会起冲突。比方说，假如大家都叫六单元 1001 号，那快递就找不到地方了。所以，有时候咱们的电脑弹出网络地址冲突，出现上不去网的情况，多半是 IP 地址冲突了。</p><p>如上输出的结果，10.100.122.2 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。这样产生的 IP 地址的数量很快就不够用了。因为当时设计 IP 地址的时候，哪知道今天会有这么多的计算机啊！因为不够用，于是就有了 IPv6，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64。这个有 128 位，现在看来是够了，但是未来的事情谁知道呢？</p><p>本来 32 位的 IP 地址就不够，还被分成了 5 类。现在想想，当时分配地址的时候，真是太奢侈了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144631049.png" alt="image-20240522144631049"></p><p>在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是网络号，后面一部分是主机号。这很好理解，大家都是六单元 1001 号，我是小区 A 的六单元 1001 号，而你是小区 B 的六单元 1001 号。</p><p>下面这个表格，详细地展示了 A、B、C 三类地址所能包含的主机的数量。在后文中，我也会多次借助这个表格来讲解。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144644621.png" alt="image-20240522144644621"></p><p>这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B 类地址能包含的最大主机数量又太多了。6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</p><h3 id="3-1-无类型域间选路（CIDR）">3.1 无类型域间选路（CIDR）</h3><p>于是有了一个折中的方式叫作无类型域间选路，简称CIDR。这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。从哪里分呢？你如果注意观察的话可以看到，10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。</p><p>伴随着 CIDR 存在的，一个是<strong>广播地址</strong>，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是<strong>子网掩码</strong>，255.255.255.0。</p><p>将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1 和任何数值取 AND，都是原来数值，因而前三个数不变，为 10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是 0，因而最后一个数变为 0，合起来就是 10.100.122.0。这就是<strong>网络号</strong>。<strong>将子网掩码和 IP 地址按位计算 AND，就可得到网络号</strong>。</p><h3 id="3-2-公有-IP-地址和私有-IP-地址">3.2 公有 IP 地址和私有 IP 地址</h3><p>在日常的工作中，几乎不用划分 A 类、B 类或者 C 类，所以时间长了，很多人就忘记了这个分类，而只记得 CIDR。但是有一点还是要注意的，就是公有 IP 地址和私有 IP 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144721679.png" alt="image-20240522144721679"></p><p>我们继续看上面的表格。表格最右列是私有 IP 地址段。平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的。</p><p>这就像每个小区有自己的楼编号和门牌号，你们小区可以叫 6 栋，我们小区也叫 6 栋，没有任何问题。但是一旦出了小区，就需要使用公有 IP 地址。就像人民路 888 号，是国家统一分配的，不能两个小区都叫人民路 888 号。</p><p>公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问。</p><p>表格中的 192.168.0.x 是最常用的私有 IP 地址。你家里有 Wi-Fi，对应就会有一个 IP 地址。一般你家里地上网设备不会超过 256 个，所以 /24 基本就够了。有时候我们也能见到 /16 的 CIDR，这两种是最常见的，也是最容易理解的。</p><p>不需要将十进制转换为二进制 32 位，就能明显看出 192.168.0 是网络号，后面是主机号。而整个网络里面的第一个地址 192.168.0.1，往往就是你这个私有网络的出口地址。例如，你家里的电脑连接 Wi-Fi，Wi-Fi 路由器的地址就是 192.168.0.1，而 192.168.0.255 就是广播地址。一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到。</p><p>但是也不总都是这样的情况。因此，其他情况往往就会很难理解，还容易出错。</p><h3 id="3-3-举例：一个容易”犯错”的-CIDR">3.3 举例：一个容易”犯错”的 CIDR</h3><p>我们来看 16.158.165.91/22 这个 CIDR。求一下这个网络的第一个地址、子网掩码和广播地址。</p><p>你要是上来就写 16.158.165.1，那就大错特错了。</p><p>/22 不是 8 的整数倍，不好办，只能先变成二进制来看。16.158 的部分不会动，它占了前 16 位。中间的 165，变为二进制为 <code>10100101</code> 。除了前面的 16 位，还剩 6 位。所以，这 8 位中前 6 位是网络号，<code>16.158.&lt;101001&gt;</code>，而 <code>&lt;01&gt;.91</code> 是机器号。</p><p>第一个地址是 <code>16.158.&lt;101001&gt;&lt;00&gt;.1</code>，即 <code>16.158.164.1</code>。子网掩码是 <code>255.255.&lt;111111&gt;&lt;00&gt;.0</code>，即 <code>255.255.252.0</code>。广播地址为 <code>16.158.&lt;101001&gt;&lt;11&gt;.255</code>，即 <code>16.158.167.255</code>。</p><p>这五类地址中，还有一类 D 类是<strong>组播地址</strong>。使用这一类地址，属于某个组的机器都能收到。这有点类似在公司里面大家都加入了一个邮件组。发送邮件，加入这个组的都能收到。组播地址在后面讲述 VXLAN 协议的时候会提到。</p><p>讲了这么多，才讲了上面的输出结果中很小的一部分，是不是觉得原来并没有真的理解 ip addr 呢？我们接着来分析。</p><p>在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。</p><p>lo 全称是<strong>loopback</strong>，又称<strong>环回接口</strong>，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p><h3 id="3-4-MAC-地址">3.4 MAC 地址</h3><p>在 IP 地址的上一行是 <code>link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff</code>，这个被称为<strong>MAC 地址</strong>，是一个网卡的物理地址，用十六进制，6 个 byte 表示。</p><p>MAC 地址是一个很容易让人”误解”的地址。因为 MAC 地址号称全局唯一，不会有两个网卡有相同的 MAC 地址，而且网卡自生产出来，就带着这个地址。很多人看到这里就会想，既然这样，整个互联网的通信，全部用 MAC 地址好了，只要知道了对方的 MAC 地址，就可以把信息传过去。</p><p>这样当然是不行的。 <strong>一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能</strong>。 而有门牌号码属性的 IP 地址，才是有远程定位功能的。</p><p>例如，你去杭州市网商路 599 号 B 楼 6 层找刘超，你在路上问路，可能被问的人不知道 B 楼是哪个，但是可以给你指网商路怎么去。但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道。</p><p><strong>MAC 地址更像是身份证，是一个唯一的标识</strong>。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。</p><p>MAC 地址是有一定定位功能的，只不过范围非常有限。你可以根据 IP 地址，找到杭州市网商路 599 号 B 楼 6 层，但是依然找不到我，你就可以靠吼了，大声喊身份证 XXXX 的是哪位？我听到了，我就会站起来说，是我啊。但是如果你在上海，到处喊身份证 XXXX 的是哪位，我不在现场，当然不会回答，因为我在杭州不在上海。</p><p>所以，MAC 地址的通信范围比较小，局限在一个子网里面。例如，从 192.168.0.2/24 访问 192.168.0.3/24 是可以用 MAC 地址的。一旦跨子网，即从 192.168.0.2/24 到 192.168.1.2/24，MAC 地址就不行了，需要 IP 地址起作用了。</p><h3 id="3-5-网络设备的状态标识">3.5 网络设备的状态标识</h3><p>解析完了 MAC 地址，我们再来看 <code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code> 是干什么的？这个叫作<strong>net_device flags，网络设备的状态标识</strong>。</p><p>UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指什么意思呢？是哪一层的概念呢？最大传输单元 MTU 为 1500，这是以太网的默认值。</p><p>上一节，我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p><p><code>qdisc pfifo_fast</code> 是什么意思呢？qdisc 全称是<strong>queueing discipline</strong>，中文叫<strong>排队规则</strong>。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。</p><p>最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。<code>pfifo_fast</code> 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</p><p>三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。</p><p>数据包是按照服务类型（<strong>Type of Service，TOS</strong>）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><p>队列是个好东西，后面我们讲云计算中的网络的时候，会有很多用户共享一个网络出口的情况，这个时候如何排队，每个队列有多粗，队列处理速度应该怎么提升，我都会详细为你讲解。</p><h3 id="3-6-小结">3.6 小结</h3><p>知识点：</p><ul><li>IP 是地址，有定位功能；MAC 是身份证，无定位功能；</li><li>CIDR 可以用来判断是不是本地人；</li><li>IP 分公有的 IP 和私有的 IP。后面的章节中我会谈到”出国门”，就与这个有关。</li></ul><h2 id="第4讲-DHCP与PXE：IP是怎么来的，又是怎么没的？">第4讲 | DHCP与PXE：IP是怎么来的，又是怎么没的？</h2><h3 id="4-1-如何配置-IP-地址？">4.1 如何配置 IP 地址？</h3><p>如果有相关的知识和积累，你可以用命令行自己配置一个地址。</p><ol><li><p>使用 net-tools：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth1 10.0.0.1/24</span><br><span class="line">sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure></li><li><p>使用 iproute2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 10.0.0.1/24 dev eth1</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> up eth1</span><br></pre></td></tr></table></figure><p>你可能会问了，自己配置这个自由度太大了吧，我是不是配置什么都可以？如果配置一个和谁都不搭边的地址呢？例如，旁边的机器都是 192.168.1.x，我非得配置一个 16.158.23.6，会出现什么现象呢？</p></li></ol><p>不会出现任何现象，就是包发不出去呗。为什么发不出去呢？我来举例说明。</p><p>192.168.1.6 就在你这台机器的旁边，甚至是在同一个交换机上，而你把机器的地址设为了 16.158.23.6。在这台机器上，你企图去 ping192.168.1.6，你觉得只要将包发出去，同一个交换机的另一台机器马上就能收到，对不对？</p><p>可是 Linux 系统不是这样的，它没你想得那么智能。你用肉眼看到那台机器就在旁边，它则需要根据自己的逻辑进行处理。</p><p>还记得我们在第二节说过的原则吗？<strong>只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层</strong>。</p><p>所以，你看着它有自己的源 IP 地址 16.158.23.6，也有目标 IP 地址 192.168.1.6，但是包发不出去，这是因为 MAC 层还没填。</p><p>自己的 MAC 地址自己知道，这个容易。但是目标 MAC 填什么呢？是不是填 192.168.1.6 这台机器的 MAC 地址呢？</p><p>当然不是。Linux 首先会判断，要去的这个地址和我是一个网段的吗，或者和我的一个网卡是同一网段的吗？只有是一个网段的，它才会发送 ARP 请求，获取 MAC 地址。如果发现不是呢？</p><p><strong>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关</strong>。</p><p>如果你配置了网关的话，Linux 会获取网关的 MAC 地址，然后将包发出去。对于 192.168.1.6 这台机器来讲，虽然路过它家门的这个包，目标 IP 是它，但是无奈 MAC 地址不是它的，所以它的网卡是不会把包收进去的。</p><p>如果没有配置网关呢？那包压根就发不出去。</p><p>如果将网关配置为 192.168.1.6 呢？不可能，Linux 不会让你配置成功的，因为网关要和当前的网络至少一个网卡是同一个网段的，怎么可能 16.158.23.6 的网关是 192.168.1.6 呢？</p><p>所以，当你需要手动配置一台机器的网络 IP 时，一定要好好问问你的网络管理员。如果在机房里面，要去网络管理员那里申请，让他给你分配一段正确的 IP 地址。当然，真正配置的时候，一定不是直接用命令配置的，而是放在一个配置文件里面。<strong>不同系统的配置文件格式不同，但是无非就是 CIDR、子网掩码、广播地址和网关地址</strong>。</p><h3 id="4-2-动态主机配置协议（DHCP）">4.2 动态主机配置协议（DHCP）</h3><p>原来配置 IP 有这么多门道儿啊。你可能会问了，配置了 IP 之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置 IP 地址，那可怎么办？还有人事、行政等非技术人员，如果公司所有的电脑都需要 IT 人员配置，肯定忙不过来啊。</p><p>因此，我们需要有一个自动配置的协议，也就是称<strong>动态主机配置协议（Dynamic Host Configuration Protocol）</strong>，简称<strong>DHCP</strong>。</p><p>有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好就可以了。等人走了，或者用完了，还回去，这样其他的机器也能用。</p><p>所以说，<strong>如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了</strong>。</p><h3 id="4-3-解析-DHCP-的工作方式">4.3 解析 DHCP 的工作方式</h3><p>当一台机器新加入一个网络的时候，肯定一脸懵，啥情况都不知道，只知道自己的 MAC 地址。怎么办？先吼一句，我来啦，有人吗？这时候的沟通基本靠”吼”。这一步，我们称为<strong>DHCP Discover</strong>。</p><p>新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。</p><p>在这个广播包里面，新人大声喊：我是新来的（Boot request），我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144856356.png" alt="image-20240522144856356"></p><p>如果一个网络管理员在网络里面配置了<strong>DHCP Server</strong>的话，他就相当于这些 IP 的管理员。他立刻能知道来了一个”新人”。这个时候，我们可以体会 MAC 地址唯一的重要性了。当一台机器带着自己的 MAC 地址加入一个网络的时候，MAC 是它唯一的身份，如果连这个都重复了，就没办法配置了。</p><p>只有 MAC 唯一，IP 管理员才能知道这是一个新人，需要租给它一个 IP 地址，这个过程我们称为<strong>DHCP Offer</strong>。同时，DHCP Server 为此客户保留为它提供的 IP 地址，从而不会为其他 DHCP 客户分配此 IP 地址。</p><p>DHCP Offer 的格式就像这样，里面有给新人分配的地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144909959.png" alt="image-20240522144909959"></p><p>DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 回复说，我分配了一个可用的 IP 给你，你看如何？除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。</p><p>新来的机器很开心，它的”吼”得到了回复，并且有人愿意租给它一个 IP 地址了，这意味着它可以在网络上立足了。当然更令人开心的是，如果有多个 DHCP Server，这台新机器会收到多个 IP 地址，简直受宠若惊。</p><p>它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144922261.png" alt="image-20240522144922261"></p><p>此时，由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP。</p><p>当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144933703.png" alt="image-20240522144933703"></p><p>最终租约达成的时候，还是需要广播一下，让大家都知道。</p><h3 id="4-4-IP-地址的收回和续租">4.4 IP 地址的收回和续租</h3><p>既然是租房子，就是有租期的。租期到了，管理员就要将 IP 收回。</p><p>如果不用的话，收回就收回了。就像你租房子一样，如果还要续租的话，不能到了时间再续租，而是要提前一段时间给房东说。DHCP 也是这样。</p><p>客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。</p><p>好了，一切看起来完美。DHCP 协议大部分人都知道，但是其实里面隐藏着一个细节，很多人可能不会去注意。接下来，我就讲一个有意思的事情：网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系统！</p><h3 id="4-5-预启动执行环境（PXE）">4.5 预启动执行环境（PXE）</h3><p>普通的笔记本电脑，一般不会有这种需求。因为你拿到电脑时，就已经有操作系统了，即便你自己重装操作系统，也不是很麻烦的事情。但是，在数据中心里就不一样了。数据中心里面的管理员可能一下子就拿到几百台空的机器，一个个安装操作系统，会累死的。</p><p>所以管理员希望的不仅仅是自动分配 IP 地址，还要自动安装系统。装好系统之后自动分配 IP 地址，直接启动就能用了，这样当然最好了！</p><p>这事儿其实仔细一想，还是挺有难度的。安装操作系统，应该有个光盘吧。数据中心里不能用光盘吧，想了一个办法就是，可以将光盘里面要安装的操作系统放在一个服务器上，让客户端去下载。但是客户端放在哪里呢？它怎么知道去哪个服务器上下载呢？客户端总得安装在一个操作系统上呀，可是这个客户端本来就是用来安装操作系统的呀？</p><p>其实，这个过程和操作系统启动的过程有点儿像。首先，启动 BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的 MBR 启动扇区，将 GRUB 启动起来；然后将权力交给 GRUB，GRUB 加载内核、加载作为根文件系统的 initramfs 文件；然后将权力交给内核；最后内核启动，初始化整个操作系统。</p><p>那我们安装操作系统的过程，只能插在 BIOS 启动之后了。因为没安装系统之前，连启动扇区都没有。因而这个过程叫做<strong>预启动执行环境（Pre-boot Execution Environment）</strong>，简称<strong>PXE</strong>。</p><p>PXE 协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在 BIOS 里面。当计算机启动时，BIOS 把 PXE 客户端调入内存里面，就可以连接到服务端做一些操作了。</p><p>首先，PXE 客户端自己也需要有个 IP 地址。因为 PXE 的客户端启动起来，就可以发送一个 DHCP 的请求，让 DHCP Server 给它分配一个地址。PXE 客户端有了自己的地址，那它怎么知道 PXE 服务器在哪里呢？对于其他的协议，都好办，要么人告诉他。例如，告诉浏览器要访问的 IP 地址，或者在配置中告诉它；例如，微服务之间的相互调用。</p><p>但是 PXE 客户端启动的时候，啥都没有。好在 DHCP Server 除了分配 IP 地址以外，还可以做一些其他的事情。这里有一个 DHCP Server 的一个样例配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ddns-update-style interim;</span><br><span class="line">ignore client-updates;</span><br><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">subnet 192.168.1.0 netmask 255.255.255.0</span><br><span class="line">&#123;</span><br><span class="line">    option routers 192.168.1.1;</span><br><span class="line">    option subnet-mask 255.255.255.0;</span><br><span class="line">    option time-offset -18000;</span><br><span class="line">    default-lease-time 21600;</span><br><span class="line">    max-lease-time 43200;</span><br><span class="line">    range dynamic-bootp 192.168.1.240 192.168.1.250;</span><br><span class="line">    filename &quot;pxelinux.0&quot;;</span><br><span class="line">    next-server 192.168.1.180;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的原理，默认的 DHCP Server 是需要配置的，无非是我们配置 IP 的时候所需要的 IP 地址段、子网掩码、网关地址、租期等。如果想使用 PXE，则需要配置 next-server，指向 PXE 服务器的地址，另外要配置初始启动文件 filename。</p><p>这样 PXE 客户端启动之后，发送 DHCP 请求之后，除了能得到一个 IP 地址，还可以知道 PXE 服务器在哪里，也可以知道如何从 PXE 服务器上下载某个文件，去初始化操作系统。</p><h3 id="4-6-解析-PXE-的工作过程">4.6 解析 PXE 的工作过程</h3><p>首先，启动 PXE 客户端。第一步是通过 DHCP 协议告诉 DHCP Server，我刚来，一穷二白，啥都没有。DHCP Server 便租给它一个 IP 地址，同时也给它 PXE 服务器的地址、启动文件 pxelinux.0。</p><p>其次，PXE 客户端知道要去 PXE 服务器下载这个文件后，就可以初始化机器。于是便开始下载，下载的时候使用的是 TFTP 协议。所以 PXE 服务器上，往往还需要有一个 TFTP 服务器。PXE 客户端向 TFTP 服务器请求下载这个文件，TFTP 服务器说好啊，于是就将这个文件传给它。</p><p>然后，PXE 客户端收到这个文件后，就开始执行这个文件。这个文件会指示 PXE 客户端，向 TFTP 服务器请求计算机的配置信息 pxelinux.cfg。TFTP 服务器会给 PXE 客户端一个配置文件，里面会说内核在哪里、initramfs 在哪里。PXE 客户端会请求这些文件。</p><p>最后，启动 Linux 内核。一旦启动了操作系统，以后就啥都好办了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144951662.png" alt="image-20240522144951662"></p><p>简单来说，预启动执行环境（PXE，Preboot eXecution Environment）是一种让计算机通过网络启动的方法。它是由Intel提出的一种行业标准，允许计算机在没有任何硬盘或操作系统的情况下，通过网络接口从网络服务器上下载必要的启动文件，进而启动操作系统。</p><p>具体来说，当启动一个PXE兼容的计算机时，计算机的BIOS会启用它的网络接口，发送一个网络启动请求。这个请求会被网络中的PXE服务器捕获，PXE服务器会回应这个请求，提供一个启动映像。计算机会下载这个映像，并从中启动操作系统。</p><p>总的来说，PXE就是一种让计算机通过网络启动的技术，它可以让计算机在没有硬盘或操作系统的情况下启动，这对于大规模的计算机集群管理和维护，或者无盘工作站等环境非常有用。</p>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C10K问题</title>
    <link href="https://penge666.github.io/posts/578383f4.html"/>
    <id>https://penge666.github.io/posts/578383f4.html</id>
    <published>2024-05-21T13:02:39.000Z</published>
    <updated>2024-05-21T13:14:27.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C10K问题">1 C10K问题</h2><p>大家都知道互联网的基础就是网络通信，早期的互联网可以说是一个小群体的集合。互联网还不够普及，用户也不多。一台服务器同时在线100个用户估计在当时已经算是大型应用了。所以并不存在什么C10K的难题。互联网的爆发期应该是在www网站，浏览器，雅虎出现后。最早的互联网称之为Web1.0，互联网大部分的使用场景是下载一个Html页面，用户在浏览器中查看网页上的信息。这个时期也不存在C10K问题。</p><p>Web2.0时代到来后就不同了，一方面是普及率大大提高了，用户群体几何倍增长。另一方面是互联网不再是单纯的浏览万维网网页，逐渐开始进行交互，而且应用程序的逻辑也变的更复杂，从简单的表单提交，到即时通信和在线实时互动。C10K的问题才体现出来了。每一个用户都必须与服务器保持TCP连接才能进行实时的数据交。Facebook这样的网站同一时间的并发TCP连接可能会过亿。</p><blockquote><p>腾讯QQ也是有C10K问题的，只不过他们是用了UDP这种原始的包交换协议来实现的，绕开了这个难题。当然过程肯定是痛苦的。如果当时有epoll技术，他们肯定会用TCP。后来的手机QQ，微信都采用TCP协议。</p></blockquote><p>这时候问题就来了，最初的服务器都是基于进程/线程模型的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，那么操作系统是无法承受的。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook，Google，雅虎才有财力购买如此多的服务器。这就是C10K问题的本质。</p><blockquote><p>实际上当时也有异步模式，如：select/poll模型，这些技术都有一定的缺点，如selelct最大不能超过1024，poll没有限制，但每次收到数据需要遍历每一个连接查看哪个连接有数据请求。</p></blockquote><p><strong>C10K 问题</strong>：如何在一台物理机上同时服务 10000 个用户。这里 C 表示并发，10K 等于 10000。</p><p>注意这里的并发连接和每秒请求数不同，虽然它们是相似的：</p><p>每秒处理许多请求需要很高的吞吐量（快速处理它们），但是更大的数量并发连接需要高效的连接调度。</p><p>C10K 问题是一个优化网络套接字以同时处理大量客户端连接的问题。</p><p>解决这一问题，主要思路有两个：<code>一个是对于每个连接处理分配一个独立的进程/线程；另一个思路是用同一进程/线程来同时处理若干连接</code>。</p><h2 id="2-解决方案">2 解决方案</h2><p>解决这一问题，主要思路有两个：<code>一个是对于每个连接处理分配一个独立的进程/线程；另一个思路是用同一进程/线程来同时处理若干连接</code>。</p><h3 id="2-1-每个进程-线程处理一个连接">2.1 每个进程/线程处理一个连接</h3><p>这一思路最为直接。但是由于申请进程/线程会占用相当可观的系统资源，同时对于多进程/线程的管理会对系统造成压力，因此这种方案不具备良好的可扩展性。</p><p>因此，这一思路在服务器资源还没有富裕到足够程度的时候，是不可行的；即便资源足够富裕，效率也不够高。</p><p><strong><code>问题：资源占用过多，可扩展性差。</code></strong></p><h3 id="2-1-每个进程-线程处理一个连接-2">2.1 每个进程/线程处理一个连接</h3><p>这一思路最为直接。但是由于申请进程/线程会占用相当可观的系统资源，同时对于多进程/线程的管理会对系统造成压力，因此这种方案不具备良好的可扩展性。</p><p>因此，这一思路在服务器资源还没有富裕到足够程度的时候，是不可行的；即便资源足够富裕，效率也不够高。</p><p><strong><code>问题：资源占用过多，可扩展性差。</code></strong></p><h3 id="2-2-每个进程-线程同时处理多个连接（IO多路复用）">2.2 每个进程/线程同时处理多个连接（IO多路复用）</h3><ol><li><strong>传统思路</strong> <code>最简单的方法是循环挨个处理各个连接，每个连接对应一个 socket</code>，当所有 socket 都有数据的时候，这种方法是可行的。 但是当应用读取某个 socket 的文件数据不 ready 的时候，<code>整个应用会阻塞在这里等待该文件句柄</code>，即使别的文件句柄 ready，也无法往下处理。 思路：直接循环处理多个连接。 问题：任一文件句柄的不成功会阻塞住整个应用。</li><li><strong>select</strong> 要解决上面阻塞的问题，思路很简单，如果我在读取文件句柄之前，<code>先查下它的状态，ready 了就进行处理，不 ready 就不进行处理</code>，这不就解决了这个问题了嘛？ 于是有了 select 方案。<code>用一个 fd_set 结构体来告诉内核同时监控多个文件句柄，当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回</code>。之后应用可以<code>使用 FD_ISSET 来逐个查看是哪个文件句柄的状态发生了变化</code>。 这样做，<code>小规模的连接问题不大，但当连接数很多（文件句柄个数很多）的时候，逐个检查状态就很慢了</code>。因此，<code>select 往往存在管理的句柄上限（FD_SETSIZE）</code>。同时，<code>在使用上，因为只有一个字段记录关注和发生事件，每次调用之前要重新初始化 fd_set 结构体</code>。 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 思路：有连接请求抵达了再检查处理。 问题：句柄上限+重复初始化+逐个排查所有文件句柄状态效率不高。</li><li><strong>poll</strong> poll 主要解决 select 的前两个问题：<code>通过一个 pollfd 数组向内核传递需要关注的事件消除文件句柄上限</code>，同时<code>使用不同字段分别标注关注事件和发生事件，来避免重复初始化</code>。 int poll(struct pollfd *fds, nfds_t nfds, int timeout); 思路：设计新的数据结构提供使用效率。 问题：逐个排查所有文件句柄状态效率不高。</li><li><strong>epoll</strong> 既然逐个排查所有文件句柄状态效率不高，很自然的，<code>如果调用返回的时候只给应用提供发生了状态变化（很可能是数据 ready）的文件句柄</code>，进行排查的效率不就高多了么。 epoll 采用了这种设计，适用于大规模的应用场景。 实验表明，<code>当文件句柄数目超过 10 之后，epoll 性能将优于 select 和 poll；当文件句柄数目达到 10K 的时候，epoll 已经超过 select 和 poll 两个数量级</code>。 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 思路：只返回状态变化的文件句柄。 问题：依赖特定平台（Linux）。 因为Linux是互联网企业中使用率最高的操作系统，<code>Epoll就成为C10K killer、高并发、高性能、异步非阻塞这些技术的代名词了</code>。FreeBSD推出了kqueue，Linux推出了epoll，Windows推出了IOCP，Solaris推出了/dev/poll。<code>这些操作系统提供的功能就是为了解决C10K问题</code>。<code>epoll技术的编程模型就是异步非阻塞回调</code>，也可以叫做Reactor，事件驱动，事件轮循（EventLoop）。Nginx，libevent，node.js这些就是Epoll时代的产物。</li><li><strong>libevent</strong> 由于epoll, kqueue, IOCP每个接口都有自己的特点，程序移植非常困难，于是需要对这些接口进行封装，以让它们易于使用和移植，其中libevent库就是其中之一。跨平台，封装底层平台的调用，提供统一的 API，但底层在不同平台上自动选择合适的调用。 按照libevent的官方网站，libevent库提供了以下功能：<code>当一个文件描述符的特定事件（如可读，可写或出错）发生了，或一个定时事件发生了，libevent就会自动执行用户指定的回调函数，来处理事件</code>。目前，libevent已支持以下接口/dev/poll, kqueue, event ports, select, poll 和 epoll。<code>Libevent的内部事件机制完全是基于所使用的接口的</code>。因此libevent非常容易移植，也使它的扩展性非常容易。目前，libevent已在以下操作系统中编译通过：Linux，BSD，Mac OS X，Solaris和Windows。 使用libevent库进行开发非常简单，也很容易在各种unix平台上移植。一个简单的使用libevent库的程序如下：</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240521211111250.png" alt="image-20240521211111250"></p><h2 id="3-协程（coroutine）">3 协程（coroutine）</h2><p>随着技术的演进，epoll 已经可以较好的处理 C10K 问题，但是如果要进一步的扩展，例如支持 10M 规模的并发连接，原有的技术就无能为力了。</p><p>那么，新的瓶颈在哪里呢？</p><p>从前面的演化过程中，我们可以看到，<code>根本的思路是要高效的去阻塞，让 CPU 可以干核心的任务</code>。<strong>所以，千万级并发实现的秘密：内核不是解决方案，而是问题所在！</strong></p><p><strong>这意味着：</strong></p><blockquote><p>不要让内核执行所有繁重的任务。将数据包处理，内存管理，处理器调度等任务从内核转移到应用程序高效地完成。让Linux只处理控制层，数据层完全交给应用程序来处理。</p></blockquote><p><code>当连接很多时，首先需要大量的进程/线程来做事</code>。同时系统中的应用进程/线程们可能大量的都处于 ready 状态，<code>需要系统去不断的进行快速切换</code>，而我们知道<code>系统上下文的切换是有代价的</code>。虽然现在 Linux 系统的调度算法已经设计的很高效了，但对于 10M 这样大规模的场景仍然力有不足。</p><p>所以我们面临的瓶颈有两个，<code>一个是进程/线程作为处理单元还是太厚重了；另一个是系统调度的代价太高了</code>。</p><p>很自然地，我们会想到，<strong><code>如果有一种更轻量级的进程/线程作为处理单元，而且它们的调度可以做到很快（最好不需要锁）</code></strong>，那就完美了。</p><p>这样的技术现在在某些语言中已经有了一些实现，<code>它们就是 coroutine（协程），或协作式例程</code>。具体的，<code>Python、Lua 语言中的 coroutine（协程）模型，Go 语言中的 goroutine（Go 程）模型，都是类似的一个概念</code>。实际上，多种语言（甚至 C 语言）都可以实现类似的模型。</p><p>它们在实现上都是<code>试图用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换</code>。<code>每个协程所独占的系统资源往往只有栈部分</code>。而且，<code>各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种 callback 类似）</code>，不需要内核参与，可以很方便的实现异步。</p><p>这个技术本质上也是<code>异步非阻塞技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环</code>。程序员就像写阻塞代码一样简单。比如调用 client-&gt;recv() 等待接收数据时，就像阻塞代码一样写。<code>实际上是底层库在执行recv时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行。</code></p><p>这就是协程的本质。<code>协程是异步非阻塞的另外一种展现形式</code>。Golang，Erlang，Lua协程都是这个模型。</p><h3 id="3-1-同步阻塞">3.1 同步阻塞</h3><p>不知道大家看完协程是否感觉得到，<code>实际上协程和同步阻塞是一样的</code>。答案是的。<code>所以协程也叫做用户态进/用户态线程</code>。区别就在于<code>进程/线程是操作系统充当了EventLoop调度，而协程是自己用Epoll进行调度</code>。</p><p>协程的优点是它比系统线程开销小，缺点是如果其中一个协程中有密集计算，其他的协程就不运行了。操作系统进程的缺点是开销大，优点是无论代码怎么写，所有进程都可以并发运行。</p><blockquote><p><code>Erlang解决了协程密集计算的问题，它基于自行开发VM，并不执行机器码</code>。即使存在密集计算的场景，<code>VM发现某个协程执行时间过长，也可以进行中止切换</code>。Golang由于是直接执行机器码的，所以无法解决此问题。<code>所以Golang要求用户必须在密集计算的代码中，自行Yield</code>。</p></blockquote><p>实际上同步阻塞程序的性能并不差，它的效率很高，不会浪费资源。当进程发生阻塞后，操作系统会将它挂起，不会分配CPU。直到数据到达才会分配CPU。多进程只是开多了之后副作用太大，<code>因为进程多了互相切换有开销</code>。所以<code>如果一个服务器程序只有1000左右的并发连接，同步阻塞模式是最好的</code>。</p><h3 id="3-2-异步回调和协程哪个性能好">3.2 异步回调和协程哪个性能好</h3><p><code>协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换</code>。所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。<code>而异步回调是没有切换开销的，它等同于顺序执行代码</code>。所以异步回调程序的性能是要优于协程模型的。</p>]]></content>
    
    
    <summary type="html">《浅析C10K问题》</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>RPC实战与核心原理</title>
    <link href="https://penge666.github.io/posts/11ab60d3.html"/>
    <id>https://penge666.github.io/posts/11ab60d3.html</id>
    <published>2024-05-20T03:38:46.000Z</published>
    <updated>2024-05-20T03:40:07.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《RPC实战与核心原理》">《RPC实战与核心原理》</h2><h3 id="开篇">开篇</h3><p><strong>为什么要学习RPC？</strong></p><blockquote><p>RPC是解决分布式系统通信问题的一大利器。 RPC对网络通信的整个过程做了完整包装，在搭建分布式系统时，它会使网络通信逻辑的开发变得更加简单，同时也会让网络通信变得更加安全可靠。</p></blockquote><p><strong>如何学习RPC？</strong></p><p>学习是一个通过不断解决问题来提升能力的过程，学习RPC可以采取“逐步深入”的方法： 1. 摆脱现有封装好的框架，了解RPC基本原理以及关键的网络通信过程。 2. 了解RPC框架中的治理功能以及集群管理功能。 3. 对RPC活学活用，学习如何提升RPC性能以及在分布式环境下如何定位解决问题。</p><h3 id="01-核心原理：能否画张图解释下RPC的通信流程">01|核心原理：能否画张图解释下RPC的通信流程</h3><p>这一讲的标题就是一道很好的面试题呀。</p><p>我们平时工作中，可以熟练使用各种框架，但是，我们也需要掌握框架背后的基本原理。</p><p><strong>什么是RPC？</strong></p><blockquote><p>RPC的全称是Remote Procedure Call，即远程过程调用。它帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地方法一样的体验，我们不需要因为这个方法是远程调用而需要编写很多与业务无关的代码。</p></blockquote><p>RPC框架一般采用TCP作为数据传输协议。</p><p>RPC中的网络传输，会涉及到数据的序列化和反序列化。</p><p><strong>RPC如何实现调用远程方法像调用本地方法一样的体验？</strong></p><blockquote><p>服务提供者给出业务接口声明，在调用方的程序里面，RPC框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到了声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候，就获得了像调用本地接口一样的体验。</p></blockquote><p><strong>RPC通信基本流程图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100006538.png" alt="image-20240520100006538"></p><p><strong>RPC在现代应用架构中的位置是怎样的？</strong></p><blockquote><p>RPC是解决应用间通信的一种方式，无论是在一个大型的分布式应用系统中，还是在中小型系统中，应用架构都会沿着单体-&gt;微服务化的方向演进，这样，整个应用会被拆分成多个不同功能的应用或者服务，这些细粒度的应用或者服务可能会部署到多台服务器中，它们之间的通信，就会通过RPC进行，所以，我们可以说，RPC对应的是整个分布式应用系统，就像是“经络”一样的存在。</p></blockquote><h3 id="02-协议：怎么设计可扩展且向后兼容的协议？">02 | 协议：怎么设计可扩展且向后兼容的协议？</h3><p><strong>我们为什么需要使用协议？</strong></p><blockquote><p>在网络通信的过程中，为了避免语义不一致的情况，我们需要在发送请求时设定一个边界，然后再收到请求时按照设定的边界对请求数据进行分割。这里的边界语义的表达，就是我们所说的协议。</p></blockquote><p><strong>为什么我们在RPC中不使用HTTP作为主要协议？</strong></p><blockquote><p>RPC负责应用间通信，对性能要求高，但HTTP协议的数据包大小相对请求数据来说，要大很多，包含了很多额外字符，例如换行、回车等。<br>HTTP协议属于无状态协议，客户端无法对请求和响应进行关联，不能很好地进行异步处理。</p></blockquote><p>我们在设计协议时，一般会把协议分成两部分：</p><ol><li>协议头，由一堆固定长度的参数组成。</li><li>协议体，根据请求接口和参数构造，长度可变。</li></ol><p><strong>什么是定长协议？</strong></p><p>定长协议是指协议头长度固定。协议头示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100618073.png" alt="image-20240520100618073"></p><p><strong>定长协议有什么缺点？</strong></p><blockquote><p>定长协议的协议头不能添加新参数，否则就会产生兼容性问题。例如我们设计了一个 88Bit 的协议头，其中协议长度占用32bit，然后为了加入新功能，在协议头里面加了2bit，并且放到协议头的最后。升级后的应用，会用新的协议发出请求，然而没有升级的应用收到的请求后，还是按照88bit 读取协议头，新加的2个bit会当作协议体前2个bit数据读出来，但原本的协议体最后2个bit会被丢弃了，这样就会导致协议体的数据是错的。</p></blockquote><p><strong>如何设计一个可扩展的协议？</strong></p><p>我们需要让协议头支持可扩展，扩展后协议头的长度就不能定长了。这样整个协议变成了三部分：固定部分、协议头内容、协议体内容。<br>可扩展协议的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100638612.png" alt="image-20240520100638612"></p><p>设计一个简单的RPC协议不难，难的地方在于怎么设计一个可“升级”的协议，不仅要让我们在扩展新特性的时候能够做到向下兼容，而且要尽可能地减少资源损耗。</p><p><strong>协议头的具体内容是什么？</strong></p><ul><li>Bit Offset：标识协议的起始位置。</li><li>魔术位：标识是什么协议。</li><li>整体长度：标识整个协议有多长，它减去头长度就是协议体长度</li><li>头长度：协议头的长度，因为协议头长度不固定，所以需要标识。</li><li>协议版本：标识协议的版本，主要用于兼容性控制。</li><li>消息类型：标识消息的类型，可能是文本、XML、JSON等。</li><li>序列化方式：标识用来做序列化和反序列化的方式。</li><li>消息ID：用于标识请求和响应的关系。</li><li>协议头扩展字段：用于扩展协议头，这样使得协议具有可扩展性，更加灵活。</li><li>协议体：协议的具体内容，二进制格式。</li></ul><h3 id="03-序列化：对象怎么在网络中传输？"><strong>03 | 序列化：对象怎么在网络中传输？</strong></h3><p><strong>什么是“序列化”和“反序列化”？</strong></p><blockquote><p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是不能直接在网络中传输，所以我们需要提前把它转变成可传输的二进制，并且要求转换算法是可逆的，这个过程称为“序列化”。<br>根据请求类型和序列化类型，服务提供方将请求传来的二进制数据还原成请求对象，这个过程称为“反序列化”。</p></blockquote><p>序列化就是将对象转换成二进制数据的过程，而反序列化就是把二进制数据转换成对象的过程。</p><p><strong>有哪些常用的序列化方式？</strong></p><ul><li>JDK原生序列化</li><li>JSON</li><li>Hessian</li><li>Protobuf</li><li>Protostuff</li><li>Thrift</li><li>Avro</li></ul><p>任何一种序列化框架，核心思想就是设计一种序列化协议，将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个对象，来完成反序列化。</p><p><strong>JSON进行序列化存在哪些问题？</strong></p><ol><li>JSON额外空间开销比较大，对于大数据量服务意味着巨大的内存和磁盘开销。</li><li>JSON没有类型，但Java属于强类型语言，这需要通过反射来解决类型问题，所以会影响性能，这样就要求服务提供者和调用者之间传输的数据量要小。</li></ol><p><strong>Hessian有什么缺点？</strong></p><p>Hessian不支持Java一些常见类型，例如：</p><ol><li>Linked系列</li><li>Locale类</li><li>Byte/Short在反序列化时会变成Integer</li></ol><p><strong>如何选择合适的序列化框架？</strong></p><p>对于服务提供者来说，服务的可靠性要比性能更重要，因此，我们在选择序列化框架时，更关注协议在版本升级后的兼容性是否很好、是否支持更多的对象类型、是否跨平台、跨语言、是否有很多人已经用过并且踩过坑了，其次，我们才会考虑性能、效率和空间开销。<br>另外序列化协议的安全也是需要考虑的一个重要因素。<br>综合考虑，当我们选择序列化协议时，考虑因素如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100802335.png" alt="image-20240520100802335"></p><p><strong>RPC框架在使用序列化协议时有哪些注意事项？</strong></p><ol><li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚。</li><li>入参对象与返回值对象体积不要太大，更不要传太大的集合。</li><li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类。</li><li>对象不要有复杂的继承关系，最好不要有父子类的情况。</li></ol><h3 id="04-网络通信：RPC框架在网络通信上更倾向于哪种网络IO模型？">04 | 网络通信：RPC框架在网络通信上更倾向于哪种网络IO模型？</h3><p><strong>网络通信在RPC调用中有什么作用？</strong></p><blockquote><p>RPC是解决进程间通信的一种方式，一次RPC调用，本质就是服务消费者与服务提供者之间的一次网络信息交换的过程。服务调用者通过网络IO发送一条请求消息，服务提供者接收并解析，处理完相关的业务逻辑之后，再发送一条响应消息给服务调用者，服务调用者接收并解析响应消息，处理完相关的响应逻辑，一次RPC调用便结束了。我们可以说，网络通信是整个RPC调用流程的基础。</p></blockquote><p><strong>有哪些常见的网络IO模型？</strong></p><blockquote><p>常见的网络IO模型分为四种：同步阻塞IO（BIO）、同步非阻塞IO（NIO）、IO多路复用和异步非阻塞IO（AIO）。其中AIO是异步IO，其他三种都是同步IO。<br>最常用的IO模型是同步阻塞IO和IO多路复用。</p></blockquote><p><strong>阻塞IO的工作流程是怎样的？</strong></p><blockquote><p>应用进程发起IO系统调用后，应用进程被阻塞，转到内核空间处理。内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中，整个IO处理完毕后返回进程。最后应用进程解除阻塞状态，运行业务逻辑。<br>系统内核在处理IO操作时，主要分为两个阶段：等待数据和拷贝数据。在此期间，应用进程中进行IO操作的线程一直会处于阻塞状态。</p></blockquote><p><strong>什么是IO多路复用？</strong></p><blockquote><p>多路就是指多个通道，也就是多个网络连接的IO，复用指多个通道复用在一个复用器上。 多个网络连接的IO可以注册到一个复用器（select）上，当用户进程调用了select，整个进程会被阻塞，同时，内核会监视所有socket负责的socket，当任何一个socket中的数据准备好了，select就会返回。这时用户进程再调用read操作，将数据从内核中拷贝到用户进程。<br>IO多路复用的优势在于用户可以在一个线程内同时处理多个socket的IO请求，用户可以注册多个socket，然后不断地调用select读取被激活的socket，这样可以达到在同一个线程内同时处理多个IO请求的目的。</p></blockquote><p><strong>有哪些常见的框架或者工具会使用IO多路复用？</strong></p><blockquote><p>Java中的NIO、Redis、Nginx、Reactor模式等。</p></blockquote><p>在高性能的网络编程框架的编写上，大多数都是基于Reactor模式做的，其中的典型就是Java的Netty框架。</p><p><strong>RPC调用在大多数情况下，是一个高并发调用的场景，考虑到系统内核的支持、编程语言的支持以及IO模型本身的特点，在RPC框架的实现中，我们选择IO多路复用作为网络通信采用的IO模型。</strong></p><p><strong>什么是“零拷贝”？</strong></p><p>在没有零拷贝之前，应用进程的每一次写操作，都会把数据写到用户空间的缓冲区内，再由CPU将数据拷贝到系统内核的缓冲区中，之后再由DMA将这份数据拷贝到网卡中，最后由网卡发送出去，这样一次写操作数据需要拷贝两次，而数据读操作也是类似的流程。 应用进程的一次完整的写操作，都需要在用户空间和内核空间中来回拷贝，并且每一次拷贝，都需要CPU进行一次上下文切换。<br>网络数据读写操作示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520101053670.png" alt="image-20240520101053670"></p><p>所谓零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，之后再通过DMA将内核中的数据拷贝到网卡，或者将网卡中的数据拷贝到内核。<br>零拷贝的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520101200527.png" alt="image-20240520101200527"></p><p><strong>零拷贝有哪些实现方式？</strong></p><blockquote><p>零拷贝有两种方式：</p><ol><li><p>mmmap+write</p></li><li><p>sendfile</p></li></ol></blockquote><h3 id="05-动态代理：面向接口编程，屏蔽RPC处理流程">05 | 动态代理：面向接口编程，屏蔽RPC处理流程</h3><p>在Java中，动态代理是一种设计模式，它允许开发者在运行时创造和使用代理对象。这个代理对象可以用来拦截对其他对象的方法调用，添加额外的处理，然后将调用转发给实际的对象。这种机制在很多场景下都非常有用，例如添加日志、权限检查、事务处理等。</p><p><strong>RPC和动态代理有什么关系？</strong></p><blockquote><p>当我们使用RPC时，我们一般会先找到服务提供方要接口，然后将接口依赖配置到项目中，我们在编写业务逻辑时，当需要调用提供方接口时，我们只需要通过依赖注入的方式把接口注入到项目中，然后再代码里面直接调用接口的方法。 但是我们的代码中，接口并没有包含真实的业务逻辑，相关的业务逻辑代码是在服务提供方应用汇总，但是我们只是调用了接口方法，就正常执行了业务逻辑，这是就是动态代理帮助我们实现的。 总的来说，RPC会自动给接口生成一个代理类，当我们在项目中注入接口时，运行过程中实际绑定的是这个接口生成的代理类，这样接口方法被调用的时候，它实际上是被代理类拦截到了，这样我们就可以在代理类中，加入远程调用逻辑。</p></blockquote><p><strong>在Java中，有哪些技术可以实现动态代理？</strong></p><ul><li>JDK提供的InvocationHandler</li><li>Javassist</li><li>Byte Buddy</li></ul><p>上述三个工具的区别在于通过什么方式生成代理类以及在生成的代理类中怎么完成方法调用。</p><p><strong>动态代理技术选型需要考虑什么因素？</strong></p><ul><li>生成代理类的速度、字节码大小。</li><li>生成的代理类的执行效率。</li><li>是否易用，API设计是否好理解、社区活跃度、依赖复杂度。</li></ul><p><strong>如果没有动态代理帮我们完成方法调用拦截，我们应该怎样完成RPC调用？</strong></p><p>如果没有动态代理，那么我们需要使用静态代理来实现，需要对原始类中所有的方法都实现一遍，并且为每个方法附加相似的代码逻辑。</p><h3 id="06-RPC实战：剖析gRPC源码，动手实现一个完整的RPC">06 | RPC实战：剖析gRPC源码，动手实现一个完整的RPC</h3><p>我们通过动态代理技术，屏蔽RPC调用的细节，从而让使用者能够面向接口编程。</p><p><strong>什么是gRPC？</strong></p><blockquote><p>gRPC是由Google开发并且开源的一款高性能、跨语言的RPC框架，当前支持C、Java和Go语言，当前Java版本最新Release版是1.51.3。</p></blockquote><p><strong>什么是protobuf？</strong></p><blockquote><p>protocol buffers是一种语言无关、平台无关、可扩展的序列化结构数据方法，可用于通信协议、数据存储等。 我们可以定义数据结构，然后使用特殊生成的源代码在各种数据流中使用各种语言进行编写和读取数据结构，也可以更新数据结构。</p></blockquote><p>protobuf的三大特点：</p><ol><li><p>语言无关，平台无关</p></li><li><p>灵活、高效</p></li><li><p>扩展性、兼容性好</p></li></ol><p>下面我们来看一下如何使用gRPC。</p><p>首先我们需要安装protobuf，如果你使用Mac电脑，那么可以运行下面的命令来安装protobuf。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><p>执行成功后，可以运行下面的命令来查看相关版本信息。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.21.9</span><br></pre></td></tr></table></figure><p>然后我们来创建下面的proto文件hello.proto。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_generic_services = true;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;</span><br><span class="line"></span><br><span class="line">// The greeting service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The request message containing the user&#x27;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用下面的命令来自动生成Java代码文件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc ./hello.proto --java_out=./</span><br></pre></td></tr></table></figure><p>命令执行完成后，会在当前目录下，生成代码文件，对应的目录结构如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tree .</span><br><span class="line">.</span><br><span class="line">├── hello.proto</span><br><span class="line">└── io</span><br><span class="line">    └── grpc</span><br><span class="line">        └── examples</span><br><span class="line">            └── helloworld</span><br><span class="line">                ├── Greeter.java</span><br><span class="line">                ├── Hello.java</span><br><span class="line">                ├── HelloReply.java</span><br><span class="line">                ├── HelloReplyOrBuilder.java</span><br><span class="line">                ├── HelloRequest.java</span><br><span class="line">                └── HelloRequestOrBuilder.java</span><br></pre></td></tr></table></figure><p>上面就完成了proto文件转换的过程。</p><p>接下来，我们看怎么在Java工程中完整的使用gRPC。</p><p>我们创建一个空的Maven工程，在pom.xml中引用必要的依赖以及protobuf Maven插件， 完整的pom.xml内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;sample.grpc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;grpc-sample&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;grpc.version&gt;1.52.1&lt;/grpc.version&gt;</span><br><span class="line">        &lt;protobuf.version&gt;3.21.9&lt;/protobuf.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.29.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.29.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.29.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;annotations-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.0.53&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;extensions&gt;</span><br><span class="line">            &lt;extension&gt;</span><br><span class="line">                &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">            &lt;/extension&gt;</span><br><span class="line">        &lt;/extensions&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;0.6.1&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;protocArtifact&gt;com.google.protobuf:protoc:3.11.0:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">                    &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">                    &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.29.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>然后将上面的hello.proto文件复制到src/main/proto目录下面创建hello.proto目录下， 这个目录是固定的。</p><p>pom.xml文件准备好以后，我们来运行下面的工程编译命令。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven compile</span><br></pre></td></tr></table></figure><p>编译结束后，会在target/generated-sources目录下维护自动生成的代码，目录结构如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree target/generated-sources</span><br><span class="line">target/generated-sources</span><br><span class="line">└── protobuf</span><br><span class="line">    ├── grpc-java</span><br><span class="line">    │   └── io</span><br><span class="line">    │       └── grpc</span><br><span class="line">    │           └── examples</span><br><span class="line">    │               └── helloworld</span><br><span class="line">    │                   └── GreeterGrpc.java</span><br><span class="line">    └── java</span><br><span class="line">        └── io</span><br><span class="line">            └── grpc</span><br><span class="line">                └── examples</span><br><span class="line">                    └── helloworld</span><br><span class="line">                        ├── Greeter.java</span><br><span class="line">                        ├── Hello.java</span><br><span class="line">                        ├── HelloReply.java</span><br><span class="line">                        ├── HelloReplyOrBuilder.java</span><br><span class="line">                        ├── HelloRequest.java</span><br><span class="line">                        └── HelloRequestOrBuilder.java</span><br><span class="line"></span><br><span class="line">11 directories, 7 files</span><br></pre></td></tr></table></figure><p>接下来，我们来编写服务器端，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.grpc.examples.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">                System.err.println(<span class="string">&quot;*** shutting down gRPC server since JVM is shutting down&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    HelloWorldServer.<span class="built_in">this</span>.stop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace(System.err);</span><br><span class="line">                &#125;</span><br><span class="line">                System.err.println(<span class="string">&quot;*** server shut down&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            server.shutdown().awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Await termination on the main thread since the grpc library uses daemon threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main launches the server from the command line.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">HelloWorldServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GreeterImpl</span> <span class="keyword">extends</span> <span class="title class_">GreeterGrpc</span>.GreeterImplBase &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">            <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder().setMessage(<span class="string">&quot;Hello &quot;</span> + req.getName()).build();</span><br><span class="line">            System.out.println(<span class="string">&quot;=====server=====&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;server: Hello &quot;</span> + req.getName());</span><br><span class="line">            responseObserver.onNext(reply);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完成后，直接运行，这样会启动一个Server，端口是50051。</p><p>最后，我们来编写客户端，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.grpc.examples.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Channel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.StatusRuntimeException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Construct client for accessing HelloWorld server using the existing channel. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorldClient</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Say hello to server. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">        HelloReply response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = blockingStub.sayHello(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Greeting: &quot;</span> + response.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;hahahahaha&quot;</span>;</span><br><span class="line">        <span class="comment">// Access a service running on the local machine on port 50051</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;localhost:50051&quot;</span>;</span><br><span class="line">        <span class="comment">// Allow passing in the user and target strings as command line arguments</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;--help&quot;</span>.equals(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Usage: [name [target]]&quot;</span>);</span><br><span class="line">                System.err.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.err.println(<span class="string">&quot;  name    The name you wish to be greeted by. Defaults to &quot;</span> + user);</span><br><span class="line">                System.err.println(<span class="string">&quot;  target  The server to connect to. Defaults to &quot;</span> + target);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            user = args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            target = args[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ManagedChannelBuilder.forTarget(target)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HelloWorldClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldClient</span>(channel);</span><br><span class="line">            client.greet(user);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            channel.shutdownNow().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们多次运行客户端程序后，我们可以在服务器端的控制台上，看到如下输出。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====server=====</span><br><span class="line">server: Hello hahahahah</span><br><span class="line">=====server=====</span><br><span class="line">server: Hello hahahahah</span><br><span class="line">=====server=====</span><br><span class="line">server: Hello hahahahah</span><br></pre></td></tr></table></figure><h3 id="07-架构设计：设计一个灵活的RPC框架">07 | 架构设计：设计一个灵活的RPC框架</h3><p>RPC就是把拦截到的方法参数，转成可以在网络中传输的二进制，并保证在服务提供方能正确地还原出语义，最终实现像调用本地一样地调用远程的目的。</p><p>RPC的本质是一个远程调用，需要通过网络来传输数据，我们一般采用TCP协议作为数据通信协议，为了屏蔽网络传输的复杂性，我们需要封装一个独立的数据传输模块来收发二进制数据，这个模块被称为<strong>传输模块</strong>。</p><p>我们在调用方法时，方法的出入参数都是对象数据，我们需要将对象转换成二进制，即进行序列化操作，同时，我们还需要在方法调用参数的二进制数据后面增加“断句”符号来分隔出不同的请求，这个过程被称为<strong>协议封装</strong>。</p><p>传输模块和协议封装都是为了保证数据在网络中可以正确传输，我们将这两个模块放在一起，称为<strong>协议模块</strong>。</p><p>我们还可以在协议模块中添加压缩功能，在方法调用参数或者返回值的二进制数据大于某个阈值时，我们使用压缩框架对数据进行无损压缩，然后再另外一段使用同样的压缩机制进行解压处理，保证数据可以还原。</p><p>传输模块和协议模块是RPC中最基础的功能，它们使得对象可以正确的传输到服务提供方。但是为了让这两个模块可以同时工作，我们还需要手写一些粘合代码，这些代码对于RPC框架的使用者来说是没有意义的，属于重复工作，我们将这些事情进行封装处理，形成RPC调用的入口，一般称为<strong>Bootstrap模块</strong>。</p><p><strong>什么是”服务发现“？</strong></p><blockquote><p>针对同一个接口有多个服务提供者，但这多个服务提供者对于我们的调用方来说是透明的，所以在RPC里面我们还需要给调用方找到所有的服务提供方，并需要在RPC里面维护好借口和服务提供者地址间的关系，这样调用方在发起请求时才能快速找到对应的接收地址。</p></blockquote><p>一个划分为四层的RPC基础架构的示意图如下。</p><p>上面的框架有什么问题吗？最主要的问题就是扩展性不高，当我们有需求变更时，很容易需要大范围调整框架。</p><p>我们可以尝试使用<strong>插件化架构</strong>的方法论来优化我们的RPC架构。</p><p><strong>我们怎么在RPC框架里面支持插件化架构？</strong></p><blockquote><p>我们可以将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的借口与功能的实现分离，并提供接口的默认实现。</p></blockquote><p>加入插件功能后，RPC框架就包含了两大核心体系：<strong>核心功能体系</strong>和<strong>插件体系</strong>，示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520101947432.png" alt="image-20240520101947432"></p><h3 id="08-服务发现：到底是要CP还是AP？">08 | 服务发现：到底是要CP还是AP？</h3><p><strong>我们为什么需要“服务发现”？</strong></p><blockquote><p>从高可用的角度出发，在生产环境中，服务提供方通常会以集群的方式对外提供服务，集群中的IP地址随时可能发生变化，因此我们需要一本“通讯录”来及时获取对应的服务节点信息，维护“通讯录”以及或者节点信息的过程，我们称之为“服务发现”。</p></blockquote><p>服务发现包括2个核心模块：</p><ul><li>服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心中，注册中心将这个服务节点的IP和接口保存下来。</li><li>服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的IP，然后缓存到本地，并用于后续远程调用。</li></ul><p><strong>我们为什么不采用基于DNS的服务发现机制？</strong></p><p>我们来看一下DNS查询流程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103411280.png" alt="image-20240520103411280"></p><p>它存在的两个主要问题：</p><ol><li>如果服务节点的IP端口下线了，服务调用者能否及时摘除服务节点？</li><li>如果之前已经上线了一部分服务节点，这时突然对这个服务进行扩容，那么新上线的服务节点能否及时接收到流程呢？</li></ol><p><strong>为什么VIP方案也不能用于服务发现？</strong> VIP方案如下所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103437431.png" alt="image-20240520103437431"></p><p>它主要有以下几个问题：</p><ul><li>搭建负载均衡设备或者TCP/IP四层代理，需要额外成本。</li><li>请求流程都经过负载均衡设备，多经过一次网络传输，会额外浪费性能。</li><li>负载均衡添加节点和摘除节点，一般都需要手动添加，当大批量扩容和下线时，会有大量的人工操作和生效延迟。</li><li>不能支持更灵活的负载均衡策略。</li></ul><p><strong>基于ZooKeeper的服务发现机制的工作流程是怎样的？</strong> 基于ZooKeeper的服务发现结构图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103453805.png" alt="image-20240520103453805"></p><p>它的工作流程如下：</p><ol><li>服务平台管理端现在ZooKeeper中创建一个服务根路径，在这个路径下面再创建服务提供方目录和服务调用方目录。</li><li>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</li><li>当服务调用方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</li><li>当服务提供方目录下有节点数据发生变更时，ZooKeeper就会通知给发起订阅的服务调用方。</li></ol><p><strong>基于ZooKeeper的服务发现有什么问题？</strong></p><p>当有超大批量的服务节点在同时发起注册操作，ZooKeeper集群的CPU使用率会飙升，导致ZooKeeper集群无法工作。</p><p>这本身就是ZooKeeper的性能问题，当连接到ZooKeeper的节点数量特别多，对ZooKeeper的读写操作会特别频繁，而且当ZooKeeper存储的目录达到一定数量时，ZooKeeper就会变得不稳定，CPU使用率持续升高，直到宕机。</p><p>ZooKeeper的一大特点就是强一致性，集群中的每个节点的数据每次发生变更操作时，都会通知其他节点同时执行跟新，这样它就要求每个节点的数据能够实时的完全一致，从而导致了ZooKeeper集群性能的下降。</p><p><strong>基于消息总线的服务发现机制的工作流程是怎样的？</strong></p><p>基于消息总线的服务发现流程图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103501069.png" alt="image-20240520103501069"></p><p>它的工作流程如下：</p><ol><li>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有一个整体递增版本。</li><li>消息总线会主动推送消息到各个注册中心，同时注册中心也会定期拉取消息。对于获取到消息的在消息回放模块里面回放只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。</li><li>消费者定于可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存中。</li><li>采取推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的混存数据进行合并。</li></ol><p>通过消息总线的方式，我们就可以完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作。</p><p><strong>服务发现的特性是允许我们在设计超大规模集群服务发现系统的时候，舍弃一致性，更多的考虑系统的健壮性，因此，在实际工作中，最终一致性是更为常用的策略。</strong></p><h3 id="09-健康监测：这个节点挂了，为啥还要疯狂发请求？">09 | 健康监测：这个节点挂了，为啥还要疯狂发请求？</h3><p>服务调用方在每次调用服务提供方的服务时，RPC框架会根据路由和负载均衡算法选择一个具体的IP地址，为了保证请求成功，我们需要确保每次选择出来的IP对应的连接是健康的。</p><p>调用方和集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏的情况，为了解决这个问题，我们的终极解决方案就是让调用方实时感知到节点的变化。</p><p>业内经常用来检测服务节点是否可用的方法是用心跳机制。心跳机制就是服务调用方每隔一段时间就问一下服务提供方，“兄弟，你还好吗？”，然后服务提供方诚实地告诉调用方它目前的状态。</p><p>服务提供方的状态一般会有三种情况：</p><ol><li>健康状态：建立连接成功，并且心跳探活也一直成功。</li><li>亚健康状态：建立连接成功，但是心跳请求连续失败。</li><li>死亡状态：建立连接失败。</li></ol><p>上述三种状态是可以变转变的。</p><p>一个节点从健康状态过渡到亚健康状态的前提是连续“心跳失次数必须达到某个阈值。</p><p>只关心服务节点网络稳定，会有2个问题：</p><ol><li>调用方每个接口的调用频次不一样，有的接口可能1秒内调用上百次，有的接口可能半个小时才会被调用一次，所以我们不能简单的把失败总次数当做判断条件。</li><li>服务的借口响应时间也不一样，有的接口可能1ms，有的可能是10s，我们不能使用TPS来作为谈判条件。</li></ol><p>我们可以使用”可用率“，它的计算方式是某一个时间窗口内接口调用的成功次数的百分比。当可用率低于某个比例就认为这个节点存在问题，需要把它转移到亚健康列表，这样既考虑了高低频的调用接口，也兼顾了接口响应时间不同的问题。</p><p>我们在部署时，需要注意将检测程序部署到多个机器里面，分布在不同的机架，甚至不同的机房。</p><h3 id="10-路由策略：怎么让请求按照设计的规则发到不同的节点上？">10 | 路由策略：怎么让请求按照设计的规则发到不同的节点上？</h3><p>我们在真实的环境中，服务提供方是以集群的方式对外提供服务，这对于服务调用方来说，就是一个借口会有多个服务提供方同时提供服务，所以RCP在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发送请求。</p><p>当服务在线上运行时，我们如果有变更，会涉及到如何升级，升级过程中可能会影响服务接口，这样会导致系统变的不稳定，甚至系统崩溃，为了减少这种风向，我们一般会选择<strong>灰度发布</strong>的方式来升级我们的服务实例，例如我们可以发布少量实例来观察是否有异常，然后根据观察的结果，来决定是发布更多实例还是回滚到旧版本。</p><p>虽然我们的服务在上线前会有测试的过程，但是因为线上环境太复杂了，测试只能是降低出现风险的概率，想要彻底验证所有场景是不可能的。</p><p>我们可以考虑在上线完成后，先让一小部分调用方请求过来进行逻辑验证，待没有问题后再接入其他调用方，从而实现流量隔离的效果。</p><p>因为注册中心会维护所有服务提供方的信息，所以我们可以在注册中心中来做流量隔离吗？一般不采用这种方式，注册中心在RPC中的定位是用来存储数据并保证数据一致性，如果把复杂的请求隔离的计算逻辑放到注册中心里面，那么当集群节点变多时，会导致注册中心压力过大，而且大部分时候，我们采用开源软件来打架注册中心，要加入其他计算逻辑的话，还需要进行二次开发，所以从实际的角度出发，在注册中心中实现请求隔离是不划算的。</p><p>调用法发起RPC调用的整个流程中，在RPC发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（也就是负载均衡），那么我们可以考虑在这个节点之前，加入一个“筛选逻辑”，把符合我们要求的节点筛选出来。</p><p>这个“筛选过程”，我们称之为“<strong>路由策略</strong>”。</p><p>我们可以设计不同得分路由策略：</p><ol><li><strong>IP路由</strong>*，根据服务调用方的IP地址，来决定哪些服务提供方的实例可以处理相关请求。*</li><li><strong>参数路由</strong>，根据服务调用方发送请求中的参数值，来决定哪些服务提供方的实例可以处理相关请求。</li></ol><p>参数路由是比IP路由更灵活、粒度更细的路由规则，它为服务提供方应用提供了另外一个服务治理的手段。</p><p>灰度发布功能是RPC路由功能的一个典型应用场景，通过RPC的路由策略的组合使用可以让服务提供方更加灵活的管理、调用自己的流量，进一步降低可能导致的风险。</p><p>在RPC里面，不论是哪种路由策略，其核心思想是一样的，就是让请求按照我们设定的规则发送到目标节点上，从而实现流量隔离的效果。</p><h3 id="11-负载均衡：节点负载差距这么大，为什么收到的流量还一样？">11 | 负载均衡：节点负载差距这么大，为什么收到的流量还一样？</h3><p><strong>什么是负载均衡？</strong></p><blockquote><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共通分担请求压力的目的。</p></blockquote><p><strong>负载均衡有哪些类型？</strong></p><blockquote><p>负载均衡分为软负载和硬负载两种，软负载就是在一台或多台服务器上安装负载均衡软件，如LVS、Nginx等；硬负载就是通过硬件设备来实现负载均衡，例如F5服务器等。</p></blockquote><p><strong>有哪些常见的负载均衡算法？</strong> 常见的负载均衡算法包括：</p><ul><li>基于权重的随机算法</li><li>基于最小活跃用数算法</li><li>基于Hash一致性算法</li><li>基于加权轮询算法</li></ul><p>Dubbo默认采用基于权重的随机算法。</p><p>RPC中的负载均衡完全由RPC框架自身实现，RPC的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起RPC调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起RPC调用请求。</p><p>示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520104220344.png" alt="image-20240520104220344"></p><p>RPC的负载均衡策略一般包括随机权重、Hash、轮询等。</p><p><strong>如何设计一个自适应的负载均衡？</strong></p><p>所谓自适应的负载均衡，就是指负载均衡组件可以根据服务节点的可处理能力，动态调整服务节点的权重，将请求转发给合适的服务节点，从而保证整个系统的稳定性。</p><p>我们可以采用一种打分策略，服务调用者收集与之建立长连接的每个服务节点的指标数据，例如服务节点的负载指标、CPU核数、内存大小、请求处理的平均耗时、服务节点的健康状态等。我们可以为这些指标设置不同的权重，之后就可以计算每个服务节点动态分值。</p><p>在得到服务节点的动态分值后，我们把分值作为服务节点的权重，采用随机权重的负载均衡策略去分发请求，这样我们就可以完成一个自适应的负载均衡。</p><p>关键步骤如下：</p><ol><li>添加服务指标收集器，并将其作为插件，默认有运行时状态指标收集器、请求耗时指标收集器。</li><li>运行时状态指标收集器收集服务节点CPU核数、CPU负载以及内存等指标，在服务调用者与服务提供者的心跳数据中获取。</li><li>请求耗时指标收集器收集请求耗时数据，如平均耗时、TP99、TP999等。</li><li>可以配置开启哪些指标收集器，并设置这些参考指标的指标权重，再根据指标数据和指标权重来综合打分。</li><li>通过服务节点的综合打分与节点的权重，最终计算出节点的最终权重，之后服务调用者会根据随机权重的策略，来选择服务节点。</li></ol><h3 id="12-异常重试：在约定的时间内安全可靠地重试">12 | 异常重试：在约定的时间内安全可靠地重试</h3><p><strong>什么是RPC框架的重试机制？</strong></p><blockquote><p>当调用端发起的请求失败时，RPC框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。 调用端发起RPC请求时，会经过负载均衡，选择一个节点，之后它会向这个节点发送请求信息。当消息发送失败或收到异常消息时，我们就可以捕获异常，根据异常触发重试，重新通过负载均衡选择一个节点发送请求信息，并且记录请求的重试次数，当重试次数达到用户配置的重试次数时，就返回给调用端动态代理一个失败异常。</p></blockquote><p><strong>如何在约定的时间内安全可靠的重试？</strong></p><p>首先，服务的业务逻辑需要是幂等的，这是我们可以重试的前提。</p><p>其次，在每次重试后，都需要重置一下请求的超时时间，因为连续的异常重试可能会导致请求处理时间过长造成超时。</p><p>再次，当我们发起服务重试时，负载均衡选择节点时，需要去掉重试之前出现过问题的节点，这样可以提高重试的成功率。</p><p>最后，我们可以在RPC框架中配置业务异常相关的白名单，这样当白名单中的业务异常类型被触发时，也可以进行服务重试。</p><h3 id="13-优雅关闭：如何避免服务停机带来的业务损失？">13 | 优雅关闭：如何避免服务停机带来的业务损失？</h3><p>我们在RPC架构下，需要考虑当服务重启时，如何做到让调用方系统不出问题。</p><p>当服务提供方要上线时，一般是通过部署系统完成实例重启，在这个过程汇总，服务提供方不会事先告诉调用方哪些实例会被重启，从而让调用方切换流量。而对调用方来说，它也无法预测服务提供方哪些实例会重启，因此负载均衡还是有可能降正在重启的实例挑选出来，这样导致请求被分发到正在重启的服务实例中，造成调用方无法拿到正确的响应结果。</p><p>在服务重启的时候，对于调用方来说，有以下2种情况：</p><ol><li>调用方发请求前，目标服务已经下线。对于调用方来说，跟目标节点的连接会断开，这时调用可以立刻感知到，并在其健康列表中将该实例删除，这样就不会被负载均衡选中。</li><li>调用方发请求时，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接没有断开，所以这个节点还会存在健康列表里面，有可能会被负载均衡选中。</li></ol><p><strong>我们可以通过服务发现来实时通知服务调用方关于服务提供方是否可用吗？</strong></p><p>不可以。这样做的话，整个过程会依赖两次RPC调用：一次是服务提供方通知注册中心下线操作，一次是注册中心通知服务调用方下线节点操作。注册中心通知服务调用方都是异步的，服务发现只保证最终一致性，并不保证实时性，所以当注册中心收到服务提供方下线的时候，并不能保证把这次要下线的节点推送给所有调用方，这样，调用方还是有可能将请求发送给错误的服务提供方节点。</p><p><strong>如何做到优雅关闭服务？</strong></p><p>我们可以尝试让服务提供方来通知调用方，RPC里面调用方和提供方之间是长连接，我们可以在提供方应用内存中维护一份调用方连接集合，当服务关闭时，挨个通知调用方去下线相关实例，这样整个调用链路就变短了，对于每个调用方来说只一次RPC，可以确保调用的成功率很高。</p><p>但是上述方法不能彻底解决问题，因为有时出问题请求的时间点和收到提供方关闭通知的时间点很接近，再加上网络延迟，还是有可能在服务提供方关闭服务后再接收到新的请求。</p><p>解决办法是我们在关闭的时候，在服务提供方设置一个请求“挡板”，它的作用是告诉调用方，我已经进入关闭流程，不能再处理新的请求了。</p><p>当服务提供方正在关闭，如果在之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（ShutdownException），这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，没有处理这个请求”，然后调用方收到这个异常响应后，RPC框架就把这个节点从健康列表中挪出，并把请求自动重试到其他节点，因为这个请求没有被服务提供方处理过，所以可以安全的重试到其他节点，这样可以实现对业务无损。</p><p>我们还可以加上主动通知流程，让服务提供方给相关调用方发送关闭通知，这样既可以保证实时性，也可以避免通知失败的情况。</p><p>在Java语言中，我们可以使用Runtime.addShudownHook方法，来注册关闭的钩子，在RPC启动的时候，我们提前去注册关闭钩子，并在里面添加连个处理程序：一个复杂开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时我们需要再调用链里面加上挡板处理器，当新的请求进来时，会判断关闭标识，如果正在关闭，就抛出特定异常。</p><p>对于关闭过程中还在处理的请求，我们可以根据引用计数器，等待正在处理的请求全部结束后再真正关闭服务，同时还可以设置一个超时控制，当超过指定时间，请求还没有处理完，就强制退出应用。</p><p>总结一下，关于如何优雅关闭服务，包括以下步骤：</p><ol><li>开启关闭挡板，拒绝新的请求</li><li>利用引用计数器确保正在执行的请求处理完</li><li>设置超时时间，保证服务可以正常关闭</li><li>执行关闭时，服务提供方通知服务调用方下线相关节点</li></ol><p>服务优雅关闭的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520105158413.png" alt="image-20240520105158413"></p><p>“优雅关闭”的概念除了在RPC里面，在其他很多框架中也很常见，例如Tomcat在关闭的时候，也是先从外层到里层逐层进行关闭，先保证不接收新的请求，然后再处理关闭前收到的请求。</p><h3 id="14-优雅启动：如何避免流量达到没有启动完成的节点？">14 | 优雅启动：如何避免流量达到没有启动完成的节点？</h3><p><strong>为什么Java程序运行一段时间会执行速度会变快？</strong></p><blockquote><p>这是因为在Java里面，在运行过程中，JVM虚拟机会把高频的代码编译成机器码，被加载过的类也会被缓存到JVM缓存中，再次使用的时候就不会触发临时加载，这样就使得 “热点”代码的执行不用每次都通过解释，从而提升执行速度。</p></blockquote><p><strong>什么是启动预热？</strong></p><blockquote><p>启动预热就是让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。</p></blockquote><p>服务调用方应用通过服务发现能够取得服务提供方的IP地址，然后每次发送请求前，都需要通过负载均衡算法从连接池中选择一个可用连接，我们可以让负载均衡在选择连接的时候，区分一下是不是刚启动的应用，如果是刚启动的应用，我们可以调低它的权重值，这样它被选中的概率会很低，随着时间推移，我们逐渐增大它的权重值，从而实现一个动态增加流量的效果。</p><p>我们如何获取服务提供方应用的启动时间？有两种方法：</p><ol><li>服务提供方在启动的时候，把自己启动的时间告诉注册中心。</li><li>注册中心收到的服务提供方请求注册的时间。</li></ol><p>启动越热更多是从调用方的角度出发，去解决服务提供方应用冷启动的问题，让调用方的请求量通过一个时间窗口过渡，慢慢达到一个正常的水平，从而实现平滑上线。</p><p>从服务提供方的角度来说，有什么优化方案吗？服务提供方可以使用<strong>延迟暴露</strong>的方法来优化热启动过程。</p><p><strong>问题</strong>：服务提供方应用在没有完成启动的时候，调用方的请求就过来了，而调用方请求过来的原因，在于服务提供方应用启动过程中把解析到的RPC服务注册到了注册中心，这就导致了后续加载没有完成的情况下，服务提供方地址就被服务调用方感知到了。</p><p><strong>解决办法</strong>：我们在应用启动加载、解析Bean的时候，如果遇到了RPC服务的Bean，只先把这个Bean注册到Spring-BeanFactory里面，而不把这个Bean对应的接口注册到注册中心，只有等应用启动完成后，才被接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。</p><p>我们还可以利用服务启动完成到注册到注册中心的那段时间，预留一个Hook，让用户可以扩展Hook逻辑，在Hook里面模拟业务调用逻辑，从而使得JVM指令能够预热起来，同时还可以在Hook中预先加载一些资源，只有等所有缓存和资源都加载完成后，才把接口注册到注册中心，这样也就完成了热启动整个流程。</p><p><strong>如果我们有大批量的服务都需要重启，如何避免同时重启造成请求被分发到新启动的应用实例而造成超时错误？</strong></p><p>我们可以采取一些措施：</p><ol><li>分时分批启动，就像灰度发布一样。</li><li>根据重启比例来设置重启服务的权重。</li><li>在请求低峰重启应用。</li><li>在重启过程中，如有必要，对服务进行限流处理。</li></ol><p>启动预热通常是指在应用启动时预先加载一些数据或执行一些操作，以提高后续使用时的性能。在很多系统或应用中，启动预热是一个常见的优化手段。</p><p>具体来说，启动预热可能包括以下一些操作：</p><ol><li>预加载数据：应用在启动时从数据库或其他数据源加载一些常用数据到内存中。这样，当这些数据被使用时，应用可以直接从内存中读取，而不需要进行磁盘I/O或网络请求，提高了性能。</li><li>预建立连接：例如，数据库连接、网络连接等。这样，当需要使用这些连接时，就不需要等待连接建立的时间。</li><li>预编译代码：例如，一些解释型语言的虚拟机会在启动时预先编译一些经常使用的代码，以提高运行速度。</li><li>预热缓存：例如，将一些经常访问的数据预先加载到缓存中，以提高后续访问的速度。</li></ol><p>需要注意的是，启动预热虽然可以提高后续使用的性能，但是也会使得应用的启动时间变长。因此，需要在启动时间和运行性能之间做好平衡。</p><h3 id="15-熔断限流：业务如何实现自我保护？">15 | 熔断限流：业务如何实现自我保护？</h3><p><strong>为什么我们的服务需要自我保护？</strong></p><blockquote><p>RPC是解决分布式系统通信问题的一大利器，它会面临高并发的场景，这意味着我们提供服务的每个服务节点都有可能由于访问量过大而引起一系列的问题，例如业务处理耗时过长、CPU利用率过高、频繁Full GC以及服务进程直接宕机等，在生产环境中，我们要保证服务的稳定性和高可用性，这就需要业务进行自我保护，从而在高访问量、高并发的场景下，应用系统依然稳定，服务依然高可用。</p></blockquote><p><strong>使用RPC时，业务如何实现自我保护？</strong></p><p>可以在服务提供方做<strong>限流</strong>操作，在服务调用方做<strong>熔断</strong>操作。</p><p>熔断是调用方为了避免在调用过程中，服务提供方出现问题的时候，自身资源被耗尽的一种保护行为，而限流则是服务提供方为防止自己被突发流量打垮的一种保护行为。</p><p><strong>熔断和限流有什么区别？</strong></p><p>熔断主要在服务调用方进行设置，限流主要在服务提供方进行设置。</p><p><strong>服务端如何实现限流逻辑？</strong></p><blockquote><p>方式有很多，包括计数器、滑动窗口、漏斗算法和令牌桶算法等，其中令牌桶算法最常用。</p></blockquote><p>我们发布服务后，提供给多个应用的调用方去调用，这时有一个应用的调用方发送过来的请求流量要比其他的应用大很多，这时我们就应该对这个应用下的调用端发送过来的请求流量进行限流。所以我们在限流时，需要考虑应用级别的维度，甚至是IP级别的维度，这样做不仅可以让我们对一个应用下的调用端发送过来的请求流量做限流，还可以对一个IP发送过来的请求流量做限流。</p><p><strong>在服务端实现限流，配置的限流阈值是作用在每个服务节点上的。</strong></p><p>我们还可以提供一个专门的限流服务，让每个节点都依赖一个限流服务，当请求流量打过来时，服务节点触发限流逻辑，调用这个限流服务来判断是否到达了限流阈值。我们甚至可以将限流逻辑放在调用端，调用端在发出请求时先触发限流逻辑，调用限流服务，如果请求量已经到达了限流阈值，请求都不需要发出去，直接返回给动态代理一个限流异常即可。</p><p>在一个服务作为调用端去调用另外一个服务时，为了防止被调用的服务出现问题而影响到座位调用端的这个服务，那么服务调用端也需要进行自我保护，而最有效的自我保护方式就是<strong>熔断</strong>。</p><p><strong>熔断器的工作原理是怎样的？</strong></p><p>熔断器的工作机制主要是关闭、打开和半打开这三个状态之间的切换。在正常情况下，熔断器是关闭的，当调用端调用下游服务出现异常时，熔断器会收集异常指标信息进行计算，当达到熔断条件时熔断器打开，这时调用端再发起请求是会直接被熔断器拦截，并快速地执行失败逻辑，当熔断器打开一段时间后，会转为半打开状态，这时熔断器允许调用端发送一个请求给服务端，如果这次请求能够正常地得到服务端的响应，则将状态置为关闭状态，否则设置为打开。</p><p><strong>熔断器放在哪里比较合适？</strong></p><blockquote><p>建议放在调用方的动态代理模块，因为这时RPC调用的第一个关口，在发出请求时先经过熔断器，如果状态是闭合则正常发出请求，如果状态是打开则执行熔断器的失败策略。</p></blockquote><h3 id="16-业务分组：如何隔离流量？">16 | 业务分组：如何隔离流量？</h3><p>关于为什么要对请求流量进行分组，作者举了一个非常合适的例子：</p><blockquote><p>在没有汽车的年代，我们的道路很简单，就一条，行人、洋车都在上边走。随着汽车的普及以及猛增，我们的道路越来越宽，慢慢地有了高速、辅路、人行道等。很显然，交通网的建设和完善不仅提高了我们的出行效率，而且还更好的保障了我们行人的安全。</p></blockquote><p>对服务进行分组，并没有一个明确的可衡量的标准，但是一般建议非核心应用不要跟核心应用分在同一个组，核心应用之间应该做好隔离，一个重要的原则就是保障核心应用不受影响。</p><p>通过分组的方式隔离调用方的流量，从而避免因为一个调用方出现流量激增而影响其他调用方的可用率。</p><p>服务分组隔离后，单个调用方在发RPC请求时可以选择的服务节点数相比之前是减少了，那么对于单个调用方来说，出错的概率就增加了。</p><p>要解决这个问题，我们还需要把配置的分组区分主次分组，只有在主分组上的节点都不可用的情况下才去选择次分组节点，只要主分组里面的节点恢复正常，我们就必须把流量都切换到主节点上。整个切换过程对于应用层完全透明，从而在一定程度上保证了服务调用方应用高可用。</p><p>我们不仅可以通过分组把服务提供方划分成不同规模的小集群，我们还可以利用分组完成一个接口多种实现的功能。正常情况下，为了方便我们自己管理服务，一般会建议每个接口完成的功能尽量保证唯一。但在有些特殊场景下，两个接口也会完全一样，只是具体实现上有所差别，那么我们就可以在服务提供方应用里面同时暴露两个相同接口，但是接口分组不一样。</p><p><strong>在实际工作中，测试人员和开发人员的工作一般都是并行的，这就导致一个问题经常出现：开发人员在开发过程中可能需要启动自身的应用，而测试人员为了能验证功能，会在测试环境中部署同样的应用。如果开发人员和测试人员用的接口分组名刚好一样，在这种情况下，就可能会干扰其它正在联调的调用方进行功能验证，进而影响整体的工作效率。有什么解决办法？</strong></p><p>解决这个问题，有几种思路：</p><ol><li>不同团队使用不同的服务注册中心来管理服务节点。</li><li>可以采取类似于K8S中的命名空间的方法来隔离服务节点。</li><li>可以尝试流量染色，具体可以参考<a href="http://link.zhihu.com/?target=https%3A//juejin.cn/post/7087078047538479141">有关于流量染色的一些实践</a>。</li></ol><h3 id="17-异步RPC：压榨单机吞吐量">17 | 异步RPC：压榨单机吞吐量</h3><blockquote><p><strong>为什么异步可以提升吞吐量</strong></p></blockquote><p>吞吐量是一个衡量系统处理能力的重要指标，通常用于描述在单位时间内，一个系统能处理的任务数量或数据量。</p><p>异步编程是一种编程模式，它可以提高系统的吞吐量和效率。在同步编程模式中，操作是按照顺序一个接一个执行的，每个操作必须完成后，才能开始下一个操作。如果一个操作需要等待外部资源（如网络请求、文件I/O等），则整个系统需要等待这个操作完成，这样就浪费了宝贵的计算资源。</p><p>相比之下，异步编程允许操作在等待外部资源时，释放计算资源给其他的操作使用。例如，当发起一个网络请求后，系统不需要等待网络请求的回应，而可以立即开始执行其他的操作。当网络请求回应到来时，系统再回来处理这个回应。这样就使得计算资源得到了充分利用，从而提高了系统的吞吐量。</p><p>此外，异步编程还可以提高系统的响应性。在同步系统中，如果一个操作需要花费很长时间，那么用户可能需要等待这个操作完成后，才能看到响应。但是在异步系统中，这个长时间的操作可以在后台进行，而系统可以立即给用户一个响应，告诉用户操作正在进行。这样就提高了系统的响应性，提升了用户体验。</p><p>所以，异步编程可以提高系统的吞吐量和响应性，但是它也带来了更复杂的编程模型，需要更多的处理错误和状态管理的代码。因此，是否使用异步编程，应根据具体的应用场景和需求来决定。</p><hr><p>在我们知道RPC框架基础知识后，我们需要从RPC框架整体性能去考虑问题，例如怎么提升RPC框架的性能、稳定性、安全性、吞吐量，以及如何在分布式的场景下快速定位问题等。</p><p><strong>影响RPC调用吞吐量的根本原因是什么？</strong></p><p>处理RPC请求比较耗时，并且CPU大部分时间都在等待而非去计算，从而导致CPU利用率不高。RPC请求的耗时大部分是业务耗时，比如业务逻辑中有访问数据库执行慢SQL的操作，所以我们要看怎么能提升业务逻辑处理。</p><p>要提升吞吐量，关键就两个字：<strong>异步</strong>。</p><p><strong>服务调用端怎么异步？</strong> 对于调用端来说，向服务端发送请求消息与接受服务端发送过来的响应消息，这两个处理过程是两个完全独立的过程，这两个过程甚至在大多数情况下都不在一个线程中进行，也就是说，对于RPC框架，无论是同步调用还是异步调用，调用端的内部实现都是异步的。</p><p>调用端发送的每条信息都有一个唯一的消息标识，实际上调用端想服务端发送请求消息之前会创建一个Future，并会存储这个消息标识与这个Future的映射，动态代理所获得的返回值最终就是从这个Future中获取的，当收到服务端响应的消息时，调用端会根据响应消息的唯一标识，通过之前存储的映射找到对应的Future，将结果注入给那个Future，再进行一系列的处理逻辑，最后动态代理从Future中得到正确的返回值。</p><p>所谓同步调用，是指RPC框架在调用端的处理逻辑中主动执行了Future.get()方法，让动态代理等待返回值，而异步调用则是RPC框架没有主动执行这个方法，用户可以从请求上下文中得到这个Future，自己决定什么时候执行Future.get()方法。</p><p>Future模式的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520111315955.png" alt="image-20240520111315955"></p><p>RPC调用在调用方和提供方之间完全异步。</p><p>CompletableFuture是Java 8原生支持的。如果RPC框架能够支持CompletableFuture，那发布一个RPC服务，服务接口定义的返回值是CompletableFuture对象，整个调用过程会分为以下几步：</p><ol><li>服务调用方发起RPC请求，直接拿到返回值CompletableFuture对象，之后就不需要任何额外的与RPC框架相关的操作了，直接就可以进行异步处理。</li><li>在服务提供方业务逻辑中创建一个返回值CompletableFuture对象，之后服务端真正的业务逻辑完全可以在一个线程池中异步处理，业务逻辑完成之后再调用这个CompletableFuture对象的complete方法，完成异步通知。</li><li>服务调用方在收到服务提供方发送过来的响应之后，RPC框架再自动地调用服务调用方拿到的那个 返回值CompletableFuture对象的complete方法，这样一次异步调用就完成了。</li></ol><p>RPC远程方法调用，有以下几种方式：</p><ol><li>sync，默认方式，这是在“方法”内部同步，但RPC框架还是异步处理的。</li><li>future，RPC消费者得到future，自行决定何时获取返回结果。</li><li>callback，RPC调用端不需要同步处理响应结果，可以直接返回，最后返回结果将会在回调线程中异步处理。</li><li>oneway，调用端发起请求后不需要接收响应。</li></ol><h3 id="18-安全体系：如何建立可靠的安全体系？">18 | 安全体系：如何建立可靠的安全体系？</h3><p>RPC一般用于解决内部应用之间的通信，这里的“内部”是指应用都部署在同一个大局域网中，这样在RPC中，我们很少考虑像数据包篡改、请求伪造等恶意行为。</p><p>我们主要关注两种类型的安全场景：</p><ol><li>调用方之间的安全保证。</li><li>服务发现中的安全保证。</li></ol><p>我们可以引入一个授权平台，来对调用方的身份进行验证，调用方可以在授权平台上申请自己应用里面需要调用的接口，而服务方可以在授权平台上进行审批，只有服务提供方审批后，调用方才能够调用。</p><p>上面的设计方案，授权平台承担了公司内所有RPC请求的次数总和，当RPC请求量达到一定水平，授权平台会成为一个瓶颈点。</p><p>为了解决这个问题，我们可以将授权平台所做的事情转移到服务提供方。我们使用一种不可逆加密算法，例如HMAC算法。服务提供方应用里面放一个用于HMAC签名的私钥，在授权平台上用这个私钥为申请调用的调用方应用进行签名，这个签名生成的串就变成了调用方唯一的身份。服务提供方在收到调用方的授权请求之后，我们只需要验证这个签名更调用方应用信息是否对应的上就可以了。</p><p>服务提供方可以提供的安全校验方式：</p><ol><li>md5摘要校验</li><li>非对称加密算法</li><li>OAuth2授权</li></ol><p>为了避免同一个接口有多个应用做发布提供者，我们需要把接口跟应用绑定上，一个接口只允许有一个应用发布提供者，避免其他应用也能发布这个接口。</p><p>当注册中心收到服务提供方注册申请时，可以验证下请求过来的应用是否跟接口绑定的应用一样，只有相同才允许注册，否则就返回错误信息给启动的应用，从而避免假冒的服务提供者对外提供错误服务。</p><h3 id="19-分布式环境下如何快速定位问题？">19 | 分布式环境下如何快速定位问题？</h3><p><strong>分布式环境下定位问题有什么难点？</strong></p><blockquote><p>分布式环境下定位问题的难点在于，各子应用、子服务之间有复杂的依赖关系，我们有时很难确定是哪个服务的哪个环节出现的问题。如果要通过日志来排查问题，就需要对每个子应用、子服务逐一进行排查，很难一步到位。</p></blockquote><p><strong>在分布式环境下如何快速定位问题？</strong> 有两种方式：</p><ol><li>借助合理封装的异常信息</li><li>借助分布式链路跟踪</li></ol><p>RPC框架打印的异常信息中，需要包含定位问题所需要的异常信息的，比如哪些异常引起的问题（如序列化问题或网络超时问题），是调用端还是服务端出现的异常，调用端与服务端的IP是多少，以及服务接口与服务分组是什么等等。</p><p>异常的示意图如下所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520113224912.png" alt="image-20240520113224912"></p><p>一款优秀的RPC框架要对异常进行详细地封装，还要对各类异常进行分类，每类异常都要有明确的异常标识码，并整理成一份简明的文档。适用房可以快速地通过异常标识码在文档中查阅，从而快速定位问题，找到原因，并且异常信息中药包含排查问题时所需要的重要信息，比如服务接口名、服务分组、调用端和服务端的IP，以及产生异常的原因。总之，要让适用房在复杂的分布式应用系统重，根据异常信息快速地定位到问题。</p><p>分布式链路跟踪可以让我们快速的知道整个服务调用的链路信息以及被调用的各个服务是否存在问题。例如服务A调用下游服务B，服务B又调用了B依赖的下游服务，如果服务A可以清楚的知道整个调用链路，并且能准确的直到调用链路中个服务的状态，那么就可以快速的定位问题。</p><p>分布式链路跟踪有Trace和Span两个关键概念：</p><ul><li><strong>Trace</strong>：代表整个链路，每次分布式都会产生一个Trace，每个Trace都有它的唯一标识，即TraceId，在分布式链路跟踪系统重，就是通过TraceId来区分每个Trace的。</li><li><strong>Span</strong>：代表了整个链路的一段链路，也就说Trace是由多个Span组成的。在一个Trace下，每个Span也有唯一的标识SpanId，而Span之间是存在父子关系的。</li></ul><p>Trace和Span的关系如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520113243384.png" alt="image-20240520113243384"></p><p>RPC在整合分布式链路跟踪所需要做的核心事情有2件：</p><ol><li><strong>埋点</strong>：分布式链路跟踪系统要想获得一次分布式调用的完整链路信息，就必须对这次分布式调用进行数据采集，而采集这些数据的方法就是通过RPC框架对分布式链路跟踪进行埋点。RPC调用端在访问服务端时，在发送请求消息前会触发分布式跟踪埋点，在接收到服务端响应时，也会触发分布式跟踪埋点，并且在服务端也会有类似的埋点。这些埋点最终可以记录一个完整的Span，而这个链路的源头会记录一个完整的Trace，最终Trace信息也会上报给分布式链路跟踪系统。</li><li><strong>传递</strong>：上游调用端将Trace信息与父Span信息传递给下游服务的服务端，由下游触发埋点，对这些信息进行处理，在分布式链路跟踪系统重，每个子Span都存有父Span的相关信息以及Trace的相关信息。</li></ol><h3 id="20-详解时钟轮在RPC中的应用">20 | 详解时钟轮在RPC中的应用</h3><p><strong>RPC中的定时任务应该如何处理？</strong></p><ol><li>针对有定时需求的请求，建立额外的线程，使用Thread.sleep方法来处理。</li><li>建立一个单独的线程，来持续扫描有定时需求的请求，判断是否到时间了。</li><li>使用时钟轮方法</li></ol><p>在时钟轮机制中，有时间槽和时钟轮的概念，时间槽相当于时钟的刻度，时钟轮箱单与秒针与分针等跳动的一个周期，我们会将每个人物放到相应的时间槽位上。</p><p>时钟轮的运行机制和生活中的时钟是一样的，每隔固定的单位时间，就会从一个时间槽位调到下一个时间槽位，这就相当于我们的秒针跳动了一次；时钟轮可以分为多层，下一层时钟轮中每个槽位的单位时间是当前时间轮整个周期的时间，这就相当于1分钟等于60秒钟；当时钟轮将一个周期的所有槽位都跳动完后，就会从下一层时钟轮中取出一个槽位的任务，重新分不到当前的时钟轮中，当前时钟轮则从第0槽位开始重新跳动，这就相当于下一分钟的第1秒。</p><p><strong>在RPC框架中哪些功能会用到时钟轮？</strong></p><ol><li><strong>调用端请求超时处理</strong>，我们每发一次请求，都创建一个处理请求超时的定时任务放到时钟轮里，在高并发、高访问量的情况下，时钟轮每次只轮询一个时间槽位中的任务，这样会节省大量的CPU。</li><li><strong>心跳检测</strong>，对于这种需要重复执行的定时任务，我们可以在定时任务执行逻辑的最后，重设这个任务的执行时间，把它重新丢回到时钟轮里面。</li></ol><p>在使用时间轮时，我们需要注意两件事情：</p><ol><li>时间槽位的单位时间越短，时间轮触发任务的时间就越精确。</li><li>时间轮的槽位越多，那么一个任务呗重复扫描的概率就越小，因为只有在多层时钟轮中的任务才会被重复扫描。</li></ol><h3 id="21-流量回放：保障业务技术升级的神器">21 | 流量回放：保障业务技术升级的神器</h3><p><strong>什么是流量回放？</strong></p><blockquote><p>流量就是指在某个时间段内的所有请求，我们通过某种手段把发送到A应用的所有请求录制下来，然后把这些请求统一转发到B应用，让B应用接收到的请求参数和A应用保持一致，从而实现A接收到的请求在B应用里面重新请求了一遍，这个过程，我们称为“流量回放”。</p></blockquote><p>当我们对应用逻辑有改动，但在做了单元测试和回归测试之后，因为线上环境更加复杂，为了降低出错的概率，可以尝试使用流量回放。</p><p>传统QA测试不能满足要求的根本原因就是在于改造后的应用在上线后出现跟应用上线前不一致的行为。我们测试的目的就是为了保证改造后的应用跟改造前应用的行为一致，我们测试Case也应该尽力去模拟应用在线上的行为，这时最好的方式就是用线上流量来验证，但是又不能把新的应用直接上线，所以我们可以考虑流量回放。也就是说我们可以把线上一段时间内的请求参数和响应结果保存下来，然后把这些请求参数在新改造的应用里面重新请求一遍，对比一下改造前后的响应结果是否一致，这样就间接达到了使用线上流量进行测试的效果。</p><p>我们常用的流量回放方案包括TcpCopy、Nginx等。</p><p>在RPC框架中，因为所有的请求都经过RPC，我们可以在RPC中拿到这些请求参数，将这些参数旁录下来，并将旁录结果用异步的方式发送到一个固定的地方保存起来，这样就完成了流量录制功能。</p><p>在完成录制功能后，我们需要模拟一个应用调用方，将录制好的请求参数重新发送一遍到要回归测试的应用里面，然后对比录制拿到的请求结果和新请求的结果，这样就完成了请求回放的过程。</p><p>流量回放不是RPC框架的核心功能，但是有了这个功能以后，用户可以更放心的升级自己的应用了。</p><p>使用流量回放，对请求有一些限制：</p><ol><li>请求是否依赖底层数据，如果依赖，那么需要保证底层数据是一致的。</li><li>请求是否与当前系统状态或者系统时间有关系，如果相关，那么相关依赖也需要保持一致。</li><li>请求所执行的方法是否幂等，如果不幂等，很可能会影响验证结果。</li></ol><p>实现流量回放的设计思路：</p><ol><li>使用动态代理，切面拦截对应的方法，获取出入参。</li><li>把拦截信息异步转存到线上验证系统。</li><li>通过线上验证系统调用待验证的防范。</li><li>收集结果对比信息，设置报警功能。</li></ol><p>服务分组：为了避免非核心业务因调用量突增而影响整个系统的可用性，我们可以把服务按照调用方的不同划分为不同的小组或集群，这样可以实现调用流量的隔离，保证不同的业务之间不会相互影响。并且，通过将非核心业务应用和核心业务应用分开，可以进一步保护核心业务的稳定性。</p><p>分组机器配置：通过压力测试来评估每台服务器能承受的请求量（QPS），然后根据每个分组的总调用量计算出所需要的机器数量。为了应对可能的流量增长，我们通常会在计算出的机器数量基础上增加一定比例的额外机器作为缓冲。</p><p>动态分组：当某个分组的流量突然增加，而预留的机器无法满足需求时，我们可以检查其他分组是否有多余的处理能力来帮助处理请求。这就涉及到动态分组的概念，即通过修改注册中心的数据，动态调整服务分组，以适应不同的调用需求。</p><h3 id="22-动态分组：超高效实现秒级扩缩容">22 | 动态分组：超高效实现秒级扩缩容</h3><p>我们之前学习过服务分组，在调用方复杂的情况下，如果让所有调用方都调用同一个集群，那么很可能会因为非核心业务调用量的突增，造成整个集群都不可用了，为了避免这种情况，我们需要把整个打击群根据不同的调用方划分出不同的小集群，从而实现调用方流量隔离的效果，保证不同业务之间不会相互影响。</p><p>在给集群分组的时候，我们一般会选择性的合并一些调用方到同一个分组里，至于如何合并，并没有统一标准，一般来说，我们可以按照应用的重要级别来划分，让非核心业务应用和核心业务应用不要共用一个分组，并且非核心应用之间也最好别用一个分组。</p><p>那么我们如何为每个分组配置合适的机器数量呢？一般会通过压测来评估服务提供方单台机器所能承受的QPS，然后再计算出每个分组里面的所有调用方的调用总量，考虑到可能的不确定性因素，我们可以在现有调用总量的基础上，添加一个百分比作为buffer，这个百分比一般来自经验总结。</p><p>我们计算每个分组所需要的机器数量时，会额外增加一些机器，这样让每个小集群可以有一定的抗压能力，而抗压能力取决于预留机器的数量，这就需要在成本和可用性之间做权衡。</p><p>当某个分组的调用方流量突增，而分组所预留的空间不能满足当前流量要求时，我们可以看一下其他分组的服务提供方是否有富余能力来帮忙处理请求，这也就是动态分组的含义。</p><p>因为服务提供方的分组信息以及机器节点都保存在注册中心里面，我们可以在注册中心里面将部分实例的别名改成我们想要的别名，然后通过服务发现进而影响到不同调用方能够调用的服务提供方实例集合，换句话说，我们可以通过控制注册中心，来管理服务调用方可以触达的服务提供方以及分组节点的信息。</p><p>通过直接修改注册中心数据，我们可以让任何一个分组瞬间拥有不同规模的集群能力。我们不仅可以实现把某个实例的分组名改成另一个分组名，还可以让某个实例分组名变成多个分组名，这就是我们在动态分组里面最常见的两种动作：追加和替换。</p><p>我们还可以利用动态分组解决分组后的每个分组预留机器冗余的问题，我们没有必要把所有冗余的机器都分配到分组里面，我们可以把这些机器做成一个共享的池子，从而减少整理预留的实例数量。</p><h3 id="23-如何在没有接口的情况下进行RPC调用？">23 | 如何在没有接口的情况下进行RPC调用？</h3><p><strong>我们什么情况下需要在没有接口时进行RPC调用？</strong> 列举2个典型场景：</p><ol><li>我们搭建一个测试平台，允许各个业务方在测试凭条上通过输入接口、分组名、方法名以及参数值，在线测试自己发布的RPC服务。</li><li>我们要搭建一个轻量级的服务网关，可以让各个业务方用HTTP的方式，通过服务网关调用其他服务。</li></ol><p>所谓RPC调用，本质上就是调用端向服务端发送一条请求消息，服务端接收并处理，之后向调用端发送一条响应消息，调用端处理完响应消息后，一次RPC调用就完成了。</p><p>如果调用端可以将服务端需要知道的消息，例如接口名、业务分组名、方法名以及参数信息封装成请求消息发送给服务器，服务端就能够解析并处理这条请求信息，这样问题就解决了。</p><p>我们可以使用泛化接口的方式，来让RPC框架通过动态代理的方式，在没有接口的情况下，进行RPC调用，也称为泛化调用。</p><h3 id="24-如何在线上环境里兼容多种RPC协议？">24 | 如何在线上环境里兼容多种RPC协议？</h3><p>不同的RPC框架随着互联网技术的发展而慢慢涌现，这些框架会在不同时期被引入到不同的项目中去解决应用之间的通信问题，这样就导致了我们在线上的环境中会存在各种各样的RPC框架。</p><p>我们可以尝试通过自下而上的滚动升级方式，最终让所有的应用都切换到统一的RPC框架上，这种方法有2个局限：</p><ol><li>这要求我们能够清楚的梳理出各个应用之间的调用关系，只有这样，我们才能按部就班地把所有应用都升级到新的RPC框架上。</li><li>这要求应用之间的关系不能存在互相调用的情况，最好是应用之间的调用关系就像一棵树，有一定的层次关系。但实际上，应用之间的调用关系往往会变成一张网。</li></ol><p>这里的关键在于，我们要让新的RPC能同时支持多种RPC调用，当一个调用方切换到新的RPC之后，调用方和服务提供方之间就可以用新的协议完成调用，当调用方用老的RPC进行调用时，调用方和服务提供方之间就继续沿用老的协议完成调用。</p><p>RPC协议的作用是用来分割二进制数据流，不同的协议约定的数据包格式是不一样的，而且每种协议开头都有一个协议编码， 一般叫做magic number。</p><p>当RPC收到数据包之后，我们可以先解析出magic number，之后就可以找到对应协议的数据格式，然后使用相应的数据格式去解析收到的二进制数据包。</p><p>协议解析过程就是把一连串的二进制数据变成一个RPC内部对象，我们可以把和协议相关的对象转换成一个和协议无关的对象。</p><p>当完成真正的方法调用以后，RPC返回的也是一个和协议无关的通用对象，当我们向调用方回写数据时，我们还需要把通用对象转换成和协议相关的对象。</p>]]></content>
    
    
    <summary type="html">《RPC实战与核心原理》</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Webbench</title>
    <link href="https://penge666.github.io/posts/689fc9d.html"/>
    <id>https://penge666.github.io/posts/689fc9d.html</id>
    <published>2024-05-19T14:07:33.000Z</published>
    <updated>2024-05-21T14:09:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Webbench是一款非常简单的网站压力测试工具，它是由Lionbridge公司开发的。由于它的简单性和轻量级，Webbench在互联网公司中广泛使用，特别是在进行网站压力测试时。</p><p>Webbench的主要功能是模拟大量的并发连接，以测试网站在高并发环境下的性能。它可以模拟多达3万个并发连接，这对于大多数网站来说已经足够了。</p><p>Webbench的使用也非常简单，你只需要在命令行中输入相应的命令，就可以开始测试。例如，以下命令会模拟1000个并发连接，持续60秒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbench -c 1000 -t 60 http://yourwebsite.com</span><br></pre></td></tr></table></figure><p>测试结束后，Webbench会在命令行中显示测试结果，包括每秒钟处理的请求数（Requests per second）、每秒钟传输的数据量（Transfer rate）等。</p><p>总的来说，Webbench是一款简单、轻量级的网站压力测试工具，它可以帮助你评估你的网站在高并发环境下的性能。</p><p>官网：<a href="http://home.tiscali.cz/~cz210552/webbench.html">http://home.tiscali.cz/~cz210552/webbench.html</a></p><h2 id="核心原理">核心原理</h2><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240521215503291.png" alt="image-20240521215503291"></p><h2 id="源码分析">源码分析</h2><p><strong>socket.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $Id: socket.c 1.1 1995/01/01 07:11:14 cthuang Exp $</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module has been modified by Radim Kolar for OS/2 emx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">  module:       socket.c</span></span><br><span class="line"><span class="comment">  program:      popclient</span></span><br><span class="line"><span class="comment">  SCCS ID:      @(#)socket.c    1.5  4/1/94</span></span><br><span class="line"><span class="comment">  programmer:   Virginia Tech Computing Center</span></span><br><span class="line"><span class="comment">  compiler:     DEC RISC C compiler (Ultrix 4.1)</span></span><br><span class="line"><span class="comment">  environment:  DEC Ultrix 4.3 </span></span><br><span class="line"><span class="comment">  description:  UNIX sockets code.</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">功能：通过地址和端口建立网络连接</span></span><br><span class="line"><span class="comment">host：网络地址</span></span><br><span class="line"><span class="comment">clientPort:端口</span></span><br><span class="line"><span class="comment">返回值：建立的socket连接</span></span><br><span class="line"><span class="comment">如果返回 -1,表示建立连接失联</span></span><br><span class="line"><span class="comment">***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以host和clientPort构成一对TCP的套接字（host支持域名）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Socket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">int</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> inaddr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ad;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *hp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;ad, <span class="number">0</span>, <span class="built_in">sizeof</span>(ad));</span><br><span class="line">    ad.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    inaddr = <span class="built_in">inet_addr</span>(host);<span class="comment">//将点分的十进制的IP转为无符号长整型</span></span><br><span class="line">    <span class="keyword">if</span> (inaddr != INADDR_NONE)</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="built_in">sizeof</span>(inaddr));</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果host是域名</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = <span class="built_in">gethostbyname</span>(host); <span class="comment">//用域名获取IP</span></span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//端口</span></span><br><span class="line">    ad.sin_port = <span class="built_in">htons</span>(clientPort); <span class="comment">//将一个无符号短整型(s)的主机数值(h)转换为网络字节顺序(n)</span></span><br><span class="line">    <span class="comment">//创建通信端点：套接字</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sock;</span><br><span class="line">    <span class="comment">//连接到相应的主机</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;ad, <span class="built_in">sizeof</span>(ad)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webbench.c</strong></p><p>在webbench.c文件中，包含了下面几个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="type">int</span> signal)</span><span class="comment">//信号处理函数，时钟结束时进行调用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//是在使用出错时提示怎么使用本程序。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span><span class="comment">//是用来创建http连接请求的。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bench</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//中创建管道和子进程，调用测试http函数。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span> *req)</span><span class="comment">//对http请求进行测试。</span></span></span><br></pre></td></tr></table></figure><p>wenbench.c源代码及注释 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* (C) Radim Kolar 1997-2004</span></span><br><span class="line"><span class="comment">* This is free software, see GNU Public License version 2 for</span></span><br><span class="line"><span class="comment">* details.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Simple forking WWW Server benchmark:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Usage:</span></span><br><span class="line"><span class="comment">*   webbench --help</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Return codes:</span></span><br><span class="line"><span class="comment">*    0 - sucess</span></span><br><span class="line"><span class="comment">*    1 - benchmark failed (server is not on-line)</span></span><br><span class="line"><span class="comment">*    2 - bad param</span></span><br><span class="line"><span class="comment">*    3 - internal error, fork failed</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;socket.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rpc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* values */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> timerexpired=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> speed=<span class="number">0</span>;<span class="comment">//子进程成功得到服务器响应的总数</span></span><br><span class="line"><span class="type">int</span> failed=<span class="number">0</span>;<span class="comment">//子进程请求失败总数</span></span><br><span class="line"><span class="type">int</span> bytes=<span class="number">0</span>;<span class="comment">//读取的字节总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* globals */</span></span><br><span class="line"><span class="type">int</span> http10=<span class="number">1</span>; <span class="comment">/* 0 - http/0.9, 1 - http/1.0, 2 - http/1.1 */</span></span><br><span class="line"><span class="comment">/* Allow: GET, HEAD, OPTIONS, TRACE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_GET 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_HEAD 1  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_OPTIONS 2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_TRACE 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRAM_VERSION <span class="string">&quot;1.5&quot;</span></span></span><br><span class="line"><span class="type">int</span> method=METHOD_GET;  <span class="comment">//HTTP请求方法，默认GET 方式</span></span><br><span class="line"><span class="type">int</span> clients=<span class="number">1</span>;  <span class="comment">//只模拟一个客户端,并发数</span></span><br><span class="line"><span class="type">int</span> force=<span class="number">0</span>;  <span class="comment">//是否等待服务器应答。默认为不等待</span></span><br><span class="line"><span class="type">int</span> force_reload=<span class="number">0</span>; <span class="comment">//失败时</span></span><br><span class="line"><span class="type">int</span> proxyport=<span class="number">80</span>; <span class="comment">//代理服务器应答，访问端口为80</span></span><br><span class="line"><span class="type">char</span> *proxyhost=<span class="literal">NULL</span>; <span class="comment">//代理服务器的地址</span></span><br><span class="line"><span class="type">int</span> benchtime=<span class="number">30</span>; <span class="comment">//模拟请求时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal */</span></span><br><span class="line"><span class="type">int</span> mypipe[<span class="number">2</span>]; <span class="comment">//管道，用于父子进程间通信</span></span><br><span class="line"><span class="type">char</span> host[MAXHOSTNAMELEN]; <span class="comment">//网络地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_SIZE 2048</span></span><br><span class="line"><span class="type">char</span> request[REQUEST_SIZE]; <span class="comment">//HTTP请求信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">option</span> long_options[]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;force&quot;</span>,no_argument,&amp;force,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;reload&quot;</span>,no_argument,&amp;force_reload,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;time&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;?&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http09&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;9&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http10&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http11&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;2&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>,no_argument,&amp;method,METHOD_GET&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;head&quot;</span>,no_argument,&amp;method,METHOD_HEAD&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;options&quot;</span>,no_argument,&amp;method,METHOD_OPTIONS&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;trace&quot;</span>,no_argument,&amp;method,METHOD_TRACE&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;version&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;V&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;proxy&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;clients&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prototypes */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host,<span class="type">const</span> <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *request)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bench</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timerexpired=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//帮助信息</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">            <span class="string">&quot;webbench [option]... URL\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -f|--force               Don&#x27;t wait for reply from server.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -r|--reload              Send reload request - Pragma: no-cache.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -9|--http09              Use HTTP/0.9 style requests.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -1|--http10              Use HTTP/1.0 protocol.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -2|--http11              Use HTTP/1.1 protocol.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --get                    Use GET request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --head                   Use HEAD request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --options                Use OPTIONS request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --trace                  Use TRACE request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -?|-h|--help             This information.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -V|--version             Display program version.\n&quot;</span></span><br><span class="line">           );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> opt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> options_index=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *tmp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带参数时直接输出帮助信息</span></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usage</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//getopt_log 为命令行解析的库函数</span></span><br><span class="line">    <span class="keyword">while</span>((opt=<span class="built_in">getopt_long</span>(argc,argv,<span class="string">&quot;912Vfrt:p:c:?h&quot;</span>,long_options,&amp;options_index))!=EOF )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果有返回对应的命令行参数</span></span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="number">0</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: force=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: force_reload=<span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>: http10=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: http10=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: http10=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="built_in">printf</span>(PROGRAM_VERSION<span class="string">&quot;\n&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//输入版本号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: benchtime=<span class="built_in">atoi</span>(optarg);<span class="keyword">break</span>;     </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: </span><br><span class="line">            <span class="comment">/* proxy server parsing server:port */</span></span><br><span class="line">            tmp=<span class="built_in">strrchr</span>(optarg,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            proxyhost=optarg;</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Error in option --proxy %s: Missing hostname.\n&quot;</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg+<span class="built_in">strlen</span>(optarg)<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Error in option --proxy %s Port number is missing.\n&quot;</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *tmp=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            proxyport=<span class="built_in">atoi</span>(tmp+<span class="number">1</span>);<span class="keyword">break</span>;<span class="comment">//重设端口号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>: <span class="built_in">usage</span>();<span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: clients=<span class="built_in">atoi</span>(optarg);<span class="keyword">break</span>;<span class="comment">//并发数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optind 被 getopt_long设置为命令行参数中未读取的下一个元素下标值</span></span><br><span class="line">    <span class="keyword">if</span>(optind==argc) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;webbench: Missing URL!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">usage</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能指定客户端数和请求时间为 0</span></span><br><span class="line">    <span class="keyword">if</span>(clients==<span class="number">0</span>) clients=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(benchtime==<span class="number">0</span>) benchtime=<span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Copyright */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Webbench - Simple Web Benchmark &quot;</span>PROGRAM_VERSION<span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n&quot;</span></span><br><span class="line">            );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造HTTP请求到request数组</span></span><br><span class="line">    <span class="built_in">build_request</span>(argv[optind]);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print request info ,do it in function build_request</span></span><br><span class="line">    <span class="comment">/*printf(&quot;Benchmarking: &quot;);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    switch(method)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        case METHOD_GET:</span></span><br><span class="line"><span class="comment">        default:</span></span><br><span class="line"><span class="comment">        printf(&quot;GET&quot;);break;</span></span><br><span class="line"><span class="comment">        case METHOD_OPTIONS:</span></span><br><span class="line"><span class="comment">        printf(&quot;OPTIONS&quot;);break;</span></span><br><span class="line"><span class="comment">        case METHOD_HEAD:</span></span><br><span class="line"><span class="comment">        printf(&quot;HEAD&quot;);break;</span></span><br><span class="line"><span class="comment">        case METHOD_TRACE:</span></span><br><span class="line"><span class="comment">        printf(&quot;TRACE&quot;);break;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    printf(&quot; %s&quot;,argv[optind]);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    switch(http10)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        case 0: printf(&quot; (using HTTP/0.9)&quot;);break;</span></span><br><span class="line"><span class="comment">        case 2: printf(&quot; (using HTTP/1.1)&quot;);break;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Runing info: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clients==<span class="number">1</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 client&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d clients&quot;</span>,clients);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, running %d sec&quot;</span>, benchtime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(force) <span class="built_in">printf</span>(<span class="string">&quot;, early socket close&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost!=<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;, via proxy server %s:%d&quot;</span>,proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(force_reload) <span class="built_in">printf</span>(<span class="string">&quot;, forcing reload&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始压力测试，返回bench函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bench</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">功能：创建URL请求连接</span></span><br><span class="line"><span class="comment">url:url地址</span></span><br><span class="line"><span class="comment">返回值:无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">********************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求地址和请求连接清零</span></span><br><span class="line">    <span class="comment">//bzero(host,MAXHOSTNAMELEN);</span></span><br><span class="line">    <span class="comment">//bzero(request,REQUEST_SIZE);</span></span><br><span class="line">    <span class="built_in">memset</span>(host,<span class="number">0</span>,MAXHOSTNAMELEN);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(request,<span class="number">0</span>,REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断应该使用的HTTP协议,协议适配</span></span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span> &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填写method方式</span></span><br><span class="line">    <span class="keyword">switch</span>(method)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> METHOD_GET: <span class="built_in">strcpy</span>(request,<span class="string">&quot;GET&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_HEAD: <span class="built_in">strcpy</span>(request,<span class="string">&quot;HEAD&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_OPTIONS: <span class="built_in">strcpy</span>(request,<span class="string">&quot;OPTIONS&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_TRACE: <span class="built_in">strcpy</span>(request,<span class="string">&quot;TRACE&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">//URL 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==<span class="built_in">strstr</span>(url,<span class="string">&quot;://&quot;</span>)) <span class="comment">//找：//”在URL中的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n%s: is not a valid URL.\n&quot;</span>,url);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(url)&gt;<span class="number">1500</span>) <span class="comment">//url是否太长</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;URL is too long.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>!=<span class="built_in">strncasecmp</span>(<span class="string">&quot;http://&quot;</span>,url,<span class="number">7</span>)) <span class="comment">//比较前7个字符串</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//只支持HTTP地址</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nOnly HTTP protocol is directly supported, set --proxy for others.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到主机名开始的地方</span></span><br><span class="line">    <span class="comment">/* protocol/host delimiter */</span></span><br><span class="line">    i=<span class="built_in">strstr</span>(url,<span class="string">&quot;://&quot;</span>)-url+<span class="number">3</span>; <span class="comment">//i指向http://后第一个位置</span></span><br><span class="line">    <span class="comment">//必须以/结束</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;/&#x27;</span>)==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nInvalid URL syntax - hostname don&#x27;t ends with &#x27;/&#x27;.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get port from hostname */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)!=<span class="literal">NULL</span> &amp;&amp; <span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)&lt;<span class="built_in">index</span>(url+i,<span class="string">&#x27;/&#x27;</span>)) <span class="comment">//判断url中是否指定了端口号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;:&#x27;</span>)-url-i);  <span class="comment">//取出主机地址</span></span><br><span class="line">            <span class="comment">//bzero(tmp,10);</span></span><br><span class="line">            <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">10</span>);<span class="comment">//端口</span></span><br><span class="line">            <span class="built_in">strncpy</span>(tmp,<span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)+<span class="number">1</span>,<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;/&#x27;</span>)-<span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;tmp=%s\n&quot;,tmp); */</span></span><br><span class="line">            proxyport=<span class="built_in">atoi</span>(tmp); <span class="comment">//设置端口</span></span><br><span class="line">            <span class="keyword">if</span>(proxyport==<span class="number">0</span>) proxyport=<span class="number">80</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strcspn</span>(url+i,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;Host=%s\n&quot;,host);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request+<span class="built_in">strlen</span>(request),url+i+<span class="built_in">strcspn</span>(url+i,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;ProxyHost=%s\nProxyPort=%d\n&quot;,proxyhost,proxyport);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request,url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(http10==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot; HTTP/1.0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (http10==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot; HTTP/1.1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;User-Agent: WebBench &quot;</span>PROGRAM_VERSION<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span> &amp;&amp; http10&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;Host: &quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(request,host);</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;Pragma: no-cache\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* add empty line at end */</span></span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>) <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRequest:\n%s\n&quot;</span>,request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment">功能：创建管道和子进程，对http请求进行测试</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* vraci system rc error kod */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bench</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为测试地址是否合法</span></span><br><span class="line">    <span class="comment">/* check avaibility of target server */</span></span><br><span class="line">    i=<span class="built_in">Socket</span>(proxyhost==<span class="literal">NULL</span>?host:proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nConnect to server failed. Aborting benchmark.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建管道</span></span><br><span class="line">    <span class="comment">/* create pipe */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(mypipe))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not needed, since we have alarm() in childrens */</span></span><br><span class="line">    <span class="comment">/* wait 4 next system clock tick */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cas=time(NULL);</span></span><br><span class="line"><span class="comment">    while(time(NULL)==cas)</span></span><br><span class="line"><span class="comment">    sched_yield();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//派生子进程</span></span><br><span class="line">    <span class="comment">/* fork childs */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;clients;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= (<span class="type">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* child process or error*/</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">/* make childs faster */</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//子进程立刻跳出循环，要不就子进程继续fork </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid &lt; (<span class="type">pid_t</span>) <span class="number">0</span>)<span class="comment">//fork出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;problems forking worker no. %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == (<span class="type">pid_t</span>) <span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程发出实际请求</span></span><br><span class="line">        <span class="comment">/* I am a child */</span></span><br><span class="line">        <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">benchcore</span>(host,proxyport,request);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">benchcore</span>(proxyhost,proxyport,request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开管道写</span></span><br><span class="line">        <span class="comment">/* write results to pipe */</span></span><br><span class="line">        f=<span class="built_in">fdopen</span>(mypipe[<span class="number">1</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;open pipe for writing failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* fprintf(stderr,&quot;Child - %d %d\n&quot;,speed,failed); */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(f,<span class="string">&quot;%d %d %d\n&quot;</span>,speed,failed,bytes);</span><br><span class="line">        <span class="built_in">fclose</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程打开管道读</span></span><br><span class="line">        f=<span class="built_in">fdopen</span>(mypipe[<span class="number">0</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;open pipe for reading failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">setvbuf</span>(f,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        speed=<span class="number">0</span>;<span class="comment">//传输速度</span></span><br><span class="line">        failed=<span class="number">0</span>;<span class="comment">//失败请求数</span></span><br><span class="line">        bytes=<span class="number">0</span>;<span class="comment">//传输字节数</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  <span class="comment">//从管道中读取每个子进程的任务执行情况，并计数</span></span><br><span class="line">        &#123;</span><br><span class="line">            pid=<span class="built_in">fscanf</span>(f,<span class="string">&quot;%d %d %d&quot;</span>,&amp;i,&amp;j,&amp;k);</span><br><span class="line">            <span class="keyword">if</span>(pid&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Some of our childrens died.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            speed+=i;</span><br><span class="line">            failed+=j;</span><br><span class="line">            bytes+=k;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//子进程是否读取完</span></span><br><span class="line">            <span class="comment">/* fprintf(stderr,&quot;*Knock* %d %d read=%d\n&quot;,speed,failed,pid); */</span></span><br><span class="line">            <span class="keyword">if</span>(--clients==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">fclose</span>(f);</span><br><span class="line">        <span class="comment">//输出测试结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n&quot;</span>,</span><br><span class="line">            (<span class="type">int</span>)((speed+failed)/(benchtime/<span class="number">60.0f</span>)),</span><br><span class="line">            (<span class="type">int</span>)(bytes/(<span class="type">float</span>)benchtime),</span><br><span class="line">            speed,</span><br><span class="line">            failed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment">功能：测试HTTP</span></span><br><span class="line"><span class="comment">host：地址</span></span><br><span class="line"><span class="comment">port：端口</span></span><br><span class="line"><span class="comment">req:http格式方法</span></span><br><span class="line"><span class="comment">**************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rlen;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="type">int</span> s,i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装信号</span></span><br><span class="line">    <span class="comment">/* setup alarm signal handler */</span></span><br><span class="line">    sa.sa_handler=alarm_handler;<span class="comment">//定时器方法</span></span><br><span class="line">    sa.sa_flags=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sigaction</span>(SIGALRM,&amp;sa,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置闹钟函数</span></span><br><span class="line">    <span class="built_in">alarm</span>(benchtime); <span class="comment">// after benchtime,then exit</span></span><br><span class="line"></span><br><span class="line">    rlen=<span class="built_in">strlen</span>(req);</span><br><span class="line">    <span class="comment">//无限执行请求，直到接收到SIGALRM信号将timerexpired设置为1时</span></span><br><span class="line">    nexttry:<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timerexpired)<span class="comment">//定时器到时后，也就是收到信号则后，会设定timerexpired=1，函数就会返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(failed&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* fprintf(stderr,&quot;Correcting failed by signal\n&quot;); */</span></span><br><span class="line">                failed--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接远程服务器 ，进行HTTP请求</span></span><br><span class="line">        s=<span class="built_in">Socket</span>(host,port); <span class="comment">//创建连接                         </span></span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">0</span>) &#123; failed++;<span class="keyword">continue</span>;&#125; <span class="comment">//连接失败，failed加1</span></span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        <span class="keyword">if</span>(rlen!=<span class="built_in">write</span>(s,req,rlen)) &#123;failed++;<span class="built_in">close</span>(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是http/0.9则关闭socket的写操作</span></span><br><span class="line">        <span class="keyword">if</span>(http10==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">shutdown</span>(s,<span class="number">1</span>)) &#123; failed++;<span class="built_in">close</span>(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果等到响应数据返回，则读取响应数据，计算传输的字节数</span></span><br><span class="line">        <span class="keyword">if</span>(force==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* read all available data from socket */</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(timerexpired) <span class="keyword">break</span>; </span><br><span class="line">                i=<span class="built_in">read</span>(s,buf,<span class="number">1500</span>);</span><br><span class="line">                <span class="comment">/* fprintf(stderr,&quot;%d\n&quot;,i); */</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) </span><br><span class="line">                &#123; </span><br><span class="line">                    failed++;</span><br><span class="line">                    <span class="built_in">close</span>(s);</span><br><span class="line">                    <span class="keyword">goto</span> nexttry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                bytes+=i; <span class="comment">//读取字节数增加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">close</span>(s)) &#123;failed++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//成功完成一次请求，并计数，继续下一次相同的请求，直到超时为止</span></span><br><span class="line">        speed++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ ./webbench -<span class="built_in">help</span></span><br><span class="line">webbench [option]... URL</span><br><span class="line">  -f|--force               Don<span class="string">&#x27;t wait for reply from server.</span></span><br><span class="line"><span class="string">  -r|--reload              Send reload request - Pragma: no-cache.</span></span><br><span class="line"><span class="string">  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.</span></span><br><span class="line"><span class="string">  -p|--proxy &lt;server:port&gt; Use proxy server for request.</span></span><br><span class="line"><span class="string">  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.</span></span><br><span class="line"><span class="string">  -9|--http09              Use HTTP/0.9 style requests.</span></span><br><span class="line"><span class="string">  -1|--http10              Use HTTP/1.0 protocol.</span></span><br><span class="line"><span class="string">  -2|--http11              Use HTTP/1.1 protocol.</span></span><br><span class="line"><span class="string">  --get                    Use GET request method.</span></span><br><span class="line"><span class="string">  --head                   Use HEAD request method.</span></span><br><span class="line"><span class="string">  --options                Use OPTIONS request method.</span></span><br><span class="line"><span class="string">  --trace                  Use TRACE request method.</span></span><br><span class="line"><span class="string">  -?|-h|--help             This information.</span></span><br><span class="line"><span class="string">  -V|--version             Display program version.</span></span><br></pre></td></tr></table></figure><p>简单测试下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ ./webbench  http://www.baidu.com/</span><br><span class="line">Webbench - Simple Web Benchmark 1.5</span><br><span class="line">Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http://www.baidu.com/</span><br><span class="line">1 client, running 30 sec.</span><br><span class="line"></span><br><span class="line">Speed=356 pages/min, 2416135 bytes/sec.</span><br><span class="line">Requests: 178 susceed, 0 failed.</span><br></pre></td></tr></table></figure><p>-t表示测试的时间，-c表示并发访问网站的客户数。上述QPS=178/30</p><p>返回的结果中有两个指标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.pages/min:每分输出的页面数；</span><br><span class="line">2.bytes/sec:每秒传输的比特数；</span><br><span class="line">3.succeed和failed表示请求的成功数目和失败数目；</span><br></pre></td></tr></table></figure><p><strong>补充</strong></p><p>Apache Bench 是 Apache 服务器自带的一个web压力测试=工具，简称 ab 。</p><p>ab的原理：ab命令会创建 <strong>多个并发</strong> 访问线程，模拟 <strong>多个访问者</strong> 同时对某一 <strong>URL地址</strong> 进行访问。</p><p>它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、<a href="https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3DIIS%26spm%3D1001.2101.3001.7020">IIS</a>等其它Web服务器的压力。</p><p>参考自：</p><ul><li><p><a href="https://blog.csdn.net/chen1415886044/article/details/103939937">web性能压力测试工具：Webbench 源码分析</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/106323837">web压力测试工具webbench</a></p></li></ul>]]></content>
    
    
    <summary type="html">Web性能压力测试工具:Webbench</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="https://penge666.github.io/posts/f12cbde5.html"/>
    <id>https://penge666.github.io/posts/f12cbde5.html</id>
    <published>2024-05-18T13:13:33.000Z</published>
    <updated>2024-05-20T11:30:55.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-开篇词"><strong>01 开篇词</strong></h2><h3 id="3-提升-MySQL-水平的方式">3 提升 MySQL 水平的方式</h3><p>如果你没有 MySQL 的基础，建议可以看下面两本书籍，看完之后，可以简单处理一些优化：</p><ul><li>《MySQL 必知必会》：主要讲 SQL 的写法；</li><li>《深入浅出 MySQL》：比较全面的讲解了 MySQL 的基础知识，也涉及了一些优化。</li></ul><p>如果已经对 MySQL 比较熟悉了，可以看下面的书籍，你会对索引和锁以及事务等有全新的看法：</p><ul><li>《高性能 MySQL》：里面讲了很多 MySQL 优化技巧；</li><li>《MySQL 技术内幕》：讲解了很多 MySQL 原理，强力推荐给想深入学习 MySQL 的同学；</li><li>《MySQL 内核：InnoDB 存储引擎》：想深入研究 MySQL 内核及原理的可以看看；</li><li>《MySQL 运维内参》：对 MySQL 源码感兴趣，可以入手；</li><li>《MySQL Internals Manual》<a href="https://dev.mysql.com/doc/internals/en/">https://dev.mysql.com/doc/internals/en/</a> ；</li><li>《MySQL 5.7 Reference Manual》<a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a> 。</li></ul><h3 id="4-学习本专栏前的提醒">4 学习本专栏前的提醒</h3><p><strong>本专栏默认使用的 MySQL 版本为 5.7.21，事务隔离级别为 RR，表的存储引擎为 InnoDB。</strong></p><h2 id="02-快速学会分析SQL执行效率（上）"><strong>02 快速学会分析SQL执行效率（上）</strong></h2><h3 id="1-定位慢-SQL">1 定位慢 SQL</h3><h4 id="1-1-通过慢查询日志">1.1 通过慢查询日志</h4><p>MySQL 的慢查询日志用来记录在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句。</p><blockquote><p>默认情况下，<strong>慢查询日志中不会记录管理语句</strong>，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。</p><p>默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。</p></blockquote><p>使用慢查询日志，一般分为三步：</p><ol><li><p>开启慢查询日</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log <span class="operator">=</span> <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置慢查询阀值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>确定慢查询日志路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;datadir&quot;; <span class="comment">/* 慢查询日志的目录 */</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;slow_query_log_file&quot;;  <span class="comment">/* 慢查询日志的文件名 */</span></span><br></pre></td></tr></table></figure></li></ol><p><code>SHOW GLOBAL VARIABLES LIKE</code>这句命令的含义就是查询MySQL数据库的全局变量。</p><h4 id="1-2-通过-show-processlist">1.2 通过 show processlist</h4><p>有时慢查询正在执行，已经导致数据库负载偏高了，而由于慢查询还没执行完，因此慢查询日志还看不到任何语句。此时可以使用 <code>show processlist</code> 命令判断正在执行的慢查询。 <strong><code>show processlist</code> 显示哪些线程正在运行</strong>。如果有 PROCESS 权限，则可以看到所有线程。否则，只能看到当前会话的线程。</p><blockquote><p>如果不使用 FULL 关键字，在 info 字段中只显示每个语句的前 100 个字符，如果想看语句的全部内容可以使用 full 修饰（<code>show full processlist</code>）。</p></blockquote><h3 id="2-使用-explain-分析慢查询">2 使用 explain 分析慢查询</h3><p>为了便于理解，先创建两张测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE muke;           <span class="comment">/* 创建测试使用的database，名为muke */</span></span><br><span class="line">use muke;                       <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;        <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (             <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">    `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`),</span><br><span class="line">    KEY `idx_b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                    <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do                  <span class="comment">/* 对满足i&lt;=1000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i, i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                      <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;                 <span class="comment">/* 创建批量写入1000条数据到表t1的存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t1();           <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t2;    <span class="comment">/* 如果表t2存在则删除表t2 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;    <span class="comment">/* 创建表t2，表结构与t1一致 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;   <span class="comment">/* 将表t1的数据导入到t2 */</span></span><br></pre></td></tr></table></figure><p>下面尝试使用 explain 分析一条 SQL，例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">=</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>Explain 的结果各字段解释如下（加粗的列为需要重点关注的项）：</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">id</td><td style="text-align:left">查询编号</td></tr><tr><td style="text-align:left"><strong>select_type</strong></td><td style="text-align:left">查询类型：显示本行是简单还是复杂查询</td></tr><tr><td style="text-align:left">table</td><td style="text-align:left">涉及到的表</td></tr><tr><td style="text-align:left">partitions</td><td style="text-align:left">匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td style="text-align:left"><strong>type</strong></td><td style="text-align:left">本次查询的表连接类型</td></tr><tr><td style="text-align:left">possible_keys</td><td style="text-align:left">可能选择的索引</td></tr><tr><td style="text-align:left"><strong>key</strong></td><td style="text-align:left">实际选择的索引</td></tr><tr><td style="text-align:left">key_len</td><td style="text-align:left">被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">与索引比较的列</td></tr><tr><td style="text-align:left"><strong>rows</strong></td><td style="text-align:left">预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td style="text-align:left">filtered</td><td style="text-align:left">按条件筛选的行的百分比</td></tr><tr><td style="text-align:left"><strong>Extra</strong></td><td style="text-align:left">附加信息</td></tr></tbody></table><p>这里介绍几个比较重要列常包含的值：</p><h4 id="2-1-select-type">2.1 select_type</h4><table><thead><tr><th style="text-align:left">select_type 的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">SIMPLE</td><td style="text-align:left">简单查询(不使用关联查询或子查询)</td></tr><tr><td style="text-align:left">PRIMARY</td><td style="text-align:left">如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td></tr><tr><td style="text-align:left">UNION</td><td style="text-align:left">联合查询中第二个及后面的查询</td></tr><tr><td style="text-align:left">DEPENDENT UNION</td><td style="text-align:left">满足依赖外部的关联查询中第二个及以后的查询</td></tr><tr><td style="text-align:left">UNION RESULT</td><td style="text-align:left">联合查询的结果</td></tr><tr><td style="text-align:left">SUBQUERY</td><td style="text-align:left">子查询中的第一个查询</td></tr><tr><td style="text-align:left">DEPENDENT SUBQUERY</td><td style="text-align:left">子查询中的第一个查询，并且依赖外部查询</td></tr><tr><td style="text-align:left">DERIVED</td><td style="text-align:left">用到派生表的查询</td></tr><tr><td style="text-align:left">MATERIALIZED</td><td style="text-align:left">被物化的子查询</td></tr><tr><td style="text-align:left">UNCACHEABLE SUBQUERY</td><td style="text-align:left">一个子查询的结果不能被缓存，必须重新评估外层查询的每一行</td></tr><tr><td style="text-align:left">UNCACHEABLE UNION</td><td style="text-align:left">关联查询第二个或后面的语句属于不可缓存的子查询</td></tr></tbody></table><h4 id="2-2-type">2.2 type</h4><table><thead><tr><th style="text-align:left">type的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">system</td><td style="text-align:left">查询对象表只有一行数据,且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td style="text-align:left">const</td><td style="text-align:left">基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td style="text-align:left">eq_ref</td><td style="text-align:left">表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td style="text-align:left">fulltext</td><td style="text-align:left">全文检索</td></tr><tr><td style="text-align:left">ref_or_null</td><td style="text-align:left">表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td style="text-align:left">index_merge</td><td style="text-align:left">利用多个索引</td></tr><tr><td style="text-align:left">unique_subquery</td><td style="text-align:left">子查询中使用唯一索引</td></tr><tr><td style="text-align:left">index_subquery</td><td style="text-align:left">子查询中使用普通索引</td></tr><tr><td style="text-align:left">range</td><td style="text-align:left">利用索引进行范围查询</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">全索引扫描</td></tr><tr><td style="text-align:left">ALL</td><td style="text-align:left">全表扫描</td></tr></tbody></table><blockquote><p><strong>上表的这些情况，查询性能从上到下依次是最好到最差。</strong></p></blockquote><h4 id="2-3-Extra">2.3 Extra</h4><table><thead><tr><th style="text-align:left">Extra 常见的值</th><th style="text-align:left">解释</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">Using filesort</td><td style="text-align:left">将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td style="text-align:left">explain select * from t1 order by create_time;</td></tr><tr><td style="text-align:left">Using temporary</td><td style="text-align:left">需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td style="text-align:left">explain select * from t1 group by create_time;</td></tr><tr><td style="text-align:left">Using index</td><td style="text-align:left">使用覆盖索引</td><td style="text-align:left">explain select a from t1 where a=111;</td></tr><tr><td style="text-align:left">Using where</td><td style="text-align:left">使用 where 语句来处理结果</td><td style="text-align:left">explain select * from t1 where create_time=’2019-06-18 14:38:24’;</td></tr><tr><td style="text-align:left">Impossible WHERE</td><td style="text-align:left">对 where 子句判断的结果总是 false 而不能选择任何数据</td><td style="text-align:left">explain select * from t1 where 1&lt;0;</td></tr><tr><td style="text-align:left">Using join buffer (Block Nested Loop)</td><td style="text-align:left">关联查询中，被驱动表的关联字段没索引</td><td style="text-align:left">explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td style="text-align:left">Using index condition</td><td style="text-align:left">先条件过滤索引，再查数据</td><td style="text-align:left">explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td style="text-align:left">Select tables optimized away</td><td style="text-align:left">使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td style="text-align:left">explain select max(a) from t1;</td></tr></tbody></table><h2 id="03-快速学会分析SQL执行效率（下）"><strong>03 快速学会分析SQL执行效率（下）</strong></h2><h3 id="1-show-profile-分析慢查询">1 show profile 分析慢查询</h3><p>有时需要确定 SQL 到底慢在哪个环节，此时 explain 可能不好确定。在 MySQL 数据库中，通过 profile，能够更清楚地了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节。</p><blockquote><p>可以通过配置参数 profiling = 1 来启用 SQL 分析。该参数可以在全局和 session 级别来设置。</p></blockquote><p>使用 profile 分析慢查询的大致步骤如下：</p><h4 id="1-1-确定是否支持-profile">1.1 确定是否支持 profile</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure><h4 id="1-2-查看-profiling-是否关闭的">1.2 查看 profiling 是否关闭的</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-通过-set-开启-profile">1.3 通过 set 开启 profile</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="1-4-执行-SQL-语句">1.4 执行 SQL 语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h4 id="1-5-确定-SQL-的-query-id">1.5 确定 SQL 的 query id</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                         |</span><br><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">|        1 | 0.00982500 | select * from t1 where b=1000 |</span><br><span class="line">+----------+------------+-------------------------------+</span><br></pre></td></tr></table></figure><h4 id="1-6-查询-SQL-执行详情">1.6 查询 SQL 执行详情</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------+----------+</span><br><span class="line">| Status                         | Duration |</span><br><span class="line">+--------------------------------+----------+</span><br><span class="line">| starting                       | 0.001746 |</span><br><span class="line">| Executing hook on transaction  | 0.000089 |</span><br><span class="line">| starting                       | 0.000107 |</span><br><span class="line">| checking permissions           | 0.000120 |</span><br><span class="line">| Opening tables                 | 0.001553 |</span><br><span class="line">| init                           | 0.000254 |</span><br><span class="line">| System lock                    | 0.000276 |</span><br><span class="line">| optimizing                     | 0.000291 |</span><br><span class="line">| statistics                     | 0.002640 |</span><br><span class="line">| preparing                      | 0.000235 |</span><br><span class="line">| executing                      | 0.001847 |</span><br><span class="line">| end                            | 0.000133 |</span><br><span class="line">| query end                      | 0.000031 |</span><br><span class="line">| waiting for handler commit     | 0.000090 |</span><br><span class="line">| closing tables                 | 0.000110 |</span><br><span class="line">| freeing items                  | 0.000242 |</span><br><span class="line">| cleaning up                    | 0.000062 |</span><br><span class="line">+--------------------------------+----------+</span><br></pre></td></tr></table></figure><h3 id="2-trace-分析-SQL-优化器">2 trace 分析 SQL 优化器</h3><p>从前面学到了 explain 可以查看 SQL 执行计划，但是无法知道它为什么做这个决策，如果想确定多种索引方案之间是如何选择的或者排序时选择的是哪种排序模式，可以使用 trace 查看优化器如何选择执行计划。</p><p>如果需要使用，先开启 trace，设置格式为 JSON，再执行需要分析的 SQL，最后查看 trace 分析结果（在 information_schema.OPTIMIZER_TRACE 中）。</p><p>开启该功能，会对 MySQL 性能有所影响，因此只建议分析问题时临时开启。</p><p>下面一起来看下 trace 的使用方法。使用讲解 explain 时创建的表t1做实验。</p><p>首先构造如下 SQL (表示取出表 t1 中 a 的值大于 900 并且 b 的值大于 910 的数据，然后按照 a 字段排序)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">and</span> b <span class="operator">&gt;</span> <span class="number">910</span> <span class="keyword">order</span>  <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p>我们首先用 explain 分析下执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">and</span> b <span class="operator">&gt;</span> <span class="number">910</span> <span class="keyword">order</span>  <span class="keyword">by</span> a;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_a,idx_b   <span class="operator">|</span> idx_b <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">90</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>通过上面执行计划中 key 这个字段可以看出，该语句使用的是 b 字段的索引 idx_b。实际表 t1 中，a、b 两个字段都有索引，为什么条件中有这两个索引字段却偏偏选了 b 字段的索引呢？这时就可以使用 trace 进行分析。大致步骤如下：</p><ol><li><p>开启 trace</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* optimizer_trace=&quot;enabled=on&quot; 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */</span></span><br><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行需要分析的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">and</span> b <span class="operator">&gt;</span> <span class="number">910</span> <span class="keyword">order</span>  <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure></li><li><p>查看 trace 分析结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">QUERY: select * from t1 where a &gt;900 and b &gt; 910 order  by a    --SQL语句</span><br><span class="line">TRACE: &#123;</span><br><span class="line">    &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">           &quot;join_preparation&quot;: &#123;    --SQL准备阶段</span><br><span class="line">               &quot;select#&quot;: 1,</span><br><span class="line">               &quot;steps&quot;: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       &quot;expanded_query&quot;: &quot;/* select#1 */ select `t1`.`id` AS `id`,`t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`create_time` AS `create_time`,`t1`.`update_time` AS `update_time` from `t1` where ((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910)) order by `t1`.`a`&quot;</span><br><span class="line">                   &#125;</span><br><span class="line">               ] /* steps */</span><br><span class="line">           &#125; /* join_preparation */</span><br><span class="line">       &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;join_optimization&quot;: &#123;   --SQL优化阶段</span><br><span class="line">                &quot;select#&quot;: 1,</span><br><span class="line">                &quot;steps&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;condition_processing&quot;: &#123;    --条件处理</span><br><span class="line">                            &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">                            &quot;original_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;,        --原始条件</span><br><span class="line">                            &quot;steps&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                                    &quot;resulting_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;   --等值传递转换</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                                    &quot;resulting_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;       --常量传递转换</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                                    &quot;resulting_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;        --去除没有的条件后的结构</span><br><span class="line">                                &#125;</span><br><span class="line">                            ] /* steps */</span><br><span class="line">                        &#125; /* condition_processing */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">                        &#125; /* substitute_generated_columns */   --替换虚拟生成列</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;table_dependencies&quot;: [  --表依赖详情</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                                &quot;map_bit&quot;: 0,</span><br><span class="line">                                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                                ] /* depends_on_map_bits */</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* table_dependencies */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">                        ] /* ref_optimizer_key_uses */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;rows_estimation&quot;: [ --预估表的访问成本</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                                    &quot;table_scan&quot;: &#123;</span><br><span class="line">                                        &quot;rows&quot;: 1000,       --扫描行数</span><br><span class="line">                                        &quot;cost&quot;: 207.1       --成本</span><br><span class="line">                                    &#125; /* table_scan */,</span><br><span class="line">                                    &quot;potential_range_indexes&quot;: [    --分析可能使用的索引</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                                            &quot;usable&quot;: false,       --为false，说明主键索引不可用</span><br><span class="line">                                            &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;index&quot;: &quot;idx_a&quot;,      --可能使用索引idx_a</span><br><span class="line">                                            &quot;usable&quot;: true,</span><br><span class="line">                                            &quot;key_parts&quot;: [</span><br><span class="line">                                                &quot;a&quot;,</span><br><span class="line">                                                &quot;id&quot;</span><br><span class="line">                                            ] /* key_parts */</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;index&quot;: &quot;idx_b&quot;,      --可能使用索引idx_b</span><br><span class="line">                                            &quot;usable&quot;: true,</span><br><span class="line">                                            &quot;key_parts&quot;: [</span><br><span class="line">                                                &quot;b&quot;,</span><br><span class="line">                                                &quot;id&quot;</span><br><span class="line">                                            ] /* key_parts */</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ] /* potential_range_indexes */,</span><br><span class="line">                                    &quot;setup_range_conditions&quot;: [</span><br><span class="line">                                    ] /* setup_range_conditions */,</span><br><span class="line">                                    &quot;group_index_range&quot;: &#123;</span><br><span class="line">                                        &quot;chosen&quot;: false,</span><br><span class="line">                                        &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                                    &#125; /* group_index_range */,</span><br><span class="line">                                    &quot;analyzing_range_alternatives&quot;: &#123; --分析各索引的成本</span><br><span class="line">                                        &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                &quot;index&quot;: &quot;idx_a&quot;, --使用索引idx_a的成本</span><br><span class="line">                                                &quot;ranges&quot;: [</span><br><span class="line">                                                    &quot;900 &lt; a&quot;   --使用索引idx_a的范围</span><br><span class="line">                                                ] /* ranges */,</span><br><span class="line">                                                &quot;index_dives_for_eq_ranges&quot;: true, --是否使用index dive（详细描述请看下方的知识扩展）</span><br><span class="line">                                                &quot;rowid_ordered&quot;: false, --使用该索引获取的记录是否按照主键排序</span><br><span class="line">                                                &quot;using_mrr&quot;: false,   --是否使用mrr</span><br><span class="line">                                                &quot;index_only&quot;: false,    --是否使用覆盖索引</span><br><span class="line">                                                &quot;rows&quot;: 100,            --使用该索引获取的记录数</span><br><span class="line">                                                &quot;cost&quot;: 121.01,         --使用该索引的成本</span><br><span class="line">                                                &quot;chosen&quot;: true          --可能选择该索引</span><br><span class="line">                                            &#125;,</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                &quot;index&quot;: &quot;idx_b&quot;,       --使用索引idx_b的成本</span><br><span class="line">                                                &quot;ranges&quot;: [</span><br><span class="line">                                                    &quot;910 &lt; b&quot;</span><br><span class="line">                                                ] /* ranges */,</span><br><span class="line">                                                &quot;index_dives_for_eq_ranges&quot;: true,</span><br><span class="line">                                                &quot;rowid_ordered&quot;: false,</span><br><span class="line">                                                &quot;using_mrr&quot;: false,</span><br><span class="line">                                                &quot;index_only&quot;: false,</span><br><span class="line">                                                &quot;rows&quot;: 90,</span><br><span class="line">                                                &quot;cost&quot;: 109.01,</span><br><span class="line">                                                &quot;chosen&quot;: true             --也可能选择该索引</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        ] /* range_scan_alternatives */,</span><br><span class="line">                                        &quot;analyzing_roworder_intersect&quot;: &#123; --分析使用索引合并的成本</span><br><span class="line">                                            &quot;usable&quot;: false,</span><br><span class="line">                                            &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                                        &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                                    &#125; /* analyzing_range_alternatives */,</span><br><span class="line">                                    &quot;chosen_range_access_summary&quot;: &#123;  --确认最优方法</span><br><span class="line">                                        &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                                            &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                                            &quot;index&quot;: &quot;idx_b&quot;,</span><br><span class="line">                                            &quot;rows&quot;: 90,</span><br><span class="line">                                            &quot;ranges&quot;: [</span><br><span class="line">                                                &quot;910 &lt; b&quot;</span><br><span class="line">                                            ] /* ranges */</span><br><span class="line">                                        &#125; /* range_access_plan */,</span><br><span class="line">                                        &quot;rows_for_plan&quot;: 90,</span><br><span class="line">                                        &quot;cost_for_plan&quot;: 109.01,</span><br><span class="line">                                        &quot;chosen&quot;: true</span><br><span class="line">                                    &#125; /* chosen_range_access_summary */</span><br><span class="line">                                &#125; /* range_analysis */</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* rows_estimation */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;considered_execution_plans&quot;: [  --考虑的执行计划</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;plan_prefix&quot;: [</span><br><span class="line">                                ] /* plan_prefix */,</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;best_access_path&quot;: &#123;          --最优的访问路径</span><br><span class="line">                                    &quot;considered_access_paths&quot;: [ --决定的访问路径</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;rows_to_scan&quot;: 90,      --扫描的行数</span><br><span class="line">                                            &quot;access_type&quot;: &quot;range&quot;,  --访问类型：为range</span><br><span class="line">                                            &quot;range_details&quot;: &#123;</span><br><span class="line">                                                &quot;used_index&quot;: &quot;idx_b&quot;  --使用的索引为：idx_b</span><br><span class="line">                                            &#125; /* range_details */,</span><br><span class="line">                                            &quot;resulting_rows&quot;: 90,    --结果行数</span><br><span class="line">                                            &quot;cost&quot;: 127.01,          --成本</span><br><span class="line">                                            &quot;chosen&quot;: true,     --确定选择</span><br><span class="line">                                            &quot;use_tmp_table&quot;: true</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ] /* considered_access_paths */</span><br><span class="line">                                &#125; /* best_access_path */,</span><br><span class="line">                                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                                &quot;rows_for_plan&quot;: 90,</span><br><span class="line">                                &quot;cost_for_plan&quot;: 127.01,</span><br><span class="line">                                &quot;sort_cost&quot;: 90,</span><br><span class="line">                                &quot;new_cost_for_plan&quot;: 217.01,</span><br><span class="line">                                &quot;chosen&quot;: true</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* considered_execution_plans */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;attaching_conditions_to_tables&quot;: &#123;  --尝试添加一些其他的查询条件</span><br><span class="line">                            &quot;original_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;,</span><br><span class="line">                            &quot;attached_conditions_computation&quot;: [</span><br><span class="line">                            ] /* attached_conditions_computation */,</span><br><span class="line">                            &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                    &quot;attached&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ] /* attached_conditions_summary */</span><br><span class="line">                        &#125; /* attaching_conditions_to_tables */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;clause_processing&quot;: &#123;</span><br><span class="line">                            &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">                            &quot;original_clause&quot;: &quot;`t1`.`a`&quot;,</span><br><span class="line">                            &quot;items&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;item&quot;: &quot;`t1`.`a`&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ] /* items */,</span><br><span class="line">                            &quot;resulting_clause_is_simple&quot;: true,</span><br><span class="line">                            &quot;resulting_clause&quot;: &quot;`t1`.`a`&quot;</span><br><span class="line">                        &#125; /* clause_processing */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;</span><br><span class="line">                            &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">                            &quot;index_order_summary&quot;: &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;index_provides_order&quot;: false,</span><br><span class="line">                                &quot;order_direction&quot;: &quot;undefined&quot;,</span><br><span class="line">                                &quot;index&quot;: &quot;idx_b&quot;,</span><br><span class="line">                                &quot;plan_changed&quot;: false</span><br><span class="line">                            &#125; /* index_order_summary */</span><br><span class="line">                        &#125; /* reconsidering_access_paths_for_index_ordering */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;refine_plan&quot;: [          --改进的执行计划</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;pushed_index_condition&quot;: &quot;(`t1`.`b` &gt; 910)&quot;,</span><br><span class="line">                                &quot;table_condition_attached&quot;: &quot;(`t1`.`a` &gt; 900)&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* refine_plan */</span><br><span class="line">                    &#125;</span><br><span class="line">                ] /* steps */</span><br><span class="line">            &#125; /* join_optimization */</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;join_execution&quot;: &#123;             --SQL执行阶段</span><br><span class="line">                &quot;select#&quot;: 1,</span><br><span class="line">                &quot;steps&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;filesort_information&quot;: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;direction&quot;: &quot;asc&quot;,</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;field&quot;: &quot;a&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* filesort_information */,</span><br><span class="line">                        &quot;filesort_priority_queue_optimization&quot;: &#123;</span><br><span class="line">                            &quot;usable&quot;: false,             --未使用优先队列优化排序</span><br><span class="line">                            &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot;     --未使用优先队列排序的原因是没有limit</span><br><span class="line">                        &#125; /* filesort_priority_queue_optimization */,</span><br><span class="line">                        &quot;filesort_execution&quot;: [</span><br><span class="line">                        ] /* filesort_execution */,</span><br><span class="line">                        &quot;filesort_summary&quot;: &#123;           --排序详情</span><br><span class="line">                            &quot;rows&quot;: 90,                   --预计扫描的行数</span><br><span class="line">                            &quot;examined_rows&quot;: 90,          --参与排序的行数</span><br><span class="line">                            &quot;number_of_tmp_files&quot;: 0,     --排序过程中使用的临时文件数</span><br><span class="line">                            &quot;sort_buffer_size&quot;: 115056,   --sort_buffer 的大小</span><br><span class="line">                            &quot;sort_mode&quot;: &quot;&lt;sort_key, additional_fields&gt;&quot;   --排序模式（详解请看下方知识扩展）</span><br><span class="line">                        &#125; /* filesort_summary */</span><br><span class="line">                    &#125;</span><br><span class="line">                ] /* steps */</span><br><span class="line">            &#125; /* join_execution */</span><br><span class="line">        &#125;</span><br><span class="line">    ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 --该字段表示分析过程丢弃的文本字节大小，本例为0，说明没丢弃任何文本</span><br><span class="line">                    INSUFFICIENT_PRIVILEGES: 0    --查看trace的权限是否不足，0表示有权限查看trace详情</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">------------------------------------------------</span><br></pre></td></tr></table></figure></li><li><p>关闭trace</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure><p>TRACE 字段中整个文本大致分为三个过程。</p></li></ol><ul><li>准备阶段：对应文本中的 join_preparation</li><li>优化阶段：对应文本中的 join_optimization</li><li>执行阶段：对应文本中的 join_execution</li></ul><p>使用时，重点关注优化阶段和执行阶段。</p><p>由此例可以看出：</p><ul><li>在 trace 结果的 analyzing_range_alternatives 这一项可以看到：使用索引 idx_a 的成本为 121.01，使用索引 idx_b 的成本为 109.01，显然使用索引 idx_b 的成本要低些，因此优化器选择了 idx_b 索引；</li><li>在 trace 结果的 filesort_summary 这一项可以看到：排序模式为 <code>&lt;sort_key, additional_fields&gt;</code> ，表示使用的是单路排序，即一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序。</li></ul><blockquote><p>知识扩展：</p><p><strong>知识点一：MySQL 常见排序模式：</strong></p><ul><li><code>&lt; sort_key, rowid &gt;</code>双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li><code>&lt; sort_key, additional_fields &gt;</code>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li><code>&lt; sort_key, packed_additional_fields &gt;</code>打包数据排序模式：将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>三种排序模式比较：</p><p>第二种模式相对第一种模式，避免了二次回表，可以理解为用空间换时间。由于 sort buffer 有限，如果需要查询的数据比较大的话，会增加磁盘排序时间，效率可能比第一种方式更低。</p><p>MySQL 提供了一个参数：max_length_for_sort_data，当”排序的键值对大小” &gt; max_length_for_sort_data 时，MySQL 认为磁盘外部排序的 IO 效率不如回表的效率，会选择第一种排序模式；否则，会选择第二种模式。</p><p>第三种模式主要解决变长字符数据存储空间浪费的问题。</p><p><strong>知识点二：优化器在估计符合条件的行数时有两个选择：</strong></p><ul><li>index diver：dive 到 index 中利用索引完成元组数的估算；特点是速度慢，但可以得到精确的值；</li><li>index statistics：使用索引的统计数值，进行估算；特点是速度快，但是值不一定准确。</li></ul></blockquote><h3 id="3-总结">3 总结</h3><p>对比一下三种分析 SQL 方法的特点：</p><ul><li>explain：获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等；</li><li>profile：可以清楚了解到SQL到底慢在哪个环节；</li><li>trace：查看优化器如何选择执行计划，获取每个可能的索引选择的代价。</li></ul><h2 id="04-条件字段有索引，为什么查询也这么慢"><strong>04 条件字段有索引，为什么查询也这么慢?</strong></h2><p>下面会讲解几种有索引但是查询不走索引导致查询慢的场景。</p><h3 id="1-函数操作">1 函数操作</h3><h4 id="1-1-验证对条件字段做函数操作是否能走索引">1.1 验证对条件字段做函数操作是否能走索引</h4><p>首先创建测试表，建表及数据写入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">use muke;                       <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;        <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (             <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `a` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">    KEY `idx_b` (`b`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">    KEY `idx_c` (`c`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                    <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do                 <span class="comment">/* 对满足i&lt;=10000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i,i);  <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                        <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_t1();                    <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> c <span class="operator">=</span> <span class="string">&#x27;2019-05-22 00:00:00&#x27;</span>;  <span class="comment">/* 更新表t1的c字段，值都为&#x27;2019-05-22 00:00:00&#x27; */</span></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> c <span class="operator">=</span> <span class="string">&#x27;2019-05-21 00:00:00&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10000</span>;  <span class="comment">/* 将id为10000的行的c字段改为与其它行都不一样的数据，以便后面实验使用 */</span></span><br></pre></td></tr></table></figure><p>对于上面创建的测试表，比如要查询测试表 t1 单独某一天的所有数据，SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="type">date</span>(c) <span class="operator">=</span><span class="string">&#x27;2019-05-21&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以使用第 2 节学习的 explain 来分析这条SQL的执行计划，分析结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>查看图中的执行计划，type 为 ALL，key 字段结果为 NULL，因此知道该 SQL 是没走索引的全表扫描。</p><p>原因：对条件字段做函数操作走不了索引。</p><h4 id="1-2-对条件字段做函数操作不走索引的原因">1.2 对条件字段做函数操作不走索引的原因</h4><p>该例中 c 字段普通索引的 B+ 索引树如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518215240866.png" alt="image-20240518215240866"></p><p>根据上面结构可以看到，索引树中存储的是列的实际值和主键值。如果拿 ‘2019-05-21’ 去匹配，将无法定位到索引树中的值。因此放弃走索引，而选择全表扫描。</p><h4 id="1-3-函数操作的-SQL-优化">1.3 函数操作的 SQL 优化</h4><p>因此如果需要优化的话，改成 c 字段实际值相匹配的形式。因为 SQL 的目的是查询 2019-05-21 当天所有的记录，因此可以改成范围查询，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> c<span class="operator">&gt;=</span><span class="string">&#x27;2019-05-21 00:00:00&#x27;</span> <span class="keyword">and</span> c<span class="operator">&lt;=</span><span class="string">&#x27;2019-05-21 23:59:59&#x27;</span>;</span><br></pre></td></tr></table></figure><p>再用 explain 分析下执行计划的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_c         | idx_c | 5       | NULL |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><h3 id="2-隐式转换"><strong>2 隐式转换</strong></h3><blockquote><p>什么时隐式转换？</p><p>当操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。某些转换是隐式的。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html">关于隐式转换详情请参考MySQL官方手册</a></p></blockquote><p>隐式转换估计是很多 MySQL 使用者踩过的坑，比如联系方式字段。由于有时电话号码带加、减等特殊字符，有时需要以 0 开头，因此一般设计表时会使用 varchar 类型存储，并且会经常做为条件来查询数据，所以会添加索引。</p><p>而有时遇到需要按照手机号码条件（比如 11111111111）去查询数据时，因为查询者看到条件是一串数字，而忽视表中对应手机号字段是 varchar 类型，因此写出了如下不合理的SQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,tele_phone from user_info <span class="built_in">where</span> tele_phone =11111111111; /* SQL 1 */</span><br></pre></td></tr></table></figure><h4 id="2-2-验证隐式转换是否能走索引">2.2 验证隐式转换是否能走索引</h4><p>实验过程分为：先创建测试表并写入数据；测试隐式转换的查询并查看执行计划；测试正常查询，再查看执行计划。</p><p>比如我们要查询 a 字段等于 1000 的值，SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>看下 explain 结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_a         | NULL | NULL    | NULL | 10302 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>通过 type 这列可以看到是最差的情况 ALL（全表扫描）， 通过 key 这列可以看到没走 a 字段的索引，通过 rows 这列可以看到进行了全表扫描。</p><h4 id="2-3-不走索引的原因">2.3 不走索引的原因</h4><p>a 字段类型是 varchar(20)，而语句中 a 字段条件值没加单引号，导致 MySQL 内部会先把a转换成int型，再去做判断，相当于实际执行的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="built_in">cast</span>(a <span class="keyword">as</span> signed <span class="type">int</span>) <span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>因此又回到上面说的：<strong>对索引字段做函数操作时，优化器会放弃使用索引</strong>。</p><h4 id="2-4-隐式转换的-SQL-优化">2.4 隐式转换的 SQL 优化</h4><p>索引字符串列条件添加单引号，查看执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;1000&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 83      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>通过 type 这列，可以看到是 ref（基于普通索引的等值查询，比 ALL 性能好很多），通过key这列，可以看到已经走了 a 字段的索引，通过rows这列可以看到通过索引查询后就扫描了一行。</p><h3 id="3-模糊查询"><strong>3 模糊查询</strong></h3><h4 id="3-1-分析模糊查询">3.1 分析模糊查询</h4><p>很多时候我们想根据某个字段的某几个关键字查询数据，比如会有如下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;%1111%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>实际这种情况无法走索引，看下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |    11.11 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>重点留意type、key、rows、Extra，发现是全表扫描。</p><h4 id="3-2-模糊查询优化建议">3.2 模糊查询优化建议</h4><p>修改业务，让模糊查询必须包含条件字段前面的值，然后落到数据库的查询为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;1111%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种写法是可以用到索引的，explain分析如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_a         | idx_a | 83      | NULL |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><blockquote><p>如果条件只知道中间的值，需要模糊查询去查，那就建议使用<strong>ElasticSearch</strong>或其它搜索服务器。</p></blockquote><h3 id="4-范围查询"><strong>4 范围查询</strong></h3><h4 id="4-1-构造不能使用索引的范围查询">4.1 构造不能使用索引的范围查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span><span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>看下这条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_b         | NULL | NULL    | NULL | 10302 |    97.07 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>发现并不能走b字段的索引。</p><p>原因：优化器会根据检索比例、表大小、I/O块大小等进行评估是否使用索引。比如单次查询的数据量过大，优化器将不走索引。</p><h4 id="4-2-优化范围查询">4.2 优化范围查询</h4><p>降低单次查询范围，分多次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span><span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1001</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看执行计划（就只看第一条的，第二条同理）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_b         | idx_b | 5       | NULL | 1000 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><p>因此，降低查询范围后，能正常使用索引。</p><blockquote><p>经验分享：</p><p>实际这种范围查询而导致使用不了索引的场景经常出现，比如按照时间段抽取全量数据，每条SQL抽取一个月的；或者某张业务表历史数据的删除。遇到此类操作时，<strong>应该在执行之前对SQL做explain分析，确定能走索引，再进行操作</strong>，否则不但可能导致操作缓慢，在做更新或者删除时，甚至会导致表所有记录锁住，十分危险。</p></blockquote><h3 id="5-计算操作">5 计算操作</h3><h4 id="5-1-查询条件进行计算操作的-SQL-执行效率">5.1 查询条件进行计算操作的 SQL 执行效率</h4><p>有时我们与有对条件字段做计算操作的需求，在使用 SQL 查询时，就应该小心了。先看下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="number">-1</span> <span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>查看执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><blockquote><p>原因：对索引字段做运算将使用不了索引。</p></blockquote><h4 id="5-2-计算操作的-SQL-优化">5.2 计算操作的 SQL 优化</h4><p>将计算操作放在等号后面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b <span class="operator">=</span><span class="number">1000</span> <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查看执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>发现将计算操作放在等号后，能正常使用索引。</p><blockquote><p>经验分享：</p><p><strong>一般需要对条件字段做计算时，建议通过程序代码实现，而不是通过MySQL实现。如果在MySQL中计算的情况避免不了，那必须把计算放在等号后面。</strong></p></blockquote><h3 id="6-总结">6 总结</h3><p>在写 SQL 时应该注意这些点：</p><ul><li>应该避免隐式转换</li><li>like查询不能以%开头</li><li>范围查询时，包含的数据比例不能太大</li><li>不建议对条件字段做运算及函数操作</li></ul><p>本节涉及到的一些SQL优化如下图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518215925762.png" alt="image-20240518215925762"></p><h2 id="05-如何优化数据导入？"><strong>05 如何优化数据导入？</strong></h2><h3 id="1-一次插入多行的值">1 一次插入多行的值</h3><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li>连接：30%</li><li>向服务器发送查询：20%</li><li>解析查询：20%</li><li>插入行：10% * 行的大小</li><li>插入索引：10% * 索引数</li><li>结束：10%</li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。</p><h3 id="2-关闭自动提交">2 关闭自动提交</h3><p>Autocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。</p><h3 id="3-参数调整">3 参数调整</h3><p>影响MySQL写入速度的主要两个参数：innodb_flush_log_at_trx_commit、sync_binlog。</p><h4 id="3-1-参数解释">3.1 参数解释</h4><p>innodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略，有0 、1和2三种值。</p><ul><li>0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。</li></ul><p>sync_binlog：控制binlog的刷盘时机，可配置0、1或者大于1的数字。</p><ul><li>0：二进制日志从不同步到磁盘，依赖OS刷盘机制；</li><li>1：二进制日志每次提交都会刷盘；</li><li>n(n&gt;1) : 每n次提交落盘一次。</li></ul><h2 id="06-让order-by、group-by查询更快"><strong>06 让order by、group by查询更快</strong></h2><h3 id="1-order-by-原理">1 order by 原理</h3><p>在优化 order by 语句之前，需要先了解 MySQL 中排序的相关知识点和原理，为了方便讲解过程举例说明，首先创建一张测试表，建表及数据写入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">use muke;                 <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;  <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (       <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `d` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a_b` (`a`,`b`),</span><br><span class="line">    KEY `idx_c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8mb4 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                  <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                        <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do         <span class="comment">/* 对满足i&lt;=10000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b,c) <span class="keyword">values</span>(i,i,i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                       <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_t1();               <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">where</span> id <span class="operator">&gt;</span><span class="number">9000</span>;    <span class="comment">/* 将id大于9000的行的a字段更新为1000 */</span></span><br></pre></td></tr></table></figure><h4 id="1-1-MySQL-的排序方式">1.1 MySQL 的排序方式</h4><p>按照排序原理分，MySQL 排序方式分两种：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行的排序</li></ul><blockquote><p><strong>怎么确定某条排序的 SQL 所使用的排序方式？</strong></p><p>使用 explain 来查看该排序 SQL 的执行计划，重点关注 Extra 字段：</p><p>如果该字段里显示是 Using index，则表示是通过有序索引直接返回有序数据。</p><p>如果该字段里显示是 Using filesort，则表示该 SQL 是通过 Filesort 进行的排序。</p></blockquote><h4 id="1-2-Filesort-是在内存中还是在磁盘中完成排序的？">1.2 Filesort 是在内存中还是在磁盘中完成排序的？</h4><p>MySQL 中的 Filesort 并不一定是在磁盘文件中进行排序的，也有可能在内存中排序，内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小。</p><ul><li>如果 “排序的数据大小” &lt; sort_buffer_size: 内存排序</li><li>如果 “排序的数据大小” &gt; sort_buffer_size: 磁盘排序</li></ul><blockquote><p><strong>怎么确定使用 Filesort 排序的 SQL 是在内存还是在磁盘中进行的排序操作？</strong></p><p>此时就可以使用 trace 进行分析，重点关注 number_of_tmp_files，如果等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序；如果大于0，则表示排序过程中使用了临时文件。</p></blockquote><h4 id="1-3-Filesort-下的排序模式">1.3 Filesort 下的排序模式</h4><p>Filesort 下的排序模式有三种，具体介绍如下：（参考<a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html">《MySQL 5.7 Reference Manual》8.2.1.14 ORDER BY Optimization</a>）</p><ul><li><code>&lt; sort_key, rowid &gt;</code>双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li><code>&lt; sort_key, additional_fields &gt;</code>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li><code>&lt; sort_key, packed_additional_fields &gt;</code>打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>因为打包数据排序模式是单路排序的一种升级模式，因此重点探讨双路排序和单路排序的区别。MySQL 通过比较系统变量 max_length_for_sort_data 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p><ul><li>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 <code>&lt; sort_key, additional_fields &gt;</code>排序模式；</li><li>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 <code>&lt;sort_key, rowid&gt;</code> 排序模式。</li></ul><p>为什么要添加 max_length_for_sort_data 这个参数让排序使用不同的排序模式呢？</p><p>接下来，我们一起分析下 max_length_for_sort_data 的重要性。比如下面这条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,c,d <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>我们先看<strong>单路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 条件的主键 id</li><li>根据主键 id 取出整行，<strong>取出 a、c、d 三个字段的值，存入 sort_buffer 中</strong></li><li>从索引 a 找到下一个满足 a = 1000 条件的主键 id</li><li>重复步骤 2、3 直到不满足 a = 1000</li><li>对 sort_buffer 中的数据按照字段 d 进行排序</li><li>返回结果给客户端</li></ol><p>我们再看下<strong>双路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 的主键 id</li><li>根据主键 id 取出整行，<strong>把排序字段 d 和主键 id 这两个字段放到 sort buffer 中</strong></li><li>从索引 a 取下一个满足 a = 1000 记录的主键 id</li><li>重复 3、4 直到不满足 a = 1000</li><li>对 sort_buffer 中的字段 d 和主键 id 按照字段 d 进行排序</li><li>遍历排序好的 id 和字段 d，按照 id 的值回到原表中取出 a、c、d 三个字段的值返回给客户端</li></ol><p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p><h3 id="2-order-by-优化">2 order by 优化</h3><h4 id="2-1-添加合适索引">2.1 添加合适索引</h4><h5 id="2-1-1-排序字段添加索引">2.1.1 排序字段添加索引</h5><p>首先我们看下对 d 字段（没有索引）进行排序的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> d,id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br></pre></td></tr></table></figure><p>发现使用的是 filesort（关注 Extra 字段）。</p><p>再看些对 c 字段（有索引）进行排序的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> c,id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> c;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_c | 5       | NULL | 10236 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>可以看到，根据有索引的字段排序，在 Extra 中显示的就为 Using index，表示使用的是索引排序。</p><p><strong>因此可以在排序字段上添加索引来优化排序语句。</strong></p><h5 id="2-1-2-多个字段排序优化">2.1.2 多个字段排序优化</h5><p>有时面对的需求是要对多个字段进行排序，而这种情况应该怎么优化或者设计索引呢？首先看下面例子：</p><p>对 a、c 两个字段进行排序的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,c <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,c;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br></pre></td></tr></table></figure><p>观察 Extra 字段，发现使用的是 filesort。</p><p>再看对 a、b（a、b 两个字段有联合索引）两个字段进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,b;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>发现使用的是索引排序。</p><p>多个字段排序的情况，如果要通过添加索引优化，得注意排序字段的顺序与联合索引中列的顺序要一致。</p><p>因此，<strong>如果多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句。</strong></p><h5 id="2-1-3-先等值查询再排序的优化">2.1.3 先等值查询再排序的优化</h5><p>我们更多的情况是会先根据某个字段条件查出一部分数据，然后再排序，而这类 SQL 应该如果优化呢？看下面的实验：</p><p>表 t1中，根据 a=1000 过滤数据再根据 d 字段排序的执行计划如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,d <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+</span><br></pre></td></tr></table></figure><p>可以在 Extra 字段中看到 “Using filesort”，说明使用的是 filesort 排序。</p><p>再看下根据 a=1000 过滤数据在根据 b 字段排序的执行计划（a、b 两个字段有联合索引）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>可以在 Extra 字段中看到”Using index”，说明使用的是索引排序。</p><p>因此，对于先等值查询再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化此类排序语句。</p><h4 id="2-2-去掉不必要的返回字段">2.2 去掉不必要的返回字段</h4><p>有时，我们其实并不需要查询出所有字段，但是可能因为习惯问题，就写成查所有字段的数据了。我们看下下面两条 SQL 的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,b;           <span class="comment">/* 根据a和b字段排序查出所有字段的值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,b;      <span class="comment">/* 根据a和b字段排序查出id,a,b字段的值 */</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 order by a,b;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id,a,b from t1 order by a,b;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>这个例子中，查询所有字段不走索引的原因是：扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><h4 id="2-3-修改参数">2.3 修改参数</h4><p>在本节一开始讲 order by 原理的时候，接触到两个跟排序有关的参数：max_length_for_sort_data、sort_buffer_size。</p><ul><li>max_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值，让优化器优先选择全字段排序。当然不能设置过大，可能会导致 CPU 利用率过低或者磁盘 I/O 过高；</li><li>sort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。但不能设置过大，可能导致数据库服务器 SWAP。</li></ul><h4 id="2-4-几种无法利用索引排序的情况">2.4 几种无法利用索引排序的情况</h4><h5 id="2-4-1-使用范围查询再排序">2.4.1 使用范围查询再排序</h5><p>在本节 2.1.3 中介绍过，对于先等值过滤再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化；但是如果联合索引中前面的字段使用了范围查询，对后面的字段排序是否能用到索引排序呢？下面我们通过实验验证一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">9000</span> <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_a_b       | idx_a_b | 5       | NULL |    1 |   100.00 | Using where; Using index; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br></pre></td></tr></table></figure><p>这里对上面执行计划做下解释：首先条件 a&gt;9000 使用了索引（关注 key 字段对应的值为 idx_a_b）；在 Extra 中，看到了”Using filesort”，表示使用了 filesort 排序，并没有使用索引排序。所以联合索引中前面的字段使用了范围查询，对后面的字段排序使用不了索引排序。</p><p>原因是：a、b 两个字段的联合索引，对于单个 a 的值，b 是有序的。而对于 a 字段的范围查询，也就是 a 字段会有多个值，取到 a，b 的值 b 就不一定有序了，因此要额外进行排序。联合索引结果如下图（为了便于理解，该图的值与上面所创建的表 t1 数据不一样）：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518221159176.png" alt="image-20240518221159176"></p><p><strong>使用范围查询再排序</strong></p><p>如上图所示，对于有 a、b 两个字段联合索引的表，如果对 a 字段范围查询，b 字段整体来看是无序的（如上图 b 的值为：1，2，3，1，2，3······）。</p><h5 id="2-4-2-ASC-和-DESC-混合使用将无法使用索引">2.4.2 ASC 和 DESC 混合使用将无法使用索引</h5><p>对联合索引多个字段同时排序时，如果一个是顺序，一个是倒序，则使用不了索引，如下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">asc</span>,b <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra                       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+</span><br></pre></td></tr></table></figure><h3 id="3-group-by-优化">3 group by 优化</h3><p>默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。</p><h3 id="4-总结">4 总结</h3><p>首先说到 MySQL 的两种排序方式：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行排序</li></ul><p>建议优先考虑索引排序。</p><p>而Filesort又分为两种：</p><ul><li>内存排序</li><li>磁盘文件排序</li></ul><p>优先考虑内存排序。</p><p>Filesort 有三种排序模式：</p><ul><li><code>&lt; sort_key, rowid &gt;</code></li><li><code>&lt; sort_key, additional_fields &gt;</code></li><li><code>&lt; sort_key, packed_additional_fields &gt;</code></li></ul><p><strong>order by 语句的优化，这个是本节的重点：</strong></p><ul><li>通过添加合适索引</li><li>去掉不必要的返回字段</li><li>调整参数：主要是 max_length_for_sort_data 和 sort_buffer_size</li><li>避免几种无法利用索引排序的情况</li></ul><p>最后说到 group by 语句的优化，如果只要分组，没有排序需求的话，可以加 order by null 禁止排序。</p><h2 id="07-换种思路写分页查询"><strong>07 换种思路写分页查询</strong></h2><p>很多时候，业务上会有分页操作的需求，对应的 SQL 类似下面这条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> t1 limit <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>表示从表 t1 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。本节内容就一起研究下，是否有办法去优化分页查询。</p><p>为了方便验证，首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use muke;                       <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;        <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (             <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">    `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`),</span><br><span class="line">    KEY `idx_b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                    <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do                  <span class="comment">/* 对满足i&lt;=100000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i, i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                      <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;                 <span class="comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t1();           <span class="comment">/* 运行存储过程insert_t1 */</span></span><br></pre></td></tr></table></figure><h3 id="1-根据自增且连续主键排序的分页查询">1 根据自增且连续主键排序的分页查询</h3><p>首先来看一个根据自增且连续主键排序的分页查询的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 limit <span class="number">9000</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>该 SQL 表示查询从第 9001 开始的两行数据，没添加单独 order by，表示通过主键排序。我们再看表 t1，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 9001开始的两行数据，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">&gt;</span><span class="number">9000</span> limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>查询的结果是一致的。我们再对比一下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 limit 9000,2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t1 where id &gt;9000 limit 2;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1000 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>原 SQL 中 key 字段为 NULL，表示未走索引，rows 显示 9963，表示扫描的行数 9963行；</p><p>改写后的 SQL key 字段为 PRIMARY，表示走了主键索引，扫描了1000行。</p><p>显然改写后的 SQL 执行效率更高。</p><p>另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：</p><ul><li>主键自增且连续</li><li>结果是按照主键排序的</li></ul><h3 id="2-查询根据非主键字段排序的分页查询">2 查询根据非主键字段排序的分页查询</h3><p>再看一个根据非主键字段排序的分页查询，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">9000</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>看下这条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure><p>发现并没有使用 a 字段的索引（key 字段对应的值为 null），具体原因：<strong>扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p><p>知道不走索引的原因，那么怎么优化呢？</p><p>其实关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL 改写如下（这里参考了《深入浅出 MySQL》18.4.7 优化分页查询）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 f <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">9000</span>,<span class="number">2</span>)g <span class="keyword">on</span> f.id <span class="operator">=</span> g.id;</span><br></pre></td></tr></table></figure><p>看下这条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 9002 |   100.00 | NULL        |</span><br><span class="line">|  1 | PRIMARY     | f          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | g.id |    1 |   100.00 | NULL        |</span><br><span class="line">|  2 | DERIVED     | t1         | NULL       | index  | NULL          | idx_a   | 5       | NULL | 9002 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p><h2 id="08-Join语句可以这样优化"><strong>08 Join语句可以这样优化</strong></h2><p>这个部分可以看《MySQL实战45讲》</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE muke; <span class="comment">/* 创建测试使用的database，名为muke */</span></span><br><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1; <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` ( <span class="comment">/* 创建表t1 */</span></span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1() <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do <span class="comment">/* 对满足i&lt;=10000的值进行while循环 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i, i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t1(); <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t2; <span class="comment">/* 如果表t2存在则删除表t2 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1; <span class="comment">/* 创建表t2，表结构与t1一致 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 limit <span class="number">100</span>; <span class="comment">/* 将表t1的前100行数据导入到t2 */</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518222859201.png" alt="image-20240518222859201"></p><h3 id="1-关联查询的算法">1 关联查询的算法</h3><p>MySQL 使用以下两种嵌套循环算法或它们的变体在表之间执行连接（参考 《<a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html">MySQL 5.7 Reference Manual》8.2.1.6 Nested-Loop Join Algorithms</a>）：</p><ul><li>Nested-Loop Join 算法</li><li>Block Nested-Loop Join 算法</li></ul><p>另外还有一种算法 Batched Key Access，其实算对 Nested-Loop Join 算法的一种优化。</p><h4 id="1-1-Nested-Loop-Join-算法">1.1 Nested-Loop Join 算法</h4><p>一个简单的 Nested-Loop Join(NLJ) 算法一次一行循环地从第一张表（称为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行，然后取出两张表的结果合集。</p><p>我们试想一下，如果在被驱动表中这个关联字段没有索引，那么每次取出驱动表的关联字段在被驱动表查找对应的数据时，都会对被驱动表做一次全表扫描，成本是非常高的（比如驱动表数据量是 m，被驱动表数据量是 n，则扫描行数为 m * n ）。</p><p>好在 MySQL 在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join，等下会细说这个算法。我们先来看下在有索引情况的情况下，使用 Nested-Loop Join 的场景（称为：Index Nested-Loop Join）。</p><p>因为 MySQL 在关联字段有索引时，才会使用 NLJ，因此本节后面的内容所用到的 NLJ 都表示 Index Nested-Loop Join。</p><p>如下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.a;       <span class="comment">/* sql1 */</span></span><br></pre></td></tr></table></figure><blockquote><p>表 t1 和表 t2 中的 a 字段都有索引。</p></blockquote><p>怎么确定这条 SQL 使用的是 NLJ 算法？</p><p>我们先来看下 sql1 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | NULL        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>从执行计划中可以看到这些信息：</p><ul><li>驱动表是 t2，被驱动表是 t1。原因是：explain 分析 join 语句时，在第一行的就是驱动表；选择 t2 做驱动表的原因：如果没固定连接方式（比如没加 straight_join）优化器会优先选择小表做驱动表。<strong>所以使用 inner join 时，前面的表并不一定就是驱动表。</strong></li><li>使用了 NLJ。原因是：一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer （***）；则表示使用的 join 算法是 NLJ。</li></ul><p>在这个过程中会读取 t2 表的所有数据，因此这里扫描了 100 行，然后遍历这 100 行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行，这里也扫描了 100 行。因此整个过程扫描了 200 行。</p><p>在前面，我们有说到：如果被驱动表的关联字段没索引，就会使用 Block Nested-Loop Join(简称：BNL)，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join呢？下面就一起分析下：</p><h4 id="1-2-Block-Nested-Loop-Join-算法">1.2 Block Nested-Loop Join 算法</h4><p>Block Nested-Loop Join(BNL) 算法的思想是：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。</p><p>我们一起看看下面这条 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b <span class="operator">=</span> t2.b;       <span class="comment">/* sql2 */</span></span><br></pre></td></tr></table></figure><blockquote><p>表 t1 和表 t2 中的 b 字段都没有索引</p></blockquote><p>看下执行计划</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br></pre></td></tr></table></figure><p>在 Extra 发现 Using join buffer (Block Nested Loop)，这个就说明该关联查询使用的是 BNL 算法。</p><p>我们再看下 sql2 的执行流程：</p><ol><li>把 t2 的所有数据放入到 join_buffer 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li><li>返回满足 join 条件的数据</li></ol><p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</p><p>下面我们来回答上面提出的一个问题：</p><p>如果被驱动表的关联字段没索引，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join 呢？</p><p>在被驱动表的关联字段没索引的情况下，比如 sql2：</p><p>如果使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。</p><p>如果使用 BNL，那么磁盘扫描是 100 + 10000=10100 次，在内存中判断 100 * 10000 = 100万次。</p><p>显然后者磁盘扫描的次数少很多，因此是更优的选择。因此对于 MySQL 的关联查询，如果被驱动表的关联字段没索引，会使用 BNL 算法。</p><h4 id="1-3-Batched-Key-Access-算法">1.3 Batched Key Access 算法</h4><p>NLJ 的关键思想是：被驱动表的关联字段有索引。</p><p>BNL 的关键思想是：把驱动表的数据批量提交一部分放到 join_buffer 中。</p><p>从 MySQL 5.6 开始，确实出现了这种集 NLJ 和 BNL 两种算法优点于一体的新算法：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html">Batched Key Access(BKA)</a>。</p><p>其原理是：</p><ol><li>将驱动表中相关列放入 join_buffer 中</li><li>批量将关联字段的值发送到 Multi-Range Read(MRR) 接口</li><li>MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作</li><li>返回结果给客户端</li></ol><blockquote><p><strong>这里补充下 MRR 相关知识：</strong></p><p>当表很大并且没有存储在缓存中时，使用辅助索引上的范围扫描读取行可能导致对表有很多随机访问。</p><p>而 Multi-Range Read 优化的设计思路是：查询辅助索引时，对查询结果先按照主键进行排序，并按照主键排序后的顺序，进行顺序查找，从而减少随机访问磁盘的次数。</p><p>使用 MRR 时，explain 输出的 Extra 列显示的是 Using MRR。</p><p>optimizer_switch 中 mrr_cost_based 参数的值会影响 MRR。</p><p>如果 mrr_cost_based=on，表示优化器尝试在使用和不使用 MRR 之间进行基于成本的选择。</p><p>如果 mrr_cost_based=off，表示一直使用 MRR。</p><p>更多 MRR 信息请参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html%E3%80%82">https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html。</a></p></blockquote><p>下面尝试开启 BKA ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里对上面几个参数做下解释：</p><ul><li>mrr=on 开启 mrr</li><li>mrr_cost_based=off 不需要优化器基于成本考虑使用还是不使用 MRR，也就是一直使用 MRR</li><li>batched_key_access=on 开启 BKA</li></ul><p>然后再看 sql1 的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.a;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra                                  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where                            |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+</span><br></pre></td></tr></table></figure><p>在 Extra 字段中发现有 Using join buffer (Batched Key Access)，表示确实变成了 BKA 算法。</p><h3 id="2-优化关联查询">2 优化关联查询</h3><p>通过上面的知识点，我们知道了关联查询的一些算法，下面一起来讨论下关联查询的优化：</p><h4 id="2-1-关联字段添加索引">2.1 关联字段添加索引</h4><p>通过上面的内容，我们知道了 BNL、NLJ 和 BKA 的原理，<strong>因此建议在被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。</strong></p><h4 id="2-2-小表做驱动表">2.2 小表做驱动表</h4><p>前面说到，Index Nested-Loop Join 算法会读取驱动表的所有数据，首先扫描的行数是驱动表的总行数（假设为 n），然后遍历这 n 行数据中关联字段的值，根据驱动表中关联字段的值索引扫描被驱动表中的对应行，这里又会扫描 n 行，因此整个过程扫描了 2n 行。当使用 Index Nested-Loop Join 算法时，扫描行数跟驱动表的数据量成正比。所以<strong>在写 SQL 时，如果确定被关联字段有索引的情况下，建议用小表做驱动表。</strong></p><p>我们来看下以 t2 为驱动表的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> t2.a <span class="operator">=</span> t1.a;</span><br></pre></td></tr></table></figure><p>这里使用 straight_join 可以固定连接方式，让前面的表为驱动表。</p><h4 id="2-3-临时表">2.3 临时表</h4><p>多数情况我们可以通过在被驱动表的关联字段上加索引来让 join 使用 NLJ 或者 BKA，但有时因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源，那么有什么办法优化呢？</p><p>这里提供一种创建临时表的方法。比如下面这条关联查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b<span class="operator">=</span> t2.b;</span><br></pre></td></tr></table></figure><p>看下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br></pre></td></tr></table></figure><p>由于表 t1 和表 t2 的字段 b都没索引，因此使用的是效率比较低的 BNL 算法。</p><p>现在用临时表的方法对这条 SQL 进行优化：</p><p>首先创建临时表 t1_tmp，表结构与表 t1 一致，只是在关联字段 b 上添加了索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> `t1_tmp` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">    `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`),</span><br><span class="line">    KEY `idx_b` (b)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB ;</span><br></pre></td></tr></table></figure><p>把 t1 表中的数据写入临时表 t1_tmp 中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1_tmp <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><p>执行 join 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1_tmp <span class="keyword">join</span> t2 <span class="keyword">on</span> t1_tmp.b<span class="operator">=</span> t2.b;</span><br></pre></td></tr></table></figure><p>我们再看下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t2     | NULL       | ALL  | NULL          | NULL  | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1_tmp | NULL       | ref  | idx_b         | idx_b | 5       | muke.t2.b |    1 |   100.00 | NULL        |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>Extra 没出现 “Block Nested Loop”，说明使用的是 Index Nested-Loop Join，并且扫描行数也大大降低了。</p><p><strong>所以当遇到 BNL 的 join 语句，如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询</strong></p><h2 id="09-为何count-这么慢"><strong>09 为何count(*)这么慢?</strong></h2><h3 id="1-重新认识-count">1 重新认识 count()</h3><h4 id="1-1-count-a-和-count-的区别">1.1 count(a) 和 count(*) 的区别</h4><p>当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。</p><p>而 <code>count(*)</code> 无论是否包含空值，都会统计。</p><h4 id="1-2-MyISAM-引擎和-InnoDB-引擎-count-的区别">1.2 MyISAM 引擎和 InnoDB 引擎 count(*) 的区别</h4><p>对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 <code>count(*)</code> 将会非常快。因为 MyISAM 引擎会把表的总行数存在磁盘上。</p><p>首先我们看下对 t2 表（存储引擎为 MyISAM）不带 where 子句做 <code>count(*)</code> 的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t2;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br></pre></td></tr></table></figure><p>在 Extra 字段发现 “Select tables optimized away” 关键字，表示是从 MyISAM 引擎维护的准确行数上获取到的统计值。</p><p>而 InnoDB 并不会保留表中的行数，<strong>因为并发事务可能同时读取到不同的行数</strong>。所以执行 <code>count(*)</code> 时都是临时去计算的，会比 MyISAM 引擎慢很多。</p><p>我们看下对 t1 表（存储引擎为 InnoDB）执行 <code>count(*)</code> 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select count(*) from t1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>发现使用的是 b 字段的索引 idx_b，并且扫描行数是10109，表示会遍历 b 字段的索引树去计算表的总量。</p><p>对比 MyISAM 引擎和 InnoDB 引擎 <code>count(*)</code> 的区别，可以知道：</p><ul><li>MyISAM 会维护表的总行数，放在磁盘中，如果有 <code>count(*)</code> 的需求，直接返回这个数据</li><li>但是 InnoDB 就会去遍历普通索引树，计算表数据总量</li></ul><p>在上面这个例子，InnoDB 表 t1 在执行 <code>count(*)</code> 时，为什么会走 b 字段的索引而不是走主键索引呢？下面我们分析下：</p><h4 id="1-3-MySQL-5-7-18-前后-count-的区别">1.3 MySQL 5.7.18 前后 count(*) 的区别</h4><p>在 MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 <code>count(*)</code> 语句。</p><p>从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句。如果不存在二级索引，则扫描聚簇索引。但是，如果索引记录不完全在缓存池中的话，处理 <code>count(*)</code> 也是比较久的。</p><p>新版本为什么会使用二级索引来处理 <code>count(*)</code> 语句呢？</p><p>原因是 InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 <code>count (*)</code> 快。</p><h4 id="1-4-count-1-比-count-快吗？">1.4 count(1) 比 count(*) 快吗？</h4><p>在前面我们知道 <code>count(*)</code> 无论是否包含空值，所有结果都会统计。</p><p>而 count(1)中的 1 是恒真表达式，因此也会统计所有结果。</p><p>所以 count(1) 和 <code>count(*)</code> 统计结果没差别。</p><p>我们来对比 count(1) 和 count(* ) 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select count(1) from t1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from t1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>执行计划一样，所以 count(1) 并不比 count(*) 快。</p><h3 id="2-哪些方法可以加快-count">2 哪些方法可以加快 count()</h3><h4 id="2-1-show-table-status">2.1 show table status</h4><p>有时，我们只需要知道某张表的大概数据量，这种情况就可以使用 show table status，具体用法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;t1&#x27;</span>\G</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Rows: 10147</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Rows 这列就表示这张表的行数。这种方式获取 InnoDB 表的行数非常快。</p><p><strong>但是，这个值是个估算值，可能与实际值相差 40% 到 50%</strong>。（对于 Rows 这个字段更详细的解释，可以参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html%EF%BC%89">https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html）</a></p><h2 id="10-为什么添加索引能提高查询速度"><strong>10 为什么添加索引能提高查询速度?</strong></h2><p>为了便于理解 MySQL 的索引，我们先了解一些与索引相关的算法。</p><h3 id="1-跟索引相关的一些算法">1 跟索引相关的一些算法</h3><p>对于 MySQL 而言，使用最频繁的就是 B+ 树索引，所以我们必须要知道 B+ 树的结构，而 B+ 树是借鉴了二分查找法、二叉查找树、平衡二叉树、B 树的一些思想构建的。因此我们首先通过了解这些算法，来一层一层拨开 B+ 树的神秘面纱。</p><h4 id="1-1-二分查找法">1.1 二分查找法</h4><p>二分查找法的查找过程是：将记录按顺序排列，查找时先以有序列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将查询范围缩小为左半部分；如果要找的元素值大于该中点元素，则将查询范围缩小为右半部分。以此类推，直到查到需要的值。</p><h4 id="1-2-二叉查找树">1.2 二叉查找树</h4><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，并且每个节点最多只有两颗子树。</p><h4 id="1-3-平衡二叉树">1.3 平衡二叉树</h4><p>平衡二叉树的定义：满足二叉查找树的定义，另外必须满足任何节点的两个子树的高度差最大为 1。</p><h4 id="1-4-B-树">1.4 B 树</h4><p>B 树可以理解为一个节点可以拥有多于 2 个子节点的平衡多叉查找树。</p><p>B 树中同一键值不会出现多次，要么在叶子节点，要么在内节点上。</p><p>比如用 1、2、3、5、6、7、9 这些数字构建一个 B 树结构，其图形如下：</p><p>与平衡二叉树相比，B 树利用多个分支（平衡二叉树只有两个分支）节点，减少获取记录时所经历的节点数。</p><p>B 树也是有缺点的，因为每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，同样会有：”要经历多层节点才能查询在叶子节点的数据”的问题。这时，B+ 树站了出来。</p><h4 id="1-5-B-树">1.5 B+ 树</h4><p>B+ 树是 B 树的变体，定义基本与 B 树一致，与 B 树的不同点：</p><ul><li>所有叶子节点中包含了全部关键字的信息</li><li>各叶子节点用指针进行连接</li><li>非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。</li><li>B 树是纵向扩展，最终变成一个”瘦高个”，而 B+ 树是横向扩展的，最终会变成一个”矮胖子”（这里参考了《MySQL 运维内参》第 8 节 B+ 树及 B 树的区别中的比喻）。</li></ul><p>在 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上。B+ 树中的 B 不是代表二叉(binary) 而是代表（balance），B+ 树并不是一个二叉树。</p><p>还是根据前面提到的这组数字（1、2、3、5、6、7、9）举例，它的结构如下</p><p>与 1.4 中 B 树的结构最大的区别就是：</p><p>它的键一定会出现在叶子节点上，同时也有可能在非叶子节点中重复出现。而 B 树中同一键值不会出现多次</p><h3 id="2-B-树索引">2 B+ 树索引</h3><p>B+ 树索引就是基于本节前面介绍的 B+ 树发展而来的。在数据库中，B+ 树的高度一般都在 2 ~ 4 层，所以<strong>查找某一行数据最多只需要 2 到 4 次 IO。而没索引的情况，需要逐行扫描，明显效率低很多，这也就是为什么添加索引能提高查询速度。</strong></p><p>B+ 树索引并不能找到一个给定键值的具体行，B+ 树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到缓冲池（buffer pool）中，在内存中通过二分查找法进行查找，得到需要的数据。</p><p>InnoDB 中 B+ 树索引分为聚集索引和辅助索引，我们再继续了解这两种索引的特点。</p><p>为了方便理解，我们先创建一张测试表并写入数据：</p><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t8; <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t8` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t8(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;e&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;f&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;g&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="2-1-聚集索引">2.1 聚集索引</h4><p>InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</p><p>InnoDB 的主键一定是聚集索引。如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，也有可能是 row id。</p><p>由于实际的数据页只能按照一颗 B+ 树进行排序，因此每张表只能有一个聚集索引（TokuDB 引擎除外）。查询优化器倾向于采用聚集索引，因为聚集索引能够在 B+ 树索引的叶子节点上直接找到数据。</p><p>聚集索引对于主键的排序查找和范围查找速度非常快。</p><p>对于刚刚创建好的测试表 t8的聚集索引的大致结构如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518224149464.png" alt="image-20240518224149464"></p><p>两点关键信息：</p><ul><li>根据主键值创建了 B+ 树结构</li><li>每个叶子节点包含了整行数据</li></ul><h4 id="2-2-辅助索引">2.2 辅助索引</h4><p>我们现在知道了聚集索引的叶子节点存放了整行数据，而 InnoDB 存储引擎辅助索引的叶子节点并不会放整行数据，而存放的是键值和主键 ID。</p><p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引来找到对应的行数据。</p><p>比如一颗高度为 3 的辅助索引树中查找数据，那需要对这颗辅助索引树遍历 3 次找到指定主键，如果聚集索引树的高度也为 3，那么还需要对聚集索引树进行 3 次查找，最终找到一个完整的行数据所在的页，因此获取数据一共需要6次逻辑 IO 访问。</p><p>我们继续拿表 t8 分析，它的辅助索引 idx_a 结构如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518224208146.png" alt="image-20240518224208146"></p><p>上图中两点关键点需要注意：</p><ul><li>根据 a 字段的值创建了 B+ 树结构</li><li>每个叶子节点保存的是 a 字段自己的键值和主键 ID</li></ul><p>对于表 t8，比如有下面这条查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t8 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>它先通过 a 字段上的索引树，得到主键 id 为 3，再到 id 的聚集索引树上找到对应的行数据。</p><p>而下面这条 SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t8 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>查询到的结果是一样的，而执行过程则只需要搜索 id 的聚集索引树。我们能看出辅助索引的查询比主键查询多扫描一颗索引树，所以，我们应该<strong>尽量使用主键做为条件进行查询</strong>。</p><h2 id="11-哪些情况需要添加索引？"><strong>11 哪些情况需要添加索引？</strong></h2><p>首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t9_1; <span class="comment">/* 如果表t9_1存在则删除表t9_1 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t9_1` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a` (`a`),</span><br><span class="line">KEY `idx_b_c` (`b`,`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t9_1; <span class="comment">/* 如果存在存储过程insert_t9_1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t9_1() <span class="comment">/* 创建存储过程insert_t9_1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do <span class="comment">/* 对满足i&lt;=100000的值进行while循环 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t9_1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入100000条数据到表t9_1的存储过程insert_t9_1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t9_1(); <span class="comment">/* 运行存储过程insert_t9_1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="comment">/*  把t9_1的数据量扩大到160万 */</span></span><br></pre></td></tr></table></figure><p>目前比较常见需要创建索引的场景有：数据检索时在条件字段添加索引、聚合函数对聚合字段添加索引、对排序字段添加索引、为了防止回表添加索引、关联查询在关联字段添加索引等。我们就一一分析这些需要创建索引的场景：</p><h3 id="1-数据检索">1 数据检索</h3><p>用上面的表 t9_1 做测试，首先把没有索引的字段 d 作为条件进行查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t9_1 <span class="keyword">where</span> d <span class="operator">=</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>发现查询时间需要0.44 秒</p><p>再把有索引的字段 a 作为条件进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t9_1 <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>发现查询时间为 0.00 sec，表示执行时间不超过 10 毫秒，非常快。</p><p>我们再对比两条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t9_1 where d = 90000;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t9_1  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 3192096 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t9_1 where a = 90000;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t9_1  | NULL       | ref  | idx_a         | idx_a | 5       | const |   32 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>前者 type 字段为 ALL，后者 type 字段为 ref，显然后者性能更好</p><p>rows 这个字段前者是 3192096，而后者是 32，有索引的情况扫描行数大大降低。</p><p>因此建议数据检索时，在条件字段添加索引。</p><h3 id="2-聚合函数">2 聚合函数</h3><p>在测试表 t9_1 中，如果要求出无索引字段 d 的最大值，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(d) <span class="keyword">from</span> t9_1;</span><br></pre></td></tr></table></figure><p>执行时间为 0.33 秒。</p><p>再看下求有索引的字段 a 的最大值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(a) <span class="keyword">from</span> t9_1;</span><br></pre></td></tr></table></figure><p>执行时间为 0.00 秒，表示执行时间不超过 10 毫秒。</p><p>相比对没有索引的字段 d 求最大值（花费330毫秒），<strong>显然索引能提升 max() 函数的效率，同理也能提升 min() 函数的效率</strong>。</p><p>在第 7 节中的 1.3 小节中有介绍 MySQL 5.7.18 之后版本的 <code>count(*)</code> 特点：从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句，如果不存在二级索引，则扫描聚簇索引。原因是：InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。</p><p><strong>因此索引对聚合函数 count(*) 也有优化作用。</strong></p><h3 id="3-排序">3 排序</h3><p>在第 4 节 2.1 小节，我们列出了几种通过添加合适索引优化 order by 的方法，这里再做一次总结（如果对下面的总结不是很理解，可以复习第 4 节的内容，有对每种情况举例说明）：</p><ul><li>如果对单个字段排序，则可以在这个排序字段上添加索引来优化排序语句；</li><li>如果是多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句；</li><li>如果是先等值查询再排序，可以通过在条件字段和排序字段添加联合索引来优化排序语句。</li></ul><h3 id="4-避免回表">4 避免回表</h3><p>比如下面这条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,d <span class="keyword">from</span> t9_1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>可以走 a 字段的索引，但是在学了第 8 节后，我们知道了辅助索引的结构，如果通过辅助索引来寻找数据，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引回表去找对应的行数据。</p><p>但是，如果条件字段和需要查询的字段有联合索引的话，其实回表这一步就省了，因为联合索引中包含了这两个字段的值。像这种索引就已经覆盖了我们的查询需求的场景，我们称为：覆盖索引。比如下面这条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b,c <span class="keyword">from</span> t9_1 <span class="keyword">where</span> b<span class="operator">=</span><span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>可直接通过联合索引 idx_b_c 找到 b、c 的值（联合索引详细讲解将放在第 11 节）。</p><p><strong>所以可以通过添加覆盖索引让 SQL 不需要回表，从而减少树的搜索次数，让查询更快地返回结果。</strong></p><h3 id="5-关联查询">5 关联查询</h3><p>在第 6 节中，我们讲到了关联查询的一些优化技巧，其中一个优化方式就是：通过在关联字段添加索引，让 BNL变成 NLJ 或者 BKA。</p><h3 id="6-总结-2">6 总结</h3><p>本节讲解了常见需要添加索引的场景：</p><ul><li>数据检索时在条件字段添加索引</li><li>聚合函数对聚合字段添加索引</li><li>对排序字段添加索引</li><li>为了防止回表添加索引</li><li>关联查询在关联字段添加索引</li></ul><h2 id="12-普通索引和唯一索引有哪些区别？"><strong>12 普通索引和唯一索引有哪些区别？</strong></h2><p>对于普通索引和唯一索引的区别，也许你已经知道：有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。其实对于 MySQL 来说，不止这一种区别。今天我们就再深入探究一下普通索引和唯一索引的区别。</p><p>在讨论两者的区别前，我们首先学习一下 Insert Buffer 和 Change Buffer。</p><h3 id="1-Insert-Buffer">1 Insert Buffer</h3><p>对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入；如果不在，则先放入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。这时通常能将多个插入合并到一个操作中（因为在一个索引页中），就大大提高了非聚集索引的插入性能。</p><blockquote><p>增加 Insert Buffer 有两个好处：</p><ul><li>减少磁盘的离散读取</li><li>将多次插入合并为一次操作</li></ul></blockquote><p>但是得注意的是，使用 Insert Buffer 得满足两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><h3 id="2-Change-Buffer">2 Change Buffer</h3><p>InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。</p><p>影响参数有两个：</p><ul><li>innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、changes、purges、all。默认为 all，表示启用所有。</li><li>innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示最多可以使用 buffer pool 的 25%，最大值50。</li></ul><p>跟 Insert Buffer 一样，Change Buffer 也得满足这两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><p>为什么唯一索引的更新不使用 Change Buffer ?</p><p>原因：唯一索引<strong>必须要将数据页读入内存才能判断是否违反唯一性约束</strong>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。</p><h3 id="3-普通索引和唯一索引的区别">3 普通索引和唯一索引的区别</h3><p>通过上面对 Insert Buffer 和 Change Buffer 的了解，也许你已经知道了普通索引和唯一索引的另外一种区别：<strong>如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。</strong></p><p>在上面讲解 Change Buffer 时，也提到了修改唯一索引必须判断是否违反唯一性约束，其实在 RR 隔离级别（事务隔离级别将在第 4 章重点讲解）下，可能会出现一个比较严重的问题：死锁。</p><p>那么查询过程两者的区别呢？</p><p>对于普通索引，查找到满足条件的第一个记录，还需要查找下一个记录，直到不满足条件。</p><p>对于唯一索引来说，查找到第一个记录返回结果就结束了。</p><p>但是 InnoDB 是按页从磁盘读取的，所以很大可能根据该普通索引查询的数据都在一个数据页里，因此如果通过普通索引查找到第一条满足条件所在的数据页，再查找后面的记录很大概率都在之前的数据页里，也就是多了几次内存扫描，实际这种消耗可以忽略不计。</p><p>这里总结一下普通索引和唯一索引的隐藏区别：</p><ul><li>数据修改时，普通索引可以用 Change Buffer，而唯一索引不行。</li><li>数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。</li><li>查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。</li></ul><h3 id="4-普通索引和唯一索引如何选择">4 普通索引和唯一索引如何选择</h3><p>上面说了普通索引和唯一索引的区别，那么两者应该如何选择呢？</p><p>如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引，让这个字段唯一，该字段新增重复数据时，将报类似如下的错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;f1&#x27;</span><br></pre></td></tr></table></figure><p>如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。 因为普通索引可以使用 Change Buffer，并且出现死锁的概率比唯一索引低。</p><h3 id="5-总结">5 总结</h3><p>普通索引和唯一索引的区别：</p><ul><li>有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。</li><li>数据修改时，普通索引优于唯一索引，因为普通索引可以用 Change Buffer，并且 RR 隔离级别下，出现死锁的概率比唯一索引低。</li><li>查询数据时，两者性能差别不大。</li></ul><h2 id="13-联合索引有哪些讲究"><strong>13 联合索引有哪些讲究?</strong></h2><h3 id="1-认识联合索引">1 认识联合索引</h3><p>联合索引：是指对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。</p><p>我们拿讲解 order by 时使用的联合索引 B+ 树图进行理解，如下图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518224509953.png" alt="image-20240518224509953"></p><p>联合索引的键值数量大于 1（比如上图中有 a 和 b 两个键值），与单个键值的 B+ 树一样，也是按照键值排序的。<strong>对于 a、b 两个字段都做为条件时，查询是可以走索引的；对于单独 a 字段查询也是可以走索引的。但是对于 b 字段单独查询就走不了索引了。</strong></p><p>联合索引的建议：</p><ul><li>where 条件中，经常同时出现的列放在联合索引中。</li><li>把选择性最大的列放在联合索引的最左边。</li></ul><p>老规矩，创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t11; <span class="comment">/* 如果表t11存在则删除表t11 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t11` ( <span class="comment">/* 创建表t11 */</span></span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`d` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a_b_c` (`a`,`b`,`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8mb4 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t11(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>); <span class="comment">/* 写入一些数据 */</span></span><br></pre></td></tr></table></figure><h3 id="2-联合索引使用分析">2 联合索引使用分析</h3><h4 id="2-1-可以完整用到联合索引的情况">2 .1 可以完整用到联合索引的情况</h4><p>下面我们列出几种可以完整用到联合索引的情况，并查看其执行计划，然后进行简短的分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* sql1 */</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>explain 中的 key_len 列用于表示这次查询中，所选择的索引长度有多少字节，常用于判断联合索引有多少列被选择了。下表总结了常用字段类型的 key_len：</p><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">KEY_LEN</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:left">key_len = 4+1</td><td style="text-align:left">int 为 4 bytes，允许为 NULL，加 1 byte</td></tr><tr><td style="text-align:left">int not null</td><td style="text-align:left">key_len = 4</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">bigint</td><td style="text-align:left">key_len=8+1</td><td style="text-align:left">bigint 为 8 bytes，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">bigint not null</td><td style="text-align:left">key_len=8</td><td style="text-align:left">bigint 为 8 bytes</td></tr><tr><td style="text-align:left">char(30) utf8</td><td style="text-align:left">key_len=30*3+1</td><td style="text-align:left">char(n)为：n * 3 ，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">char(30) not null utf8</td><td style="text-align:left">key_len=30*3</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">varchar(30) not null utf8</td><td style="text-align:left">key_len=30*3+2</td><td style="text-align:left">utf8 每个字符为 3 bytes，变长数据类型,加 2 bytes</td></tr><tr><td style="text-align:left">varchar(30) utf8</td><td style="text-align:left">key_len=30*3+2+1</td><td style="text-align:left">utf8 每个字符为 3 bytes，允许为 NULL,加 1 byte,变长数据类型，加 2 bytes</td></tr><tr><td style="text-align:left">datetime</td><td style="text-align:left">key_len=8+1 (MySQL 5.6.4之前的版本)；key_len=5+1(MySQL 5.6.4及之后的版本)</td><td style="text-align:left">允许为 NULL，加 1 byte</td></tr></tbody></table><p>因为 a、b、c 三个字段都是可以为 NULL 的 int 型。可以知道三个字段的 key_len 都是 5，所以如果完整使用索引 idx_a_b_c，则 key_len 对应的值为 15。再回到上面 sql1 的执行计划中：key_len 显示是 15，而 key 列对应的是 idx_a_b_c，所以 sql1 完整用到了联合索引 idx_a_b_c。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> c<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> a<span class="operator">=</span><span class="number">1</span>;  <span class="comment">/* sql2 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>跟 sql1 的执行计划一样，因此联合索引各字段都做为条件时，各字段的位置不会影响联合索引的使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> b <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">and</span> c<span class="operator">=</span><span class="number">2</span>;  <span class="comment">/* sql3 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 15      | NULL |    2 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><p>当联合索引前面的字段使用了范围查询，后面的字段做为条件时仍然可以使用完整的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> c;  <span class="comment">/* sql4 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    4 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>联合索引前面的字段做为条件时，对后面的字段做排序可以使用完整的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b,c;  <span class="comment">/* sql5 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>与 sql4 相似，对联合索引第一个字段做条件筛选时，对后面两个字段做排序可以使用完整的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> a,b,c <span class="keyword">from</span> t11 <span class="keyword">order</span> <span class="keyword">by</span> a,b,c;  <span class="comment">/* sql6 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | index | NULL          | idx_a_b_c | 15      | NULL |   15 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>对联合索引的字段同时做排序时（但是排序的三个字段顺序要跟联合索引中三个字段的顺序一致），可以完整用到联合索引。</p><h4 id="2-2-只能使用部分联合索引的情况">2.2 只能使用部分联合索引的情况</h4><p>有些场景只能用到部分联合索引，这里就列出几种情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* sql11 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>当条件只包含联合索引的前面部分字段时，可以用到部分联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* sql12 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |    10.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><p>对于联合索引 idx_a_b_c（a,b,c） ，如果条件中只包含 a 和 c，则只能用到联合索引中 a 的索引。c 这里是用不了索引的。<strong>联合索引 idx_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c) 三种索引，称为联合索引的最左原则。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">2</span>  <span class="keyword">and</span> b <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">order</span> <span class="keyword">by</span> c; <span class="comment">/* sql13 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 10      | NULL |    2 |   100.00 | Using index condition; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+</span><br></pre></td></tr></table></figure><p>这里可以复习第 4 节 2.4，<strong>当联合索引前面的字段使用了范围查询，对后面的字段排序使用不了索引排序</strong>，也就是只能用到联合索引前面两个字段 a 和 b 的索引。</p><p>​</p>]]></content>
    
    
    <summary type="html">《一线数据库工程师带你深入理解MySQL》</summary>
    
    
    
    <category term="MySQL" scheme="https://penge666.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://penge666.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>并发练手</title>
    <link href="https://penge666.github.io/posts/624cfcb.html"/>
    <id>https://penge666.github.io/posts/624cfcb.html</id>
    <published>2024-05-16T14:42:12.000Z</published>
    <updated>2024-05-17T10:05:09.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经典并发案例~</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="thread传参"><a href="#thread传参" class="headerlink" title="thread传参"></a>thread传参</h3><p>推荐博客</p><ul><li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/129642800?spm=1001.2014.3001.5501">C++ thread线程函数传参原理剖析</a></li></ul><p>thread函数都会把参数转成右值!</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>信号量的类型：<code>sem_t</code></li><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><ul><li>功能：初始化信号量</li><li>参数<ul><li><code>sem</code>：信号量变量的地址</li><li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li><li><code>value</code>：信号量中的值，代表容器大小</li></ul></li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p><ul><li>功能：释放资源</li></ul></li><li><code>int sem_wait(sem_t *sem);</code>【wait先判断再-】<ul><li>如果信号量的值大于0，<code>sem_wait</code>会立即返回，并将信号量的值减少1。</li><li>如果信号量的值为0，<code>sem_wait</code>会阻塞，直到信号量的值变得大于0。这通常发生在另一个线程或进程增加了信号量的值，表示它已经释放了它先前持有的资源。</li></ul></li><li><code>int sem_trywait(sem_t *sem);</code></li><li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li><li><p><code>int sem_post(sem_t *sem);</code></p><ul><li>功能：对信号量解锁，调用一次对信号量的值+1</li></ul></li><li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li></ul><h3 id="future-promise和async"><a href="#future-promise和async" class="headerlink" title="future, promise和async"></a>future, promise和async</h3><p>学习自：<a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2VWIJgH3zKEww0BpLnYQX0NMpQ9">C++ 并发三剑客future, promise和async</a></p><p><strong>async</strong></p><p><code>std::async</code> 是一个用于异步执行函数的模板函数，它返回一个 <code>std::future</code> 对象，该对象用于获取函数的返回值。</p><p>启动策略：</p><ol><li><code>std::launch::deferred</code>：这种策略意味着任务将在调用<code>std::future::get()</code>或<code>std::future::wait()</code>函数时延迟执行。换句话说，任务将在需要结果时同步执行。</li><li><code>std::launch::async</code> 函数异步执行</li><li><code>std::launch::async | std::launch::deferred</code>：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res = <span class="built_in">async</span>(std::launch::deferred, fun, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;go here&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> cur = res.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>future</strong></p><ul><li><code>std::future::get()</code> 用于获取并返回任务的结果，而 <code>std::future::wait()</code> 只是等待任务完成。</li><li><code>get()</code> 只能调用一次，而 <code>wait()</code> 可以被多次调用。</li><li>如果任务还没有完成，<code>get()</code> 和 <code>wait()</code> 都会阻塞当前线程，但 <code>get()</code> 会一直阻塞直到任务完成并返回结果，而 <code>wait()</code> 只是在等待任务完成。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_package</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离，以便主线程可以等待任务完成</span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_package</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(fun)</span></span>;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">1</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promise和future结合【<code>std::promise</code>用于在某一线程中设置某个值或异常，而<code>std::future</code>则用于在另一线程中获取这个值或异常】</p><p>在C++中，<code>std::promise</code> 和 <code>std::future</code> 是一对配套的类，用于在不同线程之间传递值.【经典例子】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(fun, std::move(prom))</span></span>;</span><br><span class="line">    cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="按序打印"><a href="#按序打印" class="headerlink" title="按序打印"></a>按序打印</h3><p><a href="https://leetcode.cn/problems/print-in-order/">1114. 按序打印</a></p><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span>()</span> &#123; print(<span class="string">&quot;first&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span>()</span> &#123; print(<span class="string">&quot;second&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span>()</span> &#123; print(<span class="string">&quot;third&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个不同的线程 A、B、C 将会共用一个 <code>Foo</code> 实例。</p><ul><li>线程 A 将会调用 <code>first()</code> 方法</li><li>线程 B 将会调用 <code>second()</code> 方法</li><li>线程 C 将会调用 <code>third()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p><p><strong>提示：</strong></p><ul><li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li><li>你看到的输入格式主要是为了确保测试的全面性。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1,2,3]</span></span><br><span class="line">输出：<span class="string">&quot;firstsecondthird&quot;</span></span><br><span class="line">解释：</span><br><span class="line">有三个线程会被异步启动。输入 <span class="selector-attr">[1,2,3]</span> 表示线程 A 将会调用 <span class="built_in">first</span>() 方法，线程 B 将会调用 <span class="built_in">second</span>() 方法，线程 C 将会调用 <span class="built_in">third</span>() 方法。正确的输出是 <span class="string">&quot;firstsecondthird&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1,3,2]</span></span><br><span class="line">输出：<span class="string">&quot;firstsecondthird&quot;</span></span><br><span class="line">解释：</span><br><span class="line">输入 <span class="selector-attr">[1,3,2]</span> 表示线程 A 将会调用 <span class="built_in">first</span>() 方法，线程 B 将会调用 <span class="built_in">third</span>() 方法，线程 C 将会调用 <span class="built_in">second</span>() 方法。正确的输出是 <span class="string">&quot;firstsecondthird&quot;</span>。</span><br></pre></td></tr></table></figure><p>（1）信号量</p><p>信号量是用来实现对共享资源的同步访问的机制，通过主动等待和主动唤醒来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> firstJobDone;</span><br><span class="line">    <span class="type">sem_t</span> secondJobDone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;firstJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;secondJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;firstJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;firstJobDone);</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;secondJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;secondJobDone);</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）互斥锁</p><p>互斥锁是用来防止多个线程同时访问共享资源对象的机制，在同一时间只有一个线程可以拥有一个特定的锁对象，其他线程如果尝试获取锁会阻塞直到锁资源被释放或直接返回失败。</p><p>针对这道题我们可以用两个互斥锁来阻塞 second 和 third 函数，分别在 first 和 second 执行结束后解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mx1, mx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mx1.<span class="built_in">lock</span>();</span><br><span class="line">        mx2.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        mx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        mx1.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        mx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        mx2.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）条件变量</p><p>条件变量一般和互斥锁搭配使用，互斥锁用于上锁，条件变量用于在多线程环境中等待特定事件发生。这里一把锁和2把锁都是OK的！</p><ul><li><a href="https://zhuanlan.zhihu.com/p/340348726">C++11多线程编程(三)——lock_guard和unique_lock</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                &#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);</span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        k = <span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                &#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）异步操作</p><p>异步操作是一种，在不需要等待被调用方返回结果之前，就让操作继续进行下去的方法。针对这道题可以使用基于 future/promise 的异步编程模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; num1, num2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        num1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = num1.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        num2.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="type">int</span> num = num2.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）原子操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">while</span> (!b)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">while</span> (!b)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交替打印-FooBar"><a href="#交替打印-FooBar" class="headerlink" title="交替打印 FooBar"></a>交替打印 FooBar</h3><p><a href="https://leetcode.cn/problems/print-foobar-alternately/">交替打印 FooBar</a></p><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同的线程将会共用一个 <code>FooBar</code> 实例：</p><ul><li>线程 A 将会调用 <code>foo()</code> 方法，而</li><li>线程 B 将会调用 <code>bar()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>&quot;foobar&quot;</code> 被输出 <code>n</code> 次。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;foobar&quot;</span></span><br><span class="line">解释：这里有两个线程被异步启动。其中一个调用 <span class="built_in">foo</span>() 方法, 另一个调用 <span class="built_in">bar</span>() 方法，<span class="string">&quot;foobar&quot;</span> 将被输出一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;foobarfoobar&quot;</span></span><br><span class="line">解释：<span class="string">&quot;foobar&quot;</span> 将被输出两次。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>（1）信号量</p><p>将其中一个信号量设置成1就可以啦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> sem1, sem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;sem2);</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;sem1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;sem1);</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;sem2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FooBar <span class="title">fooBar</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;FooBar::foo, &amp;fooBar, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;FooBar::bar, &amp;fooBar, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;bar&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 互斥锁</p><p>和上一题类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    mutex mxt1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        mxt1.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            mtx2.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            mxt1.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            mxt1.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(3)条件变量</p><p>和上一道的条件变量类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            k = <span class="number">2</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（4）异步编程</p><p><strong>Note</strong>：在你的代码中，你使用了 <code>std::promise</code> 和 <code>std::future</code> 来同步 <code>foo</code> 和 <code>bar</code> 方法。然而，你在每个循环迭代中都调用了 <code>get()</code> 方法，这导致了问题。<code>std::future::get()</code> 方法只能被调用一次，因为它会移动（而不是复制）值。如果你尝试第二次调用 <code>get()</code>，会抛出一个 <code>std::future_error</code> 异常。</p><p>解决这个问题的一种方法是在每次迭代中重新创建 <code>std::promise</code> 和 <code>std::future</code> 对象。你可以在循环的每一次迭代后用新的 <code>std::promise</code> 对象替换旧的对象，然后从新的 <code>std::promise</code> 对象获取新的 <code>std::future</code> 对象。</p><p>不过我这里用投机的方式创建一个新的对象即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        p1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            p1.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            p1 = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            p2.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            p2.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            p2 = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">            p1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用promise和future结合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; aa, bb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        aa = a.<span class="built_in">get_future</span>();</span><br><span class="line">        bb = b.<span class="built_in">get_future</span>();</span><br><span class="line">        b.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="type">int</span> tmp = bb.<span class="built_in">get</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            promise&lt;<span class="type">int</span>&gt; tmp_b;</span><br><span class="line">            future&lt;<span class="type">int</span>&gt; tmp_bb;</span><br><span class="line">            b = <span class="built_in">move</span>(tmp_b);</span><br><span class="line">            bb = <span class="built_in">move</span>(tmp_bb);</span><br><span class="line">            bb = b.<span class="built_in">get_future</span>();</span><br><span class="line">            a.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="type">int</span> tmp = aa.<span class="built_in">get</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            promise&lt;<span class="type">int</span>&gt; tmp_a;</span><br><span class="line">            future&lt;<span class="type">int</span>&gt; tmp_aa;</span><br><span class="line">            a = <span class="built_in">move</span>(tmp_a);</span><br><span class="line">            aa = <span class="built_in">move</span>(tmp_aa);</span><br><span class="line">            aa = a.<span class="built_in">get_future</span>();</span><br><span class="line">            b.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（5）原子操作</p><p>貌似用不用atomic都可以~可能这才是最纯粹的控制并发的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span> (a)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            a = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span> (!a)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            a = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="打印零与奇偶数"><a href="#打印零与奇偶数" class="headerlink" title="打印零与奇偶数"></a>打印零与奇偶数</h3><p><a href="https://leetcode.cn/problems/print-zero-even-odd/">打印零与奇偶数</a></p><p>现有函数 <code>printNumber</code> 可以用一个整数参数调用，并输出该整数到控制台。</p><ul><li>例如，调用 <code>printNumber(7)</code> 将会输出 <code>7</code> 到控制台。</li></ul><p>给你类 <code>ZeroEvenOdd</code> 的一个实例，该类中有三个函数：<code>zero</code>、<code>even</code> 和 <code>odd</code> 。<code>ZeroEvenOdd</code> 的相同实例将会传递给三个不同线程：</p><ul><li><strong>线程 A：</strong>调用 <code>zero()</code> ，只输出 <code>0</code></li><li><strong>线程 B：</strong>调用 <code>even()</code> ，只输出偶数</li><li><strong>线程 C：</strong>调用 <code>odd()</code> ，只输出奇数</li></ul><p>修改给出的类，以输出序列 <code>&quot;010203040506...&quot;</code> ，其中序列的长度必须为 <code>2n</code> 。</p><p>实现 <code>ZeroEvenOdd</code> 类：</p><ul><li><code>ZeroEvenOdd(int n)</code> 用数字 <code>n</code> 初始化对象，表示需要输出的数。</li><li><code>void zero(printNumber)</code> 调用 <code>printNumber</code> 以输出一个 0 。</li><li><code>void even(printNumber)</code> 调用<code>printNumber</code> 以输出偶数。</li><li><code>void odd(printNumber)</code> 调用 <code>printNumber</code> 以输出奇数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;0102&quot;</span></span><br><span class="line">解释：三条线程异步执行，其中一个调用 zero()，另一个线程调用 <span class="built_in">even</span>()，最后一个线程调用<span class="built_in">odd</span>()。正确的输出为 <span class="string">&quot;0102&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="string">&quot;0102030405&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>（1）原子变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">cnt</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zeroEvenOdd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;ZeroEvenOdd::zero, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;ZeroEvenOdd::even, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;ZeroEvenOdd::odd, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）信号量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> zero1, even1, odd1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;zero1, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;even1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;odd1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;zero1);</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sem_post</span>(&amp;odd1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sem_post</span>(&amp;even1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;even1);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;zero1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;odd1);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;zero1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zeroEvenOdd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;ZeroEvenOdd::zero, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;ZeroEvenOdd::even, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;ZeroEvenOdd::odd, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)条件变量+互斥锁</p><p>记得要写notify_all()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx, mtx1, mtx2;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">flag</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">0</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">2</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">1</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(4)互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx, mtx1, mtx2;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">flag</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx2.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx1.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="H2O生成"><a href="#H2O生成" class="headerlink" title="H2O生成"></a>H2O生成</h3><p><a href="https://leetcode.cn/problems/building-h2o/">1117. H2O 生成</a></p><p>现在有两种线程，氧 <code>oxygen</code> 和氢 <code>hydrogen</code>，你的目标是组织这两种线程来产生水分子。</p><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 <code>releaseHydrogen</code> 和 <code>releaseOxygen</code> 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><ul><li>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</li><li>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</li></ul><p>书写满足这些限制条件的氢、氧线程同步代码。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">water</span> = <span class="string">&quot;HOH&quot;</span></span><br><span class="line">输出: <span class="string">&quot;HHO&quot;</span></span><br><span class="line">解释: <span class="string">&quot;HOH&quot;</span> 和 <span class="string">&quot;OHH&quot;</span> 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">water</span> = <span class="string">&quot;OOHHHH&quot;</span></span><br><span class="line">输出: <span class="string">&quot;HHOHHO&quot;</span></span><br><span class="line">解释: <span class="string">&quot;HOHHHO&quot;</span>, <span class="string">&quot;OHHHHO&quot;</span>, <span class="string">&quot;HHOHOH&quot;</span>, <span class="string">&quot;HOHHOH&quot;</span>, <span class="string">&quot;OHHHOH&quot;</span>, <span class="string">&quot;HHOOHH&quot;</span>, <span class="string">&quot;HOHOHH&quot;</span> 和 <span class="string">&quot;OHHOHH&quot;</span> 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 * n == water.length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>water[i] == &#39;O&#39; or &#39;H&#39;</code></li><li>输入字符串 <code>water</code> 中的 ‘H’ 总数将会是 <code>2 * n</code> 。</li><li>输入字符串 <code>water</code> 中的 ‘O’ 总数将会是 <code>n</code> 。</li></ul><p>思路：</p><p>一道典型的阅读理解题。</p><p>题目的意思是，要一个水分子，一个水分子的生成。一个水分子是两个H一个O，也就是要运行两次hydrogen和一次oxygen。要想保证水分子正常生成，那么当有了2个H时，就不能再，执行hydrogen了，它就要等。同理，当有了1个O时，就不能再执行oxygen，就要等。</p><p>同时，当任何时候凑够了2个H，1个O时，也即能生成水分子时，就要把计数重置，以生成下一个水分子。</p><p>一个水分子内部，是不用管顺序的，也即HHO，OHH，HOH都是合法的。</p><p>互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H2O</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx1,mtx2;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">H2O</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hydrogen</span><span class="params">(function&lt;<span class="type">void</span>()&gt; releaseHydrogen)</span> </span>&#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">releaseHydrogen</span>();</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>) mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oxygen</span><span class="params">(function&lt;<span class="type">void</span>()&gt; releaseOxygen)</span> </span>&#123;</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">releaseOxygen</span>();</span><br><span class="line">        cnt+=<span class="number">2</span>;</span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交替打印字符串"><a href="#交替打印字符串" class="headerlink" title="交替打印字符串"></a>交替打印字符串</h3><p><a href="https://leetcode.cn/problems/fizz-buzz-multithreaded/"> 交替打印字符串</a></p><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><ul><li>如果这个数字可以被 3 整除，输出 “fizz”。</li><li>如果这个数字可以被 5 整除，输出 “buzz”。</li><li>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。</li></ul><p>例如，当 <code>n = 15</code>，输出： <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>。</p><p>假设有这么一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">FizzBuzz</span>(int n) &#123; ... &#125;               <span class="comment">// constructor</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fizz</span>(<span class="params">printFizz</span>) &#123; ... &#125;          <span class="comment">// only output &quot;fizz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">buzz</span>(<span class="params">printBuzz</span>) &#123; ... &#125;          <span class="comment">// only output &quot;buzz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fizzbuzz</span>(<span class="params">printFizzBuzz</span>) &#123; ... &#125;  <span class="comment">// only output &quot;fizzbuzz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">number</span>(<span class="params">printNumber</span>) &#123; ... &#125;      <span class="comment">// only output the numbers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请你实现一个有四个线程的多线程版 <code>FizzBuzz</code>， 同一个 <code>FizzBuzz</code> 实例会被如下四个线程使用：</p><ol><li>线程A将调用 <code>fizz()</code> 来判断是否能被 3 整除，如果可以，则输出 <code>fizz</code>。</li><li>线程B将调用 <code>buzz()</code> 来判断是否能被 5 整除，如果可以，则输出 <code>buzz</code>。</li><li>线程C将调用 <code>fizzbuzz()</code> 来判断是否同时能被 3 和 5 整除，如果可以，则输出 <code>fizzbuzz</code>。</li><li>线程D将调用 <code>number()</code> 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li></ol><p><strong>提示：</strong></p><ul><li>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分。</li></ul><p>1.互斥锁+条件变量</p><p>一波暴力出奇迹~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FizzBuzz</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz() outputs &quot;fizz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;cnt%<span class="number">5</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printFizz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz() outputs &quot;buzz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buzz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBuzz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">3</span>!=<span class="number">0</span>&amp;&amp;cnt%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printBuzz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz() outputs &quot;fizzbuzz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizzbuzz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizzBuzz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">5</span>==<span class="number">0</span>&amp;&amp;cnt%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printFizzBuzz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">number</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">5</span>==<span class="number">0</span>||cnt%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printNumber</span>(cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FizzBuzz <span class="title">tmp</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;FizzBuzz::fizz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;fizz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;FizzBuzz::buzz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;buzz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;FizzBuzz::fizzbuzz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;fizzbuzz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(&amp;FizzBuzz::number, &amp;tmp, [](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><p><a href="https://leetcode.cn/problems/the-dining-philosophers/">哲学家进餐</a></p><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p><p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p><p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240517094400802.png" alt="image-20240517094400802"></p><p>哲学家从 <strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数 <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</p><ul><li><code>philosopher</code> 哲学家的编号。</li><li><code>pickLeftFork</code> 和 <code>pickRightFork</code> 表示拿起左边或右边的叉子。</li><li><code>eat</code> 表示吃面。</li><li><code>putLeftFork</code> 和 <code>putRightFork</code> 表示放下左边或右边的叉子。</li><li>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</li></ul><p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。 </p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]</span><br><span class="line">解释:</span><br><span class="line">n 表示每个哲学家需要进餐的次数。</span><br><span class="line">输出数组描述了叉子的控制和进餐的调用，它的格式如下：</span><br><span class="line">output[i] = [a, b, c] (3个整数)</span><br><span class="line">- a 哲学家编号。</span><br><span class="line">- b 指定叉子：&#123;1 : 左边, 2 : 右边&#125;.</span><br><span class="line">- c 指定行为：&#123;1 : 拿起, 2 : 放下, 3 : 吃面&#125;。</span><br><span class="line">如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 60</code></li></ul><p>学过操作系统的童鞋们都比较好懂。</p><p>开始这个问题之前，想个最暴力的做法，就是每次只能让一个人吃。一把大锁即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Yun_Ge/article/details/89177918">PV操作经典例题——哲学家进餐问题</a></p><p><strong>分析</strong>：放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用，为了实现对筷子的互斥访问，可以用一个信号量表示筷子，由这五个信号量构成信号量数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*当哲学家饥饿时，总是先拿左边的筷子，再拿右边的筷子*/</span></span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃饭</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*当哲学家进餐完成后，总是先放下左边的筷子，再放下右边的筷子*/</span></span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述的代码可以保证不会有两个相邻的哲学家同时进餐，但却可能引起死锁的情况。假如五位哲学家同时饥饿而都拿起的左边的筷子，就会使五个信号量chopstick都为0，当他们试图去拿右手边的筷子时，都将无筷子而陷入无限期的等待。</li></ul><p><strong>为避免死锁，可以使用以下三种策略</strong>：</p><p><strong>策略一</strong>：<strong>至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐</strong>，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。</p><p>错误代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DiningPhilosophers diningPhilosophers;</span><br><span class="line">    <span class="type">int</span> nPhilosophers = <span class="number">5</span>;</span><br><span class="line">    <span class="function">vector&lt;thread&gt; <span class="title">philosophers</span><span class="params">(nPhilosophers)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i] = <span class="built_in">thread</span>(&amp;DiningPhilosophers::wantsToEat, &amp;diningPhilosophers, i, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up right fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; eats\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down right fork\n&quot;</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：本代码使用了一个信号量来限制同时吃饭的哲学家的数量。这是一个常见的解决方案，可以避免死锁。但是，没有考虑到叉子的使用情况。所有的哲学家都试图先拿起左边的叉子，然后拿起右边的叉子。这可能会导致一个问题：如果所有的哲学家都拿起了他们左边的叉子，那么他们的右边的叉子就都被他们右边的哲学家拿走了，因此每个哲学家都无法吃饭，导致所有哲学家都在等待，从而产生死锁。</p><p>简单来说，我们需要考虑哲学家人数问题，也要考虑到叉子的资源使用。</p><p>正确代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    mutex mtx[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">        <span class="type">int</span> l = philosopher;</span><br><span class="line">        <span class="type">int</span> r = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>策略二</strong>：<strong>仅当哲学家的左右两支筷子都可用时，才允许他拿起筷子进餐</strong>。可以利用AND 型信号量机制实现，也可以利用信号量的保护机制实现。利用信号量的保护机制实现的思想是通过记录型信号量mutex对取左侧和右侧筷子的操作进行保护，使之成为一个<a href="https://so.csdn.net/so/search?q=原子操作&amp;spm=1001.2101.3001.7020">原子操作</a>，这样可以防止死锁的出现。描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    mutex mtx[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">        <span class="type">int</span> l = philosopher;</span><br><span class="line">        <span class="type">int</span> r = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>策略三</strong>：规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则先拿起他右边的筷子，然后再去拿他左边的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = philosopher;</span><br><span class="line">        <span class="type">int</span> r = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (philosopher % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">            mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">pickLeftFork</span>();</span><br><span class="line">            <span class="built_in">pickRightFork</span>();</span><br><span class="line">            <span class="built_in">eat</span>();</span><br><span class="line">            <span class="built_in">putLeftFork</span>();</span><br><span class="line">            <span class="built_in">putRightFork</span>();</span><br><span class="line">            mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">            mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">            mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">pickLeftFork</span>();</span><br><span class="line">            <span class="built_in">pickRightFork</span>();</span><br><span class="line">            <span class="built_in">eat</span>();</span><br><span class="line">            <span class="built_in">putLeftFork</span>();</span><br><span class="line">            <span class="built_in">putRightFork</span>();</span><br><span class="line">            mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">            mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DiningPhilosophers diningPhilosophers;</span><br><span class="line">    <span class="type">int</span> nPhilosophers = <span class="number">5</span>;</span><br><span class="line">    <span class="function">vector&lt;thread&gt; <span class="title">philosophers</span><span class="params">(nPhilosophers)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i] = <span class="built_in">thread</span>(&amp;DiningPhilosophers::wantsToEat, &amp;diningPhilosophers, i, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up right fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; eats\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down right fork\n&quot;</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在写并发程序的时候很容易写着写着就有bug了。这时候，如何定位bug就显得尤为关键。</p><p>问题代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>           <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>             <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// std::condition_variable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁资源1</span></span><br><span class="line">std::mutex mtx1;</span><br><span class="line"><span class="comment">// 锁资源2</span></span><br><span class="line">std::mutex mtx2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 保证线程A先获取锁1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockA</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程A获取锁1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A睡眠2s再获取锁2，保证锁2先被线程B获取，模拟死锁问题的发生</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A先获取锁2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockB</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程A获取锁2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程A释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程B先睡眠1s保证线程A先获取锁1</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockB</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程B获取锁2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 线程B尝试获取锁1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockA</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程B获取锁1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程B释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(taskA)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(taskB)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main主线程等待所有子线程执行完</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行可执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ✘ ⚙ penge@penge-virtual-machine  ~/Desktop/MordenCpp  ./main</span><br><span class="line">线程A获取锁1</span><br><span class="line">线程B获取锁2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看进程号<code>ps -aux | grep main</code></p><p>通过top命令再查看一下进程内每个线程具体的运行情况：top -Hp pid</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">80342</span> penge     <span class="number">20</span>   <span class="number">0</span>   <span class="number">88564</span>   <span class="number">1676</span>   <span class="number">1508</span> S   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> main                                                                                  </span><br><span class="line"> <span class="attribute">80343</span> penge     <span class="number">20</span>   <span class="number">0</span>   <span class="number">88564</span>   <span class="number">1676</span>   <span class="number">1508</span> S   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> main                                                         </span><br><span class="line"> <span class="attribute">80344</span> penge     <span class="number">20</span>   <span class="number">0</span>   <span class="number">88564</span>   <span class="number">1676</span>   <span class="number">1508</span> t   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> main</span><br></pre></td></tr></table></figure><p>查看状态为S【<a href="https://blog.csdn.net/sdkdlwk/article/details/65938204">Linux进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)</a>】</p><p>接着使用 <strong>gdb attach pid</strong>调试一个已经在运行的进程.</p><p>查看所有线程的调用堆栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7f0846b3c700 (LWP 1407291)):</span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x5574527f2160 &lt;mtx1&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line"><span class="comment">#1  0x00007f084768f0a3 in __GI___pthread_mutex_lock (mutex=0x5574527f2160 &lt;mtx1&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x00005574527ed74f in __gthread_mutex_lock (__mutex=0x5574527f2160 &lt;mtx1&gt;) at /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:749</span></span><br><span class="line"><span class="comment">#3  0x00005574527ed8a4 in std::mutex::lock (this=0x5574527f2160 &lt;mtx1&gt;) at /usr/include/c++/9/bits/std_mutex.h:100</span></span><br><span class="line"><span class="comment">#4  0x00005574527ed940 in std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7f0846b3bdf0, __m=...) at /usr/include/c++/9/bits/std_mutex.h:159</span></span><br><span class="line"><span class="comment">#5  0x00005574527ed541 in taskB () at main.cpp:36</span></span><br><span class="line"><span class="comment">#6  0x00005574527ee526 in std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x557453d97008: 0x5574527ed4b1 &lt;taskB()&gt;) at /usr/include/c++/9/bits/invoke.h:60</span></span><br><span class="line"><span class="comment">#7  0x00005574527ee4be in std::__invoke&lt;void (*)()&gt; (__fn=@0x557453d97008: 0x5574527ed4b1 &lt;taskB()&gt;) at /usr/include/c++/9/bits/invoke.h:95</span></span><br><span class="line"><span class="comment">#8  0x00005574527ee450 in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x557453d97008) at /usr/include/c++/9/thread:244</span></span><br><span class="line"><span class="comment">#9  0x00005574527ee40d in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x557453d97008) at /usr/include/c++/9/thread:251</span></span><br><span class="line"><span class="comment">#10 0x00005574527ee3de in std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x557453d97000) at /usr/include/c++/9/thread:195</span></span><br><span class="line"><span class="comment">#11 0x00007f0847798df4 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#12 0x00007f084768c609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span></span><br><span class="line"><span class="comment">#13 0x00007f08475b1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7f084733d700 (LWP 1407290)):</span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x5574527f21a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line"><span class="comment">#1  0x00007f084768f0a3 in __GI___pthread_mutex_lock (mutex=0x5574527f21a0 &lt;mtx2&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x00005574527ed74f in __gthread_mutex_lock (__mutex=0x5574527f21a0 &lt;mtx2&gt;) at /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:749</span></span><br><span class="line"><span class="comment">#3  0x00005574527ed8a4 in std::mutex::lock (this=0x5574527f21a0 &lt;mtx2&gt;) at /usr/include/c++/9/bits/std_mutex.h:100</span></span><br><span class="line"><span class="comment">#4  0x00005574527ed940 in std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7f084733cdf0, __m=...) at /usr/include/c++/9/bits/std_mutex.h:159</span></span><br><span class="line"><span class="comment">#5  0x00005574527ed3f8 in taskA () at main.cpp:23</span></span><br><span class="line"><span class="comment">#6  0x00005574527ee526 in std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x557453d96eb8: 0x5574527ed368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:60</span></span><br><span class="line"><span class="comment">#7  0x00005574527ee4be in std::__invoke&lt;void (*)()&gt; (__fn=@0x557453d96eb8: 0x5574527ed368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:95</span></span><br><span class="line"><span class="comment">#8  0x00005574527ee450 in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x557453d96eb8) at /usr/include/c++/9/thread:244</span></span><br><span class="line"><span class="comment">#9  0x00005574527ee40d in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x557453d96eb8) at /usr/include/c++/9/thread:251</span></span><br><span class="line"><span class="comment">#10 0x00005574527ee3de in std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x557453d96eb0) at /usr/include/c++/9/thread:195</span></span><br><span class="line"><span class="comment">#11 0x00007f0847798df4 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#12 0x00007f084768c609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span></span><br><span class="line"><span class="comment">#13 0x00007f08475b1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line"></span><br><span class="line">Thread 1 (Thread 0x7f084733e740 (LWP 1407289)):</span><br><span class="line"><span class="comment">#0  __pthread_clockjoin_ex (threadid=139673531045632, thread_return=0x0, clockid=&lt;optimized out&gt;, abstime=&lt;optimized out&gt;, block=&lt;optimized out&gt;) at pthread_join_common.c:145</span></span><br><span class="line"><span class="comment">#1  0x00007f0847799057 in std::thread::join() () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#2  0x00005574527ed648 in main () at main.cpp:47</span></span><br></pre></td></tr></table></figure><p>定位到taskA和taskB线程阻塞的原因，都是因为锁获取不到，然后再结合源码进行分析定位，最终发现taskA之所以获取不到mtx2，是因为mtx2早被taskB线程获取了；同样taskB之所以获取不到mtx1，是因为mtx1早被taskA线程获取了，导致所有线程进入阻塞状态，等待锁资源的获取，但是又因为没有线程释放锁，最终导致死锁问题。</p><p>知道是死锁问题，那么如何定位具体哪一行呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo gdb attach 1406920</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">attach: 没有那个文件或目录.</span><br><span class="line">Attaching to process 1406920</span><br><span class="line">[New LWP 1406921]</span><br><span class="line">[New LWP 1406922]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">__pthread_clockjoin_ex (threadid=139933978740480, thread_return=0x0, clockid=&lt;optimized out&gt;, abstime=&lt;optimized out&gt;, block=&lt;optimized out&gt;)</span><br><span class="line">    at pthread_join_common.c:145</span><br><span class="line">145     pthread_join_common.c: 没有那个文件或目录.</span><br><span class="line">(gdb) info threads </span><br><span class="line">  Id   Target Id                                  Frame</span><br><span class="line">* 1    Thread 0x7f44eb185740 (LWP 1406920) <span class="string">&quot;main&quot;</span> __pthread_clockjoin_ex (threadid=139933978740480, thread_return=0x0, clockid=&lt;optimized out&gt;,</span><br><span class="line">    abstime=&lt;optimized out&gt;, block=&lt;optimized out&gt;) at pthread_join_common.c:145</span><br><span class="line">  2    Thread 0x7f44eb184700 (LWP 1406921) <span class="string">&quot;main&quot;</span> __lll_lock_wait (futex=futex@entry=0x55d52319e1a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span><br><span class="line">  3    Thread 0x7f44ea983700 (LWP 1406922) <span class="string">&quot;main&quot;</span> __lll_lock_wait (futex=futex@entry=0x55d52319e160 &lt;mtx1&gt;, private=0) at lowlevellock.c:52</span><br><span class="line">(gdb) thread 2</span><br><span class="line">[Switching to thread 2 (Thread 0x7f44eb184700 (LWP 1406921))]</span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x55d52319e1a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line">52      lowlevellock.c: 没有那个文件或目录.</span><br><span class="line">(gdb) bt <span class="comment"># 函数调用栈</span></span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x55d52319e1a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line"><span class="comment">#1  0x00007f44eb4d60a3 in __GI___pthread_mutex_lock (mutex=0x55d52319e1a0 &lt;mtx2&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x000055d52319974f in __gthread_mutex_lock (__mutex=0x55d52319e1a0 &lt;mtx2&gt;) at /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:749</span></span><br><span class="line"><span class="comment">#3  0x000055d5231998a4 in std::mutex::lock (this=0x55d52319e1a0 &lt;mtx2&gt;) at /usr/include/c++/9/bits/std_mutex.h:100</span></span><br><span class="line"><span class="comment">#4  0x000055d523199940 in std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7f44eb183df0, __m=...) at /usr/include/c++/9/bits/std_mutex.h:159</span></span><br><span class="line"><span class="comment">#5  0x000055d5231993f8 in taskA () at main.cpp:23</span></span><br><span class="line"><span class="comment">#6  0x000055d52319a526 in std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x55d523aeeeb8: 0x55d523199368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:60</span></span><br><span class="line"><span class="comment">#7  0x000055d52319a4be in std::__invoke&lt;void (*)()&gt; (__fn=@0x55d523aeeeb8: 0x55d523199368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:95</span></span><br><span class="line"><span class="comment">#8  0x000055d52319a450 in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x55d523aeeeb8) at /usr/include/c++/9/thread:244</span></span><br><span class="line"><span class="comment">#9  0x000055d52319a40d in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x55d523aeeeb8) at /usr/include/c++/9/thread:251</span></span><br><span class="line"><span class="comment">#10 0x000055d52319a3de in std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x55d523aeeeb0)</span></span><br><span class="line">    at /usr/include/c++/9/thread:195</span><br><span class="line"><span class="comment">#11 0x00007f44eb5dfdf4 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#12 0x00007f44eb4d3609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span></span><br><span class="line"><span class="comment">#13 0x00007f44eb3f8353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line">(gdb) f 5 <span class="comment"># 线程2的第5帧信息</span></span><br><span class="line"><span class="comment">#5  0x000055d5231993f8 in taskA () at main.cpp:23</span></span><br><span class="line">23          std::lock_guard&lt;std::mutex&gt; lockB(mtx2)</span><br></pre></td></tr></table></figure><p>main.cpp:23即可知道问题行所在定位。</p><ul><li><a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/08/19/cpluscplus-gdbusage_part2">GDB调试多线程及多进程</a></li></ul>]]></content>
    
    
    <summary type="html">经典并发案例</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux Performance</title>
    <link href="https://penge666.github.io/posts/e16c05c.html"/>
    <id>https://penge666.github.io/posts/e16c05c.html</id>
    <published>2024-05-16T02:43:10.000Z</published>
    <updated>2024-05-21T14:39:33.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516145620615.png" alt="image-20240516145620615"></p><p><a href="https://www.brendangregg.com/linuxperf.html">Linux Performance</a></p><h2 id="CPU篇">CPU篇</h2><h3 id="CPU性能指标">CPU性能指标</h3><p><strong>CPU使用率</strong></p><ul><li>用户CPU使用率：CPU使用率高，通常说明有应用程序比较繁忙。</li><li>系统CPU使用率：CPU使用率高，说明内核比较繁忙。</li><li>等待I/O的CPU使用率：iowait,表示等待I/O的时间百分比，iowait高通常说明系统与硬件设备I/O交互时间比较长。<ul><li>iowait指的是CPU等待硬盘I/O（输入/输出）操作完成的时间百分比。在这种状态下，CPU没有执行任何代码，因为它正在等待硬盘的I/O操作完成。</li></ul></li><li>软中断和硬中断的CPU使用率，内核调用软中断处理程序，硬中断处理程序的百分比。</li></ul><p><strong>平均负载</strong></p><p>平均负载其实就是平均活跃进程数。平均负载大于CPU数量表示CPU不足以服务线程，有些线程在等待；如果平均负载小于CPU数量，这代表还有一些余量。</p><p>主要包括三个数值，分别值过去1分钟，5分钟，15分钟的平均负载。</p><p>平均负载与 CPU 使用率关系：平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。【可运行状态是指正在使用或等待使用 CPU，而不可中断状态是指进程正执行某种 I/O 操作，比如读写磁盘】。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p><ul><li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li><li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><p><strong>上下文切换</strong></p><p>频繁上下文切换，将时间消耗在寄存器、内核栈以及虚拟内存等数据保持与恢复上。切换分为以下两类：</p><ul><li><p>无法获取资源而导致的自愿上下文切换。</p></li><li><p>被系统强制调度导致的非自愿上下文切换。</p></li></ul><p><strong>CPU缓存命中率</strong></p><p>CPU速度比内存访问速度快得多，协调这两者巨大性能差距，使用CPU缓存。缓存的是热点的内存数据。L1 L2 L3到缓存。L1 L2常用在单核中，L3则用在多核中。L1-&gt;L3三级缓存大小依次增大，相应性能依次降低。命中率衡量的是CPU缓存的复用情况，命中率越高，则性能越好。</p><h3 id="常用命令">常用命令</h3><table><thead><tr><th style="text-align:center"><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">uptime</td><td>平均负载</td></tr><tr><td style="text-align:center">vmstat</td><td>包括系统范围的CPU平均负载，上下文切换次数、中断次数、还包括处于运行和不可中断状态的进程数量</td></tr><tr><td style="text-align:center">mpstat</td><td>单个CPU统计信息和软中断次数</td></tr><tr><td style="text-align:center">sar</td><td>统计历史信息</td></tr><tr><td style="text-align:center">ps</td><td>进程状态和CPU使用率</td></tr><tr><td style="text-align:center">top</td><td>监控平均负载，运行队列、整体CPU使用率，以及每个进程/线程CPU用量</td></tr><tr><td style="text-align:center">pidstat</td><td>每个进程/线程CPU用量分解</td></tr><tr><td style="text-align:center">time</td><td>给一个命令计时，带CPU用量分解</td></tr><tr><td style="text-align:center">Dtrace,perf</td><td>CPU剖析和跟踪</td></tr><tr><td style="text-align:center">perf</td><td>CPU性能计数器分析，CPU缓存，cpu调度</td></tr></tbody></table><h4 id="uptime"><strong>uptime</strong></h4><p>功能：打印平均负载，系统运行时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">uptime</span></span><br><span class="line"> 10:56:18 up 72 days, 20:32,  2 <span class="built_in">users</span>,  load average: 25.44, 25.69, 25.18</span><br></pre></td></tr></table></figure><p>最后三个数字是1,5,15分钟内的平均负载。通过这三个值可以判断系统负载在此段时间内上升，下降还是平稳。</p><p>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</p><p>把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势，一般当平均负载高于 CPU 数量 70% 的时候，应该分析排查负载高的问题。</p><p>查看几个 CPU数量【lscpu】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br><span class="line">40</span><br></pre></td></tr></table></figure><h4 id="vmstat"><strong>vmstat</strong></h4><p>(Vitual Memory Static)</p><p>功能：报告虚拟内存统计信息</p><p>具体使用<code>vmstat --help</code>查看详细用法。</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示活跃和非活跃内存</td></tr><tr><td>-f</td><td>显示从系统启动至今的fork数量</td></tr><tr><td>-m</td><td>显示slabinfo</td></tr><tr><td><strong>-s</strong></td><td><strong>显示内存相关统计信息及多种系统活动数量</strong></td></tr><tr><td>-d</td><td>显示磁盘相关的统计信息</td></tr><tr><td>-S</td><td>使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节(Byte)，默认单位为K(1024 Bytes)</td></tr><tr><td>delay</td><td>刷新时间间隔，如果不指定，只显示一条结果</td></tr><tr><td>count</td><td>刷新次数，如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 1 秒后输出 1 组数据</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ vmstat 1 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line">23  0 1719692 7783592 400820 23694264    0    0     1     4    0    0 46  0 54  0  0</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>类别</strong></th><th><strong>参数</strong></th><th><strong>含义</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Procs</strong></td><td>r</td><td>（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</td><td>当这个值超过了cpu个数，就会出现cpu瓶颈。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高</td></tr><tr><td></td><td>b</td><td>等待IO的进程数量，阻塞的进程</td><td></td></tr><tr><td><strong>system</strong></td><td>in</td><td>每秒中断数，包括时钟中断</td><td>这两个值越大，会看到由内核消耗的cpu时间sy会越多这个值要越小越好，太大了，要考虑调低线程或者进程的数目</td></tr><tr><td></td><td>cs</td><td>每秒上下文切换数</td><td>同上，当进行线程的切换，进行上下文切换，这个值越小越好。</td></tr><tr><td><strong>CPU</strong></td><td>us</td><td>用户进程执行消耗cpu时间</td><td>us的值比较高时，说明用户进程消耗的cpu时间多</td></tr><tr><td></td><td>sy</td><td>系统进程消耗cpu时间</td><td>sys的值过高时，说明系统内核消耗的cpu资源多，例如I/O频繁操作。</td></tr><tr><td></td><td>Id</td><td>空闲时间(包括IO等待时间)</td><td>一般来说 us+sy+id=100</td></tr><tr><td></td><td>wa</td><td>等待IO时间</td><td>wa过高时，说明io等待比较严重，可能由于磁盘大量随机访问造成，也有可能是磁盘的带宽出现瓶颈。</td></tr><tr><td></td><td>st</td><td>来自于虚拟机偷取的CPU所占的百分比</td><td></td></tr><tr><td><strong>io</strong></td><td>bi</td><td>每秒从文件系统或SWAP读入到RAM（blocks in）的块数，block(1KB磁盘块)为单位</td><td>随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</td></tr><tr><td></td><td>bo</td><td>每秒从RAM写出到文件系统或SWAP（blocks out）的块数，block(1KB磁盘块)为单位</td><td></td></tr><tr><td><strong>swap</strong></td><td>si</td><td>每秒从SWAP(交换分区)读入到RAM（swap in）的大小，单位是KB</td><td>内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响。</td></tr><tr><td></td><td>so</td><td>每秒从RAM写出到SWAP（swap out）的大小，单位是KB</td><td></td></tr><tr><td><strong>memory</strong></td><td>swpd</td><td>使用的虚拟内存的大小，单位是KB</td><td></td></tr><tr><td></td><td>free</td><td>可用的物理内存大小，单位是KB</td><td></td></tr><tr><td></td><td>buff</td><td>物理内存用来缓存读写操作的buffer大小，单位是KB</td><td></td></tr><tr><td></td><td>cache</td><td>物理内存用来缓存进程地址空间的cache大小，单位是KB</td><td></td></tr></tbody></table><h4 id="mpstat"><strong>mpstat</strong></h4><p>（Multiprocessor Statistics）</p><p>功能：报告处理器相关的统计信息。</p><p>报告每个CPU的统计信息，-p ALL 用来打印CPU的报告，默认只打印系统级别的总结信息。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-P {|ALL}</td><td>表示监控哪个CPU，例如mpstat -P 0  mpstat -P 7  mpstat -P ALL</td></tr><tr><td>internal</td><td>相邻的两次采样的间隔时间</td></tr><tr><td>count</td><td>采样的次数，count只能和delay一起使用</td></tr></tbody></table><p>各个字段含义</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>%usr</td><td>用户态占用CPU的时间(%)，不包含nice值为正的进程时间，但包括了 guest 时间。</td></tr><tr><td>%nice</td><td>代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</td></tr><tr><td>%sys</td><td>内核态占用CPU的时间(%)</td></tr><tr><td>%iowait</td><td>等待IO占用CPU的时间(%)</td></tr><tr><td>%irq</td><td>硬中断占用CPU的时间(%)</td></tr><tr><td>%soft</td><td>软中断占用CPU的时间(%)</td></tr><tr><td>%guest</td><td>CPU处理虚拟进程花费的时间开销</td></tr><tr><td>%idle</td><td>空闲CPU的时间(%)</td></tr><tr><td>%steal</td><td>代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</td></tr></tbody></table><h4 id="top"><strong>top</strong></h4><p>功能：显示最消耗CPU的任务，并且有百分百。</p><p>top的使用方式 top [-d number] | top [-bnp]</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-d number</td><td>number代表秒数，表示top命令显示的页面更新一次的间隔 (default=5s)</td></tr><tr><td>-b</td><td>以批次的方式执行top</td></tr><tr><td>-n</td><td>与-b配合使用，表示需要进行几次top命令的输出结果</td></tr><tr><td>-p</td><td>指定特定的pid进程号进行观察</td></tr></tbody></table><p>top命令显示的页面还可以输入以下按键执行相应的功能（注意大小写区分的）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>？</td><td>显示在top当中可以输入的命令</td></tr><tr><td>P</td><td>以CPU的使用资源排序显示</td></tr><tr><td>M</td><td>以内存的使用资源排序显示</td></tr><tr><td>N</td><td>以pid排序显示</td></tr><tr><td>T</td><td>由进程使用的时间累计排序显示</td></tr><tr><td>k</td><td>给某一个pid一个信号,可以用来杀死进程(9)</td></tr><tr><td>r</td><td>给某个pid重新定制一个nice值（即优先级)</td></tr><tr><td>q</td><td>退出top（用ctrl+c也可以退出top）</td></tr></tbody></table><p>top各输出参数含义</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516115231233.png" alt="image-20240516115231233"></p><p>一、top前五条信息解释</p><p>top - 14:49:28 up 1:33, 1 user, load average: 0.00, 0.00, 0.00</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>14:49:28</td><td>表示当前时间</td></tr><tr><td>up 1:33</td><td>系统远行时间，格式为时：分</td></tr><tr><td>1 user</td><td>当前登陆用户数</td></tr><tr><td>load average: 0.00, 0.00, 0.00</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值</td></tr></tbody></table><p>Tasks: 80 total, 2 running, 78 sleeping, 0 stopped, 0 zombie</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>Tasks: 80 total</td><td>进程总数</td></tr><tr><td>2 running</td><td>正在运行的进程数</td></tr><tr><td>78 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr></tbody></table><p>Cpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>0.0%us</td><td>用户空间占用CPU百分比</td></tr><tr><td>0.0%sy</td><td>内核空间占用CPU百分比</td></tr><tr><td>0.0%ni</td><td>用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td>100.0%id</td><td>空闲CPU百分比</td></tr><tr><td>0.0%wa</td><td>等待输入输出的CPU时间百分比</td></tr><tr><td>0.0%hi</td><td>硬中断（Hardware IRQ）占用CPU的百分比</td></tr><tr><td>0.0%si</td><td>软中断（Software Interrupts）占用CPU的百分比</td></tr><tr><td>0.0 st</td><td>用于有虚拟cpu的情况，用来指示被虚拟机偷掉的cpu时间</td></tr></tbody></table><p>Mem: 1922488k total, 406936k used, 1515552k free, 11940k buffers</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>1922488k total</td><td>物理内存总量</td></tr><tr><td>406936k used</td><td>使用的物理内存总量</td></tr><tr><td>1515552k free</td><td>空闲内存总量</td></tr><tr><td>11940k buffers</td><td>用作内核缓存的内存量</td></tr></tbody></table><p>Swap: 835576k total, 0k used, 835576k free, 111596k cached</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>835576k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>835576k free</td><td>空闲交换区总量</td></tr><tr><td>111596k cached</td><td>缓冲的交换区总量</td></tr></tbody></table><p>二、进程信息</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>PID</td><td>进程id</td></tr><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td>SHR</td><td>共享内存大小，单位kb</td></tr><tr><td>S</td><td>进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>COMMAND</td><td>命令名/命令行</td></tr></tbody></table><p>Note:</p><ul><li>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</li><li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li><li>%MEM 是进程使用物理内存占系统总内存的百分比。</li></ul><p>默认进入top时，各进程是按照CPU的占用量来排序的。</p><h4 id="sar">sar</h4><p>文章：<a href="https://www.cnblogs.com/zsql/p/11628766.html">linux分析利刃之sar命令详解 </a></p><p>功能：收集、报告或保存系统活动信息</p><p>sar是一个非常全面的一个分析工具，可以比较瑞士军刀，对文件的读写，系统调用的使用情况，磁盘IO，CPU相关使用情况，内存使用情况，进程活动等都可以进行有效的分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-A：所有报告的总和</span><br><span class="line">-u：输出CPU使用情况的统计信息</span><br><span class="line">-v：输出inode、文件和其他内核表的统计信息</span><br><span class="line">-d：输出每一个块设备的活动信息</span><br><span class="line">-r：输出内存和交换空间的统计信息</span><br><span class="line">-b：显示I/O和传送速率的统计信息-R：输出内存页面的统计信息</span><br><span class="line">-y：终端设备活动情况</span><br><span class="line">-w：输出系统交换活动信息</span><br><span class="line">-B：显示换页状态；</span><br><span class="line">-e：设置显示报告的结束时间</span><br><span class="line">-f：从指定文件提取报告</span><br><span class="line">-i：设状态信息刷新的间隔时间</span><br><span class="line">-p：报告每个CPU的状态</span><br><span class="line">-q：平均负载分析</span><br></pre></td></tr></table></figure><p>1.统计CPU使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -u 1 3<span class="comment"># 统计CPU的使用情况，每间隔1秒钟统计一次总共统计三次</span></span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时00分10秒     CPU     %user     %<span class="built_in">nice</span>   %system   %iowait    %steal     %idle</span><br><span class="line">15时00分11秒     all     60.64      0.00      0.90      0.00      0.00     38.46</span><br><span class="line">15时00分12秒     all     62.84      0.00      0.45      0.00      0.00     36.71</span><br><span class="line">15时00分13秒     all     60.88      0.00      1.08      0.00      0.00     38.04</span><br><span class="line">平均时间:     all     61.46      0.00      0.81      0.00      0.00     37.73</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -o test.txt -u 1 3</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -u -f test.txt</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时01分57秒     CPU     %user     %<span class="built_in">nice</span>   %system   %iowait    %steal     %idle</span><br><span class="line">15时01分58秒     all     61.59      0.00      0.43      0.00      0.00     37.99</span><br><span class="line">15时01分59秒     all     66.08      1.00      0.93      0.00      0.00     31.99</span><br><span class="line">15时02分00秒     all     62.38      0.10      1.13      0.00      0.00     36.39</span><br><span class="line">平均时间:     all     63.35      0.37      0.83      0.00      0.00     35.45</span><br></pre></td></tr></table></figure><p>2.查看磁盘IO</p><p>查看I/O和传递速率的统计信息，每间隔1秒钟统计一次总共统计三次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sar -b 1 3</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时03分49秒       tps      rtps      wtps      dtps   bread/s   bwrtn/s   bdscd/s</span><br><span class="line">15时03分50秒      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15时03分51秒      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15时03分52秒      2.00      0.00      2.00      0.00      0.00     24.00      0.00</span><br><span class="line">平均时间:      0.67      0.00      0.67      0.00      0.00      8.00      0.00</span><br></pre></td></tr></table></figure><h4 id="pidstat">pidstat</h4><p>pidstat 是sysstat软件套件的一部分，sysstat包含很多监控linux系统状态的工具，它能够从大多数linux发行版的软件源中获得。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install sysstat</span><br></pre></td></tr></table></figure><p>功能：pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</p><p>按进程或线程打印CPU用量，包括用户态和系统态时间的分解。</p><p><strong>cpu使用情况统计(-u)，针对特定进程统计(-p)</strong></p><ul><li><strong>UID</strong>:一列代表了进程的用户标识符（User Identifier）</li><li><strong>PID</strong>: 进程pid</li><li><strong>%usr</strong>: 进程在用户态运行所占cpu时间比率</li><li><strong>%system</strong>: 进程在内核态运行所占cpu时间比率</li><li>%<strong>guest</strong> :任务花费在虚拟机上的cpu使用率（运行在虚拟处理器）</li><li><strong>%CPU</strong>: 进程运行所占cpu时间比率</li><li><strong>CPU</strong>: 指示进程在哪个核运行</li><li><strong>Command</strong>: 拉起进程对应的命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ pidstat</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">15时08分27秒   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">15时08分27秒     0         1    0.01    0.01    0.00    0.00    0.01    32  systemd</span><br><span class="line">15时08分27秒     0         2    0.00    0.00    0.00    0.00    0.00    32  kthreadd</span><br><span class="line">15时08分27秒     0        14    0.00    0.00    0.00    0.00    0.00     0  ksoftirqd/0</span><br><span class="line">15时08分27秒     0        15    0.00    0.08    0.00    0.02    0.08    29  rcu_sched</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分析CPU性能瓶颈方法">分析CPU性能瓶颈方法</h3><p>《速查表》</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516151750649.png" alt="image-20240516151750649"></p><p>通常先运行几个支持指标较多的工具，<strong>top,vmstat和pidstat</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516152157984.png" alt="image-20240516152157984"></p><ul><li>从 top 的输出可以得到各种 CPU 使用率以及僵尸进程和平均负载等信息。</li><li>从 vmstat 的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数。</li><li>从 pidstat 的输出可以得到进程的用户 CPU 使用率、系统 CPU 使用率、以及自愿上下文切换和非自愿上下文切换情况。</li></ul><p>分析问题待填坑。</p><p><strong>系统优化</strong></p><ul><li><strong>CPU 绑定</strong>：一个进程可以被设置为只在一个或者多个特定的CPU上运行，而不是在所有的CPU上随机调度。这种技术被称为CPU亲和性（CPU Affinity）。通过设置CPU亲和性，可以提高缓存命中率和内存访问性能，从而提高整体性能。</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</li></ul><h2 id="内存篇">内存篇</h2><h3 id="内存信息">内存信息</h3><p>查看内存信息命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516163609218.png" alt="image-20240516163609218"></p><p>查看红框信息</p><ul><li>MemTotal：系统总内存，由于 BIOS、内核等会占用一些内存，所以这里和配置声称的内存会有一些出入，比如我这里配置有 2G，但其实只有 1.95G 可用。</li><li>MemFree：系统空闲内存。</li><li>MemAvailable：应用程序可用内存。有人会比较奇怪和 MemFree 的区别，可以从两个层面来区分，<strong>MemFree 是系统层面的，而 MemAvailable 是应用程序层面的</strong>。系统中有些内存虽然被使用了但是有一部分是可以回收的，比如 Buffers、Cached 及 Slab 这些内存，这部分可以回收的内存加上 MemFree 才是 MemAvailable 的内存值，这是内核通过特定算法算出来的，是一个估算值。</li><li>Buffers：缓冲区内存</li><li>Cached：缓存</li></ul><h3 id="常用命令-2">常用命令</h3><h4 id="free"><strong>free</strong></h4><p>查看内存使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：    65566072    34371864     6931596      927388    24262612    29574080</span><br><span class="line">交换：     2097148     1718532      378616</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free -h</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：        62Gi        32Gi       6.6Gi       905Mi        23Gi        28Gi</span><br><span class="line">交换：       2.0Gi       1.6Gi       369Mi</span><br></pre></td></tr></table></figure><p>我们观察到free 很小，buff/cache 却很大。这是由于Linux设计思想：内存闲着反正也是闲着，不如拿出来做系统缓存和缓冲区，提高数据读写的速率。</p><ul><li>Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。</li><li>Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。</li></ul><p><strong>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中</strong>。</p><p>Swap</p><p>交换空间是硬盘上的一块区域，它被操作系统用作虚拟内存，用来在物理内存（RAM）不足时，存放暂时不需要的内存数据。</p><p>详细来说，当系统的物理内存不足以支持当前的所有进程时，操作系统会选择一些暂时不活跃的内存页，把它们从物理内存移动到交换空间，从而释放出物理内存给当前活跃的进程使用。这个过程被称为“交换出”（Swap Out）。</p><p>反过来，当这些被交换出的内存页再次被需要时，操作系统会把它们从交换空间移回到物理内存，这个过程被称为“交换入”（Swap In）。</p><h4 id="pmap">pmap</h4><p>这个命令用于查看进程的内存映像信息，能够查看进程在哪些地方用了多少内存。常用 pmap -x pid 来查看。</p><p>可以看到该进程内存被哪些库、哪些文件所占用，据此我们定位程序对内存的使用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240516164838320.png" alt="image-20240516164838320"></p><p>几个字段介绍一下：</p><ul><li><p>Address：占用内存的文件的内存起始地址。</p></li><li><p>Kbytes：占用内存的字节数。</p></li><li><p>RSS：实际占用内存大小。</p></li><li><p>Dirty：脏页大小。</p></li><li><p>Mapping：占用内存的文件，[anon] 为已分配的内存，[stack] 为程序堆栈</p></li><li><p>最后的 total 为统计的总值。我们可以使用 pmap -x pid | tail -1 这样只显示最后一行，循环显示最后一行，达到监控该进程的目的。使用：</p><p>while true; do pmap -x pid | tail -1; sleep 1; done</p></li></ul><h2 id="IO-篇">IO 篇</h2><p>IO 和 存储密切相关，存储可以概括为磁盘，内存，缓存，三者读写的性能差距非常大，<strong>磁盘读写是毫秒级的（一般 0.1-10ms），内存读写是微妙级的（一般 0.1-10us），cache 是纳秒级的（一般 1-10ns）。</strong></p><h3 id="磁盘性能指标">磁盘性能指标</h3><p>五个常见指标</p><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li><li><strong>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数（每秒读写的次数）。</strong></li><li><strong>吞吐量，是指每秒的 I/O 请求大小（每秒读写的数据量）。</strong></li><li><strong>响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</strong></li></ul><h3 id="常用命令-3">常用命令</h3><h4 id="fdisk">fdisk</h4><p>查看磁盘信息，包括磁盘容量，扇区大小，IO 大小等信息，常用 fdisk -l 查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo fdisk -l</span><br><span class="line">Disk /dev/loop0：63.97 MiB，67051520 字节，130960 个扇区</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="df"><strong>df</strong></h4><p>查看磁盘使用情况，通常看磁盘使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">df</span> -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev             32G     0   32G    0% /dev</span><br><span class="line">tmpfs           6.3G  2.8M  6.3G    1% /run</span><br><span class="line">/dev/sda2       439G  253G  164G   61% /</span><br><span class="line">tmpfs            32G  136K   32G    1% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs            32G     0   32G    0% /sys/fs/cgroup</span><br><span class="line">/dev/loop1      128K  128K     0  100% /snap/bare/5</span><br><span class="line">/dev/loop4       56M   56M     0  100% /snap/core18/2812</span><br><span class="line">/dev/loop6       75M   75M     0  100% /snap/core22/1122</span><br><span class="line">/dev/loop18     350M  350M     0  100% /snap/gnome-3-38-2004/140</span><br><span class="line">/dev/loop17      13M   13M     0  100% /snap/snap-store/959</span><br><span class="line">/dev/loop13     350M  350M     0  100% /snap/gnome-3-38-2004/143</span><br><span class="line">/dev/loop19      92M   92M     0  100% /snap/gtk-common-themes/1535</span><br><span class="line">/dev/loop14     219M  219M     0  100% /snap/gnome-3-34-1804/90</span><br><span class="line">/dev/loop12      82M   82M     0  100% /snap/gtk-common-themes/1534</span><br><span class="line">/dev/loop10     219M  219M     0  100% /snap/gnome-3-34-1804/93</span><br><span class="line">/dev/sda1       511M  6.1M  505M    2% /boot/efi</span><br><span class="line">/dev/sdb2       3.6T  438G  3.0T   13% /data</span><br><span class="line">tmpfs           6.3G   76K  6.3G    1% /run/user/1000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="vmstat-2">vmstat</h4><p>常用的还是这个万能的 vmstat：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line">24  0 1718020 6435840 450144 23930416    0    0     1     4    0    0 46  0 54  0  0</span><br></pre></td></tr></table></figure><p>对于 IO，我们常关注三个部分：</p><ul><li>b 值：表示因为 IO 阻塞排队的任务数</li><li>bi 和 bo 值：表示每秒读写磁盘的块数，bi（block in）是写磁盘，bo（block out）是读磁盘。</li><li>wa 值：表示因为 IO 等待（wait）而消耗的 CPU 比例。</li></ul><p>一般这几个值偏大，都意味着系统 IO 的消耗较大，对于读请求较大的服务器，b、bo、wa 的值偏大，而写请求较大的服务器，b、bi、wa 的值偏大。</p><h4 id="iostat"><strong>iostat</strong></h4><p>vmstat 虽然万能，但是它分析的东西有限，<strong>iostat 是专业分析 IO 性能的工具，可以方便查看 CPU、网卡、tty 设备、磁盘、CD-ROM 等等设备的信息</strong>，非常强大，总结下来，共有以下几种用法：</p><p><strong>1）iostat -c 查看部分 CPU 使用情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ iostat -c</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %<span class="built_in">nice</span> %system %iowait  %steal   %idle</span><br><span class="line">          45.91    0.00    0.31    0.01    0.00   53.77</span><br></pre></td></tr></table></figure><p>这里显示的是多个 CPU 的平均值，每个字段的含义我就不多解释了，我一般会重点关注 %iowait 和 %idle，分别表示 CPU 等待 IO 完成时间的百分比和 CPU 空闲时间百分比。</p><p><strong>如果 %iowait 较高，则表明磁盘存在 IO 瓶颈，如果 %idle 较高，则 CPU 比较空闲，如果两个值都比较高，则有可能 CPU 在等待分配内存，瓶颈在内存，此时应该加大内存，如果 %idle 较低，则此时瓶颈在 CPU，应该增加 CPU 资源。</strong></p><p><strong>2）iostat -d 查看磁盘使用情况</strong>，主要是<strong>显示 IOPS 和吞吐量信息</strong>（-k : 以 KB 为单位显示，-m：以 M 为单位显示）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ iostat -d -k</span><br><span class="line">Linux 5.15.0-91-generic (sv-NF5280M5)   2024年05月16日  _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">loop0             0.00         0.00         0.00         0.00        731          0          0</span><br><span class="line">loop1             0.00         0.00         0.00         0.00         21          0          0</span><br><span class="line">loop10            0.00         0.00         0.00         0.00       2175          0          0</span><br><span class="line">loop11            0.00         0.00         0.00         0.00       1460          0          0</span><br><span class="line">loop12            0.00         0.00         0.00         0.00       2120          0          0</span><br><span class="line">loop13            0.00         0.00         0.00         0.00       2192          0          0</span><br><span class="line">loop14            0.00         0.00         0.00         0.00       2155          0          0</span><br><span class="line">loop15            0.00         0.00         0.00         0.00       1234          0          0</span><br><span class="line">loop16            0.00         0.00         0.00         0.00       1500          0          0</span><br></pre></td></tr></table></figure><p>其中，几个参数分别解释如下：</p><ul><li>tps：设备每秒的传输次数（transfers per second），也就是读写次数。</li><li>kB_read/s 和 kB_wrtn/s：每秒读写磁盘的数据量。</li><li>kB_read 和 kB_wrtn：读取磁盘的数据总量。</li></ul><p><strong>3）iostat -x 查看磁盘详细信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %<span class="built_in">nice</span> %system %iowait  %steal   %idle</span><br><span class="line">          45.91    0.00    0.31    0.01    0.00   53.77</span><br><span class="line"></span><br><span class="line">Device            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz  aqu-sz  %util</span><br><span class="line">loop0            0.00      0.00     0.00   0.00    0.25     7.31    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00   0.00</span><br><span class="line">loop1            0.00      0.00     0.00   0.00    0.33     1.40    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00   0.00</span><br></pre></td></tr></table></figure><p>其中，几个参数解释如下；</p><ul><li>rrqm/s 和 wrqm/s：分别每秒进行合并的读操作数和写操作数，这是什么意思呢，合并就是说把多次 IO 请求合并成少量的几次，这样可以减小 IO 开销，buffer 存在的意义就是为了解决这个问题的。</li><li>r/s 和 w/s：每秒磁盘读写的次数。这两个值相加就是 tps。</li><li>rkB/s 和 wkB/s：每秒磁盘读写的数据量，这两个值和上面的 kB_read/s、kB_wrnt/s 是一样的。</li><li>avgrq-sz：平均每次读写磁盘扇区的大小。</li><li>avgqu-sze：平均 IO 队列长度。队列长度越短越好。</li><li>await：平均每次磁盘读写的等待时间（ms）。</li><li>svctm：平均每次磁盘读写的服务时间（ms）。</li><li>%util：一秒钟有百分之多少的时间用于磁盘读写操作。</li></ul><p>以上这些参数太多了，我们并不需要每个都关注，可以重点关注两个：</p><p><strong>a. %util：衡量 IO 的繁忙程度</strong></p><p>这个值越大，说明产生的 IO 请求较多，IO 压力较大，我们可以结合 %idle 参数来看，如果 %idle &lt; 70% 就说明 IO 比较繁忙了。也可以结合 vmstat 的 b 参数（等待 IO 的进程数）和 wa 参数（IO 等待所占 CPU 时间百分比）来看，如果 wa &gt; 30% 也说明 IO 较为繁忙。</p><p><strong>b. await：衡量 IO 的响应速度</strong></p><p>通俗理解，await 就像我们去医院看病排队等待的时间，这个值和医生的服务速度（svctm）和你前面排队的人数（avgqu-size）有关。如果 svctm 和 await 接近，说明磁盘 IO 响应时间较快，排队较少，如果 await 远大于 svctm，说明此时队列太长，响应较慢，这时可以考虑换性能更好的磁盘或升级 CPU。</p><p><strong>4）iostat 1 2 默认显示 cpu 和 吞吐量信息，1 定时 1s 显示，2 显示 2 条信息</strong></p><h4 id="iotop"><strong>iotop</strong></h4><p>用于查看每个进程的 IO 情况，有了这个命令，就可以定位具体哪个进程的 IO 开销比较大了。</p><p>总结：<strong>fdisk -l 和 df 查看磁盘基本信息，iostat -d 查看磁盘 IOPS 和吞吐量，iostat -x 结合 vmstat 查看磁盘的繁忙程度和处理效率</strong>。</p><h2 id="网络篇">网络篇</h2><h3 id="ping">ping</h3><p>ping 发送 ICMP echo 数据包来探测网络的连通性，除了能直观地看出网络的连通状况外，还能获得本次连接的往返时间（RTT 时间），丢包情况，以及访问的域名所对应的 IP 地址（使用 DNS 域名解析），比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (183.2.172.42) 56(84) bytes of data.</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=1 ttl=50 时间=32.9 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=2 ttl=50 时间=32.7 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=3 ttl=50 时间=32.9 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=4 ttl=50 时间=32.8 毫秒</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping 统计 ---</span><br><span class="line">已发送 4 个包， 已接收 4 个包, 0% 包丢失, 耗时 3004 毫秒</span><br><span class="line">rtt min/avg/max/mdev = 32.677/32.833/32.946/0.103 ms</span><br></pre></td></tr></table></figure><p>我们 <code>ping baidu.com，-c</code> 参数指定发包数。可以看到，解析到了 baidu 的一台服务器 IP 地址为 183.2.172.42。RTT 时间的最小、平均、最大和算术平均差分别是32.677/32.833/32.946/0.103 ms</p><h3 id="ifconfig">ifconfig</h3><p>ifconfig 命令被用于配置和显示 Linux 内核中网络接口的统计信息。通过这些统计信息，我们也能够进行一定的网络性能调优。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ ifconfig</span><br><span class="line">eno1: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 9c:c2:c4:04:8a:78  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eno2: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 9c:c2:c4:04:8a:79  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eno4: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.168.157.251  netmask 255.255.255.0  broadcast 10.168.157.255</span><br><span class="line">        inet6 fe80::9ec2:c4ff:fe04:8a7b  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 9c:c2:c4:04:8a:7b  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 601118544  bytes 77263020820 (77.2 GB)</span><br><span class="line">        RX errors 0  dropped 56947  overruns 0  frame 0</span><br><span class="line">        TX packets 358969340  bytes 106533835973 (106.5 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 250401850  bytes 62505601736 (62.5 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 250401850  bytes 62505601736 (62.5 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>这是关于Linux下的网络接口信息的输出。让我们逐行解释一下：</p><ol><li><code>eno4: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</code>：这是网络接口eno4的状态信息。&quot;UP&quot;表示接口正在运行；&quot;BROADCAST&quot;表示接口有广播能力；&quot;RUNNING&quot;表示接口是活动的；&quot;MULTICAST&quot;表示接口支持多播。&quot;mtu 1500&quot;表示最大传输单元（MTU）是1500字节，这是以太网的标准MTU。</li><li><code>inet 10.168.157.251 netmask 255.255.255.0 broadcast 10.168.157.255</code>：这是IPv4的地址信息。&quot;inet 10.168.157.251&quot;表示IPv4地址是10.168.157.251；&quot;netmask 255.255.255.0&quot;表示子网掩码是255.255.255.0；&quot;broadcast 10.168.157.255&quot;表示广播地址是10.168.157.255。</li><li><code>inet6 fe80::9ec2:c4ff:fe04:8a7b prefixlen 64 scopeid 0x20&lt;link&gt;</code>：这是IPv6的地址信息。&quot;inet6 fe80::9ec2:c4ff:fe04:8a7b&quot;表示IPv6地址是fe80::9ec2:c4ff:fe04:8a7b；&quot;prefixlen 64&quot;表示前缀长度是64位；&quot;scopeid 0x20&lt; link &gt;&quot;表示这是一个链路本地地址。</li><li><code>ether 9c:c2:c4:04:8a:7b txqueuelen 1000 (以太网)</code>：这是物理地址信息。&quot;ether 9c:c2:c4:04:8a:7b&quot;表示MAC地址是9c:c2:c4:04:8a:7b；&quot;txqueuelen 1000&quot;表示发送队列的长度是1000。</li><li><code>RX packets 469211354 bytes 68619885994 (68.6 GB)</code>：这是接收（Receive）的数据信息。&quot;RX packets 469211354&quot;表示接收了469211354个数据包；&quot;bytes 68619885994 (68.6 GB)&quot;表示接收的数据总量是68.6 GB。</li><li><code>TX packets 101656642 bytes 33416911871 (33.4 GB)</code>：这是发送（Transmit）的数据信息。&quot;TX packets 101656642&quot;表示发送了101656642个数据包；&quot;bytes 33416911871 (33.4 GB)&quot;表示发送的数据总量是33.4 GB。</li><li><code>RX errors 0 dropped 56877 overruns 0 frame 0</code> 和 <code>TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code>：这些是网络错误的统计信息。包括错误的数据包数量、丢弃的数据包数量、overruns（数据包过多，接口处理不过来）的数量等。</li></ol><h3 id="IP">IP</h3><p>ip 命令用来显示或设置 Linux 主机的网络接口、路由、网络设备、策略路由和隧道等信息，是 Linux 下功能强大的网络配置工具，旨在替代 ifconfig 命令，如下显示 IP 命令的强大之处，功能涵盖到 ifconfig、netstat、route 三个命令。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240521222605084.png" alt="image-20240521222605084"></p><h3 id="netstat">netstat</h3><p>netstat 可以查看整个 Linux 系统关于网络的情况，是一个集多钟网络工具于一身的组合工具。<br>常用的选项包括以下几个：</p><ul><li>默认：列出连接的套接字</li><li>-a：列出所有套接字的信息</li><li>-s：各种网络协议栈统计信息</li><li>-i：网络接口信息</li><li>-r：列出路由表</li><li>-l：仅列出有在 Listen 的服务状态</li><li>-p：显示 PID 和进程名称</li></ul><p>各参数组合使用实例如下：</p><ul><li>netstat -at 列出所有 TCP 端口</li><li>netstat -au 列出所有 UDP 端口</li><li>netstat -lt 列出所有监听 TCP 端口的 socket</li><li>netstat -lu 列出所有监听 UDP 端口的 socket</li><li>netstat -lx 列出所有监听 UNIX 端口的 socket</li><li>netstat -ap | grep ssh 找出程序运行的端口</li><li>netstat -an | grep ‘:80’ 找出运行在指定端口的进程</li></ul><p><strong>1）netstat 默认显示连接的套接字数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ netstat</span><br><span class="line">激活Internet连接 (w/o 服务器)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 10.168.157.251:60242    182.100.46.118:https    ESTABLISHED</span><br><span class="line">tcp        1      0 10.168.157.251:33878    101.6.15.130:http       CLOSE_WAIT</span><br><span class="line">tcp        0      0 10.168.157.251:41326    182.100.46.63:https     ESTABLISHED</span><br></pre></td></tr></table></figure><p><strong>2）netstat -i 显示网络接口信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eno1      1500        0      0      0 0             0      0      0      0 BMU</span><br><span class="line">eno2      1500        0      0      0 0             0      0      0      0 BMU</span><br><span class="line">eno4      1500 601157740      0  56947 0      358974952      0      0      0 BMRU</span><br><span class="line">lo       65536 250402016      0      0 0      250402016      0      0      0 LRU</span><br></pre></td></tr></table></figure><p>接口信息包括网络接口名称（Iface）、MTU，以及一系列接收（RX-）和传输（TX-）的指标。其中 OK 表示传输成功的包，ERR 是错误包，DRP 是丢包，OVR 是超限包。</p><p>这些参数有助于我们对网络收包情况进行分析，从而判断瓶颈所在。</p><p><strong>3）netstat -s 显示所有网络协议栈的信息</strong></p><p><strong>4）netstat -r 显示路由表信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ netstat -r</span><br><span class="line">内核 IP 路由表</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         10.168.157.1    0.0.0.0         UG        0 0          0 eno4</span><br><span class="line">10.168.157.0    0.0.0.0         255.255.255.0   U         0 0          0 eno4</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U         0 0          0 eno4</span><br></pre></td></tr></table></figure><h3 id="ifstat">ifstat</h3><p>ifstat 主要用来监测主机网口的网络流量，常用的选项包括：</p><ul><li>-a：监测主机所有网口</li><li>-i：指定要监测的网口</li><li>-t：在每行输出信息前加上时间戳</li><li>-b：以 Kbit/s 显示流量数据，而不是默认的 KB/s</li><li>-delay：采样间隔（单位是 s），即每隔 delay 的时间输出一次统计信息</li><li>-count：采样次数，即共输出 count 次统计信息</li></ul><h3 id="netcat">netcat</h3><p>netcat，简称 nc，命令简单，但功能强大，在排查网络故障时非常有用，因此它也在众多网络工具中有着“瑞士军刀”的美誉。</p><p>它主要被用来构建网络连接。可以以客户端和服务端的方式运行，当以服务端方式运行时，它负责监听某个端口并接受客户端的连接，因此可以用它来调试客户端程序；当以客户端方式运行时，它负责向服务端发起连接并收发数据，因此也可以用它来调试服务端程序，此时它有点像 Telnet 程序。</p><p>常用的选项包括以下几种：</p><ul><li>-l：以服务端的方式运行，监听指定的端口。默认是以客户端的方式运行。</li><li>-k：重复接受并处理某个端口上的所有连接，必须与 -l 一起使用。</li><li>-n：使用 IP 地址表示主机，而不是主机名，使用数字表示端口号，而不是服务名称。</li><li>-p：当以客户端运行时，指定端口号。</li><li>-s：设置本地主机发出的数据包的 IP 地址。</li><li>-C：将 CR 和 LF 两个字符作为结束符。</li><li>-U：使用 UNIX 本地域套接字通信。</li><li>-u：使用 UDP 协议通信，默认使用的是 TCP 协议。</li><li>-w：如果 nc 客户端在指定的时间内未检测到任何输入，则退出。</li><li>-X：当 nc 客户端与代理服务器通信时，该选项指定它们之间的通信协议，目前支持的代理协议包括 “4”（SOCKS v.4），“5”（SOCKS v.5）和 “connect” （HTTPs Proxy），默认使用 SOCKS v.5。</li><li>-x：指定目标代理服务器的 IP 地址和端口号。</li></ul><p>下面举一个简单的例子，使用 nc 命令发送消息：</p><p>首先，启动服务端，用 <code>nc -l 0.0.0.0 12345</code> 监听端口 12345 上的所有连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ nc -l 127.0.0.1 12345</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>然后，启动客户端，用 <code>nc -p 1234 127.0.0.1 12345</code> 使用 1234 端口连接服务器 127.0.0.1::12345。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ nc -p 1234 127.0.0.1 12345</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>着就可以在两端互发数据了。</p><h3 id="tcpdump">tcpdump</h3><p>最后是 tcpdump，强大的网络抓包工具。虽然有 wireshark 这样更易使用的图形化抓包工具，但 tcpdump 仍然是网络排错的必备利器。</p><p>tcpdump 选项很多，我就不一一列举了，大家可以看文章末尾的引用来进一步了解。这里列举几种 tcpdump 常用的用法。</p><p><strong>1）捕获某主机的数据包</strong></p><p>比如想要捕获主机 200.200.200.100 上所有收到和发出的所有数据包，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 200.200.200.100</span><br></pre></td></tr></table></figure><p><strong>2）捕获多个主机的数据包</strong></p><p>比如要捕获主机 200.200.200.1 和主机 200.200.200.2 或 200.200.200.3 的通信，使用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host <span class="number">200</span>.<span class="number">200</span>.<span class="number">200</span>.<span class="number">1</span> <span class="keyword">and </span>\(<span class="number">200</span>.<span class="number">200</span>.<span class="number">200</span>.<span class="number">2</span> <span class="keyword">or </span>\)</span><br></pre></td></tr></table></figure><p>同样要捕获主机 200.200.200.1 除了和主机 200.200.200.2 之外所有主机通信的 IP 包。使用：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tcpdump</span> <span class="built_in">ip</span> host <span class="number">200</span>.<span class="number">200</span>.<span class="number">200</span>.<span class="number">1</span> <span class="keyword">and</span> ! <span class="number">200</span>.<span class="number">200</span>.<span class="number">200</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>3）捕获某主机接收或发出的某种协议类型的包</strong></p><p>比如要捕获主机 200.200.200.1 接收或发出的 Telnet 包，使用：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump tcp <span class="keyword">port</span> <span class="number">23</span> host <span class="number">200.200</span>.<span class="number">200.1</span></span><br></pre></td></tr></table></figure><p><strong>4）捕获某端口相关的数据包</strong></p><p>比如捕获在端口 6666 上通过的包，使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tcpdump</span> <span class="string">port</span> <span class="number">6666</span></span><br></pre></td></tr></table></figure><p><strong>5）捕获某网口的数据包</strong></p><p>比如捕获在网口 eth0 上通过的包，使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -<span class="selector-tag">i</span> eth0</span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/weixin_45465395/article/details/115728520">linux top命令详解（看这一篇就够了）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1OTY2MzMxOQ==&amp;mid=2247484103&amp;idx=1&amp;sn=d437fd54bac8ac00522aa4538ca9c7a1&amp;chksm=ea74367fdd03bf699d603f39836bb35c0e6190f6781e0eda104a3710705034293255e85bd6b4&amp;scene=21#wechat_redirect">一文掌握 Linux 性能分析之 CPU 篇</a></li></ul>]]></content>
    
    
    <summary type="html">Linux Performance</summary>
    
    
    
    <category term="Linux" scheme="https://penge666.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://penge666.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Sanitizer</title>
    <link href="https://penge666.github.io/posts/f07e3ce0.html"/>
    <id>https://penge666.github.io/posts/f07e3ce0.html</id>
    <published>2024-05-14T11:48:21.000Z</published>
    <updated>2024-05-14T12:29:22.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sanitizer">Sanitizer</h2><p>Sanitizer是由Google发起的开源工具集，用于检测内存泄露等问题。它包括了AddressSanitizer、MemorySanitizer、ThreadSanitizer、LeakSanitizer等多种工具。这些工具最初是LLVM项目的一部分，后来也被GNU的GCC编译器支持。从GCC的4.8版本开始，就已经支持AddressSanitizer和ThreadSanitizer，而4.9版本则开始支持LeakSanitizer。</p><ul><li><strong>AddressSanitizer</strong>，检测内存访问问题</li><li><strong>MemorySanitizer</strong>，检测未初始化内存问题</li><li><strong>ThreadSanitizer</strong>，检测线程竞态和死锁问题</li><li><strong>LeakSanitizer</strong>，检测内存泄露问题</li></ul><p>编译器自带。相比于检测工具valgrind，它对程序性能的影响更小，用过valgrind的就知道，使用valgrind后程序的性能大大降低。</p><p>官方链接：<a href="https://link.zhihu.com/?target=https%3A//github.com/google/sanitizers/wiki/">https://link.zhihu.com/?target=https%3A//github.com/google/sanitizers/wiki/</a></p><h2 id="AddressSanitizer">AddressSanitizer</h2><p><strong>原理介绍</strong><br>AddressSanitizer（简称ASan）是一种内存错误检测器，它可以检测出各种内存相关的错误，包括内存泄漏。在Android NDK中，我们可以通过在编译选项中添加-fsanitize=address来启用ASan。ASan会在程序运行时监控内存操作，当检测到内存泄漏时，会打印出详细的错误信息，包括泄漏的大小、位置和堆栈信息。</p><p><strong>AddressSanitizer的原理</strong></p><ul><li><p>内存布局变换：ASan在编译时改变程序的内存布局，使得程序中的每个对象（变量、数组等）周围都有一些额外的“红色区域”（redzones）。这些红色区域用于检测内存访问越界。例如，如果一个数组的访问越过了它的边界并访问了红色区域，ASan就会报告一个缓冲区溢出错误。</p></li><li><p>影子内存：ASan使用影子内存（shadow memory）来跟踪程序中的每个内存字节的状态。影子内存是程序内存的一个映射，用于存储有关内存状态的元数据，如内存是否已分配、是否已初始化等。当程序访问内存时，ASan会检查对应的影子内存，以确定访问是否合法。</p></li><li><p>编译器插桩：ASan通过编译器插桩（instrumentation）在程序中插入检查代码。这些检查代码在内存访问发生时执行，以检测潜在的内存错误。例如，ASan会在堆分配和释放函数（如malloc和free）中插入代码，以检测内存泄漏和使用已释放的内存。</p></li></ul><p><strong>工具使用</strong></p><p>ASan是一个C/C++的内存错误检测工具，它能够检测：</p><ul><li>Use after free，悬空指针引用，也叫野指针引用，即对free后的内存进行存取操作。</li><li>Heap buffer overflow，堆溢出访问，即对堆的操作越界了。</li><li>Stack buffer overflow，栈溢出访问，即对栈的操作越界了。</li><li>Global buffer overflow，全局缓冲区溢出，例如全局的数组这些，反正都是越界访问，只不过位于程序的不同segment。</li><li>Use after return，即栈的野指针，例如A函数调用B函数，A函数有个指针传入到B中，B把它赋值指向了B的一个局部变量，即栈变量，B返回到A后，A操作该指针的错误。</li><li>Use after scope，和Use after return有点类似，C/C++的{}表示一个scope。</li><li>Initialization order bugs</li><li>Memory leaks，内存泄露，AddressSanitizer集成了LeakSanitizer的功能。</li></ul><blockquote><p><strong>Use after free</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -fsanitize=address main.cpp -fpermissive</span><br><span class="line">main.cpp: In <span class="keyword">function</span> ‘int main(int, char**)’:</span><br><span class="line">main.cpp:5:21: warning: invalid conversion from ‘void*’ to ‘char*’ [-fpermissive]</span><br><span class="line">    5 |     char *p = malloc(10);</span><br><span class="line">      |               ~~~~~~^~~~</span><br><span class="line">      |                     |</span><br><span class="line">      |                     void*</span><br></pre></td></tr></table></figure><p>Note：<code>-g</code>是一个选项，用来为生成的可执行文件添加调试信息。</p><p>查看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./a.out</span><br><span class="line">=================================================================</span><br><span class="line">==<span class="number">1336741</span>==ERROR: AddressSanitizer: heap-use-after-free on address <span class="number">0x602000000010</span> at pc <span class="number">0x55bced57822a</span> bp <span class="number">0x7ffc50d251d0</span> sp <span class="number">0x7ffc50d251c0</span></span><br><span class="line">WRITE of size <span class="number">1</span> at <span class="number">0x602000000010</span> thread T0</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x55bced578229</span> in main /home/sv/桌面/main.cpp:<span class="number">7</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x7faf0d998082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x55bced57810d</span> in _start (/home/sv/桌面/a.out+<span class="number">0x110d</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000000010</span> is located <span class="number">0</span> bytes inside of <span class="number">10</span>-byte region [<span class="number">0x602000000010</span>,<span class="number">0x60200000001a</span>)</span><br><span class="line">freed by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x7faf0dfbf40f</span> in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:<span class="number">122</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x55bced5781f5</span> in main /home/sv/桌面/main.cpp:<span class="number">6</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x7faf0d998082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line"></span><br><span class="line">previously allocated by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x7faf0dfbf808</span> in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:<span class="number">144</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x55bced5781e5</span> in main /home/sv/桌面/main.cpp:<span class="number">5</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x7faf0d998082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/sv/桌面/main.cpp:<span class="number">7</span> in main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff7fb0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fc0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fd0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fe0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7ff0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x0c047fff8000</span>: fa fa[fd]fd fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8010</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8020</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8030</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8040</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8050</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte <span class="built_in">legend</span> (one shadow byte represents <span class="number">8</span> application bytes):</span><br><span class="line">  Addressable:           <span class="number">00</span></span><br><span class="line">  Partially addressable: <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span></span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="keyword">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==<span class="number">1336741</span>==ABORTING</span><br></pre></td></tr></table></figure><p>显然，存在 heap-use-after-free。</p><p>仔细分析下上述信息：</p><p>1.进程号，错误类型，操作是读，还是写，操作的地址，线程号等，以及栈的回溯信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==1336741==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x55bced57822a bp 0x7ffc50d251d0 sp 0x7ffc50d251c0</span><br><span class="line">WRITE of size 1 at 0x602000000010 thread T0</span><br><span class="line">    <span class="comment">#0 0x55bced578229 in main /home/sv/桌面/main.cpp:7</span></span><br><span class="line">    <span class="comment">#1 0x7faf0d998082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x55bced57810d in _start (/home/sv/桌面/a.out+0x110d)</span></span><br></pre></td></tr></table></figure><p>2.对此块内存的操作的具体位置，对10字节的内存区域[0x602000000010,0x60200000001a),的第0个字节操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000000010 is located 0 bytes inside of 10-byte region [0x602000000010,0x60200000001a)</span><br><span class="line">freed by thread T0 here:</span><br><span class="line">    <span class="comment">#0 0x7faf0dfbf40f in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:122</span></span><br><span class="line">    <span class="comment">#1 0x55bced5781f5 in main /home/sv/桌面/main.cpp:6</span></span><br><span class="line">    <span class="comment">#2 0x7faf0d998082 in __libc_start_main ../csu/libc-start.c:308</span></span><br></pre></td></tr></table></figure><p>3.此块内存区域在那个线程，哪个地方分配的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">previously allocated by thread T0 here:</span><br><span class="line">    <span class="comment">#0 0x7faf0dfbf808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144</span></span><br><span class="line">    <span class="comment">#1 0x55bced5781e5 in main /home/sv/桌面/main.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x7faf0d998082 in __libc_start_main ../csu/libc-start.c:308</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Heap buffer overflow</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p[<span class="number">10</span>] =  <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -fsanitize=address main.cpp -fpermissive</span><br><span class="line">main.cpp: In <span class="keyword">function</span> ‘int main(int, char**)’:</span><br><span class="line">main.cpp:5:21: warning: invalid conversion from ‘void*’ to ‘char*’ [-fpermissive]</span><br><span class="line">    5 |     char *p = malloc(10);</span><br><span class="line">      |               ~~~~~~^~~~</span><br><span class="line">      |                     |</span><br><span class="line">      |                     void*</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./a.out</span><br><span class="line">=================================================================</span><br><span class="line">==1336960==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000001a at pc 0x5563af190226 bp 0x7fff4fbb4d30 sp 0x7fff4fbb4d20</span><br><span class="line">WRITE of size 1 at 0x60200000001a thread T0</span><br><span class="line">    <span class="comment">#0 0x5563af190225 in main /home/sv/桌面/main.cpp:6</span></span><br><span class="line">    <span class="comment">#1 0x7f88cfff5082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x5563af19010d in _start (/home/sv/桌面/a.out+0x110d)</span></span><br><span class="line"></span><br><span class="line">0x60200000001a is located 0 bytes to the right of 10-byte region [0x602000000010,0x60200000001a)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    <span class="comment">#0 0x7f88d061c808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144</span></span><br><span class="line">    <span class="comment">#1 0x5563af1901e5 in main /home/sv/桌面/main.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x7f88cfff5082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/sv/桌面/main.cpp:6 <span class="keyword">in</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">=&gt;0x0c047fff8000: fa fa 00[02]fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07</span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="built_in">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      <span class="built_in">fc</span></span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==1336960==ABORTING</span><br></pre></td></tr></table></figure><blockquote><p><strong>Stack buffer overflow</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> p[<span class="number">10</span>];</span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==26927==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffe0389d7a at pc 0x5577fcfd7289 bp 0x7fffe0389d30 sp 0x7fffe0389d20</span><br><span class="line">WRITE of size 1 at 0x7fffe0389d7a thread T0</span><br><span class="line">    <span class="comment">#0 0x5577fcfd7288 in main /home/thomas/test/ctest/main.c:5</span></span><br><span class="line">    <span class="comment">#1 0x7f97e9d0d082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x5577fcfd710d in _start (/home/thomas/test/ctest/a.out+0x110d)</span></span><br><span class="line"> </span><br><span class="line">Address 0x7fffe0389d7a is located <span class="keyword">in</span> stack of thread T0 at offset 42 <span class="keyword">in</span> frame</span><br><span class="line">    <span class="comment">#0 0x5577fcfd71d8 in main /home/thomas/test/ctest/main.c:3</span></span><br><span class="line"> </span><br><span class="line">  This frame has 1 object(s):</span><br><span class="line">    [32, 42) <span class="string">&#x27;p&#x27;</span> (line 4) &lt;== Memory access at offset 42 overflows this variable</span><br><span class="line">HINT: this may be a <span class="literal">false</span> positive <span class="keyword">if</span> your program uses some custom stack unwind mechanism, swapcontext or vfork</span><br><span class="line">      (longjmp and C++ exceptions *are* supported)</span><br><span class="line">SUMMARY: AddressSanitizer: stack-buffer-overflow /home/thomas/test/ctest/main.c:5 <span class="keyword">in</span> main</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p><strong>Global buffer overflow</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> p[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，运行输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==27271==ERROR: AddressSanitizer: global-buffer-overflow on address 0x5632b22930aa at pc 0x5632b2290213 bp 0x7ffeba0b5140 sp 0x7ffeba0b5130</span><br><span class="line">WRITE of size 1 at 0x5632b22930aa thread T0</span><br><span class="line">    <span class="comment">#0 0x5632b2290212 in main /home/thomas/test/ctest/main.c:5</span></span><br><span class="line">    <span class="comment">#1 0x7f90fd627082 in __libc_start_main ../csu/libc-start.c:308</span></span><br><span class="line">    <span class="comment">#2 0x5632b229010d in _start (/home/thomas/test/ctest/a.out+0x110d)</span></span><br><span class="line"> </span><br><span class="line">0x5632b22930aa is located 0 bytes to the right of global variable <span class="string">&#x27;p&#x27;</span> defined <span class="keyword">in</span> <span class="string">&#x27;main.c:2:6&#x27;</span> (0x5632b22930a0) of size 10</span><br><span class="line">SUMMARY: AddressSanitizer: global-buffer-overflow /home/thomas/test/ctest/main.c:5 <span class="keyword">in</span> main</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>。。。</p><h2 id="LeakSanitizer">LeakSanitizer</h2><p>LeakSanitizer是一个强大的内存泄漏检测工具，主要用于C/C++程序的内存泄漏问题诊断。它通过在程序运行时监控动态内存分配和释放的行为，帮助开发者快速定位和解决内存泄漏问题。LeakSanitizer是Clang/LLVM编译器套件的一部分，与GCC编译器的内存泄漏检测工具Valgrind互为补充。</p><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="comment">// ptr没有被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ clang -g -fsanitize=leak main.cpp -fpermissive</span><br></pre></td></tr></table></figure><p>查看【Note:g++编译可能会出错~】</p><p>推荐阅读：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/357803433">详解三大编译器：gcc、llvm 和 clang - 知乎专栏</a></li><li><a href="https://zhuanlan.zhihu.com/p/682607611">GCC vs Clang: 两大编译器巨头的龙争虎斗 - 知乎专栏</a></li><li><a href="https://www.cnblogs.com/findumars/p/14213309.html">GCC与Clang / LLVM：C / C ++编译器的深度比较 - findumars - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/545695166">clang 与 GCC 的区别 - 知乎 - 知乎专栏</a></li><li><a href="https://zh.wikipedia.org/wiki/Clang">Clang - 维基百科，自由的百科全书</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./a.out</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==1338908==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x407925 in malloc (/home/sv/桌面/a.out+0x407925)</span></span><br><span class="line">    <span class="comment">#1 0x426dc1 in foo() /home/sv/桌面/main.cpp:4:23</span></span><br><span class="line">    <span class="comment">#2 0x426de3 in main /home/sv/桌面/main.cpp:9:5</span></span><br><span class="line">    <span class="comment">#3 0x7f0251d2e082 in __libc_start_main /build/glibc-e2p3jK/glibc-2.31/csu/../csu/libc-start.c:308:16</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>LeakSanitizer主要针对动态内存分配的检测，对于静态分配或全局分配的内存泄漏无能为力。</li><li>启用LeakSanitizer可能会对程序性能产生一定影响，因此通常在开发和测试阶段使用，而不推荐在生产环境中持续启用。</li><li>在使用LeakSanitizer时，可能会遇到各种问题，如初始化失败、缺少依赖库等。这些问题通常需要根据具体的错误信息进行排查和解决。</li></ol><p><strong>AddressSanitizer和LeakSanitizer的区别</strong></p><p>AddressSanitizer（ASan）和LeakSanitizer（LSan）都是用于内存错误检测的工具，它们的主要区别在于检测的问题类型和应用场景。</p><ol><li>AddressSanitizer（ASan）:<ul><li>ASan是一种用于检测内存错误的工具，包括内存访问越界、使用释放的内存、堆栈溢出等问题。</li><li>ASan能够在编译时插额外的运行时检查代码，对进行动态分析，提供详细的信息和错误的位置。</li><li>ASan要用于发现和调试内存相关的问题，可以帮助开发者早发现和修内存错误。</li></ul></li><li>LeakSanitizer（LS）:<ul><li>LSan是一种用于检测内存泄漏的工具，主要用于检测程序中的动态内存分配和没有释放的内存。</li><li>LSan通过追踪内存分配和释放操作，检测出未释放的内存并报告泄漏的位置和类型。</li><li>LSan主要用于发现内存泄漏问题，帮助开发者查找未释放的内存资源，优化内存使用效率。</li></ul></li></ol><p>ASan主要用于检测内存错误，如越界访问和释放后，而LSan主用于检测内存泄漏问题。它们都能够在编译时插入额外的运行时检查代码，帮助开发者发现修复内存相关问题。</p><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/thammer/p/17117286.html">Sanitizers使用介绍</a></li><li><a href="https://blog.csdn.net/zjtimef/article/details/138415276">LeakSanitizer概述与使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/508470880">[C++]🤓Mac下C++内存检查指北(Valgrind VS Asan)</a></li><li><a href="https://zhuanlan.zhihu.com/p/37515148">内存检测工具AddressSanitizer</a></li><li><a href="https://zhuanlan.zhihu.com/p/28117513">AddressSanitizer算法及源码分析</a></li></ul>]]></content>
    
    
    <summary type="html">内存检测-Sanitizer</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Valgrind</title>
    <link href="https://penge666.github.io/posts/41691f83.html"/>
    <id>https://penge666.github.io/posts/41691f83.html</id>
    <published>2024-05-14T02:30:16.000Z</published>
    <updated>2024-05-18T12:18:44.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Valgrind的介绍">Valgrind的介绍</h2><blockquote><p><strong>介绍</strong></p></blockquote><p>Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。Valgrind的体系结构如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240514111938295.png" alt="image-20240514111938295"></p><p>通俗的说：</p><p>Valgrind是一个由多个组件构成的内存调试工具套件。这些组件可以分为两类：内核和基于内核的其他工具。</p><ol><li><strong>内核</strong>：内核在这里可以被理解为Valgrind的核心部分，它提供了一个虚拟的CPU环境，并且提供一些基本的服务，比如内存管理、错误检测等。你可以把它想象成一个工厂的骨架或者框架，提供了基础设施和一些常用的功能。</li><li><strong>其他工具</strong>：这些工具则类似于插件，它们利用内核提供的服务，完成各种特定的内存调试任务。比如Memcheck就是其中一个工具，它可以检测内存泄漏、数组越界等问题。你可以把这些工具想象成工厂的流水线，每个流水线都负责完成特定的任务。</li></ol><p><strong>Valgrind检测一个可执行程序是否存在内存泄漏的工作原理</strong></p><p>它的工作原理主要是通过插桩技术，也就是在程序运行时动态地插入一些检查代码来监视内存的使用情况。</p><p>当我们使用Valgrind运行一个程序时，Valgrind会首先加载自己的内核，然后把我们的程序加载到自己的虚拟内存空间中。在这个虚拟内存空间中，Valgrind可以完全控制程序的执行流程，并且可以检测到所有的内存访问。</p><p>Valgrind使用一种称为影子内存的技术来跟踪每个字节的内存状态，包括该字节是否已被分配、是否已被释放、是否已被初始化等。每当程序进行一次内存操作（如malloc、free、read、write等）时，Valgrind都会更新影子内存的状态，并检查这次操作是否合法。</p><p>如果Valgrind检测到一次非法的内存操作，比如访问了未被初始化的内存，或者访问了已经被释放的内存，它就会立即报告一个错误。当程序退出时，Valgrind会检查是否所有的内存都已经被正确释放，如果有任何内存泄漏，它也会报告一个错误。</p><blockquote><p><strong>valgrind工具</strong></p></blockquote><p>（1）Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</p><p>（2）Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</p><p>（3）Cachegrind。它主要用来检查程序中缓存使用出现的问题。</p><p>（4）Helgrind。它主要用来检查多线程程序中出现的竞争问题。</p><p>（5）Massif。它主要用来检查程序中堆栈使用中出现的问题。</p><p>（6）Extension。可以利用core提供的功能，自己编写特定的内存调试工具。</p><blockquote><p><strong>Memcheck检查的原理</strong></p></blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/510362477">Valgrind笔记（二）：MemCheck基本原理</a></li></ul><p>Memcheck检测内存问题的原理如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240514112408569.png" alt="image-20240514112408569"></p><p>Memcheck是Valgrind的一个组件，它用于检测C和C++程序中的内存管理问题。它通过在程序运行期间拦截所有内存访问和管理请求，来检测内存泄漏、使用未初始化的内存、访问已经释放的内存等问题。</p><p>Memcheck的工作原理主要依赖于两个全局表：</p><ol><li><strong>A-bit（Addressability bit）表</strong>：A-bit表用于标记哪些内存是可访问的。对于每个字节的内存，A-bit表都有一个对应的位。如果该位被设置，那么对应的内存字节就是可访问的。否则，该字节是不可访问的。当程序试图读写一个不可访问的内存字节时，Memcheck会报告一个错误。</li><li><strong>V-bit（Validity bit）表</strong>：V-bit表用于标记哪些内存是已初始化的。对于每个字节的内存，V-bit表都有一个对应的位。如果该位被设置，那么对应的内存字节就是已经被初始化的。否则，该字节是未初始化的。当程序试图读取一个未初始化的内存字节时，Memcheck会报告一个错误。</li></ol><h2 id="内存泄漏示例">内存泄漏示例</h2><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ sudo apt-get install valgrind</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2</span><br><span class="line">$ bzip2 -d valgrind-3.13.0.tar.bz2</span><br><span class="line">$ tar -xf valgrind-3.13.0.tar</span><br><span class="line">$ <span class="built_in">cd</span> valgrind-3.13.0</span><br><span class="line">$ ./configure &amp;&amp; make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>这里主要演示memcheck的示例。其他更多工具的示例请看：<a href="https://blog.csdn.net/weixin_45518728/article/details/119865117">valgrind基本功能介绍、基础使用方法说明</a></p><h3 id="未即时释放">未即时释放</h3><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *array = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序时，需要加上<code>-g</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o main_c main.cpp</span><br></pre></td></tr></table></figure><p>使用 Valgrind 检测内存使用情况：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --tool=memcheck --leak-check=full  ./main_c</span><br><span class="line">==<span class="number">31416</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">31416</span>== Copyright (C) <span class="number">2002</span>-<span class="number">2017</span>, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==<span class="number">3141</span>6== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==<span class="number">3141</span>6== Command: ./main_c</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== HEAP SUMMARY:</span><br><span class="line">==<span class="number">3141</span>6==     in use at exit: 4 bytes in 1 blocks</span><br><span class="line">==<span class="number">3141</span>6==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==<span class="number">3141</span>6==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==<span class="number">3141</span>6==    by 0x<span class="number">400537</span>: main (main.c:5)</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== LEAK SUMMARY:</span><br><span class="line">==<span class="number">3141</span>6==    definitely lost: 4 bytes in 1 blocks</span><br><span class="line">==<span class="number">3141</span>6==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==<span class="number">3141</span>6==</span><br><span class="line">==<span class="number">3141</span>6== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==<span class="number">3141</span>6== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>看看输出信息中的<code>HEAP SUMMARY</code>，它表示程序在堆上分配内存的情况，其中的<code>1 allocs</code>表示程序分配了 1 次内存，<code>0 frees</code>表示程序释放了 0 次内存，<code>4 bytes allocated</code>表示分配了 4 个字节的内存。<br>　另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是<code>main.c</code>文件的第 5 行。</p><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Valgrind 分析这段程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp</span><br><span class="line">==31438== Memcheck, a memory error detector</span><br><span class="line">==31438== Copyright (C) 2002-2017, and GNU GPL<span class="string">&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31438== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==31438==     in use at exit: 72,704 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1</span></span><br><span class="line"><span class="string">==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span></span><br><span class="line"><span class="string">==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)</span></span><br><span class="line"><span class="string">==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)</span></span><br><span class="line"><span class="string">==31438==    by 0x40105FA: call_init (dl-init.c:30)</span></span><br><span class="line"><span class="string">==31438==    by 0x40105FA: _dl_init (dl-init.c:120)</span></span><br><span class="line"><span class="string">==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== LEAK SUMMARY:</span></span><br><span class="line"><span class="string">==31438==    definitely lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==    indirectly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==      possibly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==    still reachable: 72,704 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31438==         suppressed: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== For counts of detected and suppressed errors, rerun with: -v</span></span><br><span class="line"><span class="string">==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span></span><br></pre></td></tr></table></figure><p>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从<code>HEAP SUMMARY</code>可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？</p><p>解释：</p><p>你的这段代码中，<code>new std::string(&quot;Hello, World!&quot;)</code> 这行代码实际上进行了两次内存分配：</p><ol><li>第一次分配是创建 <code>std::string</code> 对象本身，这会在堆上分配一块内存用来存储 <code>std::string</code> 对象的元数据，如长度、容量等。</li><li>第二次分配是在 <code>std::string</code> 对象初始化时，对字符串 “Hello, World!” 进行分配，存储实际的字符串内容。</li></ol><p>因此，你的程序实际上进行了两次内存分配。</p><p>然后在 <code>delete ptr;</code> 这行代码执行时，会调用 <code>std::string</code> 的析构函数，自动释放用于存储字符串内容的内存，然后再释放 <code>std::string</code> 对象本身的内存。所以虽然你只写了一次 <code>delete</code>，但实际上进行了两次内存释放。</p><p>然而，Valgrind 报告的 “frees” 数量可能只计算了你直接调用的 <code>delete</code> 操作，而没有计算 <code>std::string</code> 析构函数中自动进行的内存释放，因此它显示 “1 frees”。这也是为什么你的代码显示 “2 allocs, 1 frees”。</p><h3 id="检测越界访问">检测越界访问</h3><p>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">10</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">11</span> -g -o main_cpp main.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./main_cpp</span><br><span class="line">==<span class="number">31523</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">31523</span>== <span class="built_in">Copyright</span> (C) <span class="number">2002</span><span class="number">-2017</span>, <span class="keyword">and</span> GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31523== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31523==</span></span><br><span class="line"><span class="string">==31523== Invalid read of size 4</span></span><br><span class="line"><span class="string">==31523==    at 0x400AD7: main (main.cpp:7)</span></span><br><span class="line"><span class="string">==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc&#x27;</span>d</span><br><span class="line">==<span class="number">31523</span>==    at <span class="number">0x4C2E216</span>: <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="type">unsigned</span> <span class="type">long</span>) (vg_replace_malloc.c:<span class="number">334</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x4010D3</span>: __gnu_cxx::new_allocator&lt;<span class="type">int</span>&gt;::<span class="built_in">allocate</span>(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">void</span> <span class="type">const</span>*) (new_allocator.h:<span class="number">104</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x401040</span>: std::allocator_traits&lt;std::allocator&lt;<span class="type">int</span>&gt; &gt;::<span class="built_in">allocate</span>(std::allocator&lt;<span class="type">int</span>&gt;&amp;, <span class="type">unsigned</span> <span class="type">long</span>) (alloc_traits.h:<span class="number">491</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400F91</span>: std::_Vector_base&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::_M_allocate(<span class="type">unsigned</span> <span class="type">long</span>) (stl_vector.h:<span class="number">170</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400E7E</span>: std::_Vector_base&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::_M_create_storage(<span class="type">unsigned</span> <span class="type">long</span>) (stl_vector.h:<span class="number">185</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400D1E</span>: std::_Vector_base&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::_Vector_base(<span class="type">unsigned</span> <span class="type">long</span>, std::allocator&lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp;) (stl_vector.h:<span class="number">136</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400C11</span>: std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;::<span class="built_in">vector</span>(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">int</span> <span class="type">const</span>&amp;, std::allocator&lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp;) (stl_vector.h:<span class="number">291</span>)</span><br><span class="line">==<span class="number">31523</span>==    by <span class="number">0x400AB9</span>: <span class="built_in">main</span> (main.cpp:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><code>Invalid read of size 4</code>表示越界读取 4 个字节，这个操作出现在<code>main.cpp</code>文件的第 7 行。另外可以看到，<code>vector</code>分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><h3 id="检测未初始化的内存">检测未初始化的内存</h3><p>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;X is zero&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Valgrind 检测这个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">11</span> -g -o main_cpp main.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./main_cpp</span><br><span class="line">==<span class="number">31554</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">31554</span>== <span class="built_in">Copyright</span> (C) <span class="number">2002</span><span class="number">-2017</span>, <span class="keyword">and</span> GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31554== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31554==</span></span><br><span class="line"><span class="string">==31554== Conditional jump or move depends on uninitialised value(s)</span></span><br><span class="line"><span class="string">==31554==    at 0x400852: main (main.cpp:6)</span></span><br></pre></td></tr></table></figure><p>输出中提示了<code>main.cpp</code>文件的第 6 行访问了未初始化的内存。</p><p>即学即用一波【<a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="comment">// 3[a2[c]]</span></span><br><span class="line"><span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">deque&lt;string&gt; str;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">string ans=<span class="string">&quot;&quot;</span>,cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">num=num*<span class="number">10</span>+(<span class="type">int</span>)(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">q.<span class="built_in">push_back</span>(num);</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cur.<span class="built_in">size</span>()&gt;<span class="number">0</span>) str.<span class="built_in">push_back</span>(cur);</span><br><span class="line">cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur.<span class="built_in">size</span>())</span><br><span class="line">str.<span class="built_in">push_back</span>(cur); </span><br><span class="line">string str_tmp=str.<span class="built_in">back</span>();str.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="type">int</span> num_tmp=q.<span class="built_in">back</span>();q.<span class="built_in">pop_back</span>();</span><br><span class="line">string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num_tmp;j++)&#123;</span><br><span class="line">res=res+str_tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">string tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">tmp=str.<span class="built_in">back</span>();</span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br><span class="line">str.<span class="built_in">push_back</span>(tmp+res);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ans=ans+res;</span><br><span class="line">&#125;</span><br><span class="line">cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">cur=cur+s[i];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ans=ans+s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;3[z]2[2[y]pq4[2[jk]e1[f]]]ef&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用内存检测工具检测</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ vim main.<span class="built_in">cpp</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -o main_c main.<span class="built_in">cpp</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ valgrind --tool=memcheck --leak-check=full  ./main_c</span><br><span class="line">==<span class="number">1335995</span>== Memcheck, a memory error detector</span><br><span class="line">==<span class="number">1335995</span>== <span class="built_in">Copyright</span> (C) <span class="number">2002</span><span class="number">-2017</span>, <span class="keyword">and</span> GNU GP<span class="string">L&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==1335995== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==1335995== Command: ./main_c</span></span><br><span class="line"><span class="string">==1335995==</span></span><br><span class="line"><span class="string">3[z]2[2[y]pq4[2[jk]e1[f]]]ef</span></span><br><span class="line"><span class="string">==1335995== Use of uninitialised value of size 8</span></span><br><span class="line"><span class="string">==1335995==    at 0x49ACC38: std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28)</span></span><br><span class="line"><span class="string">==1335995==    by 0x10A87C: main (main.cpp:32)</span></span><br><span class="line"><span class="string">==1335995==</span></span><br><span class="line"><span class="string">==1335995== Invalid read of size 8</span></span><br><span class="line"><span class="string">==1335995==    at 0x49ACC38: std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28)</span></span><br><span class="line"><span class="string">==1335995==    by 0x10A87C: main (main.cpp:32)</span></span><br><span class="line"><span class="string">==1335995==  Address 0x1e8 is not stack&#x27;</span>d, malloc<span class="number">&#x27;</span>d <span class="built_in">or</span> (recently) free<span class="number">&#x27;</span>d</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== Process terminating with <span class="keyword">default</span> action of signal <span class="number">11</span> (SIGSEGV): dumping core</span><br><span class="line">==<span class="number">1335995</span>==  Access <span class="keyword">not</span> within mapped region at address <span class="number">0x1E8</span></span><br><span class="line">==<span class="number">1335995</span>==    at <span class="number">0x49ACC38</span>: std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt;::<span class="built_in">basic_string</span>(std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt; <span class="type">const</span>&amp;) (in /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.28</span>)</span><br><span class="line">==<span class="number">1335995</span>==    by <span class="number">0x10A87C</span>: <span class="built_in">main</span> (main.cpp:<span class="number">32</span>)</span><br><span class="line">==<span class="number">1335995</span>==  If you believe <span class="keyword">this</span> happened as a result of a stack</span><br><span class="line">==<span class="number">1335995</span>==  overflow in your program<span class="number">&#x27;</span>s main <span class="built_in">thread</span> (unlikely but</span><br><span class="line">==<span class="number">1335995</span>==  possible), you can <span class="keyword">try</span> to increase the size of the</span><br><span class="line">==<span class="number">1335995</span>==  main thread stack <span class="keyword">using</span> the --main-stacksize= flag.</span><br><span class="line">==<span class="number">1335995</span>==  The main thread stack size used in <span class="keyword">this</span> run was <span class="number">8388608.</span></span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== HEAP SUMMARY:</span><br><span class="line">==<span class="number">1335995</span>==     in use at exit: <span class="number">1</span>,<span class="number">183</span> bytes in <span class="number">5</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==   total heap usage: <span class="number">7</span> allocs, <span class="number">2</span> frees, <span class="number">74</span>,<span class="number">911</span> bytes allocated</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== LEAK SUMMARY:</span><br><span class="line">==<span class="number">1335995</span>==    definitely lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==    indirectly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==      possibly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==    still reachable: <span class="number">1</span>,<span class="number">183</span> bytes in <span class="number">5</span> blocks</span><br><span class="line">==<span class="number">1335995</span>==         suppressed: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">1335995</span>== Reachable <span class="built_in">blocks</span> (those to which a pointer was found) are <span class="keyword">not</span> shown.</span><br><span class="line">==<span class="number">1335995</span>== To see them, rerun with: --leak-check=full --show-leak-kinds=all</span><br><span class="line">==<span class="number">1335995</span>==</span><br><span class="line">==<span class="number">1335995</span>== Use --track-origins=yes to see where uninitialised values come from</span><br><span class="line">==<span class="number">1335995</span>== For lists of detected <span class="keyword">and</span> suppressed errors, rerun with: -s</span><br><span class="line">==<span class="number">1335995</span>== ERROR SUMMARY: <span class="number">2</span> errors from <span class="number">2</span> <span class="built_in">contexts</span> (suppressed: <span class="number">0</span> from <span class="number">0</span>)</span><br><span class="line">段错误</span><br></pre></td></tr></table></figure><p>一下就知道，问题在这</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>str.back()<span class="comment">;</span></span><br><span class="line">str.pop_back()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="asan和valgrind的区别">asan和valgrind的区别</h2><ol><li>实现方式：<ol><li>ASan：ASan是一种静态和动态混合的工具，它通过在编译时插入额外的代码来检测内存错误。ASan会在程序运行时检测内存访问错误，如缓冲区溢出、使用已释放的内存等。</li><li>Valgrind：Valgrind是一个动态二进制工具，它通过在程序运行时对二进制代码进行重写和模拟来检测内存错误。Valgrind提供了一种更广泛的工具集，包括Memcheck（用于内存错误检测）、Cachegrind（用于缓存分析）、Callgrind（用于函数调用跟踪）等。</li></ol></li><li>性能开销：<ol><li>ASan：ASan通常比Valgrind更快，因为它在编译时引入了一些运行时检查，但这些检查开销相对较小。它对程序性能的影响通常较小。</li><li>Valgrind：Valgrind在运行时对程序进行重写和模拟，因此通常比ASan更慢。在某些情况下，Valgrind的性能开销可能会很高，特别是对于大型应用程序。</li></ol></li><li>检测能力：<ol><li>ASan：ASan主要用于检测内存访问错误，如缓冲区溢出、内存泄漏等。它在这些方面非常强大。</li><li>Valgrind：Valgrind的Memcheck工具不仅可以检测内存访问错误，还可以检测未初始化的内存访问、内存泄漏、不匹配的内存分配/释放等多种问题。因此，Valgrind在某些情况下可能提供更全面的错误检测。</li></ol></li></ol><p>参考资料</p><ul><li><a href="https://www.it.uc3m.es/pbasanta/asng/course_notes/memory_profiler_en.html#memcheck_tool">Chapter 17. The memory profiler Valgrind</a></li><li><a href="https://senlinzhan.github.io/2017/12/31/valgrind/">使用 Valgrind 检测 C++ 内存泄漏</a></li><li><a href="https://zhuanlan.zhihu.com/p/643271982">【C/C++ 集成内存调试、内存泄漏检测和性能分析的工具 Valgrind 】Linux 下 Valgrind 工具的全面使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/56538645">内存检测王者之剑—valgrind</a></li></ul>]]></content>
    
    
    <summary type="html">内存检测-Valgrind</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp面经</title>
    <link href="https://penge666.github.io/posts/680a3d55.html"/>
    <id>https://penge666.github.io/posts/680a3d55.html</id>
    <published>2024-05-13T12:35:09.000Z</published>
    <updated>2024-05-14T02:18:32.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-98"><a href="#C-98" class="headerlink" title="C++98"></a>C++98</h2><h3 id="1-在main执行的前后需要处理什么工作？"><a href="#1-在main执行的前后需要处理什么工作？" class="headerlink" title="1. 在main执行的前后需要处理什么工作？"></a>1. 在main执行的前后需要处理什么工作？</h3><p><strong>Main函数之前</strong></p><p>(1) 设置栈指针</p><p>(2) 全局对象初始化，在main之前调用构造函数</p><p>(3) 将main函数的参数argc，argv等传递给main函数</p><p><strong>Main函数之后</strong></p><p>全局对象的析构函数</p><h3 id="2-什么是内存对齐？"><a href="#2-什么是内存对齐？" class="headerlink" title="2.什么是内存对齐？"></a>2.什么是内存对齐？</h3><p>学习自：<a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解</a></p><p>还是得看例子：【从例子解释概念】</p><p>还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(s);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。</p><p>精简：</p><p>(1) 在计算机中，内存是按字节划分的，而CPU在读取数据时，并不是一个字节一个字节的读取，实际上是<strong>按块的大小读取</strong>，块大小可以是2，4，8，16等等，称为内存访问粒度。</p><p>(2) 内存对齐则是将特定的数据类型按照一定的规则摆放在内存上，具体规则是按照变量的声明顺序，依次安排内存，其偏移量为变量大小的整数倍。</p><h3 id="3-为什么要做内存对齐？"><a href="#3-为什么要做内存对齐？" class="headerlink" title="3. 为什么要做内存对齐？"></a>3. 为什么要做内存对齐？</h3><p>这个的话展开说就是：</p><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204345153.png" alt="image-20240513204345153"></p><p>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204405396.png" alt="image-20240513204405396"></p><p>精简：</p><p>(1) <strong>平台原因(移植原因)：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p><p>(2) <strong>性能原因：</strong>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p><h3 id="4-说说内存对齐规则？"><a href="#4-说说内存对齐规则？" class="headerlink" title="4. 说说内存对齐规则？"></a>4. 说说内存对齐规则？</h3><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(3) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p>下面给出几个例子以便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2; </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上测试都是在Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节，下面根据上面所说的规则以s2来分析其内存布局：</p><p>首先使用规则1，对成员变量进行对齐：</p><p>sizeof(c1) = 1 &lt;= 4(有效对齐位)，按照1字节对齐，占用第0单元；</p><p>sizeof(i) = 4 &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为4的倍数，占用第4，5，6，7单元；</p><p>sizeof(c2) = 1 &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元；</p><p>然后使用规则2，对结构体整体进行对齐：</p><p>s2中变量i占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到s2占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。</p><p>根据上面的分析，不难得出上面例子三个结构体的内存布局如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204725927.png" alt="image-20240513204725927"></p><p><strong>#pragma pack(n)</strong></p><p>不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数。</p><p>例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204744215.png" alt="image-20240513204744215"></p><p>如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513204752271.png" alt="image-20240513204752271"></p><p>经过上面的实例分析，大家应该对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。</p><p>精简：</p><p>(1) 每个特定平台上的编译器都有自己的默认<strong>“对齐系数”（也叫对齐模数）</strong>。32位系统，gcc中默认#pragma pack(4)，即对齐系数默认为4。可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>(2) 有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中<strong>较小</strong>的那个。<strong>有效对齐值也叫对齐单位</strong>。</p><p>(3) 结构体第一个成员的偏移量为0，以后每个成员相对于结构体首地址的偏移量都是该成员大小与有效对齐值中<strong>较小</strong>数的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(4) 结构体的总大小为<strong>有效对齐值的整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><h3 id="5-指针和引用的区别？"><a href="#5-指针和引用的区别？" class="headerlink" title="5. 指针和引用的区别？"></a>5. 指针和引用的区别？</h3><p>(1) 指针是一个变量，存储的是一个地址。引用跟原来的变量实质上是同一个东西，是原变量的别名</p><p>(2) 指针可以有多级，引用只有一级</p><p>(3) 指针可以为空，引用不能为NULL且在定义时必须初始化</p><p>(4) 指针在初始化后可以改变指向，而引用在初始化之后不可再改变</p><p>(5) sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</p><ul><li><a href="https://zhuanlan.zhihu.com/p/140966943">C++中指针与引用的区别</a></li></ul><h3 id="6-堆和栈的区别？"><a href="#6-堆和栈的区别？" class="headerlink" title="6. 堆和栈的区别？"></a>6. 堆和栈的区别？</h3><p>(1) 栈由系统自动分配，堆是自己申请和释放的。</p><p>(2) 堆向上，向高地址方向增长。栈向下，向低地址方向增长。</p><p>(3) 在空间连续性上，栈区的空间是连续的；但堆的空间是不连续的。</p><p>(4) 堆只能动态分配。栈有静态分配和动态分配，静态分配由编译器完成，动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</p><p>(5) 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p><p>(6) 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p><h3 id="7-new-delete-与-malloc-free的异同？"><a href="#7-new-delete-与-malloc-free的异同？" class="headerlink" title="7. new / delete 与 malloc / free的异同？"></a>7. new / delete 与 malloc / free的异同？</h3><p>(1) 都可用于内存的动态申请和释放</p><p>(2) 前者是C++运算符，后者是C/C++语言标准库函数</p><p>(3) new自动计算要分配的空间大小，malloc需要手工计算</p><p>(4) new是类型安全的，malloc不是。</p><p>(5) new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始类型的内存，接下来在该内存上调用构造函数初始化对象；最后返回该内存指针。</p><p>(6) delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存</p><p>(7) malloc/free可重载，new/delete不可重载，operator new/operator delete可重载</p><h3 id="8-被free回收的内存是立即返还给操作系统吗？"><a href="#8-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="8. 被free回收的内存是立即返还给操作系统吗？"></a>8. 被free回收的内存是立即返还给操作系统吗？</h3><p>不会，new或者malloc申请内存是向内存管理器申请，内存管理器再向操作系统申请，这里面涉及到系统调用，如果频繁的申请释放，效率会很低，所以一般进程申请了内存后，释放资源后并不会立即将内存还给操作系统，而是放到一个类似于内存缓存池的地方，下次申请的时候首先会在内存缓存池中查找合适的内存，减少了大量的系统调用，提高速度。</p><h3 id="9-宏函数和普通函数有何区别？"><a href="#9-宏函数和普通函数有何区别？" class="headerlink" title="9. 宏函数和普通函数有何区别？"></a>9. 宏函数和普通函数有何区别？</h3><p>(1) 宏函数作用在预编译期，进行文本替换，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；普通函数调用在运行时需要跳转到具体调用函数。</p><p>(2) 宏函数属于在结构中插入代码，没有返回值；普通函数调用具有返回值。</p><p>(3) 宏函数参数没有类型，不进行类型检查；普通函数参数具有类型，需要检查类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义，没有类型检查</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，有类型检查</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.5</span>;</span><br><span class="line">    <span class="comment">// 使用宏，虽然y的类型不是整数，但仍然可以计算</span></span><br><span class="line">    <span class="type">double</span> r1 = <span class="built_in">SQUARE</span>(y);  <span class="comment">// 结果是2.25</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数，如果尝试将y作为参数，编译器会报错，因为y的类型与函数期望的类型不匹配</span></span><br><span class="line">    <span class="type">int</span> r2 = <span class="built_in">square</span>(y);  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>SQUARE(x)</code>是一个宏，它接受任何类型的参数<code>x</code>，并返回<code>x</code>的平方。因为宏没有类型检查，所以你可以传递任何类型的参数给宏，编译器不会报错。</p><p>但是，<code>square(x)</code>是一个函数，它期望一个整数类型的参数<code>x</code>。如果你尝试将一个非整数类型的值（如<code>double</code>类型的值）传递给这个函数，编译器会报错，因为函数参数的类型检查失败。</p><h3 id="10-宏定义和typedef有何区别？"><a href="#10-宏定义和typedef有何区别？" class="headerlink" title="10. 宏定义和typedef有何区别？"></a>10. 宏定义和typedef有何区别？</h3><p>(1) 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p><p>(2) 宏替换发生在预编译期，属于文本插入替换；typedef是编译的一部分。</p><p>(3) 宏不检查类型；typedef会检查数据类型。</p><h3 id="11-宏定义和const的区别？"><a href="#11-宏定义和const的区别？" class="headerlink" title="11. 宏定义和const的区别？"></a>11. 宏定义和const的区别？</h3><p>(1) 宏定义发生在预编译期。const是在编译、运行的时候起作用</p><p>(2) 宏定义只做替换，不做类型检查和计算。const常量有数据类型，编译器做类型检查。</p><p>(3) define只是将宏名称进行文本替换，占用代码段内存。const在程序运行中只有一份备份，占用数据段内存。</p><h3 id="12-内联函数和宏函数的区别？"><a href="#12-内联函数和宏函数的区别？" class="headerlink" title="12. 内联函数和宏函数的区别？"></a>12. 内联函数和宏函数的区别？</h3><p>(1) 宏函数在预处理阶段进行文本替换，inline函数在编译阶段进行替换</p><p>(2) inline函数有类型检查，相比宏函数比较安全</p><p>(3) Inline函数具有返回值，宏函数没有</p><h3 id="13-变量声明和定义的区别？"><a href="#13-变量声明和定义的区别？" class="headerlink" title="13. 变量声明和定义的区别？"></a>13. 变量声明和定义的区别？</h3><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间。只有在定义处才为其分配存储空间。<strong>相同变量可以在多处声明，但只能在一处定义</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>isOK!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-strlen和sizeof的区别？"><a href="#14-strlen和sizeof的区别？" class="headerlink" title="14. strlen和sizeof的区别？"></a>14. strlen和sizeof的区别？</h3><p>(1) sizeof是C/C++操作符，并不是函数，结果在编译时得到。strlen是字符处理的库函数。</p><p>(2) sizeof参数可以是任何数据的类型或者数据。strlen的参数只能是字符指针，它指向了一个结尾是’\0’的字符串。</p><h3 id="15-常量指针和指针常量的区别？"><a href="#15-常量指针和指针常量的区别？" class="headerlink" title="15. 常量指针和指针常量的区别？"></a>15. 常量指针和指针常量的区别？</h3><p>(1) 指针常量（底层const）是一个指针，它指向了一个只读值。它实际上只是限制了指针的拥有者不能通过指针修改它所指向的值，对这个值的属性没有限制，这个值是可以是常量也可以变量，均不影响。</p><p>(2) 常量指针（顶层const）是一个不能给改变指向的指针，即我们可以通过指针修改它所指向的值，但不能修改指针的指向。</p><p>详细说明：</p><p><strong>指针常量</strong></p><p>指针常量：顾名思义它就是一个常量，但是是指针修饰的。</p><p>格式为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> p <span class="comment">//指针常量</span></span><br><span class="line">在这个例子下定义以下代码：</span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a，b；</span><br><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</span></span><br></pre></td></tr></table></figure><p><strong>常量指针</strong></p><p>常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> *p = &amp;a; <span class="comment">//常量指针</span></span><br><span class="line">在这个例子下定义以下代码：</span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a，b；</span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><h3 id="16-指针常量能不能赋值给非指针常量？"><a href="#16-指针常量能不能赋值给非指针常量？" class="headerlink" title="16. 指针常量能不能赋值给非指针常量？"></a>16. 指针常量能不能赋值给非指针常量？</h3><p>不能，指针常量限制了指针的拥有者不能通过指针修改它所指向的值，如果指针常量可以赋值给非指针常量，那就意味着拥有者可以使用这种方法获取写权限，这在语义上是冲突的。</p><h3 id="17-C-和Python的区别？"><a href="#17-C-和Python的区别？" class="headerlink" title="17. C++和Python的区别？"></a>17. C++和Python的区别？</h3><p>(1) Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。</p><p>(2) python可以很方便的跨平台，但是效率没有C++高。</p><p>(3) C++中需要事先定义变量的类型，而Python不需要</p><p>(4) Python的库函数比C++的多，调用起来很方便</p><h3 id="18-C-中struct和class的区别？"><a href="#18-C-中struct和class的区别？" class="headerlink" title="18. C++中struct和class的区别？"></a>18. C++中struct和class的区别？</h3><p>(1) 两者都拥有成员函数、公有和私有部分</p><p>(2) 任何可以使用class完成的工作，同样可以使用struct完成</p><p>(3) 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p><p>(4) class默认是private继承，而struct模式是public继承</p><h3 id="19-C-和C的struct的区别？"><a href="#19-C-和C的struct的区别？" class="headerlink" title="19. C++和C的struct的区别？"></a>19. C++和C的struct的区别？</h3><p>C语言：struct是用户自定义数据类型（UDT），不能设置权限，成员不可以是函数，不能被继承。</p><p>C++：struct是抽象数据类型（ADT）支持成员函数的定义，能设置权限，能被继承与实现多态。</p><h3 id="20-C-中const和static的作用？"><a href="#20-C-中const和static的作用？" class="headerlink" title="20. C++中const和static的作用？"></a>20. C++中const和static的作用？</h3><p><strong>(1) Static（类外）：</strong></p><p>①　隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他模块中使用，加了之后只能在该文件所在的编译模块中使用</p><p>②　静态变量没有定义初始值时，会初始化为0。</p><p>③　静态变量在函数内定义，生命周期跟随程序（同全局变量），且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</p><p><strong>(2) Static（类内）：</strong></p><p>①　static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化， 必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</p><p>②　static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问</p><p><strong>(3) Const（类外）：</strong></p><p>①　const常量在定义时必须初始化，之后无法更改</p><p>②　const形参可以接收const和非const类型的实参</p><p><strong>(4) Const（类内）：</strong></p><p>①　const成员变量：只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</p><p>②　const成员函数：const类对象不可以调用类中的非const成员函数；非const类对象则均可调用；const成员函数不可以改变类中非mutable数据成员的值。</p><p>举例说明</p><p>在C++中，<code>const</code>和<code>static</code>都是修饰符，它们可以用来修改变量、函数或对象的行为。</p><ul><li><code>const</code>: <code>const</code>关键字可以用来修饰变量，表示这个变量的值是常量，不能被修改。在类中，如果一个成员函数被声明为<code>const</code>，那么这个函数不能修改类的任何成员变量（除非这个变量是<code>mutable</code>的）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x = a;  // Error, can&#x27;t modify x in a const function</span></span><br><span class="line">        y = a;  <span class="comment">// OK, y is mutable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>static</code>: <code>static</code>关键字在类中有两种用法。一种是修饰成员变量，这样这个变量就变成了一个静态成员变量，它不属于类的任何对象，而是属于类本身，所有的对象都共享这一个变量。另一种是修饰成员函数，这样这个函数就变成了一个静态成员函数，它可以在不创建对象的情况下被调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::x = <span class="number">0</span>;  <span class="comment">// Define static member variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">setX</span>(<span class="number">10</span>);  <span class="comment">// Call static member function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类外部来看，<code>const</code>和<code>static</code>修饰的成员变量或函数可以通过类名直接访问（对于<code>static</code>），或者通过对象访问但不能修改（对于<code>const</code>）。</p><h3 id="21-数组名和指针（这里为指向数组首元素的指针）的区别？"><a href="#21-数组名和指针（这里为指向数组首元素的指针）的区别？" class="headerlink" title="21.数组名和指针（这里为指向数组首元素的指针）的区别？"></a>21.数组名和指针（这里为指向数组首元素的指针）的区别？</h3><p>(1) 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</p><p>(2) 二者均可通过增减偏移量来访问数组中的元素。</p><p>(3) 数组名不是真正意义上的指针，实际上是一个常量指针，所以不能进行自增自减操作。</p><p>(4) 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作， 但sizeof运算符不能再得到原数组的大小了。</p><h3 id="22-C代码使用C语言编译和C-编译有什么不同？"><a href="#22-C代码使用C语言编译和C-编译有什么不同？" class="headerlink" title="22. C代码使用C语言编译和C++编译有什么不同？"></a>22. C代码使用C语言编译和C++编译有什么不同？</h3><p>(1) C++虽然语法上支持和兼容C语言，但为了支持多种特性，在编译上却做了很多C语言所没有的其他处理。</p><p>(2) 比如说现在有一个C语言函数库，而我们用C++去调用该函数库，在编译链接时链接器会报错。因为<strong>C++为了支持函数重载，会在编译时给每个函数进行“改名”</strong>，但是C语言在编译时则不会改名，C函数库中的函数名都保持原样，这就会使链接器在函数库中找不到改名后的对应函数地址，然后报错。<strong>extern “C”可以很好地解决这个问题</strong>。</p><p>(3) 因为C++的函数改名规则，<strong>C++代码在使用其他模块的函数前必须包含其头文件或显式声明函数</strong>，不然它无法识别该函数是C函数还是C++函数，是否需要进行改名。<strong>C语言编译器即使不提前声明函数也可以调用函数，因为C编译器没有改名规则</strong>。</p><h3 id="23-extern”C”的用法？"><a href="#23-extern”C”的用法？" class="headerlink" title="23. extern”C”的用法？"></a>23. extern”C”的用法？</h3><p>在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++，在以下情况时会用到该语法：</p><p>(1) <strong>C++代码中调用C语言函数库</strong>；</p><p>(2) <strong>在多个人协同开发时，可能有人擅长C语言，而有人擅长C++</strong></p><h3 id="24-说说野指针和悬空指针？"><a href="#24-说说野指针和悬空指针？" class="headerlink" title="24. 说说野指针和悬空指针？"></a>24. 说说野指针和悬空指针？</h3><p>(1) <strong>野指针：</strong>指的是没有被初始化过的指针。解决方法：定义指针变量要及时初始化或者置空。（保持良好的编码规范）</p><p>(2) <strong>悬空指针：</strong>指针最初指向的内存已经被释放了的一种指针。解决方法：释放操作后立即置空，或者使用智能指针</p><p>野指针和空悬指针的区别是野指针是指向未知地址的指针，而空悬指针是指向已经被释放的地址的指针</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *p;</span><br><span class="line">// 此时 p 是“野指针”</span><br></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *p <span class="operator">=</span> malloc(size)<span class="comment">;</span></span><br><span class="line">assert(p)<span class="comment">;</span></span><br><span class="line">free(p)<span class="comment">; </span></span><br><span class="line">// 现在 p 是“悬空指针”</span><br><span class="line">// 避免“悬空指针”</span><br><span class="line"><span class="attribute">p</span> <span class="operator">=</span> NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="25-C-中的重载、重写（覆盖）和隐藏的区别？"><a href="#25-C-中的重载、重写（覆盖）和隐藏的区别？" class="headerlink" title="25. C++中的重载、重写（覆盖）和隐藏的区别？"></a>25. C++中的重载、重写（覆盖）和隐藏的区别？</h3><p>(1) 重载是指在<strong>同一范围定义中的同名函数</strong>才存在重载关系。主要特点是<strong>函数名相同，参数类型和数目有所不同</strong>，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</p><p>(2) 重写指的是在派生类中重写父类的函数体，<strong>要求基类函数必须是虚函数</strong>，且重写的函数签名<strong>（返回值、函数名、参数列表）</strong>必须完全一致。</p><p>(3) 隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数。</p><p>(4) <strong>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</strong></p><p>(5) <strong>隐藏和重写的区别在于基类函数是否是虚函数</strong>。</p><h3 id="26-浅拷贝和深拷贝的区别？"><a href="#26-浅拷贝和深拷贝的区别？" class="headerlink" title="26. 浅拷贝和深拷贝的区别？"></a>26. 浅拷贝和深拷贝的区别？</h3><p>(1) 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。如果原来的指针所指向的资源释放了，那么使用新指针就会出现错误。</p><p>(2) 深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><h3 id="27-public，protected和private权限的区别？"><a href="#27-public，protected和private权限的区别？" class="headerlink" title="27. public，protected和private权限的区别？"></a>27. public，protected和private权限的区别？</h3><p><strong>(1) 访问权限：</strong></p><p>①　public的变量和函数在类的内部外部都可以访问。</p><p>②　protected的变量和函数只能在类的内部和其派生类中访问。</p><p>③　private修饰的元素只能在类内访问。</p><p><strong>(2) 继承权限：</strong></p><p>①　Public:基类的公有成员和保护成员作为派生类的成员时，都保持原有的访问权限，基类的私有成员任然是私有的</p><p>②　Protected：基类的公有成员和保护成员都成为派生类的保护成员，基类的私有成员仍然是私有的</p><p>③　private：基类的公有成员和保护成员都成为派生类的私有成员，基类的私有成员任然是私有的</p><p><strong>对于继承权限而言，它所针对的是类外的访问权限。对于类内来说，不管是何种继承，派生类均可访问基类的公用和保护成员，但不可访问基类的私有成员。</strong></p><h3 id="28-如何用代码判断大小端存储？"><a href="#28-如何用代码判断大小端存储？" class="headerlink" title="28. 如何用代码判断大小端存储？"></a>28. 如何用代码判断大小端存储？</h3><p>(1) <strong>大端存储：</strong>字数据的高字节存储在低地址中</p><p>(2) <strong>小端存储：</strong>字数据的高字节存储在高地址中</p><p>(3) <strong>方式一：使用强制类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0x1234</span>;</span><br><span class="line"><span class="type">char</span> c=(<span class="type">char</span>)(a);</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">0x12</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;big&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;small&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) <strong>方式二：使用union联合体</strong></p><ul><li><a href="https://blog.csdn.net/sxg226273531/article/details/135996096">如何使用联合体判断大小端，详细介绍其内存原理（附完整代码）</a></li></ul><h3 id="29-volatile、mutable和explicit关键字的用法？"><a href="#29-volatile、mutable和explicit关键字的用法？" class="headerlink" title="29. volatile、mutable和explicit关键字的用法？"></a>29. volatile、mutable和explicit关键字的用法？</h3><p>(1) volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示它可能被某些编译器未知的因素更改</strong>，所以系统总是重新从它所在的内存读取数据而不会去使用内存读取优化（使用寄存器），即使它前面的指令刚刚从该处读取过数据。</p><p>【防止编译的时候被优化！每次都得从内存中读取！】</p><p>(2) mutable关键字是一种类型修饰符，<strong>被mutable修饰的数据成员表示他可以被const成员函数所修改（const成员函数无法修改类中的普通数据成员）</strong>，它的修改不会影响整个类对象的状态。</p><p>(3) <strong>explicit关键字用来修饰类的构造函数，</strong>加上该关键字，表示该类不能发生相应的隐式类型转换（函数调用传参时的类型转换），只能以显式地进行类型转换（调用构造函数） 。</p><h3 id="30-C-中有几种类型的new？"><a href="#30-C-中有几种类型的new？" class="headerlink" title="30. C++中有几种类型的new？"></a>30. C++中有几种类型的new？</h3><p>【未看】</p><p>在C++中，new有三种典型的使用方法：<strong>plain new，nothrow new和placement new</strong></p><p>(1) <strong>plain new</strong>：最普通的new，它在分配内存失败时会抛出std::bad_alloc异常而不是返回NULL</p><p>(2) <strong>nothrow new</strong> ：不会抛出异常的new，分配内存失败时返回NULL</p><p>(3) <strong>placement new</strong>：不分配内存，只在一块分配好了的内存上调用类的构造函数</p><h3 id="31-形参与实参的区别？"><a href="#31-形参与实参的区别？" class="headerlink" title="31. 形参与实参的区别？"></a>31. 形参与实参的区别？</h3><p>(1) <strong>形参在定义时不分配内存，只有在被调用时才分配内存</strong></p><p>(2) 实参可以任意形式的表达式，但在进行函数调用时，它们都必须具有确定的值</p><p>(3) 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生<strong>“类型不匹配”</strong>的错误</p><p>(4) <strong>函数调用中发生的数据传送是单向的。</strong> 即只能把实参的值传送给形参。</p><h3 id="32-值传递、指针传递、引用传递的区别和效率？"><a href="#32-值传递、指针传递、引用传递的区别和效率？" class="headerlink" title="32. 值传递、指针传递、引用传递的区别和效率？"></a>32. 值传递、指针传递、引用传递的区别和效率？</h3><p>(1) 值传递：实参的值向形参进行值拷贝，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。</p><p>(2) 指针传递：同样有实参的值向形参进行值拷贝，但拷贝的数据是一个固定大小的地址。</p><p>(3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。</p><p>(4) <strong>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰</strong>。</p><h3 id="33-C-有哪几种的构造函数？"><a href="#33-C-有哪几种的构造函数？" class="headerlink" title="33. C++有哪几种的构造函数？"></a>33. C++有哪几种的构造函数？</h3><p>(1) 默认构造函数（无参数）</p><p>(2) 初始化构造函数（有参数）</p><p>(3) 拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-什么情况下会调用拷贝构造函数？"><a href="#34-什么情况下会调用拷贝构造函数？" class="headerlink" title="34. 什么情况下会调用拷贝构造函数？"></a>34. 什么情况下会调用拷贝构造函数？</h3><p>(1) 用类的一个实例对象去初始化构造一个类的新对象的时候</p><p>(2) 函数的参数是类的对象时（值传递）</p><p>(3) 函数的返回值是函数体内局部对象的类的对象时</p><h3 id="35-说说C-中的初始化？"><a href="#35-说说C-中的初始化？" class="headerlink" title="35. 说说C++中的初始化？"></a>35. 说说C++中的初始化？</h3><p>C++中变量的初始化有很多种方式，如：默认初始化，值初始化，直接初始化，拷贝初始化。下面一一介绍。</p><p>(1) <strong>默认初始化</strong></p><p>①　默认初始化是指定义变量时 没有指定初值时进行的初始化操作。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>②　对于内置类型变量（如int，double，bool等），<strong>如果是全局变量或静态变量，则初始化为0，如果是栈或者堆变量，则将拥有未定义的值</strong>。</p><p>③　对于类类型的变量（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发错误。因此，建议为每个类都定义一个默认构造函数（=default）。</p><p>④　注意：默认初始化的值并不是绝对的，在一些情况下会产生未知的错误，<strong>一般定义变量时最好都要为它设定初始值，这是一种良好的编程习惯。</strong></p><p>(2) <strong>值初始化</strong></p><p>①　值初始化是指使用了初始化器（即使用了圆括号或花括号）但却没有提供初始值的情况。</p><p>②　特别的，采用动态分配内存的方式（即采用new关键字）创建的变量，不加括号时，如int <em>p=new int，是默认初始化，加了括号，如int </em>p=new int()，为值初始化。</p><p>③　若不采用动态分配内存的方式（即不采用new运算符），写成int a();是错误的值初始化方式，因为这种方式是声明了一个函数而不是进行值初始化。如果一定要进行值初始化，必须结合拷贝初始化使用，即写成int a=int()。</p><p>④　值初始化和默认初始化一样，对于内置类型初始化为0，对于类类型则调用其默认构造函数，如果没有默认构造函数，则不能进行初始化。</p><p>(3) <strong>直接初始化</strong></p><p>①　直接初始化是指采用小括号的方式进行变量初始化（小括号里一定要有初始值，如果没提供初始值，那就是值初始化了！）</p><p>②　<strong>对于类类型来说，直接初始化会直接调用与实参匹配的构造函数。</strong></p><p>(4) <strong>拷贝初始化</strong></p><p>①　拷贝初始化是指采用等号（=）进行初始化的方式，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p><p>②　拷贝初始化首先使用指定构造函数创建一个临时对象，然后用<strong>拷贝构造函数</strong>将那个临时对象拷贝到正在创建的对象。</p><h3 id="36-直接初始化、拷贝初始化、赋值的差别？"><a href="#36-直接初始化、拷贝初始化、赋值的差别？" class="headerlink" title="36. 直接初始化、拷贝初始化、赋值的差别？"></a>36. 直接初始化、拷贝初始化、赋值的差别？</h3><p>(1) 这三种操作非常类似，语法上也很相像，<strong>区分这三者主要看他们的最终调用的函数</strong>。</p><p>(2) 直接初始化：<strong>要创建的对象不存在</strong>，主要利用<strong>初始化器（圆括号）</strong>使用其他的初始值进行初始化操作，一般这个初始值是别的对象或数据类型，<strong>直接初始化调用类的构造函数（调用参数类型最佳匹配的那个）</strong>。</p><p>(3) 拷贝初始化：<strong>要创建的对象不存在</strong>，使用已有的对象（与创建的对象类型一致）来进行初始化，这个已有的对象既可以是临时对象也可以是其他对象。<strong>既可以使用初始化器（圆括号），也可以使用赋值号（“=”）来进行初始化操作，但他们的背后都会调用类的拷贝构造函数</strong>。</p><p>(4) 赋值：<strong>要创建的对象已存在</strong>，用已存在的对象给它赋值，这属于重载“=”号运算符的范畴，他并不是一种初始化操作，<strong>背后调用类的重载“=”运算符函数</strong>。</p><p>(5) 对于内置类型变量（如int，double，bool等），直接初始化与拷贝初始化差别可以忽略不计。</p><h3 id="37-静态变量什么时候初始化？"><a href="#37-静态变量什么时候初始化？" class="headerlink" title="37. 静态变量什么时候初始化？"></a>37. 静态变量什么时候初始化？</h3><p>视编译器而定，有些可能在代码执行之前就初始化，有些则可能直到代码执行时才初始化。</p><h3 id="38-delete、delete-的区别？"><a href="#38-delete、delete-的区别？" class="headerlink" title="38. delete、delete []的区别？"></a>38. delete、delete []的区别？</h3><p>delete只会调用一次析构函数，delete [] 会根据数组元素的数量，对数组中的每个元素调用析构函数。</p><h3 id="39-malloc、calloc、realloc的区别？"><a href="#39-malloc、calloc、realloc的区别？" class="headerlink" title="39. malloc、calloc、realloc的区别？"></a>39. malloc、calloc、realloc的区别？</h3><p>(1) <strong>malloc函数</strong>：void* malloc(unsigned int num_size); 需要手动计算分配大小，申请的空间的值是随机初始化的</p><p>(2) <strong>calloc函数</strong>：void* calloc(size_t n,size_t size);无需手动计算分配大小，申请的空间的值是初始化为0的</p><p>(3) <strong>realloc函数</strong> ：给动态分配的空间分配额外的空间，用于扩充容量。</p><p>详细解释：</p><p><code>malloc</code>, <code>calloc</code> 和 <code>realloc</code> 都是 C 和 C++ 语言中用来动态分配内存的函数，但它们各有不同的用途和行为。</p><ul><li><code>malloc</code>: 这是最常用的动态内存分配函数。<code>malloc</code> 接受一个参数，即要分配的字节数，然后返回一个指向新分配内存的指针，或者在无法分配内存时返回 NULL。需要注意的是 <code>malloc</code> 不会清零新分配的内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存</span></span><br></pre></td></tr></table></figure><ul><li><code>calloc</code>: 这个函数与 <code>malloc</code> 类似，但它接受两个参数：要分配的元素数量和每个元素的大小。<code>calloc</code> 会返回一个指向新分配内存的指针，或者在无法分配内存时返回 NULL。与 <code>malloc</code> 不同，<code>calloc</code> 会清零新分配的内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存，并将内存清零</span></span><br></pre></td></tr></table></figure><ul><li><code>realloc</code>: 这个函数用于改变已分配的内存大小。<code>realloc</code> 接受两个参数：一个指向已分配内存的指针和新的内存大小（以字节为单位）。<code>realloc</code> 会返回一个指向新内存的指针，或者在无法分配内存时返回 NULL。如果新的内存大小大于原来的大小，<code>realloc</code> 会保留原来内存的内容，并可能将新的内存部分初始化为零。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配足够存储10个整数的内存</span></span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 扩大内存以存储20个整数</span></span><br></pre></td></tr></table></figure><p>在使用这些函数时，一定要记住在不再需要内存时使用 <code>free</code> 函数释放它，以防止内存泄漏。</p><h3 id="40-说说类成员的初始化方式？"><a href="#40-说说类成员的初始化方式？" class="headerlink" title="40. 说说类成员的初始化方式？"></a>40. 说说类成员的初始化方式？</h3><p>(1) <strong>构造函数初始化：</strong>在构造函数体中初始化,在所有的数据成员被分配内存空间后，才进行赋值操作。背后会调用一次数据成员的构造函数和赋值函数。</p><p>(2) <strong>初始化列表：</strong>给数据成员分配内存空间时就进行初始化，相比起构造函数初始化，少了一次调用赋值函数的操作，因此效率会更高一些。</p><h3 id="41-构造函数的执行顺序？"><a href="#41-构造函数的执行顺序？" class="headerlink" title="41. 构造函数的执行顺序？"></a>41. 构造函数的执行顺序？</h3><p>(1) 基类的构造函数</p><p>(2) 派生类的数据成员的构造函数</p><p>(3) 派生类自己的构造函数</p><h3 id="42-析构函数的执行顺序？"><a href="#42-析构函数的执行顺序？" class="headerlink" title="42. 析构函数的执行顺序？"></a>42. 析构函数的执行顺序？</h3><p>(1) 调用派生类的析构函数；</p><p>(2) 调用派生类的数据成员的析构函数；</p><p>(3) 调用基类的析构函数。</p><h3 id="43-有哪些情况必须使用初始化列表？"><a href="#43-有哪些情况必须使用初始化列表？" class="headerlink" title="43. 有哪些情况必须使用初始化列表？"></a>43. 有哪些情况必须使用初始化列表？</h3><p>要不然进入到括号里面就对象就构造完成了。</p><p>(1) 当初始化一个引用成员时</p><p>(2) 当初始化一个常量成员时</p><p>(3) 当调用一个基类的构造函数，而它拥有一组参数时</p><p>(4) 当调用一个成员类的构造函数，而它拥有一组参数时</p><h3 id="44-初始化列表的初始化顺序？"><a href="#44-初始化列表的初始化顺序？" class="headerlink" title="44. 初始化列表的初始化顺序？"></a>44. 初始化列表的初始化顺序？</h3><p>这和对象内存有关。</p><p>初始化列表中出现的顺序并不是真正的初始化顺序，初始化顺序只取决于成员变量在类中的声明顺序。我们应尽可能保证成员变量的声明顺序与初始化列表顺序一致，才能真正保证其效率。</p><h3 id="45-C-中新增的string与C中的-char-有什么区别？"><a href="#45-C-中新增的string与C中的-char-有什么区别？" class="headerlink" title="45. C++中新增的string与C中的 char *有什么区别？"></a>45. C++中新增的string与C中的 char *有什么区别？</h3><p>(1) string对char*进行了封装，包含了字符串的属性以及对外提供了通用方法。</p><p>(2) string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p><h3 id="46-什么是内存泄露，如何检测与避免？"><a href="#46-什么是内存泄露，如何检测与避免？" class="headerlink" title="46. 什么是内存泄露，如何检测与避免？"></a>46. 什么是内存泄露，如何检测与避免？</h3><p>(1) 内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的内存块，使用完后必须显式释放的内存，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。</p><p>(2) 检测方法：有专门的内存泄漏检测工具，Linux下可以使用Valgrind工具 ，Windows下可以使用CRT库。</p><p>(3) 避免方法：使用智能指针，良好的编程习惯。</p><h3 id="47-什么是内存溢出和内存越界？"><a href="#47-什么是内存溢出和内存越界？" class="headerlink" title="47. 什么是内存溢出和内存越界？"></a>47. 什么是内存溢出和内存越界？</h3><p>(1) 内存溢出指的是程序在申请内存时，没有足够的内存空间供其使用。</p><p>(2) 内存越界指的是申请了一块内存，使用的时候超出了这块内存区域。</p><h3 id="48-介绍C-面向对象的三大特性？"><a href="#48-介绍C-面向对象的三大特性？" class="headerlink" title="48. 介绍C++面向对象的三大特性？"></a>48. 介绍C++面向对象的三大特性？</h3><p>(1) <strong>继承</strong></p><p>让某个类获得另一个类的属性和方法。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展，是代码复用的一种机制。</p><p>常见的继承有两种方式：</p><p><strong>实现继承：</strong>指使用基类的属性和方法而无需额外编码的能力</p><p><strong>接口继承：</strong>指仅使用属性和方法的名称、但是子类必须提供实现的能力</p><p>(2) <strong>封装</strong></p><p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。在C++中借以权限机制实现这一特性，利用三种访问权限控制外界对对象数据的访问。</p><p>(3) <strong>多态</strong></p><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>常见的多态有两种方式：</p><p><strong>编译时多态（重载）：</strong>是指允许存在多个同名函数，而这些函数的参数表不同</p><p><strong>运行时多态（重写）：</strong>是指子类重新定义父类的虚函数的做法</p><h3 id="49-说说C-的四种强制转换？"><a href="#49-说说C-的四种强制转换？" class="headerlink" title="49. 说说C++的四种强制转换？"></a>49. 说说C++的四种强制转换？</h3><p>(1) <strong>reinterpret_cast：</strong>reinterpret_cast 用以处理互不相关的类型之间的转换，reinterpret_cast 操作执行的是比特位拷贝，即编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去。这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。</p><p>(2) <strong>const_cast：</strong>该运算符用来修改类型的const属性，可以使指向常量的指针被转化成指向非常量的指针，并且仍然指向原来的对象，使拥有者可以通过指针修改对象。</p><p>(3) <strong>static_cast：</strong>static_cast 用于进行比较“自然”和低风险的转换，如<strong>整型和浮点型、字符型与整型</strong>之间的互相转换。static_cast <strong>不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。</strong>因为这些属于风险比较高的转换。他的安全性比起reinterpret_cast 更高，但是由于该操作符没有运行时类型检查机制，在进行下行转换（把基类指针或引用转换成派生类指针或引用）时仍然是不安全的。</p><p>(4) <strong>dynamic_cast：</strong>dynamic_cast主要用于类层次间的上行转换和下行转换，因为有动态类型检测，在进行下行转换时比static_cast更安全。</p><p>举例</p><p>C++中有四种类型的强制类型转换，分别是 <code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p><ol><li><code>static_cast</code>：这是最常用的类型转换符。它可以在任何的数据类型之间进行转换，但是转换的类型需要是相关的，否则可能会产生意外的结果。</li></ol><p>例如，将整数转换为浮点数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(a);  <span class="comment">// b = 10.0</span></span><br></pre></td></tr></table></figure><ol><li><code>dynamic_cast</code>：这个类型转换符主要用在类的继承体系中，用于进行上行转换和安全的下行转换。当我们试图将父类指针转换为子类指针时，可以使用 <code>dynamic_cast</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  <span class="comment">// 安全的下行转换</span></span><br></pre></td></tr></table></figure><ol><li><code>const_cast</code>：这个类型转换符用于移除常量性。如果我们有一个 <code>const</code> 变量，但我们需要修改它，可以使用 <code>const_cast</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">20</span>;  <span class="comment">// a现在是20，但这样做是危险的，因为a本来是const的</span></span><br></pre></td></tr></table></figure><ol><li><code>reinterpret_cast</code>：这个类型转换符用于进行低级别的类型转换，它可以在任何指针或整数类型之间进行转换。但是使用这个转换符需要非常小心，因为它可能会产生意外的结果。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">char</span>* c = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(p);  <span class="comment">// 将int*转换为char*</span></span><br></pre></td></tr></table></figure><p>注意：尽管 C++ 提供了这些强制类型转换，但应尽量避免使用它们，除非你非常确定你知道自己在做什么。在很多情况下，使用强制类型转换可能会导致未定义的行为。</p><h3 id="50-如何获得结构成员相对于结构开头的字节偏移量？"><a href="#50-如何获得结构成员相对于结构开头的字节偏移量？" class="headerlink" title="50. 如何获得结构成员相对于结构开头的字节偏移量？"></a>50. 如何获得结构成员相对于结构开头的字节偏移量？</h3><p>使用<stddef.h>头文件中的，offsetof宏</p><p>offsetof用法：offsetof(S, x)，S为结构体对象，x为结构体数据成员之一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s, m) (reinterpret_cast<span class="string">&lt;size_t&gt;</span>(&amp;reinterpret_cast<span class="string">&lt;const volatile char&amp;&gt;</span>(static_cast<span class="string">&lt;s*&gt;</span>(nullptr)-&gt;m)))</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the first element is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, a)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the second is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, b)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the third element is at offset &quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(<span class="keyword">struct</span> S, c)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>此处，通过 <code>static_cast&lt;s*&gt;(nullptr)</code>，编译器相信在 <code>nullptr</code> 处（<code>0x0</code>）有一个真实存在的 <code>s</code> 类型的对象。</p><p>此处使用 <code>static_cast</code> 而非 <code>reinterpret_cast</code> 是因为 C++ 标准不允许将 <code>nullptr</code> 通过 <code>reinterpret_cast</code> 转换成其他类型的指针；</p><p>此类转换应用 <code>static_cast</code>。由于 <code>static_cast&lt;s*&gt;(nullptr)</code> 返回指向 <code>s</code> 类型对象的指针，因此 <code>static_cast&lt;s*&gt;(nullptr)-&gt;m</code> 就是一个虚拟但在编译器看来可用的成员变量 <code>m</code>。</p><p>为了求得以字节为单位的 <code>ptrdiff_t</code>，实现中通过 <code>&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)</code> 获得一个 <code>const volatile char*</code> 类型的变量。</p><p>由于在该实现中，虚拟的变量位于 <code>0x0</code> 位置，故而 <code>&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)</code> 即是 <code>m</code> 在 <code>s</code> 类型对象当中相对对象起始地址的偏移量。</p><p>最后，只需将它转换为 <code>size_t</code> 类型的值即可。</p><p>具体：<a href="https://zhuanlan.zhihu.com/p/677486774">理解C/C++ 中的offsetof 宏原理</a></p><h3 id="51-静态类型和动态类型，静态绑定和动态绑定的介绍？"><a href="#51-静态类型和动态类型，静态绑定和动态绑定的介绍？" class="headerlink" title="51. 静态类型和动态类型，静态绑定和动态绑定的介绍？"></a>51. 静态类型和动态类型，静态绑定和动态绑定的介绍？</h3><p>(1) 静态类型：对象在声明时采用的类型，在编译期既已确定；</p><p>(2) 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</p><p>(3) 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p><p>(4) 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</p><h3 id="52-全局变量和局部变量有什么区别？"><a href="#52-全局变量和局部变量有什么区别？" class="headerlink" title="52. 全局变量和局部变量有什么区别？"></a>52. 全局变量和局部变量有什么区别？</h3><p>(1) 生命周期：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p>(2) 作用域：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用</p><h3 id="53-指针加减计算要注意什么？"><a href="#53-指针加减计算要注意什么？" class="headerlink" title="53. 指针加减计算要注意什么？"></a>53. 指针加减计算要注意什么？</h3><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，即内存越界。</p><h3 id="54-怎样判断两个浮点数是否相等？"><a href="#54-怎样判断两个浮点数是否相等？" class="headerlink" title="54. 怎样判断两个浮点数是否相等？"></a>54. 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</p><h3 id="55-类如何实现只能静态分配和只能动态分配？"><a href="#55-类如何实现只能静态分配和只能动态分配？" class="headerlink" title="55. 类如何实现只能静态分配和只能动态分配？"></a>55. 类如何实现只能静态分配和只能动态分配？</h3><p>(1) 实现只能静态分配：把operator new运算符重载为private属性。</p><p>(2) 实现只能动态分配：把构造函数设为private属性</p><h3 id="56-知道C-中的组合吗-它与继承相比有什么优缺点吗？"><a href="#56-知道C-中的组合吗-它与继承相比有什么优缺点吗？" class="headerlink" title="56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？"></a>56. 知道C++中的组合吗?它与继承相比有什么优缺点吗？</h3><p>继承有以下几个缺点：</p><p>(1) 父类的内部细节对子类是可见的，破坏了封装性。</p><p>(2) 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p><p>(3) 子类与父类是一种高耦合，违背了面向对象思想。</p><p>使用组合的目的即为了克服这几个缺点，但也因此产生了另一些缺点，如：容易产生过多的对象、为了能组合多个对象，必须仔细对接口进行定义。</p><h3 id="57-为什么模板类一般都是放在一个头文件中？"><a href="#57-为什么模板类一般都是放在一个头文件中？" class="headerlink" title="57. 为什么模板类一般都是放在一个头文件中？"></a>57. 为什么模板类一般都是放在一个头文件中？</h3><p>模板定义很特殊，编译器在遇到任何的模板定义时不会为它分配内存空间，它一直处于等待状态直到被一个模板实例告知才会分配内存空间。如果在分离式编译环境下，编译器编译某一个源文件时并不知道另一个源文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器），同时由于模板定义没有被分配空间，链接器也无法查找到函数的入口地址。</p><h3 id="58-你了解重载运算符吗？"><a href="#58-你了解重载运算符吗？" class="headerlink" title="58. 你了解重载运算符吗？"></a>58. 你了解重载运算符吗？</h3><p>C++预定义中的运算符的操作对象只局限于基本的内置数据类型，但是对于我们自定义的类型（类）是没有办法操作的。但是大多时候我们需要对我们定义的类型进行类似的运算，这个时候就需要我们对这么运算符进行重新定义，赋予其新的功能，以满足自身的需求。<strong>这就是运算符重载，它的实质就是函数重载。</strong></p><p>运算符重载规则：</p><p>(1) 为了防止用户对标准类型进行运算符重载，C++规定重载后的运算符的操作对象必须至少有一个是用户定义的类型。</p><p>(2) 使用运算符不能违法运算符原来的句法规则。如不能将‘+’重载为一个操作数。</p><p>(3) 不能修改运算符原先的优先级。</p><p>(4) 不能创建一个新的运算符</p><p>(5) 不能进行重载的运算符：成员运算符，作用域运算符，条件运算符，sizeof运算符，typeid运算符，const_cast、dynamic_cast、reinterpret_cast、static_cast强制类型转换运算符。</p><p>(6) 大多数运算符可以通过成员函数和非成员函数进行重载，但是下面这四种运算符只能通过成员函数进行重载：= 赋值运算符，（）函数调用运算符，[ ]下标运算符，-&gt;通过指针访问类成员的运算符。</p><p>(7) 一般来说，单目运算符重载为类的成员函数，双目运算符重载为类的友元函数</p><h3 id="59-前-和后-重载的区别？"><a href="#59-前-和后-重载的区别？" class="headerlink" title="59. 前++和后++重载的区别？"></a>59. 前++和后++重载的区别？</h3><p>(1) 前++重载函数参数列表不需要带参数，后++参数列表需要带参数，这个参数仅仅只是区分前++和后++用，没有实际意义。</p><p>(2) 前++返回一个引用，后++返回一个临时对象，后++效率比较高。</p><h3 id="60-当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#60-当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>60. 当程序中有函数重载时，函数的匹配原则和顺序是什么？</h3><p>(1) 名字查找</p><p>(2) 确定候选函数</p><p>(3) 寻找最佳匹配</p><h3 id="61-条件编译的作用？"><a href="#61-条件编译的作用？" class="headerlink" title="61. 条件编译的作用？"></a>61. 条件编译的作用？</h3><p>(1) 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”<strong>。</strong></p><p>(2) 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用条件编译即可避免该错误。</p><h3 id="62-隐式转换是什么，如何消除类的隐式转换？"><a href="#62-隐式转换是什么，如何消除类的隐式转换？" class="headerlink" title="62. 隐式转换是什么，如何消除类的隐式转换？"></a>62. 隐式转换是什么，如何消除类的隐式转换？</h3><p>(1) C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换。<strong>最常见的隐式转换为函数传参。</strong></p><p>(2) C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p><h3 id="63-如何在不使用额外空间的情况下，交换两个数？"><a href="#63-如何在不使用额外空间的情况下，交换两个数？" class="headerlink" title="63. 如何在不使用额外空间的情况下，交换两个数？"></a>63. 如何在不使用额外空间的情况下，交换两个数？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line"><span class="attribute">x</span>=x+y</span><br><span class="line"><span class="attribute">y</span>=x-y</span><br><span class="line"><span class="attribute">x</span>=x-y</span><br><span class="line">(2)</span><br><span class="line"><span class="attribute">x</span>=x^y</span><br><span class="line"><span class="attribute">y</span>=x^y</span><br><span class="line"><span class="attribute">x</span>=x&amp;y</span><br></pre></td></tr></table></figure><h3 id="64-你知道strcpy和memcpy的区别是什么？"><a href="#64-你知道strcpy和memcpy的区别是什么？" class="headerlink" title="64. 你知道strcpy和memcpy的区别是什么？"></a>64. 你知道strcpy和memcpy的区别是什么？</h3><p>(1) <strong>复制的内容不同。</strong>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类对象等。</p><p>(2) <strong>复制的方法不同。</strong>strcpy不需要指定长度，它遇到被复制字符串的结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度，更加安全。</p><p>(3) <strong>用途不同。</strong>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p><h3 id="65-如果有一个空类，它会默认添加哪些函数？"><a href="#65-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="65. 如果有一个空类，它会默认添加哪些函数？"></a>65. 如果有一个空类，它会默认添加哪些函数？</h3><p>(1) 默认构造函数</p><p>(2) 拷贝构造函数</p><p>(3) 析构函数</p><p>(4) 赋值运算符函数</p><h3 id="66-static-cast比C语言中的转换强在哪里？"><a href="#66-static-cast比C语言中的转换强在哪里？" class="headerlink" title="66. static_cast比C语言中的转换强在哪里？"></a>66. static_cast比C语言中的转换强在哪里？</h3><p>(1) 更加安全</p><p>(2) 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误</p><h3 id="67-成员函数里memset-this-0-sizeof-this-会发生什么？"><a href="#67-成员函数里memset-this-0-sizeof-this-会发生什么？" class="headerlink" title="67. 成员函数里memset(this,0,sizeof(*this))会发生什么？"></a>67. 成员函数里memset(this,0,sizeof(*this))会发生什么？</h3><p>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。</p><p><strong>对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</strong></p><p>(1) 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</p><p>(2) 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</p><h3 id="68-你知道回调函数吗-它的作用？"><a href="#68-你知道回调函数吗-它的作用？" class="headerlink" title="68. 你知道回调函数吗?它的作用？"></a>68. 你知道回调函数吗?它的作用？</h3><p>(1) 回调函数就是一个通过函数指针调用的函数。回调的函数的定义由程序员实现，但无需程序员调用，可将函数指针作为参数传递给某个函数库中的函数，由函数库去调用。</p><p>(2) 回调函数是在<strong>“你想让别人的代码执行你的代码，而别人的代码你又不能动”</strong>这种需求下产生的。</p><p>(3) 可以做回调函数的函数有两种，一种是普通函数，一种是静态成员函数。<strong>普通成员函数不能做回调函数</strong>，因为普通成员函数自带this指针参数，会导致函数声明与调用不匹配的情况发生。</p><p>(4) 回调函数是一种设计系统的思想，能够解决系统架构中的部分问题，但是系统中不能过多使用回调函数，因为回调函数会改变整个系统的运行轨迹和执行顺序，耗费资源，而且会使得代码晦涩难懂。</p><p><strong>回调函数的本质确实是函数指针。通过函数指针，我们可以将函数作为参数传递给另一个函数，这就是所谓的“回调”。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef int(*callback)(int);//定义回调函数的原型（接收参数、返回值、名称等）</span></span><br><span class="line"><span class="keyword">using</span>  callback = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,callback cb)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">cb</span>(x); &#125;<span class="comment">//接收回调函数指针的函数（需要使用回调功能的地方）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callbackImpl1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;<span class="comment">//第一个回调函数实现示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callbackImpl2</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;<span class="comment">//第二个回调函数实现示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result1=<span class="built_in">func</span>(<span class="number">2</span>, &amp;callbackImpl1);<span class="comment">//注意传入的是第一个回调函数实现的（地址）指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result1);</span><br><span class="line"><span class="type">int</span> result2 = <span class="built_in">func</span>(<span class="number">2</span>, &amp;callbackImpl2);<span class="comment">//注意传入的是第一个回调函数实现的（地址）指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result2);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="69-C-从代码到可执行程序经历了什么？"><a href="#69-C-从代码到可执行程序经历了什么？" class="headerlink" title="69. C++从代码到可执行程序经历了什么？"></a>69. C++从代码到可执行程序经历了什么？</h3><p><strong>(1) 预编译</strong></p><p>主要处理源代码文件中的以“#”开头的预编译指令。</p><p><strong>(2) 编译</strong></p><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><p><strong>(3) 汇编</strong></p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来。</p><p><strong>(4) 链接</strong></p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。</p><h3 id="70-类的对象存储空间？"><a href="#70-类的对象存储空间？" class="headerlink" title="70. 类的对象存储空间？"></a>70. 类的对象存储空间？</h3><p>(1) 非静态成员的数据类型大小之和。</p><p>(2) 编译器加入的额外成员变量（如指向虚函数表的指针）。</p><p>(3) 为了内存对齐而补入的额外空间。</p><p>(4) 空类大小为1，但若是作为基类，则大小为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="71-静态链接和动态链接的区别？"><a href="#71-静态链接和动态链接的区别？" class="headerlink" title="71. 静态链接和动态链接的区别？"></a>71. 静态链接和动态链接的区别？</h3><p>静态链接和动态链接是针对函数库来说的，现在的函数库分为两种：<strong>静态库和动态库</strong>。他们分别对应静态链接和动态链接。</p><p>(1) <strong>静态链接：</strong>所有的函数和数据都被编译进一个文件中。在使用静态库的情况下，在编译链接可执行文件时，链接器从函数库中复制函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。静态链接有以下特点：</p><p>①　空间浪费：因为每个可执行程序中都拥有函数库数据的一份副本，所以如果多个程序对同一个目标文件都有依赖，当他们同时运行在计算机上，会出现同一个函数库在内存中有多个副本，浪费内存空间；</p><p>②　更新困难：每当库函数的代码修改了，所有依赖该库的程序都需要重新进行编译链接。</p><p>③　运行速度快：因为在可执行程序中已经具备了所有执行程序所需要的任何东西，所以在执行的时候运行速度快。</p><p>(2) <strong>动态链接：</strong>动态链接会在程序运行时才将函数库与源程序执行链接，而不是像静态链接一样把所有模块都链接成一个单独的可执行文件。动态链接有以下特点：</p><p>①　共享库：如果多个程序都依赖同一个库，该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p><p>②　更新方便：更新时只需要替换原来的库文件，依赖它的程序无需重新编译。当程序下一次运行时，新库会被自动加载到内存并且与其他程序执行链接，程序就完成了升级迭代。</p><p>性能损耗：因为把链接推迟到了程序运行时，每次执行程序都需要进行链接，所以性能会有一定损失。</p><h3 id="72-为什么不能把所有的函数写成内联函数？"><a href="#72-为什么不能把所有的函数写成内联函数？" class="headerlink" title="72. 为什么不能把所有的函数写成内联函数？"></a>72. 为什么不能把所有的函数写成内联函数？</h3><p>(1) 首先，不管是什么函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，<strong>编译器并不一定真正的内联</strong>。</p><p>(2) 内联函数以代码复杂为代价，省去了函数调用的开销来提高执行效率。如果内联函数体内代码执行时间相比起函数调用开销更大，则没有太大的意义。<strong>一般来说若是函数体代码比较长或者内部带有循环，则不推荐使用内联函数。</strong></p><p>(3) <strong>将构造函数和析构函数声明为inline是没有什么意义的，</strong>即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。</p><p>(4) <strong>将虚函数声明为inline，要分情况讨论。</strong>当指向派生类的指针（多态性）调用声明为inline的虚函数时，由于inline是编译期决定的，而虚函数是运行期决定的，在不知道将要调用哪个函数的情况下，编译器不会内联展开；当对象本身调用虚函数时，编译器能决议出会调用哪个函数时，就会内联展开，当然前提依然是函数并不复杂的情况下。</p><h3 id="73-为什么C-没有垃圾回收机制？"><a href="#73-为什么C-没有垃圾回收机制？" class="headerlink" title="73. 为什么C++没有垃圾回收机制？"></a>73. 为什么C++没有垃圾回收机制？</h3><p>(1) 实现一个垃圾回收器会带来额外的空间和时间开销。</p><p>(2) 垃圾回收会使得C++不适合进行很多底层的操作。</p><h3 id="74-说说C-的内存分区？"><a href="#74-说说C-的内存分区？" class="headerlink" title="74. 说说C++的内存分区？"></a>74. 说说C++的内存分区？</h3><p>在C++中，内存分成5个区，他们分别是<strong>堆、栈、全局/静态存储区和常量存储区和代码区</strong>。</p><p>(1) <strong>栈：</strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈工作效率很高，但是分配的内存容量有限。</p><p>(2) <strong>堆：</strong>就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>(3) <strong>全局/静态存储区：</strong>这块内存在编译时已经分配好，且在程序运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量。</p><p>(4) <strong>常量存储区：</strong>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p><p>(5) <strong>代码区：</strong>存放程序的二进制代码。</p><h3 id="75-说说友元函数和友元类的特性？"><a href="#75-说说友元函数和友元类的特性？" class="headerlink" title="75. 说说友元函数和友元类的特性？"></a>75. 说说友元函数和友元类的特性？</h3><p>友元提供了<strong>不同类的成员函数之间、类的成员函数和一般函数之间</strong>进行数据共享的机制。通过友元，外部的普通函数或者另一个类中的成员函数可以访问本类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。友元具有以下特性：</p><p>(1) <strong>友元关系不能被继承。</strong></p><p>(2) <strong>友元关系是单向的，不具有交换性。</strong>若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p><p><strong>友元关系不具有传递性。</strong>若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的声明。</p><h3 id="76-关于this指针你知道什么？"><a href="#76-关于this指针你知道什么？" class="headerlink" title="76. 关于this指针你知道什么？"></a>76. 关于this指针你知道什么？</h3><p>(1) this指针是类的指针，指向对象的首地址。</p><p>(2) this指针只能在普通成员函数中使用，在全局函数、静态成员函数中都不能用this。</p><p>(3) this在成员函数的开始执行前构造，在成员的执行结束后清除。</p><p>(4) this指针只有在普通成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p><p>(5) this指针主要可用于返回类对象本身的时候，直接使用 return *this。或者当形参数与成员变量名相同时用于区分，如this-&gt;n = n。</p><h3 id="77-在成员函数中调用delete-this会出现什么问题？"><a href="#77-在成员函数中调用delete-this会出现什么问题？" class="headerlink" title="77. 在成员函数中调用delete this会出现什么问题？"></a>77. 在成员函数中调用delete this会出现什么问题？</h3><p>当调用delete this时，类对象的内存空间被释放。因为类成员函数并没有存放在类对象的内存空间中，所以在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，因为内存被释放，所以就会出现不可预期的问题。</p><h3 id="78-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#78-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="78. 如果在类的析构函数中调用delete this，会发生什么？"></a>78. 如果在类的析构函数中调用delete this，会发生什么？</h3><p>会导致堆栈溢出。因为delete会调用析构函数，导致递归。</p><h3 id="79-C-中类的数据成员和成员函数内存分布情况？"><a href="#79-C-中类的数据成员和成员函数内存分布情况？" class="headerlink" title="79. C++中类的数据成员和成员函数内存分布情况？"></a>79. C++中类的数据成员和成员函数内存分布情况？</h3><p>(1) 普通数据成员存放在对象内存空间中</p><p>(2) 静态数据成员存放在全局/静态存储区中</p><p>(3) 普通成员函数和静态成员函数都存放在代码区中</p><h3 id="80-C-的多态怎么实现？"><a href="#80-C-的多态怎么实现？" class="headerlink" title="80. C++的多态怎么实现？"></a>80. C++的多态怎么实现？</h3><p>C++的多态机制有两种，分为编译时多态和运行时多态，下面分别介绍这两种多态。</p><p><strong>编译时多态</strong></p><p>(1) 主要通过模板和函数重载实现，在编译期发生，由编译器进行推断决议。</p><p>(2) 优点：</p><p>①　它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。</p><p>②　在编译器完成多态，提高运行期效率。</p><p>③　具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。</p><p>(3) 缺点：</p><p>①　程序可读性降低，代码调试带来困难。</p><p>②　无法实现模板的分离编译，当工程很大时，编译时间不可小觑。</p><p><strong>运行时多态</strong></p><p>(1) 运行期多态的设计思想要归结到类继承体系的设计上去。对于有相关功能的对象集合，我们总希望能够抽象出它们共有的功能集合，在基类中将这些功能声明为虚接口（虚函数），然后由子类继承基类去重写这些虚接口，以实现子类特有的具体功能。</p><p>(2) 在C++中，主要由虚表和虚表指针实现运行时多态。运行时多态实现细节如下：</p><p>①　编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。</p><p>②　编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p><p>③　在派生类定义对象时，会先调用父类的构造函数，此时，编译器只“看到了父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p><p>④　当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p><p>(3) 优点：</p><p>面向对象设计中重要的特性，对客观世界直觉认识。</p><p>(4) 缺点：</p><p>①　运行期间进行虚函数绑定，提高了程序运行开销。</p><p>②　庞大的类继承层次，对接口的修改易影响类继承层次。</p><p>③　由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。</p><p>④　虚表指针增大了对象体积，类也多了一张虚函数表。</p><h3 id="81-为什么要把析构函数写成虚函数？"><a href="#81-为什么要把析构函数写成虚函数？" class="headerlink" title="81. 为什么要把析构函数写成虚函数？"></a>81. 为什么要把析构函数写成虚函数？</h3><p>由于类的多态性，基类指针可以指向派生类的对象。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p><h3 id="82-虚函数表存放在内存的什么区域？"><a href="#82-虚函数表存放在内存的什么区域？" class="headerlink" title="82. 虚函数表存放在内存的什么区域？"></a>82. 虚函数表存放在内存的什么区域？</h3><p>C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；</p><p>虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</p><h3 id="83-模板偏特化了解吗？"><a href="#83-模板偏特化了解吗？" class="headerlink" title="83. 模板偏特化了解吗？"></a>83. 模板偏特化了解吗？</h3><p>(1) 通过编写模板，能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化（模板偏特化）。</p><p>(2) 所谓的模板偏特化对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上。</p><p>(3) 特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以<strong>最佳匹配</strong>为原则。</p><p>(4) 可以特例化类中的部分成员函数而不是整个类。</p><p>举例：</p><p>模板偏特化是C++模板编程中的一个重要概念。简单来说，模板偏特化就是对模板进行部分特化，也就是将模板的部分参数具体化。模板偏特化可以让我们为特定的类型或条件提供特化的实现。</p><p>举例来说，假设我们有一个模板类用于存储数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    T data[N];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们想要对<code>bool</code>类型的数组进行特化，因为<code>bool</code>类型的数组可以通过位操作进行压缩存储，从而节省空间。我们可以通过模板偏特化来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">bool</span>, N&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用位操作进行压缩存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[(N+<span class="number">7</span>)/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Array&lt;bool, N&gt;</code>是<code>Array&lt;T, N&gt;</code>的一个偏特化版本。当我们创建一个<code>Array&lt;bool, 100&gt;</code>对象时，编译器会使用偏特化版本的模板，从而实现对<code>bool</code>类型数组的优化存储。</p><h3 id="84-哪些函数不能被定义为虚函数？"><a href="#84-哪些函数不能被定义为虚函数？" class="headerlink" title="84. 哪些函数不能被定义为虚函数？"></a>84. 哪些函数不能被定义为虚函数？</h3><p>(1) <strong>构造函数。</strong>每一个声明了虚函数的类对象都有一个指向虚表(vtable)的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的,假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？再者，虚函数主要是在调用对象不确定的情况下使用的，然而构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。</p><p>(2) <strong>静态函数。</strong>静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p><p>(3) <strong>友元函数。</strong>友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p><p>(4) <strong>普通函数。</strong>普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p><h3 id="85-构造函数和析构函数可以调用虚函数吗，为什么？"><a href="#85-构造函数和析构函数可以调用虚函数吗，为什么？" class="headerlink" title="85. 构造函数和析构函数可以调用虚函数吗，为什么？"></a>85. 构造函数和析构函数可以调用虚函数吗，为什么？</h3><p>(1) <strong>构造函数调用虚函数没有意义</strong>，因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编。</p><p>(2) <strong>析构函数调用虚函数没有意义，</strong>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p><h3 id="86-构造函数和析构函数可否抛出异常？"><a href="#86-构造函数和析构函数可否抛出异常？" class="headerlink" title="86. 构造函数和析构函数可否抛出异常？"></a>86. 构造函数和析构函数可否抛出异常？</h3><p>(1) <strong>构造函数不可抛出异常：</strong>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，<strong>如果某个对象的构造函数中发生异常，则该对象的析构函数不会被调用。因此会造成内存泄漏。</strong></p><p>(2) <strong>析构函数不可抛出异常：</strong>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。再者，通常异常发生时，C++ 的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p><h3 id="87-模板类和模板函数的区别是什么？"><a href="#87-模板类和模板函数的区别是什么？" class="headerlink" title="87. 模板类和模板函数的区别是什么？"></a>87. 模板类和模板函数的区别是什么？</h3><p>函数模板的实例化是由编译器在处理函数调用时自动完成的，而类模板的实例化必须由程序员在代码中显式地指定。即函数模板允许隐式调用和显式调用，而类模板只能显式调用。</p><h3 id="88-什么是虚继承？"><a href="#88-什么是虚继承？" class="headerlink" title="88. 什么是虚继承？"></a>88. 什么是虚继承？</h3><p>(1) 由于C++支持多继承，因此除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承。</p><p>(2) 多继承有可能引发一直特别情况：B和C公有继承A，D又公有继承B和C，这种方式是一种菱形继承或者钻石继承，如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240513220826075.png" alt="image-20240513220826075"></p><p>(3) 如果D调用了A的方法，则会引发数据的二义性和冗余，编译器不知道是要调用B所继承的A，还是C所继承的A。</p><p>(4) 为了解决这个问题，C++引入了虚拟继承，在虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</p><h3 id="89-抽象基类为什么不能创建对象？纯虚函数又是什么？"><a href="#89-抽象基类为什么不能创建对象？纯虚函数又是什么？" class="headerlink" title="89. 抽象基类为什么不能创建对象？纯虚函数又是什么？"></a>89. 抽象基类为什么不能创建对象？纯虚函数又是什么？</h3><p>(1) 带有纯虚函数的类为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的。抽象类会将所有派生类中有关的操作抽象成一个通用接口且不做具体实现（纯虚函数），具体实现由派生类实现，因此抽象基类不可以创建对象。</p><p>(2) 纯虚函数是一种特殊的虚函数，该类函数没有函数体。因为在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><h3 id="90-说说RTTI？"><a href="#90-说说RTTI？" class="headerlink" title="90. 说说RTTI？"></a>90. 说说RTTI？</h3><p><strong>运行时类型识别（Run-time type identification , RTTI）</strong>，是指在只有一个指向基类的指针或引用时，确定所指对象的准确类型的操作。其常被说成是C++的四大扩展之一（其他三个为异常、模板和名字空间）。使用RTTI有两种方法：</p><p>1、typeid()</p><p>第一种就像sizeof()，它看上像一个函数，但实际上它是由编译器实现的。typeid()带有一个参数，它可以是一个对象引用或指针，返回全局typeinfo类的常量对象的一个引用。可以用运算符“= =”和“!=”来互相比较这些对象，也可以用name()来获得类型的名称。同时，我们也可以用typeid 检查基本类型和非多态类型。如果想知道一个指针所指对象的精确类型，我们必须逆向引用这个指针。比如：</p><p>2、dynamic_cast (expression)</p><p>该运算符为强制类型转换符，上文第49条有提及</p><h3 id="91-多继承的优缺点，作为一个开发者怎么看待多继承？"><a href="#91-多继承的优缺点，作为一个开发者怎么看待多继承？" class="headerlink" title="91. 多继承的优缺点，作为一个开发者怎么看待多继承？"></a>91. 多继承的优缺点，作为一个开发者怎么看待多继承？</h3><p>多重继承的优点很明显，就是一个对象可以调用多个基类中的接口。多继承容易导致菱形继承问题，虽然可以用虚继承解决该问题，但也会造成内存结构复杂，效率降低，继承体系过于复杂化的缺点。</p><h3 id="92-为什么拷贝构造函数必须传引用不能传值？"><a href="#92-为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="92. 为什么拷贝构造函数必须传引用不能传值？"></a>92. 为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数的作用就是用来拷贝对象的，使用一个已存在的对象来初始化一个新的对象。如果使用传值方式，那么在拷贝构造函数被调用时，<strong>在进行参数传递的时候就会调用拷贝构造函数，这样会导致递归溢出。</strong></p><h3 id="93-为什么在C-C-中要将代码分为头文件和源文件，不能写到一起吗？"><a href="#93-为什么在C-C-中要将代码分为头文件和源文件，不能写到一起吗？" class="headerlink" title="93. 为什么在C/C++中要将代码分为头文件和源文件，不能写到一起吗？"></a>93. 为什么在C/C++中要将代码分为头文件和源文件，不能写到一起吗？</h3><p>(1) <strong>将所有代码写入一个文件中当然可以，同样可以通过编译且正常运行</strong>。</p><p>(2) <strong>分开写的目的是方便未来。</strong>有时候我们写的代码会给别人去用，如果是非开源代码，可以将源文件封装起来并生成库文件（<strong>库文件是二进制文件，无法查阅代码</strong>）。只对外开放头文件和库文件，那么别人就无法看到代码的具体实现了。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="1-auto、decltype的用法？"><a href="#1-auto、decltype的用法？" class="headerlink" title="1. auto、decltype的用法？"></a>1. auto、decltype的用法？</h3><p>(1) auto：C++11引入了auto类型说明符，它可以让编译器通过初始值来进行类型推演，使得程序员无需知道类型名称就可以定义变量，所以auto 定义的变量必须有初始值。</p><p>(2) decltype: auto定义的变量必须初始化，如果我们不想要初始化就可以使用decltype，它会返回参数的数据类型，并定义新的变量，而且新变量的值不会被初始化。</p><h3 id="2-C-中NULL和nullptr的区别？"><a href="#2-C-中NULL和nullptr的区别？" class="headerlink" title="2. C++中NULL和nullptr的区别？"></a>2. C++中NULL和nullptr的区别？</h3><p>(1) NULL是一个宏定义，C中NULL为（void*)0，C++中NULL为整数0。</p><p>(2) 将NULL定义为0带来的一个问题是无法与整数的0区分，因为C++中允许有函数重载，若是有个a、b两个重载函数，参数分别为整数和指针，那么在传入NULL参数时，会把NULL当做整数0来看，导致错误调用了参数为整数的函数。</p><p>(3) nullptr可以解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p><h3 id="3-说说final和override关键字？"><a href="#3-说说final和override关键字？" class="headerlink" title="3. 说说final和override关键字？"></a>3. 说说final和override关键字？</h3><p>(1) Override指定了子类的这个虚函数是对父类虚函数的重写，如果函数名不小心打错了的话，编译器会进行报错。</p><p>(2) 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后如果被继承或重写，编译器会报错。</p><p>举例：</p><p>在C++中，<code>final</code> 和 <code>override</code> 是两个非常有用的关键字，它们主要用于类和成员函数的继承。</p><ol><li><code>final</code> 关键字可以用于阻止类的进一步继承，或者阻止虚函数的进一步覆盖。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;   <span class="comment">// 这个类不能被继承</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;   <span class="comment">// 这个函数不能被子类覆盖</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>override</code> 关键字用于明确表示一个虚函数覆盖了基类中的虚函数。这有助于编译器检查我们的代码，如果基类中没有对应的虚函数，使用 <code>override</code> 将导致编译错误。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;   <span class="comment">// 明确表示这个函数覆盖了基类的虚函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是 <code>final</code> 和 <code>override</code> 在C++中的基本用法。这两个关键字都可以帮助我们编写出更清晰、更安全的代码。</p><h3 id="4-C-中的智能指针？"><a href="#4-C-中的智能指针？" class="headerlink" title="4. C++中的智能指针？"></a>4. C++中的智能指针？</h3><p>(1) 智能指针会管理程序员申请的内存，在使用结束后会自动释放，防止堆内存泄漏。</p><p>(2) <strong>auto_ptr：</strong>最原始的智能指针。auto_ptr采用的是<strong>独享所有权语义</strong>，一个非空的auto_ptr总是拥有它所指向的资源，转移一个auto_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空。由于支持拷贝语义，拷贝后源对象变得无效，如果程序员忽视了这点，这可能引发很严重的问题。<strong>在C++11中该指针已被弃用</strong>。</p><p>(3) <strong>unique_ptr：</strong>与auto_ptr类似，采用<strong>独享所有权语义</strong>。<strong>unique_ptr提供移动语义</strong>，这在很大程度上避免了auto_ptr的错误，因为很明显必须使用std::move()进行转移，提醒程序员在这个地方发生了移动。</p><p>(4) <strong>shared_ptr：</strong>采用<strong>引用计数器</strong>的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。引用计数器的变化依据如下所示。</p><p>①　每次创建类的新对象时，初始化指针并将引用计数置为1</p><p>②　当对象作为另一对象的副本而创建时，拷贝构造函数会拷贝指针并增加与之相应的引用计数</p><p>③　对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</p><p>④　调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</p><p>(5) <strong>weak_ptr：</strong> 由于shared_ptr引用计数存在的问题，即互相引用形成环（环形引用），使得两个指针指向的内存都无法释放，如下所示。</p><p>①　为了解决这个问题，C++引入了weak_ptr(弱引用)，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，<strong>它只引用，不计数</strong>。</p><p>②　如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。</p><p>③　weak_ptr不保证它指向的内存一定是有效的，在使用之前应先检查weak_ptr是否为空指针，避免访问非法内存，也因此weak_ptr并不能直接访问对象，他只能通过转化为shared_ptr来使用对象。</p><blockquote><p><strong>share_ptr手写</strong></p></blockquote><p><strong>share_ptr-double free问题</strong>：double free 问题就是一块内存空间或者资源被释放两次。</p><p>double free 可能是下面这些原因造成的：</p><ul><li>直接使用原始指针创建多个 shared_ptr，而没有使用 shared_ptr 的 make_shared 工厂函数，从而导致多个独立的引用计数。</li><li>循环引用，即两个或多个 shared_ptr 互相引用，导致引用计数永远无法降为零，从而无法释放内存。</li></ul><p>case1:举例</p><p>在C++中，std::shared_ptr 是一个智能指针，它可以自动管理对象的生命周期。它通过引用计数来确保当没有任何 shared_ptr 指向一个对象时，该对象会被自动删除。</p><p>然而，直接使用原始指针创建多个 shared_ptr，而没有使用 shared_ptr 的 make_shared 工厂函数，可能会导致多个独立的引用计数，进而导致double-free的问题。</p><p>下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// 创建一个原始指针指向一个新的int对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个独立的shared_ptr，它们都指向同一个对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当sp1和sp2离开其作用域时，它们都会试图删除同一个对象，导致double-free的问题</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了两个独立的 shared_ptr，它们都指向同一个对象。当它们离开其作用域时，它们都会试图删除同一个对象，导致double-free的问题。</p><p>正确的做法是使用 make_shared 工厂函数来创建 shared_ptr，或者只使用一个原始指针来初始化一个 shared_ptr，然后使用这个 shared_ptr 来初始化其他的 shared_ptr。这样，所有的 shared_ptr 都会共享同一个引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 使用原始指针初始化一个shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">// 使用sp1初始化sp2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 使用make_shared创建一个shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">// 使用sp1初始化sp2</span></span><br></pre></td></tr></table></figure><p>在上述正确的做法中，所有的 shared_ptr 都会共享同一个引用计数，因此不会出现double-free的问题。</p><p>case2:</p><p>循环引用问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;b_ptr = b; <span class="comment">// A 指向 B</span></span><br><span class="line">        b-&gt;a_ptr = a; <span class="comment">// B 指向 A</span></span><br><span class="line">    &#125; <span class="comment">// a 和 b 离开作用域，但由于循环引用，它们的析构函数不会被调用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用weak_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 替代 shared_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;b_ptr = b; <span class="comment">// A 指向 B</span></span><br><span class="line">        b-&gt;a_ptr = a; <span class="comment">// B 对 A 使用 weak_ptr</span></span><br><span class="line">    &#125; <span class="comment">// a 和 b 离开作用域，它们的析构函数会被正确调用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enable_shared_from_this</strong><br>从名字可以看出几个关键词：enable: 允许 shared 指 shared_ptr, from_this 则是指从类自身this 构造 shared_ptr。</p><p>想象这样一个场景:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这段代码需要在NeedCallSomeAPI函数中调用SomeAPI，而SomeAPI需要的是一个std::shared_ptr的实参。这个时候应该怎么做？ 这样吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的做法是错误的，因为SomeAPI调用结束后std::shared_ptr对象的引用计数会降为0，导致 this 被意外释放。</p><p>这种情况下，我们需要使用std::enable_shared_from_this ，使用方法很简单，只需要让SomeData继承std::enable_shared_from_this，然后调用shared_from_this，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> shared_ptr&lt;st&gt; &amp;d)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span> : enable_shared_from_this&lt;st&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;st&gt; <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;st&gt;(<span class="keyword">new</span> st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">66</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> shared_ptr&lt;st&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; d-&gt;num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = st::<span class="built_in">New</span>();</span><br><span class="line">    p-&gt;<span class="built_in">f1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，当下面👇这些场景用到 shared_ptr 时，需要搭配上 enable_shared_from_this:</p><ul><li>当你需要将this指针传递给其他函数或方法，而这些函数或方法需要一个std::shared_ptr，而不是裸指针。</li><li>当你需要在类的成员函数内部创建指向当前对象的std::shared_ptr，例如在回调函数或事件处理中。</li></ul><p>手敲智能指针是面试常见的题目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr), count_(ptr ? new size_t(<span class="number">1</span>) : nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr_</span>(other.ptr_), <span class="built_in">count_</span>(other.count_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count_) &#123;</span><br><span class="line">            ++(*count_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr_ = other.ptr_;</span><br><span class="line">            count_ = other.count_;</span><br><span class="line">            <span class="keyword">if</span> (count_) &#123;</span><br><span class="line">                ++(*count_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_ ? *count_ : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count_ &amp;&amp; --(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* ptr_;</span><br><span class="line">    <span class="type">size_t</span>* count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass 构造函数\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass 析构函数\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyClass::do_something() 被调用\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SimpleSharedPtr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            SimpleSharedPtr&lt;MyClass&gt; ptr2 = ptr1;</span><br><span class="line">            ptr1-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">            ptr2-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr">https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr</a></li></ul><h3 id="5-说说STL容器中的智能指针？"><a href="#5-说说STL容器中的智能指针？" class="headerlink" title="5. 说说STL容器中的智能指针？"></a>5. 说说STL容器中的智能指针？</h3><p>具备<strong>独占所有权语义</strong>的智能指针不能在STL的容器中使用，如auto_ptr和unique_ptr，因为STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，容易导致错误，而unique_ptr又不支持普通的拷贝和赋值操作，也不能用在STL标准容器中。</p><h3 id="6-说说lambda函数？"><a href="#6-说说lambda函数？" class="headerlink" title="6. 说说lambda函数？"></a>6. 说说lambda函数？</h3><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象。每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，该实例是一个右值。lambda的优点有以下几点：</p><p>(1) <strong>距离</strong>：很多人认为，让定义位于使用的地方附近很有用。这样，就无需翻阅很多页的源代码，以了解函数。另外，如果需要修改代码，设计的内容就在附近，就很好修改。</p><p>(2) <strong>简洁</strong>：函数符代码要比lambda代码更加繁琐，函数和lambda的简洁程度相当。</p><p>(3) <strong>功能</strong>：lambda可以访问作用域内的任何动态变量，可以采用取值、引用的形式进行捕获。</p><h3 id="7-什么是声明时初始化？"><a href="#7-什么是声明时初始化？" class="headerlink" title="7. 什么是声明时初始化？"></a>7. 什么是声明时初始化？</h3><p>C++11新增了<strong>类成员初始化新机制</strong>——声明时初始化，可以直接在类中声明数据成员时就进行初始化操作，而不用借助构造函数或者初始化列表。</p><h3 id="8-C-11添加哪几种构造函数关键字？"><a href="#8-C-11添加哪几种构造函数关键字？" class="headerlink" title="8. C++11添加哪几种构造函数关键字？"></a>8. C++11添加哪几种构造函数关键字？</h3><p>(1) default关键字可以显式要求编译器生成默认构造函数，防止在调用时相关构造函数没有定义而报错。</p><p>(2) delete关键字可以删除构造函数、赋值运算符函数等，在使用时编译器会报错</p><h3 id="9-说说C-的左值和右值？"><a href="#9-说说C-的左值和右值？" class="headerlink" title="9. 说说C++的左值和右值？"></a>9. 说说C++的左值和右值？</h3><p>(1) 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。</p><p>(2) 在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p><p>(3) 纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和字面量值；将亡值则是C++11新增的新右值，它表示该对象的内存空间接下来会被其他对象接管。通过这种接管空间的方式可以避免内存空间的释放和分配，延长变量值的生命期。</p><p>(4) C++11对于引用了也有了新的解释。传统的C++引用被称为<strong>左值引用</strong>，符号为&amp;，他关联的是左值。C++11中增加了<strong>右值引用</strong>，符号为&amp;&amp;。<strong>右值引用会关联到右值</strong>，右值被存储到特定位置，右值引用会指向该特定位置，也就是说，<strong>右值虽然无法获取地址，但是右值引用是可以获取地址的</strong>，该地址表示临时对象的存储位置。使用std::move可以使一个左值转换为右值引用。</p><h3 id="10-说说移动构造函数？"><a href="#10-说说移动构造函数？" class="headerlink" title="10. 说说移动构造函数？"></a>10. 说说移动构造函数？</h3><p>(1) 移动构造是C++11标准中提供的一种新的构造方法，用来给予程序员新的构造选择，用以替换拷贝构造。</p><p>(2) 拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，拷贝的内存越大越耗费时间，并且进行了深拷贝，就需要给对象分配地址空间。</p><p>(3) 移动构造函数会直接接管源对象空间，既不会产生额外的拷贝开销，也不会给新对象分配内存空间。提高程序的执行效率，节省内存消耗。</p><p>(4) 移动构造函数的参数必须是<strong>自身类型的右值引用</strong>，也就是说能调用移动构造函数的参数必然是个右值（纯右值和将亡值）。</p><h3 id="11-什么是列表初始化？"><a href="#11-什么是列表初始化？" class="headerlink" title="11. 什么是列表初始化？"></a>11. 什么是列表初始化？</h3><p>列表初始化是C++ 11新引进的初始化方式，它采用一对花括号（即<strong>｛｝</strong>）进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化。</p><h3 id="12-初始化列表和列表初始化的区别？"><a href="#12-初始化列表和列表初始化的区别？" class="headerlink" title="12.初始化列表和列表初始化的区别？"></a>12.初始化列表和列表初始化的区别？</h3><p>(1) 初始化列表是在创建类对象时，对类对象内部的数据成员进行的一种初始化方式，具体用在类的构造函数中。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="1-什么是STL？"><a href="#1-什么是STL？" class="headerlink" title="1.什么是STL？"></a>1.什么是STL？</h3><p>Standard Template Library（标准模板库），是C++的标准库之一，它是一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。STL包含6大部件：<strong>容器、迭代器、算法、仿函数、适配器和空间配置器</strong>。</p><h3 id="2-SGI的二级空间配置器了解吗？"><a href="#2-SGI的二级空间配置器了解吗？" class="headerlink" title="2.SGI的二级空间配置器了解吗？"></a>2.SGI的二级空间配置器了解吗？</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/331809729">5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码</a></li><li><a href="https://blog.csdn.net/xiajun07061225/article/details/8807890">【STL深入学习】SGI STL空间配置器详解（二）-第二级空间配置器</a></li></ul><p>(1) 对象构造前的空间配置和对象析构后的空间释放，由<stl_alloc.h>负责，SGI设计了<strong>双层级配置器</strong>：</p><p>①　第一级空间配置器直接使用malloc和free，如果在申请动态内存时找不到足够大的内存块，将返回NULL 指针，宣告内存申请失败。</p><p>②　第二级空间配置器视情况使用不同的策略，当申请内存大于128字节时，调用第一级配置器。当申请内存小于128b字节时，采用内存池方式，维护16个（128/8）自由链表，每个链表维护8字节大小的内存块，从中进行内存分配，如果内存不足转第一级配置器处理。</p><p>(2) <strong>二级空间配置器存在的问题</strong>：</p><p>①　自由链表所挂区块都是8的整数倍，因此当我们需要非8倍数的区块，往往会导致浪费。</p><p>②　由于配置器的链表都是静态变量，他们存放在全局/静态区，其释放时机就是程序结束，这样子会导致自由链表一直占用内存。</p><h3 id="3-traits技法"><a href="#3-traits技法" class="headerlink" title="3.traits技法?"></a>3.traits技法?</h3><p>入门案例：</p><p>在C++中，traits（特性）是一种常用的技术，主要用于在编译期间获取类型的信息。通过traits，我们可以编写出更加通用、灵活的代码。</p><p>下面是一个简单的traits的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个traits模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTraits</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，我们假设类型T不是一个指针</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_pointer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针类型进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTraits</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="comment">// 对于指针类型，我们设定is_pointer为true</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_pointer = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MyTraits&lt;<span class="type">int</span>&gt;::is_pointer &lt;&lt; endl;  <span class="comment">// 输出0，表示int不是指针</span></span><br><span class="line">    cout &lt;&lt; MyTraits&lt;<span class="type">int</span>*&gt;::is_pointer &lt;&lt; endl; <span class="comment">// 输出1，表示int*是指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们定义了一个名为 <code>MyTraits</code> 的模板，并对指针类型进行了特化。通过 <code>MyTraits</code>，我们可以在编译期间判断一个类型是否是指针类型。</p><p>除了这个简单的例子，traits还有很多其他的应用，例如获取一个类型的大小、判断一个类型是否是const类型、获取一个容器的迭代器类型等等。通过traits，我们可以更好地抽象和封装代码，提高代码的复用性和灵活性。</p><h3 id="4-说说STL中的容器？"><a href="#4-说说STL中的容器？" class="headerlink" title="4.说说STL中的容器？"></a>4.说说STL中的容器？</h3><p>(1) <strong>vector</strong></p><p>①　vector底层是一个动态数组，包含三个迭代器：start、finish、end_of_storage。start和finish之间是已经被使用的空间范围，表示当前vector中有多少个元素，即有效空间size。start和end_of_storage是整块连续空间包括备用空间的大小，表示它分配的内存中可以容纳多少元素，即容量capacity。</p><p>②　<strong>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍）</strong>，然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间。之所以是1.5倍或者2倍，是因为考虑到可能产生的堆空间浪费，增长倍数不能太大，使用1.5或者2是比较合理的倍数。</p><p>③　当释放或者删除（vec.clear()）里面的数据时，其<strong>存储空间不释放</strong>，仅仅是清空了里面的数据。</p><p>④　对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器都会失效。</p><p>⑤　reserve函数的作用：将vector直接扩充到确定的大小，可以减少多次开辟和释放空间的效率问题（优化push_back），还可以减少拷贝数据的次数，<strong>它直接更改capacity</strong>。</p><p>⑥　resize()函数的作用：<strong>可以改变vector有效空间的大小，即size的大小</strong>。如果size大于capacity，capacity的大小也会随着改变。</p><p>⑦　vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此<strong>vector的元素类型不能是引用</strong>。</p><p>⑧　当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。<strong>erase方法会返回下一个有效的迭代器</strong>。</p><p>⑨　释放vector内存的方法：</p><p><strong>vec.clear()：</strong>清空内容，但是不释放内存。</p><p><strong>vector().swap(vec)：</strong>清空内容，且释放内存，想得到一个全新的vector。</p><p><strong>vec.shrink_to_fit()：</strong>请求容器降低其capacity和size匹配。</p><p><strong>vec.clear();vec.shrink_to_fit();：</strong>清空内容，且释放内存。</p><p>(2) <strong>List</strong></p><p>①　list的底层是一个双向链表，以结点为单位存放数据，<strong>结点的地址在内存中不一定连续</strong>，每次插入或删除一个元素，就配置或释放一个元素空间。</p><p>②　list不支持随机存取，如果需要大量的插入和删除，而不关心随机存取，则可以使用list。</p><p>(3) <strong>Deque</strong></p><p>①　deque的是一个<strong>双向开口的连续线性空间（双端队列）</strong>，在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</p><p>②　deque的底层并不是真正连续的空间，而是由一段段连续的小空间拼接而成，实际<strong>deque类似于一个动态的二维数组</strong>，由一个map（中控指针数组）和多个连续的缓冲区组成。</p><p>③　当deque不断增加元素时，一旦map（中控指针数组）满了，那么会增容，不过<strong>map增容的代价非常低，因为只需要拷贝存储数据的buffer数组的指针，不需要拷贝buffer中的内容</strong>。</p><p>④　双端队列底层是一段假象的连续空间，实际是<strong>分段连续</strong>的，为了维护其“整体连续”以及随机访问的假象，deque的迭代器设计就比较复杂。<strong>由cur、first、last指向当前遍历buffer数组，node指向map中的元素</strong>，遍历deque的操作由这几个指针进行维护。</p><p>⑤　deque并不是从map的第一个位置就开始存放元素，而是从中间开始存放，这样在头部和尾部插入元素就会变得容易。</p><p>⑥　与vector比较：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。</p><p>⑦　与list比较：其底层是连续空间，空间利用率比较高，不需要存储额外字段。</p><p>⑧　不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下。不适合大量的中间插入删除，也不适合大量的随机访问。</p><p>(4) <strong>map 、set、multiset、multimap</strong></p><p>①　底层数据结构都是红黑树，是一种自平衡的二叉搜索树</p><p>②　set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。</p><p>③　map和multimap将key和value组成的键值对作为元素，根据key的排序准则自动将元素排序，map中元素的key不允许重复，multimap可以重复。</p><p>④　map和set的增删改查速度为都是logn，是比较高效的。</p><p>⑤　map和set的插入删除效率比序列容器高，而且每次insert之后，以前保存的iterator不会失效。因为存储的是结点，不需要内存拷贝和内存移动。</p><p>(5) <strong>unordered_map、unordered_set</strong></p><p>①　底层数据结构是一个防冗余的哈希表（采用除留余数法）。其数据的存储和查找的效率很高，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。</p><p>②　使用开链法解决哈希冲突。</p><p>③　数据的存放是无序的</p><h3 id="5-什么是STL的顺序容器和关联式容器？"><a href="#5-什么是STL的顺序容器和关联式容器？" class="headerlink" title="5. 什么是STL的顺序容器和关联式容器？"></a>5. 什么是STL的顺序容器和关联式容器？</h3><p>(1) 关联容器(Associative Container)与顺序容器(Sequential Container)的本质区别在于：<strong>关联容器是通过键(key)存储和读取元素的，而顺序容器则通过元素在容器中的位置顺序存储和访问元素</strong>。</p><p>(2) 在STL中，这里的“顺序”和“关联”指的是<strong>上层接口表现出来的访问方式</strong>，并非底层存储方式。为什么这样划分呢？因为对STL的用户来说，他们并不需要知道容器的底层实现机制，只要知道如何通过上层接口访问容器元素就可以了，否则违背了泛型容器设计的初衷。</p><p>(3) 顺序容器主要采用向量和链表及其组合作为基本存储结构，如堆栈和各种队列。而关联式容器采用平衡二叉搜索树作为底层存储结构。</p><h3 id="6-说说STL的容器适配器？"><a href="#6-说说STL的容器适配器？" class="headerlink" title="6. 说说STL的容器适配器？"></a>6. 说说STL的容器适配器？</h3><p>容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现都是通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。</p><p>(1) <strong>stack</strong></p><p>①　stack（栈）是一种<strong>先进后出（First In Last Out）</strong>的数据结构，只有一个出入口，那就是栈顶，除了对栈顶元素进行操作外，没有其他方法可以操作内部的其他元素。</p><p>②　C++的栈是一种<strong>容器适配器</strong>，其底层数据结构一般用<strong>list或deque</strong>实现，只开放一部分的接口和方法即可完成对栈的支持。</p><p>(2) <strong>queue</strong></p><p>①　queue（队列）是一种<strong>先进先出（First In First Out）</strong>的数据结构，只有一个入口和一个出口，分别位于队头与队尾，只能在队尾插入元素，在队头取出元素，没有其他方法可以操作内部的其他元素。</p><p>②　C++的队列是一种<strong>容器适配器</strong>，其底层数据结构一般用<strong>list或deque</strong>实现，只开放一部分的接口和方法即可完成对队列的支持。</p><p>(3) <strong>priority_queue</strong></p><p>①　priority_queue，优先级队列，是一个<strong>拥有权值观念的queue</strong>，它跟queue一样只能在队尾插入元素，在队头取出元素。在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面。</p><p>②　priority queue（优先队列）的底层实现机制实际上是<strong>堆</strong>，因为大根堆总是最大值位于堆的根部，优先级最高。</p><p>③　C++中的堆是容器适配器，一般是vector为底层容器，以堆的处理规则来进行管理。</p><h3 id="7-说说STL的迭代器？"><a href="#7-说说STL的迭代器？" class="headerlink" title="7. 说说STL的迭代器？"></a>7. 说说STL的迭代器？</h3><p>(1) <strong>迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。</strong></p><p>(2) 在遍历容器的时候，不可避免的要对遍历的容器内部有所了解，所以，干脆把迭代器的开发工作交给容器的设计者好了，如此以来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种 STL 容器都提供有专属迭代器的缘故。</p><p>(3) 迭代器种类分为5类：</p><p>①　<strong>输入迭代器：</strong>是只读迭代器，在每个被遍历的位置上只能读取一次。</p><p>②　<strong>输出迭代器：</strong>是只写迭代器，在每个被遍历的位置上只能被写一次。</p><p>③　<strong>前向迭代器：</strong>兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持operator–，所以只能向前移动。</p><p>④　<strong>双向迭代器：</strong>很像前向迭代器，只是它向后移动和向前移动同样容易。</p><p>⑤　<strong>随机访问迭代器：</strong>有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置， 包含指针的所有操作，可进行随机访问，随意移动指定的步数。</p><p>(5) 通过traits技法，我们可以获取到迭代器一些特性，STL规定，每一个迭代器至少包含以下几种特性供外界获取，方便算法使用迭代器。</p><p>①　<strong>value_type：</strong>迭代器所指对象的类型</p><p>②　<strong>difference_type：</strong>两个迭代器之间的距离</p><p>③　<strong>pointer：</strong>迭代器所指对象的指针类型</p><p>④　<strong>reference：</strong>迭代器所指对象的引用类型</p><p>⑤　<strong>iterator_category：</strong>迭代器种类</p><p>(6) 迭代器失效问题</p><p>①　<strong>数组型数据结构（vector）：</strong>该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert( <em> iter)(或erase( </em> iter))，然后再iter++，是没有意义的。解决方法：erase( * iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter)。</p><p>②　<strong>链表型数据结构：</strong>对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase( * iter)会返回下一个有效迭代器的值，或者erase(iter++)。</p><p>③　<strong>树形数据结构：</strong> 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p><p>④　<strong>Deque：</strong>插入头尾会使<strong>迭代器全部失效但是引用不失效</strong>。其原因在于插入头尾可能会进行扩容，由于map的重新分配，迭代器的node失效，但是原map指向的连续数组并没有重新分配。因此，对整个迭代器来说是失效的，但对于元素的指针和引用仍然是有效的。<strong>删除头尾会使被删除的元素迭代器和引用失效，插入和删除中间会使迭代器和引用全部失效。</strong></p><p>⑤　<strong>unodered_map/unordered_set：</strong>由于底层是哈希表，迭代器是否失效主要看哈希表的实现策略，对于使用<strong>除留余数法和开链法</strong>的哈希表来说，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p><h3 id="8-说说STL容器的线程安全性？"><a href="#8-说说STL容器的线程安全性？" class="headerlink" title="8. 说说STL容器的线程安全性？"></a>8. 说说STL容器的线程安全性？</h3><p><strong>STL只保证最低限度的线程安全性，即：</strong>多个读者是安全的，多线程可以同时读取一个容器的内容，但如果有多个写者，则必须使用同步互斥机制保证线程安全。</p><h3 id="9-STL容器的使用场景？"><a href="#9-STL容器的使用场景？" class="headerlink" title="9. STL容器的使用场景？"></a>9. STL容器的使用场景？</h3><p>(1) vector的使用场景：只查看，而不频繁插入删除的</p><p>(2) deque的使用场景：头尾需要频繁插入删除</p><p>(3) list的使用场景：频繁的插入删除的场景，且位置不固定</p><p>(4) Set：针对单一值的增删查改操作都要有，且要求数据有序</p><p>(5) Map：针对键值对的增删查改操作都要有，且要求数据有序</p><p>(6) unordered_set：针对单一值的增删查改操作都要有，数据排列无要求。</p><p>(7) unordered_map：针对键值对的增删查改操作都要有，数据排列无要求。</p>]]></content>
    
    
    <summary type="html">Cpp基础部分</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>tinyxml库</title>
    <link href="https://penge666.github.io/posts/60c6b3ce.html"/>
    <id>https://penge666.github.io/posts/60c6b3ce.html</id>
    <published>2024-05-13T08:58:25.000Z</published>
    <updated>2024-05-18T13:03:53.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tinyxml库">Tinyxml库</h2><p>许多公司常常使用XML文件保存信息，因此，需要使用专门XML库获取数据。</p><blockquote><p>常用的XML库</p></blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fwww.libexpat.org%2F">Expat</a> ：用C语言编写的xml解析库</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fxmlsoft.org%2F">Libxml2</a> ：Gnome的xml C解析器和工具包</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flibxmlplusplus.sourceforge.net%2F">libxml++</a> ：C++的xml解析器</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fpugixml.org%2F">PugiXML</a> ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Frapidxml.sourceforge.net%2F">RapidXml</a> ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fsourceforge.net%2Fprojects%2Ftinyxml%2F">TinyXML</a> ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Fleethomason%2Ftinyxml2">TinyXML2</a>：简单快速的C++CML解析器，可以很容易集成到其它项目中。</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fcode.google.com%2Fp%2Fticpp%2F">TinyXML++</a>：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fxerces.apache.org%2Fxerces-c%2F">Xerces-C++</a> ：用可移植的C++的子集编写的XML验证解析器。</p><blockquote><p>介绍</p></blockquote><p>XML 全称为可扩展标记语言（eXtensible Markup Language），是一种用于标记电子文件结构以便存储、传输和展现数据的标记语言。XML 被设计用来传输和存储数据，而不是用来显示数据的。</p><p>XML 的解析方式分为四种：1、DOM 解析；2、SAX 解析；3、JDOM 解析；4、DOM4J 解析。其中前两种属于基础方法，是官方提供的平台无关的解析方式；后两种属于扩展方法，它们是在基础的方法上扩展出来的，只适用于 Java 平台。</p><p><strong>DOM 解析</strong></p><p><strong>DOM 的全称是 Document Object Model，即文档对象模型</strong>。在应用程序中，<strong>基于 DOM 的 XML 分析器将一个 XML 文档转换成一个对象模型的集合（通常称 DOM 树）</strong>，<strong>应用程序正是通过对这个对象模型的操作，来实现对 XML 文档数据的操作</strong>。通过 DOM 接口，应用程序可以在任何时候访问 XML 文档中的任何一部分数据，因此，这种利用 DOM 接口的机制也被称作随机访问机制。</p><p>DOM 接口提供了一种通过分层对象模型来访问 XML 文档信息的方式，这些分层对象模型依据 XML 的文档结构形成了一棵节点树。无论 XML 文档中所描述的是什么类型的信息，即便是制表数据、项目列表或一个文档，利用 DOM 所生成的模型都是节点树的形式。也就是说，DOM 强制使用树模型来访问 XML 文档中的信息。由于 XML 本质上就是一种分层结构，所以这种描述方法是相当有效的。</p><p>DOM 树所提供的随机访问方式给应用程序的开发带来了很大的灵活性，它可以任意地控制整个 XML 文档中的内容。然而，由于 DOM 分析器把整个 XML 文档转化成 DOM 树放在了内存中，因此，当文档比较大或者结构比较复杂时，对内存的需求就比较高。而且，对于结构复杂的树的遍历也是一项耗时的操作。所以，DOM 分析器对机器性能的要求比较高，实现效率不十分理想。不过，由于 DOM 分析器所采用的树结构的思想与 XML 文档的结构相吻合，同时鉴于随机访问所带来的方便，因此，DOM 分析器还是有很广泛的使用价值的。</p><blockquote><p><strong>优点：</strong></p></blockquote><ul><li><strong>形成了树结构，有助于更好的理解、掌握，且代码容易编写。</strong></li><li><strong>解析过程中，树结构保存在内存中，方便修改。</strong></li></ul><blockquote><p><strong>缺点：</strong></p></blockquote><ul><li><strong>由于文件是一次性读取，所以对内存的耗费比较大。</strong></li><li><strong>如果XML文件比较大，容易影响解析性能且可能会造成内存溢出。</strong></li></ul><p><a href="https://blog.csdn.net/wei78008023/article/details/44940579">XML解析和Json解析简介以及两者的区别</a></p><h2 id="准备工作">准备工作</h2><p>首先看一下XML文件的组成部分：</p><p>xml主要是由两部分组成，<strong>头部信息</strong> 和 <strong>节点</strong></p><p>细分下来，头部信息就是开头这一串东西：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</code></p><p>节点是：根节点、子节点、属性三部分。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518204145695.png" alt="image-20240518204145695"></p><p>一个完整的xml文件由图中部分组成！</p><p>头部信息：这个是xml文件必须要有的一段描述语句；</p><p>根节点：xml文件由只有一个根节点（仅有），它是所有子节点的父节点；</p><p>子节点：可有多个，必须在根节点内；</p><p>属性：存储数据的一种方式。</p><p>下载链接：<a href="https://sourceforge.net/projects/tinyxml/">https://sourceforge.net/projects/tinyxml/</a></p><p>在Linux环境下，我直接放在XMLParse下，共四个文件。要用直接导入头文件即可。</p><h2 id="创建">创建</h2><p>创建一个xml文件，并为其插入头部信息 和 跟、子节点。</p><h3 id="创建一个XML类">创建一个XML类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TiXmlDocument* tinyXmlDoc = new TiXmlDocument();</span><br></pre></td></tr></table></figure><h3 id="创建头部信息">创建头部信息</h3><p>并插入到xml类中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xml的声明(三个属性：版本，编码格式，保留空串即可)</span></span><br><span class="line">TiXmlDeclaration* tinyXmlDeclare = <span class="keyword">new</span> <span class="built_in">TiXmlDeclaration</span>(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">// 声明头部格式</span></span><br><span class="line"><span class="comment">// 插入文档类中</span></span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">LinkEndChild</span>(tinyXmlDeclare);</span><br></pre></td></tr></table></figure><p>即上图头部信息</p><h3 id="创建根节点">创建根节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时需要指定根节点的名称</span></span><br><span class="line">TiXmlElement* Library = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Library&quot;</span>);</span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">LinkEndChild</span>(Library);<span class="comment">// 把根节点插入到文档类中</span></span><br></pre></td></tr></table></figure><p>即上图Library</p><h3 id="添加子节点">添加子节点</h3><p>首先创建一个子节点，然后新建一个文本，将文本添加到子节点中，最后将字节点添加到根节点中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TiXmlElement *Book = new TiXmlElement(<span class="string">&quot;Book&quot;</span>);</span><br><span class="line">TiXmlText *bookText = new TiXmlText(<span class="string">&quot;书本&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Book-&gt;LinkEndChild(bookText);<span class="comment">// 给Book节点添加文本</span></span><br><span class="line">Library-&gt;LinkEndChild(Book);<span class="comment">// 插入到根节点下</span></span><br></pre></td></tr></table></figure><h3 id="添加带属性的子节点">添加带属性的子节点</h3><p>使用setAttribute可以简单的给节点添加属性值；<br>如果要创建子节点的子节点，就跟创建子节点一样，只是创建好后要添加到子节点中即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TiXmlElement *Book1 = new TiXmlElement(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="comment">// 插入属性</span></span><br><span class="line">Book1-&gt;SetAttribute(<span class="string">&quot;ID&quot;</span>, <span class="number">1</span>);</span><br><span class="line">Book1-&gt;SetAttribute(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;水浒传&quot;</span>);</span><br><span class="line">Book1-&gt;SetAttribute(<span class="string">&quot;Price&quot;</span>, <span class="string">&quot;64.6&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Description</span></span><br><span class="line">TiXmlElement *Description = new TiXmlElement(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line">TiXmlText *descriptionText = new TiXmlText(<span class="string">&quot;108个拆迁户&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Description-&gt;LinkEndChild(descriptionText);<span class="comment">// 给Description节点添加文本</span></span><br><span class="line">Book1-&gt;LinkEndChild(Description);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Page</span></span><br><span class="line">TiXmlElement *Page = new TiXmlElement(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line">TiXmlText *pageText = new TiXmlText(<span class="string">&quot;100页&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Page-&gt;LinkEndChild(pageText);<span class="comment">// 给Page节点添加文本</span></span><br><span class="line">Book1-&gt;LinkEndChild(Page);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line">Library-&gt;LinkEndChild(Book1);<span class="comment">// 插入到根节点下</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518204707541.png" alt="image-20240518204707541"></p><h3 id="将doc写入xml文件">将doc写入xml文件</h3><p>只需使用文档类调用SaveFile方法即可，参数传文件名</p><p>写入成功返回true，写入失败返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> result = tinyXmlDoc-&gt;<span class="built_in">SaveFile</span>(FILE_NAME);</span><br></pre></td></tr></table></figure><h3 id="转换为字符串">转换为字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TiXmlPrinter printer;</span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">Accept</span>(&amp;printer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, printer.<span class="built_in">CStr</span>());</span><br></pre></td></tr></table></figure><p>如果只是想在控制台打印而已，那么可以直接调用函数<code>tinyXmlDoc-&gt;Print();</code>就可以实现在控制台上打印出来了！</p><h3 id="创建xml文件并插入元素节点">创建xml文件并插入元素节点</h3><p>总代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_XML</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n----- create_XML -----\n&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个xml文件</span></span><br><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = <span class="keyword">new</span> <span class="built_in">TiXmlDocument</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// xml的声明(三个属性：版本，编码格式，保留空串即可)</span></span><br><span class="line">TiXmlDeclaration* tinyXmlDeclare = <span class="keyword">new</span> <span class="built_in">TiXmlDeclaration</span>(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">// 声明头部格式</span></span><br><span class="line"><span class="comment">// 插入文档类中</span></span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">LinkEndChild</span>(tinyXmlDeclare);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根节点</span></span><br><span class="line">TiXmlElement* Library = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Library&quot;</span>);</span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">LinkEndChild</span>(Library);<span class="comment">// 把根节点插入到文档类中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book节点</span></span><br><span class="line">TiXmlElement *Book = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Book&quot;</span>);</span><br><span class="line">TiXmlText *bookText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;书本&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Book-&gt;<span class="built_in">LinkEndChild</span>(bookText);<span class="comment">// 给Book节点添加文本</span></span><br><span class="line">Library-&gt;<span class="built_in">LinkEndChild</span>(Book);<span class="comment">// 插入到根节点下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1节点</span></span><br><span class="line">TiXmlElement *Book1 = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="comment">// 插入属性</span></span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;ID&quot;</span>, <span class="number">1</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;水浒传&quot;</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Price&quot;</span>, <span class="string">&quot;64.6&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Description</span></span><br><span class="line">TiXmlElement *Description = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line">TiXmlText *descriptionText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;108个拆迁户&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Description-&gt;<span class="built_in">LinkEndChild</span>(descriptionText);<span class="comment">// 给Description节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Description);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Page</span></span><br><span class="line">TiXmlElement *Page = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line">TiXmlText *pageText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;100页&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Page-&gt;<span class="built_in">LinkEndChild</span>(pageText);<span class="comment">// 给Page节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Page);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line">Library-&gt;<span class="built_in">LinkEndChild</span>(Book1);<span class="comment">// 插入到根节点下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line"><span class="type">bool</span> result = tinyXmlDoc-&gt;<span class="built_in">SaveFile</span>(FILE_NAME);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;文件写入成功！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;文件写入失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出来看看</span></span><br><span class="line"><span class="comment">//tinyXmlDoc-&gt;Print();</span></span><br><span class="line"></span><br><span class="line">TiXmlPrinter printer;</span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">Accept</span>(&amp;printer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, printer.<span class="built_in">CStr</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加">添加</h2><p>往xml文件中添加节点元素</p><p>例：在上面创建的xml文件基础上，添加两个Book1子节点。</p><h3 id="定义一个xml文件类，并读取文件中的xml内容初始化它">定义一个xml文件类，并读取文件中的xml内容初始化它</h3><p>这里有两种方式，有点奇怪，当使用第一种方式读取xml文件时，xml中有多个子节点Book1时，由于属性都有相同的id、name、price，导致会读取失败，不得已让我搞出了第二种方式去读取进行初始化，这样就没问题！</p><p><strong>方式1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = new TiXmlDocument;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件中的xml</span></span><br><span class="line"><span class="keyword">if</span> (!tinyXmlDoc-&gt;LoadFile(FILE_NAME)) &#123;</span><br><span class="line"><span class="comment">// 读取失败，打印失败原因</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Could not load example xml file %s. Error=&#x27;%s&#x27;\n&quot;</span>, FILE_NAME, tinyXmlDoc-&gt;ErrorDesc());</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式2</strong></p><p>定义xml文档类对象时指定文件名，然后在使用这个对象去调用LoadFile传参TIXML_ENCODING_LEGACY即可，具体传参是什么意思，我</p><p>也不清楚，自己摸索出来的，其中有三个枚举可以选择，其他两个都不行，就这个可以！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义xml文档类对象时指定文件名</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = new TiXmlDocument(FILE_NAME);</span><br><span class="line"><span class="comment">// 然后在使用这个对象去调用LoadFile传参TIXML_ENCODING_LEGACY即可</span></span><br><span class="line">tinyXmlDoc-&gt;LoadFile(TIXML_ENCODING_LEGACY);</span><br></pre></td></tr></table></figure><p>我一般都是，第一种方式用不了，就用第二种方式初始化！</p><p><strong>对已存在的数据进行初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::string data;<span class="comment">// 这里默认data是存储xml数据的字符串变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式一： */</span></span><br><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = <span class="keyword">new</span> <span class="built_in">TiXmlDocument</span>();</span><br><span class="line"><span class="comment">// 数据初始化</span></span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">Parse</span>(data.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式二： */</span></span><br><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = <span class="keyword">new</span> <span class="built_in">TiXmlDocument</span>(data.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p><strong>也可以获取头部信息中的版本号和编码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文档声明信息(也就是xml的头部信息：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;)</span></span><br><span class="line">TiXmlDeclaration *pDeclar = tinyXmlDoc-&gt;<span class="built_in">FirstChild</span>()-&gt;<span class="built_in">ToDeclaration</span>();</span><br><span class="line"><span class="keyword">if</span> (pDeclar != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头部信息： version is %s , encoding is %s\n&quot;</span>, pDeclar-&gt;<span class="built_in">Version</span>(), pDeclar-&gt;<span class="built_in">Encoding</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取根节点">获取根节点</h3><p>这个定义是需要指定参数根节点的名字，然后再通过RootElement方法获取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TiXmlElement *Library = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Library&quot;</span>);</span><br><span class="line">Library = tinyXmlDoc-&gt;<span class="built_in">RootElement</span>();</span><br></pre></td></tr></table></figure><h3 id="创建Book1节点，并设置属性">创建Book1节点，并设置属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TiXmlElement *Book1 = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="comment">// 插入属性</span></span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;ID&quot;</span>, <span class="number">2</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Price&quot;</span>, <span class="string">&quot;99.81&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="创建Book1的子节点Description-和-Page">创建Book1的子节点Description 和 Page</h3><p>和上面创建的思路代码是一样的，创建好后在插入到Book1节点中就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Book1的子节点Description</span></span><br><span class="line">TiXmlElement *Description = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line">TiXmlText *descriptionText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;师徒四人&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Description-&gt;<span class="built_in">LinkEndChild</span>(descriptionText);<span class="comment">// 给Description节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Description);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Page</span></span><br><span class="line">TiXmlElement *Page = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line">TiXmlText *pageText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;81页&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Page-&gt;<span class="built_in">LinkEndChild</span>(pageText);<span class="comment">// 给Page节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Page);<span class="comment">// 插入到Book1节点下</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518205212632.png" alt="image-20240518205212632"></p><h3 id="将Book1节点添加到根节点中">将Book1节点添加到根节点中</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Library-&gt;<span class="built_in">LinkEndChild</span>(Book1);<span class="comment">// 插入到根节点下</span></span><br></pre></td></tr></table></figure><h3 id="将doc写入xml文件-2">将doc写入xml文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line"><span class="type">bool</span> result = tinyXmlDoc-&gt;<span class="built_in">SaveFile</span>(FILE_NAME);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;文件写入成功！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;文件写入失败！\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="为已存在的xml文件添加节点元素，总代码如下">为已存在的xml文件添加节点元素，总代码如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_XML</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n----- add_XML -----\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = <span class="keyword">new</span> <span class="built_in">TiXmlDocument</span>(FILE_NAME);</span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">LoadFile</span>(TIXML_ENCODING_LEGACY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文档声明信息(也就是xml的头部信息：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;)</span></span><br><span class="line">TiXmlDeclaration *pDeclar = tinyXmlDoc-&gt;<span class="built_in">FirstChild</span>()-&gt;<span class="built_in">ToDeclaration</span>();</span><br><span class="line"><span class="keyword">if</span> (pDeclar != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头部信息： version is %s , encoding is %s\n&quot;</span>, pDeclar-&gt;<span class="built_in">Version</span>(), pDeclar-&gt;<span class="built_in">Encoding</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到文件根节点</span></span><br><span class="line">TiXmlElement *Library = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Library&quot;</span>);</span><br><span class="line">Library = tinyXmlDoc-&gt;<span class="built_in">RootElement</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1节点</span></span><br><span class="line">TiXmlElement *Book1 = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="comment">// 插入属性</span></span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;ID&quot;</span>, <span class="number">2</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Price&quot;</span>, <span class="string">&quot;99.81&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Description</span></span><br><span class="line">TiXmlElement *Description = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line">TiXmlText *descriptionText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;师徒四人&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Description-&gt;<span class="built_in">LinkEndChild</span>(descriptionText);<span class="comment">// 给Description节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Description);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Page</span></span><br><span class="line">TiXmlElement *Page = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line">TiXmlText *pageText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;81页&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Page-&gt;<span class="built_in">LinkEndChild</span>(pageText);<span class="comment">// 给Page节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Page);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line">Library-&gt;<span class="built_in">LinkEndChild</span>(Book1);<span class="comment">// 插入到根节点下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1节点</span></span><br><span class="line">Book1 = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="comment">// 插入属性</span></span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;ID&quot;</span>, <span class="number">3</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">Book1-&gt;<span class="built_in">SetAttribute</span>(<span class="string">&quot;Price&quot;</span>, <span class="string">&quot;66.66&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Description</span></span><br><span class="line">Description = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line">descriptionText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;三国大战&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Description-&gt;<span class="built_in">LinkEndChild</span>(descriptionText);<span class="comment">// 给Description节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Description);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Book1的子节点Page</span></span><br><span class="line">Page = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line">pageText = <span class="keyword">new</span> <span class="built_in">TiXmlText</span>(<span class="string">&quot;30页&quot;</span>);<span class="comment">// 创建文本</span></span><br><span class="line">Page-&gt;<span class="built_in">LinkEndChild</span>(pageText);<span class="comment">// 给Page节点添加文本</span></span><br><span class="line">Book1-&gt;<span class="built_in">LinkEndChild</span>(Page);<span class="comment">// 插入到Book1节点下</span></span><br><span class="line"></span><br><span class="line">Library-&gt;<span class="built_in">LinkEndChild</span>(Book1);<span class="comment">// 插入到根节点下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line"><span class="type">bool</span> result = tinyXmlDoc-&gt;<span class="built_in">SaveFile</span>(FILE_NAME);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;文件写入成功！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;文件写入失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出来看看</span></span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，创建相同子节点的代码都是一样的，也就是说，当需要创建几十个这个的子节点时，可以使用for循环去处理，至于数据可以使用数组是事先存储即可！</p><h2 id="解析">解析</h2><p>解析指定节点中值</p><h3 id="定义一个xml文件类，并读取文件中的xml内容初始化它-2">定义一个xml文件类，并读取文件中的xml内容初始化它</h3><p>和上面 <strong>添加 的第1步骤</strong> 一样…</p><h3 id="获取根节点-2">获取根节点</h3><p>和上面 <strong>三、添加 的第2步骤</strong> 一样…</p><h3 id="解析Book节点">解析Book节点</h3><p>当然，前面已将Book节点删掉了，所以获取到的Book为NULL</p><p><strong>所以如果是指针，在使用前最好先判断一下再去使用！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TiXmlElement* Book = Library-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Book&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (Book) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Book = %s\n\n&quot;</span>, Book-&gt;<span class="built_in">GetText</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析所有的Book1节点的属性">解析所有的Book1节点的属性</h3><p>直接调用Attribute，传入属性名即可获得属性的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当有多个相同名字的节点时，可以使用循环进行读取解析 */</span></span><br><span class="line"><span class="comment">// 函数FirstChildElement():找到指定名字的元素</span></span><br><span class="line"><span class="comment">// 函数NextSiblingElement:在同一级元素中查找下一个指定名字的元素</span></span><br><span class="line">TiXmlElement* pItem = Library-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pItem) &#123;</span><br><span class="line"><span class="keyword">for</span> (; pItem != <span class="literal">NULL</span>; pItem = pItem-&gt;<span class="built_in">NextSiblingElement</span>(<span class="string">&quot;Book1&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析属性</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ID = %s\n&quot;</span>, pItem-&gt;<span class="built_in">Attribute</span>(<span class="string">&quot;ID&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, pItem-&gt;<span class="built_in">Attribute</span>(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Price = %s\n&quot;</span>, pItem-&gt;<span class="built_in">Attribute</span>(<span class="string">&quot;Price&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析所有的Book1节点的子节点">解析所有的Book1节点的子节点</h3><p>获得对应解析的节点后，调用GetText可以获得里面的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当有多个相同名字的节点时，可以使用循环进行读取解析 */</span></span><br><span class="line">TiXmlElement* pItem = Library-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pItem) &#123;</span><br><span class="line"><span class="keyword">for</span> (; pItem != <span class="literal">NULL</span>; pItem = pItem-&gt;<span class="built_in">NextSiblingElement</span>(<span class="string">&quot;Book1&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">// 解析Book1的子节点</span></span><br><span class="line">TiXmlElement* Description = pItem-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Description = %s\n&quot;</span>, Description-&gt;<span class="built_in">GetText</span>());</span><br><span class="line"></span><br><span class="line">TiXmlElement *Page = pItem-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Page = %s\n&quot;</span>, Page-&gt;<span class="built_in">GetText</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析xml节点值">解析xml节点值</h3><p>总代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse_XML</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n----- parse_XML -----\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式一：当读取有问题时，可以使用下面方式二</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line"><span class="comment">TiXmlDocument* tinyXmlDoc = new TiXmlDocument;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 读取文件中的xml</span></span><br><span class="line"><span class="comment">if (!tinyXmlDoc-&gt;LoadFile(FILE_NAME)) &#123;</span></span><br><span class="line"><span class="comment">// 读取失败，打印失败原因</span></span><br><span class="line"><span class="comment">printf(&quot;Could not load example xml file %s. Error=&#x27;%s&#x27;\n&quot;, FILE_NAME, tinyXmlDoc-&gt;ErrorDesc());</span></span><br><span class="line"><span class="comment">return ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个TiXmlDocument类指针</span></span><br><span class="line">TiXmlDocument* tinyXmlDoc = <span class="keyword">new</span> <span class="built_in">TiXmlDocument</span>(FILE_NAME);</span><br><span class="line">tinyXmlDoc-&gt;<span class="built_in">LoadFile</span>(TIXML_ENCODING_LEGACY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文档声明信息(也就是xml的头部信息：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;)</span></span><br><span class="line">TiXmlDeclaration* pDeclar = tinyXmlDoc-&gt;<span class="built_in">FirstChild</span>()-&gt;<span class="built_in">ToDeclaration</span>();</span><br><span class="line"><span class="keyword">if</span> (pDeclar != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头部信息：version is %s , encoding is %s\n&quot;</span>, pDeclar-&gt;<span class="built_in">Version</span>(), pDeclar-&gt;<span class="built_in">Encoding</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到文件根节点</span></span><br><span class="line">TiXmlElement* Library = <span class="keyword">new</span> <span class="built_in">TiXmlElement</span>(<span class="string">&quot;Library&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (Library) &#123;</span><br><span class="line">Library = tinyXmlDoc-&gt;<span class="built_in">RootElement</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析Book节点</span></span><br><span class="line">TiXmlElement* Book = Library-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Book&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (Book) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Book = %s\n\n&quot;</span>, Book-&gt;<span class="built_in">GetText</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当有多个相同名字的节点时，可以使用循环进行读取解析 */</span></span><br><span class="line"><span class="comment">// 函数FirstChildElement():找到指定名字的元素</span></span><br><span class="line"><span class="comment">// 函数NextSiblingElement:在同一级元素中查找下一个指定名字的元素</span></span><br><span class="line">TiXmlElement* pItem = Library-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Book1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pItem) &#123;</span><br><span class="line"><span class="keyword">for</span> (; pItem != <span class="literal">NULL</span>; pItem = pItem-&gt;<span class="built_in">NextSiblingElement</span>(<span class="string">&quot;Book1&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析属性</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ID = %s\n&quot;</span>, pItem-&gt;<span class="built_in">Attribute</span>(<span class="string">&quot;ID&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, pItem-&gt;<span class="built_in">Attribute</span>(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Price = %s\n&quot;</span>, pItem-&gt;<span class="built_in">Attribute</span>(<span class="string">&quot;Price&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析Book1的子节点</span></span><br><span class="line">TiXmlElement* Description = pItem-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Description = %s\n&quot;</span>, Description-&gt;<span class="built_in">GetText</span>());</span><br><span class="line"></span><br><span class="line">TiXmlElement *Page = pItem-&gt;<span class="built_in">FirstChildElement</span>(<span class="string">&quot;Page&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Page = %s\n&quot;</span>, Page-&gt;<span class="built_in">GetText</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://blog.csdn.net/cpp_learner/article/details/122286597">C/C++ 使用 tinyxml库 操作XML格式文件（创建、插入、删除、修改、解析）</a></li></ul>]]></content>
    
    
    <summary type="html">XML文件解析利器</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试总结</title>
    <link href="https://penge666.github.io/posts/df73e2d8.html"/>
    <id>https://penge666.github.io/posts/df73e2d8.html</id>
    <published>2024-05-13T08:18:27.000Z</published>
    <updated>2024-05-13T08:54:18.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>GDB</strong> (全称为GNU Debuger) 是一款由 GNU 开源组织发布、基于 UNIX/LINUX 操作系统的<strong>命令行程序调试工具</strong>。对于一名 Linux 下工作的 C++ 程序员，GDB 是必不可少的工具。</p><h2 id="GDB常用调试命令">GDB常用调试命令</h2><p>为了便于讲解，将通过以下 demo 进行举例说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>１．启动 GDB</strong></p><p>对于 C/C++ 程序调试，<strong>需要在编译前加入 -g 参数选项，表示加入一些调试信息。这样在编译后生成的可执行文件才能使用 GDB 进行调试</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g main.cpp -o demo  <span class="comment">// 生成可执行文件</span></span><br></pre></td></tr></table></figure><p>启动 GDB 命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb demo  <span class="comment">// 启动 GDB 调试</span></span><br></pre></td></tr></table></figure><p>效果如图 1 所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ gdb main</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p><strong>2. 终端列出源代码</strong></p><p>我们可以在终端列出要调试的代码，这样可以不用打开源文件查看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list  <span class="comment">// 执行一次列出 10 行代码，再执行一次列出后面 10 行代码</span></span><br></pre></td></tr></table></figure><p>效果如图 2 所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) list</span><br><span class="line">1       <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">2       using namespace std;</span><br><span class="line">3       int add(int a,int b)&#123;</span><br><span class="line">4           int <span class="built_in">sum</span> = 0;</span><br><span class="line">5           <span class="built_in">sum</span> = a + b;</span><br><span class="line">6           <span class="built_in">return</span> <span class="built_in">sum</span>;</span><br><span class="line">7       &#125;</span><br><span class="line">8       int main(int argc,char *argv[])&#123;</span><br><span class="line">9           int <span class="built_in">sum</span> = 0;</span><br><span class="line">10          <span class="built_in">sum</span> = add(1, 2);</span><br><span class="line">(gdb)</span><br><span class="line">11          cout &lt;&lt; <span class="string">sum &lt;&lt; endl;</span></span><br><span class="line"><span class="string">12          return 0;</span></span><br><span class="line"><span class="string">13      &#125;</span></span><br></pre></td></tr></table></figure><p><strong>3. 设置断点</strong></p><p>断点是程序调试的关键所在，随心所欲地设置断点使我们调试程序变得高效。</p><p>断点打在源程序第 n 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> n  <span class="comment">// 在源程序第 n 行设置一个断点，break 可以用 b 缩写替代</span></span><br></pre></td></tr></table></figure><p>断点打在源程序 main() 函数入口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> main  <span class="comment">// 在 main() 函数入口打断点，也就是第 9 行，break 可以用 b 缩写替代</span></span><br></pre></td></tr></table></figure><p>上面是打在源文件的函数入口，<strong>若要将断点打在其他文件的函数入口或者其他文件的特定行号应该怎么做呢？</strong></p><p>下面的命令可以解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> otherfile:func  <span class="comment">// 断点打在其他文件的函数入口</span></span><br><span class="line"><span class="keyword">break</span> otherfile:n     <span class="comment">// 断点打在其他文件的第 n 行</span></span><br><span class="line"><span class="comment">// 注：otherfile 为其他文件，例如 sort.cpp，而 n 代表行号</span></span><br></pre></td></tr></table></figure><p>我们还可以查看我们所有打的断点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="keyword">break</span>  <span class="comment">// 列出我们所有打的断点的信息，break 可以用 b 缩写替代</span></span><br></pre></td></tr></table></figure><p>除了设置断点外，我们还能删除指定断点或者删除全部断点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>    <span class="comment">// 删除全部断点</span></span><br><span class="line"><span class="keyword">delete</span> n  <span class="comment">// 删除指定断点，n 表示断点号</span></span><br></pre></td></tr></table></figure><p>还有使能和失能断点，失能表示这个断点不会删除，只是暂时失作用，可以理解为屏蔽。若想再次启用可以直接使能，断点功能恢复，不用去重新打断点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable n  <span class="comment">// 失能第 n 个断点</span></span><br><span class="line">enable n   <span class="comment">// 使能第 n 个断点</span></span><br></pre></td></tr></table></figure><p>效果如图 3 所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x11ce: file main.cpp, line 8.</span><br><span class="line">(gdb) b 10</span><br><span class="line">Breakpoint 2 at 0x11e8: file main.cpp, line 10.</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000000011ce <span class="keyword">in</span> main(int, char**) at main.cpp:8</span><br><span class="line">2       breakpoint     keep y   0x00000000000011e8 <span class="keyword">in</span> main(int, char**) at main.cpp:10</span><br><span class="line">(gdb) delete</span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) info b</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure><p><strong>4. 运行程序</strong></p><p>运行程序命令与我们 IDE 调试程序类似，两者可以作对比。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run  <span class="comment">// 类比于 IDE 的全速运行，遇到断点会停下，run 可以用 r 缩写替代</span></span><br><span class="line">next <span class="comment">// 类比于 IDE 不进入函数的单步调试，next 可以用 n 缩写替代</span></span><br><span class="line">step <span class="comment">// 类比于 IDE 进入函数的单步调试，step 可以用 s 缩写替代</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 继续执行直到遇到下一个断点停下，没有断点直接结束，可以用 c 缩写替代</span></span><br><span class="line">until n  <span class="comment">// 直接跳转到指定行号程序，n 表示行号</span></span><br><span class="line">finish   <span class="comment">// 当程序运行在函数中时，直接执行完当前函数并打印函数返回信息</span></span><br><span class="line">kill  <span class="comment">// 直接结束当前进程，程序可以从头运行</span></span><br><span class="line">quit  <span class="comment">// 退出 GDB，quit 可以用 q 缩写替代</span></span><br></pre></td></tr></table></figure><p><strong>5.打印信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print x  <span class="comment">// 可以打印变量、地址、表达式值等，x 表示需要打印的东西，print 可以用 p 替代</span></span><br><span class="line">bt  <span class="comment">// 打印当前调用堆栈的信息，后面会继续讲</span></span><br></pre></td></tr></table></figure><p>GDB 的常用调试命令基本上就这些，而且都有缩写表示，非常好记忆的！</p><h2 id="GDB调试core文件">GDB调试core文件</h2><p>Linux应用程序发生<code>Segmentation fault</code>段错误时，需要利用<code>core dump</code>文件定位错误。</p><p>段错误segmentation fault，信号SIGSEGV，是由于访问内存管理单元MMU异常所致，通常由于无效内存引用，如指针引用了一个不属于当前进程地址空间中的地址，操作系统便会进行干涉引发SIGSEGV信号产生段错误。</p><p><strong>段错误产生的原因</strong></p><ul><li>空指针</li><li>野指针</li><li>堆栈越界</li><li>…</li></ul><p><strong>核心转储</strong></p><p>在 Linux 系统中，常<strong>将“主内存”称为核心(<code>core</code>)，<strong>而</strong>核心映像(<code>core image</code>) 就是 “进程”(process)执行当时的内存内容。</strong></p><p>当进程发生错误或收到“信号”(signal) 而终止执行时，<strong>系统会将核心映像写入一个文件</strong>，以作为调试之用，这就是所谓的<strong>核心转储(<code>core dump</code>)。</strong></p><p>【简单解释】当在一个程序崩溃时，系统会在指定目录下生成一个<code>core</code>文件，我们就可以通过<code> core</code>文件来对造成程序崩贵的原因进行调试定位。</p><p><strong>1. 产生 Segmentation fault 程序</strong></p><p>下面是一个<strong>没有递归终止条件</strong>的程序，显然会发生 Segmentation fault 错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ g++ -g -o main main.cpp -lpthread -fpermissive</span><br><span class="line">main.cpp: In <span class="keyword">function</span> ‘int recursion(int)’:</span><br><span class="line">main.cpp:5:1: warning: no <span class="built_in">return</span> statement <span class="keyword">in</span> <span class="keyword">function</span> returning non-void [-Wreturn-<span class="built_in">type</span>]</span><br><span class="line">    5 | &#125;</span><br><span class="line">      | ^</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ ./main</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>此时编译运行的时候是没有 core 文件的，是因为我们没有配置生成 core 文件。</p><p><strong>2. 生成 core 文件</strong></p><p>**Core 文件是一种特殊的文件类型，通常在程序崩溃时由操作系统生成。它包含了程序崩溃时的内存镜像和程序状态信息，**比如程序计数器、堆栈指针、寄存器状态等。这些信息可以用来调试程序，找出导致程序崩溃的原因。</p><p>Core 文件的名字通常为 “core”，但也可以通过操作系统的设置来改变。在 Unix 和类 Unix 系统（比如 Linux）中，你可以使用 <code>ulimit</code> 命令来控制是否生成 core 文件，以及 core 文件的大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们先使用如下命令查看 core 文件大小，若结果为 0 表示还没有生成 core 文件。</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulimit</span> -c  // 查看 core 文件大小</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="meta">@sv</span>-NF5280M5:/home/sv/桌面$ ulimit -c</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(base) sv<span class="meta">@sv</span>-NF5280M5:/home/sv/桌面$ ulimit -a</span><br><span class="line">core file <span class="title function_">size</span>          <span class="params">(blocks, -c)</span> <span class="number">0</span></span><br><span class="line">data seg <span class="title function_">size</span>           <span class="params">(kbytes, -d)</span> unlimited</span><br><span class="line">scheduling <span class="title function_">priority</span>             <span class="params">(-e)</span> <span class="number">0</span></span><br><span class="line">file <span class="title function_">size</span>               <span class="params">(blocks, -f)</span> unlimited</span><br><span class="line">pending <span class="title function_">signals</span>                 <span class="params">(-i)</span> <span class="number">255799</span></span><br><span class="line">max locked <span class="title function_">memory</span>       <span class="params">(kbytes, -l)</span> <span class="number">65536</span></span><br><span class="line">max memory <span class="title function_">size</span>         <span class="params">(kbytes, -m)</span> unlimited</span><br><span class="line">open <span class="title function_">files</span>                      <span class="params">(-n)</span> <span class="number">1024</span></span><br><span class="line">pipe <span class="title function_">size</span>            <span class="params">(<span class="number">512</span> bytes, -p)</span> <span class="number">8</span></span><br><span class="line">POSIX message <span class="title function_">queues</span>     <span class="params">(bytes, -q)</span> <span class="number">819200</span></span><br><span class="line">real-time <span class="title function_">priority</span>              <span class="params">(-r)</span> <span class="number">0</span></span><br><span class="line">stack <span class="title function_">size</span>              <span class="params">(kbytes, -s)</span> <span class="number">8192</span></span><br><span class="line">cpu <span class="title function_">time</span>               <span class="params">(seconds, -t)</span> unlimited</span><br><span class="line">max user <span class="title function_">processes</span>              <span class="params">(-u)</span> <span class="number">255799</span></span><br><span class="line">virtual <span class="title function_">memory</span>          <span class="params">(kbytes, -v)</span> unlimited</span><br><span class="line">file <span class="title function_">locks</span>                      <span class="params">(-x)</span> unlimited</span><br></pre></td></tr></table></figure><p>使用如下命令修改 core 文件大小不受限制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited  <span class="comment">// 修改 core 文件大小不受限制</span></span><br></pre></td></tr></table></figure><p>但是以下并未查找到core文件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>g++ -g -o main main.cpp -lpthread -fpermissive</span><br><span class="line">main.<span class="symbol">cpp:</span> <span class="title class_">In</span> function ‘int recursion(int)’:</span><br><span class="line">main.<span class="symbol">cpp:</span><span class="number">5</span><span class="symbol">:</span><span class="number">1</span>: <span class="symbol">warning:</span> no <span class="keyword">return</span> statement <span class="keyword">in</span> function returning non-void [-<span class="title class_">Wreturn</span>-type]</span><br><span class="line">    <span class="number">5</span> |<span class="params"> &#125;</span></span><br><span class="line"><span class="params">      </span>| ^</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>./main</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>ls</span><br><span class="line"><span class="string">&#x27;未命名 1.ods&#x27;</span>  <span class="string">&#x27;未命名 2.odt&#x27;</span>   lu3018gtmnzo.tmp   main.c     params.odt</span><br><span class="line"><span class="string">&#x27;未命名 1.odt&#x27;</span>   index.html      main               main.cpp   proxy.txt</span><br></pre></td></tr></table></figure><p>但是当前目录下<strong>没有看到core文件的生成</strong>。</p><p>这是因为<strong>core文件的默认生成路径不对</strong>，只要发生段错误时，括号里出现了<code>core dumped</code>就代表<code>core</code>文件已生成。</p><p>可以通过以下命令查看<code>core</code>文件的存放路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>sys<span class="regexp">/kernel/</span>core_pattern</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/桌面$ <span class="built_in">cat</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p><strong>修改<code>core</code>文件生成路径为当前目录下</strong>，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">&quot;echo core &gt; /proc/sys/kernel/core_pattern &quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意使用root用户权限</p></blockquote><p>修改后，<code>core</code>文件就会在当前目录下生成。</p><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base) sv@sv-NF5280M5:/home/sv/桌面$ <span class="built_in">ls</span></span><br><span class="line"><span class="string">&#x27;未命名 1.ods&#x27;</span>  <span class="string">&#x27;未命名 2.odt&#x27;</span>   index.html         main     main.cpp     proxy.txt</span><br><span class="line"><span class="string">&#x27;未命名 1.odt&#x27;</span>   core            lu3018gtmnzo.tmp   main.c   params.odt</span><br></pre></td></tr></table></figure><p><strong>3.调试 core 文件</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/</span>桌面<span class="variable">$ </span>gdb main core</span><br></pre></td></tr></table></figure><p>接下来可以打印当前堆栈信息分析问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtrace  <span class="comment">// 打印当前堆栈信息，backtrace 可以用 bt 的缩写替代</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>           <span class="selector-tag">recursion</span>(n - <span class="number">1</span>);</span><br><span class="line">(gdb) <span class="selector-tag">bt</span></span><br><span class="line"><span class="selector-id">#0</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74180</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261907</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#1</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261906</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#2</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261905</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#3</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261904</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#4</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261903</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#5</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261902</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#6</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261901</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#7</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261900</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#8</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261899</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#9</span>  <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261898</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#10</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261897</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#11</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261896</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#12</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261895</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#13</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261894</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#14</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261893</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#15</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261892</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#16</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261891</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#17</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261890</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#18</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261889</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#19</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261888</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br><span class="line"><span class="selector-id">#20</span> <span class="number">0</span><span class="selector-tag">x000055fb7cc74185</span> <span class="selector-tag">in</span> <span class="selector-tag">recursion</span> (n=-<span class="number">261887</span>) <span class="selector-tag">at</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure><p>常使用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bt 或 backtrace: 显示当前线程的调用栈跟踪。</span><br><span class="line">info threads: 列出所有线程。</span><br><span class="line">thread n: 切换到指定的线程号，n为指定的线程号</span><br><span class="line">list: 显示当前执行的源代码。</span><br><span class="line"><span class="built_in">print</span> x: 打印变量或表达式的值，x为变量或表达式</span><br><span class="line">frame f: 切换到特定的栈帧。f为指定的栈帧号</span><br><span class="line">thread apply all bt: 打印所有堆栈信息</span><br></pre></td></tr></table></figure><p>参考文献</p><ul><li><a href="https://blog.csdn.net/weixin_44046545/article/details/138252207">一篇文章轻松学会使用gdb调试程序的core文件（调试全过程）</a></li><li><a href="https://www.kancloud.cn/wizardforcel/gdb-tips-100">https://www.kancloud.cn/wizardforcel/gdb-tips-100</a></li><li>[<a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/08/19/cpluscplus-gdbusage_part2">GDB调试多线程及多进程</a>](<a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/08/19/cpluscplus-gdbusage_part2">GDB调试多线程及多进程</a>)</li></ul>]]></content>
    
    
    <summary type="html">GDB调试</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux实战技能</title>
    <link href="https://penge666.github.io/posts/a9ea3099.html"/>
    <id>https://penge666.github.io/posts/a9ea3099.html</id>
    <published>2024-05-10T14:29:26.000Z</published>
    <updated>2024-05-11T09:39:55.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>发烧了2天，掉了一天的水，烧的快见太奶了。</p><p>Last，纵使人生百般滋味，也要笑对！！！</p><h2 id="Linux背景介绍">Linux背景介绍</h2><h3 id="Linux版本">Linux版本</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内核版本：</span><br><span class="line"></span><br><span class="line"><span class="symbol">https:</span>//www.kernel<span class="meta">.org</span> </span><br></pre></td></tr></table></figure><p>内核版本分为三个部分，主版本号、次版本号、末版本号，次版本号是奇数为开发板，偶数为稳定版</p><p>发行版本</p><p>RedHat：经过专业测试</p><p>Fedora：社区发行，版本较新，但是没有经过专业测试。（也是redhat发行）</p><p>CentOS：用RedHat的源代码编译，但是把RedHat的商标等去掉。但是没有一些技术支持</p><p>桌面安装：Debian，Ubuntu</p><h3 id="常见目录">常见目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/  根目录</span><br><span class="line">/root  root用户的家目录</span><br><span class="line">/home/username  普通用户的家目录</span><br><span class="line">/etc  配置文件目录</span><br><span class="line">/bin  命令目录</span><br><span class="line">/sbin  管理命令目录</span><br><span class="line">/usr/bin/usr/sbin  系统预装的其他命令</span><br></pre></td></tr></table></figure><p><strong>sbin和bin命令的区别</strong></p><p><code>sbin</code>和<code>bin</code>都是Linux文件系统中的重要目录，它们分别存放了系统的重要可执行文件。这两个目录的主要区别在于，它们各自存放的命令的使用者不同。</p><ul><li><code>bin</code>目录：这个目录存放的是所有用户都可以运行的命令。这些命令包括很多基本的Linux命令，如ls、cp、rm等。<code>bin</code>是“binary”的缩写，意为二进制，表示这个目录下存放的都是可执行的二进制文件。</li><li><code>sbin</code>目录：这个目录存放的是系统管理员（root用户）才能运行的命令。这些命令一般都是和系统管理有关的，如fdisk、ifconfig等。<code>sbin</code>是“system binary”的缩写，表示这个目录下存放的都是系统命令的二进制文件。</li></ul><p>总的来说，<code>bin</code>和<code>sbin</code>的区别在于，<code>bin</code>目录下的命令是给所有用户使用的，而<code>sbin</code>目录下的命令则是给系统管理员使用的。</p><p>另外，除了根目录下的<code>/bin</code>和<code>/sbin</code>，在<code>/usr</code>目录下也有<code>/usr/bin</code>和<code>/usr/sbin</code>两个目录。它们的作用和根目录下的<code>/bin</code>、<code>/sbin</code>类似，只不过<code>/usr/bin</code>和<code>/usr/sbin</code>中的命令是非必需的，也就是说，系统可以在没有这些命令的情况下正常运行。</p><h2 id="系统操作">系统操作</h2><h3 id="帮助命令">帮助命令</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span> 是 manual 的缩写</span><br><span class="line"><span class="keyword">man</span> 帮助用法演示</span><br><span class="line">    #<span class="keyword">man</span> <span class="keyword">ls</span></span><br><span class="line"><span class="keyword">man</span> 也是一条命令，分为9章，可以使用<span class="keyword">man</span>命令获得<span class="keyword">man</span>的帮助</span><br><span class="line">    #<span class="keyword">man</span> 7 <span class="keyword">man</span></span><br></pre></td></tr></table></figure><p><strong>man命令</strong></p><p><code>man 1 kill</code>、<code>man 2 kill</code>，这些命令都是查看 kill 命令的手册，但是文档却大不相同。</p><p><strong>因为 kill 是一个命令行的工具，<code>which kill</code> 看到 /usr/bin/kill 是一个二进制文件；其实，也有一个系统调用叫做 kill。</strong></p><p>man 1 kill 显示的是命令行工具 kill 的手册；</p><p>man 2 kill 显示系统调用 kill 的手册；</p><p>显示什么类型的手册，由 man 和命令中间的数字决定，目前共有 9 个 man 支持的数字。</p><table><thead><tr><th>数字</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>可执行程序或 Shell 命令</td></tr><tr><td>2</td><td>系统调用（内核提供的函数）</td></tr><tr><td>3</td><td>库调用</td></tr><tr><td>4</td><td>特殊文件（通常位于 /dev 目录）</td></tr><tr><td>5</td><td>文件格式和约定（比如 /etc/passwd）</td></tr><tr><td>6</td><td>游戏</td></tr><tr><td>7</td><td>杂项（包和一些约定）Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)</td></tr><tr><td>8</td><td>系统管理命令（通常是 root 用户执行的命令）</td></tr><tr><td>9</td><td>内核相关的文件 Kernel routines [Non standard]</td></tr></tbody></table><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">help</span></span><br><span class="line"><span class="keyword">shell</span>（命令解释器）自带的命令成为内部命令，其他的是外部命令</span><br><span class="line">内部命令使用 <span class="keyword">help</span> 帮助</span><br><span class="line">    #<span class="keyword">help</span> <span class="keyword">cd</span></span><br><span class="line">外部命令使用<span class="keyword">help</span>帮助</span><br><span class="line">    #<span class="keyword">ls</span> --<span class="keyword">help</span></span><br><span class="line"></span><br><span class="line">可以通过<span class="keyword">type</span>来判断一个命令是内部还是外部命令</span><br><span class="line">    #<span class="keyword">type</span> <span class="keyword">ls</span></span><br><span class="line">    #<span class="keyword">type</span> <span class="keyword">cd</span></span><br></pre></td></tr></table></figure><p>Linux的命令可以分为内部命令和外部命令：</p><ul><li>内置命令在系统启动时就调入内存，是常驻内存的，所以执行效率高。</li><li>外部命令是系统的软件功能，用户需要时才从硬盘中读入内存。</li></ul><h3 id="文件管理">文件管理</h3><p>显示当前的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> 显示当前的目录名称</span><br></pre></td></tr></table></figure><p>更改当前的操作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 更改当前的操作目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path/to/... 绝对路径</span><br><span class="line"><span class="built_in">cd</span> ./path/to/... 相对路径</span><br><span class="line"><span class="built_in">cd</span> ../path/to/... 相对路径</span><br></pre></td></tr></table></figure><p>文件查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 查看当前目录下的文件</span><br><span class="line"><span class="built_in">ls</span> /  /root    这样会同时查看根目录和 /root目录下的文件</span><br><span class="line">常用参数</span><br><span class="line">    -l 长格式显示文件</span><br><span class="line">    -a 显示隐藏文件</span><br><span class="line">    -r 逆序显示（默认按照文件名排序）</span><br><span class="line">    -t 按照时间顺序显示   <span class="built_in">ls</span> -l -r -t （会按照时间逆向排序）</span><br><span class="line">    -R 递归显示    -h 人性化显示、    -d 只显示目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/$ sudo <span class="built_in">ls</span> /  /root</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">/:</span><br><span class="line">bin   cdrom  data_old  etc   lib    lib64   lost+found  mmkv.default      mnt  proc  run   snap  swapfile  tmp  var</span><br><span class="line">boot  data   dev       home  lib32  libx32  media       mmkv.default.crc  opt  root  sbin  srv   sys       usr</span><br><span class="line"></span><br><span class="line">/root:</span><br><span class="line">snap</span><br></pre></td></tr></table></figure><p>目录文件的创建与删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>  建立空目录</span><br><span class="line"><span class="built_in">mkdir</span> a</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -p  递归创建多级文件夹</span><br><span class="line"></span><br><span class="line"><span class="built_in">rmdir</span> 删除空文件夹</span><br><span class="line"><span class="built_in">rmdir</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> 可以删除非空目录及文件</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -r 删除目录</span><br><span class="line">    -f 强制删除，不提示</span><br><span class="line">    需要注意，<span class="built_in">rm</span> -rf 后面可以跟多个目录，不要出现 <span class="built_in">rm</span> -rf / usr 这种，会从根目录开始删除</span><br></pre></td></tr></table></figure><p>复制和移动目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 复制文件和目录</span><br><span class="line"><span class="built_in">cp</span> /root/a /tmp（临时文件）</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -r/R 递归复制目录</span><br><span class="line">    -v 显示过程</span><br><span class="line">    -p 保留文件原有更新时间（属性）</span><br><span class="line">    -a 时间戳+所有权+复制连接文件属性而非档案本身    -f 强行覆盖    -i 覆盖之前先行提示</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 移动文件或者重命名</span><br><span class="line"><span class="built_in">mv</span> /a /othera</span><br><span class="line"><span class="built_in">mv</span> /a /tmp</span><br><span class="line"><span class="built_in">mv</span> /a /tmp/b（移动+重命名）</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -i 覆盖文件前提示</span><br></pre></td></tr></table></figure><h3 id="通配符">通配符</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义：<span class="built_in">shell</span> 内建的符号</span><br><span class="line">用途：操作多个相似（有简单规律的）文件</span><br><span class="line">常用通配符：</span><br><span class="line">　　* 匹配任何字符串</span><br><span class="line">　　？ 匹配<span class="number">1</span>个字符串</span><br><span class="line">　　[<span class="built_in">xyz</span>] 匹配<span class="built_in">xyz</span>任意一个字符</span><br><span class="line">　　[a-z] 匹配一个范围</span><br><span class="line">　　[!<span class="built_in">xyz</span>]或者[^<span class="built_in">xyz</span>] 不匹配</span><br></pre></td></tr></table></figure><h3 id="文本内容查看">文本内容查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文本内容显示到终端</span><br><span class="line">    显示全部</span><br><span class="line"><span class="built_in">head</span> 查看文件开头</span><br><span class="line">    <span class="built_in">head</span> test.txt  默认查看前10行</span><br><span class="line">    <span class="built_in">head</span> -5 test.txt </span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> 查看文件结尾</span><br><span class="line">    <span class="built_in">tail</span> -1000f catalina.out</span><br><span class="line">    常用参数 </span><br><span class="line">    -f 文件内容更新后，显示信息同步更新</span><br><span class="line"></span><br><span class="line"><span class="built_in">wc</span> 统计文件内容信息    </span><br><span class="line">    <span class="built_in">wc</span> -l /tmp/test.txt    查看文件有多少行</span><br><span class="line">    -c或--bytes或——chars：只显示Bytes数；</span><br><span class="line">    -l或——lines：只显示列数；</span><br><span class="line">    -w或——words：只显示字数。</span><br><span class="line">more 分行显示 </span><br><span class="line">less</span><br></pre></td></tr></table></figure><p>Note:可以使用tail -f 查看日志内容。</p><h3 id="打包和压缩">打包和压缩</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">最早的Linux备份介质是磁带，使用的命令是tar</span><br><span class="line">可以打包后的磁带文件进行压缩储存，压缩的命令是 gzip 和 bzip2</span><br><span class="line">经常使用的扩展名是 <span class="string">.tar.gz</span>  <span class="string">.tar.bz2</span>  <span class="string">.tgz</span></span><br><span class="line">tar 打包命令</span><br><span class="line">常用参数</span><br><span class="line">    c 打包</span><br><span class="line">    x 解包</span><br><span class="line">    f 指定操作类型为文件    　　 v 显示进度    P 使用绝对路径</span><br><span class="line">打包</span><br><span class="line">tar cf <span class="string">/tmp/etc-backup.tar</span> <span class="string">/etc</span>      把  <span class="string">/etc</span> 这个文件夹打包放在<span class="string">/tmp/etc-backup.tar</span>会提示，但是也能成功：tar: Removing leading `/&#x27; from member names</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar cPf /tmp/etc-backup.tar /etc      使用绝对路径 （没有提示）</span><br><span class="line">tar czf /tmp/etc-backup.tar.gz /etc  （tar集成了gzip和bzip2）</span><br><span class="line">tar cjf /tmp/etc-backup.tar.bz2 /etc  （压缩比例更高）</span><br><span class="line"></span><br><span class="line">解包</span><br><span class="line">tar xf /tmp/etc-backup.tar -C /root  把 tar包解压到 /root 目录下</span><br><span class="line">tar zxf /tmp/etc-backup.tar.gz -C /etc</span><br><span class="line">tar zjf /tmp/etc-backup.tar.gz -C /etc</span><br></pre></td></tr></table></figure><h3 id="VI">VI</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">多模式产生的原因</span><br><span class="line">四种模式：</span><br><span class="line">    正常模式（<span class="title class_">Normal</span>-mode）</span><br><span class="line">    插入模式（<span class="title class_">Insert</span>-mode）</span><br><span class="line">    命令模式（<span class="title class_">Command</span>-mode）</span><br><span class="line">    可视模式（<span class="title class_">Visual</span>-mode）</span><br><span class="line"></span><br><span class="line">i 进入插入模式</span><br><span class="line">i是当前光标</span><br><span class="line">I是光标当行开头</span><br><span class="line">a是光标后一位</span><br><span class="line">A是光标当行结尾</span><br><span class="line">o下一行，会产生一个空行</span><br><span class="line">O上一行，会产生一个空行</span><br><span class="line"></span><br><span class="line">v进入可视模式</span><br><span class="line"></span><br><span class="line"><span class="symbol">:</span>进入命令模式</span><br><span class="line"></span><br><span class="line">esc返回正常模式</span><br><span class="line"></span><br><span class="line">正常模式下：</span><br><span class="line">hjkl可以控制上下左右</span><br><span class="line"></span><br><span class="line">yy表示复制当行，p可以粘贴</span><br><span class="line"><span class="number">3</span>yy表示复制三行</span><br><span class="line">y<span class="variable">$ </span>表示复制从光标到当行结尾</span><br><span class="line">dd d<span class="variable">$表</span>示剪切</span><br><span class="line"></span><br><span class="line">操作错误，u可以撤销，ctrl+r重做</span><br><span class="line">x表示删除当前光标的字符</span><br><span class="line">r可以替换当前字符</span><br><span class="line"></span><br><span class="line"><span class="symbol">:set</span> nu 可以查看目前是第几行</span><br><span class="line">数字 + G可以到数字对应的行</span><br><span class="line">g移动到第一行</span><br><span class="line">G移动到最后一行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">^来到光标所在行的开头，<span class="variable">$来</span>到光标所在行的结尾</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 命令模式</span><br><span class="line"><span class="symbol">:w</span> /root/test.txt   文件新建的，可以保存一个新文件</span><br><span class="line"><span class="symbol">:w</span> 文件已经存在的情况下，保存</span><br><span class="line"><span class="symbol">:wq</span> 保存退出</span><br><span class="line"><span class="symbol">:q!</span> 强制退出</span><br><span class="line"></span><br><span class="line"><span class="symbol">:</span>! 执行linux命令，看完后回车重新回到vim</span><br><span class="line">/x  查找x字符，n查找下一个，shift+n上一个</span><br><span class="line"><span class="symbol">:s/old/new</span> 用新字符替换旧字符（只正对光标所在的行）</span><br><span class="line"><span class="symbol">:%s/old/new</span> 用新字符替换旧字符（整个文本，但只替换一个）</span><br><span class="line"><span class="symbol">:%s/old/new/g</span> 用新字符替换旧字符（整个文本，全部替换）</span><br><span class="line"><span class="symbol">:</span><span class="number">3</span>,<span class="number">5</span>s/x/X/g <span class="number">3</span><span class="number">-5</span>行内全部替换，替换一个就去掉g</span><br><span class="line"></span><br><span class="line"><span class="symbol">:set</span> nu 显示行号</span><br><span class="line"><span class="symbol">:set</span> nonu 不显示行号</span><br><span class="line"></span><br><span class="line">以上是单次修改的，如果要修改默认配置</span><br><span class="line">vim /etc/vimrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可视模式</span><br><span class="line">三种进入可视模式的方式</span><br><span class="line">v 字符可视模式</span><br><span class="line">V 行可视模式</span><br><span class="line">ctrl + v 块可视模式</span><br><span class="line">    配合d和I（大写i）命令可以进行块的便利操作</span><br><span class="line"></span><br><span class="line">需要在块的所有行之前加入一些字符，选中块，I的时候会在选中的块的第一行的第一个光标处，输入字符，连续两次esc。</span><br><span class="line">选中块，d，然后选中的块就会被删除</span><br></pre></td></tr></table></figure><h3 id="用户与权限管理">用户与权限管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">useradd 新建用户</span><br><span class="line">    useradd dongye（可以用 <span class="built_in">id</span> dongye 来验证是否存在）</span><br><span class="line">    创建一个用户后，自动在 /home建立家目录，并且创建一些隐藏文件。同时，在 /etc/passwd 这个文件里会加入新用户dongye的数据，/etc/shadow里面也有会相关数据（密码相关）。如果没有组的话，创建一个同名的组。</span><br><span class="line">userdel 删除用户</span><br><span class="line">    userdel dongye</span><br><span class="line">    userdel -r dongye 同时删除家目录</span><br><span class="line">passwd 修改用户密码</span><br><span class="line">    passwd dongye</span><br><span class="line">    passwd更改当前用户密码</span><br><span class="line">    /etc/passwd 和 /etc/shadow 里面的数据也被删除</span><br><span class="line">usermod 修改一个用户账户</span><br><span class="line">    usermod -d /home/other dongye  家目录从 /home/dongye 改成 /home/other</span><br><span class="line">chage 修改用户生命周期    设置用户密码的过期时间，甚至用户本身的过期时间</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>奇怪的现象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@penge-<span class="keyword">virtual</span>-machine:/home<span class="meta"># useradd test</span></span><br><span class="line">root@penge-<span class="keyword">virtual</span>-machine:/home<span class="meta"># ls</span></span><br><span class="line">penge</span><br></pre></td></tr></table></figure><p><strong>GPT解答</strong></p><p>在Linux中，当你创建一个新的用户时，系统会默认在 <code>/home</code> 目录下创建一个与用户名同名的家目录。你可以使用 <code>useradd</code> 命令来创建新用户。下面是一些示例：</p><ul><li>创建一个新用户并指定家目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m username</span><br></pre></td></tr></table></figure><p>这里的 <code>-m</code> 选项表示创建家目录。</p><ul><li>如果你想指定家目录的路径，你可以使用 <code>-d</code> 选项：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -d /home/custom_directory username</span><br></pre></td></tr></table></figure><p>这里，<code>-d</code> 选项后面跟的是你想要设定的家目录的路径。</p><ul><li>记得，创建新用户后，你需要为新用户设置密码，这样新用户才能登录。你可以使用 <code>passwd</code> 命令来设置密码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>不过请注意，这些操作需要管理员权限，所以在命令前可能需要加上 <code>sudo</code>。</p><p>如果你已经创建了用户但忘记了设置家目录，你可以使用 <code>usermod</code> 命令来修改用户的家目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -d /home/new_directory username</span><br></pre></td></tr></table></figure><p>这里，<code>-d</code> 选项后面跟的是你想要设定的新的家目录的路径。</p><p><strong>使用<code>/etc/passwd</code>查看</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">root@penge-virtual-machine:/home<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">messagebus:x:103:106::/nonexistent:/usr/sbin/nologin</span><br><span class="line">syslog:x:104:110::/home/syslog:/usr/sbin/nologin</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">tcpdump:x:108:115::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">usbmux:x:110:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">rtkit:x:111:117:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">dnsmasq:x:112:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin</span><br><span class="line">cups-pk-helper:x:113:120:user <span class="keyword">for</span> cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin</span><br><span class="line">speech-dispatcher:x:114:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">kernoops:x:116:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin</span><br><span class="line">saned:x:117:123::/var/lib/saned:/usr/sbin/nologin</span><br><span class="line">nm-openvpn:x:118:124:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin</span><br><span class="line">hplip:x:119:7:HPLIP system user,,,:/run/hplip:/bin/false</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">colord:x:121:126:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin</span><br><span class="line">geoclue:x:122:127::/var/lib/geoclue:/usr/sbin/nologin</span><br><span class="line">pulse:x:123:128:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin</span><br><span class="line">gnome-initial-setup:x:124:65534::/run/gnome-initial-setup/:/bin/false</span><br><span class="line">gdm:x:125:130:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">sssd:x:126:131:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologin</span><br><span class="line">penge:x:1000:1000:penge,,,:/home/penge:/usr/bin/zsh</span><br><span class="line">systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin</span><br><span class="line">sshd:x:127:65534::/run/sshd:/usr/sbin/nologin</span><br><span class="line">fwupd-refresh:x:128:135:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">mysql:x:129:137:MySQL Server,,,:/nonexistent:/bin/false</span><br><span class="line"><span class="built_in">test</span>:x:1001:1002::/home/test:/bin/sh</span><br></pre></td></tr></table></figure><p><strong>id test</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@penge-virtual-machine:/home<span class="comment"># id test</span></span><br><span class="line">uid=1001(<span class="built_in">test</span>) gid=1002(<span class="built_in">test</span>) <span class="built_in">groups</span>=1002(<span class="built_in">test</span>)</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="selector-attr">[-gGnru]</span><span class="selector-attr">[--help]</span><span class="selector-attr">[--version]</span><span class="selector-attr">[用户名称]</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-g 或 --group 　显示用户所属群组的ID。</li><li>-G 或 --groups 　显示用户所属附加群组的ID。</li><li>-n 或 --name 　显示用户，所属群组或附加群组的名称。</li><li>-r 或 --real 　显示实际ID。</li><li>-u 或 --user 　显示用户ID。</li><li>-help 　显示帮助。</li><li>-version 　显示版本信息。</li></ul><h3 id="组管理命令">组管理命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd 新建用户组</span><br><span class="line">    groupadd group1</span><br><span class="line">    useradd user1</span><br><span class="line">    usermod -g group1 user1 把user1这个用户的组改成group1</span><br><span class="line">    useradd -g group1 user2 新建用户user2时就把它放到group1组下</span><br><span class="line">groupdel 删除用户组    groupdel group1 删除组group1</span><br></pre></td></tr></table></figure><h3 id="用户切换">用户切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su 切换用户</span><br><span class="line">    su - USERNAME 使用 login shell 方式切换用户</span><br><span class="line">    su USERNAME 不完全切换，比如还是在 /root下而不会自动跳转到用户家目录</span><br><span class="line"></span><br><span class="line">sudo 以其他用户身份执行命令</span><br><span class="line">    visudo 设置需要使用sudo的用户（组）。下图设置 user3用户拥有shutdown -c权限，需要输入 user3自己的密码</span><br></pre></td></tr></table></figure><p><strong>su和sudo的区别</strong></p><p><code>su</code>和<code>sudo</code>都是Linux系统中用于权限管理的命令，它们的主要区别在于使用方式和权限控制：</p><ul><li><code>su</code>命令：<code>su</code>是“Switch User”的缩写，主要用于切换到其他用户。当你输入<code>su</code>命令后，系统会提示你输入目标用户的密码，输入正确后，你就切换到了那个用户，拥有了那个用户的全部权限。如果没有指定用户名，那么默认切换到root用户。</li><li><code>sudo</code>命令：<code>sudo</code>是“Super User DO”的缩写，主要用于临时获取root权限。当你在命令前加上<code>sudo</code>后，那个命令就会以root用户的身份运行，但之后的操作还是以普通用户的身份进行。使用<code>sudo</code>需要输入当前用户的密码，并且当前用户需要在sudoers文件中（一般位于/etc/sudoers）。</li></ul><p>总的来说，<code>su</code>是切换到其他用户，拥有目标用户的全部权限；而<code>sudo</code>则是临时获取root权限，执行完命令后仍然保持原用户身份。使用哪个命令主要取决于你的需求，如果你需要连续执行多条需要root权限的命令，可能使用<code>su</code>切换到root用户会更方便；如果你只是临时需要执行一条需要root权限的命令，那么使用<code>sudo</code>可能更安全，更符合权限最小化的原则。</p><h3 id="用户和用户组的配置文件介绍">用户和用户组的配置文件介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd 用户配置文件，7个字段</span><br><span class="line"></span><br><span class="line">user3:x:1003:1003::/home/user3:bin/bash</span><br><span class="line">user3：用户名称</span><br><span class="line">x：是否需要密码验证，x表示需要，空表示不需要</span><br><span class="line">1003：用户的uid，用户的<span class="built_in">id</span>信息，唯一识别用户的标识。root是0。</span><br><span class="line">1003：用户的gid，表示组<span class="built_in">id</span>信息</span><br><span class="line">第五个字段：注释</span><br><span class="line">/home/user3：家目录</span><br><span class="line">/bin/bash：用户登录后的命令解释器。/sbin/nologin 表示不能登录</span><br><span class="line"></span><br><span class="line">/etc/shadow 保存用户和用户密码相关信息的</span><br><span class="line">第一个字段：用户名称</span><br><span class="line">第二个字段：用户加密过后的密码（看到也没用，经过处理，即使相同的密码也会显示不同）</span><br><span class="line"></span><br><span class="line">/etc/group 用户组相关的配置文件，4个字段</span><br><span class="line">group:x:10:another</span><br><span class="line">group：组的名称</span><br><span class="line">x：是否需要密码验证</span><br><span class="line">10：gid</span><br><span class="line">another：其他组设置，说明another这个用户的第二个组是group比如输入 <span class="built_in">id</span> user1uid=1001(user1) gid=1001(group1) 组=1001(group1)<span class="built_in">id</span> anotheruid=1002(another) gid=1002(another) 组=1003(group)  查找another信息，发现他的第二个组是group</span><br></pre></td></tr></table></figure><h3 id="文件与目录权限表示方法">文件与目录权限表示方法</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240509110036508.png" alt="image-20240509110036508"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">文件类型</span><br><span class="line">-    普通文件</span><br><span class="line">d   目录文件</span><br><span class="line">b   块特殊文件</span><br><span class="line">c   字符特殊文件</span><br><span class="line">l    符号链接</span><br><span class="line">f    命名管道</span><br><span class="line">s    套接字文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件权限的表示方法</span><br><span class="line"></span><br><span class="line">    字符权限表示方法</span><br><span class="line">    r    读</span><br><span class="line">    w    写</span><br><span class="line">    x    执行</span><br><span class="line"></span><br><span class="line">    数字权限的表示方法</span><br><span class="line">    r=4</span><br><span class="line">    w=2</span><br><span class="line">    x=1</span><br><span class="line"></span><br><span class="line">文件权限的表示方法</span><br><span class="line">rwxrwxrwx</span><br><span class="line">第一个表示文件属主的权限，第二个表示文件属组的权限，第三个表示其他用户的权限</span><br><span class="line"></span><br><span class="line">创建新文件有默认权限，根据<span class="built_in">umask</span>值计算，属主和属组根据当前进程的用户来设定</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目录权限的标识方法</span><br><span class="line">x    进入目录</span><br><span class="line">rx   显示目录内的文件名</span><br><span class="line">wx  修改目录内的文件名</span><br></pre></td></tr></table></figure><h3 id="文件权限的修改方法和数字表示方法">文件权限的修改方法和数字表示方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">修改权限命令(测试的时候别用root，root不受限制）</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span>    修改文件、目录权限</span><br><span class="line">    <span class="built_in">chmod</span> u+x /tmp/testfile    u表示属主</span><br><span class="line">    <span class="built_in">chmod</span> u=rwx /tmp/testfile  </span><br><span class="line">    <span class="built_in">chmod</span> g-r  /tmp/testfile   g表示属组</span><br><span class="line">    <span class="built_in">chmod</span> 0-r /tmp/testfile    o表示其他用户</span><br><span class="line">    <span class="built_in">chmod</span> a+r /tmp/testfile   a表示所有</span><br><span class="line">    <span class="built_in">chmod</span> 755 /tmp/testfile如果属主没有权限，所属的组有权限，以属主为准，还是没有权限。</span><br><span class="line"><span class="built_in">chown</span>    更改属主、属组</span><br><span class="line">    <span class="built_in">chown</span> user1 /test   把<span class="built_in">test</span>这个目录的属主改成user1</span><br><span class="line">    <span class="built_in">chown</span> :group /test   把<span class="built_in">test</span>这个目录的属组给成group    <span class="built_in">chown</span> user1:group /test   一起修改</span><br><span class="line"><span class="built_in">chgrp</span>    可以单独更改属组、不常用</span><br><span class="line"></span><br><span class="line">linux一般创建一个文件默认会赋予666权限，然后根据用的<span class="built_in">umask</span>值来计算。</span><br><span class="line">用户默认<span class="built_in">umask</span>值为022，所以一般是 666-022=644，对应rw-r--r--</span><br></pre></td></tr></table></figure><h3 id="特殊权限">特殊权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUID  用于二进制可执行文件，执行命令时取得文件属主权限</span><br><span class="line">    如，/usr/bin/passwd</span><br><span class="line"></span><br><span class="line">SGID  用于目录，在该目录下创建新的文件和目录，权限自动更改为该目录的属组</span><br><span class="line">    文件共享时使用</span><br><span class="line">SBIT  用于目录，该目录下新建的文件和目录，仅root和自己可以删除</span><br><span class="line">    如 /tmp</span><br></pre></td></tr></table></figure><h2 id="网络管理">网络管理</h2><p><strong>网卡介绍</strong></p><p>网卡，也被称为网络接口卡（Network Interface Card，NIC），是一种硬件设备，它允许计算机通过网络与其他计算机进行连接和通信。一般来说，网卡被安装在计算机或其他网络设备的扩展插槽中。</p><p>网卡的主要工作是将数据包发送和接收到网络上。它把计算机中的数字信息转化为可以在网络上传输的信号，同时也能把网络上的信号转化为计算机可以理解的数字信息。这个过程被称为“调制”和“解调”。</p><p>每个网卡都有一个全球唯一的物理地址，也叫作MAC地址。这个地址在网卡生产时被厂家写入，用于在网络上唯一标识这个网卡。</p><p>网卡可以按照连接方式分类，有有线网卡和无线网卡两种。有线网卡一般使用以太网线缆（Ethernet Cable）进行连接，而无线网卡则使用无线信号，如Wi-Fi进行连接。</p><h3 id="网络状态查看">网络状态查看</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span>-tools VS iproute</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="built_in">net</span>-tools</span><br><span class="line">    ifconfig</span><br><span class="line">    route</span><br><span class="line">    netstat</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. iproute2</span><br><span class="line">    ip</span><br><span class="line">    ss</span><br></pre></td></tr></table></figure><p>网卡名称</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">ifconfig</span>查看网卡名称</span><br><span class="line">        · <span class="variable">eth0</span> 第一块网卡（网络接口）</span><br><span class="line">        · 你的第一个网络接口可能叫做下面的名字</span><br><span class="line">            · <span class="variable">eno1</span> 板载网卡</span><br><span class="line">            · <span class="variable">ens33</span> <span class="variable">PCI</span><span class="operator">-</span><span class="built_in">E</span>网卡</span><br><span class="line">            · <span class="variable">enp0s3</span> 无法获取物理信息的 <span class="variable">PCI</span><span class="operator">-</span><span class="built_in">E</span> 网卡</span><br><span class="line">            · <span class="variable">CentOS7</span>使用了一致性网络设备命名，以上都不匹配则使用<span class="variable">eth0</span></span><br></pre></td></tr></table></figure><p>PCI-E网卡：</p><p>PCI-E网卡是一种使用PCI Express接口的网络适配器，它是计算机硬件的重要组成部分，负责处理计算机的网络连接。以下是关于PCI-E网卡的一些重点介绍：</p><ol><li><strong>高速性能</strong>：PCI Express接口（也被称为PCI-E或PCIe）是一种高速硬件接口，它提供了比传统的PCI接口更快的数据传输速率。这使得PCI-E网卡在处理大量数据流时，如视频流或大型文件传输等场景，表现出更好的性能。</li><li><strong>向下兼容</strong>：PCI-E网卡可以在所有支持PCI-E接口的主板上使用，无论其它硬件接口版本如何。这使得PCI-E网卡在多种系统配置中具有很好的兼容性。</li><li><strong>易于升级</strong>：由于PCI-E接口采用串行连接方式，它可以很容易地通过增加信道数量来提升带宽，因此，PCI-E网卡在未来的升级中具有很大的潜力。</li><li><strong>多种形式</strong>：PCI-E网卡有多种形式，包括台式机网卡、便携式网卡、无线网卡等，可以满足不同用户的需求。</li></ol><p>请注意，虽然PCI-E网卡具有许多优点，但它可能不适合所有的应用场景。例如，对于一些只需要基本网络连接功能的用户，更便宜、更简单的网络解决方案可能更合适。</p><p>ifconfig看看</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">eno1</span>: flags=<span class="number">4099</span>&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        <span class="attribute">ether</span> <span class="number">9</span>c:c2:c4:<span class="number">04</span>:<span class="number">8</span>a:<span class="number">78</span>  txqueuelen <span class="number">1000</span>  (以太网)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">eno2</span>: flags=<span class="number">4099</span>&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        <span class="attribute">ether</span> <span class="number">9</span>c:c2:c4:<span class="number">04</span>:<span class="number">8</span>a:<span class="number">79</span>  txqueuelen <span class="number">1000</span>  (以太网)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0</span>.<span class="number">0</span> B)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">eno4</span>: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        <span class="attribute">inet</span>【网络地址】 <span class="number">10.168.157.251</span>  netmask【掩码】 <span class="number">255.255.255.0</span>  broadcast <span class="number">10.168.127.255</span></span><br><span class="line">        <span class="attribute">inet6</span> fe80::<span class="number">9</span>ec2:c4ff:fe04:<span class="number">8</span>a7b  prefixlen <span class="number">64</span>  scopeid <span class="number">0</span>x20&lt;link&gt;</span><br><span class="line">        <span class="attribute">ether</span>【mac地址】 <span class="number">9</span>c:c2:c4:<span class="number">04</span>:<span class="number">8</span>a:<span class="number">7</span>b  txqueuelen <span class="number">1000</span>  (以太网)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">404748669</span>  bytes <span class="number">62270812330</span> (<span class="number">62</span>.<span class="number">2</span> GB)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">45412</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">89401903</span>  bytes <span class="number">29846981462</span> (<span class="number">29</span>.<span class="number">8</span> GB)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"><span class="attribute">lo</span>: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        <span class="attribute">inet</span> <span class="number">127.0.0.1</span>  netmask <span class="number">255.0.0.0</span></span><br><span class="line">        <span class="attribute">inet6</span> ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0</span>x10&lt;host&gt;</span><br><span class="line">        <span class="attribute">loop</span>  txqueuelen <span class="number">1000</span>  (本地环回)</span><br><span class="line">        <span class="attribute">RX</span> packets <span class="number">216531961</span>  bytes <span class="number">57623160675</span> (<span class="number">57</span>.<span class="number">6</span> GB)</span><br><span class="line">        <span class="attribute">RX</span> errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        <span class="attribute">TX</span> packets <span class="number">216531961</span>  bytes <span class="number">57623160675</span> (<span class="number">57</span>.<span class="number">6</span> GB)</span><br><span class="line">        <span class="attribute">TX</span> errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure><p>修改网卡命名</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当工作中大量管理网卡，所有设备的网卡最好都是以 eth0 命名，这样可以批量操作。</span><br><span class="line">网络接口命名修改</span><br><span class="line">网卡命名规则受 biosdevname 和 net.ifnames 两个参数影响</span><br><span class="line">编辑 /etc/default/grup 文件，增加 <span class="attribute">biosdevname</span>=0 net.<span class="attribute">ifnames</span>=0</span><br><span class="line">更新 grub</span><br><span class="line">    # grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">重启</span><br><span class="line">    # reboot</span><br><span class="line"></span><br><span class="line">组合，<span class="attribute">biosdevname</span>=0 net.<span class="attribute">ifnames</span>=0，则网卡名为 eth0</span><br><span class="line">     <span class="attribute">biosdevname</span>=1 net.<span class="attribute">ifnames</span>=0，则网卡名为 em1</span><br><span class="line">     <span class="attribute">biosdevname</span>=0 net.<span class="attribute">ifnames</span>=1，则网卡名为 ens33</span><br></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mii-tool eth0  查看网卡物理连接情况</span><br><span class="line">route -<span class="built_in">n</span> 查看网关（路由），使用 -<span class="built_in">n</span> 参数不解析主机名（把ip解析成域名）</span><br></pre></td></tr></table></figure><p>网关基本理解：<a href="https://zhuanlan.zhihu.com/p/165142303">什么是网关，网关的作用是什么？</a>【里面的例子蛮有趣的】</p><p>动手实操：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ route -n</span><br><span class="line">内核 IP 路由表</span><br><span class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</span><br><span class="line">0.0.0.0         10.168.147.10    0.0.0.0         UG    100    0        0 eno4</span><br><span class="line">10.168.147.0    0.0.0.0         255.255.255.0   U     100    0        0 eno4</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 eno4</span><br></pre></td></tr></table></figure><p>网络配置命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig <span class="tag">&lt;<span class="name">接口</span>&gt;</span> <span class="tag">&lt;<span class="name">IP地址</span>&gt;</span> [netmask 子网掩码]      设置网卡的ip地址</span><br><span class="line">ifup <span class="tag">&lt;<span class="name">接口</span>&gt;</span>    启用网卡</span><br><span class="line">ifdown <span class="tag">&lt;<span class="name">接口</span>&gt;</span>    禁用网卡</span><br></pre></td></tr></table></figure><p>网关配置命令</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加网关</span><br><span class="line"><span class="keyword">route</span> add <span class="keyword">default</span> gw <span class="variable">&lt;网关ip&gt;</span></span><br><span class="line"><span class="keyword">route</span> add -host <span class="variable">&lt;指定ip&gt;</span> gw <span class="variable">&lt;网关ip&gt;</span></span><br><span class="line"><span class="keyword">route</span> add -net <span class="variable">&lt;指定网段&gt;</span> netmask <span class="variable">&lt;子网掩码&gt;</span> gw <span class="variable">&lt;网关ip&gt;</span></span><br></pre></td></tr></table></figure><p>网络命令集合：ip命令</p><h3 id="网络故障排除">网络故障排除</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ping 检测是否连接到主机</span><br><span class="line">    ping www<span class="selector-class">.baidu</span><span class="selector-class">.com</span> </span><br><span class="line">traceroute  跟踪当前主机到目标主机的网络状态，-w <span class="number">1</span>超时最多等<span class="number">1</span>秒</span><br><span class="line">    traceroute -w <span class="number">1</span> www<span class="selector-class">.baidu</span><span class="selector-class">.com</span></span><br><span class="line">    </span><br><span class="line">mtr  显示自己主机的网络状态</span><br><span class="line"></span><br><span class="line">nslookup  域名解析成ip</span><br><span class="line">    nslooup www<span class="selector-class">.baidu</span><span class="selector-class">.com</span></span><br><span class="line"></span><br><span class="line">telnet  检测端口</span><br><span class="line">    telnet www<span class="selector-class">.baidu</span><span class="selector-class">.com</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line">tcpdump  网络抓包   -<span class="selector-tag">i</span> any 抓取所有网卡里的数据包，-n 把域名解析成 ip ，port <span class="number">80</span> 抓取指定端口  host <span class="number">10.0</span>.<span class="number">0.1</span> 抓取当前主机到某个主机的数据包</span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n port <span class="number">80</span></span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n host <span class="number">10.0</span>.<span class="number">0.1</span></span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n host <span class="number">10.0</span>.<span class="number">0.1</span> and port <span class="number">80</span></span><br><span class="line">    tcpdump -<span class="selector-tag">i</span> any -n host <span class="number">10.0</span>.<span class="number">0.1</span> and port <span class="number">80</span> -w /tmp/filename 捕获并且保存</span><br><span class="line"></span><br><span class="line">netstat 监听地址 -n 域名转换，-t 显示tcp ，-<span class="selector-tag">p</span> 进程 ，-l  tcp状态 listen</span><br><span class="line">    netstat -ntpl</span><br><span class="line"></span><br><span class="line">ss 跟netstat一样，参数也一样，显示的格式不一样</span><br></pre></td></tr></table></figure><p><strong>ping</strong></p><p>Ping是用来测试网络连接质量的工具。它通过发送ICMP（Internet Control Message Protocol）回显请求消息到目标主机，并等待回显应答。通过测量这个过程的时间，Ping可以帮助我们了解数据包从一台计算机传输到另一台计算机所需要的时间，从而了解网络的延迟情况。此外，Ping还能帮助我们找出丢包的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$<span class="built_in"> ping </span>www.baidu.com<span class="built_in"></span></span><br><span class="line"><span class="built_in">PING </span>www.a.shifen.com (183.2.172.42) 56(84) bytes of data.</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=50 时间=32.6 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=50 时间=33.1 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=50 时间=32.5 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=4 <span class="attribute">ttl</span>=50 时间=32.8 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=5 <span class="attribute">ttl</span>=50 时间=32.6 毫秒</span><br><span class="line">64 字节，来自 183.2.172.42 (183.2.172.42): <span class="attribute">icmp_seq</span>=6 <span class="attribute">ttl</span>=50 时间=32.8 毫秒</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com<span class="built_in"> ping </span>统计 ---</span><br><span class="line">已发送 6 个包， 已接收 6 个包, 0% 包丢失, 耗时 5008 毫秒</span><br><span class="line">rtt min/avg/max/mdev = 32.530/32.750/33.089/0.189 ms</span><br></pre></td></tr></table></figure><p><strong>traceout</strong></p><p>Traceroute是用来追踪数据包在网络上从源主机到目标主机的路径的工具。它通过发送一系列的ICMP请求消息，并记录每一跳的IP地址和传输时间，从而找出数据包在网络中的完整路径。Traceroute对于诊断网络中的路由问题非常有用。</p><p><a href="https://zhuanlan.zhihu.com/p/36811672">traceout原理</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ traceroute -w <span class="number">1</span> www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (<span class="number">183.2</span>.<span class="number">172.42</span>), <span class="number">30</span> hops max, <span class="number">60</span> byte packets</span><br><span class="line"> <span class="number">1</span>  <span class="number">10.168</span>.<span class="number">157.1</span> (<span class="number">10.168</span>.<span class="number">157.1</span>)  <span class="number">0.264</span> <span class="keyword">ms</span>  <span class="title">0</span>.<span class="number">245</span> <span class="keyword">ms</span>  <span class="title">0</span>.<span class="number">235</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">2</span>  * * *</span><br><span class="line"> <span class="number">3</span>  <span class="number">10.168</span>.<span class="number">82.2</span> (<span class="number">10.168</span>.<span class="number">82.2</span>)  <span class="number">1.305</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">775</span> <span class="keyword">ms</span>  <span class="title">2</span>.<span class="number">248</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">4</span>  <span class="number">172.16</span>.<span class="number">255.254</span> (<span class="number">172.16</span>.<span class="number">255.254</span>)  <span class="number">0.897</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">018</span> <span class="keyword">ms</span>  <span class="title">0</span>.<span class="number">795</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">5</span>  <span class="number">113.140</span>.<span class="number">11.1</span> (<span class="number">113.140</span>.<span class="number">11.1</span>)  <span class="number">2.604</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">501</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">590</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">6</span>  <span class="number">10.224</span>.<span class="number">27.5</span> (<span class="number">10.224</span>.<span class="number">27.5</span>)  <span class="number">1.483</span> <span class="keyword">ms</span> <span class="title">10</span>.<span class="number">224.27</span>.<span class="number">9</span> (<span class="number">10.224</span>.<span class="number">27.9</span>)  <span class="number">1.658</span> <span class="keyword">ms</span>  <span class="title">1</span>.<span class="number">715</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">7</span>  <span class="number">1.85</span>.<span class="number">253.45</span> (<span class="number">1.85</span>.<span class="number">253.45</span>)  <span class="number">1.777</span> <span class="keyword">ms</span> <span class="title">1</span>.<span class="number">85.253</span>.<span class="number">53</span> (<span class="number">1.85</span>.<span class="number">253.53</span>)  <span class="number">1.764</span> <span class="keyword">ms</span> <span class="title">*</span></span><br><span class="line"><span class="title"> 8</span>  * <span class="number">202.97</span>.<span class="number">36.109</span> (<span class="number">202.97</span>.<span class="number">36.109</span>)  <span class="number">31.468</span> <span class="keyword">ms</span> <span class="title">202</span>.<span class="number">97.13</span>.<span class="number">253</span> (<span class="number">202.97</span>.<span class="number">13.253</span>)  <span class="number">29.065</span> <span class="keyword">ms</span></span><br><span class="line"> <span class="title">9</span>  <span class="number">113.96</span>.<span class="number">4.74</span> (<span class="number">113.96</span>.<span class="number">4.74</span>)  <span class="number">33.720</span> <span class="keyword">ms</span> <span class="title">* *</span></span><br><span class="line"><span class="title">10</span>  * * *</span><br><span class="line"><span class="number">11</span>  <span class="number">14.29</span>.<span class="number">117.178</span> (<span class="number">14.29</span>.<span class="number">117.178</span>)  <span class="number">31.263</span> <span class="keyword">ms</span> <span class="title">14</span>.<span class="number">29.117</span>.<span class="number">170</span> (<span class="number">14.29</span>.<span class="number">117.170</span>)  <span class="number">39.950</span> <span class="keyword">ms</span>  <span class="title">37</span>.<span class="number">211</span> <span class="keyword">ms</span></span><br><span class="line"><span class="title">12</span>  * * *</span><br><span class="line"><span class="number">13</span>  * * *</span><br><span class="line"><span class="number">14</span>  * * *</span><br><span class="line"><span class="number">15</span>  * * *</span><br></pre></td></tr></table></figure><p><strong>Ping与Traceroute的区别</strong>：<br>主要区别在于Ping主要用于测试网络连接的质量（如延迟和丢包），而Traceroute主要用于追踪数据包的路径。Ping只告诉你数据包是否能够到达目标主机，以及这个过程需要多长时间，但它不能告诉你数据包到达目标主机的具体路径。而Traceroute则能详细地展示数据包从源主机到目标主机的每一跳路径，有助于我们了解网络的结构和找出可能存在的路由问题。</p><p><strong>mtr</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv</span><span class="variable">$ </span>mtr                                                       <span class="title class_">My</span> traceroute  [v0.<span class="number">93</span>]</span><br><span class="line">sv-<span class="variable constant_">NF5280M5</span> (<span class="number">127.0</span>.<span class="number">0.1</span>)                                                                                     <span class="number">2024</span>-<span class="number">05</span>-10<span class="symbol">T16:</span><span class="number">29</span><span class="symbol">:</span><span class="number">13</span>+0800</span><br><span class="line"><span class="title class_">Keys</span>:  <span class="title class_">Help</span>   <span class="title class_">Display</span> mode   <span class="title class_">Restart</span> statistics   <span class="title class_">Order</span> of fields   quit</span><br><span class="line">                                                                                            <span class="title class_">Packets</span>               <span class="title class_">Pings</span></span><br><span class="line"> <span class="title class_">Host</span>                                                                                     <span class="title class_">Loss</span>%   <span class="title class_">Snt</span>   <span class="title class_">Last</span>   <span class="title class_">Avg</span>  <span class="title class_">Best</span>  <span class="title class_">Wrst</span> <span class="title class_">StDev</span></span><br><span class="line"> <span class="number">1</span>. localhost                                                                              <span class="number">0.0</span>%     <span class="number">9</span>    <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><strong>netstat</strong></p><p>netstat是一个非常实用的命令，它可以帮助我们了解我们的系统网络状态。以下是一些基本的使用方法：</p><ol><li><strong>显示网络状态</strong>：netstat 命令可以显示网络状态，它通常用于问题确定而不是性能测量。但是，netstat 命令可用于确定网络上的流量，以确定性能问题是否是由于网络拥塞引起的。在 netstat 关于所配置的网络接口，诸如以下的流量命令显示信息：与所有sockets关联的信息。详情请参考<a href="https://zhuanlan.zhihu.com/p/367635200">此链接</a>。</li><li><strong>网络统计工具</strong>：netstat 是一个网络分析工具，用于显示网络连接、路由表、接口统计、伪装连接和多播成员资格等信息。然而随着时间的推移，一些Linux发行版已经开始用像ss, ip这样的更现代的工具代替netstat。详情请参考<a href="https://blog.csdn.net/u012964600/article/details/137612961">此链接</a>。</li><li><strong>显示端口和网络统计数据</strong>：netsta命令是一个CLI工具，用于网络统计。它提供了网络活动的概览，并显示哪些端口是开放的或已建立连接。netstat 工具对于发现网络问题至关重要。详情请参考<a href="https://phoenixnap.com/kb/netstat-command">此链接</a>。</li></ol><p>在使用 netstat 命令时，需要注意的是，由于其强大的功能，可能需要管理员权限才能获取完整的网络状态信息。</p><p>网络管理和配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网络服务管理程序分为两种，分别是 SysV 和 systemd(centos7)</span><br><span class="line">service network status|start|stop|restart</span><br><span class="line"></span><br><span class="line">网络配置文件</span><br><span class="line"></span><br><span class="line"><span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0 （网卡配置项）</span><br><span class="line"><span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>常用命令</p><p>下面是一些常见的<code>netstat</code>操作：</p><ol><li>显示所有活动的网络连接：<code>netstat</code>命令默认就可以显示当前系统的所有网络连接信息。</li><li>显示监听的服务器套接字：<code>netstat -l</code>可以显示所有正在监听的服务器套接字。</li><li>显示路由表：<code>netstat -r</code>可以显示路由表，这对于诊断网络问题非常有用。</li><li>显示每个协议的统计信息：<code>netstat -s</code>可以显示每个网络协议的统计信息，如TCP、UDP、ICMP等。</li><li>显示网络接口的统计信息：<code>netstat -i</code>可以显示每个网络接口的统计信息，如发送和接收的数据包数量等。</li></ol><h3 id="软件包管理">软件包管理</h3><p><strong>软件包管理器</strong></p><p>包管理器是方便软件安装、卸载，解决软件依赖关系的重要工具。</p><ul><li>CentOS 和 RedHat 使用 yum 包管理器，软件安装包格式为 rpm</li><li>Debian、Ubuntu使用 apt 包管理器，软件安装包格式为 deb</li></ul><p><strong>使用rpm命令安装软件包</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240510193643483.png" alt="image-20240510193643483"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm 命令常用参数</span><br><span class="line">    -<span class="selector-tag">q</span> 查询软件包　　　　rpm -qa 查询所有软件包　　　　rpm -<span class="selector-tag">q</span> vim-common 查询某个软件包</span><br><span class="line">    -<span class="selector-tag">i</span>  安装软件包　　　　rpm -<span class="selector-tag">i</span> vim-enhanced-<span class="number">7.4</span>.<span class="number">160</span>-<span class="number">5</span><span class="selector-class">.el7</span><span class="selector-class">.x84_64</span><span class="selector-class">.rpm</span>  （要全称）</span><br><span class="line">    -e 卸载软件包　　　　rpm -e vim-enhanced   （只要名字，不需要版本号等）用 rpm 安装的问题：如果一个软件包依赖其他软件包，那么就会安装失败。需要操作者自己解决依赖关系。</span><br></pre></td></tr></table></figure><p><strong>使用yum包管理器安装软件包</strong></p><p>rpm 包的问题</p><ul><li>需要自己解决依赖关系</li><li>软件包来源不可靠</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CentOS yum源</span><br><span class="line">    http:<span class="regexp">//mi</span>rror.centos.org<span class="regexp">/centos/</span><span class="number">7</span>/</span><br><span class="line">国内镜像</span><br><span class="line">    https:<span class="regexp">//</span>opsx.alibaba.com/mirror</span><br><span class="line">yum 配置文件</span><br><span class="line">    <span class="regexp">/etc/yum</span>.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">可以修改配置文件</span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base -mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">            http:<span class="regexp">//mi</span>rrors.aliyuncs.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">             http:<span class="regexp">//mi</span>rrors.cloud.aliyuncs.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/centos/</span>RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br><span class="line">或者直接用别人已经写好的配置文件</span><br><span class="line">wget -O <span class="regexp">/etc/yum</span>.repo.d<span class="regexp">/CentOS-Base.repo http:/</span><span class="regexp">/mirrors.aliyun.com/</span>repo/Centos-<span class="number">7</span>.repo需要清除缓存yum makecache</span><br></pre></td></tr></table></figure><p>yum 命令常用选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用选项</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span> 安装软件包</span><br><span class="line"><span class="keyword">remove</span> 卸载软件包</span><br><span class="line"><span class="keyword">list</span> |grouplist 查看软件包</span><br><span class="line">update 升级软件包</span><br></pre></td></tr></table></figure><h3 id="其他方式安装">其他方式安装</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二进制安装</span><br><span class="line">源代码编译安装</span><br><span class="line"></span><br><span class="line">wget https:<span class="comment">//openresty.org/download/openresty-1.15.8.1.tar.gz</span></span><br><span class="line">tar zxf openresty-<span class="keyword">VERSION</span>.tar.gz</span><br><span class="line"><span class="keyword">cd</span> openresty-<span class="keyword">VERSION</span>/</span><br><span class="line">./configure --prefix=/usr/<span class="keyword">local</span>/openresty</span><br><span class="line">make -j2   （用2核编译）</span><br><span class="line">make isntall</span><br></pre></td></tr></table></figure><h3 id="升级内核">升级内核</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">rpm 格式内核</span><br><span class="line">    查看内核版本</span><br><span class="line">        uname -r</span><br><span class="line">    升级内核版本</span><br><span class="line">        yum install kernel-<span class="number">3.10</span>.<span class="number">0</span>   这种方式一般不能升级到最新</span><br><span class="line">        epel软件仓库会有较高的软件版本。yum install epel-release -<span class="keyword">y</span></span><br><span class="line">    升级已安装的其他软件包和补丁</span><br><span class="line">        yum <span class="keyword">update</span>    除了升级内核，还会升级软件包。正常不要使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">源代码编译安装内核</span><br><span class="line">yum install gcc gcc-<span class="keyword">c</span>++ <span class="keyword">make</span> ncurses-devel openssl-devel elfutils-libelf-devel</span><br><span class="line"></span><br><span class="line">下载并解压缩内核</span><br><span class="line">https://www.kernel.org</span><br><span class="line">tar xvf linux-<span class="number">5.1</span>.<span class="number">10</span>.tar.xz -C /usr/src/kernels</span><br><span class="line"></span><br><span class="line">配置内核编译参数</span><br><span class="line"><span class="keyword">cd</span> /usr/src/kernels/linux-<span class="number">5.1</span>.<span class="number">10</span>/</span><br><span class="line"><span class="keyword">make</span> menuconfig | allyesconfig | allnoconfig</span><br><span class="line"><span class="keyword">make</span> allyesconfig （无脑全选）</span><br><span class="line"></span><br><span class="line">使用当前系统内核配置</span><br><span class="line"><span class="keyword">cp</span> /boot/config-kernelversion.platform /usr/src/kernels/linux-<span class="number">5.1</span>.<span class="number">10</span>/.config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看cpu</span><br><span class="line">lscpu</span><br><span class="line"></span><br><span class="line">编译</span><br><span class="line"><span class="keyword">make</span> j2 <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">安装内核</span><br><span class="line"><span class="keyword">make</span> modules_install</span><br><span class="line"><span class="keyword">make</span> install</span><br></pre></td></tr></table></figure><p>这篇教程详细记录了每个步骤：<a href="https://blog.csdn.net/weixin_42888638/article/details/127288997?spm=1001.2014.3001.5501">linux内核编译记录</a></p><h2 id="进程管理">进程管理</h2><h3 id="进程的概念与进程查看">进程的概念与进程查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进程-运行中的程序，从程序开始运行到终止的整个生命周期是可管理的</span><br><span class="line"></span><br><span class="line">查看命令</span><br><span class="line">ps</span><br><span class="line">    -e 表示所有的终端运行的进程</span><br><span class="line">    -f  显示更多信息，比如 UID、PPID（父进程）、CMD（命令的完整路径）</span><br><span class="line">    -L  多显示 LWP ，线程信息</span><br><span class="line">    ps -eLf  常用命令</span><br><span class="line"></span><br><span class="line">pstree  查看进程树</span><br><span class="line">    </span><br><span class="line">top  动态查看进程信息top -p 进程号</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">进程也是树形结构</span><br><span class="line">进程和权限有着密不可分的关系</span><br></pre></td></tr></table></figure><p>ps</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv</span><span class="variable">$ </span>ps</span><br><span class="line">    <span class="variable constant_">PID</span> <span class="variable constant_">TTY</span>          <span class="variable constant_">TIME</span> <span class="variable constant_">CMD</span></span><br><span class="line"><span class="number">1221450</span> pts/<span class="number">1</span>    <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">03</span> bash</span><br><span class="line"><span class="number">1247704</span> pts/<span class="number">1</span>    <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> ps</span><br></pre></td></tr></table></figure><p>“pts/1” 是一种特殊的终端设备文件，表示的是一种伪终端（Pseudo-Terminal Slave）。在这里，“pts” 是伪终端的缩写，数字 “1” 是这个伪终端的编号。</p><ul><li><a href="https://linux265.com/course/linux-command-ps.html#:~:text=ps%E5%91%BD%E4%BB%A4%20-%20Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%20%7C%20linux%E6%95%99%E7%A8%8B%20ps%E5%91%BD%E4%BB%A4,protoize%E5%91%BD%E4%BB%A4%20pssh%E5%91%BD%E4%BB%A4%20ps%E5%91%BD%E4%BB%A4%E6%98%AF%E2%80%9Cprocess%20status%E2%80%9D%E7%9A%84%E7%BC%A9%E5%86%99%EF%BC%8Cps%E5%91%BD%E4%BB%A4%E7%94%A8%E4%BA%8E%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E3%80%82%20%E5%8F%AF%E4%BB%A5%E6%90%AD%E9%85%8Dkill%E6%8C%87%E4%BB%A4%E9%9A%8F%E6%97%B6%E4%B8%AD%E6%96%AD%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%82%20ps%E5%91%BD%E4%BB%A4%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E5%90%8C%E6%97%B6%E4%B9%9F%E6%98%AF%E9%9D%9E%E5%B8%B8%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E7%A1%AE%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%81%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%93%E6%9D%9F%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9C%89%E6%B2%A1%E6%9C%89%E5%83%B5%E6%AD%BB%E3%80%81%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E4%BA%86%E8%BF%87%E5%A4%9A%E7%9A%84%E8%B5%84%E6%BA%90%E7%AD%89%E7%AD%89%EF%BC%8C%E6%80%BB%E4%B9%8B%E5%A4%A7%E9%83%A8%E5%88%86%E4%BF%A1%E6%81%AF%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4%E5%BE%97%E5%88%B0%E7%9A%84%E3%80%82">ps命令</a></li></ul><p><strong>top</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240510195736332.png" alt="image-20240510195736332"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一行 </span><br><span class="line">    <span class="number">34</span><span class="built_in">min</span> 表示这台机器已经启动<span class="number">34</span>分钟没有关机了</span><br><span class="line">    <span class="number">2</span>users 表示有<span class="number">2</span>个用户登录</span><br><span class="line">    平均负载：<span class="number">1</span>分钟，<span class="number">5</span>分钟，<span class="number">15</span>分钟</span><br><span class="line"></span><br><span class="line">第二行</span><br><span class="line">    一共运行的任务，几个在running ，几个在sleeping</span><br><span class="line"></span><br><span class="line">第三行（平均值，按 <span class="number">1</span> 会把所有 逻辑cpu 的使用情况列出来）</span><br><span class="line">    <span class="number">2.8</span> us  <span class="number">1.8</span> <span class="keyword">sy</span> <span class="number">97.7</span> id <span class="number">0.0</span> <span class="keyword">wa</span></span><br><span class="line">    us 表示用户计算，<span class="keyword">sy</span>表示进程之间状态交互，id表示空闲，<span class="keyword">wa</span>表示磁盘等待</span><br><span class="line"></span><br><span class="line">第四行</span><br><span class="line">    内存状态</span><br><span class="line">第五行</span><br><span class="line">    交换分区（虚拟内存）</span><br></pre></td></tr></table></figure><p>进程的优先级调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">调整优先级</span><br><span class="line">    <span class="built_in">nice</span> 范围从 -20 到 19，值越小优先级越高，抢占资源就越多</span><br><span class="line">        <span class="built_in">nice</span> -n 10 ./rest.sh  启动的时候调整为 10</span><br><span class="line">    renice 重新设置优先级</span><br><span class="line">        renice -n 15 19312  已经处于启动的情况下进行调整。根据进程号</span><br><span class="line">进程的作业控制</span><br><span class="line">    &amp;符号，后台运行</span><br><span class="line">        ./test.sh &amp;</span><br><span class="line">    <span class="built_in">jobs</span> 把处于后台运行的程序调到前台显示</span><br><span class="line">        <span class="built_in">jobs</span> 能得到一个编号</span><br><span class="line">        <span class="built_in">fg</span> 编号，可以调到前台</span><br><span class="line">    ctrl +z，把已经处于前台的程序调到后台，状态会stop</span><br></pre></td></tr></table></figure><h3 id="进程的通信方式-信号">进程的通信方式-信号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">信号是进程间通信方式之一，典型用法是：终端用户输入中断命令，通过信号机制停止一个程序的运行。</span><br><span class="line">使用信号的常用快捷键和命令</span><br><span class="line"><span class="built_in">kill</span> -l 查看所有的信号</span><br><span class="line">    SIGINT 通知前台进程组终止进程 ctrl + c，2号信号</span><br><span class="line">    SIGKILL 立即结束程序，不能被阻塞和处理 <span class="built_in">kill</span> -9 pid ，9号信号 </span><br></pre></td></tr></table></figure><h3 id="守护进程和系统日志">守护进程和系统日志</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">守护进程（精灵进程）</span><br><span class="line"></span><br><span class="line">使用 nohup 与 &amp; 符号配合运行一个命令 （nohup进程不是守护进程）</span><br><span class="line">    nohup 命令使进程忽略 hangup（挂起）信号。关掉终端这个进程依然可以运行，忽略输入并且把输出打印到 nohup.out</span><br><span class="line">守护进程（daemon）和一般进程有什么差别呢？</span><br><span class="line">    开机自启，守护进程不需要终端，输出可以打印到特殊的文件中，进程所占用的目录是根目录。<span class="keyword">cd</span> /<span class="keyword">proc</span>/ 这个目录是内存信息，相应的进程会有进程号同名的目录。</span><br><span class="line"></span><br><span class="line">使用<span class="title"> screen</span> 命令，进入screen环境后，如果远程连接断掉了，可以通过screen恢复工作现场<span class="title"></span></span><br><span class="line"><span class="title">    screen</span> 进入<span class="title"> screen</span> 环境<span class="title"></span></span><br><span class="line"><span class="title">    ctrl</span> +a然后再单独按d退出（detached）screen 环境<span class="title"></span></span><br><span class="line"><span class="title">    screen</span> -ls 查看<span class="title"> screen</span> 的会话<span class="title"></span></span><br><span class="line"><span class="title">    screen</span> -r<span class="title"> sessionid</span> 恢复会话系统日志文件 /var/log系统常规日志：messages内核运行情况：dmesg安全日志<span class="title">  secure定时任务日志</span> cron</span><br></pre></td></tr></table></figure><h3 id="服务管理工具systermctl">服务管理工具systermctl</h3><p>服务（提供常见功能的守护进程）集中管理工具</p><ul><li>service</li><li>systemctl（centos7以后的，可以看做service进化版）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">service 启动脚本</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/ 目录下</span><br><span class="line">vim network 可以查看network的启动脚本，200多行，完全由编写人员自己控制，比较复杂；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl 启动脚本</span><br><span class="line"><span class="built_in">cd</span> /usr/lib/systemd/system/</span><br><span class="line">vim sshd.service</span><br><span class="line"></span><br><span class="line">原有的init，linux的1号进程</span><br><span class="line">init 0 关机 （不能用<span class="built_in">kill</span> -9杀掉这个进程，只能0结束这个进程，进而关机）</span><br><span class="line">init 6 重启</span><br><span class="line">init  3 字符终端</span><br><span class="line">init 5 图形界面</span><br><span class="line"></span><br><span class="line">systemctl 常见操作</span><br><span class="line">systemctl status|start|stop|restart|reload|<span class="built_in">enable</span>|<span class="built_in">disable</span> 服务名称  </span><br><span class="line">1、restart 和reload差别，reload不停服务，直接重启</span><br><span class="line">2、<span class="built_in">enable</span>开机启动，<span class="built_in">disable</span>不开机启动</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/qq_41308872/article/details/133743091">完全指南：systemctl命令及服务管理技巧</a></li></ul><p>启动Docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><h3 id="SELinux">SELinux</h3><p>MAC（强制访问控制）和DAC（自主访问控制）。SELinux就是 MAC，生产环境不太用，比较麻烦。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">根据进程pid查端口</span><br><span class="line"><span class="title">lsof</span> -i |grep pid</span><br><span class="line"></span><br><span class="line">根据端口<span class="keyword">port</span>查进程</span><br><span class="line">lsof -i:<span class="keyword">port</span></span><br><span class="line"></span><br><span class="line">根据进程pid查端口</span><br><span class="line">netstat -nap |grep pid</span><br><span class="line"></span><br><span class="line">根据端口<span class="keyword">port</span>查进程</span><br><span class="line">netstat -nap |grep <span class="keyword">port</span></span><br></pre></td></tr></table></figure><h2 id="内存和磁盘管理">内存和磁盘管理</h2><h3 id="内存和磁盘使用率查看">内存和磁盘使用率查看</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存使用率查看</span><br><span class="line">free</span><br><span class="line">    -m  以兆的方式显示</span><br><span class="line">    -g   以G的方式显示，但是会被四舍五入。一般不用</span><br><span class="line"><span class="built_in">top</span></span><br></pre></td></tr></table></figure><p>看看电脑先</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free -m apport.log</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：      <span class="number"> 64029 </span>     <span class="number"> 20697 </span>      <span class="number"> 2641 </span>       <span class="number"> 789 </span>     <span class="number"> 40690 </span>      41890</span><br><span class="line">交换：       <span class="number"> 2047 </span>       <span class="number"> 894 </span>       1153</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：   <span class="number"> 65566072 </span>  <span class="number"> 21394584 </span>   <span class="number"> 2503952 </span>    <span class="number"> 808044 </span>  <span class="number"> 41667536 </span>   42695292</span><br><span class="line">交换：    <span class="number"> 2097148 </span>    <span class="number"> 916176 </span>    1180972</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ free -g</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：         <span class="number"> 62 </span>        <span class="number"> 20 </span>         <span class="number"> 2 </span>         <span class="number"> 0 </span>        <span class="number"> 39 </span>         40</span><br><span class="line">交换：          <span class="number"> 1 </span>         <span class="number"> 0 </span>          1</span><br></pre></td></tr></table></figure><p>交换空间（Swap Space）是硬盘上的一块区域，它被操作系统用作虚拟内存，用来临时存放内存中的数据。当系统的物理内存用完时，操作系统会将一些不常用的数据移动到交换空间，从而释放出物理内存给需要的程序使用。</p><p>不用Swap的话就随机杀掉。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">磁盘使用率的查看</span><br><span class="line">fdisk</span><br><span class="line">    -l 查看</span><br><span class="line">    磁盘分区一块硬盘最多分15个分区</span><br></pre></td></tr></table></figure><p>实操</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo fdisk -l</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">Disk /dev/loop1：4 KiB，4096 字节，8 个扇区</span><br><span class="line">单元：扇区 /<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/loop2：6.77 MiB，7081984 字节，13832 个扇区</span><br><span class="line">单元：扇区 /<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/loop3：40.44 MiB，42393600 字节，82800 个扇区</span><br><span class="line">单元：扇区 /<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 /<span class="number"> 512 </span>字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 /<span class="number"> 512 </span>字节</span><br></pre></td></tr></table></figure><blockquote><p>问个问题，为什么要对磁盘分区？</p></blockquote><p>磁盘分区基本上是把一个磁盘分成一个或多个逻辑磁盘。每个分区都像一个独立的硬盘一样，有自己的文件系统。在操作系统中，磁盘分区通常被表示为不同的驱动器，如C盘、D盘等。对磁盘进行分区的原因主要有以下几点：</p><ol><li><strong>提高磁盘效率</strong>：文件系统通常会在磁盘上留有一些空间，这样可以提高读写速度。如果你只有一个大的分区，那么这个空间可能就会浪费很多。如果你有多个小的分区，那么每个分区的空间都会更加合理地利用。</li><li><strong>数据安全</strong>：如果你的操作系统崩溃，那么可能会损坏整个文件系统。如果你有多个分区，那么一个分区的损坏不会影响其他分区。这样，你的数据就更安全了。</li><li><strong>多操作系统</strong>：如果你想在一台计算机上安装多个操作系统，那么你需要为每个操作系统创建一个分区。这样，每个操作系统都可以在自己的分区上运行，互不干扰。</li><li><strong>文件组织</strong>：分区可以帮助你更好地组织文件。例如，你可以在一个分区上存储系统文件，在另一个分区上存储个人文件。这样，即使系统分区出现问题，你的个人文件也不会受到影响。</li></ol><p>以上就是对磁盘进行分区的主要原因。</p><p><strong>每个磁盘分区都可以被格式化为一个独立的文件系统。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> 既能够看到分区，又能够看到挂载到的目录</span><br><span class="line">    -h 人性化可读</span><br><span class="line">系统中各个文件系统的磁盘使用情况</span><br></pre></td></tr></table></figure><p>实操</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="symbol">NF5280M5:</span>/dev<span class="variable">$ </span>df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev             <span class="number">32</span>G     <span class="number">0</span>   <span class="number">32</span>G    <span class="number">0</span>% <span class="regexp">/dev</span></span><br><span class="line"><span class="regexp">tmpfs           6.3G  2.8M  6.3G    1% /run</span></span><br><span class="line"><span class="regexp">/dev/sda</span>2       <span class="number">439</span>G  <span class="number">253</span>G  <span class="number">165</span>G   <span class="number">61</span>% <span class="regexp">/</span></span><br><span class="line"><span class="regexp">tmpfs            32G  396K   32G    1% /dev</span><span class="regexp">/shm</span></span><br><span class="line"><span class="regexp">tmpfs           5.0M  4.0K  5.0M    1% /run</span><span class="regexp">/lock</span></span><br><span class="line"><span class="regexp">tmpfs            32G     0   32G    0% /sys</span><span class="regexp">/fs/cgroup</span></span><br><span class="line"><span class="regexp">/dev/loop</span>1      <span class="number">128</span>K  <span class="number">128</span>K     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/bare</span><span class="regexp">/5</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop4       56M   56M     0  100% /snap</span><span class="regexp">/core18/</span><span class="number">2812</span></span><br><span class="line"><span class="regexp">/dev/loop</span>5       <span class="number">64</span>M   <span class="number">64</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/core</span>20/<span class="number">2182</span></span><br><span class="line"><span class="regexp">/dev/loop</span>6       <span class="number">75</span>M   <span class="number">75</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/core</span>22/<span class="number">1122</span></span><br><span class="line"><span class="regexp">/dev/loop</span>18     <span class="number">350</span>M  <span class="number">350</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">38</span>-<span class="number">2004</span>/<span class="number">140</span></span><br><span class="line"><span class="regexp">/dev/loop</span>17      <span class="number">13</span>M   <span class="number">13</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snap</span>-store/<span class="number">959</span></span><br><span class="line"><span class="regexp">/dev/loop</span>13     <span class="number">350</span>M  <span class="number">350</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">38</span>-<span class="number">2004</span>/<span class="number">143</span></span><br><span class="line"><span class="regexp">/dev/loop</span>19      <span class="number">92</span>M   <span class="number">92</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gtk</span>-common-themes/<span class="number">1535</span></span><br><span class="line"><span class="regexp">/dev/loop</span>14     <span class="number">219</span>M  <span class="number">219</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">34</span>-<span class="number">1804</span>/<span class="number">90</span></span><br><span class="line"><span class="regexp">/dev/loop</span>12      <span class="number">82</span>M   <span class="number">82</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gtk</span>-common-themes/<span class="number">1534</span></span><br><span class="line"><span class="regexp">/dev/loop</span>10     <span class="number">219</span>M  <span class="number">219</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">3</span>-<span class="number">34</span>-<span class="number">1804</span>/<span class="number">93</span></span><br><span class="line"><span class="regexp">/dev/sda</span>1       <span class="number">511</span>M  <span class="number">6.1</span>M  <span class="number">505</span>M    <span class="number">2</span>% <span class="regexp">/boot/efi</span></span><br><span class="line"><span class="regexp">/dev/sdb</span>2       <span class="number">3.6</span>T  <span class="number">420</span>G  <span class="number">3.0</span>T   <span class="number">13</span>% <span class="regexp">/data</span></span><br><span class="line"><span class="regexp">tmpfs           6.3G   76K  6.3G    1% /run</span><span class="regexp">/user/</span><span class="number">1000</span></span><br><span class="line"><span class="regexp">/dev/loop</span>21      <span class="number">40</span>M   <span class="number">40</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snapd</span><span class="regexp">/21184</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop2      6.9M  6.9M     0  100% /snap</span><span class="regexp">/ngrok/</span><span class="number">138</span></span><br><span class="line"><span class="regexp">/dev/loop</span>9      <span class="number">505</span>M  <span class="number">505</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">42</span>-<span class="number">2204</span>/<span class="number">172</span></span><br><span class="line"><span class="regexp">/dev/loop</span>16      <span class="number">13</span>M   <span class="number">13</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snap</span>-store/<span class="number">1113</span></span><br><span class="line"><span class="regexp">/dev/loop</span>20      <span class="number">64</span>M   <span class="number">64</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/core</span>20/<span class="number">2264</span></span><br><span class="line"><span class="regexp">/dev/loop</span>11     <span class="number">506</span>M  <span class="number">506</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/gnome</span>-<span class="number">42</span>-<span class="number">2204</span>/<span class="number">176</span></span><br><span class="line"><span class="regexp">/dev/loop</span>22     <span class="number">7.0</span>M  <span class="number">7.0</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/ngrok</span><span class="regexp">/148</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop15      75M   75M     0  100% /snap</span><span class="regexp">/core22/</span><span class="number">1380</span></span><br><span class="line"><span class="regexp">/dev/loop</span>8       <span class="number">39</span>M   <span class="number">39</span>M     <span class="number">0</span>  <span class="number">100</span>% <span class="regexp">/snap/snapd</span><span class="regexp">/21465</span></span><br><span class="line"><span class="regexp">/dev</span><span class="regexp">/loop23      56M   56M     0  100% /snap</span><span class="regexp">/core18/</span><span class="number">2823</span></span><br></pre></td></tr></table></figure><ul><li><p>在Linux系统中，<code>tmpfs</code>、<code>udev</code>和<code>/dev/sda2</code>都是你的系统挂载点上的文件系统。</p><ol><li><p><strong>tmpfs</strong>：tmpfs是一种基于内存的文件系统，它将一部分RAM作为一个挂载点，允许你像操作磁盘分区一样操作内存。因为它存储在内存中，所以读写速度非常快。然而，一旦系统重启，存储在tmpfs中的所有数据都会丢失。</p></li><li><p><strong>udev</strong>：udev文件系统是一个动态设备管理器，它管理<code>/dev</code>目录下的设备节点。udev允许设备管理工作在用户空间中完成，提供了一种灵活的方式来管理设备节点，并允许通过设备的物理属性或者热插拔事件来改变设备的配置。</p><ul><li><p>udev就是这样的一个动态设备管理器。当一个设备被接入到系统中，udev会根据设备的类型和属性，动态地在<code>/dev</code>目录下创建一个设备节点，这样应用程序就可以通过这个设备节点来访问设备。当设备被移除时，udev会删除对应的设备节点。</p><p>例如，当你插入一个USB设备时，udev会在<code>/dev</code>下创建一个像是<code>sdb1</code>的设备节点，你就可以通过这个设备节点来访问你的USB设备。当你移除USB设备时，<code>/dev/sdb1</code>这个设备节点就会被删除。</p></li></ul></li><li><p><strong>/dev/sdaX</strong>：<code>/dev/sda2</code> 和 <code>/dev/sdb2</code> 这两个设备。这里的 <code>sda</code> 和 <code>sdb</code> 分别代表系统中的第一块和第二块硬盘，而后面的数字 <code>2</code> 表示的是这个硬盘上的第二个分区。</p></li></ol><p>至于为什么你在<code>fdisk -l</code>的输出中看不到这些分区，<strong>这是因为<code>fdisk</code>只显示物理磁盘分区</strong>，而不显示基于内存的文件系统（如tmpfs）或特殊的文件系统（如udev）。你可以使用<code>df -h</code>或<code>mount</code>命令来查看所有的挂载点和文件系统，包括<code>tmpfs</code>和<code>udev</code>。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> （实际占用的空间）</span><br><span class="line">    -h 人性化显示</span><br><span class="line">    -s  只显示总计</span><br></pre></td></tr></table></figure><p>挂载点就是这些物理设备在文件系统中的位置。当一个设备被&quot;挂载&quot;到一个挂载点时，这个设备的内容就可以通过访问这个挂载点来访问了。</p><p>举个例子，如果你插入一个USB驱动器，系统可能会自动将这个驱动器挂载到<code>/media/your_username/usb_drive</code>这个目录下，那么你就可以通过访问这个目录来查看和操作这个USB驱动器的内容。</p><p><strong>du与ls的区别</strong><br><strong>du 是实际占用的，ls算上空洞数据。</strong></p><h3 id="常见文件系统">常见文件系统</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux 支持多种文件系统，常见的有</span><br><span class="line">ext4（centos6）</span><br><span class="line">xfs（centos7）</span><br><span class="line">NTFS（需安装额外软件，<span class="built_in">window</span>常用，有版权）</span><br></pre></td></tr></table></figure><p>ext4文件系统</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ext4文件系统基本结构比较复杂</span><br><span class="line">超级块</span><br><span class="line">超级块副本</span><br><span class="line"><span class="selector-tag">i</span>节点（inode）</span><br><span class="line">数据块（datablock）</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>du -h utils.py</span><br><span class="line"><span class="number">4</span>.0K    utils.py</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -l utils.py</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">3322</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">15</span><span class="symbol">:</span><span class="number">51</span> utils.py</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -li utils.py</span><br><span class="line"><span class="number">19200499</span> -rw-r--r-- <span class="number">1</span> root root <span class="number">3322</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">15</span><span class="symbol">:</span><span class="number">51</span> utils.py</span><br></pre></td></tr></table></figure><blockquote><p>为社么vim会改变i节点，echo不会改变i节点</p></blockquote><p>Vim和echo命令在处理文件时的行为确实有所不同。</p><p>当你使用Vim编辑并保存一个文件时，Vim实际上是创建了一个新的文件来替代旧的文件。这个新文件会有一个新的i节点，所以你会看到i节点的数值发生了变化。</p><p>这样做的好处是，如果在保存文件时发生错误（比如磁盘空间不足），你仍然可以保留原来的文件，不会丢失数据。同时，Vim还会记录下每次修改的时间和用户等信息。</p><p>相比之下，echo命令则更简单。它直接将输出追加到文件中，不会创建新的文件，因此i节点的数值不会改变。</p><p>另外，文件的权限也可能影响i节点的变化。如果文件没有写权限，Vim在保存时会创建新的文件，从而改变i节点。如果你给文件添加了写权限（比如使用<code>chmod o+w filename</code>命令），则Vim在保存时不会改变i节点。</p><p>总的来说，这两个命令在处理文件时的行为差异，反映了它们的设计理念和使用场景的不同。Vim是一个功能强大的文本编辑器，它提供了丰富的编辑功能和数据保护机制；而echo更多地被用来在脚本中输出文本或者简单地向文件中追加内容。</p><p><strong>rm只是将i节点和数据块断开</strong></p><p>因此有了ln命令，看个例子，硬链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 1 root root 3322 11月 17 15:51 utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 1 root root 3322 11月 17 15:51 utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ln</span> utils.py utils1.py</span><br><span class="line"><span class="built_in">ln</span>: 无法创建硬链接 <span class="string">&#x27;utils1.py&#x27;</span> =&gt; <span class="string">&#x27;utils.py&#x27;</span>: 不允许的操作</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 1 root root 3322 11月 17 15:51 utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ sudo <span class="built_in">ln</span> utils.py utils1.py</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span> -li utils.py</span><br><span class="line">19200499 -rw-r--r-- 2 root root 3322 11月 17 15:51 utils.py</span><br></pre></td></tr></table></figure><p>软连接：不同分区</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -li utils.py</span><br><span class="line"><span class="number">19200499</span> -rw-r--r-- <span class="number">1</span> root root <span class="number">3322</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">15</span><span class="symbol">:</span><span class="number">51</span> utils.py</span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>ls -li utils1.py</span><br><span class="line"><span class="number">19200215</span> lrwxrwxrwx <span class="number">1</span> sv sv <span class="number">8</span> <span class="number">5</span>月  <span class="number">10</span> <span class="number">21</span><span class="symbol">:</span><span class="number">19</span> utils1.py -&gt; utils.py</span><br></pre></td></tr></table></figure><blockquote><p><strong>硬链接和软链接的区别</strong></p></blockquote><p>硬链接和软链接（也被称为符号链接）都是Unix和Linux文件系统中的概念，它们是文件的两种不同类型的链接。</p><ol><li><strong>硬链接</strong>：硬链接是一个指向文件的i节点的引用。i节点是文件系统中存储文件元数据（如文件大小、创建日期等）的数据结构。硬链接可以看作是同一文件的不同名字，它们可以位于同一文件系统的不同位置，但都指向同一i节点。删除一个硬链接不会影响到其他的硬链接，因为它们都直接指向同一i节点。【取别名】</li><li><strong>软链接</strong>：软链接（或符号链接）则类似于Windows中的快捷方式。它是一个独立的文件，包含了指向另一个文件或目录的路径。软链接可以跨越不同的文件系统，但如果目标文件被删除，软链接就会变为无效。【存路径】</li></ol><p>下面是它们之间的主要区别：</p><ul><li><strong>存储方式</strong>：硬链接是在文件系统中创建一个新的i节点，它与原文件共享i节点，而软链接是创建一个新的文件，该文件中包含了指向原文件的路径。</li><li><strong>跨文件系统</strong>：硬链接仅限于在同一文件系统中，而软链接可以链接到其他文件系统的文件。</li><li><strong>链接目录</strong>：通常，硬链接不能链接目录，而软链接可以。</li><li><strong>删除原文件</strong>：当原文件被删除后，硬链接仍然可以访问文件的内容，而软链接则会失效。</li></ul><p>这就是硬链接和软链接的基本区别。在实际使用中，你可以根据需要选择使用硬链接或软链接。</p><h3 id="磁盘分区和挂载">磁盘分区和挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line">fdisk</span><br><span class="line">mkfs</span><br><span class="line">parted</span><br><span class="line">mount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常见配置文件</span><br><span class="line">/etc/fstab</span><br><span class="line"></span><br><span class="line">用fdisk创建分区（一个硬盘设备可以创建多个分区，也可以创建一个）</span><br><span class="line">1：fdisk -l 查看有几个硬盘设备及分区</span><br><span class="line">2：fdisk /dev/sdc    （比如有设备sdc，则可以针对sdc进行分区）</span><br><span class="line">3：之后 m 键是帮助</span><br><span class="line">4：n 表示新建一个分区</span><br><span class="line">5：新建分区时，需要选择主分区和扩展分区，其中 p表示主分区，最多有4个。e表示扩展分区（里面可以建立逻辑分区）。一般把一块硬盘划分为一个主分区。使用扩展分区时，只能建立3个主分区。</span><br><span class="line">6：选择区分编号1-4</span><br><span class="line">7：指定分区扇区大小，默认2048</span><br><span class="line">8：指定分区大小。默认全部。可以 + 20G等可以选择分区大小</span><br><span class="line">9：q 表示退出，分区不生效。w 表示生效</span><br><span class="line"></span><br><span class="line">建立完分区后，需要对分区进行格式化。</span><br><span class="line"></span><br><span class="line">mkfs.ext4  mkfs.xfs等命令</span><br><span class="line">mkfs.ext4 /dev/sdc1</span><br><span class="line"></span><br><span class="line">然后要进行操作，linux里都是文件级别的操作，需要挂载到某个目录下</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/sdc1</span><br><span class="line">mount /dev/sdc1 /mnt/sdc1 挂载上去</span><br><span class="line">对/mnt/sdc1的读写就会落入sdc1设备上</span><br><span class="line"></span><br><span class="line">1、一个硬盘</span><br><span class="line">2、进行分区</span><br><span class="line">3、格式化</span><br><span class="line">4、挂载</span><br><span class="line">5、对指定目录进行操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要注意的事情：</span><br><span class="line">如果一个硬盘大于 2T ，不能使用 fdisk 进行分区，需要使用 parted</span><br><span class="line">parted /dev/sdd</span><br><span class="line"><span class="built_in">help</span> 获取帮助</span><br><span class="line"></span><br><span class="line">mount 进行挂载是临时的，不是固化的</span><br><span class="line">vim /etc/fstab</span><br><span class="line">在文件中新增下面一句话</span><br><span class="line">/dev/sdc1 /mnt/sdc1 ext4 defaults（表示权限）0 0</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/qq_38028248/article/details/115524071">Linux虚拟机磁盘分区创建、挂载、卸载、删除</a></li></ul><h3 id="系统综合状态查询">系统综合状态查询</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="keyword">sar</span> 命令查看系统综合状态</span><br><span class="line">    <span class="keyword">sar</span> -u <span class="number">1</span> <span class="number">10</span> <span class="meta">CPU</span>的查看，每隔<span class="number">1</span>秒做采样，采样<span class="number">10</span>次，</span><br><span class="line">    <span class="keyword">sar</span> -r <span class="number">1</span> <span class="number">10</span> 看内存</span><br><span class="line">    <span class="keyword">sar</span> -b <span class="number">1</span> <span class="number">10</span> IO的情况（磁盘读写）</span><br><span class="line">    <span class="keyword">sar</span> -d <span class="number">1</span> <span class="number">10</span> 查看每块磁盘的读写</span><br><span class="line">    <span class="keyword">sar</span> -q <span class="number">1</span> <span class="number">10</span> 查看进程</span><br><span class="line">使用第三方命令查看网络流量</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install iftop （网络情况）</span><br><span class="line">iftop -p （默认eth0）</span><br></pre></td></tr></table></figure><h2 id="Shell">Shell</h2><h3 id="什么是Shell">什么是Shell</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span> 是命令解释器，用于解释用户对操作系统的操作。</span><br><span class="line"></span><br><span class="line"><span class="keyword">shell</span>有很多</span><br><span class="line">    <span class="keyword">cat</span> /etc/shells</span><br><span class="line"></span><br><span class="line">CentOS 7 默认使用的<span class="keyword">shell</span>是bash</span><br></pre></td></tr></table></figure><h3 id="Shell脚本">Shell脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNIX的哲学：一条命令只做一件事情</span><br><span class="line">为了组合命令和多次执行命令，使用脚本文件来保存需要执行的命令</span><br><span class="line">赋予该文件执行权限（<span class="built_in">chmod</span> u+rx filename）</span><br></pre></td></tr></table></figure><p>Shell和Bash的区别</p><p>Shell 和 Bash 都是命令行界面，但是它们之间存在一些主要的区别。</p><ol><li>Shell 是一个通用术语，用于描述一个命令行解释器（或脚本解释器）。它是用户与操作系统进行交互的接口。在 Unix 和类 Unix 系统（如 Linux）中，有多种不同的 shell 可供选择，如 Bourne shell（sh）、C shell（csh）、Korn shell（ksh）等等。</li><li>Bash（Bourne Again SHell）是 Bourne shell 的扩展，也是 Linux 默认的 shell。它增加了许多特性，如命令行编辑、命令历史记录等，使得用户在使用命令行时更加方便。</li></ol><p>所以，可以说所有的 Bash 都是 Shell，但并非所有的 Shell 都是 Bash。如果你在 Linux 系统中打开一个终端窗口，你通常会得到一个 Bash shell。如果你在编写 shell 脚本，你可以选择使用 Bourne shell 语法（这样脚本可以在所有的 Unix-like 系统上运行），或者使用 Bash 语法（这样你可以使用 Bash 提供的额外特性，但脚本可能无法在只有 Bourne shell 的系统上运行）。</p><p>标准的Shell脚本要包含哪些元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Sha-Bang</span><br><span class="line">命令</span><br><span class="line">“<span class="comment">#”号开头的注释</span></span><br><span class="line"><span class="built_in">chmod</span> u+x filename 可执行权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行命令</span><br><span class="line">bash ./filename.sh   会生成一个子进程（不需要执行权限）</span><br><span class="line">./filename.sh   会生成一个子进程，使用Sha-Bang （需要可执行权限）</span><br><span class="line"><span class="built_in">source</span> ./filename.sh  在当前进程运行</span><br><span class="line">. filename.sh （点之后会产生一个子进程）</span><br><span class="line"></span><br><span class="line">比如一个脚本如下：</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"></span><br><span class="line">在/home目录下运行</span><br><span class="line">bash ./filename.sh 运行，子进程运行<span class="built_in">cd</span>，然后子进程结束，此时<span class="built_in">pwd</span>，还是在 /home 而不是/tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ./filename.sh 或者 . filename.sh</span><br><span class="line"></span><br><span class="line">内建命令和外部命令的区别</span><br><span class="line">内建命令不需要创建子进程，内建命令比如<span class="built_in">source</span></span><br><span class="line">内建命令对当前shell生效</span><br></pre></td></tr></table></figure><p>Sha-Bang</p><p>用于指明执行这个脚本文件的解释器</p><ul><li><a href="https://blog.csdn.net/u012294618/article/details/78427864">释伴：Linux 上的 Shebang 符号(#!)</a></li></ul><h3 id="管道与重定向">管道与重定向</h3><p><strong>管道与管道符</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">管道和信号一样，也是进程通信的方式之一</span><br><span class="line">匿名管道（管道符）是 Shell 变成经常用到的通信工具</span><br><span class="line">管道符是“|<span class="type">”，将前一个命令执行的结果传递给后面的命令</span></span><br><span class="line"><span class="type">ps</span> | <span class="type">cat</span></span><br><span class="line">echo <span class="number">123</span> | <span class="type">psecho</span> <span class="number">123</span> |<span class="type">cat</span> |<span class="type">cmd</span> 可以连续使用</span><br></pre></td></tr></table></figure><p>可以看到 cat 和 ps 是两个进程，两个进程之间的通信被连接起来。</p><p><strong>重定向符号</strong></p><p>理解箭头的方向即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一个进程默认会打开标准输入、标准输出、错误输出三个文件描述符</span><br><span class="line">输入重定向符号 “&lt;”</span><br><span class="line">read var &lt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span></span><br><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv/LANet</span><span class="variable">$ </span>wc -l  &lt; <span class="regexp">/etc/passwd</span></span><br><span class="line"><span class="number">53</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出重定向符号  <span class="string">&quot;&gt;&quot;</span>  <span class="string">&quot;&gt;&gt;&quot;</span>  <span class="string">&quot;2&gt;&quot;</span> <span class="string">&quot;&amp;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">echo <span class="number">123</span> &gt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span>   清空再输入</span><br><span class="line">echo <span class="number">123</span> &gt;&gt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span>  追加</span><br><span class="line"><span class="number">2</span>&gt; 命令执行过程中有错误则重定向</span><br><span class="line">&amp;&gt; 命令执行过程中无论正确错误都重定向 </span><br><span class="line"></span><br><span class="line">输入和输出重定向组合使用</span><br><span class="line">cat &gt; <span class="regexp">/path/to</span><span class="regexp">/a/file</span>.sh &lt;&lt; <span class="variable constant_">EOF</span></span><br><span class="line">i am <span class="variable">$USER</span></span><br><span class="line"><span class="variable constant_">EOF</span></span><br><span class="line"></span><br><span class="line">运行以上三句话，会生成一个file.sh文件，文件里内容为i am $<span class="variable constant_">USER</span></span><br></pre></td></tr></table></figure><p>补充：echo 命令在Linux中用于在标准输出设备（通常是终端或屏幕）上显示一行文本</p><p>来看看这条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">cat</span> a.sh</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ./file.sh &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">i am $USER</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ vim a.sh</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ bash ./a.sh</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">ls</span></span><br><span class="line">a.sh  file.sh  README.md  tmp  train2017.zip  utils1.py  utils.py</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">cat</span> file.sh</span><br><span class="line">i am sv</span><br></pre></td></tr></table></figure><p>GPT解释：</p><p>这条命令是在 Unix/Linux 系统中使用的，用于向文件中写入内容。让我分解一下这条命令：</p><ol><li><code>cat &gt; /path/to/a/file.sh</code>: <code>cat</code> 是 “concatenate” 的缩写，通常用于输出一个或多个文件的内容。但是这里我们使用了 <code>&gt;</code> 这个重定向符，意思是把 <code>cat</code> 命令的输出重定向到 <code>/path/to/a/file.sh</code> 这个文件中。如果文件已经存在，这个操作会覆盖原有的内容。如果文件不存在，这个操作会创建一个新的文件。</li><li><code>&lt;&lt; EOF</code>: 这是一个叫做 “here document” 的技术。<code>&lt;&lt;</code> 是一个特殊的重定向符，意思是把后面的内容作为输入。<code>EOF</code> 是一个标志，它告诉 shell，这个输入会一直持续到遇到另一个 <code>EOF</code> 为止。</li><li><code>i am $USER</code>: 这是要写入文件的内容。<code>$USER</code> 是一个环境变量，代表当前的用户名。所以这一行的意思是 “我是 当前用户名”。</li><li><code>EOF</code>: 这是前面提到的那个结束标志。遇到这个标志，shell 就知道输入结束了。</li></ol><p>所以，总的来说，这条命令的意思是创建一个文件 <code>/path/to/a/file.sh</code>，并向其中写入 “我是 当前用户名” 这样的内容。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/638108440">如何在Linux系统中使用Cat命令 [22个典型示例]</a></li></ul><h3 id="变量">变量</h3><p><strong>变量的赋值</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">变量名的命名规则</span><br><span class="line"></span><br><span class="line">字母、数字、下划线</span><br><span class="line">不以数字开头</span><br><span class="line"></span><br><span class="line">变量的赋值</span><br><span class="line"></span><br><span class="line">为变量赋值的过程中，称为变量替换</span><br><span class="line">    变量名=变量值</span><br><span class="line">    <span class="attribute">a</span>=123  （不允许出现空格，shell会认为前面不是变量名而是一个命令，比如reboot =1），会重启</span><br><span class="line"></span><br><span class="line">使用let为变量赋值</span><br><span class="line">    let <span class="attribute">a</span>=10+20 （尽量少用，效率很低）</span><br><span class="line"></span><br><span class="line">将命令赋值给变量</span><br><span class="line">    <span class="attribute">l</span>=ls  （用处不大）</span><br><span class="line"></span><br><span class="line">将命令结果赋值给变量，使用$() 或者 <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attribute">letc</span>=$(ls -l /etc)</span><br><span class="line">    <span class="attribute">letc</span>=$&#x27;ls /root<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量值有空格等特殊字符可以包含在 &quot;&quot; 或 &#x27;</span><span class="string">&#x27; 中</span></span><br><span class="line"><span class="string">    srring1=&#x27;</span>hello bash<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    string2=&quot;hello I&#x27;</span>m name<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><strong>变量引用及作用范围</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">变量的引用</span><br><span class="line">    <span class="variable">$&#123;变量名&#125;</span>称作对变量的引用</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;变量名&#125;</span> 查看变量的值</span><br><span class="line">    <span class="variable">$&#123;变量名&#125;</span> 在部分情况下可以省略为 $变量名</span><br><span class="line"></span><br><span class="line">变量的作用范围</span><br><span class="line">    变量的默认作用范围</span><br><span class="line">        当前的shell，父进程的变量对子进程无效，子进程的对父进程也无效。</span><br><span class="line">        可以使用<span class="built_in">source</span></span><br><span class="line">    变量的导出</span><br><span class="line">        <span class="built_in">export</span> ，子进程可以获得父进程的变量，同时，父进程也能看到子进程的变量</span><br><span class="line">        <span class="built_in">export</span> demo_var1=<span class="string">&quot;hello subshell&quot;</span></span><br><span class="line">    变量的删除</span><br><span class="line">        <span class="built_in">unset</span></span><br><span class="line">        <span class="built_in">unset</span> demo_var1</span><br></pre></td></tr></table></figure><p>变量作用范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ bash</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">&quot;root&quot;</span>), use <span class="string">&quot;sudo &lt;command&gt;&quot;</span>.</span><br><span class="line">See <span class="string">&quot;man sudo_root&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">-------- freesurfer-linux-ubuntu18_x86_64-7.3.2-20220819-6354275 --------</span><br><span class="line">Setting up environment <span class="keyword">for</span> FreeSurfer/FS-FAST (and FSL)</span><br><span class="line">FREESURFER_HOME   /data/home/qulijun/freesurfer</span><br><span class="line">FSFAST_HOME       /data/home/qulijun/freesurfer/fsfast</span><br><span class="line">FSF_OUTPUT_FORMAT nii.gz</span><br><span class="line">SUBJECTS_DIR      /data/home/qulijun/freesurfer/subjects</span><br><span class="line">MNI_DIR           /data/home/qulijun/freesurfer/mni</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ a=2</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>变量的导出：export ，子进程可以获得父进程的变量，同时，父进程也能看到子进程的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$demo_var1</span></span><br><span class="line">hello subshell</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ bash</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">&quot;root&quot;</span>), use <span class="string">&quot;sudo &lt;command&gt;&quot;</span>.</span><br><span class="line">See <span class="string">&quot;man sudo_root&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">-------- freesurfer-linux-ubuntu18_x86_64-7.3.2-20220819-6354275 --------</span><br><span class="line">Setting up environment <span class="keyword">for</span> FreeSurfer/FS-FAST (and FSL)</span><br><span class="line">FREESURFER_HOME   /data/home/qulijun/freesurfer</span><br><span class="line">FSFAST_HOME       /data/home/qulijun/freesurfer/fsfast</span><br><span class="line">FSF_OUTPUT_FORMAT nii.gz</span><br><span class="line">SUBJECTS_DIR      /data/home/qulijun/freesurfer/subjects</span><br><span class="line">MNI_DIR           /data/home/qulijun/freesurfer/mni</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$demo_var1</span></span><br><span class="line">hello subshell</span><br><span class="line">sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv/LANet$ <span class="built_in">echo</span> <span class="variable">$demo_var1</span></span><br><span class="line">hello subshell</span><br></pre></td></tr></table></figure><p><strong>系统环境变量，预定义变量与位置变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">环境变量：每个Shell打开都可以获得到的变量</span><br><span class="line">    <span class="built_in">set</span> 和 <span class="built_in">env</span> 命令</span><br><span class="line">        <span class="built_in">env</span> |  more 查看当前所有的环境变量</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$&#123;HOME&#125;</span>  查看单个环境变量</span><br><span class="line">    <span class="variable">$PATH</span> 当前命令的搜索路径</span><br><span class="line">        所以要在<span class="variable">$PATH</span> 中新增路径，使用PATH=<span class="variable">$PATH</span>:新加路径（只对当前终端生效，对子shell生效）</span><br><span class="line">    <span class="variable">$PS1</span>  当前提示终端</span><br><span class="line"></span><br><span class="line">预定义变量</span><br><span class="line">        <span class="built_in">echo</span> $?  $$ <span class="variable">$0</span>等</span><br><span class="line">        $?   指上一条命令是否正确执行，<span class="built_in">echo</span> $?，正确执行返回0，错误1</span><br><span class="line">        $$   显示当前进程 PID</span><br><span class="line">        <span class="variable">$0</span>   显示当前进程名称</span><br><span class="line"></span><br><span class="line">位置变量</span><br><span class="line">    <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$&#123;10&#125;</span>，需要有&#123;&#125;</span><br><span class="line"></span><br><span class="line">比如有脚本 test.sh]如下：</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line">pos1=<span class="variable">$1</span></span><br><span class="line">pos2=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos2</span></span><br><span class="line"></span><br><span class="line">执行的时候，./test.sh -a -l</span><br><span class="line">会传参进去，可以对脚本进行简化</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">考虑到<span class="built_in">echo</span> <span class="variable">$2</span> 的时候 <span class="variable">$2</span> 有可能是空值。所以写成下面这样</span><br><span class="line">pos1=<span class="variable">$1</span></span><br><span class="line">pos2=<span class="variable">$&#123;2&#125;</span>_</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pos2</span></span><br><span class="line">如果没有传参，则<span class="variable">$2</span>默认为_，规避读入的值是空值。但是这么写，如果传参进去，后面会多一个_，所以可以改成下面这样：</span><br><span class="line">pos2=<span class="variable">$&#123;2-_&#125;</span></span><br></pre></td></tr></table></figure><p><strong>环境变量配置文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">配置文件</span><br><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc</span><br><span class="line">/etc/bashrc</span><br><span class="line"></span><br><span class="line">所以经常在 /etc/profile 中新增 <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/new/path</span><br><span class="line">su - 切换用户会加载4个文件</span><br><span class="line">su 切换用户只会加载~/.bashrc、/etc/bashrc</span><br></pre></td></tr></table></figure><p>在 Unix 和 Linux 中，以上这些文件都是环境配置文件，具体作用如下：</p><ol><li><code>/etc/profile</code>：这是系统的全局配置文件，对所有用户都有效。该文件设置了环境变量，包括用户的 shell 环境设置、程序路径等。</li><li><code>/etc/profile.d/</code>：这是一个目录，里面的脚本文件会被 <code>/etc/profile</code> 文件在启动时候执行。这样设计的目的是为了更好的模块化和管理系统环境变量。</li><li><code>~/.bash_profile</code>：这是针对单个用户的配置文件。每当用户登录时，这个文件就会执行一次。这个文件首先查找 <code>~/.bashrc</code> 文件，如果找到，就加载该文件。</li><li><code>~/.bashrc</code>：这也是针对单个用户的配置文件。但是与 <code>~/.bash_profile</code> 不同的是，<code>~/.bashrc</code> 文件在每次打开新的 shell 时都会执行。这意味着每次打开新的终端窗口或新的 shell 时，都会读取并执行这个文件。</li><li><code>/etc/bashrc</code>：这是系统级别的，对所有用户都有效。当 bash shell 被打开时，都会读取并执行这个文件。</li></ol><p>总的来说，这些文件都是用来配置用户的 shell 环境的。其中，<code>/etc/profile</code> 和 <code>/etc/bashrc</code> 是全局的，对所有用户都有效；而 <code>~/.bash_profile</code> 和 <code>~/.bashrc</code> 是针对每个用户的，只对当前用户有效。</p><h3 id="数组">数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定义数组</span><br><span class="line">    IPTS=(10.0.0.1 10.0.0.2 10.0.0.3)</span><br><span class="line"></span><br><span class="line">显示数组的所有元素</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;IPTS[@]&#125;</span></span><br><span class="line"></span><br><span class="line">显示数组元素个数</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;#IPTS[@]&#125;</span></span><br><span class="line"></span><br><span class="line">显示数组的第一个元素</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;IPTS[0]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="转义和引用">转义和引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：一个字符不仅有字面意义，还有元意（meta-meaning）</span><br><span class="line">    <span class="comment"># 注释</span></span><br><span class="line">    ; 分号</span><br><span class="line">    \ 转义符号</span><br><span class="line">    <span class="string">&quot; 和 &#x27; 引号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单个字符的转义</span></span><br><span class="line"><span class="string">    \n \r \t 单个字母的转义</span></span><br><span class="line"><span class="string">    \$ \&quot;  \\ 单个非字母的转义</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">引用</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot; 双引号，如果里面有变量，会进行解释</span></span><br><span class="line"><span class="string">&#x27;&#x27; 单引号不会进行解释</span></span><br><span class="line"><span class="string">` 反引号</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">赋值运算符</span><br><span class="line">= 赋值运算符，用于算数赋值和字符串赋值</span><br><span class="line">使用 <span class="built_in">unset</span> 取消为变量的赋值</span><br><span class="line">= 除了作为赋值运算符还可以作为测试操作符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算数运算符</span><br><span class="line"></span><br><span class="line">基本运算符</span><br><span class="line">+ - * / ** %</span><br><span class="line"></span><br><span class="line">使用<span class="built_in">expr</span>进行计算</span><br><span class="line"><span class="built_in">expr</span> 4 + 5 （要有空格，只能支持整数）</span><br><span class="line">num1=`<span class="built_in">expr</span> 4 + 5`</span><br><span class="line"></span><br><span class="line">数字常量的使用方法，如果不用特殊方法，a=4+5，其实把 “4+5”字符串赋值给a</span><br><span class="line"><span class="built_in">let</span> “变量名=变量值”</span><br><span class="line">变量值使用0开头为八进制，0x开头为十六进制</span><br><span class="line"></span><br><span class="line">双圆括号是<span class="built_in">let</span>命令的简化</span><br><span class="line">((a=<span class="number">4</span>+<span class="number">5</span>))</span><br><span class="line">((a++))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="number">10</span>+<span class="number">20</span>)）</span><br></pre></td></tr></table></figure><h3 id="特殊字符大全">特殊字符大全</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">引号</span><br><span class="line">    <span class="string">&#x27; 完全引用</span></span><br><span class="line"><span class="string">    &quot; 不完全引用</span></span><br><span class="line"><span class="string">    ` 执行命令</span></span><br><span class="line"><span class="string">括号</span></span><br><span class="line"><span class="string">    () (()) $() 圆括号</span></span><br><span class="line"><span class="string">        单独使用圆括号会产生一个子shell（xyz=123）</span></span><br><span class="line"><span class="string">        数组初始化 IPS=(ip1 ip2 ip3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    [] [[]] 方括号</span></span><br><span class="line"><span class="string">        单独使用方括号是测试（test）或数组元素功能</span></span><br><span class="line"><span class="string">        两个方括号表示测试表达式</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">    &lt;&gt; 尖括号 重定向符号</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &#123;&#125; 花括号</span></span><br><span class="line"><span class="string">        输出范围 echo&#123;0..9&#125;，会输出0-9所有数字</span></span><br><span class="line"><span class="string">        文件复制 cp -v /etc/passwd /etc/passwd.bak </span></span><br><span class="line"><span class="string">        等同于 cp -v /etc/passwd&#123;,.bak&#125;</span></span><br><span class="line"><span class="string">运算和逻辑符号</span></span><br><span class="line"><span class="string">    +-*/% 算数运算符</span></span><br><span class="line"><span class="string">    &gt;&lt;= 比较运算符</span></span><br><span class="line"><span class="string">    &amp;&amp; || ！逻辑运算符</span></span><br><span class="line"><span class="string">        (( 5 &gt; 4 &amp;&amp; 6&gt; 5))，然后通过 echo $? 判断</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">转义符号</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其他符号</span></span><br><span class="line"><span class="string">    # 注释符</span></span><br><span class="line"><span class="string">    ;  命令分隔符</span></span><br><span class="line"><span class="string">        case 语句的分隔符要转义 ;;</span></span><br><span class="line"><span class="string">    ：空指令</span></span><br><span class="line"><span class="string">    .  和source命令相同</span></span><br><span class="line"><span class="string">    ~  家目录</span></span><br><span class="line"><span class="string">    ,  分隔目录</span></span><br><span class="line"><span class="string">    * 通配符</span></span><br><span class="line"><span class="string">    ? 条件测试或通配符</span></span><br><span class="line"><span class="string">    $ 取值符号</span></span><br><span class="line"><span class="string">    | 管道符</span></span><br><span class="line"><span class="string">    &amp; 后台运行</span></span><br><span class="line"><span class="string">       空格</span></span><br></pre></td></tr></table></figure><h3 id="测试与判断">测试与判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">退出程序命令</span><br><span class="line">    <span class="built_in">exit</span> 判断上一条命令是否正常，0或者非0</span><br><span class="line">    <span class="built_in">exit</span> 1或者0 返回10 给shell ，返回值非0位不正常退出</span><br><span class="line">    $? 判断当前shell前一个进程是否正常退出</span><br><span class="line"></span><br><span class="line">测试命令<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>命令用于检查文件或者比较值</span><br><span class="line"><span class="built_in">test</span>可以做以下测试</span><br><span class="line">    文件测试 </span><br><span class="line">    整数比较测试</span><br><span class="line">    字符串测试</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>测试语句可以简化为[]符号</span><br><span class="line">    <span class="built_in">test</span> -f /etc/passwd2 判断文件是否存在并且是个普通文件，-e是文件或者目录，-d目录</span><br><span class="line">    [ -d /etc/ ]</span><br><span class="line">[]符号还有扩展写法 [[]] 支持 &amp;&amp; || &lt; &gt;</span><br></pre></td></tr></table></figure><p>if判断语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if-then 语句的基本用法</span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ] 或 命令返回值是否为0</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">fi</span> 结束</span><br><span class="line"></span><br><span class="line">if-then-else 语句可以在条件不成立时也运行相应的命令</span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">else</span> 测试条件不成立，执行相应命令</span><br><span class="line">    <span class="keyword">fi</span> 结束</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">elif</span>  [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">    <span class="keyword">else</span> 测试条件不成立，执行相应命令</span><br><span class="line">    <span class="keyword">fi</span> 结束</span><br><span class="line"></span><br><span class="line">嵌套 <span class="keyword">if</span> 的使用</span><br><span class="line"><span class="keyword">if</span> 条件测试中可以再嵌套 <span class="keyword">if</span> 条件测试</span><br><span class="line">    <span class="keyword">if</span> [ 测试条件成立 ]</span><br><span class="line">    <span class="keyword">then</span> 执行相应命令</span><br><span class="line">        <span class="keyword">if</span> [测试条件成立]</span><br><span class="line">        <span class="keyword">then</span> 执行相应命令</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case分支">case分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 语句和 <span class="keyword">select</span> 语句可以构成分支</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;$变量&quot;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;情况1&quot;</span> )</span><br><span class="line">    命令...;;;</span><br><span class="line">    <span class="string">&quot;情况2&quot;</span> )</span><br><span class="line">    命令...;;;</span><br><span class="line">    * )</span><br><span class="line">     命令...;;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="循环">循环</h3><p><strong>for循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环的语法</span><br><span class="line">    <span class="keyword">for</span>  参数 <span class="keyword">in</span> 列表</span><br><span class="line">    <span class="keyword">do</span> 执行的命令</span><br><span class="line">    <span class="keyword">done</span> 封闭一个循环</span><br><span class="line"></span><br><span class="line">使用反引号或 $() 方式执行命令，命令的结果当做列表进行处理</span><br><span class="line">列表中包含多个变量，变量用空格分隔</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..9&#125;</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> <span class="string">&#x27;ls *.mp3&#x27;</span></span><br><span class="line">对文本处理，要使用文本查看命令取出文本内容</span><br><span class="line">默认逐行处理，如果文本出现空格会当做多行处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C 语言风格的 <span class="keyword">for</span> 命令</span><br><span class="line"><span class="keyword">for</span>((变量的初始化;循环判断条件;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">test</span>测试是否成立</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    命令</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> 循环 与<span class="keyword">while</span> 循环相反，循环测试为假时，执行循环，为真实循环停止</span><br></pre></td></tr></table></figure><p><strong>break和continue</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> 退出</span><br><span class="line"><span class="built_in">continue</span> 结束本轮循环</span><br></pre></td></tr></table></figure><p><strong>使用循环处理位置参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">命令行参数可以使用 <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$&#123;10&#125;</span>..<span class="variable">$n</span> 进行读取</span><br><span class="line"><span class="variable">$0</span> 代表脚本名称</span><br><span class="line">$* 和 <span class="variable">$@</span> 代表所有位置参数</span><br><span class="line"><span class="variable">$#</span> 代表位置参数的数量</span><br><span class="line"></span><br><span class="line">有脚本test.sh如下：</span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># help display help help</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$pos</span>&quot;</span> = <span class="string">&quot;help&quot;</span>]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$pos</span> <span class="variable">$pos</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">运行语句：</span><br><span class="line">bash test.sh a b c <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 脚本如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -ge 1]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;help&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$1</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span>能够参数左移</span><br><span class="line">运行语句：</span><br><span class="line">bash test.sh a b c <span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><p><strong>自定义函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">函数用于“包含”重复使用的命令集合</span><br><span class="line"></span><br><span class="line">自定义函数</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">fname</span></span>()&#123;</span><br><span class="line">    命令</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">函数的执行</span><br><span class="line">    fname</span><br><span class="line"></span><br><span class="line">函数作用范围的变量</span><br><span class="line"><span class="built_in">local</span> 变量名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数的参数</span><br><span class="line"><span class="variable">$1</span> <span class="variable">$2</span>...<span class="variable">$n</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">checkpid</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">        [ -d <span class="string">&quot;/proc/<span class="variable">$i</span>&quot;</span> ] &amp;&amp; <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行时</span><br><span class="line">checkpid 1    或者 checkpid 1 2</span><br><span class="line"><span class="built_in">echo</span>  $?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>系统脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">系统自建了函数库，可以在脚本中引用</span><br><span class="line">/etc/init.d/functions</span><br><span class="line"></span><br><span class="line">自建函数库</span><br><span class="line">使用 <span class="built_in">source</span> 函数脚本文件“导入”函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/init.d/functions</span><br><span class="line">echo_success</span><br></pre></td></tr></table></figure><h3 id="脚本优先级控制">脚本优先级控制</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以使用 nice 和 renice 调整脚本优先级</span><br><span class="line">避免出现“不可控的”死循环</span><br><span class="line">死循环导致cpu占用过高</span><br><span class="line">死循环导致死机</span><br><span class="line"></span><br><span class="line">ulimit -a  可以查看当前终端的使用限制，root用户的话有些限制不会生效</span><br><span class="line"></span><br><span class="line">max <span class="keyword">user</span> <span class="title">processes</span> 用户的最大进程数</span><br></pre></td></tr></table></figure><h3 id="计划任务">计划任务</h3><h3 id="正则表达式与文本搜索">正则表达式与文本搜索</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">元字符</span><br><span class="line"></span><br><span class="line">. 匹配除换行符外的任意单个字符</span><br><span class="line">* 匹配任意一个跟在它前面的字符</span><br><span class="line">[] 匹配方括号中的字符类中的任意一个</span><br><span class="line">^ 匹配开头</span><br><span class="line">$ 匹配结尾</span><br><span class="line">\ 转义后面的特殊字符</span><br><span class="line"></span><br><span class="line">扩展元字符</span><br><span class="line">+ 匹配前面的正则表达式至少出现一次</span><br><span class="line">？ 匹配前面的正则表达式出现零次或一次</span><br><span class="line">| 匹配它前面或后面的正则表达式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">grep</span> 搜索</span><br><span class="line"><span class="keyword">grep</span> test <span class="regexp">/root/</span>test.txt</span><br></pre></td></tr></table></figure><h3 id="搜索文件">搜索文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">find passwd</span><br><span class="line">    -regex 区分大小写</span><br><span class="line">    -iregex 不区分大小写</span><br><span class="line"></span><br><span class="line">find /etc -regex .*wd</span><br><span class="line"></span><br><span class="line">find * txt -<span class="built_in">exec</span> <span class="built_in">rm</span> -v &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/54110864">如何高效地在 Linux 中搜索文件？</a></li></ul><h3 id="sed和awk行编辑器">sed和awk行编辑器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed 一般用于对文本内容做替换</span><br><span class="line"></span><br><span class="line">    sed <span class="string">&#x27;/user1/s/user1/u1&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">awk 基本用法</span><br><span class="line">awk 一般用于对文本内容进行统计，按需要的格式进行输出</span><br><span class="line">    <span class="built_in">cut</span> 命令：<span class="built_in">cut</span> -d:-f 1/etc/passwd</span><br><span class="line">    awk 命令：awk -F: <span class="string">&#x27;/wd$/&#123;print$1&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们看看快速启动muduo脚本的编写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash # 这行表示这个脚本文件将由 bash shell 来执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e <span class="comment"># 这行命令表示如果后面的命令返回非零退出状态，则立即退出脚本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的if语句表示如果当前目录下不存在名为build的文件夹，则创建这个文件夹。</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d `<span class="built_in">pwd</span>`/build ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> `<span class="built_in">pwd</span>`/build</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf `<span class="built_in">pwd</span>`/build/* <span class="comment"># 删除 build 文件夹下的所有文件和子目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 build 目录，然后使用 CMake 生成 Makefile 并使用 make 命令编译项目。</span></span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">pwd</span>`/build &amp;&amp;</span><br><span class="line">    cmake .. &amp;&amp;</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment"># 切换回项目的根目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的if语句表示如果 /usr/include/mymuduo 文件夹不存在，则创建这个文件夹。</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /usr/include/mymuduo ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">mkdir</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历当前目录下的所有 .h 文件，并将它们复制到 /usr/include/mymuduo 文件夹。</span></span><br><span class="line"><span class="keyword">for</span> header <span class="keyword">in</span> `<span class="built_in">ls</span> *.h`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$header</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> `<span class="built_in">pwd</span>`/lib/libmymuduo.so /usr/lib <span class="comment"># 将 libmymuduo.so 文件复制到 /usr/lib 文件夹。</span></span><br><span class="line"></span><br><span class="line">ldconfig <span class="comment"># 刷新动态链接库缓存</span></span><br></pre></td></tr></table></figure><p>这段脚本的主要目的是编译一个项目并将生成的头文件和库文件复制到系统的相应目录。</p>]]></content>
    
    
    <summary type="html">Linux实战技能</summary>
    
    
    
    <category term="Linux" scheme="https://penge666.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://penge666.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>无锁队列</title>
    <link href="https://penge666.github.io/posts/9131331a.html"/>
    <id>https://penge666.github.io/posts/9131331a.html</id>
    <published>2024-05-07T12:15:38.000Z</published>
    <updated>2024-05-17T13:46:21.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在上一篇博客中，介绍了通过指定原子变量的操作的内存顺序, 实现线程同步问题。本文看看原子变量和内存顺序的应用 – 无锁队列（Lock-Free Queue）。本文介绍无锁队列的实现，学习无锁队列设计的基本思路。</p><h2 id="数组版本">数组版本</h2><h3 id="单写单读队列">单写单读队列</h3><p>单写单读的队列比较简单, 这里我们使用循环队列实现. 如下图所示, 队列维护两个指针 <code>head</code> 和 <code>tail</code>, 分别指向队首和队尾. <code>tail</code> 始终指向 dummy 节点, 这样 <code>tail == head</code> 表示队列为空, <code>(tail + 1) % Cap == head</code> 表示队列已满, 不用维护 <code>size</code> 成员.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507202501356.png" alt="image-20240507202501356"></p><p>入队的时候移动 <code>tail</code> 指针, 而出队的时候移动 <code>head</code> 指针, 两个操作并无冲突. 不过, 出队前需要读取 <code>tail</code> 指针, 判断 <code>tail != head</code> 确认队列不为空; 同理入队时也要判断 <code>(tail + 1) % Cap != head</code> 以确认队列不满. 由于存在多个线程读写这两个指针, 因此它们都应该是原子变量.</p><p>此外, 由于两个操作在不同线程中执行, 我们还需考虑内存顺序. 如果初始队列为空, 线程 a 先执行入队操作, 线程 b 后执行出队操作, 则线程 a 入队操作的内容要对线程 b 可见.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507202552069.png" alt="image-20240507202552069"></p><p>为了做到这一点, 需要有 a(2) “happens-before” b(3). 而 a(3) 和 b(2) 分别修改了读取了 <code>tail</code>, 所以应该利用原子变量同步, 使得 a(3) “synchronizes-with” b(2). 可以在 a(3) 写入 <code>tail</code> 的操作中使用 release, b(2) 读取 <code>tail</code> 的操作中使用 acquire 实现同步.</p><p>同理, 如果初始队列满, 线程 a 先执行出队操作, 线程 b 后执行入队操作, 则线程 a 出队操作的结果要对线程 b 可见. 出队的时候需要调用出队元素的析构函数, 要保证出队元素正常销毁后才能在那个位置写入新元素, 否则会导致内存损坏. 可以在出队写入 <code>head</code> 的操作中使用 release, 入队读取 <code>head</code> 的操作中使用 acquire 实现出队 “synchronizes-with” 入队.</p><p>简单来说:</p><p>1.线程 a 先执行出队操作, 线程 b 后执行入队操作, 则线程 a 出队操作的结果要对线程 b 可见.</p><p>2.线程 a 先执行入队操作, 线程 b 后执行出队操作, 则线程 a 入队操作的结果要对线程 b 可见.</p><p>使用memory_order_acquire和memory_order_release实现线程同步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">spsc</span> : <span class="keyword">private</span> allocator&lt;T&gt; &#123;</span><br><span class="line">    T *data;</span><br><span class="line">    atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">spsc</span>(): <span class="built_in">data</span>(allocator&lt;T&gt;::<span class="built_in">allocate</span>(Cap)) &#123;&#125;</span><br><span class="line">    <span class="built_in">spsc</span>(<span class="type">const</span> spsc&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    spsc &amp;<span class="keyword">operator</span>=(<span class="type">const</span> spsc&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    spsc &amp;<span class="keyword">operator</span>=(<span class="type">const</span> spsc&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T &amp;&amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ...args)</span> </span>&#123; <span class="comment">// 入队操作</span></span><br><span class="line">        <span class="type">size_t</span> t = tail.<span class="built_in">load</span>(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">// (1)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        allocator&lt;T&gt;::<span class="built_in">construct</span>(data + t, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">// (2)  synchronizes-with (3)</span></span><br><span class="line">        tail.<span class="built_in">store</span>((t + <span class="number">1</span>) % Cap, memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;val)</span> </span>&#123; <span class="comment">// 出队操作</span></span><br><span class="line">        <span class="type">size_t</span> h = head.<span class="built_in">load</span>(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">// (3)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = std::<span class="built_in">move</span>(data[h]);</span><br><span class="line">        allocator&lt;T&gt;::<span class="built_in">destroy</span>(data + h);</span><br><span class="line">        <span class="comment">// (4) synchronizes-with (1)</span></span><br><span class="line">        head.<span class="built_in">store</span>((h + <span class="number">1</span>) % Cap, memory_order_release); <span class="comment">// (4)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种单写单读的无锁队列的两种操作可以同时执行, 且两种操作都只需要执行确定数量的指令, 因此数据 wait-free 结构, 性能很高.</p><p>给出完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type __sync_val_compare_and_swap(type *ptr, type oldval type newval, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">data</span>(<span class="keyword">new</span> T[Cap]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t = tail.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Producer: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">        data[t % Cap] = val;</span><br><span class="line">        tail.<span class="built_in">store</span>((t + <span class="number">1</span>) % Cap, std::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h % Cap];</span><br><span class="line">        head.<span class="built_in">store</span>((h + <span class="number">1</span>) % Cap, std::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="type">int</span>, <span class="number">5</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">pop</span>(val))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumer: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">push</span>(num))</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(Producer)</span></span>;</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS-操作">CAS 操作</h4><p><strong>CAS (compare and swap)</strong> 是一种原子操作, 在一个不可被中断的过程中执行比较和交换. C++ 的 <code>std::atomic</code> 中有两种 CAS 操作, <code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_weak</span>(T &amp;expected, T desired);</span><br><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired);</span><br></pre></td></tr></table></figure><p>这两种 CAS 操作基本上是相同的:</p><ul><li><p>如果原子变量与 <code>expected</code> 相等, 则将其赋值为 <code>desired</code> 并返回 <code>true</code>;</p></li><li><p>否则 <code>expected</code> 赋值成原子变量当前的值并返回 <code>false</code>.</p></li></ul><p>下面是 <code>compare_exchange_strong</code> 的一个伪实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_val == expected)</span><br><span class="line">        <span class="keyword">return</span> m_val = desired, <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> expected = m_val, <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然实际的实现不可能是这样的.</p><p><code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code> 的区别在于, <code>compare_exchange_weak</code> 有可能在当前值与 <code>expected</code> 相等时仍然不执行交换并返回 <code>false</code>; <code>compare_exchange_strong</code> 则不会有这个问题. weak 版本能让编译器在一些平台下生成一些更优的代码, 在 x86 下是没区别的.</p><p><code>compare_exchange_*</code> 支持指定两个内存顺序: 成功时的内存顺序和失败时的内存顺序.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order failure)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以利用 CAS 操作实现很多无锁数据结构. 下面我们来看如何实现多写多读的队列.</p><h3 id="多写多读队列">多写多读队列</h3><p>前面单读单写能否用到执行多写多读呢？答案是不可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h = head.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    val = std::<span class="built_in">move</span>(data[h]); <span class="comment">// (2)</span></span><br><span class="line">    allocator&lt;T&gt;::<span class="built_in">destroy</span>(data + h);</span><br><span class="line">    head.<span class="built_in">store</span>((h + <span class="number">1</span>) % Cap); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 a 和 b 同时调用 <code>pop</code>, 执行顺序是 a(1), b(1), b(2) a(2). 这种情况下, 线程 a 和线程 b 都读到相同的 <code>head</code> 指针, 存储在变量 <code>h</code> 中. 当 a(2) 尝试读取 <code>data[h]</code> 时, 其中的数据已经在 b(2) 中被 move 走了. 因此这样的队列不允许多个线程同时执行 pop 操作.</p><p>简单来说，就是2个线程都调用pop,但是只要一个data[h]可给val.</p><h4 id="解决抢占问题">解决抢占问题</h4><p>可以看到, 整个 <code>pop</code> 函数是一个非原子过程, 一旦这个过程别其他线程抢占, 就会出问题. 如何解决这个问题呢? 在无锁数据结构中, 一种常用的做法是<strong>不断重试</strong>. 具体的做法是, 在非原子过程的最后一步设计一个 CAS 操作, 如果过程被其他线程抢占, 则 CAS 操作失败, 并重新执行整个过程. 否则 CAS 操作成功, 完成整个过程的最后一步.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        h = head.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h]; <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先注意到我们不再使用 <code>std::move</code> 和 <code>allocator::destroy</code>, 而是直接复制, 使得循环体内的操作不会修改队列本身. (3) 是整个过程的最后一步, 也是唯一会修改队列的一步, 我们使用了一个 CAS 操作. 只有当 <code>head</code> 的值等于第 (1) 步获取的值的时候, 才会移动 <code>head</code> 指针, 并且返回 <code>true</code> 跳出循环; 否则就不断重试.【简单来说，就是只能有一个pop，其他的需要进入循环等待.利用CAS进行暴力美学】</p><p>这样如果多个线程并发执行 <code>pop</code>, 则只有成功执行 (3) 的线程被视为成功执行了整个过程, 其它的线程都会因为被抢占, 导致执行 (3) 的时候 <code>head</code> 被修改, 因而与局部变量 <code>h</code> 不相等, 导致 CAS 操作失败. 这样它们就要重试整个过程.</p><p>类似的思路也可以用在 <code>push</code> 上. 看看如果我们用同样的方式修改 <code>push</code> 会怎样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t = tail.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        data[t] = val; <span class="comment">// (2)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % Cap)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>pop</code> 操作不同, <code>push</code> 操作的第 (2) 步需要对 <code>data[t]</code> 赋值, 导致循环体内的操作会修改队列. 假设 a, b 两个线程的执行顺序是 a(1), a(2), b(1), b(2), a(3). a 可以成功执行到 (3), 但是入队的值却被 b(2) 覆盖掉了.【简单来说，就是2个线程push，但是可能后者线程会覆盖前者线程的值的这样的问题】</p><p>我们尝试将赋值操作 <code>data[t] = val</code> 移到循环的外面, 这样循环体内的操作就不会修改队列了. 当循环退出时, 能确保 <code>tail</code> 向后移动了一格, 且 <code>t</code> 指向 <code>tail</code> 移动前的位置. 这样并发的时候就不会有其他线程覆盖我们写入的值.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t = tail.<span class="built_in">load</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % Cap)); <span class="comment">// (2)</span></span><br><span class="line">    data[t] = val; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样做的问题是, 我们先移动 <code>tail</code> 指针再对 <code>data[t]</code> 赋值, 会导致 <code>push</code> 与 <code>pop</code> 并发不正确. 回顾下 <code>pop</code> 的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> spsc&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        h = head.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">if</span> (h == tail.<span class="built_in">load</span>()) <span class="comment">// (4)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h]; <span class="comment">// (5)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样假设有两个线程 a 和 b. 假设队列初始为空</p><ul><li>线程 a 调用 <code>push</code> , 执行 a(1), a(2). <code>tail</code> 被更新, 然后切换到线程 b</li><li>线程 b 调用 <code>pop</code> , 执行 b(4). 因为 <code>tail</code> 被更新, 因此判断队列不为空</li><li>执行到 b(5), 会读取到无效的值</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507205821012.png" alt="image-20240507205821012"></p><p>【简单来说，就是当满足pop条件，但是没有值的这样问题】</p><p>为了实现 <code>push</code> 与 <code>pop</code> 的并发, <code>push</code> 对 <code>data[t]</code> 的写入必须 “happens-before” <code>pop</code> 对 <code>data[h]</code> 的读取. 因此这就要求 <code>push</code> 操作先对 <code>data[t]</code> 赋值, 再移动 <code>tail</code> 指针. 可是前面为了实现 <code>push</code> 与 <code>push</code> 的并发我们又让 <code>push</code> 操作先移动 <code>tail</code> 再对 <code>data[t]</code> 赋值. 如何解决这一矛盾呢?</p><p>解决办法是引入一个新的指针 <code>write</code> , 用于 <code>push</code> 与 <code>pop</code> 同步. 它表示 <code>push</code> 操作<strong>写到了哪个位置</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ring_buffer</span> &#123;</span><br><span class="line">    T data[Cap];</span><br><span class="line">    atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;, write&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ring_buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ring_buffer</span>(<span class="type">const</span> ring_buffer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ring_buffer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ring_buffer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ring_buffer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ring_buffer&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t, w;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            t = tail.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_weak</span>(t, (t + <span class="number">1</span>) % Cap)); <span class="comment">// (1)</span></span><br><span class="line">        data[t] = val; <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            w = t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!write.<span class="built_in">compare_exchange_weak</span>(w, (w + <span class="number">1</span>) % Cap)); <span class="comment">// (3), (3) synchronizes-with (4)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = head.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span> (h == write.<span class="built_in">load</span>()) <span class="comment">// (4) 读 write 的值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            val = data[h]; <span class="comment">// (5)</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是暴力，多加个变量解决上述问题。</p><p><code>push</code> 操作的基本步骤是:</p><ol><li>移动 <code>tail</code>;</li><li>对 <code>data[t]</code> 赋值, <code>t</code> 等于 <code>tail</code> 移动前的位置;</li><li>移动 <code>write</code>. <code>write</code> 移动后等于 <code>tail</code>.</li></ol><p>而 <code>pop</code> 操作使用 <code>write</code> 指针判断队列中是否有元素. 因为有 (3) “synchronizes-with” (4), 所以 (2) “happens-before” (5), <code>pop</code> 能读到 <code>push</code> 写入的值. 在 <code>push</code> 函数中, 只有在当前的 <code>write</code> 等于 <code>t</code> 时才将 <code>write</code> 移动一格, 能确保最终 <code>write</code> 等于 <code>tail</code>.</p><p>这种多写多读的无锁队列的两种操作可以同时执行, 但是每种操作都有可能要重试, 因此属于 lock-free 结构.</p><h4 id="考虑内存顺序">考虑内存顺序</h4><p>前面例子使用默认的内存顺序, 也就是 memory_order_seq_cst . 为了优化性能, 可以使用更宽松的内存顺序. 而要考虑内存顺序, 就要找出其中的 happens-before 的关系.</p><p>前面分析了, <code>push</code> 中的赋值操作 <code>data[t] = val</code> 要 “happens-before” <code>pop</code> 中的读取操作 <code>val = data[h]</code>, 这是通过 <code>write</code> 原子变量实现的: <code>push</code> 中对 <code>write</code> 的修改要 “synchronizes-with” <code>pop</code> 中对 <code>write</code> 的读取. 因此 <code>push</code> 修改 <code>write</code> 的 CAS 操作应该使用 release, <code>pop</code> 读取 <code>write</code> 时则应使用 acquire.</p><p>同理, 当队列初始为满的时候, 先运行 <code>pop</code> 在运行 <code>push</code>, 要保证 <code>pop</code> 中的读取操作 <code>val = data[h]</code> “happens-before” <code>push</code> 中的赋值操作 <code>data[t] = val</code>. 这是通过 <code>head</code> 原子变量实现的: <code>pop</code> 中对 <code>head</code> 的修改要 “synchronizes-with” <code>push</code> 中对 <code>head</code> 的读取. 因此 <code>pop</code> 修改 <code>head</code> 的 CAS 操作应该使用 release, <code>push</code> 读取 <code>head</code> 时则应使用 acquire.</p><p>这部分和上面一样，就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ring_buffer&lt;T, Cap&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> t, w;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t = tail.<span class="built_in">load</span>(memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">//(2)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_weak</span>(t, (t + <span class="number">1</span>) % Cap, memory_order_relaxed)); <span class="comment">// (3)</span></span><br><span class="line">    data[t] = val; <span class="comment">// (4), (4) happens-before (8)</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        w = t;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!write.<span class="built_in">compare_exchange_weak</span>(w, (w + <span class="number">1</span>) % Cap,</span><br><span class="line">              memory_order_release, memory_order_relaxed)); <span class="comment">// (5), (5) synchronizes-with (7)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ring_buffer&lt;T, Cap&gt;::<span class="built_in">pop</span>(T &amp;val) &#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        h = head.<span class="built_in">load</span>(memory_order_relaxed); <span class="comment">// (6)</span></span><br><span class="line">        <span class="keyword">if</span> (h == write.<span class="built_in">load</span>(memory_order_acquire)) <span class="comment">// (7)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data[h]; <span class="comment">// (8), (8) happens-before (4)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap,</span><br><span class="line">              memory_order_release, memory_order_relaxed)); <span class="comment">// (9), (9) synchronizes-with (2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 与 <code>push</code> 并发移动 <code>tail</code> 指针的时候, 只影响到 <code>tail</code> 本身. 因此 (1) 和 (3) 对 <code>tail</code> 读写使用 relaxed 就可以了. 同样 <code>push</code> 与 <code>push</code> 并发移动 <code>write</code> 指针时, 也不需要利用它做同步, 因此 (5) 处的做法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write.<span class="built_in">compare_exchange_weak</span>(w, (w + <span class="number">1</span>) % Cap,</span><br><span class="line">                            memory_order_release, memory_order_relaxed)</span><br></pre></td></tr></table></figure><p>成功时使用 release, 为了与 <code>pop</code> 同步; 而失败时使用 relaxed 就可以了.</p><p>同理, <code>pop</code> 与 <code>pop</code> 并发移动 <code>head</code> 时, 也影响到 <code>head</code> 本身. 因此 (6) 读取 <code>head</code> 使用 relaxed 即可. 而 (9) 处为了与 <code>push</code> 同步, 成功时要使用 release, 失败时使用 relaxed 即可.</p><p>最后，给出完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type __sync_val_compare_and_swap(type *ptr, type oldval type newval, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">data</span>(<span class="keyword">new</span> T[Cap]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t, w;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = tail.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span> ((t + <span class="number">1</span>) % Cap == head.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % Cap, memory_order_relaxed));</span><br><span class="line">        data[t % Cap] = val;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Producer:&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; data:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            w = t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!write.<span class="built_in">compare_exchange_strong</span>(w, (w + <span class="number">1</span>) % Cap, memory_order_release, memory_order_relaxed));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T val;</span><br><span class="line">        <span class="type">size_t</span> h;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span> (h == write.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            val = data[h % Cap];</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(h, (h + <span class="number">1</span>) % Cap,</span><br><span class="line">                                               memory_order_release, memory_order_relaxed));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Comsumer:&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; data:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;, tail&#123;<span class="number">0</span>&#125;, write&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="type">int</span>, <span class="number">5</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">pop</span>())</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">push</span>(num))</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;thread&gt; p, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p.<span class="built_in">emplace_back</span>(Producer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">emplace_back</span>(Consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ci : c)</span><br><span class="line">        ci.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pi : p)</span><br><span class="line">        pi.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表版本">链表版本</h2><p>废话少说，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeLockQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        T data;</span><br><span class="line">        atomic&lt;Node *&gt; next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">const</span> T &amp;x) : <span class="built_in">data</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    atomic&lt;Node *&gt; head;</span><br><span class="line">    atomic&lt;Node *&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreeLockQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">        head.<span class="built_in">store</span>(node);</span><br><span class="line">        tail.<span class="built_in">store</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FreeLockQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (Node *h = head.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Node *tmp = h-&gt;next.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">delete</span> h;</span><br><span class="line">            head.<span class="built_in">store</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作，将一个元素添加到队列的尾部</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *cur = <span class="keyword">new</span> <span class="built_in">Node</span>(x); <span class="comment">// 创建一个新的节点</span></span><br><span class="line">        Node *t = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = tail.<span class="built_in">load</span>();             <span class="comment">// 读取尾指针</span></span><br><span class="line">            Node *next = t-&gt;next.<span class="built_in">load</span>(); <span class="comment">// 读取尾节点的下一个节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t != tail.<span class="built_in">load</span>()) <span class="comment">// 检查尾指针是否被其他线程修改</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果尾指针被修改，则重新开始循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 假设现在有两个线程 A 和 B，他们同时尝试对队列进行 enqueue 操作。</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">nullptr</span>) <span class="comment">// 检查尾节点的下一个节点是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(t, next); <span class="comment">// 如果不为空，则尝试更新尾指针</span></span><br><span class="line">                <span class="keyword">continue</span>;                              <span class="comment">// 无论是否更新成功，都继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;next.<span class="built_in">compare_exchange_strong</span>(next, cur)) <span class="comment">// 尝试将尾节点的下一个节点设置为新节点</span></span><br><span class="line">                <span class="keyword">break</span>;                                      <span class="comment">// 如果设置成功，则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        tail.<span class="built_in">compare_exchange_strong</span>(t, cur); <span class="comment">// 尝试更新尾指针为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *h = <span class="literal">nullptr</span>; <span class="comment">// 创建一个指针 h，用来引用队列头部的节点</span></span><br><span class="line">        T d;               <span class="comment">// 创建一个变量 d，用来存储被出队元素的数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)       <span class="comment">// 循环，直到成功出队一个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = head.<span class="built_in">load</span>();             <span class="comment">// 读取头指针</span></span><br><span class="line">            Node *t = tail.<span class="built_in">load</span>();       <span class="comment">// 读取尾指针</span></span><br><span class="line">            Node *next = h-&gt;next.<span class="built_in">load</span>(); <span class="comment">// 读取头部节点的下一个节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h != head.<span class="built_in">load</span>()) <span class="comment">// 检查头指针是否被其他线程修改</span></span><br><span class="line">                <span class="keyword">continue</span>;         <span class="comment">// 如果头指针被修改，则重新开始循环</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h == t &amp;&amp; next == <span class="literal">nullptr</span>) <span class="comment">// 检查队列是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Can not dequeue from empty queue&quot;</span> &lt;&lt; endl; <span class="comment">// 如果队列为空，则输出错误信息</span></span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>)); <span class="comment">// 暂停一段时间，然后重新开始循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h == t &amp;&amp; next != <span class="literal">nullptr</span>) <span class="comment">// 检查头部节点是否已经被其他线程移动到尾部</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(t, next); <span class="comment">// 如果是，则尝试更新尾指针</span></span><br><span class="line">                <span class="keyword">continue</span>;                              <span class="comment">// 无论是否更新成功，都继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(h, next)) <span class="comment">// 尝试将头指针更新为下一个节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                d = next-&gt;data; <span class="comment">// 如果更新成功，则读取被出队元素的数据</span></span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">// 然后跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> h; <span class="comment">// 删除被出队的节点</span></span><br><span class="line">        <span class="keyword">return</span> d; <span class="comment">// 返回被出队元素的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FreeLockQueue&lt;<span class="type">int</span>&gt; mFQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mFQ.<span class="built_in">enqueue</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enqueue data: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; successfully!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mFQ.<span class="built_in">enqueue</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enqueue data: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; successfully!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = mFQ.<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="keyword">if</span> (d != <span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Get data: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; successfully!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">p1</span><span class="params">(producer1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">p2</span><span class="params">(producer2)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ca</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">cb</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">join</span>();</span><br><span class="line">    p2.<span class="built_in">join</span>();</span><br><span class="line">    ca.<span class="built_in">join</span>();</span><br><span class="line">    cb.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较难以理解的2个点：</p><p><strong>1.tail.compare_exchange_strong(t, next);这行代码什么时候为true？</strong></p><p>假设现在有两个线程 A 和 B，他们同时尝试对队列进行 <code>enqueue</code> 操作。</p><ol><li>线程 A 执行到 <code>t = tail.load()</code> 和 <code>Node *next = t-&gt;next.load()</code>，此时 <code>t</code> 是尾节点，<code>next</code> 是 <code>nullptr</code>。</li><li>线程 B 插入一个新节点，更新了尾指针和原尾节点的 <code>next</code> 指针。</li><li>线程 A 继续执行，此时它认为 <code>t</code> 还是尾节点，且 <code>t</code> 的 <code>next</code> 应该是 <code>nullptr</code>。但实际上，由于线程 B 的插入操作，<code>t</code> 的 <code>next</code> 已经不再是 <code>nullptr</code>。</li></ol><p>所以，在这个地方进行 <code>if (next != nullptr)</code> 的判断，就是为了检查这种情况。如果发现 <code>next</code> 不为空，说明尾节点已经被其他线程修改过，此时应该重新读取尾指针，并尝试将尾指针更新为 <code>next</code>。然后继续循环，直到成功将新节点添加到队列的尾部。</p><p><strong>2.tail.compare_exchange_strong(t, next); 这行代码什么时候为true？</strong></p><p>假设现在有两个线程 A 和 B，线程 A 正在执行 <code>dequeue</code> 操作，而线程 B 正在执行 <code>enqueue</code> 操作。</p><ol><li>线程 A 读取头指针 <code>h</code> 和尾指针 <code>t</code>，此时 <code>h</code> 和 <code>t</code> 都指向同一个节点，表示队列为空。</li><li>线程 B 在队列的尾部添加了一个新的节点，但尾指针 <code>tail</code> 还没有被更新。</li><li>线程 A 继续执行，此时它读取头部节点（也是尾部节点）的 <code>next</code> 指针，发现 <code>next</code> 不为空，即头部节点的后面有一个新的节点。</li><li>所以，线程 A 满足 <code>if (h == t &amp;&amp; next != nullptr)</code> 的条件，然后尝试使用 <code>compare_exchange_strong</code> 方法更新尾指针 <code>tail</code>。</li></ol><h2 id="ABA问题">ABA问题</h2><p><strong>问题概述</strong></p><p>在多线程编程中，CAS（Compare And Swap）是一种重要的无锁算法。CAS通过原子操作比较内存中的某个值和预期值，如果它们相等，就将内存中的值替换为新的值。但是，CAS也有一个著名的问题，就是ABA问题。</p><p>ABA问题是指，在CAS操作中，如果一个变量原来是A，经过其他线程的两次操作，变成了B，然后又变成了A，那么在使用CAS检查时，会发现它的值没有发生变化，但是实际上却发生了变化。这就是所谓的ABA问题。</p><p>例如，考虑一个多线程的栈实现。假设有两个线程，线程1和线程2。首先，线程1从栈中取出一个元素A，然后线程1被挂起。此时线程2执行，它从栈中取出元素A，然后压入新的元素B，接着再次压入元素A。当线程1恢复运行时，它会发现栈顶元素仍然是A，因此它认为没有其他线程修改过栈。然而，实际上栈的状态已经发生了改变。</p><p><strong>解决方法</strong></p><p>解决CAS中的ABA问题常用的方法是使用&quot;带版本号的CAS&quot;或者&quot;原子引用&quot;。这种方法在每次修改变量时，都会增加一个版本号。即使一个变量的值被改变后又被改回来，其版本号也会发生变化，因此可以避免ABA问题。</p><p>具体可以通过以下几步来解决ABA问题：</p><ol><li>增加一个版本号的记录。每次修改变量，都让版本号自增。这样，在执行CAS操作时，不仅会检查变量的值，还会检查版本号。</li><li>在执行CAS操作时，将版本号和变量的值一起作为CAS的比较对象。</li><li>如果在执行CAS操作时，版本号或变量的值有任何一个与预期不符，那么CAS操作就会失败。</li></ol><p>其中，简单的是直接使用boost库中的<code>boost::lockfree::queue</code>。这是一个线程安全的无锁队列，可以在多线程环境下使用。</p><p>参考文献</p><ul><li><a href="https://luyuhuang.tech/2022/10/30/lock-free-queue.html#cas-%E6%93%8D%E4%BD%9C">C++ 实现无锁队列</a></li><li><a href="https://blog.csdn.net/qq_43593404/article/details/130598220?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22130598220%22%2C%22source%22%3A%22qq_43593404%22%7D">无锁化栈、队列深入解析及实现</a></li><li><a href="https://github.com/jiapengwen/LockFreeCpp/tree/master">https://github.com/jiapengwen/LockFreeCpp/tree/master</a></li><li><a href="https://www.nowcoder.com/discuss/353157562482761728?sourceSSR=search">无锁队列讲解（多生产者多消费者场景）</a></li><li><a href="https://github.com/0voice/cpp_backend_awsome_blog/blob/main/%E3%80%90NO.222%E3%80%91Linux%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%97%A0%E9%94%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97ypipeyqueue%E8%AF%A6%E8%A7%A3.md">【NO.222】Linux基础组件之无锁消息队列ypipe/yqueue详解</a></li><li><a href="https://github.com/0voice/cpp_backend_awsome_blog/blob/main/%E3%80%90NO.186%E3%80%91ZeroMQ%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.md">【NO.186】ZeroMQ无锁队列的原理与实现</a></li><li><a href="https://github.com/slan-ning/coolshell-markdown/blob/main/2012/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0.md">无锁队列的实现</a></li></ul>]]></content>
    
    
    <summary type="html">Lock-Free Queue</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp内存顺序</title>
    <link href="https://penge666.github.io/posts/4c8902bb.html"/>
    <id>https://penge666.github.io/posts/4c8902bb.html</id>
    <published>2024-05-07T03:31:55.000Z</published>
    <updated>2024-05-07T13:27:13.984Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 将多线程纳入了标准. 一旦涉及到多线程, 就需要考虑<strong>并发</strong>, <strong>数据竞争 (date race)</strong>, <strong>线程同步</strong>等问题, 为此 C++ 提供了互斥锁 <code>std::mutex</code>, 原子变量 <code>std::atomic</code> 等标准库。</p><p>把博客中的例子理解清楚。</p><h2 id="1-原子变量">1. 原子变量</h2><p>我们不能在两个线程中同时访问修改一个变量, 这会导致数据竞争的问题. 程序的结果是未定义的. 从实现上来说, 我们不能保证读写操作是原子的, 例如 32 位机器上, 修改一个 64 位变量可能需要两条指令; 或者变量有可能只是在寄存器里, 对其的修改要在稍后才会写入内存. 解决数据竞争的方式除了使用 <code>std::mutex</code> 加锁, 还可以使用原子变量.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子展示了原子变量最简单的用法. 使用原子变量不用担心数据竞争, 对它的操作都是原子的. <strong>除此之外, 原子变量的操作可以指定内存顺序, 帮助我们实现线程同步, 这也是本文的重点</strong>. 上面的代码中, 线程 1 将值写入原子变量 <code>a</code>, 线程 2 则读取 <code>a</code> 中的值. 这便是原子变量最基础的两种操作。</p><h3 id="1-1-原子变量的操作">1.1 原子变量的操作</h3><p>对原子变量的操作可以分为三种</p><ol><li>store. 将一个值存到原子变量中.</li><li>load. 读取原子变量中的值.</li><li>read-modify-write (RMW). 原子地执行读取, 修改和写入. 如自增操作 <code>fetch_add</code>, 交换操作 <code>exchange</code> (返回变量当前的值并写入指定值) 等.</li></ol><p>每个原子操作都需要指定一个<strong>内存顺序 (memory order)</strong>. 不同的内存顺序有不同的语义, 会实现不同的顺序模型 (order model), 性能也各不相同. C++ 中有六种内存顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这六种内存顺序相互组合可以实现三种顺序模型 (ordering model)</strong></p><ul><li><strong>Sequencial consistent ordering. 实现同步, 且保证全局顺序一致 (single total order) 的模型. 是一致性最强的模型, 也是默认的顺序模型.</strong></li><li><strong>Acquire-release ordering. 实现同步, 但不保证保证全局顺序一致的模型.</strong></li><li><strong>Relaxed ordering. 不能实现同步, 只保证原子性的模型.</strong></li></ul><p>稍后我们会详细讨论这六种内存顺序. <code>atomic::store</code> 和 <code>atomic::load</code> 函数都有一个内存顺序的参数, 默认为 <code>memory_order_seq_cst</code>. 它们的声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">(T desired, std::memory_order order = std::memory_order_seq_cst)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>此外 <code>std::atomic</code> 重载了运算符, 我们可以像使用普通变量一样读写原子变量. 例如上面代码中两个线程的读写操作分别调用的是 <code>std::atomic&lt;int&gt;::operator=(int)</code> 和 <code>std::atomic&lt;int&gt;::operator int()</code>. 此时会使用默认的内存顺序, 也就是 <code>memory_order_seq_cst</code>。</p><h2 id="2-基础概念">2. 基础概念</h2><p>在开始讲这六种内存顺序之前, 有必要先了解一下几个最基础的概念.</p><h3 id="2-1-修改顺序-Modification-orders">2.1 修改顺序 (Modification orders)</h3><p>对一个原子变量的所有修改操作总是存在一定的先后顺序, 且所有线程都认可这个顺序, 即使这些修改操作是在不同的线程中执行的. 这个所有线程一致同意的顺序就称为<strong>修改顺序 (modification order)</strong>. 这意味着</p><ul><li>两个修改操作不可能同时进行, 一定存在一个先后顺序. 这很容易理解, 因为这是原子操作必须保证的, 否则就有数据竞争的问题.</li><li>即使每次运行的修改顺序可能都不同, 但所有线程看到的修改顺序总是一致的. 如果线程 a 看到原子变量 x 由 1 变成 2, 那么线程 b 就不可能看到 x 由 2 变成 1.</li></ul><p>无论使用哪种内存顺序, 原子变量的操作总能满足修改顺序一致性, 即使是最松散的 <code>memory_order_relaxed</code>. 我们来看一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">        a.<span class="built_in">store</span>(i, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">        a.<span class="built_in">store</span>(i, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        v-&gt;<span class="built_in">push_back</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread4</span><span class="params">(vector&lt;<span class="type">int</span>&gt; *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        v-&gt;<span class="built_in">push_back</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3, v4;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span>, <span class="title">t2</span><span class="params">(thread2)</span>, <span class="title">t3</span><span class="params">(thread3, &amp;v3)</span>, <span class="title">t4</span><span class="params">(thread4, &amp;v4)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(), t2.<span class="built_in">join</span>(), t3.<span class="built_in">join</span>(), t4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v3) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v4) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了 4 个线程. <code>thread1</code> 和 <code>thread2</code> 分别将偶数和奇数依次写入原子变量 <code>a</code>, <code>thread3</code> 和 <code>thread4</code> 则读取它们. 最后输出 <code>thread3</code> 和 <code>thread4</code> 每次读取到的值. 程序运行的结果可能是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-modification-order</span><br><span class="line"><span class="number">1</span> <span class="number">8</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">$ ./test-modification-order</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>虽然每次运行的修改顺序不同, 各个线程也不太可能看到每次修改的结果, 但是它们看到的修改顺序是一致的. 例如 <code>thread3</code> 看到 8 先于 9, <code>thread4</code> 也会看到 8 先于 9, 反之亦然.</p><h3 id="2-2-Happens-before">2.2 Happens-before</h3><p><strong>Happens-before</strong> 是一个非常重要的概念. 如果操作 a “happens-before” 操作 b, 则操作 a 的结果对于操作 b 可见. happens-before 的关系可以建立在用一个线程的两个操作之间, 也可以建立在不同的线程的两个操作之间.</p><h4 id="2-2-1-单线程的情况-sequenced-before">2.2.1 单线程的情况: sequenced-before</h4><p>单线程的情况很容易理解. 函数的语句按顺序依次执行, 前面的语句先执行, 后面的后执行. 正式地说, 前面的语句总是 <strong>“sequenced-before”</strong> 后面的语句. 显然, 根据定义, sequenced-before 具有传递性:</p><ul><li>如果操作 a “sequenced-before” 操作 k, 且操作 k “sequenced-before” 操作 b, 则操作 a “sequenced-before” 操作 b.</li></ul><p>Sequenced-before 可以直接构成 happens-before 的关系. 如果操作 a “sequenced-before” 操作 b, 则操作 a “happens-before” 操作 b. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">42</span>; <span class="comment">// (1)</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>语句 (1) 在语句 (2) 的前面, 因此语句 (1) “sequenced-before” 语句 (2), 也就是 (1) “happens-before” 语句 (2). 所以 (2) 可以打印出 (1) 赋值的结果.</p><h4 id="2-2-2-多线程的情况-synchronizes-with-和-inter-thread-happens-before">2.2.2 多线程的情况: synchronizes-with 和 inter-thread happens-before</h4><p>多线程的情况就稍微复杂些. 一般来说多线程都是并发执行的, 如果没有正确的同步操作, 就无法保证两个操作之间有 happens-before 的关系. 如果我们通过一些手段, 让不同线程的两个操作同步, 我们称这两个操作之间有 <strong>synchronizes-with</strong> 的关系. 稍后我们会详细讨论如何组合使用 6 种内存顺序, 让两个操作达成 synchronizes-with 的关系.</p><p>如果线程 1 中的操作 a “synchronizes-with” 线程 2 中的操作 b, 则操作 a <strong>“inter-thread happens-before”</strong> 操作 b. 此外 synchronizes-with 还可以 “后接” 一个 sequenced-before 关系组合成 inter-thread happens-before 的关系:</p><ul><li>如果操作 a “synchronizes-with” 操作 k, 且操作 k “sequenced-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li></ul><p>Inter-thread happens-before 关系则可以 “前接” 一个 sequenced-before 关系以延伸它的范围; 而且 inter-thread happens-before 关系具有传递性:</p><ul><li>如果操作 a “sequenced-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li><li>如果操作 a “inter-thread happens-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li></ul><p>正如它的名字暗示的, 如果操作 a “inter-thread happens-before” 操作 b, 则操作 a “happens-before” 操作 b. 下图展示了这几个概念之间的关系:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507143104191.png" alt=""></p><p>注意, 虽然 sequenced-before 和 inter-thread happens-before 都有传递性, 但是 <strong>happens-before 没有传递性</strong>. 后面我们会在 3.5 节中看到这个性质的重要性, 以及 C++ 为什么要定义这么多概念.</p><p>现在我们来看一个例子. 假设下面的代码中 <code>unlock()</code> 操作 “synchronizes-with” <code>lock()</code> 操作.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a += <span class="number">1</span> <span class="comment">// (1)</span></span><br><span class="line">    <span class="built_in">unlock</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(); <span class="comment">// (3)</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设直到 <code>thread1</code> 执行到 (2) 之前, <code>thread2</code> 都会阻塞在 (3) 处的 <code>lock()</code> 中. 那么可以推导出:</p><ul><li>根据语句顺序, 有 (1) “sequenced-before” (2) 且 (3) “sequenced-before” (4);</li><li>因为 (2) “synchronizes-with” (3) 且 (3) “sequenced-before” (4), 所以 (2) “inter-thread happens-before” (4);</li><li>因为 (1) “sequenced-before” (2) 且 (2) “inter-thread happens-before” (4), 所以 (1) “inter-thread happens-before” (4); 所以 (1) “happens-before” (4).</li></ul><p>因此 (4) 可以读到 (1) 对变量 <code>a</code> 的修改.</p><h3 id="2-3-Happens-before-不代表指令实际的执行顺序">2.3 Happens-before 不代表指令实际的执行顺序</h3><p>需要说明的是, happens-before 是 C++ 语义层面的概念, 它并不代表指令在 CPU 中实际的执行顺序. 为了优化性能, 编译器会在不破坏语义的前提下对指令重排. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有 <code>a++;</code> “happens-before” <code>b++;</code>, 但编译器实际生成的指令可能是先加载 <code>a</code>, <code>b</code> 两个变量到寄存器, 接着分别执行 “加一” 操作, 然后再执行 <code>a + b</code>, 最后才将自增的结果写入内存.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add():</span><br><span class="line">    movl    a(%rip), %eax   # 将变量 a 加载到寄存器</span><br><span class="line">    movl    b(%rip), %ecx   # 将变量 b 加载到寄存器</span><br><span class="line">    addl    $1, %eax        # a 的值加一</span><br><span class="line">    leal    1(%rcx), %edx   # b 的值加一</span><br><span class="line">    movl    %eax, a(%rip)   # 将 a 加一的结果写入内存</span><br><span class="line">    addl    %edx, %eax      # a + b</span><br><span class="line">    movl    %edx, b(%rip)   # 将 b 加一的结果写入内存</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>上面展示了 x86-64 下的一种可能的编译结果. 可以看到 C++ 的一条语句可能产生多条指令, 这些指令都是交错执行的. 其实编译器甚至还有可能先自增 <code>b</code> 再自增 <code>a</code>. 这样的重排并不会影响语义, 两个自增操作的结果仍然对 <code>return a + b;</code> 可见.</p><h2 id="3-内存顺序">3. 内存顺序</h2><p>前面我们提到 C++ 的六种内存顺序相互组合可以实现三种顺序模型. 现在我们来具体看看如何使用这六种内存顺序, 以及怎样的组合可以实现 synchronizes-with 的关系.</p><h3 id="3-1-memory-order-seq-cst">3.1 memory_order_seq_cst</h3><p><code>memory_order_seq_cst</code> 可以用于 store, load 和 read-modify-write 操作, 实现 sequencial consistent 的顺序模型. 在这个模型下, 所有线程看到的所有操作都有一个一致的顺序, 即使这些操作可能针对不同的变量, 运行在不同的线程. 2.1 节中我们介绍了修改顺序 (modification order), 即单一变量的修改顺序在所有线程看来都是一致的. Sequencial consistent 则将这种一致性扩展到了所有变量. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thread1</code> 和 <code>thread2</code> 分别修改原子变量 <code>x</code> 和 <code>y</code>. 运行过程中, 有可能先执行 (1) 再执行 (2), 也有可能先执行 (2) 后执行 (1). 但无论如何, 所有线程中看到的顺序都是一致的. 因此如果我们这样测试这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) ++z; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst)); <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) ++z; <span class="comment">// (6)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread1)</span>, <span class="title">b</span><span class="params">(thread2)</span>, <span class="title">c</span><span class="params">(read_x_then_y)</span>, <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(), b.<span class="built_in">join</span>(), c.<span class="built_in">join</span>(), d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">// (7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(7) 处的断言永远不会失败. <strong>因为 <code>x</code> 和 <code>y</code> 的修改顺序是全局一致的, 如果先执行 (1) 后执行 (2), 则 <code>read_y_then_x</code> 中循环 (5) 退出时, 能保证 <code>y</code> 为 <code>true</code>, 此时 <code>x</code> 也必然为 <code>true</code>, 因此 (6) 会被执行; 同理, 如果先执行 (2) 后执行 (1), 则循环 (3) 退出时 <code>y</code> 也必然为 <code>true</code>, 因此 (4) 会被执行. 无论如何, <code>z</code> 最终都不会等于 0.</strong></p><p>Sequencial consistent 可以实现 synchronizes-with 的关系. 如果一个 <code>memory_order_seq_cst</code> 的 load 操作在某个原子变量上读到了一个 <code>memory_order_seq_cst</code> 的 store 操作在这个原子变量中写入的值, 则 store 操作 “synchronizes-with” load 操作. 在上面的例子中, 有 (1) “synchronizes-with” (3) 和 (2) “synchronizes-with” (5).</p><p>实现 sequencial consistent 模型有一定的开销. 现代 CPU 通常有多核, 每个核心还有自己的缓存. 为了做到<strong>全局顺序一致</strong>, 每次写入操作都必须同步给其他核心. 为了减少性能开销, 如果不需要全局顺序一致, 我们应该考虑使用更加宽松的顺序模型.</p><h3 id="3-2-memory-order-relaxed">3.2 memory_order_relaxed</h3><p><code>memory_order_relaxed</code> 可以用于 store, load 和 read-modify-write 操作, 实现 relaxed 的顺序模型. 这种模型下, 只能保证操作的原子性和修改顺序 (modification order) 一致性, 无法实现 synchronizes-with 的关系. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thread1</code> 对不同的变量执行 store 操作. 那么在某些线程看来, 有可能是 <code>x</code> 先变为 <code>true</code>, y 后变为 <code>true</code>; 另一些线程看来, 又有可能是 <code>y</code> 先变为 <code>true</code>, <code>x</code> 后变为 <code>true</code>. 如果这样测试这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="built_in">assert</span>(x.<span class="built_in">load</span>()); <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) 处的断言就有可能失败. 因为 (2) 与 (3) 之间没有 synchronizes-with 的关系, 所以就不能保证 (1) “happens-before” (4). 因此 (4) 就有可能读到 <code>false</code>.</strong> 至于 relaxed 顺序模型能保证的修改顺序一致性的例子, 2.1 节中已经讨论过了, 这里就不多赘述了.</p><p>Relaxed 顺序模型的开销很小. 在 x86 架构下, <code>memory_order_relaxed</code> 的操作不会产生任何其他的指令, 只会影响编译器优化, 确保操作是原子的. Relaxed 模型可以用在一些不需要线程同步的场景, 但是使用时要小心. 例如 <code>std::shared_ptr</code> 增加引用计数时用的就是 <code>memory_order_relaxed</code>, 因为不需要同步; 但是减小应用计数不能用它, 因为需要与析构操作同步.</p><h3 id="3-3-Acquire-release">3.3 Acquire-release</h3><p>在 acquire-release 模型中, 会使用 <code>memory_order_acquire</code>, <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code> 这三种内存顺序. 它们的用法具体是这样的:</p><ul><li><p>对原子变量的 load 可以使用 <code>memory_order_acquire</code> 内存顺序. 这称为 <strong>acquire 操作</strong>.</p></li><li><p>对原子变量的 store 可以使用 <code>memory_order_release</code> 内存顺序. 这称为 <strong>release 操作</strong>.</p></li><li><p>read-modify-write 操作即读 (load) 又写 (store), 它可以使用 <code>memory_order_acquire</code>, <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code>:</p><ul><li>如果使用 <code>memory_order_acquire</code>, 则作为 acquire 操作;</li><li>如果使用 <code>memory_order_release</code>, 则作为 release 操作;</li><li>如果使用 <code>memory_order_acq_rel</code>, 则同时为两者.</li></ul></li></ul><p>Acquire-release 可以实现 synchronizes-with 的关系. 如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值, 则这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们来看一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="built_in">assert</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed)); <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中, 语句 (2) 使用 <code>memory_order_release</code> 在 <code>y</code> 中写入 <code>true</code>, 语句 (3) 中使用 <code>memory_order_acquire</code> 从 <code>y</code> 中读取值. 循环 (3) 退出时, 它已经读取到了 <code>y</code> 的值为 <code>true</code>, 也就是读取到了操作 (2) 中写入的值. 因此有 (2) “synchronizes-with” (3). 根据 2.2 节介绍的规则我们可以推导出:</p><ul><li>因为 (2) “synchronizes-with” (3) 且 (3) “sequenced-before” (4), 所以 (2) “inter-thread happens-before” (4);</li><li>因为 (1) “sequenced-before” (2) 且 (2) “inter-thread happens-before” (4), 所以 (1) “inter-thread happens-before” (4);</li></ul><p>所以 (1) “happens-before” (4). 因此 (4) 能读取到 (1) 中写入的值, 断言永远不会失败. 即使 (1) 和 (4) 用的是 <code>memory_order_relaxed</code>.</p><p>3.1 节我们提到 sequencial consistent 模型可以实现 synchronizes-with 关系. 事实上, 内存顺序为 <code>memory_order_seq_cst</code> 的 load 操作和 store 操作可以分别视为 acquire 操作和 release 操作. 因此对于两个指定了 <code>memory_order_seq_cst</code> 的 store 操作和 load 操作, 如果后者读到了前者写入的值, 则前者 “synchronizes-with” 后者.</p><p>为了实现 synchronizes-with 关系, acquire 操作和 release 操作应该成对出现. 如果 <code>memory_order_acquire</code> 的 load 读到了 <code>memory_order_relaxed</code> 的 store 写入的值, 或者 <code>memory_order_relaxed</code> 的 load 读到了 <code>memory_order_release</code> 的 store 写入的值, 都不能实现 synchronizes-with 的关系.</p><p><strong>虽然 sequencial consistent 模型能够像 acquire-release 一样实现同步, 但是反过来 acquire-release 模型不能像 sequencial consistent 一样提供全局顺序一致性.</strong> 如果将 3.1 节的例子中的 <code>memory_order_seq_cst</code> 换成 <code>memory_order_acquire</code> 和 <code>memory_order_release</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) ++z; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) ++z; <span class="comment">// (6)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则最终不能保证 <code>z</code> 不为 0. <strong>在同一次运行中, <code>read_x_then_y</code> 有可能看到先 (1) 后 (2), 而 <code>read_y_then_x</code> 有可能看到先 (2) 后 (1). 这样有可能 (4) 和 (6) 的 load 的结果都为 <code>false</code>, 导致最后 <code>z</code> 仍然为 0.</strong></p><p>Acquire-release 的开销比 sequencial consistent 小. 在 x86 架构下, <code>memory_order_acquire</code> 和 <code>memory_order_release</code> 的操作不会产生任何其他的指令, 只会影响编译器的优化: 任何指令都不能重排到 acquire 操作的前面, 且不能重排到 release 操作的后面; 否则会违反 acquire-release 的语义. 因此很多需要实现 synchronizes-with 关系的场景都会使用 acquire-release.</p><h3 id="3-4-Release-sequences">3.4* Release sequences</h3><p>到目前为止我们看到的, 无论是 sequencial consistent 还是 acquire-release, <strong>要想实现 synchronizes-with 的关系, acquire 操作必须在同一个原子变量上读到 release 操作的写入的值. 如果 acquire 操作没有读到 release 操作写入的值, 那么它俩之间通常没有 synchronizes-with 的关系</strong>. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// (1)</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="number">2</span>, std::memory_order_release); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// (4)</span></span><br><span class="line">    <span class="built_in">assert</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">1</span>); <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中, 只要 <code>y</code> 的值非 0 循环 (4) 就会退出. 当它退出时, 有可能读到 (2) 写入的值, 也有可能读到 (3) 写入的值. 如果是后者, 则只能保证 (3) “synchronizes-with” (4), 不能保证与 (2) 与 (4) 之间有同步关系. 因此 (5) 处的断言就有可能失败.</p><p>但并不是只有在 acquire 操作读取到 release 操作写入的值时才能构成 synchronizes-with 关系. 为了说这种情况, 我们需要引入 <strong>release sequence</strong> 这个概念.</p><p>针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. <strong>如果这一连串操作是由</strong></p><ul><li><strong>同一线程上的写操作, 或者</strong></li><li><strong>任意线程上的 read-modify-write 操作</strong></li></ul><p>这两种构成的, 则称这一连串的操作为<strong>以 release 操作 A 为首的 release sequence</strong>. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序.</p><p>如果一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们来看个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>); <span class="comment">// (1)</span></span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_relaxed)) <span class="comment">// (3)</span></span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>); <span class="comment">// (4)</span></span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中, (3) 处的 <code>compare_exchange_strong</code> 是一种 read-modify-write 操作, 它判断原子变量的值是否与期望的值 (第一个参数) 相等, 如果相等则将原子变量设置成目标值 (第二个参数) 并返回 <code>true</code>, 否则将第一个参数 (引用传递) 设置成原子变量当前值并返回 <code>false</code>. 操作 (3) 会一直循环检查, 当 <code>flag</code> 当值为 1 时, 将其替换成 2. 所以 (3) 属于 (2) 的 release sequence. 而循环 (4) 退出时, 它已经读到了 (3) 写入的值, 也就是 release 操作 (2) 为首的 release sequence 写入的值. 所以有 (2) “synchronizes-with” (4). 因此 (1) “happens-before” (5), (5) 处的断言不会失败.</p><p>注意 (3) 处的 <code>compare_exchange_strong</code> 的内存顺序是 <code>memory_order_relaxed</code>, 所以 (2) 与 (3) 并不构成 synchronizes-with 的关系. 也就是说, 当循环 (3) 退出时, 并不能保证 <code>thread2</code> 能读到 <code>data.at(0)</code> 为 42. 但是 (3) 属于 (2) 的 release sequence, 当 (4) 以 <code>memory_order_acquire</code> 的内存顺序读到 (2) 的 release sequence 写入的值时, 可以与 (2) 构成 synchronizes-with 的关系.</p><h3 id="3-5-memory-order-consume">3.5* memory_order_consume</h3><p><code>memory_order_consume</code> 其实是 acquire-release 模型的一部分, 但是它比较特殊, 它涉及到数据间相互依赖的关系. 为此我们又要提出两个新概念: <strong>carries dependency</strong> 和 <strong>dependency-ordered before</strong>.</p><p>如果操作 a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 一般来说, 如果 a 的值用作 b 的一个操作数, 或者 b 读取到了 a 写入的值, 都可以称为 b 依赖于 a. 例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p++;  <span class="comment">// (1)</span></span><br><span class="line">i++;  <span class="comment">// (2)</span></span><br><span class="line">p[i]; <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><p>有 (1) “sequenced-before” (2) “sequenced-before” (3); (1) 和 (2) 的值作为 (3) 的下标运算符 <code>[]</code> 的操作数, 所以有 (1) “carries a dependency into” (3) 和 (2) “carries a dependency into” (3). 但是 (1) 和 (2) 并没有相互依赖, 它们之间没有 carries dependency 的关系. 类似于 sequenced-before, carries dependency 关系具有传递性.</p><p><code>memory_order_consume</code> 可以用于 load 操作. 使用 <code>memory_order_consume</code> 的 load 称为 consume 操作. 如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值, 或以其为首的 release sequence 写入的值, 则这个 release 操作 “dependency-ordered before” 这个 consume 操作.</p><p>Dependency-ordered before 可以 “后接” 一个 carries dependency 的关系以延伸它的范围: 如果 a “dependency-ordered before” k 且 k “carries a dependency into” b, 则 a “dependency-ordered before” b. Dependency-ordered before 可以直接构成 inter-thread happens-before 的关系: 如果 a “dependency-ordered before” b 则 a “inter-thread happens-before” b.</p><p>概念很复杂, 但是基本思路是:</p><ul><li>release 操作和 acquire 操作构成的 synchronizes-with 可以后接 sequenced-before 构成 inter-thread happens-before 的关系;</li><li>release 操作和 consume 操作构成的 dependency-ordered before 则只能后接 carries dependency 构成 inter-thread happens-before 的关系.</li><li>无论 inter-thread happens-before 是怎么构成的, 都可以前接 sequenced-before 以延伸其范围.</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240507150744160.png" alt="image-20240507150744160"></p><p>我们来看一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// (1)</span></span><br><span class="line">    data = <span class="number">42</span>; <span class="comment">// (2)</span></span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume))); <span class="comment">// (4)</span></span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// (5)</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// (6)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 处的循环退出时, consume 操作 (4) 读取到 release 操作 (3) 写入的值, 因此 (3) “dependency-ordered before” (4). 由此可以推导出:</p><ul><li><code>p2</code> 的值作为 (5) 的操作数, 因此 (4) “carries a dependency into” (5);</li><li>因为 (3) “dependency-ordered before” (4) 且 (4) “carries a dependency into” (5), 所以 (3) “inter-thread happens-before” (5);</li><li>因为 (1) “sequenced-before” (3) 且 (3) “inter-thread happens-before” (5), 所以 (1) “inter-thread happens-before” (5);</li></ul><p>所以 (1) “happens-before” (5). 因此 (5) 可以读到 (1) 写入的值, 断言 (5) 不会失败. 但是操作 (6) 并不依赖于 (4), 所以 (3) 和 (6) 之间没有 inter-thread happens-before 的关系, 因此断言 (6) 就有可能失败. 回想 2.2 节强调过的, happens-before 没有传递性. 所以不能说因为 (3) “happens-before” (4) 且 (4) “happens-before” (6) 所以 (2) “happens-before” (6).</p><p>与 acquire-release 类似, 在 x86 下使用 <code>memory_order_consume</code> 的操作不会产生任何其他的指令, 只会影响编译器优化. 与 consume 操作有依赖关系的指令都不会重排到 consume 操作前面. 它对重排的限制比 acquire 宽松些, acquire 要求所有的指令都不能重排到它的前面, 而 consume 只要求有依赖关系的指令不能重排到它的前面. 因此在某些情况下, consume 的性能可能会高一些.</p><h2 id="4-例子">4. 例子</h2><blockquote><p><strong>自旋锁</strong></p></blockquote><p>在一些场景下, 如果锁被占用的时间很短, 我们会选择自旋锁, 以减少上下文切换的开销. 锁一般用来保护临界数据的读写, 我们希望同一时间只有一个线程能获取到锁, 且获取到锁后, 被锁保护的数据总是最新的. 前者通过原子操作即可保证, 而后者就需要考虑内存顺序了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">spinlock mu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span> ((val = <span class="built_in">read_from_remote</span>())) &#123;</span><br><span class="line">        mu.<span class="built_in">lock</span>(); <span class="comment">// (1)</span></span><br><span class="line">        queue.<span class="built_in">push_back</span>(val); <span class="comment">// (2)</span></span><br><span class="line">        mu.<span class="built_in">unlock</span>(); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        mu.<span class="built_in">lock</span>(); <span class="comment">// (4)</span></span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        queue.<span class="built_in">pop_front</span>(); <span class="comment">// (5)</span></span><br><span class="line">        mu.<span class="built_in">unlock</span>(); <span class="comment">// (6)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个线程并发运行, <code>thread1</code> 往队列里写入数据, <code>thread2</code> 从队列里读出数据. 入队操作 (2) 可能需要复制数据, 移动指针, 甚至 resize 队列, 因此我们要保证获取到锁时, 这些操作的结果完全可见. 出队操作也是同理. 所以自旋锁要保证 unlock 操作 “synchronizes-with” lock 操作, 保证锁保护的数据是完整的.</p><p>我们可以用 acquire-release 模型实现自旋锁. 下面是一个简单的实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">exchange</span>(<span class="literal">true</span>, std::memory_order_acquire)); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的实现中, (1) 处加锁用到的 <code>exchange</code> 是一种 read-modify-write 操作, 它将目标值 (第一个参数) 写入原子变量, 并返回写入前的值. 在这个实现中, 锁被占用时 <code>flag</code> 为 <code>true</code>. 如果锁被占用, (1) 处的 exchange 操作会一直返回 <code>true</code>, 线程阻塞在循环中; 直到锁被释放, <code>flag</code> 为 <code>false</code>, exchange 操作将 <code>flag</code> 重新置为 <code>true</code> 以抢占锁, 并且返回其原来的值 <code>false</code>, 循环退出, 加锁成功. 解锁则很简单, 将 <code>flag</code> 置为 <code>false</code> 即可.</p><p>由于解锁操作使用 <code>memory_order_release</code> 且加锁操作使用 <code>memory_order_acquire</code>, 所以能保证加锁成功时与上一次解锁操作构成 “synchronizes-with” 的关系, 也就是 unlock 操作 “synchronizes-with” lock 操作.</p><p>加锁时的 exchange 操作是一个 read-modify-write 操作, 它既读又写. 当它使用 <code>memory_order_acquire</code> 时, 只能保证它读的部分是一个 acquire 操作. 如果有两个线程抢占同一个锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spinlock mu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some operations</span></span><br><span class="line">    mu.<span class="built_in">lock</span>(); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu.<span class="built_in">lock</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 和 (2) 之间没有任何同步关系, 假设先执行操作 (1) 后执行操作 (2), 那么 <code>thread1</code> 中 (1) 之前的操作结果不一定对 <code>thread2</code> 可见. 但能确定的是, 只会有一个线程得到锁, 这是由原子变量的修改顺序 (modification order) 所保证的. 要么 <code>thread1</code> 先将 <code>flag</code> 置为 <code>true</code>, 要么 <code>thread2</code> 先将 <code>flag</code> 置为 <code>true</code>, 这个顺序是全局一致的.</p><h2 id="5-总结">5. 总结</h2><p>总结一下这几种内存顺序模型:</p><ul><li><code>memory_order_relaxed</code>: 最宽松的内存顺序, 只保证操作的<strong>原子性</strong>和<strong>修改顺序 (modification order)</strong>.</li><li><code>memory_order_acquire</code>, <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code>: 实现 <strong>acquire 操作</strong>和 <strong>release 操作</strong>, 如果 acquire 操作读到了 release 操作写入的值, 或其 release sequence 写入的值, 则构成 <strong>synchronizes-with 关系</strong>, 进而可以推导出 <strong>happens-before 的关系</strong>.</li><li><code>memory_order_consume</code>: 实现 <strong>consume 操作</strong>, 能实现数据依赖相关的同步关系. 如果 consume 操作读到了 release 操作写入的值, 或其 release sequence 写入的值, 则构成 <strong>dependency-ordered before 的关系</strong>, 对于有数据依赖的操作可以进而推导出 <strong>happens-before 的关系</strong>.</li><li><code>memory_order_seq_cst</code>: 加强版的 acquire-release 模型, 除了可以实现 <strong>synchronizes-with 关系</strong>, 还保证<strong>全局顺序一致</strong>.</li></ul><h2 id="6-资料">6. 资料</h2><ul><li><a href="https://nj.gitbooks.io/c/content/">《C++并发编程实战》</a></li><li><a href="https://www.zhihu.com/question/24301047">内存模型</a></li></ul><p>本文转载自：<a href="https://luyuhuang.tech/2022/06/25/cpp-memory-order.html#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F">谈谈 C++ 中的内存顺序 (Memory Order)</a></p><p>参考资料：</p><ul><li><a href="https://blog.51cto.com/quantfabric/2588193">C++性能优化（十三）——无锁队列</a></li><li><a href="%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">无锁队列的几种实现及其性能对比</a></li><li><a href="https://blog.csdn.net/xin_hen/article/details/108142403">C++11实现基于循环数组的无锁队列LockFreeArrayQueue</a></li><li><a href="https://zhuanlan.zhihu.com/p/638443455">揭秘C++无锁队列的几种实现及性能对比</a></li><li><a href="https://zhuanlan.zhihu.com/p/678154776">C++性能优化——无锁队列的原理与实现</a></li></ul>]]></content>
    
    
    <summary type="html">Memory Order</summary>
    
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CMake快速上手</title>
    <link href="https://penge666.github.io/posts/48ea1a6e.html"/>
    <id>https://penge666.github.io/posts/48ea1a6e.html</id>
    <published>2024-05-06T14:38:59.000Z</published>
    <updated>2024-05-06T15:23:10.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>CMake 不再使你在构建项目时郁闷地想自杀了。</p><p>插曲：之前在研究所做项目的时候，刘总总是暴力的使用sh脚本编译[狗头保命一波]，狠狠的暴力美学。但是，这对写lab的我有点难泵，于是乎，全给重写CMakeLists.txt文件的形式编译。</p><p>好了，基本文件的CMakeList.txt学习清楚后，就应该学习实际项目中CMakeLists.txt是如何规范书写，到实践中学习。</p><h2 id="介绍">介绍</h2><h3 id="跨平台设计原理">跨平台设计原理</h3><p>在大型C/C++项目中，跨平台设计是一个重要的考虑因素。跨平台设计的目标是使得源代码能够在多种操作系统和硬件架构上编译和运行，而无需进行大量的修改。这样可以大大提高代码的可移植性和复用性，降低维护成本。</p><p>CMake（Cross-platform Make）是一个开源的、跨平台的自动化建构系统，它允许开发者编写一份通用的CMakeList.txt文件来控制编译过程，而不需要修改特定平台下的编译配置，从而实现真正意义上的跨平台编译。</p><p>CMake支持多种编译器，包括GCC，Clang，Visual Studio等，并且可以生成各种类型的项目文件，如Makefile，Ninja，Visual Studio解决方案等。这使得CMake成为了跨平台C/C++项目的首选构建工具。</p><p>在CMake中，跨平台设计的实现主要依赖于以下几个原理：</p><ol><li><strong>抽象层</strong>：CMake为各种操作系统和编译器提供了一套抽象层，开发者只需要关注源代码和依赖库，而无需关心具体的编译器和操作系统。这是通过在CMakeList.txt文件中设置目标（target）和属性（property）来实现的。</li><li><strong>模块系统</strong>：CMake提供了一套模块系统，用于查找库和包，检查编译器和系统特性，以及管理测试等。这些模块大大简化了跨平台开发的复杂性。</li><li><strong>生成器</strong>：CMake通过生成器（generator）将CMakeList.txt文件转换为特定平台下的构建文件。生成器根据目标系统的特性，自动处理平台相关的编译和链接问题。</li><li><strong>变量和条件</strong>：CMake支持变量和条件语句，使得开发者可以根据不同的平台和编译器，选择不同的源文件和编译选项。</li></ol><p>以上就是CMake实现跨平台设计的基本原理，接下来我们将深入探讨CMake在跨平台设计中的应用。</p><h3 id="跨平台设计">跨平台设计</h3><p>在大型C/C++项目中，跨平台设计是必不可少的一环。这主要涉及到如何使用CMake来配置和管理不同平台的编译环境。</p><p><strong>CMake的跨平台特性</strong></p><p>CMake本身就是一个跨平台的构建工具，它可以在Windows、Linux、Mac等多种操作系统上运行。CMake通过生成平台相关的构建文件（如Unix的Makefile，Windows的nmake文件或Visual Studio项目文件等）来实现跨平台构建。这意味着，我们可以编写一套CMake构建脚本，然后在不同的平台上生成相应的构建文件，从而实现跨平台构建。</p><p><strong>使用CMake进行跨编译</strong></p><p>跨编译是指在一个平台上生成另一个平台的可执行代码。例如，我们可能需要在Linux平台上编译出运行在嵌入式设备上的ARM架构的代码。CMake支持跨编译，我们可以通过设置CMake的工具链文件（Toolchain File）来指定交叉编译器和相关的编译选项。</p><p>在CMake的工具链文件中，我们可以设置如下变量：</p><ul><li><code>CMAKE_SYSTEM_NAME</code>：目标系统的名称，如Linux、Windows、Android等。</li><li><code>CMAKE_SYSTEM_PROCESSOR</code>：目标系统的处理器架构，如x86、arm等。</li><li><code>CMAKE_C_COMPILER</code>、<code>CMAKE_CXX_COMPILER</code>：C和C++的交叉编译器的路径。</li><li><code>CMAKE_FIND_ROOT_PATH</code>：在查找库和头文件时，CMake应该查找的路径。</li></ul><p>通过设置这些变量，我们可以告诉CMake我们要编译的目标平台是什么，以及应该使用哪些工具进行编译。</p><p><strong>处理平台相关的代码</strong></p><p>在大型C/C++项目中，通常会有一些平台相关的代码。例如，Windows平台和Linux平台的系统调用是不同的，处理文件路径的方式也是不同的。我们需要在CMake构建脚本中检测目标平台，然后根据目标平台来决定编译哪些源文件。</p><p>CMake提供了<code>if</code>命令来进行条件判断。我们可以使用<code>CMAKE_SYSTEM_NAME</code>变量来判断目标平台。例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    <span class="comment"># 编译Linux平台的源文件</span></span><br><span class="line">    <span class="keyword">add_library</span>(mylib linux_specific_code.c)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">    <span class="comment"># 编译Windows平台的源文件</span></span><br></pre></td></tr></table></figure><p>以下是跨平台设计的流程图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240506230531403.png" alt="image-20240506230531403"></p><p>在大型C/C++项目中，我们需要考虑到跨平台设计。这主要涉及到如何使用CMake来配置和管理不同平台的编译环境。CMake本身就是一个跨平台的构建工具，它可以在Windows、Linux、Mac等多种操作系统上运行。CMake通过生成平台相关的构建文件（如Unix的Makefile，Windows的nmake文件或Visual Studio项目文件等）来实现跨平台构建。</p><p>跨编译是指在一个平台上生成另一个平台的可执行代码。例如，我们可能需要在Linux平台上编译出运行在嵌入式设备上的ARM架构的代码。CMake支持跨编译，我们可以通过设置CMake的工具链文件（Toolchain File）来指定交叉编译器和相关的编译选项。</p><p>在大型C/C++项目中，通常会有一些平台相关的代码。例如，Windows平台和Linux平台的系统调用是不同的，处理文件路径的方式也是不同的。我们需要在CMake构建脚本中检测目标平台，然后根据目标平台来决定编译哪些源文件。CMake提供了<code>if</code>命令来进行条件判断。我们可以使用<code>CMAKE_SYSTEM_NAME</code>变量来判断目标平台。</p><h3 id="跨平台设计案例">跨平台设计案例</h3><p>在实践中，跨平台设计是一个复杂的过程，需要考虑到各种因素。以下是一些实践和案例，帮助我们更好地理解跨平台设计的过程和挑战。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240506230621696.png" alt="image-20240506230621696"></p><p>首先，我们需要理解平台差异（Understanding Platform Differences）。不同的操作系统和硬件平台有不同的特性和限制。例如，Windows和Linux在文件系统、线程管理和网络编程等方面有显著的差异。理解这些差异是设计跨平台应用的第一步。</p><p>其次，选择合适的工具和库（Choosing Appropriate Tools and Libraries）也是非常重要的。有些工具和库是跨平台的，可以在多种操作系统和硬件平台上运行。例如，CMake就是一个跨平台的构建工具，可以在Windows、Linux和MacOS上使用。使用这些工具和库可以大大简化跨平台设计的复杂性。</p><p>然后，编写可移植的代码（Writing Portable Code）是另一个关键步骤。可移植的代码是指可以在多种平台上编译和运行的代码。为了实现代码的可移植性，我们需要避免使用特定平台的特性和API，或者使用预处理器指令来处理平台差异。</p><p>最后，进行全面的测试（Comprehensive Testing）是确保跨平台应用正确运行的重要步骤。我们需要在所有目标平台上测试应用，确保它在各种环境中都能正常工作。</p><p>以上就是跨平台设计的一些基本步骤和实践。在实际的项目中，我们可能还需要考虑到其他的因素，如性能、安全性和用户体验等。但是，只要我们遵循这些基本原则，我们就可以设计出高质量的跨平台应用。</p><h2 id="基本使用">基本使用</h2><h3 id="常用命令">常用命令</h3><p><strong>1. 指定 cmake 的最小版本</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这行命令是可选的，当然可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p><p><strong>2. 设置项目名称</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">project</span>(demo)</span><br></pre></td></tr></table></figure><p>这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p><p><strong>3. 设置编译类型</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(demo demo.cpp) # 生成可执行文件</span><br><span class="line"><span class="built_in">add_library</span>(common STATIC util.cpp) # 生成静态库</span><br><span class="line"><span class="built_in">add_library</span>(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></table></figure><p>add_library 默认生成是静态库，通过以上命令生成文件名字，</p><ul><li>在 Linux 下是：<br>demo<br>libcommon.a<br><a href="http://libcommon.so">libcommon.so</a></li><li>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</li></ul><p><strong>4. 指定编译包含的源文件</strong></p><p>4.1 明确指定包含哪些源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(demo demo.cpp test.cpp util.cpp)</span><br></pre></td></tr></table></figure><p>4.2 搜索所有的 cpp 文件</p><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST) # 搜索当前目录下的所有<span class="selector-class">.cpp</span>文件</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>4.3 自定义搜索规则</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span>(GLOB SRC_LIST &quot;*.cpp&quot; &quot;protocol/*.cpp&quot;)</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125;)</span><br><span class="line"># 或者</span><br><span class="line"><span class="built_in">file</span>(GLOB SRC_LIST &quot;*.cpp&quot;)</span><br><span class="line"><span class="built_in">file</span>(GLOB SRC_PROTOCOL_LIST &quot;protocol/*.cpp&quot;)</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br><span class="line"># 或者</span><br><span class="line"><span class="built_in">file</span>(GLOB_RECURSE SRC_LIST &quot;*.cpp&quot;) #递归搜索</span><br><span class="line"><span class="built_in">FILE</span>(GLOB SRC_PROTOCOL RELATIVE &quot;protocol&quot; &quot;*.cpp&quot;) # 相对protocol目录下搜索</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br><span class="line"># 或者</span><br><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="built_in">aux_source_directory</span>(protocol SRC_PROTOCOL_LIST)</span><br><span class="line"><span class="built_in">add_library</span>(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br></pre></td></tr></table></figure><p><strong>5. 查找指定的库文件</strong></p><p>find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。<br>默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              <span class="keyword">log</span>-lib</span><br><span class="line"> </span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              <span class="keyword">log</span> )</span><br></pre></td></tr></table></figure><p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p><p><strong>6. 设置包含的目录</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>7. 设置链接库搜索目录</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">link_directories</span>(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>8. 设置 target 需要链接的库</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>( # 目标库</span><br><span class="line">                       demo</span><br><span class="line"> </span><br><span class="line">                       # 目标库需要链接的库</span><br><span class="line">                       # log-lib 是上面 find_library 指定的变量名</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 <a href="http://xxx.so">xxx.so</a> 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p><p>8.1 指定链接动态库或静态库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(demo libface.a) # 链接libface.<span class="function">a</span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(demo libface.so)</span> # 链接libface.so</span></span><br></pre></td></tr></table></figure><p>8.2 指定全路径</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.a)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.so)</span><br></pre></td></tr></table></figure><p>8.3 指定链接多个库</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(demo</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.a</span><br><span class="line">    boost_system.a</span><br><span class="line">    boost_thread</span><br><span class="line">    pthread)</span><br></pre></td></tr></table></figure><p><strong>9. 设置变量</strong></p><p>9.1 set 直接设置变量的值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(SRC_LIST main.cpp test.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>9.2 set 追加设置变量的值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(SRC_LIST main.cpp)</span><br><span class="line"><span class="built_in">set</span>(SRC_LIST $&#123;SRC_LIST&#125; test.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>9.3 list 追加或者删除变量的值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(SRC_LIST main.cpp)</span><br><span class="line"><span class="built_in">list</span>(APPEND SRC_LIST test.cpp)</span><br><span class="line"><span class="built_in">list</span>(REMOVE_ITEM SRC_LIST main.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p><strong>10. 条件控制</strong></p><p>10.1 if…elseif…else…endif</p><p>逻辑判断和比较：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (expression)：expression 不为空（<span class="number">0</span>,N,NO,OFF,FALSE,NOTFOUND）时为真</span><br><span class="line">if (not exp)：与上面相反</span><br><span class="line">if (var1 AND var2)</span><br><span class="line">if (var1 OR var2)</span><br><span class="line">if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真</span><br><span class="line">if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真</span><br><span class="line">if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径</span><br><span class="line">if (IS_DIRECTORY dir)：当 dir 是目录时为真</span><br><span class="line">if (DEFINED var)：如果变量被定义为真</span><br><span class="line">if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 <span class="selector-tag">var</span> 可以用 <span class="selector-tag">var</span> 名，也可以用 $&#123;<span class="selector-tag">var</span>&#125;</span><br><span class="line">if (string MATCHES regex)</span><br></pre></td></tr></table></figure><p>数字比较：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (variable LESS number)：LESS 小于</span><br><span class="line">if (string LESS number)</span><br><span class="line">if (variable GREATER number)：GREATER 大于</span><br><span class="line">if (string GREATER number)</span><br><span class="line">if (variable EQUAL number)：EQUAL 等于</span><br><span class="line">if (string EQUAL number)</span><br></pre></td></tr></table></figure><p>字母表顺序比较：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (variable STRLESS string)</span><br><span class="line">if (string STRLESS string)</span><br><span class="line">if (variable STRGREATER string)</span><br><span class="line">if (string STRGREATER string)</span><br><span class="line">if (variable STREQUAL string)</span><br><span class="line">if (string STREQUAL string)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if(MSVC)</span><br><span class="line">    set(LINK_LIBS common)</span><br><span class="line">else()</span><br><span class="line">    set(boost_thread boost_log.a boost_system.a)</span><br><span class="line">endif()</span><br><span class="line">target_link_libraries(demo $&#123;LINK_LIBS&#125;)</span><br><span class="line"># 或者</span><br><span class="line">if(UNIX)</span><br><span class="line">    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -fpermissive -g&quot;)</span><br><span class="line">else()</span><br><span class="line">    add_definitions(-D_SCL_SECURE_NO_WARNINGS</span><br><span class="line">    D_CRT_SECURE_NO_WARNINGS</span><br><span class="line">    -D_WIN32_WINNT=0x601</span><br><span class="line">    -D_WINSOCK_DEPRECATED_NO_WARNINGS)</span><br><span class="line">endif()</span><br><span class="line"> </span><br><span class="line">if($&#123;CMAKE_BUILD_TYPE&#125; MATCHES &quot;debug&quot;)</span><br><span class="line">    ...</span><br><span class="line">else()</span><br><span class="line">    ...</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>10.2 while…endwhile</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span>(condition)</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">endwhile</span>()</span><br></pre></td></tr></table></figure><p>10.3 foreach…endforeach</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foreach</span>(loop_var RANGE start stop [step])</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">endforeach</span>(loop_var)</span><br></pre></td></tr></table></figure><p>start 表示起始数，stop 表示终止数，step 表示步长，示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foreach</span>(i RANGE <span class="number">1</span> <span class="number">9</span> <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">message</span>($&#123;i&#125;)</span><br><span class="line"><span class="built_in">endforeach</span>(i)</span><br><span class="line"># 输出：<span class="number">13579</span></span><br></pre></td></tr></table></figure><p><strong>11. 打印信息</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">message</span>($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class="line"><span class="built_in">message</span>(&quot;build with debug mode&quot;)</span><br><span class="line"><span class="built_in">message</span>(WARNING &quot;this is warnning message&quot;)</span><br><span class="line"><span class="built_in">message</span>(FATAL_ERROR &quot;this build has many error&quot;) # FATAL_ERROR 会导致编译失败</span><br></pre></td></tr></table></figure><p><strong>12. 包含其它 cmake 文件</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include</span>(./common.cmake) # 指定包含文件的全路径</span><br><span class="line"><span class="built_in">include</span>(def) # 在搜索路径中搜索def<span class="selector-class">.cmake</span>文件</span><br><span class="line"><span class="built_in">set</span>(CMAKE_MODULE_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake) # 设置include的搜索路径</span><br></pre></td></tr></table></figure><h3 id="常用信息">常用信息</h3><p><strong>1.预定义变量</strong></p><ul><li>PROJECT_SOURCE_DIR：工程的根目录</li><li>PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build</li><li>PROJECT_NAME：返回通过 project 命令定义的项目名称</li><li>CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径</li><li>CMAKE_CURRENT_BINARY_DIR：target 编译目录</li><li>CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径</li><li>CMAKE_CURRENT_LIST_LINE：当前所在的行</li><li>CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH</li><li>${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块</li><li>EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置</li><li>LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</li></ul><p><strong>2. 环境变量</strong></p><p>使用环境变量</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ENV</span>&#123;Name&#125;</span><br></pre></td></tr></table></figure><p>写入环境变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;Name&#125; <span class="keyword">value</span>) <span class="meta"># 这里没有“$”符号</span></span><br></pre></td></tr></table></figure><p>3.系统信息</p><ul><li>CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3</li><li>CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4</li><li>CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1</li><li>CMAKE_SYSTEM：系统名称，比如 Linux-­2.6.22­</li><li>CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux­</li><li>CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22</li><li>CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686</li><li>UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin</li><li>WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin</li></ul><p>4.主要开关选项</p><ul><li>BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库</li><li>CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加</li><li>CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DENABLE_DEBUG -DABC) <span class="comment"># 参数之间用空格分隔</span></span><br></pre></td></tr></table></figure><h2 id="实战">实战</h2><p>在实践之前，先看份去年写的CMakeList.txt，截取部分。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 打印CMake模块路径</span><br><span class="line"><span class="built_in">message</span>(&quot;CMake module path: $&#123;CMAKE_MODULE_PATH&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 设置CMake的最低版本要求为<span class="number">2.8</span></span><br><span class="line"><span class="built_in">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line"># 设置C++编译器的标志，启用C++<span class="number">11</span>标准</span><br><span class="line"><span class="built_in">SET</span>(CMAKE_CXX_FLAGS &quot;-std=c++<span class="number">11</span>&quot;)</span><br><span class="line"></span><br><span class="line"># 添加编译选项，启用-Wformat警告</span><br><span class="line"><span class="built_in">add_compile_options</span>(-Wformat)</span><br><span class="line"></span><br><span class="line"># 设置项目名称为&quot;task&quot;</span><br><span class="line"><span class="built_in">project</span>(task)</span><br><span class="line"></span><br><span class="line"># 设置OpenCV的路径，并查找OpenCV库</span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR &quot;/usr/local/include/opencv2&quot;)</span><br><span class="line"><span class="built_in">find_package</span>( OpenCV <span class="number">2</span>  REQUIRED )</span><br><span class="line"></span><br><span class="line"># 将OpenCV的头文件目录添加到包含目录中</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 查找libtiff库，并将其头文件目录添加到包含目录中</span><br><span class="line"><span class="built_in">find_package</span>(TIFF REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;TIFF_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 设置libgdal库的路径，并将其头文件目录添加到包含目录中</span><br><span class="line"><span class="built_in">set</span>(LIBGDAL_INCLUDE_DIR &quot;/usr/local/include&quot;)</span><br><span class="line"><span class="built_in">set</span>(LIBGDAL_LIBRARY &quot;/usr/local/lib64/libgdal.so&quot;)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;LIBGDAL_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 将libgdal库添加到链接库中</span><br><span class="line"><span class="built_in">link_libraries</span>($&#123;LIBGDAL_LIBRARY&#125;)</span><br><span class="line"></span><br><span class="line"># 添加一个名为&quot;task&quot;的可执行文件目标，设置其源文件</span><br><span class="line"><span class="built_in">add_executable</span>( </span><br><span class="line">    task </span><br><span class="line">    src/main.cpp</span><br><span class="line">    include/XmlParse/tinyxml.cpp</span><br><span class="line">    include/XmlParse/tinyxmlparser.cpp</span><br><span class="line">    include/XmlParse/tinyxmlerror.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 将OpenCV库、libtiff库和libraw库添加到&quot;task&quot;目标的链接库中</span><br><span class="line"><span class="built_in">target_link_libraries</span>(task  $&#123;OpenCV_LIBS&#125; $&#123;TIFF_LIBRARIES&#125; $&#123;LIBRAW_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 将pthread库添加到&quot;task&quot;目标的链接库中</span><br><span class="line"><span class="built_in">target_link_libraries</span>(task  -lpthread)</span><br><span class="line"></span><br><span class="line"># 将openmp库添加到&quot;task&quot;目标的链接库中</span><br><span class="line"><span class="built_in">target_link_libraries</span>(task  -fopenmp)</span><br></pre></td></tr></table></figure><h3 id="单个源文件">单个源文件</h3><p>(源代码所在目录：Demo1)</p><p>假设现在我们的项目中只有一个源文件<a href="https://link.zhihu.com/?target=http%3A//main.cc">http://main.cc</a>，该程序的用途是计算一个数的指数幂。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * power - Calculate the power of number.</span><br><span class="line"> * @param base: Base value.</span><br><span class="line"> * @param exponent: Exponent value.</span><br><span class="line"> *</span><br><span class="line"> * @return base raised to the power exponent.</span><br><span class="line"> */</span><br><span class="line">double power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    int result = base;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if (exponent == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(i = 1; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先编写 CMakeLists.txt 文件，并保存在与<a href="https://link.zhihu.com/?target=http%3A//mian.cc">http://mian.cc</a>源文件同个目录下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo1)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc)</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p><p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><ol><li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li><li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li><li><code>add_executable</code>： 将名为 <a href="http://main.cc">main.cc</a> 的源文件编译成一个名称为 Demo 的可执行文件。</li></ol><p>之后，在当前目录执行<code>cmake .</code>，得到 Makefile 后再使用<code>make</code>命令编译得到 Demo1 可执行文件。</p><h3 id="多个源文件">多个源文件</h3><p>(源代码所在目录Demo2)</p><p>上面的例子只有单个源文件。现在假如把<code>power</code>函数单独写进一个名为<code>MathFunctions.c</code>的源文件里，使得这个工程变成如下的形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure><p>这个时候，CMakeLists.txt 可以改成如下的形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure><p>唯一的改动只是在<code>add_executable</code>命令中增加了一个<code>MathFunctions.cc</code>源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用<code>aux_source_directory</code>命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><p>因此，可以修改 CMakeLists.txt 如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量<code>DIR_SRCS</code>，再指示变量<code>DIR_SRCS</code>中的源文件需要编译成一个名称为 Demo 的可执行文件。</p><h3 id="多个目录，多个源文件">多个目录，多个源文件</h3><p>(源代码所在目录Demo3)</p><p>现在进一步将 MathFunctions.h 和<a href="https://link.zhihu.com/?target=http%3A//MathFunctions.cc">http://MathFunctions.cc</a>文件移动到 math 目录下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure><p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p><p>根目录中的 CMakeLists.txt ：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo3)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 添加 math 子目录</span><br><span class="line">add_subdirectory(math)</span><br><span class="line"></span><br><span class="line"># 指定生成目标 </span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line"># 添加链接库</span><br><span class="line">target_link_libraries(Demo MathFunctions)</span><br></pre></td></tr></table></figure><p>该文件添加了下面的内容: 第3行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p><p>子目录中的 CMakeLists.txt：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"># 生成链接库</span><br><span class="line">add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>在该文件中使用命令<code>add_library</code>将 src 目录中的源文件编译为静态链接库。</p><h2 id="资料">资料</h2><ul><li><a href="https://gavinliu6.github.io/CMake-Practice-zh-CN/#/acquaintance">cmake实战</a></li><li><a href="https://zhuanlan.zhihu.com/p/661284252">CMake构建大型C_C++项目：跨平台设计与高级应用</a></li><li><a href="https://blog.csdn.net/afei__/article/details/81201039">CMakeLists.txt 语法介绍与实例演练</a></li></ul>]]></content>
    
    
    <summary type="html">CMake快速上手</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模型</title>
    <link href="https://penge666.github.io/posts/161dcf21.html"/>
    <id>https://penge666.github.io/posts/161dcf21.html</id>
    <published>2024-05-06T13:47:26.000Z</published>
    <updated>2024-05-06T13:49:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>这个仓库主记录了生产者和消费者模式中经典的案例。</p><h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>完整代码见仓库：<a href="https://github.com/Penge666/Producer-Consumer-Pattern">https://github.com/Penge666/Producer-Consumer-Pattern</a></p><p><strong>1.CPU轮询等待版单生产者单消费者：</strong>（basic.cpp）</p><p>该版本使用了简单的轮询机制，生产者不断地检查消费者是否已经消费完数据。这种模式简单直接，但效率较低，因为生产者在没有数据时仍然在忙等待。</p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">           data_ = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;生产data:&quot;</span> &lt;&lt; data_ &lt;&lt; endl;</span><br><span class="line">           ready_ = <span class="literal">true</span>;</span><br><span class="line">           lock.<span class="built_in">unlock</span>();</span><br><span class="line">           <span class="keyword">while</span> (ready_)</span><br><span class="line">           &#123;</span><br><span class="line">               this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span> (!ready_)</span><br><span class="line">           &#123;</span><br><span class="line">               this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;消费data:&quot;</span> &lt;&lt; data_ &lt;&lt; endl;</span><br><span class="line">           ready_ = <span class="literal">false</span>;</span><br><span class="line">           lock.<span class="built_in">unlock</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>2.等待通知版单生产者单消费者：</strong>（single.cpp）</p><p>该版本引入了等待通知机制，生产者在没有数据时会等待消费者的通知。这种模式避免了忙等待，提高了效率，同时减少了资源消耗。</p><p><strong>实现</strong></p><p>在这个版本我们借助condition_variable，完成多线程之间的同步操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv_;</span><br><span class="line"><span class="type">bool</span> ready_&#123;<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure><p>生产者会不断生成一个随机数并将其存储在 data<em> 变量中，然后将 ready</em> 标志设置为 true，表示有可用的数据。接着，它通知等待的消费者线程，然后自己等待消费者线程处理完数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !ready_; &#125;);</span><br></pre></td></tr></table></figure><p>消费者将会在一个无限循环中等待生产者通知数据的可用性。当 ready<em> 标志为 true 时，它会从 data</em> 变量中获取数据并进行处理，然后将 ready_ 标志设置为 false，表示数据已经被消费。接着，它通知生产者线程，然后自己等待生产者线程生成新的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> ready_; &#125;);</span><br></pre></td></tr></table></figure><p><strong>3.等待通知版单生产者多消费者：</strong>（mutiple.cpp）</p><p>在这个版本中，引入了多个消费者，它们共享生产者的数据。生产者在产生数据后，通知所有消费者进行处理。</p><p><strong>实现</strong></p><p>前面的版本中，我们还是单生产，单个消费者，如何做到多个消费者抢占消费？</p><p>此时需要引入队列，我们将任务丢到队列中去，随后多个消费者进行消费即可，与上述等待条件不同点在于队列的状态。</p><p>对于生产者：如果队列大小未达到 max<em>queue_size</em> 的限制，如果队列已满，则生产者线程将等待消费者线程从队列中取走一些数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> queue_.<span class="built_in">size</span>() &lt; max_queue_size_; &#125;); </span><br></pre></td></tr></table></figure><p>对于消费者：队列有数据就消费，否则等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.<span class="built_in">wait</span>(ul, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure><p><strong>4.等待通知版多生产者多消费者：</strong>（mutiple_mutiple.cpp）</p><p>这个版本支持多个生产者和多个消费者，生产者之间和消费者之间共享数据。生产者在产生数据后，通知所有消费者进行处理。</p><p><strong>实现</strong></p><p>对于这个版本比较简单，基于第三个版本继续优化，创建n个生产者线程即可。</p><p><strong>5.单生产者多消费者并行版：</strong>（mutiple_sync.cpp）</p><p>在这个版本中，引入了并行处理机制，多个消费者可以同时处理数据。生产者产生数据后，多个消费者并行处理，提高了整体处理速度。</p><p><strong>实现</strong></p><p>对于以上版本有个比较大的问题，当生产者生产的数据到达上限时，消费者此时在消费，而生产者并没有动起来，它在等待消费者消费完才能进行，如何让生产者与消费者同时运转呢？</p><p>改进点在于使用多个cv，来回切换通知。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv_producer_;</span><br><span class="line">std::condition_variable cv_consumer_;</span><br></pre></td></tr></table></figure><p><strong>6.多生产者多消费者并行版：</strong>（mutiple_mutiple_sync.cpp）</p><p>这个版本支持多个生产者和多个消费者，并且允许并行处理。多个生产者并行产生数据，多个消费者并行处理数据，提高了整体并发能力。</p><p><strong>实现</strong></p><p>基于5进行改造，支持多个生产者即可。</p><p><strong>7.支持Lambda回调的优雅停止版：</strong>（mutiple_mutiple_stop.cpp）</p><p>在这个版本中，引入了Lambda回调函数，用于优雅地停止并发处理。可以通过调用回调函数来停止生产者和消费者的处理，并进行清理工作。</p><p><strong>实现</strong></p><p>简单来说，就是加回调函数</p><p>最后运行【比较简朴~】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  mutiple_mutiple_stop.cpp -o mutiple_mutiple_stop -lpthread</span><br></pre></td></tr></table></figure><p>本文字学习自：<a href="https://github.com/LHCyGan/Concurrent_Programming">https://github.com/LHCyGan/Concurrent_Programming</a></p>]]></content>
    
    
    <summary type="html">Producer-Consumer Pattern</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
</feed>
