<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-06-02T07:51:20.514Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊MVCC</title>
    <link href="https://penge666.github.io/posts/5f51f1dd.html"/>
    <id>https://penge666.github.io/posts/5f51f1dd.html</id>
    <published>2024-06-02T07:28:05.000Z</published>
    <updated>2024-06-02T07:51:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>推荐2篇经典论文：</p><ul><li>MVCC：<a href="https://www.vldb.org/pvldb/vol10/p781-Wu.pdf">An Empirical Evaluation of InMemory Multi-Version Concurrency Control</a></li><li>GC：<a href="http://www.vldb.org/pvldb/vol13/p128-bottcher.pdf">Scalable Garbage Collection for In-Memory MVCC Systems</a></li></ul><p>先聊聊第一篇的趣事，论文最初投稿时使用的并不是这个标题，而是《This is the Best Paper Ever on In-Memory Multi-Version Concurrency Control》。据Andrew Pavlo（论文作者之一，CMU Associate Professor）称他们给VLDB投稿时得到的Review反馈非常正面，要求他们更换题目。哈哈哈哈哈哈，大佬总是那么自信~</p><h2 id="MVCC简介">MVCC简介</h2><ul><li><p>MVCC（Multi-Version Concurrency Control）字面包含了两个方面的内容：</p><ul><li>Multi-Versioning：产生多版本的数据内容，使得读写可以不互相阻塞。</li><li>Concurrency Control：并发控制，使得并行执行的内容能保持串行化结果。</li></ul><p>例如，对于SQL：<code>SELECT a FROM tab_1 where id = 1;</code>，事务T1和T3可以访问到不同版本的数据结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="operator">|</span> T1                                <span class="operator">|</span> T2                                   <span class="operator">|</span> T3                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">---|-----------------------------------|--------------------------------------|-----------------------------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="keyword">BEGIN</span>;                            <span class="operator">|</span>                                      <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span>                                   <span class="operator">|</span> <span class="keyword">BEGIN</span>;                               <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span>                                   <span class="operator">|</span> <span class="keyword">UPDATE</span> tab_1 <span class="keyword">SET</span> a <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span> <span class="operator">|</span>                                   <span class="operator">|</span> <span class="keyword">COMMIT</span>;                              <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span>                                   <span class="operator">|</span>                                      <span class="operator">|</span> <span class="keyword">BEGIN</span>;                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span> <span class="operator">|</span> <span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tab_1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="operator">|</span>                                      <span class="operator">|</span> <span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tab_1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>T1在T2前开启，T3在T2修改记录后开启，因此T1读到的是修改前的版本，T3读到的是commit后的版本。</p><p>MVCC的目的是<strong>让不同的事务都能运行在各自的快照版本数据下而不互相阻塞</strong>：写操作写操作可以生成新版本数据，而读操作仍能够读到旧的版本。目前很多主流的DBMS都支持MVCC，如：MySQL、Microsoft SQL Server、Oracle、Hekaton等。</p><p>虽然诞生已久，也有很多数据库支持，但是MVCC并没有一个“标准”的实现。不同的数据库在MVCC的设计上都有自己的权衡和取舍，不同的设计在不同场景下也有性能上的差异。</p><p>MVCC的实现主要可以分为四个关键模块设计：</p><ul><li>并发控制协议</li><li>版本数据存储</li><li>垃圾清理机制</li><li>索引管理</li></ul><p>我们后面将会逐一介绍不同模块的多种设计与实现。不过首先，让我们来认识一下为了支持MVCC，DMBS中需要补充什么样的元数据。</p></li></ul><h2 id="版本数据形式">版本数据形式</h2><p>从<strong>事务</strong>（transaction）维度和<strong>数据行</strong>（tuple）维度而言，为了支持MVCC，都需要引入特定的Metadata。</p><p>对于<strong>事务</strong>，DBMS需要提供一个唯一的标识符区分不同事务。这个标识符通常是单调递增的时间戳（可以是0、1、2的序号，也可以是真实时间），我们把它称作事务的ID。有了<code>TID</code>，DMBS可以用他们来标记数据行的版本。</p><p>对于<strong>数据行</strong>，DBMS需要以下4个字段来在并发事务中进行定位：</p><ul><li><code>txn-id</code>：事务ID，并可用作写锁</li><li><code>begin-ts</code>与<code>end-ts</code>：代表版本数据的生命周期</li><li><code>pointer</code>：指向同一行数据相邻（新/旧）版的指针，依靠指针，版本数据可以形成一个<strong>单向</strong>链表</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153258896.png" alt="image-20240602153258896"></p><p>MVCC中的MV是通过版本数据行的这些Metadata实现的，如果我们把模型稍微简化一下，只要记录有<code>begin-ts</code>和<code>end-ts</code>，我们就可以通过对比他们与当前事务的<code>TID</code>判断出哪个版本行才是事务可见的。而CC的实现，实际上也可以独立于MV存在，例如通过Timestamp Ordering或Two-phase Locking保持事务的串行性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153307531.png" alt="image-20240602153307531"></p><h2 id="并发控制协议">并发控制协议</h2><p>每个DBMS系统都需要有一套并发控制协议，这套协议需要做的事情有两个：</p><ul><li>判定特定事务是否可以访问或修改特定版本的数据</li><li>判定特定事务是否可以提交它的改动</li></ul><p>注意通过这套协议，MVCC解决的是不同事务间执行顺序和结果的问题（而不是多版本数据），也就是通过<strong>锁</strong>或者<strong>时间顺序</strong>保持串行性。本节中将介绍两种协议：MVTO和MV2PL，MVOCC与Serialization Certifier可以在论文中进一步了解。</p><h3 id="Timestamp-Ordering-MVTO">Timestamp Ordering (MVTO)</h3><p>MVTO的设计思路是依赖时间顺序保证事务的串行性执行结果：</p><ul><li>写锁依然通过<code>txn-id</code>来实现，只要<code>txn-id</code>不为0或者不为事务自己的<code>TID</code>，说明有其他事务进行了改动，第二个想进行改动的事务将会终止</li><li>读锁通过时间先后顺序保证，并发读的场景中互不阻塞，但是会将读取这个版本数据行的最大<code>TID</code>进行记录，如果有未来事务进行了读取（尽管它已经发生，也就是发生在过去），那么当前事务将不能修改这行数据（不能新增版本数据行）</li></ul><p>MVTO的实现关键在于借助事务的唯一标识符（<code>TID</code>，即时间戳）来计算不同事务的先后顺序。</p><p>在这个实现中，版本数据行除了上面提到的Metadata字段外，还引入了一个<code>read-ts</code>字段，它记录的是上一个读取它的事务<code>TID</code>。</p><p>当事务T对逻辑数据行A进行读操作时，DBMS需要根据当前的<code>TID</code>搜寻A合适的版本数据，使得<code>TID</code>落在begin-ts和end-ts之间。同时，事务T能读到的数据必须是<code>txn-id</code>为0或<code>TID</code>的，意味着数据行没有被其他事务加上写锁，因为MVTO不允许事务读取到未提交的改动。在读取A的版本数据Ax时，如果Ax的<code>read-ts</code>小于<code>TID</code>，则将该字段修改为<code>TID</code>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153402967.png" alt="image-20240602153402967"></p><p>在MVTO中，事务更新数据行的结果总是生成一个该数据行的最新版本。事务T在满足如下条件的时候，可以对版本<code>Bx</code>进行更新：</p><ul><li><code>Bx</code>版本数据没有被其他事务加上写锁</li><li><code>TID</code>必须大于等于<code>Bx</code>的<code>read-ts</code>，代表没有在<code>TID</code>之后的事务读了这行数据</li></ul><p>更新时事务T会新增一个版本数据<code>Bx+1</code>，它的<code>txn-id</code>等于<code>TID</code>。在事务T提交的时候，<code>Bx+1</code>的<code>begin-ts</code>设为<code>TID</code>，<code>end-ts</code>设为<code>INF</code>，并且将上一个版本数据<code>Bx</code>的<code>end-ts</code>设为<code>TID</code>。</p><h3 id="Optimistic-Concurrency-Control-OCC">Optimistic Concurrency Control (OCC)</h3><p>OCC 是 H.T. KUNG 在 CMU 任教时提出的并发控制算法。在 OCC 中，数据库为每个事务都创建一个私有空间：</p><ul><li>所有被读取的数据都复制到私有空间中</li><li>所有修改都在私有空间中执行</li></ul><p>OCC 分为 3 个阶段：</p><ol><li>Read Phase：追踪、记录每个事务的读、写集合，并存储到私有空间中</li><li>Validation Phase：当事务提交时，检查冲突</li><li>Write Phase：如果校验成功，则合并数据；否则中止并重启事务</li></ol><p>DBMS 需要维持所有活跃事务的全局视角，并将 Validation Phase 和 Write Phase 的逻辑放入一个 critical section 中。</p><p><strong>OCC - Example</strong></p><p>事务 𝑇1 读取 A 时，将 A 复制到自己的 workspace 中，可以看到，与 Basic T/O 相比，OCC 只需要记录一个时间戳，W-TS。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153459749.png" alt="image-20240602153459749"></p><p>事务 𝑇2 读取 A 时，同样将 A 复制到自己的 workspace 中：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153527180.png" alt="image-20240602153527180"></p><p>事务 𝑇2 完成数据操作，在 Validation Phase 中获得事务时间戳 1，由于没有数据写入，跳过 Write Phase</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153545234.png" alt="image-20240602153545234"></p><p>事务 𝑇1 修改 A 的值为 456，由于尚不知道自己的事务时间戳，将 W-TS(A) 设置为无穷大：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153603371.png" alt="image-20240602153603371"></p><p>事务 𝑇1 在 Validation Phase 获得事务时间戳 2，并通过校验，将 W-TS(A) 修改为 2，并合并到数据库中</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153618764.png" alt="image-20240602153618764"></p><h4 id="OCC-Read-Phase">OCC - Read Phase</h4><p>追踪事务的读写集合 (read/write sets)，将 read set 存放在 private workspace 中用来保证 repeatable read，将 write set 存放在 private workspace 中用来作冲突检测。</p><h4 id="OCC-Validation-Phase">OCC - Validation Phase</h4><p>在进入 Validation Phase 后，每个事务都会被赋予一个时间戳，然后与其它正在运行的事务执行 Timestamp Ordering 检查，检查的方式有两种：</p><ol><li>Backward Validation</li><li>Forward Validation</li></ol><p>如下图所示，在 Backward Validation 中，需要检查待提交的事务 (txn #2) 的读写集合是否与已经提交的事务的读写集合存在交集：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153635989.png" alt="image-20240602153635989"></p><p>与此类似，在 Forward Validation 中，需要检查待提交的事务 (txn #2) 的读写集合是否与尚未提交的事务的读写集合存在交集：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153648206.png" alt="image-20240602153648206"></p><p>如果 𝑇𝑆(𝑇𝑖)&lt;𝑇𝑆(𝑇𝑗)，那么以下 3 个条件之一必须成立：</p><blockquote><p>Condition 1: 𝑇𝑖Tcompletes all three phases before 𝑇𝑗 begins</p></blockquote><p>如果事务 𝑇𝑖在事务 𝑇𝑗 开始之前已经完成 OCC 的所有 3 个阶段，那么二者之间不存在任何冲突。</p><blockquote><p>Condition 2: 𝑇𝑖 completes before 𝑇𝑗starts its <strong>Write Phase</strong>, and 𝑇𝑖does not write to any object read by 𝑇𝑗</p></blockquote><p>如果 𝑇𝑖在 𝑇𝑗 的 Write Phase 开始前就已提交，同时 𝑇𝑖 没有修改任意 𝑇𝑗 读取的数据，即 𝑊𝑟𝑖𝑡𝑒𝑆𝑒𝑡(𝑇𝑖)∩𝑅𝑒𝑎𝑑𝑆𝑒𝑡(𝑇𝑗)=∅ ，则二者之间不存在冲突。</p><blockquote><p>Condition 3: 𝑇𝑖 completes its <strong>Read Phase</strong> before 𝑇𝑗 completes its Read Phase, and 𝑇𝑖 does not write to any object that is either read or written by 𝑇𝑗</p></blockquote><p>如果 𝑇𝑖在 𝑇𝑗结束自己的 Read Phase 前结束 Read Phase，同时 𝑇𝑖 没有修改任何 𝑇𝑗读取或修改的数据，即满足：</p><p>𝑊𝑟𝑖𝑡𝑒𝑆𝑒𝑡(𝑇𝑖)∩𝑅𝑒𝑎𝑑𝑆𝑒𝑡(𝑇𝑗)=∅ , 𝑊𝑟𝑖𝑡𝑒𝑆𝑒𝑡(𝑇𝑖)∩𝑊𝑟𝑖𝑡𝑒𝑆𝑒𝑡(𝑇𝑗)=∅</p><p>时，二者之间不存在冲突。</p><p>OCC 与 Basic T/O 的思路类似，都是在检查事务之间的 WW、WR 冲突。当冲突发生的频率很低时，即：</p><ul><li>大部分事务都是读事务</li><li>大部分事务之间访问的数据间没有交集</li></ul><p>OCC 的表现很好，如在数据库体量较大，workload 比较均衡的场景下。2PC 的性能瓶颈在于锁管理，尽管 OCC 没有加锁的成本，但它也存在性能问题:</p><ul><li>在 private workspace 与 global database 之间移动、合并数据开销大</li><li>Validation/Write Phase 需要在一个全局的 critical section 中完成，可能造成瓶颈</li><li>在 Validation Phase 中，待提交事务需要和其它事务做冲突检查，即便实际上并没有冲突，这里也有很多获取 latch 的成本 (锁住其它事务的 private workspace，对比是否有冲突，再释放锁)</li><li>事务中止的成本比 2PL 高，因为 OCC 在事务执行快结束时才检查数据冲突</li></ul><h3 id="Two-phase-Locking-MV2PL">Two-phase Locking (MV2PL)</h3><p>MV2PL仍然使用<code>begin-ts</code>和<code>end-ts</code>来决定版本记录是否可见。是否可读、可写，由读写锁来控制。</p><p>MV2PL使用<code>read-cnt</code>作为读锁，当寻找到对应版本行数据时，通过<code>read-cnt</code>加1可以给版本数据加读锁。同时，在版本数据持有写锁时，<code>read-cnt</code>不能进行递增。</p><p><strong>2PL，顾名思义，有两个阶段：growing 和 shrinking：</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602153911817.png" alt="image-20240602153911817"></p><p>但是2PL会有脏读问题，会导致级联终止！</p><p>事实上 2PL 还有一个增强版变种，Rigorous 2PL，后者<strong>每个事务在结束之前，其写过的数据不能被其它事务读取或者重写</strong>，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154001534.png" alt="image-20240602154001534"></p><p>Rigorous 2PL 可以避免级联中止，而且回滚操作很简单。</p><h2 id="版本数据存储">版本数据存储</h2><p>在MVCC中，每次的更新都会创建一个新的版本数据。版本数据行中的指针负责指向前一个版本的数据或后一个版本的数据，以此形成一个单向的版本链。版本链不能是双向链表，因为双向链表的修改操作需要加锁，不能借助原子指令完成。</p><p>主流的版本数据的存储Schema有多种，不过可以提前透露的是，Delta存储是最优的方案，InnoDB使用的就是Delta存储，Postgres使用了Append-only存储，而极少数的DBMS在使用Time-travel存储。我们将逐一介绍。</p><h3 id="Append-only">Append-only</h3><p>Append-only将所有数据行的不同版本（包括master版本）都存放在同一块空间中（例如同一张表）。每当有逻辑数据更新时，DMBS在表中先请求一个数据行的空间，然后将最新版本的数据复制一份到新数据行空间中，最后将变更内容应用到这一行上。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154026377.png" alt="image-20240602154026377"></p><p>前面说过，因为锁的关系，没有办法维护一个双向链表的版本数据，那么版本数据的方向就变得非常重要：</p><ul><li>如果版本数据是从老到新（O2N）排列的，那么每次获取较新的版本数据（大部分场景都是如此）都需要遍历整个链表</li><li>如果版本数据是从新到老（N2O）排列的，那么每次插入新的版本数据时，链表的起点都要发生变更</li></ul><p>在O2N的方案中，由于无用版本遍历的存在，这种方案的性能高度依赖于版本数据的垃圾回收机制，如果垃圾回收能够将单链表维持在较短的长度，那么查询的性能是可以有提升的，否则就会很耗费时间。</p><p>而在N2O的方案中，也有方法可以减少变更起点的次数，就是采用一个映射entry代表链表的起点，这样当新版本数据产生时，只有entry指向的地址需要改变，而指向entry的索引则可以不发生变更。这种优化在辅助索引非常多的表上有很好的提升，但是会需要额外的存储空间。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154038670.png" alt="image-20240602154038670"></p><p>由于Append-only存储的是完整的数据行，即使数据行中只有少量字段发生了变更。这种行为在表中带有非内联数据（即数据不记录在tuple内，如BLOB、TEXT）时会导致引入大量的重复且大体积数据。其中一个优化方式是允许不同的版本数据行指向同一个BLOB、TEXT对象，并且增加<code>cnt</code>元数据来记录引用次数，便于GC处理。</p><h3 id="Time-Travel">Time-Travel</h3><p>Time-Travel和Append-only的存储很相似，版本数据都是链表记录数据行，但是历史的版本数据与最新版本数据的存储空间分离开。在主表上，只有最新的master版本数据，而历史数据的链表存放在一张“Time-Travel”表中。</p><p>在更新逻辑行时，DBMS将master版本的数据复制进“Time-Travel”表中，然后原地更新主表中的数据行，形成新的版本数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154055859.png" alt="image-20240602154055859"></p><p>Time-Travel的设计可以避免索引上的指针频繁更新，因为他们始终指向主表上的master版本数据，并且数据原地更新，地址也没有发生变更。</p><p>但是因为版本数据存储的是完整tuple，因此也会有非内联数据的问题，同样，可以使用共享对象的方式进行优化。</p><h3 id="Delta">Delta</h3><p>最后介绍的Delta存储同样在主表上只维护master版本的数据，然后将版本数据存放在额外的“Delta”空间中。“Delta”空间在MySQL InnoDB和Oracle中指的就是用于rollback的数据段，例如InnoDB中的undo log。</p><p>在更新逻辑数据行时，DMBS同样先申请“delta”空间的位置，然后将被改动的属性的老版本数据写入其中，而不是完整的tuple行。最后DMBS在主表上原地更新master版本的数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154111711.png" alt="image-20240602154111711"></p><p>Delta存储在记录版本数据时表现非常优秀，当UPDATE只操作了数据行的子集时，减少了内存的分配占用，也没有外联数据版本体积过大的问题。然而，在重度读的场景中，为了获得对应的版本数据，DMBS必须从各个字段的版本数据链中获取到对应版本的字段值，再进行拼凑，这就带来了一定的额外开销。</p><p><strong>总结</strong></p><p>由此可见，不同的版本数据存储方案都有各自适应的场景。例如Append-only存储在一些数据分析场景下更佳，因为版本数据存储在连续的空间中，当进行大范围的扫描时可以提高缓存的命中率，而且还可以配合硬件预读进行优化。另外，存储完整数据行的方案（Append-only、Time-Travel）可以暴露物理的版本数据给索引管理系统，为索引管理提供了更多可选的方案，而Delta存储中就没有物理的版本数据行，在以上方面的对比处于劣势。</p><h2 id="垃圾清理机制">垃圾清理机制</h2><p>不断创建版本数据的好处在于，如果一直不进行清理的话，DBMS可以借助它们实现“Time Travel”，意味着可以访问任意时刻的数据快照。Postgre在之前的版本曾经这样做过，但是当他们意识到没有什么场景需要这种功能之后，在新版本就放弃支持了。</p><p>版本数据积累的坏处有很多，包括巨大的存储开销，极高的版本链遍历开销（也取决于版本链的方向和使用场景）。所以自然而然就需要有GC操作去释放这部分的空间。</p><p>GC可以分作3个步骤：</p><ul><li>检测过时版本</li><li>在链表中将它们断开连接（移除链表元素）</li><li>释放空间</li></ul><p>检测过时版本数据有很多方法，例如检测版本行是否由异常的事务创建，或者检查版本行是否对所有活跃事务都不可见。对于后者，可以通过比较版本行的<code>end-ts</code>和活跃事务的<code>TID</code>来实现。DBMS通常可以把事务信息集中存储，但在多核系统上这会是扩展性的一个瓶颈。</p><p>有了检测方法之后，DMBS可以从不同的维度去寻找这些过时版本，比如从版本数据行出发，以及从事务出发。</p><h3 id="Tuple-level">Tuple-level</h3><p>论文中介绍了两种数据行维度的GC方法，VAC和COOP。</p><p>Background Vacuuming（VAC）使用一个后台线程，周期性地扫描数据库以寻找过时的版本。这种方案最简单的实现就是遍历版本数据链表，但是这样做的GC性能很难在数据量增长时同步提升，我们需要减少无目的的遍历，或者让遍历范围能缩小下来。一种优化的方案是让DBMS维护一个bitmap，映射包含改动过数据的block，这样后台的vacuum线程就可以跳过上一次GC以来没有发生数据变更的block。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154258084.png" alt="image-20240602154258084"></p><p>Cooperative Cleaning（COOP）的思路是改用worker线程进行GC。寻找版本数据时，worker线程也需要跟着版本链表进行遍历，在遍历过程中，如果发现过时版本数据，就直接进行清理。这种方案会存在两个问题：</p><ul><li>只支持O2N的版本数据记录方式，否则worker线程每次遍历的都是靠前的活跃版本数据，找到目标后就停止，不能发现过时数据</li><li>存在“dusty corners”问题，GC与查询任务关联在一起，因此如果逻辑数据创建有多个版本数据后，就没有发生过任何查询，那么这些版本数据就一直没办法得到清理。一般DBMS会通过结合VAC来处理这部分的数据</li></ul><h3 id="Transaction-level">Transaction-level</h3><p>事务维度的GC一般通过事务记录它读写数据行的集合，DBMS需要监控集合中的版本数据是否都过时了。当某个事务的版本数据集合对所有的活跃事务都不可见时，就可以将这个集合中的版本数据都进行GC清理。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240602154321693.png" alt="image-20240602154321693"></p><p>简单说：让每个事务都保存着它的读写数据集合 (read/write set)，当 DBMS 决定什么时候这个事务创建的各版本数据可以被回收时，就按照集合内部的数据处理即可。</p><p><strong>总结</strong></p><p>Tuple-level的VAC是最常用的版本数据清理方案，通过增加GC线程的数量可以提升它的性能。但是对比Transaction-level GC，这种方案在出现长事务的时候会对性能有较大的影响，因为长事务意味着它开始之后的所有版本数据都得不到清理，这时候版本数据链就会变得很长，直到长事务提交或者中止。</p><p>解释：</p><p>在数据库系统中，垃圾回收（GC）是一个重要的过程，其目标是清理不再需要的数据版本，释放存储空间。在使用MVCC（多版本并发控制）的数据库中，由于每个事务都可能创建新的数据版本，因此需要一个有效的机制来清理旧的数据版本。这就是版本数据清理方案，通常有Tuple-level GC和Transaction-level GC两种。</p><p><strong>Tuple-level GC</strong>：这种方案中，GC线程会检查每个数据版本，看它是否还被任何事务引用。如果没有，就将其清理掉。这种方案的优点是可以增加GC线程的数量来提升性能，因为每个线程可以独立地检查和清理数据版本。</p><p>但是，Tuple-level GC的问题在于，如果存在长事务，在这个长事务运行期间，它引用的所有数据版本都不能被清理。这可能会导致大量的旧数据版本堆积，占用大量的存储空间，因此对性能有较大的影响。</p><p>举个例子，假设我们有一个大的数据库，里面存储了一个在线商店的所有交易记录。每一次交易都会创建新的数据版本。如果我们有一个长事务正在运行，比如统计过去一年的所有交易，那么这个事务运行期间，所有的交易记录都不能被清理，即使有些交易记录已经很旧了。</p><p><strong>Transaction-level GC</strong>：这种方案中，GC线程会检查每个事务，看它是否还在运行。如果一个事务已经完成，那么这个事务创建的所有数据版本都可以被清理。这种方案的优点是可以更有效地清理旧的数据版本，因为一次可以清理很多的数据版本。但是，这种方案的性能取决于事务的数量和大小，如果有很多大的事务，那么清理的工作可能会很重。</p><p>以上就是Tuple-level GC和Transaction-level GC在面对长事务时对性能影响的原因。在实际的数据库系统中，可能会根据具体的需求和性能考虑，选择合适的版本数据清理方案。</p><h2 id="索引管理">索引管理</h2><p>所有支持MVCC的DBMSs都将版本数据和索引数据分开存储。我们可以将索引看作KV键值对，键是被索引的数据行中的字段值（例如ID），值是索引对应的数据行的指针。</p><p>主键索引的情况比较简单，因为主键（同时也是索引的Key）是保持不变的，索引的Value总是指向版本数据链的起点，比如在InnoDB中，主键索引的数据行就是指向主表的。在主键索引中，索引的键值对指针会发生什么样的变更，取决于DBMS使用了哪种的数据存储方式。</p><p>对于Delta存储，我们上面讨论过，主表永远都是存的master版本数据，它是原地更新的，因此在更新数据时，主表中的数据行位置不发生改变，因此索引Value的指针也没有发生改变。</p><p>对于Append-only的存储，版本数据链有两种不同的方向：</p><ul><li>O2N，新的版本数据Append在版本链的末端，因此索引的Value指针始终指向链表的起点不变；只有在发生GC的时候才会调整指针地址</li><li>N2O，每当产生新版本时，都需要调整索引值的指针，此时DBMS一般会在索引上进行DELETE &amp; INSERT的操作完成调整</li></ul><p>对于辅助索引，被索引的字段值（同时也是索引中的Key）可能改变，索引的Value指向的版本数据也有可能改变。因此有不同的方案对索引中的指针进行管理。</p><h3 id="Logical-Pointers">Logical Pointers</h3><p>最常用的方案是建立一层中间表，让索引的Value能够一直不变，例如指向主键。这种方案也是InnoDB在使用的，所以我们通常说辅助索引会包含被索引值以及主键值。通过主键值将索引中的指针固定下来，这样每当版本数据链表起点发生改变时，只需要同时更新主键值对应的指针。虽然只有一个辅助索引时，听起来改动的复杂度是相同的，都是改变了1处指针，但是当有许多辅助索引时，就会是O(1) vs. O(n)的差异了。</p><p>借助主键的坏处是辅助索引的体积会随着主键体积发生变化，另一个方案是为逻辑tuple提供64-bit的唯一ID。实际上思路并没有区别，都是在物理版本链和索引之间增加了一层映射，只是看映射的内容如何选取一个唯一固定、节约空间的值。</p><h3 id="Physical-Pointers">Physical Pointers</h3><p>Uber曾经发过一篇文章：<a href="https://eng.uber.com/postgres-to-mysql-migration/">《Why Uber Engineering Switched from Postgres to MySQL》</a>，实际上他们并不是一开始就在用Postgres。Uber最早使用的也是MySQL，中途招了一些热衷于Postgres的工程师，所以他们就从MySQL切到了Postgres。他们在表中加了非常多的辅助索引，在使用过程中发现，Postgres的辅助索引是指向磁盘中的版本链起点的，在版本链起点发生变动时，多个辅助索引的指针就要发生修改。在Append-only的存储方式下，这种设计的好处是没有通过中间层映射（例如主键ID）回表查询，坏处也非常明显，当辅助索引非常多的时候，版本数据链起点的变更将会导致所有辅助索引的指针都需要更新。</p><p>目前还有一些DBMS使用了这种方案，例如MemSQL、Hekaton。如果Uber的工程师有读过这篇论文，他们可能可以节约不少的迁移成本。</p><p><strong>解释</strong>：</p><p>在数据库系统中，索引是一种数据结构，它可以帮助我们快速地查找到数据。索引中的每一个条目都是一个键值对，其中键通常是一些列的值，值是这些列值对应的行的位置信息。在使用MVCC（多版本并发控制）的数据库中，每一行数据可能有多个版本，因此索引的值实际上是指向一个版本链的。</p><p>理解逻辑指针和物理指针的关键在于理解，它们在索引中作为值，实际上指向了什么。</p><ol><li><strong>逻辑指针</strong>：逻辑指针实际上存储的是主键的值。当我们需要查找数据时，首先会通过索引找到对应的主键值，然后再通过主键值找到数据。这种方式的好处是，即使数据的位置发生了变化，只要主键值没有变，我们就能找到数据。比如，我们可以把图书的ISBN号视为主键，即使图书在书架上的位置变了，只要我们知道ISBN号，就能找到这本书。</li><li><strong>物理指针</strong>：物理指针则是直接存储了数据的物理位置信息。这意味着我们可以通过物理指针直接找到数据，无需经过主键。这种方式的好处是查找效率高，因为减少了一次查找。但是缺点是，一旦数据的位置发生了变化，物理指针就会失效。比如，我们把图书在书架上的位置作为物理指针，如果图书被移动了，那么我们就无法通过原来的位置找到这本书。</li></ol><p>在实际的数据库系统中，通常会根据具体的需求和性能考虑，选择适合的索引管理策略。</p><p><strong>总结</strong></p><p>同样，不同的管理方式也有各自适合的场景。对于Logical Pointer，在写入频繁的场景下表现更好，因为辅助索引只需要在索引字段值发生改变时才会改变，在读取场景下，它还需要对不同的版本链进行对比，因为同一个逻辑值有可能对应不同的物理值，例如DELETE后再INSERT同一个值；对于Physical Pointers，缺点之前已经提到过，频繁的更新场景会导致写入性能变差，但是在检索时就会有它的优势。</p><p>另外，在支持MVCC的DBMS中，所谓的“覆盖索引”其实并不能通过扫描单个索引得到Query结果，因为索引里面并没有版本数据。对于Append-only的设计，回到主表进行检索是必须的；而对于Delta存储，至少也需要在Delta空间（例如undo log）中查找对应版本。</p><h2 id="总结">总结</h2><p>论文对MVCC的4个要点进行了分类总结：</p><ul><li>并发控制协议：MVTO、MVOCC、MV2PL和Serialization Certifier</li><li>版本数据存储：Append-only、Time-Travel和Delta</li><li>垃圾清理机制：Tuple-level和Transaction-level</li><li>索引管理：Logical Pointers和Physical Pointers</li></ul><p>意在说明MVCC并没有一套标准的实现，不同的实现之间针对具体场景Workload的不同也有着不同的表现。在Paper Reading中我们并没有展示论文中不同Approaches的测试结果，关心的同学可以在文末的链接找到原文查看。</p><p>另外，尽管可以从不同的DBMS中总结出一些共用的实现方案，但是它们各自都有进一步地做不同的优化，例如InnoDB中的undo log管理与GC就比原文的概述复杂得多。</p><p>学习自：<a href="https://jiekun.dev/posts/mvcc/#transaction-level">Paper Reading：聊一聊MVCC</a></p>]]></content>
    
    
    <summary type="html">聊聊Multi-Version Concurrency Control</summary>
    
    
    
    <category term="数据库" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper基础篇</title>
    <link href="https://penge666.github.io/posts/ccd40453.html"/>
    <id>https://penge666.github.io/posts/ccd40453.html</id>
    <published>2024-06-01T13:42:49.000Z</published>
    <updated>2024-06-01T13:53:48.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-ZooKeeper-数据模型：节点的特性与应用">01 ZooKeeper 数据模型：节点的特性与应用</h2><p>ZooKeeper 基础知识基本分为三大模块：</p><ul><li>数据模型</li><li>ACL 权限控制</li><li>Watch 监控</li></ul><p>其中，数据模型是最重要的，很多 ZooKeeper 中典型的应用场景都是利用这些基础模块实现的。比如我们可以利用数据模型中的临时节点和 Watch 监控机制来实现一个发布订阅的功能。</p><h3 id="数据模型">数据模型</h3><p>计算机最根本的作用其实就是处理和存储数据，作为一款分布式一致性框架，ZooKeeper 也是如此。数据模型就是 ZooKeeper 用来存储和处理数据的一种逻辑结构。就像我们用 MySQL 数据库一样，要想处理复杂业务。前提是先学会如何往里边新增数据。ZooKeeper 数据模型最根本的功能就像一个数据库。</p><p>现在，数据模型对我们来说还是一个比较抽象的概念，接下来我们开始部署一个开发测试环境，并在上面做一些简单的操作。来看看 ZooKeeper 的数据模型究竟是什么样的：</p><ol><li>配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line">dataDir=/<span class="keyword">var</span>/lib/zookeeper</span><br><span class="line"></span><br><span class="line">clientPort=<span class="number">2181</span></span><br></pre></td></tr></table></figure><ol><li>服务启动</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure><ol><li>使用客户端连接服务器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh -server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure><ol><li>这样单机版的开发环境就已经构建完成了，接下来我们通过 ZooKeeper 提供的 create 命令来创建几个节点，分别是：“/locks”“/servers”“/works”：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create /locks</span><br><span class="line"></span><br><span class="line">create /servers</span><br><span class="line"></span><br><span class="line">create /works</span><br></pre></td></tr></table></figure><p>最终在 ZooKeeper 服务器上会得到一个具有层级关系的数据结构，如下图所示，这个数据结构就是 ZooKeeper 中的数据模型。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214357114.png" alt="image-20240601214357114"></p><p>ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。ZooKeeper 的数据模型也具有一个固定的根节点（/），我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。ZooKeeper 树中的每一层级用斜杠（/）分隔开，且只能用绝对路径（如“get /work/task1”）的方式查询 ZooKeeper 节点，而不能使用相对路径。具体的结构你可以看看下面这张图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214410026.png" alt="image-20240601214410026"></p><h3 id="znode-节点类型与特性">znode 节点类型与特性</h3><p>知道了 ZooKeeper 的数据模型是一种树形结构，就像在 MySQL 中数据是存在于数据表中，ZooKeeper 中的数据是由多个数据节点最终构成的一个层级的树状结构，和我们在创建 MySOL 数据表时会定义不同类型的数据列字段，ZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：</p><h4 id="1、持久节点">1、持久节点</h4><p>我们第一个介绍的是持久节点，这种节点也是在 ZooKeeper 最为常用的，几乎所有业务场景中都会包含持久节点的创建。之所以叫作持久节点是因为一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。</p><h4 id="2、临时节点">2、临时节点</h4><p>接下来我们来介绍临时节点。从名称上我们可以看出该节点的一个最重要的特性就是临时性。所谓临时性是指，如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除。同样，我们可以像删除持久节点一样主动删除临时节点。</p><p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为“/servers”节点，并为集群下的每台服务器创建一个临时节点“/servers/host”，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214425685.png" alt="image-20240601214425685"></p><h4 id="3、有序节点">3、有序节点</h4><p>最后我们再说一下有序节点，其实有序节点并不算是一种单独种类的节点，而是在之前提到的持久节点和临时节点特性的基础上，增加了一个节点有序的性质。所谓节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。例如一个客户端创建了一个路径为 works/task- 的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为 works/task-1。通过这种方式我们可以直观的查看到节点的创建顺序。</p><p>到目前为止我们知道在 ZooKeeper 服务器上存储数据的基本信息，知道了 ZooKeeper 中的数据节点种类有持久节点和临时节点等。上述这几种数据节点虽然类型不同，但 ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组（byte data[]），用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p><p>下面我们详细说明节点的状态信息。</p><h3 id="节点的状态结构">节点的状态结构</h3><p>每个节点都有属于自己的状态信息，这就很像我们每个人的身份信息一样，我们打开之前的客户端，执行 stat /zk_test，可以看到控制台输出了一些信息，这些就是节点状态信息。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214440092.png" alt="image-20240601214440092"></p><p>每一个节点都有一个自己的状态属性，记录了节点本身的一些信息，这些属性包括的内容我列在了下面这个表格里：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214456572.png" alt="image-20240601214456572"></p><h3 id="数据节点的版本">数据节点的版本</h3><p>这里我们重点讲解一下版本相关的属性，在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。ZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。</p><h4 id="使用-ZooKeeper-实现锁">使用 ZooKeeper 实现锁</h4><p>学习了 ZooKeeper 的数据模型和数据节点的相关知识，下面我们通过实际的应用进一步加深理解。</p><p>设想这样一个情景：一个购物网站，某个商品库存只剩一件，客户 A 搜索到这件商品并准备下单，但在这期间客户 B 也查询到了该件商品并提交了购买，于此同时，客户 A 也下单购买了此商品，这样就出现了只有一件库存的商品实际上卖出了两件的情况。为了解决这个问题，我们可以在客户 A 对商品进行操作的时候对这件商品进行锁定从而避免这种超卖的情况发生。</p><p>实现锁的方式有很多中，这里我们主要介绍两种：悲观锁、乐观锁。</p><p><strong>悲观锁</strong> 悲观锁认为进程对临界区的竞争总是会出现，为了保证进程在操作数据时，该条数据不被其他进程修改。数据会一直处于被锁定的状态。</p><p>我们假设一个具有 n 个进程的应用，同时访问临界区资源，我们通过进程创建 ZooKeeper 节点 /locks 的方式获取锁。</p><p>线程 a 通过成功创建 ZooKeeper 节点“/locks”的方式获取锁后继续执行，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214512591.png" alt="image-20240601214512591"></p><p>这时进程 b 也要访问临界区资源，于是进程 b 也尝试创建“/locks”节点来获取锁，因为之前进程 a 已经创建该节点，所以进程 b 创建节点失败无法获得锁。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214529182.png" alt="image-20240601214529182"></p><p>这样就实现了一个简单的悲观锁，不过这也有一个隐含的问题，就是当进程 a 因为异常中断导致 /locks 节点始终存在，其他线程因为无法再次创建节点而无法获取锁，这就产生了一个死锁问题。针对这种情况我们可以通过将节点设置为临时节点的方式避免。并通过在服务器端添加监听事件来通知其他进程重新获取锁。</p><p><strong>乐观锁</strong> 乐观锁认为，进程对临界区资源的竞争不会总是出现，所以相对悲观锁而言。加锁方式没有那么激烈，不会全程的锁定资源，而是在数据进行提交更新的时候，对数据的冲突与否进行检测，如果发现冲突了，则拒绝操作。</p><p>**乐观锁基本可以分为读取、校验、写入三个步骤。**CAS（Compare-And-Swap），即比较并替换，就是一个乐观锁的实现。CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p><p>在 ZooKeeper 中的 version 属性就是用来实现乐观锁机制中的“校验”的，ZooKeeper 每个节点都有数据版本的概念，在调用更新操作的时候，假如有一个客户端试图进行更新操作，它会携带上次获取到的 version 值进行更新。而如果在这段时间内，ZooKeeper 服务器上该节点的数值恰好已经被其他客户端更新了，那么其数据版本一定也会发生变化，因此肯定与客户端携带的 version 无法匹配，便无法成功更新，因此可以有效地避免一些分布式更新的并发问题。</p><p>在 ZooKeeper 的底层实现中，当服务端处理 setDataRequest 请求时，首先会调用 checkAndIncVersion 方法进行数据版本校验。ZooKeeper 会从 setDataRequest 请求中获取当前请求的版本 version，同时通过 getRecordForPath 方法获取服务器数据记录 nodeRecord， 从中得到当前服务器上的版本信息 currentversion。如果 version 为 -1，表示该请求操作不使用乐观锁，可以忽略版本对比；如果 version 不是 -1，那么就对比 version 和 currentversion，如果相等，则进行更新操作，否则就会抛出 BadVersionException 异常中断操作。</p><h3 id="总结">总结</h3><p>主要介绍了ZooKeeper的基础知识点——<strong>数据模型。并深入介绍了节点类型、stat 状态属性等知识，并利用目前学到的知识解决了集群中服务器运行情况统计、悲观锁、乐观锁等问题</strong>。</p><p><strong>为什么 ZooKeeper 不能采用相对路径查找节点呢？</strong></p><p>这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。像这种查找与给定值相等的记录问题最适合用散列来解决。因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 hashtableConcurrentHashMap nodes ，用节点的完整路径来作为 key 存储节点数据。这样就大大提高了 ZooKeeper 的性能。</p><h2 id="02-发布订阅模式：如何使用-Watch-机制实现分布式通知">02 发布订阅模式：如何使用 Watch 机制实现分布式通知</h2><p>我们来学习 ZooKeeper 又一关键技术——Watch 监控机制，并用它实现一个发布订阅功能。</p><p>在日常生活中也有很多订阅发布的场景。比如我们喜欢观看某一个剧集，视频网站会有一个订阅按钮，用户可以订阅自己喜欢的电视剧，当有新的剧集发布时，网站会通知该用户第一时间观看。或者我们在网站上看到一件心仪的商品，但是当前没有库存，网站会提供到货通知的功能，我们开启这个商品的到货通知功能后，商品补货的时候会通知我们，之后就可以进行购买了。ZooKeeper 中的 Watch 机制很像这些日常的应用场景，其中的客户端就是用户，而服务端的数据节点就好像是我们订阅的商品或剧集。</p><p>现在我们可以从技术实现的角度分析一下上边提到的这些场景，无论是订阅一集电视剧还是订购一件商品。都有几个核心节点，即用户端注册服务、服务端处理请求、客户端收到回调后执行相应的操作。接下来我们也带着这个观点来看一下 ZooKeeper 中的 Watch 机制是如何实现的。</p><h3 id="Watch-机制是如何实现的">Watch 机制是如何实现的</h3><p>正如我们可以通过点击视频网站上的”收藏“按钮来订阅我们喜欢的内容，ZooKeeper 的客户端也可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知，我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(String connectString, <span class="type">int</span> sessionTimeout, Watcher watcher)</span><br></pre></td></tr></table></figure><p>上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connectString 服务端地址</span><br><span class="line"></span><br><span class="line">sessionTimeout：超时时间</span><br><span class="line"></span><br><span class="line">Watcher：监控事件</span><br></pre></td></tr></table></figure><p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。</p><p>除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getData</span>(<span class="title class_">String</span> path, <span class="title class_">Watcher</span> watcher, <span class="title class_">Stat</span> stat)</span><br></pre></td></tr></table></figure><p>知道了 ZooKeeper 添加服务器监控事件的方式，下面我们来讲解一下触发通知的条件。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214646207.png" alt="image-20240601214646207"></p><p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。</p><p>现在我们已经从应用层的角度了解了 ZooKeeper 中的 Watch 机制，而学习 ZooKeeper 过程中一个大问题就是入门容易精通难，像上边我们通过几个简单的 API 调用就可以对服务器的节点状态变更进行监控，但是在实际生产环境中我们会遇到很多意想不到的问题，要想解决好这些问题就要深入理解 Watch 的底层实现机制。</p><h3 id="Watch-机制的底层原理">Watch 机制的底层原理</h3><p>现在我们就深入底层了解其背后的实现原理。与上个课时直接通过底层代码的调用过程来分析不同，在 Watch 底层实现的分析阶段，由于 Watch 机制涉及了客户端和服务端的多个函数和操作节点，单单按照程序执行流程分析跳跃性对整体实现机制的理解难度大，这也是我在学习 Watch 这部分底层实现遇到的问题。为了更好地阐述 Watch 机制，我们另辟蹊径，从设计模式角度出发来分析其底层实现：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214659082.png" alt="image-20240601214659082"></p><p>【简单说，思考整个过程，就是网络发送，回调处理】</p><p>最初我在开始学习 Watch 机制的时候，它给我的第一印象是，其结构很像设计模式中的”观察者模式“，一个对象或者数据节点可能会被多个客户端监控，当对应事件被触发时，会通知这些对象或客户端。我们可以将 Watch 机制理解为是分布式环境下的观察者模式。所以接下来我们就以观察者模式的角度点来看看 ZooKeeper 底层 Watch 是如何实现的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214711961.png" alt="image-20240601214711961"></p><p>通常我们在实现观察者模式时，最核心或者说关键的代码就是创建一个列表来存放观察者。 而在 ZooKeeper 中则是在客户端和服务器端分别实现两个存放观察者列表，即：ZKWatchManager 和 WatchManager。其核心操作就是围绕着这两个展开的。</p><h4 id="客户端-Watch-注册实现过程">客户端 Watch 注册实现过程</h4><p>我们先看一下客户端的实现过程，在发送一个 Watch 监控事件的会话请求时，ZooKeeper 客户端主要做了两个工作：</p><ul><li>标记该会话是一个带有 Watch 事件的请求</li><li>将 Watch 事件存储到 ZKWatchManager</li></ul><p>我们以 getData 接口为例。当发送一个带有 Watch 事件的请求时，客户端首先会把该会话标记为带有 Watch 监控的事件请求，之后通过 DataWatchRegistration 类来保存 watcher 事件和节点的对应关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">WatchRegistration</span> <span class="variable">wcb</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (watcher != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    wcb = <span class="keyword">new</span> <span class="title class_">DataWatchRegistration</span>(watcher, clientPath);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line"></span><br><span class="line">  request.setWatch(watcher != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">GetDataResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetDataResponse</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后客户端向服务器发送请求时，是将请求封装成一个 Packet 对象，并添加到一个等待发送队列 outgoingQueue 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Packet <span class="title function_">queuePacket</span><span class="params">(RequestHeader h, ReplyHeader r，...)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    packet = <span class="keyword">new</span> <span class="title class_">Packet</span>(h, r, request, response, watchRegistration);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    outgoingQueue.add(packet); </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，ZooKeeper 客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的 SendThread 线程类中的 readResponse 方法接收服务端的回调，并在最后执行 finishPacket（）方法将 Watch 注册到 ZKWatchManager 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishPacket</span><span class="params">(Packet p)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> p.replyHeader.getErr();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            p.watchRegistration.register(err);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端-Watch-注册实现过程">服务端 Watch 注册实现过程</h4><p>介绍完客户端对 Watch 请求的发送过程，下面我们来看一下服务端是如何处理一个 Watch 事件。</p><p>Zookeeper 服务端处理 Watch 事件基本有 2 个过程：</p><ul><li>解析收到的请求是否带有 Watch 注册事件</li><li>将对应的 Watch 事件存储到 WatchManager</li></ul><p>下面我们分别对这 2 个步骤进行分析：</p><p>当 ZooKeeper 服务器接收到一个客户端请求后，首先会对请求进行解析，判断该请求是否包含 Watch 事件。这在 ZooKeeper 底层是通过 FinalRequestProcessor 类中的 processRequest 函数实现的。当 getDataRequest.getWatch() 值为 True 时，表明该请求需要进行 Watch 监控注册。并通过 zks.getZKDatabase().getData 函数将 Watch 事件注册到服务端的 WatchManager 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> b[] =                zks.getZKDatabase().getData(getDataRequest.getPath(), stat,</span><br><span class="line"></span><br><span class="line">        getDataRequest.getWatch() ? cnxn : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">rsp = <span class="keyword">new</span> <span class="title class_">GetDataResponse</span>(b, stat);</span><br><span class="line"></span><br><span class="line">..</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端-Watch-事件的触发过程">服务端 Watch 事件的触发过程</h4><p>在客户端和服务端都对 watch 注册完成后，我们接下来看一下在 ZooKeeper 中触发一个 Watch 事件的底层实现过程：</p><p>我们以 setData 接口即“节点数据内容发生变更”事件为例。在 setData 方法内部执行完对节点数据的变更后，会调用 WatchManager.triggerWatch 方法触发数据变更事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat <span class="title function_">setData</span><span class="params">(String path, <span class="type">byte</span> data[], ...)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">DataNode</span> <span class="variable">n</span> <span class="operator">=</span> nodes.get(path);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面我们进入 triggerWatch 函数内部来看看他究竟做了哪些工作。首先，封装了一个具有会话状态、事件类型、数据节点 3 种属性的 WatchedEvent 对象。之后查询该节点注册的 Watch 事件，如果为空说明该节点没有注册过 Watch 事件。如果存在 Watch 事件则添加到定义的 Wathcers 集合中，并在 WatchManager 管理中删除。最后，通过调用 process 方法向客户端发送通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Watcher&gt; <span class="title function_">triggerWatch</span><span class="params">(String path, EventType type...)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">WatchedEvent</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(type,</span><br><span class="line"></span><br><span class="line">               KeeperState.SyncConnected, path);</span><br><span class="line"></span><br><span class="line">       Set&lt;Watcher&gt; watchers;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">           watchers = watchTable.remove(path);</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line"></span><br><span class="line">               Set&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (paths != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   paths.remove(path);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (supress != <span class="literal">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           w.process(e);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> watchers;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="客户端回调的处理过程">客户端回调的处理过程</h4><p>知道了服务器端 Watch 事件的触发过程后，我们来看一下客户端接收到通知后如何进行操作的。</p><p>客户端使用 SendThread.readResponse() 方法来统一处理服务端的相应。首先反序列化服务器发送请求头信息 replyHdr.deserialize(bbia, “header”)，并判断相属性字段 xid 的值为 -1，表示该请求响应为通知类型。在处理通知类型时，首先将己收到的字节流反序列化转换成 WatcherEvent 对象。接着判断客户端是否配置了 chrootPath 属性，如果为 True 说明客户端配置了 chrootPath 属性。需要对接收到的节点路径进行 chrootPath 处理。最后调用 eventThread.queueEvent( ）方法将接收到的事件交给 EventThread 线程进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">WatcherEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatcherEvent</span>();</span><br><span class="line"></span><br><span class="line">    event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chrootPath != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> event.getPath();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">WatchedEvent</span> <span class="variable">we</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(event);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    eventThread.queueEvent( we );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下 EventThread.queueEvent() 方法内部的执行逻辑。其主要工作分为 2 点： 第 1 步按照通知的事件类型，从 ZKWatchManager 中查询注册过的客户端 Watch 信息。客户端在查询到对应的 Watch 信息后，会将其从 ZKWatchManager 的管理中删除。因此这里也请你多注意，客户端的 Watcher 机制是一次性的，触发后就会被删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title function_">materialize</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Set&lt;Watcher&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NodeDataChanged:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NodeCreated:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (dataWatches) &#123;</span><br><span class="line"></span><br><span class="line">        addTo(dataWatches.remove(clientPath), result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (existWatches) &#123;</span><br><span class="line"></span><br><span class="line">        addTo(existWatches.remove(clientPath), result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了第 1 步工作获取到对应的 Watcher 信息后，将查询到的 Watcher 存储到 waitingEvents 队列中，调用 EventThread 类中的 run 方法会循环取出在 waitingEvents 队列中等待的 Watcher 事件进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">  isRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Object</span> <span class="variable">event</span> <span class="operator">=</span> waitingEvents.take();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (event == eventOfDeath) &#123;</span><br><span class="line"></span><br><span class="line">        wasKilled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        processEvent(event);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (wasKilled)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (waitingEvents.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">              isRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用 processEvent(event) 方法来最终执行实现了 Watcher 接口的 process（）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WatcherSetEventPair) &#123;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="type">WatcherSetEventPair</span> <span class="variable">pair</span> <span class="operator">=</span> (WatcherSetEventPair) event;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Watcher watcher : pair.watchers) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">              watcher.process(pair.event);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">              LOG.error(<span class="string">&quot;Error while calling watcher &quot;</span>, t);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止我们将 ZooKeeper 中 Watch 机制的处理过程全部学习了一遍，大体上讲 ZooKeeper 实现的方式是通过客服端和服务端分别创建有观察者的信息列表。客户端调用 getData、exist 等接口时，首先将对应的 Watch 事件放到本地的 ZKWatchManager 中进行管理。服务端在接收到客户端的请求后根据请求类型判断是否含有 Watch 事件，并将对应事件放到 WatchManager 中进行管理。</p><p>在事件触发的时候服务端通过节点的路径信息查询相应的 Watch 事件通知给客户端，客户端在接收到通知后，首先查询本地的 ZKWatchManager 获得对应的 Watch 信息处理回调操作。这种设计不但实现了一个分布式环境下的观察者模式，而且通过将客户端和服务端各自处理 Watch 事件所需要的额外信息分别保存在两端，减少彼此通信的内容。大大提升了服务的处理性能。</p><h3 id="订阅发布场景实现">订阅发布场景实现</h3><p>现在我们已经知道 Watch 事件在 ZooKeeper 中的完整处理过程，接下来我们通过一个实际应用来加深我们对 ZooKeeper 中 Watch 机制的理解。</p><p>提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。ZooKeeper 采用了两种模式结合的方式实现订阅发布功能。下面我们来分析一个具体案例：</p><p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。</p><p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。如图中的 /confs/data_item1。服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214733308.png" alt="image-20240601214733308"></p><p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。<strong>要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。</strong></p><h3 id="总结-2">总结</h3><p>学习了 ZooKeeper 中非常重要的基础知识——Watch 监控机制。详细分析了 ZooKeeper 在处理 Watch 事件的底层实现，并通过我们掌握的知识实现了一个集群环境下的配置管理功能。</p><p>现在我有一个思考题留给你：“当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？答案是否定的，通过本课时对 ZooKeeper 内部实现机制的解析可以知道，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。</p><h2 id="03-ACL-权限控制：如何避免未经授权的访问？">03 ACL 权限控制：如何避免未经授权的访问？</h2><p>之前，我们学习了数据模型节点、Watch 监控机制等知识。并利用这些知识实现了在分布式环境中经常用到的诸如分布式锁、配置管理等功能。这些功能的本质都在于操作数据节点，而如果作为分布式锁或配置项的数据节点被错误删除或修改，那么对整个分布式系统有很大的影响，甚至会造成严重的生产事故。而作为在分布式领域应用最为广泛的一致性解决框架，ZooKeeper 提供一个很好的解决方案那就是 ACL 权限控制。</p><p>说到 ACL 可能你会觉得陌生，但是提到权限控制相信你一定很熟悉。比如 Linux 系统将对文件的使用者分为三种身份，即 User、Group、Others。使用者对文件拥有读（read） 写（write）以及执行（execute）3 种方式的控制权。这种权限控制方式相对比较粗糙，在复杂的授权场景下往往并不适用。比如下边一个应用场景。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214908300.png" alt="image-20240601214908300"></p><p>上图给出了某个技术开发公司的一个工作项目 /object 。项目中的每个开发人员都可以读取和修改该项目中的文件，作为开发组长也对这个项目文件具有读取和修改的权限。其他技术开发组的员工则不能访问这个项目。如果我们用之前说到的 Linux 权限应该怎么设计呢？</p><p>首先作为技术组长使用 User 身份，具有读、写、执行权限。项目组其他成员使用 Group 身份，具有读写权限，其他项目组的人员则没有任何权限。这样就实现了满足要求的权限设定了。</p><p>但是，如果技术组新加入一个实习人员，为了能让他熟悉项目，必须具有该项目的读取的权限。但是目前他不具备修改项目的能力，所以并没给他赋予写入的权限。而如果使用现有的权限设置，显然将其分配给 User 用户或者 Group 用户都并不合适。而如果修改 Others 用户的权限，其他项目组的成员也能访问该项目文件。显然普通的三种身份的权限划分是无法满足要求的。而 ZooKeeper 中的 ACl 就能应对这种复杂的权限应用场景。</p><h3 id="ACL-的使用">ACL 的使用</h3><p>下面我们来讲解一下如何使用 ZooKeeper 的 ACL 机制来实现客户端对数据节点的访问控制。</p><p>一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。最终组成一条例如“scheme:id:permission”格式的 ACL 请求信息。下面我们具体看一下这 3 部分代表什么意思：</p><h4 id="权限模式：Scheme">权限模式：Scheme</h4><p>权限模式就是用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。比如我们可以让一个 IP 地址为“ip：192.168.0.11”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.0.11/22”给一段 IP 地址的机器赋权。</p><p>另一种权限模式就是口令验证，也可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以“绝不通过明文在网络发送密码”也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送“username:password”这种形式的权限表示符后，ZooKeeper 服务端会对密码 部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。另一种权限模式 Super 可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。下面这段代码给出了 Digest 模式下客户端的调用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"></span><br><span class="line">create /digest_node1</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置digest权限验证</span></span><br><span class="line"></span><br><span class="line">setAcl /digest_node1 digest:用户名:base64格式密码:rwadc </span><br><span class="line"></span><br><span class="line"><span class="comment">//查询节点Acl权限</span></span><br><span class="line"></span><br><span class="line">getAcl /digest_node1 </span><br><span class="line"></span><br><span class="line"><span class="comment">//授权操作</span></span><br><span class="line"></span><br><span class="line">addauth digest user:passwd</span><br></pre></td></tr></table></figure><p>最后一种授权模式是 world 模式，其实这种授权模式对应于系统中的所有用户，本质上起不到任何作用。设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。</p><h4 id="授权对象（ID）">授权对象（ID）</h4><p>接下来我们再看一下授权对象部分，其实这个很好理解，所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。如果是 World 模式，是授权系统中所有的用户。</p><h4 id="权限信息（Permission）">权限信息（Permission）</h4><p>介绍完授权方式以及授权对象，下面我们学习 ACL 请求信息中的最后一项：权限（Permission）。权限就是指我们可以在数据节点上执行的操作种类，如下图所示：在 ZooKeeper 中已经定义好的权限有 5 种：</p><ul><li>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li><li>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</li><li>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</li><li>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li><li>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214925230.png" alt="image-20240601214925230"></p><p>需要注意的一点是，<strong>每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限</strong>。如下中“172.168.11.1”服务器有“/Config”节点的读取权限，但是没有其子节点的“/Config/dataBase_Config1”权限。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214939192.png" alt="image-20240601214939192"></p><h4 id="实现自己的权限口控制">实现自己的权限口控制</h4><p>通过上边的介绍我们了解了 ZooKeeper 中的权限相关知识，虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。官方文档中对这种机制的定义是 “Pluggable ZooKeeper Authenication”，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？</p><p>首先，要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。下面这张图片展示了接口的内部结构，用户通过该接口实现自定义的权限控制。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601214950210.png" alt="image-20240601214950210"></p><p>实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。</p><p>第一种是通过设置系统属性来注册自定义的权限控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dzookeeper.authProvider.x=CustomAuthenticationProvider</span><br></pre></td></tr></table></figure><p>另一种是在配置文件 zoo.cfg 中进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authProvider.x=CustomAuthenticationProvider</span><br></pre></td></tr></table></figure><h3 id="ACL-内部实现原理">ACL 内部实现原理</h3><p>到目前为止我们学习了 ACL 权限控制机制应用层方面的相关知识，下面就深入到底层学习一下 ZooKeeper 是如何实现的。</p><h4 id="客户端处理过程">客户端处理过程</h4><p>我们先看一下客户端是如何操作的，我们以节点授权 addAuth 接口为例，首先客户端通过 ClientCnxn 类中的 addAuthInfo 方法向服务端发送 ACL 权限信息变更请求，该方法首先将 scheme 和 auth 封装成 AuthPacket 类，并通过 RequestHeader 方法表示该请求是权限操作请求，最后将这些数据统一封装到 packet 中，并添加到 outgoingQueue 队列中发送给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAuthInfo</span><span class="params">(String scheme, <span class="type">byte</span> auth[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authInfo.add(<span class="keyword">new</span> <span class="title class_">AuthData</span>(scheme, auth));</span><br><span class="line"></span><br><span class="line">    queuePacket(<span class="keyword">new</span> <span class="title class_">RequestHeader</span>(-<span class="number">4</span>, OpCode.auth), <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AuthPacket</span>(<span class="number">0</span>, scheme, auth), <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">            <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ACL 权限控制机制的客户端实现相对简单，只是封装请求类型为权限请求，方便服务器识别处理，而发送到服务器的信息包括我们之前提到的权限校验信息。</p><h4 id="服务端实现过程">服务端实现过程</h4><p>相比于客户端的处理过程，服务器端对 ACL 内部实现就比较复杂，当节点授权请求发送到服务端后，在服务器的处理中首先调用 readRequest（）方法作为服务器处理的入口，其内部只是调用 processPacket 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    zkServer.processPacket(<span class="built_in">this</span>, incomingBuffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 processPacket 方法的内部，首先反序列化客户端的请求信息并封装到 AuthPacket 对象中。之后通过 getServerProvider 方法根据不同的 scheme 判断具体的实现类，这里我们使用 Digest 模式为例，因此该实现类是 DigestAuthenticationProvider 。之后调用其 handleAuthentication() 方法进行权限验证。如果返 KeeperException.Code.OK 则表示该请求已经通过了权限验证，如果返回的状态是其他或者抛出异常则表示权限验证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPacket</span><span class="params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line"> ServerAuthenticationProvider         ap=ProviderRegistry.getServerProvider(scheme);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ap != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">authReturn = ap.handleAuthentication(<span class="keyword">new</span>                          <span class="title class_">ServerAuthenticationProvider</span>.ServerObjs(<span class="built_in">this</span>, cnxn), authPacket.getAuth());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们知道了权限认证的最终实现函数是 handleAuthentication 函数，而这个函数内部实现的逻辑就很清晰简单了，主要的工作就是解析客户端传递的权限验证类型，并通过 addAuthInfo 函数将权限信息添加到 authInfo 集合属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> KeeperException.Code </span><br><span class="line"></span><br><span class="line">        <span class="title function_">handleAuthentication</span><span class="params">(ServerCnxn cnxn, <span class="type">byte</span>[] authData)</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(authData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">digest</span> <span class="operator">=</span> generateDigest(id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (digest.equals(superDigest)) &#123;</span><br><span class="line"></span><br><span class="line">                cnxn.addAuthInfo(<span class="keyword">new</span> <span class="title class_">Id</span>(<span class="string">&quot;super&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cnxn.addAuthInfo(<span class="keyword">new</span> <span class="title class_">Id</span>(getScheme(), digest));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> KeeperException.Code.OK;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们重点讲解一下 addAuthInfo 函数，其作用是将解析到的权限信息存储到 ZooKeeper 服务器的内存中，该信息在整个会话存活期间一直会保存在服务器上，如果会话关闭，该信息则会被删，这个特性很像我们之前学过的数据节点中的临时节点。</p><p>经过上面的步骤，服务器已经将客户端 ACL 请求解析并将对应的会话权限信息存储在服务器上，下面我们再看一下服务器是如何进行权限验证的。首先，在处理一次权限请求时，先通过 PrepRequestProcessor 中的 checkAcl 函数检查对应的请求权限，如果该节点没有任何权限设置则直接返回，如果该节点有权限设置则循环遍历节点信息进行检查，如果具有相应的权限则直接返回表明权限认证成功，否则最后抛出 NoAuthException 异常中断操作表明权限认证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkACL</span><span class="params">(...)</span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ACL a : acl) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(authId.getScheme().equals(id.getScheme()..)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KeeperException</span>.NoAuthException();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止我们对 ACL 权限在 ZooKeeper 服务器客户端和服务端的底层实现过程进行了深度的分析。总体来说，客户端在 ACL 权限请求发送过程的步骤比较简单：首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。本课时的例子采用了授权接口 addAuth 而没有采用权限设置接口 setAcl，是因为权限设置接口相对简单，其核心功能点已经包括在授权接口实现中。而在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。下次连接服务器后，需要重新调用授权接口进行授权。</p><h3 id="总结-3">总结</h3><p>ZooKeeper 作为分布式系统协调框架，往往在一个分布式系统下起到关键的作用。尤其是在分布式锁、配置管理等应用场景中。如果因为错误操作对重要数据节点进行变更或删除，对整个分布式系统影响很大，甚至会导致整个分布式服务不可用。所以当你在设计使用 ZooKeeper 的时候一定要考虑对关键节点添加权限控制。</p><h2 id="04-ZooKeeper-如何进行序列化？">04 ZooKeeper 如何进行序列化？</h2><p>我们大概清楚了使用 ZooKeeper 实现一些功能的主要方式，也就是通过客户端与服务端之间的相互通信。那么首先要解决的问题就是通过网络传输数据，而要想通过网络传输我们定义好的 Java 对象数据，必须要先对其进行序列化。例如，我们通过 ZooKeeper 客户端发送 ACL 权限控制请求时，需要把请求信息封装成 packet 类型，经过序列化后才能通过网络将 ACL 信息发送给 ZooKeeper 服务端进行处理。</p><h4 id="什么是序列化，为什么要进行序列化操作">什么是序列化，为什么要进行序列化操作</h4><p>序列化是指将我们定义好的 Java 类型转化成数据流的形式。之所以这么做是因为在网络传输过程中，TCP 协议采用“流通信”的方式，提供了可以读写的字节流。而这种设计的好处在于避免了在网络传输过程中经常出现的问题：比如消息丢失、消息重复和排序等问题。那么什么时候需要序列化呢？如果我们需要通过网络传递对象或将对象信息进行持久化的时候，就需要将该对象进行序列化。</p><p>我们较为熟悉的序列化操作是在 Java中，当我们要序列化一个对象的时候，首先要实现一个 Serializable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Long ids;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 Serializable 接口后其实没有做什么实际的工作，它是一个没有任何内容的空接口，起到的作用就是标识该类是需要进行序列化的，这个就与我们后边要重点讲解的 ZooKeeper 序列化实现方法有很大的不同，这里请你先记住当前的写法，后边我们会展开讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好序列化接口后，我们再看一下如何进行序列化和反序列化的操作。Java 中进行序列化和反序列化的过程中，主要用到了 ObjectInputStream 和 ObjectOutputStream 两个 IO 类。</p><p>ObjectOutputStream 负责将对象进行序列化并存储到本地。而 ObjectInputStream 从本地存储中读取对象信息反序列化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>()</span><br><span class="line"></span><br><span class="line">oo.writeObject(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ois.readObject();</span><br></pre></td></tr></table></figure><p>到目前为止我们了解了什么是序列化，以及为什么要进行序列化，并通过我们熟悉的 Java 编程语言中的序列化实现，进一步对序列化操作有更加具体的了解。我们知道，当我们要把对象进行本地存储或网络传输时是需要进行序列化操作的，而在 ZooKeeper 中需要频繁的网络传输工作，那么在 ZooKeeper 中是如何进行序列化的呢，我们带着这个问题继续下面的学习。</p><h4 id="ZooKeeper-中的序列化方案">ZooKeeper 中的序列化方案</h4><p>在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式，说到 Jute 框架，它最早作为 Hadoop 中的序列化组件。之后 Jute 从 Hadoop 中独立出来，成为一个独立的序列化解决方案。ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。</p><p>虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题，这里也请你注意，也许在之后的版本中，ZooKeeper 会选择更加高效的序列化解决方案。</p><h4 id="使用-Jute-实现序列化">使用 Jute 实现序列化</h4><p>简单介绍了 Jute 框架的发展过程，下面我们来看一下如何使用 Jute 在 ZooKeeper 中实现序列化。如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：首先，我们定义了一个 test_jute 类，为了能够对它进行序列化，需要该 test_jute 类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_jute</span> <span class="keyword">implements</span> <span class="title class_">Record</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> ids；</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(OutpurArchive a_,String tag)</span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deserialize</span><span class="params">(INputArchive a_,String tag)</span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(OutpurArchive a_,String tag)</span> <span class="keyword">throws</span> ...&#123;</span><br><span class="line"></span><br><span class="line">  a_.startRecord(<span class="built_in">this</span>.tag);</span><br><span class="line"></span><br><span class="line">  a_.writeLong(ids,<span class="string">&quot;ids&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a_.writeString(type,<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a_.endRecord(<span class="built_in">this</span>,tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deserialize</span><span class="params">(INputArchive a_,String tag)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line"></span><br><span class="line">  a_.startRecord(tag);</span><br><span class="line"></span><br><span class="line">  ids = a_.readLong(<span class="string">&quot;ids&quot;</span>);</span><br><span class="line"></span><br><span class="line">  name = a_.readString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a_.endRecord(tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们就介绍完了如何在 ZooKeeper 中使用 Jute 实现序列化，需要注意的是，<strong>在实现了Record 接口后，具体的序列化和反序列化逻辑要我们自己在 serialize 和 deserialize 函数中完成</strong>。</p><p>序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持 整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte/Buffer 类型。</p><h4 id="Jute-在-ZooKeeper-中的底层实现">Jute 在 ZooKeeper 中的底层实现</h4><p>正因为 ZooKeeper 的设计目的是将复杂的底层操作封装成简单易用的接口，从而方便用户调用，也使得我们在使用 ZooKeeper 实现序列化的时候能够更加容易。</p><p>学会了利用 Jute 实现序列化和反序列化后，我们深入底层，看一下 ZooKeeper 框架具体是如何实现序列化操作的。正如上边我们提到的，通过简单的实现 Record 接口就可以实现序列化，那么我们接下来就以这个接口作为入口，详细分析其底层原理。</p><p>Record 接口可以理解为 ZooKeeper 中专门用来进行网络传输或本地存储时使用的数据类型。因此所有我们实现的类要想传输或者存储到本地都要实现该 Record 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Record</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(OutputArchive archive, String tag)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deserialize</span><span class="params">(InputArchive archive, String tag)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Record 接口的内部实现逻辑非常简单，只是定义了一个 序列化方法 serialize 和一个反序列化方法 deserialize 。而在 Record 起到关键作用的则是两个重要的类：OutputArchive 和 InputArchive ，其实这两个类才是真正的序列化和反序列化工具类。</p><p>在 OutputArchive 中定义了可进行序列化的参数类型，根据不同的序列化方式调用不同的实现类进行序列化操作。如下图所示，Jute 可以通过 Binary 、 Csv 、Xml 等方式进行序列化操作。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601215044427.png" alt="image-20240601215044427"></p><p>而对应于序列化操作，在反序列化时也会相应调用不同的实现类，来进行反序列化操作。 如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240601215058769.png" alt="image-20240601215058769"></p><p>注意：无论是序列化还是反序列化，都可以对多个对象进行操作，所以当我们在定义序列化和反序列化方法时，需要字符类型参数 tag 表示要序列化或反序列化哪个对象。</p><h4 id="总结-4">总结</h4><p>为什么需要序列化</p><p>在计算机网络中，数据通常会在不同的系统和设备之间进行传输。这些系统和设备可能有不同的架构和数据表示方式。序列化是将复杂的数据结构转换为字节流的过程，这使得数据能够在网络中进行传输，或者被存储到磁盘上。</p><p>以下是序列化的几个主要原因：</p><ol><li><strong>跨平台通信</strong>：不同的系统或语言有自己的内存管理和数据表示方式。序列化可以将数据转换为通用的格式，使得不同的系统和语言能够理解和使用。</li><li><strong>网络传输</strong>：网络传输的基本单位是字节，复杂的数据结构（如对象、数组等）无法直接在网络中传输。序列化可以将这些数据结构转换为字节流，从而可以在网络中进行传输。</li><li><strong>持久化存储</strong>：序列化也可以用于将数据持久化存储到磁盘中。序列化的数据可以在后续的程序运行中重新加载和使用，实现了数据的持久化。</li></ol><p>因此，无论是为了实现跨平台通信，还是为了网络传输，或者是为了持久化存储，序列化都是必不可少的过程。</p><h2 id="05-深入分析-Jute-的底层实现原理">05 深入分析 Jute 的底层实现原理</h2><p>上个课时我们讲解了 ZooKeeper 中采用 Jute 作为序列化解决的方案，并介绍了其应用层的使用技巧。本课时我们就深入 Jute 框架的内部核心，来看一看其内部的实现原理和算法。而通过研究 Jute 序列化框架的内部的实现原理，能够让我们在日常工作中更加高效安全地使用 Jute 序列化框架。</p><h3 id="简述-Jute-序列化">简述 Jute 序列化</h3><p>通过前面的课时我们知道了序列化就是将 Java 对象转化成字节码的形式，从而方便进行网络传输和本地化存储，那么具体的序列化方法都有哪些呢？这里我们结合 ZooKeeper 中使用到的序列化解决方案 Jute 来进行介绍，Jute 框架给出了 3 种序列化方式，分别是 Binary 方式、Csv 方式、XML 方式。序列化方式可以通俗地理解成我们将 Java 对象通过转化成特定的格式，从而更加方便在网络中传输和本地化存储。之所以采用这 3 种方式的格式化文件，也是因为这 3 种方式具有跨平台和普遍的规约特性，后面我将会对这三种方法的特性进行具体讲解。接下来我将深入 Jute 的底层，看一下这 3 种实现方式的底层实现过程。</p><h3 id="Jute-内部核心算法">Jute 内部核心算法</h3><p>上个课时中我们提到过，ZooKeeper 在实现序列化的时候要实现 Record 接口，而在 Record 接口的内部，真正起作用的是两个工具类，分别是 OutPutArchive 和 InputArchive。下边我们分别来看一下它们在 Jute 内部是如何实现的。</p><p>OutPutArchive 是一个接口，规定了一系列序列化相关的操作。而要实现具体的相关操作，Jute 是通过三个具体实现类分别实现了 Binary、Csv、XML 三种方式的序列化操作。而这三种方式有什么不同，我们在日常工作中应该如何选择呢？带着这些问题我们来深入到 Jute 的内部实现来找寻答案</p><h4 id="Binary-方式的序列化">Binary 方式的序列化</h4><p>首先我们来看一下 Jute 中的第 1 种序列化方式：Binary 序列化方式，即二进制的序列化方式。正如我们前边所提到的，采用这种方式的序列化就是将 Java 对象信息转化成二进制的文件格式。</p><p>在 Jute 中实现 Binary 序列化方式的类是 BinaryOutputArchive。该 BinaryOutputArchive 类通过实现 OutPutArchive 接口，在 Jute 框架采用二进制的方式实现序列化的时候，采用其作为具体的实现类。</p><p>在这里我们通过调用 Record 接口中的 writeString 方法为例，该方法是将 Java 对象的 String 字符类型进行序列化。当调用 writeString 方法后，首先判断所要进行序列化的字符串是否为空。如果是空字符串则采用 writeInt 方法，将空字符串当作值为 -1 的数字类型进行序列化；如果不为空，则调用 stringtoByteBuffer 方法对字符串进行序列化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">writeString</span> <span class="params">(String s, Sring tag)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">    writeInt(-<span class="number">1</span>,<span class="string">&quot;len&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> stringtoByteBuffer(s);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 stringToByteBuffer 方法也是 BinaryOutputArchive 类的内部核心方法，除了 writeString 序列化方法外，其他的比如 writeInt、wirteDoule 等序列化方法则是调用 DataOutPut 接口中的相关方法来实现具体的序列化操作。</p><p>在调用 BinaryOutputArchive 类的 stringToByteBuffer 方法时，在将字符串转化成二进制字节流的过程中，首选将字符串转化成字符数组 CharSequence 对象，并根据 ascii 编码判断字符类型，如果是字母等则使用1个 byte 进行存储。如果是诸如 “¥” 等符号则采用两个 byte 进程存储。如果是汉字则采用3个 byte 进行存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ByteBuffer <span class="title function_">stringToByteBuffer</span><span class="params">(CharSeuquece s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line"></span><br><span class="line">                bb.put((<span class="type">byte</span>) c);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">0x800</span>) &#123;</span><br><span class="line"></span><br><span class="line">      bb.put((<span class="type">byte</span>) (<span class="number">0xc0</span> | (c &gt;&gt; <span class="number">6</span>)));</span><br><span class="line"></span><br><span class="line">      bb.put((<span class="type">byte</span>) (<span class="number">0x80</span> | (c &amp; <span class="number">0x3f</span>)));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      bb.put((<span class="type">byte</span>) (<span class="number">0xe0</span> | (c &gt;&gt; <span class="number">12</span>)));</span><br><span class="line"></span><br><span class="line">      bb.put((<span class="type">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>)));</span><br><span class="line"></span><br><span class="line">      bb.put((<span class="type">byte</span>) (<span class="number">0x80</span> | (c &amp; <span class="number">0x3f</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Binary 二进制序列化方式的底层实现相对简单，只是采用将对应的 Java 对象转化成二进制字节流的方式。Binary 方式序列化的优点有很多：无论是 Windows 操作系统、还是 Linux 操作系统或者是苹果的 macOS 操作系统，其底层都是对二进制文件进行操作，而且所有的系统对二进制文件的编译与解析也是一样的，所有操作系统都能对二进制文件进行操作，跨平台的支持性更好。而缺点则是会存在不同操作系统下，产生大端小端的问题。</p><h4 id="XML-方式的序列化">XML 方式的序列化</h4><p>说完了 Binary 的序列化方式，我们再来看看 Jute 中的另一种序列化方式 XML 方式。XML 是一种可扩展的标记语言。当初设计的目的就是用来传输和存储数据，很像我们都很熟悉的 HTML 语言，而与 HTML 语言不同的是我们需要自己定义标签。在 XML 文件中每个标签都是我们自己定义的，而每个标签就对应一项内容。一个简单的 XML 的格式如下面这段代码所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>学生<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>老师<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>上课提醒<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>记得9:00来上课<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大概了解了 XML 文件，接下来我们看一下 Jute 框架中是如何采用 XML 方式进行序列化操作的。在 Jute 中使用 XmlOutPutArchive 类作用 XML 方式序列化的具体实现类。与上面讲解二进制的序列化实现一样 ，这里我们还是以 writeString 方法的 XML 序列化方式的实现为例。 首先，当采用XML 方式进行序列化时，调用 writeString 方法将 Java 中的 String 字符串对象进行序列化时，在 writeString 内部首先调用 printBeginEnvelope 方法并传入 tag 参数，标记我们要序列化的字段名称。之后采用“”和“”作用自定义标签，封装好传入的 Java 字符串。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">writeString</span>(String s, String tag)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printBeginEnvelope</span>(tag);</span><br><span class="line"></span><br><span class="line">   stream<span class="selector-class">.print</span>(&quot;&lt;string&gt;&quot;);</span><br><span class="line"></span><br><span class="line">   stream<span class="selector-class">.print</span>(Utils.toXMLString(s));</span><br><span class="line"></span><br><span class="line">   stream<span class="selector-class">.print</span>(&quot;&lt;/string&gt;&quot;);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printEndEnvelope</span>(tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 printBeginEnvelope 方法中，其主要作用就是添加该字段的名称、字段值等信息，用于之后反序列化的过程中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_ invoke__">printBeginEnvelope</span> (String tag)&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;struct&quot;</span>.<span class="title function_ invoke__">equals</span>(s)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">putIndent</span>();</span><br><span class="line"></span><br><span class="line">        stream.<span class="keyword">print</span>(<span class="string">&quot;&lt;member&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">addIndent</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">putIndent</span>();</span><br><span class="line"></span><br><span class="line">        stream.<span class="keyword">print</span>(<span class="string">&quot;&lt;name&gt;&quot;</span>+tag+<span class="string">&quot;&lt;/name&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">putIndent</span>();</span><br><span class="line"></span><br><span class="line">        stream.<span class="keyword">print</span>(<span class="string">&quot;&lt;value&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;vector&quot;</span>.<span class="title function_ invoke__">equals</span>(s)) &#123;</span><br><span class="line"></span><br><span class="line">        stream.<span class="keyword">print</span>(<span class="string">&quot;&lt;value&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;map&quot;</span>.<span class="title function_ invoke__">equals</span>(s)) &#123;</span><br><span class="line"></span><br><span class="line">        stream.<span class="keyword">print</span>(<span class="string">&quot;&lt;value&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    stream.<span class="keyword">print</span>(<span class="string">&quot;&lt;value&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面在 Jute 框架中，对采用 XML 方式序列化的实现类：XmlOutPutArchive 中的底层实现过程分析，我们可以了解到其实现的基本原理，也就是根据 XML 格式的要求，解析传入的序列化参数，并将参数按照 Jute 定义好的格式，采用设定好的默认标签封装成对应的序列化文件。</p><p>而采用 XML 方式进行序列化的优点则是，通过可扩展标记协议，不同平台或操作系统对序列化和反序列化的方式都是一样的，不存在因为平台不同而产生的差异性，也不会出现如 Binary 二进制序列化方法中产生的大小端的问题。而缺点则是序列化和反序列化的性能不如二进制方式。在序列化后产生的文件相比与二进制方式，同样的信息所产生的文件更大。</p><h4 id="Csv-方式的序列化">Csv 方式的序列化</h4><p>最后我们来学习一下 Jute 序列化框架的最后一种序列化方式：Csv，它和 XML 方式很像，只是所采用的转化格式不同，Csv 格式采用逗号将文本进行分割，我们日常使用中最常用的 Csv 格式文件就是 Excel 文件。</p><p>在 Jute 框架中实现 Csv 序列化的类是 CsvOutputArchive，我们还是以 String 字符对象序列化为例，在调用 CsvOutputArchive 的 writeString 方法时，writeString 方法首先调用 printCommaUnlessFirst 方法生成一个逗号分隔符，之后将要序列化的字符串值转换成 CSV 编码格式追加到字节数组中。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">writeString</span>(String s, String tag)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printCommaUnlessFirst</span>();</span><br><span class="line"></span><br><span class="line">  stream<span class="selector-class">.print</span>(Utils.toCSVString(s));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">throwExceptionOnError</span>(tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们已经对 Jute 框架的 3 种序列化方式的底层实现有了一个整体了解，这 3 种方式相比，二进制底层的实现方式最为简单，性能也最好。而 XML 作为可扩展的标记语言跨平台性更强。而 CSV 方式介于两者之间实现起来也相比 XML 格式更加简单。</p><h3 id="总结-5">总结</h3><p><strong>在 ZooKeeper 中默认的序列化实现方式是 Binary 二进制方式</strong>。这是因为二进制具有更好的性能，以及大多数平台对二进制的实现都不尽相同。</p><h2 id="06-ZooKeeper-的网络通信协议详解">06 ZooKeeper 的网络通信协议详解</h2><p>课我们将学习 ZooKeeper 的网络通信协议。同时，本节课也是基础篇中的最后一节课。在 ZooKeeper 中无论是客户端和服务器之间的通信，还是集群之间服务器的内部协同工作都是基于网络进行通信的。而网络通信协议则是影响 ZooKeeper 性能和稳定性的核心点。</p><h3 id="ZooKeeper-协议简述">ZooKeeper 协议简述</h3><p>说到网络通信协议我们最为熟悉的应该就是 TCP/IP 协议。而 ZooKeeper 则是在 TCP/IP 协议的基础上实现了自己特有的通信协议格式。在 ZooKeeper 中一次客户端的请求协议由请求头、请求体组成。而在一次服务端的响应协议中由响应头和响应体组成。</p><h3 id="ZooKeeper-协议的底层实现">ZooKeeper 协议的底层实现</h3><p>我们大概了解了 ZooKeeper 中的网络通信协议的结构后。接下来我们看一下在 ZooKeeper 中的内部对于网络通信协议的底层是怎么样实现的。</p><h4 id="请求协议">请求协议</h4><p>请求协议就是客户端向服务端发送的协议。比如我们经常用到的会话创建、数据节点查询等操作。都是客户端通过网络向 ZooKeeper 服务端发送请求协议完成的。</p><h4 id="客户端请求头底层解析">客户端请求头底层解析</h4><p>首先，我们先看一下请求头的内部的实现原理。在 ZooKeeper 中请求头是通过 RequestHeader 类实现的。首先 RequestHeader 类实现了 Record 接口，用于之后在网络传输中进行序列化操作。</p><p>我们可以看到 RequestHeader 类中只有两个属性字段分别是 xid 和 type。这两个字段在我们第一节课 ZooKeeper 的数据模型中介绍过，分别代表客户端序号用于记录客户端请求的发起顺序以及请求操作的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHeader</span> <span class="keyword">implements</span> <span class="title class_">Record</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> xid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端请求体底层解析">客户端请求体底层解析</h4><p>我们接下来再看一下客户端请求协议的请求体，协议的请求体包括了协议处理逻辑的全部内容，一次会话请求的所有操作内容都涵盖在请求体中。在 ZooKeeper 的内部实现中，根据不同的请求操作类型，会采用不同的结构封装请求体。接下来我们就以最常用的创建一次会话和数据节点的查询和更新这三种操作来介绍，深入底层看看 ZooKeeper 在内部是如何实现的。</p><p><strong>会话创建</strong></p><p>前面的课程我们已经介绍了 ZooKeeper 中的会话创建以及会话管理等相关知识。通过之前的学习我们知道了在 ZooKeeper 客户端发起会话时，会向服务端发送一个会话创建请求，该请求的作用就是通知 ZooKeeper 服务端需要处理一个来自客户端的访问链接。</p><p>而服务端处理会话创建请求时所需要的所有信息都包括在请求体内。在 ZooKeeper 中该请求体是通过 ConnectRequest 类实现的，其内部一共包括了五种属性字段。分别是 protocolVersion 表示该请求协议的版本信息、lastZxidSeen 最后一次接收到的服务器的 zxid 序号、timeOut 会话的超时时间、会话标识符 sessionId 以及会话的密码 password。有了这些信息 ZooKeeper 服务端在接收一个请求时，就可以根据请求体的信息进行相关的操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConnectRequest <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> protocolVersion;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> lastZxidSeen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> timeOut;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> sessionId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] passwd;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>节点查询</strong></p><p>在我们通过客户端 API 查询 ZooKeeper 服务器上的数据节点时，客户端会向服务端发送 GetDataRequest 会话请求。与上面介绍的会话请求不同。ZooKeeper 在处理获取数据节点会话请求时，选择了另一种结构作为该协议的请求体。而具体的实现类则是 GetDataRequest 。在 GetDataRequest 类中首先实现了 Record 接口用于序列化操作。其具有两个属性分别是字符类型 path 表示要请求的数据节点路径以及布尔类型 watch 表示该节点是否注册了 Watch 监控。</p><p>节点路径如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetDataRequest</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> watch;</span><br></pre></td></tr></table></figure><p><strong>节点更新</strong></p><p>最后，我们来看一下最后一种会话操作类型即节点的更新操作，同样的在客户端向服务端发送一个数据节点更新操作时，其在网络上实际发送的是更新操作的请求协议。而在 ZooKeeper 中对于协议内部的请求体，ZooKeeper 通过 SetDataRequest 类进行了封装。在 SetDataRequest 内部也包含了三种属性，分别是 path 表示节点的路径、data 表示节点数据信息以及 version 表示节点期望的版本号用于锁的验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetDataRequest</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>到目前为止我们就对 ZooKeeper 客户端在一次网络会话请求中所发送的请求协议的内部结构和底层实现都做了介绍，然而这些都是客户端向服务器端的请求协议，接下来我们就继续分析 ZooKeeper 服务端向客户端发送的响应协议是如何实现的。</p><h4 id="响应协议">响应协议</h4><p>响应协议可以理解为服务端在处理客户端的请求后，返回相关信息给客户端。而服务端所采用的响应协议类型则要根据客户端的请求协议类型来选择。</p><h4 id="服务端请求头解析">服务端请求头解析</h4><p>在服务端接收到客户端的请求后，执行相关操作将结果通知给客户端。而在 ZooKeeper 服务端向客户单发送的响应协议中，也是包括了请求头和请求体。而与客户端的请求头不同的是在 ZooKeeper 服务端的请求头多了一个错误状态字段。具体的实现类是 ReplyHeader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplyHeader</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> xid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> zxid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="服务端请求体解析">服务端请求体解析</h4><p>下面我们再看一下响应协议的请求体部分，服务端的请求体可以理解为对客户端所请求内容的封装，一个服务端的请求体包含了客户端所要查询的数据而对于不同的请求类型，在 ZooKeeper 的服务端也是采用了不同的结构进行处理的。与上面我们讲解客户端请求体的方法一样，我们还是通过会话的创建、数据节点的查询和修改这三种请求操作来介绍，看看 ZooKeeper 服务端是如何响应客户端请求的。</p><p><strong>响应会话创建</strong></p><p>对于客户端发起的一次会话连接操作，ZooKeeper 服务端在处理后，会返回给客户端一个 Response 响应。而在底层代码中 ZooKeeper 是通过 ConnectRespose 类来实现的。在该类中有四个属性，分别是 protocolVersion 请求协议的版本信息、timeOut 会话超时时间、sessionId 会话标识符以及 passwd 会话密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectResponse</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> protocolVersion;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> timeOut;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> sessionId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] passwd;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>响应节点查询</strong></p><p>在客户端发起查询节点数据的请求时，服务端根据客户端发送的节点路径，并验证客户端具有相应的权限后，会将节点数据返回给客户端。而 ZooKeeper 服务端通过 GetDataResponse 类来封装查询到的节点相关信息到响应协议的请求体中。在 GetDataResponse 内部有两种属性字段分别是 data 属性表示节点数据的内容和 stat 属性表示节点的状态信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetDataResponse</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> org.apache.zookeeper.data.Stat stat;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>响应节点更新</strong></p><p>在客户端发送一个节点变更操作后， ZooKeeper 服务端在处理完相关逻辑后，会发送一个响应给客户端。而在 ZooKeeper 中更新完节点后会将操作结果返回给客户端，节点更新操作的响应协议请求体通过 SetDataResponse 类来实现。而在该类的内部只有一个属性就是 stat 字段，表示该节点数据更新后的最新状态信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetDataResponse</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> org.apache.zookeeper.data.Stat stat;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="总结-6">总结</h3><p>Zookeeper为什么需要自定义协议？</p><p>ooKeeper选择使用自定义协议的主要原因是为了提高性能和灵活性。</p><ol><li><strong>性能</strong>：自定义协议允许ZooKeeper精确地定义和优化网络通信，以满足其特定的需求。例如，ZooKeeper的自定义协议可以更有效地处理大量的小数据包，这是ZooKeeper常见的使用场景。</li><li><strong>灵活性</strong>：使用自定义协议，ZooKeeper可以更灵活地调整和改进其网络通信。例如，它可以添加新的消息类型或者调整消息格式来支持新的功能。</li><li><strong>适应性</strong>：ZooKeeper的自定义协议可以更好地适应其特定的应用场景。例如，ZooKeeper需要在分布式环境中维护和同步状态，这需要一种能够有效处理这种需求的协议。</li></ol><p>总的来说，虽然使用自定义协议可能需要更多的开发工作，但是它可以带来更好的性能和更高的灵活性，使得ZooKeeper能够更好地满足其特定的需求。</p><p>参考:<a href="https://www.cnblogs.com/leesf456/p/6091208.html">https://www.cnblogs.com/leesf456/p/6091208.html</a></p>]]></content>
    
    
    <summary type="html">Zookeeper基础篇</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SEDA异步事件框架</title>
    <link href="https://penge666.github.io/posts/b1577ae3.html"/>
    <id>https://penge666.github.io/posts/b1577ae3.html</id>
    <published>2024-05-30T14:23:30.000Z</published>
    <updated>2024-05-30T14:43:33.302Z</updated>
    
    <content type="html"><![CDATA[<p>SEDA: An Architecture for Well-Conditioned, Scalable Internet Services</p><p>Matt Welsh, David Culler, and Eric Brewer 加州大学伯克利分校</p><p>论文地址：<a href="https://people.eecs.berkeley.edu/~brewer/papers/SEDA-sosp.pdf">https://people.eecs.berkeley.edu/~brewer/papers/SEDA-sosp.pdf</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    我们为高度并发的Internet服务提出了一种新设计，我们将其称为<strong>分阶段事件驱动架构（SEDA）</strong>。SEDA旨在支持大规模并发需求并简化良好服务的构建。在SEDA中，应用程序由通过显式队列连接的阶段事件驱动网络组成。这种架构使服务具有良好的负载，在需求超过服务容量时防止资源过度使用。尽管负载波动很大，但SEDA利用一组动态资源控制器将各阶段保持在其运行状态。我们描述了几种用于自动调整和负载调节的控制机制，包括线程池大小调整，事件批处理和自适应负载消减。我们介绍了SEDA设计以及基于该架构的互联网服务平台的实现。我们通过两个应用程序评估SEDA的使用：用于Gnutella（无结构的P2P网络代表软件）对等文件共享网络的高性能HTTP服务器和数据包路由器。这些结果表明，SEDA应用程序表现出比传统服务设计更高的性能，并且对于负载的巨大变化具有稳健性。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​      互联网呈现出前所未有的计算机系统问题：要求支持数百万用户的访问，服务必须是相应的、稳健的、始终可用的。Internet站点每天的并发会话数和点击次数转化为更多的I/O和网络请求，对底层资源提出了巨大的要求。雅虎每天收到超过12亿的页面浏览量，AOL的网络缓存每天提供超过100亿次点击。此外，互联网服务在服务负载方面经历巨大变化，突发与服务具有最大价值的时间一致。详细记录的“Slashdot效应”表明，当网站变得流行时，需求增长超过100倍并不罕见。随着对互联网服务的需求的增长，必须使用新的系统设计技术来管理这种负载。</p><p>​      这种系统挑战被三种趋势放大，这些趋势增加了服务的普遍性。首先，服务本身变得越来越复杂，静态内容被涉及大量计算和I/O的动态内容所取代。其次，服务逻辑趋于快速变化，这增加了工程和部署的复杂性。第三，服务越来越多地托管在通用设施上，而不是在为特定服务精心设计的平台上。随着这些趋势的继续，我们设想将创建一系列丰富的新颖服务并将其推入基础设施，在这些基础设施中，它们可能会成功扩展到数百万用户。一些研究正在解决服务的高级方面，包括命名，查找，组合和版本控制。我们将重点放在问题的性能方面：在负载变化很大的情况下，在广泛的服务上实现强大的性能，同时保持其易用性。复制是服务可伸缩性的关键方面。给定一个可以维持一定性能水平的服务实例，必须复制它以维持负载的多倍增加，可扩展的集群现在被广泛用于在服务站点内获得复制，并且广泛的复制越来越多地用于特定服务，例如内容分发网络。但是，因为峰值负载可能比平均值大几个数量级，所以它不实用。复制大多数服务以处理最大的潜在需求。 因此，我们预计每个节点所承受的负载会出现大幅峰值。我们的目标是开发一个通用框架，用于创建高度并发且运行良好的服务实例，以便优雅地处理负载。</p><p>​      遗憾的是，传统的操作系统设计和广泛推广的并发模型并不能提供这种优雅的负载管理。商品操作系统专注于通过为每个进程提供独有的CPU，内存，磁盘和网络的虚拟机的抽象来提供最大的透明度。 这个目标与互联网服务的需求有些不一致，互联网服务需要大量的并发性和对资源使用的广泛控制。进程和线程是良好支持的并发编程模型，但在上下文切换时间和内存占用方面往往需要很高的开销，这限制了并发性。 透明的资源虚拟化阻止了应用程序做出明智的决策，这对于管理过多的负载至关重要。大多说工作都侧重于特定服务的性能和稳健性。然而，随着服务变得越来越动态和灵活，这种工程负担变得过度。很少有工具可以帮助开发高度并发，运行良好的服务; 我们的目标是通过提供帮助软件开发人员获取这些属性的通用机制来降低这种复杂性。</p><p>​      我们为高度并发的服务器应用程序提出了一个新的设计框架，我们将其称为分阶段事件驱动架构（SEDA）。SEDA结合了线程和基于事件的编程模型的各个方面来管理Internet服务的并发性，I/O，调度和资源管理需求。在SEDA中，应用程序被构建为阶段网络，每个阶段都具有关联的传入事件队列。每个阶段可以通过单独调节负载阈值或过滤其事件队列来构建一个健壮的模块。此外，使事件队列显式化允许应用程序进行合适的调度和资源管理决策，例如重新排序，过滤或聚合请求。SEDA利用动态资源限制来控制应用程序组件的资源分配和调度，使系统能够适应过载状态。</p><p>​      本文描述了基于SEDA的Internet服务平台的设计，体系结构和实现。该平台提供高效，可扩展的I/O接口以及多种资源控制机制，包括线程池大小调整和动态事件调度。我们通过两个应用程序评估框架 - 一个高性能HTTP服务器和一个用于Gnutella对等文件共享网络的数据包路由器。我们为这些应用提供了性能和可扩展性结果，证明了SEDA在负载的巨大变化上实现了稳健性，并且优于其他服务设计。我们基于Java的SEDA HTTP服务器优于基于C实现的两个流行的Web服务器，如第5.1节所述。我们认为使用SEDA，高度并发的应用程序更容易构建，更高效，更强大的负载。通过正确的接口，应用程序设计人员可以专注于特定于应用程序的逻辑，而不是并发和资源管理的细节。</p><h2 id="背景和相关工作"><a href="#背景和相关工作" class="headerlink" title="背景和相关工作"></a>背景和相关工作</h2><p>​      SEDA汇集了两个重要的研究领域：<strong>使用基于线程的并发模型来简化编程，使用基于事件的模型来实现大规模的并发</strong>。本节通过概述主导SEDA设计的步骤中的关键贡献和问题来阐明开发这种方法的谱系。</p><p>​      直观地说，如果服务的行为类似于简单的管道，那么服务就是运行良好的，管道的深度由通过网络的路径和服务本身内的处理阶段决定。随着提供的负载增加，交付的吞吐量按比例增加，直到管道充满并且吞吐量饱和; 额外的负载不应该降低吞吐量。类似地，服务所呈现的响应时间在轻负载时大致恒定，因为它由管道的深度支配。当负载接近饱和时，排队延迟占主导地位。在许多服务典型的闭环场景中，每个客户端在提交下一个请求之前等待响应，响应时间应随客户端数量线性增加。</p><p>​      良好的服务的关键属性是优雅降级：当提供的负载超过容量时，服务保持高吞吐量，线性响应时间损失同等地影响所有客户端，或者至少根据某些特定于服务的策略可预测影响。请注意，这不是典型的Web体验; 相反，随着负载的增加，吞吐量会降低，响应时间也会大幅增加，从而产生服务崩溃的印象。</p><h3 id="基于线程的并发"><a href="#基于线程的并发" class="headerlink" title="基于线程的并发"></a>基于线程的并发</h3><p>​      服务器应用程序最常用的设计是thread-per-request线程模型，如RPC包，Java远程方法调用和DCOM中所体现的。 当前的语言和编程环境很好地支持这个模型。 在此模型中，如图1所示，每个接受的请求都使用一个线程来处理它，同步操作受保护的共享资源。操作系统通过在线程之间透明切换来交叉计算和I/O.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530222909219.png" alt="image-20240530222909219"></p><p>图1：线程服务器设计：将每个传入请求分派到一个单独的线程，该线程处理请求并将结果返回给客户端。边表示分支之间的控制流。请注意，此处未显示其他I/O操作（如磁盘访问），但会将其合并到每个线程的请求处理中。</p><p>尽管编程相对容易，但与线程相关的开销（包括缓存和TLB未命中，调度开销和锁争用）当线程数量变大时，会导致严重的性能下降。作为一个具体示例，图2显示了随着线程数量的增加，简单线程服务器的性能。尽管有效的线程限制对于通用分时来说会很大，但它不足以满足Internet服务的巨大并发要求。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530222949971.png" alt="image-20240530222949971"></p><p>图2：线程服务器吞吐量降低</p><p>纵坐标表示吞吐量（每秒任务数） 横坐标表示线程数</p><p>红线代表吞吐量 蓝线代表实际延迟走势 紫线代表理想状态下线性延迟走势</p><p>​    此基准测试用于测量一个简单的线程服务器，该服务器为管道中的每个任务创建单个线收到任务后，每个线程从磁盘文件执行8 KB读取; 所有线程都从同一个文件读取，因此数据总是在缓冲区缓存中。线程在服务器中预先分配，以消除测量中的线程启动开销，并在内部生成任务以消除网络效应。该服务器采用C语言实现，运行在Linux 2.2.14下的4路500 MHz Pentium III和2 GB内存上。 随着并发任务数量的增加，吞吐量会增加，直到线程数量增大，之后吞吐量会大幅下降。 随着任务队列长度的增加，响应时间变得无限制; 为了比较，我们已经显示了理想的线性响应时间曲线（注意x轴上的对数刻度）。</p><p>​      线程和进程主要用于支持多道程序设计，现有的OS力求以对应用程序透明的方式虚拟化硬件资源。应用程序很少有机会参与系统范围的资源管理决策，或者给出资源可用性的指示，以使其行为适应不断变化的条件。虚拟化从根本上隐藏了资源有限和共享的事实。</p><p>​      许多系统试图通过向应用程序公开更多控制来解决这个问题。调度程序激活[5]，应用程序特定处理程序[59]和操作系统（如SPIN [11]，Exokernel [28]和Nemesis [34]）都试图通过为应用程序提供特化内核做出的决策的能力来增强有限的操作系统接口。然而，这些系统的设计仍然基于多道程序设计，因为重点仍然放在安全和有效的资源虚拟化上，而不是优雅的管理和高并发性。</p><h3 id="有界线程池"><a href="#有界线程池" class="headerlink" title="有界线程池"></a>有界线程池</h3><p>​      为了避免过度使用线程，许多系统采用粗略形式的负载调节，用于绑定与服务关联的线程池的大小。 当服务器中的请求数超过某个固定限制时，不接受其他连接。 Web服务器（如Apache [6]，IIS [38]和Netscape Enterprise Server [42]）以及应用程序服务器（如BEA Weblogic [10]和IBM WebSphere [25]）使用此方法。 通过限制并发线程的数量，服务器可以避免吞吐量降低，并且整体性能比无约束的每任务线程模型更强大。但是，这种方法会给客户端带来很多不公平：当所有服务器线程忙或被阻塞时，客户端请求在网络中排队等待服务。正如我们将在5.1节中所示，这可能导致客户端经历任意大的等待时间。</p><p>​      当每个请求由单个线程处理时，很难识别内部性能瓶颈以执行调整和负载调节。 考虑一个简单的线程Web服务器，其中一些请求处理起来成本低廉（例如，缓存的静态页面）而其他请求则很昂贵（例如，不在缓存中的大页面）。 对于许多并发请求，昂贵的请求可能是性能瓶颈的来源，因此需要执行减载。 但是，服务器无法检查内部请求流以实现此类策略; 它所知道的是线程池已经饱和，并且一定是在不知道瓶颈来源的情况下随意拒绝工作。</p><p>​      资源容器[7]和来自Scout操作系统[41,49]的路径概念是两种可用于限制服务器中任务的资源使用的技术。这些机制将垂直资源管理应用于一组软件模块，允许整个数据流通过系统的资源作为一个单元进行管理。 在上述瓶颈的情况下，限制给定请求的资源使用，将避免由于高速缓存未命中而导致的降级，但允许高速缓存命中继续进行。</p><h3 id="事件驱动的并发"><a href="#事件驱动的并发" class="headerlink" title="事件驱动的并发"></a>事件驱动的并发</h3><p>​      线程的可伸缩性限制导致许多开发人员几乎完全避开它们，并采用事件驱动的方法来管理并发。在这种方法中，如图3所示，服务器由少量线程（通常每个CPU一个）组成，它们不断循环，处理队列中不同类型的事件。事件可以由操作系统生成，也可以由应用程序在内部生成，通常对应于网络和磁盘I/O就绪和完成通知，定时器或其他特定于应用程序的事件。事件驱动方法将每个任务的处理实现为有限状态机，其中FSM（finite state machine）中的状态之间的转换由事件触发。通过这种方式，服务器为每个任务维护自己的连续状态，而不是依赖于线程上下文。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223052896.png" alt="image-20240530223052896"></p><p>图3：事件驱动的服务器设计：此图显示了通过事件驱动的服务器的事件流。 主线程处理来自网络，磁盘和其他来源的传入事件，并使用它们来驱动许多有限状态机的执行。 每个FSM代表通过系统的单个请求或执行流程。 此设计的复杂性的关键来源是事件调度程序，它必须控制每个FSM的执行。</p><pre><code> 事件驱动设计被许多系统使用，包括Flash [44]，thttpd [4]，Zeus [63]和JAWS [24] Web服务器以及Harvest [12] Web缓存。在Flash中，服务器的每个组件都响应特定类型的事件，例如套接字连接或文件系统访问。主服务器进程负责不断地将事件分派给每个组件，这些组件实现为库调用。因为某些I/O操作（在这种情况下，文件系统访问）没有异步接口，所以主服务器进程通过IPC将它们分派给辅助进程来处理这些事件。帮助程序处理发出（阻塞）I/O请求并在完成时将事件返回到主进程。Harvest的结构非常相似：它是单线程和事件驱动的，但FTP协议除外，它由一个单独的进程实现。(Harvest:google搜索到是一款面向自由职业者和小型企业的时间跟踪和在线发票应用程序。</code></pre><p>​      线程和事件驱动的并发模型之间的权衡已经在JAWS Web服务器中进行了广泛的研究[23,24]。JAWS(一个高性能的web服务器架构，jaws设计论文)为Web服务器构建提供了一个框架，允许自定义并发模型，协议处理代码，缓存文件系统和其他组件。与SEDA一样，JAWS强调服务设计中适应性的重要性，通过促进服务框架中的静态和动态适应性。据我们所知，JAWS仅在轻载（少于50个并发客户端）下进行了评估，并未解决在高负荷下使用适应性进行调节的问题。</p><p>​      事件驱动系统往往对负载具有稳定性，随着提供的负载增加超出饱和度，吞吐量几乎没有降低。 图4显示了使用图2中的服务的事件驱动版本实现的吞吐量。随着任务数量的增加，服务器吞吐量会增加，直到管道填满并且瓶颈（在这种情况下为CPU）变得饱和。 如果管道中的任务数量进一步增加，则多余的任务将被吸收在服务器的事件队列中。 吞吐量在很大的负载范围内保持不变，每个任务的延迟线性增加。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223140377.png" alt="image-20240530223140377"></p><p>图4：事件驱动的服务器吞吐量：该基准测试用于测量图2中服务器的事件驱动版本。</p><p>在这种情况下，服务器使用单个线程来处理任务，其中每个任务从单个磁盘文件读取8 KB。尽管此处使用的操作系统（Linux 2.2.14）提供的文件系统接口是阻塞的，但由于磁盘数据始终位于缓存中，因此此基准测试可估算非阻塞磁盘I/O层的最佳性能。如图所示，当负载增加到非常大量的任务时，吞吐量保持不变（注意图2中水平轴刻度的变化），响应时间是线性的（注意x轴上的对数刻度）。</p><p>​      此模型的一个重要限制是它假定事件处理线程不会阻塞，因此必须使用非阻塞I/O机制。虽然许多先前的工作已经研究了可伸缩的I/O原语[8,9,33,46,48]，但由于中断，页面错误或垃圾收集，事件处理线程会造成阻塞而不管所使用的I/O机制如何。</p><p>​      事件驱动的设计为应用程序开发人员带来了许多额外的挑战。 事件的调度和排序可能是最重要的问题：应用程序负责决定何时处理每个传入事件以及处理多个流的FSM的顺序。 为了平衡公平性和低响应时间，应用程序必须仔细地复用多个FSM的执行。事件调度算法的选择通常是针对特定应用而定制的，并且新功能的引入可能需要重新设计算法。此外，模块化很难实现，因为必须信任实现每个状态的代码，以阻止或消耗大量可能使事件处理线程停滞的资源。</p><h3 id="结构化事件队列"><a href="#结构化事件队列" class="headerlink" title="结构化事件队列"></a>结构化事件队列</h3><p>   已经提出了关于标准事件驱动设计的若干变体来解决上述问题。 这些设计的一个共同方面是使用一组事件队列构建事件驱动的应用程序，以提高代码模块性并简化应用程序设计。</p><p>   Click模块化分组路由器(Click路由器论文)[40]就是这样一个例子。在Click中，数据包处理阶段由具有自己的私有状态的单独代码模块实现。Click经过优化，可通过路由器改善每个数据包的延迟，允许单个线程直接通过多个数据包处理阶段进行调用。 此设计针对特定应用程序（路由），单个线程为所有事件队列提供服务。Click假设模块具有有限的处理时间，从而导致相对静态的资源管理策略。Qie(Qie路由器论文)等。[47]还描述了在基于软件的路由器中调度和负载调节的技术; 与SEDA一样，他们的设计利用控制器根据负载动态调整运行时参数。</p><p>   Gribble的分布式数据结构（DDS）[20]层也使用了结构化的事件处理框架。在DDS中，存储服务器通过使用固定大小的线程池来模拟异步网络和磁盘I/O接口，并且使用显式事件队列或隐式上行调用来组成软件组件。Work Crews [56]和TSS/360队列扫描程序[35]是利用结构化事件队列和有限数量的线程来管理并发性的系统的其他示例。在这些系统的每一个中，事件队列的使用解耦了两个组件的执行，这提高了模块性和稳定性。</p><p>   StagedServer [31]是另一个利用显式事件队列进行通信的系统。 在这种情况下，目标是通过仔细调度每个模块中的线程和事件来最大化处理器缓存局部性。 通过聚合队列中多个类似事件的执行，增强了局部性，从而提高了性能。（译者注：线程跳转越少，局部性就会更好）</p><p>   Lauer和Needham的经典论文[32]讨论了通过消息进行通信的过程的优点，并将这种方法与“procedures”的方法进行了对比，这与上述线程模型密切相关。 SEDA可以看作是那里讨论的面向消息的模型的一个实例。 作者声称基于消息和基于过程的模型是彼此的双重性，并且在一个模型中实现的任何程序都可以在另一个模型中有效地实现。 虽然我们同意这种基本情绪，但这一论点忽略了构建可扩展通用多线程的复杂性，以及在没有显示请求队列的情况下在基于线程的模型中调整负载的固有困难。</p><h3 id="分阶段事件驱动架构"><a href="#分阶段事件驱动架构" class="headerlink" title="分阶段事件驱动架构"></a>分阶段事件驱动架构</h3><p>​      在本节中，我们提出了一种新的软件架构，即分阶段事件驱动架构（SEDA），旨在实现Internet服务的高并发性，负载调节和易于设计。SEDA将应用程序分解为由事件队列分隔的阶段网络，并引入动态资源控制器的概念，以允许应用程序动态调整以适应不断变化的负载。SEDA服务设计方法概述如图5所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223255205.png" alt="image-20240530223255205"></p><p><strong>目标</strong></p><p>SEDA的主要目标如下：</p><p>支持大规模并发：为避免因为线程导致性能下降，SEDA尽可能使用事件驱动的执行。 这还要求系统提供高效且可扩展的I/O原语。</p><p>简化良好条件服务的构建：为了降低构建Internet服务的复杂性，SEDA保护应用程序开发者免受许多调度和资源管理的细节。该设计还支持这些应用程序的模块化构造，并为调试和性能分析提供支持。</p><p>启用自我检查：应用程序应该能够分析请求流，以使行为适应不断变化的负载条件。 例如，系统应该能够确定优先级并过滤请求，以支持在高负载下降级服务。</p><p>支持自我调优资源管理：系统应该动态调整其资源管理参数以满足性能目标，而不是强制要求应用程序资源需求和客户端负载特性的先验知识。例如，分配给阶段的线程数可以根据感知的并发需求自动确定，而不是由程序员或管理员硬编码。</p><p><strong>作为健壮构建块的阶段</strong></p><p>​      SEDA内的基本处理单位是stage。stage是一个独立的应用程序组件，由事件处理程序，传入事件队列和线程池组成，如图6所示。每个阶段由影响调度和线程分配的控制器管理，如下所述。阶段线程通过从传入事件队列中拉出一批事件并调用应用程序提供的事件处理程序来进行操作。事件处理程序处理每批事件，并通过将它们排入其他阶段的事件队列来调度零个或多个事件。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223336442.png" alt="image-20240530223336442"></p><p>图6：SEDA阶段：阶段由传入事件队列，线程池和应用程序提供的事件处理程序组成。 阶段的操作由控制器管理，控制器动态调整资源分配和调度。</p><p>​      线程是SEDA中的基本并发机制，但它们的使用仅限于每个阶段的少量线程，而不是系统中每个任务一个线程。此外，动态控制的使用（参见3.4节）可以根据需求自动调整分配给每个阶段的线程数。此设计允许阶段按顺序或并行运行，或两者的组合，取决于线程系统和调度程序的特性 在本文中，我们假设在SMP环境中的操作系统支持抢占式线程，尽管这种选择不是SEDA设计的基础。例如，可以设计一个线程系统，它认识到应用程序的分阶段结构并相应地调度线程。 我们在3.4节回到这个问题。</p><p>​      每个阶段的核心逻辑由事件处理程序提供，其输入是一批多个事件。 事件处理程序无法直接控制队列操作或线程。通过将核心应用程序逻辑与线程管理和调度分离，该阶段能够控制事件处理程序的执行以实现各种资源管理策略。例如，传递给事件处理程序的事件的数量和顺序可以由运行时环境在外部控制。但是，应用程序还可以通过过滤或重新排序传递给它的事件批来实现自己的调度策略。</p><p><strong>作为阶段网络的应用</strong></p><p>​      SEDA应用程序构建为阶段网络，由事件队列连接。事件处理程序可以通过首先获取该阶段的传入事件队列的句柄（通过系统提供的查找例程），然后在该队列上调用入队操作，将事件排入另一个阶段。<br>SEDA中事件队列的一个重要方面是它们可能是有限的：也就是说，如果队列希望拒绝新条目（例如，因为它已达到阈值），则入队操作可能会失败。当排队操作失败时，应用程序可以使用背压（通过阻塞整个队列）或减载（通过丢弃事件）。或者，应用程序可能希望采取某些特定于服务的操作，例如向用户发送错误，或执行替代功能，例如提供降级服务。</p><p>​      图5说明了基于SEDA的应用程序的结构，在本例中是5.1节中描述的Haboob Web服务器。该应用程序包含许多特定于应用程序的阶段，用于处理HTTP请求，实现页面缓存等，以及运行时提供的几个通用阶段，以支持异步I/O. 这些接口在第4节中进一步描述。</p><p>​      阶段之间引入队列通过采用显式控制边界来解耦其执行。此模型将线程的执行约束到给定阶段，因为线程可能只通过将事件排入队列来跨控制边界传递数据。一个基本问题是两个代码模块是应该通过队列进行通信，还是直接通过子程序调用进行通信。在两个模块之间引入队列可提供隔离，模块化和独立负载管理，但可能会增加延迟。例如，第三方代码模块可以在其自己的阶段中隔离，允许其他阶段通过其事件队列与之通信，而不是直接调用它。</p><p>​      SEDA设计有助于服务的调试和性能分析，这对于复杂的多线程服务器来说一直是一个挑战。 将应用程序代码分解为阶段和显式事件传递机制有助于检查; 例如，调试工具可以跟踪通过系统的事件流，并可视化阶段之间的交互。 由于各阶段通过事件调度协议而不是传统API进行交互，因此可以直接在组件之间插入代理阶段以进行调试和性能分析。 使用这种机制，我们的SEDA原型能够生成描绘应用程序阶段及其关系的图表。 原型还可以生成事件队列长度，内存使用和其他系统属性的时间视图，这些属性对于理解性能很有价值。</p><h3 id="动态资源控制器"><a href="#动态资源控制器" class="headerlink" title="动态资源控制器"></a>动态资源控制器</h3><p>​      实现易于服务工程的关键目标是保护程序员免受性能调优的复杂性。 为了使每个阶段保持在其运行状态内，SEDA利用一组资源控制器，根据观察到的性能和需求自动调整阶段的资源使用。 抽象地，控制器观察阶段的运行时特性并调整分配和调度参数以满足性能目标。 控制器既可以完全掌握关于特定阶段的本地知识，也可以基于全局状态协同工作。</p><p>​      我们在SEDA中实现了几个资源控制器，其中两个如图7所示。第一个是线程池控制器，它调整每个阶段内执行的线程数。 目标是避免分配太多线程，但仍有足够的线程来满足阶段的并发需求。 控制器定期对输入队列进行采样，并在队列长度超过某个阈值时添加一个线程，最多为每个阶段的最大线程数。 当线程空闲一段指定的时间后，线程将从一个阶段中删除。 图8显示了在5.1节中描述的Web服务器中运行的线程池控制器的影响; 控制器操作将在4.2节中详细讨论。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223433294.png" alt="image-20240530223433294"></p><p>图7：SEDA资源控制器：每个阶段都有一个关联的控制器，可以调整其资源分配和行为，以使应用程序保持在其运行状态。 线程池控制器调整在阶段内执行的线程数，批处理控制器调整事件处理程序的每次迭代处理的事件数。<br>      第二个是批处理控制器，它调整每个阶段内事件处理程序调用处理的事件数（批处理因子）。 已经观察到[31]一次处理许多事件会增加吞吐量，因为可以执行缓存局部性和任务聚合。 但是，较大的批处理因子也会增加响应时间。 控制器试图通过搜索维持高吞吐量的最小批处理因子来权衡这些影响。 它通过观察来自一个阶段的事件的输出速率（通过维持许多样本的移动平均值）来操作，并降低批处理因子直到吞吐量开始降低。 如果吞吐量略有下降，则批处理因子会少量增加。 控制器通过将批处理因子重置为其最大值来响应负载的突然下降。 图9显示了工作中的批处理控制器。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223454494.png" alt="image-20240530223454494"></p><p>图8：SEDA线程池控制器：此图显示了在运行Haboob Web服务器期间线程池控制器的操作，如第5.1节中所述。 控制器根据相应事件队列的长度调整每个阶段的线程池的大小。 在此运行中，队列长度每2秒采样一次，如果队列超过100个条目，则会将一个线程添加到池中（每个阶段的最大限制为20个线程）。当线程空闲超过5秒时，它们将从池中删除。 异步文件阶段使用10个队列条目的控制器阈值来夸大控制器的行为。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223512168.png" alt="image-20240530223512168"></p><p>图9：SEDA批处理控制器：该图显示了批处理控制器对简单基准测试的操作，该基准测试包括以振荡速率生成事件的单个阶段。 这导致测量的输出速率变化，如图的顶部所示。当输出速率增加时，控制器会降低批处理因子。当输出速率降低时，控制器会增加批处理因子。在输出速率突然下降之后，批处理因子被重置为其最大值。<br>      这些机制代表了SEDA中动态控制的两个简单例子。可以将更复杂的控制器引入系统中; 例如，控制器可能会根据阶段优先级的全局概念调整线程池大小，或者将整个系统中的线程数保持在某个阈值以下。另一种选择是根据阶段的进展调整线程调度参数，如Steere等人提出的。[51]。 SEDA异步套接字库（将在下一节中介绍）包含一个可选控制器，用于限制从网络读取数据包的速率 在5.1节中，我们描述了一个特定于应用程序的控制器，它可以自适应地减少负载以满足响应时间目标。SEDA的结构有助于检查和控制底层应用，并且该模型可以实现一系列控制策略。<br>      SEDA中动态控制的一个重要方面是它允许应用程序适应不断变化的条件，尽管底层操作系统使用了特定的算法。从某种意义上说，SEDA的控制器对操作系统的资源管理策略很天真。例如，SEDA批处理控制器不知道OS线程调度策略; 相反，它会影响基于应用程序性能的外部观察的线程调度。 虽然在某些情况下可能需要对底层操作系统施加更多控制 - 例如，为特定阶段或线程提供服务质量保证 - 我们认为商用操作系统提供的基本资源管理机制，取决于应用级别控制，足以满足互联网服务的需求。</p><h3 id="Sandstorm：SEDA原型"><a href="#Sandstorm：SEDA原型" class="headerlink" title="Sandstorm：SEDA原型"></a>Sandstorm：SEDA原型</h3><p>​      我们已经实施了一个名为Sandstorm的基于SEDA的互联网服务平台。Sandstorm完全用Java实现，并使用一组native库来实现非阻塞套接字I/O（如第4节所述）。使用最新的Java实现，加上正确地使用Java的语言功能，我们发现使用Java的软件工程的稳定性优势远远超过了性能权衡。例如，我们依靠Java的自动内存管理来在系统内对“过期”事件进行垃圾收集; 这大大简化了代码，因为组件不负责跟踪事件的生命周期。Java和静态编译语言之间的性能差距也在缩小; 事实上，我们基于Java的SEDA Web服务器优于在C中实现的两个流行的Web服务器，如第5.1节所述。</p><p>​      在Sandstorm中，每个应用程序模块都使用单个方法调用handleEvents()实现一个简单的事件处理程序接口，该方法处理从阶段的传入事件队列中提取的一批事件。应用程序不创建或管理线程; 这是运行时系统和相关控制器的责任。Sandstorm提供了一个线程管理器接口，可以对其进行定制以实现各种线程分配和调度策略; 此处描述的版本管理每个阶段的线程池，并依赖于底层操作系统进行调度。 Sandstorm提供用于命名，创建和销毁阶段，执行队列操作，控制队列阈值以及分析和调试的API。下一节中描述的套接字和文件I/O机制被提供为标准接口。</p><p>​      Sandstorm运行时由19934行代码和7871非注释源语句（NCSS）组成。其中，3023 NCSS专用于核心运行时，2566专用于I/O设施。</p><h2 id="异步I-O原语"><a href="#异步I-O原语" class="headerlink" title="异步I/O原语"></a>异步I/O原语</h2><p>​      要满足SEDA支持高并发性的目标，需要高效，强大的I/O接口。本节描述如何使用SEDA概念使用现有OS原语实现这些接口。我们描述了一个异步网络套接字层，它利用操作系统提供的非阻塞I/O，以及使用阻塞OS调用和线程池来暴露非阻塞行为的异步文件I/O层。这两个层都实现为一组SEDA阶段，应用程序可以使用它们来提供快速的异步I/O.</p><h3 id="异步套接字I-O"><a href="#异步套接字I-O" class="headerlink" title="异步套接字I / O."></a>异步套接字I / O.</h3><p>​      Sandstorm异步套接字（asyncSocket）层为服务提供了易于使用的非阻塞套接字接口。 应用程序创建类asyncClientSocket和asyncServerSocket的实例以启动传出和传入套接字连接。建立连接时，会将asyncConnection对象推送到用户提供的事件队列（通常是与请求阶段关联的队列）。传入的数据包被排入用户的事件队列，asyncConnection实现了一个可以放置传出数据包的队列接口。每个输出包还可以具有相关联的事件队列，当包被传输时，一个完成事件被推到这个队列上。错误和其他通知事件以类似的方式传递给用户。<br>​      在内部，asyncSocket层使用三个阶段实现，这三个阶段在所有套接字之间共享，如图10所示.readStage读取网络数据包并响应用户请求以在新套接字上启动数据包读取。writeStage将数据包写入网络并建立新的传出连接。 listenStage接受新的TCP连接并响应用户监听新端口的请求。asyncConnection，asyncClientSocket或async-ServerSocket上的每个操作都将转换为请求并放置到相应阶段的请求队列中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223637885.png" alt="image-20240530223637885"></p><p>图10：基于SEDA的异步套接字层：Sandstorm套接字接口包括三个阶段：读取，写入和监听。读取阶段响应网络I/O就绪事件并从套接字读取数据，将新数据包推送到应用程序阶段。写入阶段接受传出数据包并调度它们以写入适当的套接字。它还建立新的传出套接字连接。listen阶段接受新的TCP连接并将连接事件推送到应用程序。<br>      每个asyncSocket阶段都为两个独立的事件队列提供服务：来自用户的请求队列，以及来自操作系统的I/O 就绪/完成事件队列。 每个阶段中的线程交替地为每个队列服务，使用简单的超时机制在两者之间切换。I/O事件队列实现为库，该库导致出队操作调用适当的OS调用以检索I/O事件。我们当前的实现支持标准的UNIX poll（2）系统调用以及用于事件传递的/dev/poll [46]接口。 native库用于在Java [60]中提供非阻塞套接字调用。为了提高套接字的公平性，每个阶段随机化处理操作系统提供的I/O事件的顺序。这是必要的，因为OS通常以固定顺序（例如，按文件描述符的递增顺序）返回套接字事件。<br>      只要I/O就绪事件指示套接字具有可用数据，readStage就会通过执行套接字读取来进行操作。它最多将16 KB读入预先分配的缓冲区，并将生成的数据包排入用户提供的事件队列中。在I/O错误的情况下（例如，因为对等方已关闭连接），该阶段关闭套接字并将适当的通知事件推送给用户。每个套接字读取都需要分配新的数据包缓冲区;虽然这可能会导致大量的垃圾收集开销，但我们并未发现这是一个性能问题。请注意，由于此系统是用Java实现的，因此不需要显式释放过期的数据包。readStage还提供了一个可选的速率控制器，可以限制从网络读取数据包的速率;该控制器可用于在过载条件下执行减载。通过计算输入包速率的移动平均值并将人工延迟引入事件处理循环以实现特定速率目标来实现控制器。<br>      writeStage接收来自用户的数据包写入请求，并将它们排入与特定套接字关联的内部队列。当操作系统指示套接字已准备好写入时，它会尝试在该套接字的传出队列上写入下一个数据包。如第5.2节所述，可以对套接字队列进行阈值处理，以防止“慢”套接字在服务器中占用过多资源。<br>      为了评估asyncSocket的性能，我们实现了一个简单的服务器应用程序，它接受来自多个客户端的8KB突发数据包，每1000个突发数据包响应一个32字节的ACK。这种有点人为的应用程序旨在强调网络层，并随着客户端数量的增加来衡量其可扩展性。图11显示了服务器的总吞吐量，期间客户端数量从1增加到8192.服务器和客户端计算机都是使用运行Linux 2.2.14和IBM JDK 1.3的千兆以太网互连的4路500 MHz Pentium III系统。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240530223652100.png" alt="image-20240530223652100"></p><p>图11：异步套接字层性能：此图显示了基于SEDA异步套接字层作为并发连接数量的函数的性能。每个客户端打开与服务器的连接并发出8KB突发数据包; 服务器对每个1000个数据包的突发，响应一个32字节的单独ACK。所有机器都通过交换式千兆以太网连接，并运行Linux 2.2.14。基于SEDA的服务器使用操作系统提供的非阻塞I/O原语。将性能与使用阻塞套接字和多个线程来模拟异步I/O的兼容性层进行比较。基于线程的层无法接受超过400个并发连接，因为所需的线程数将超过Linux中的每用户线程限制。<br>      套接字层的两种实现方式。 基于SEDA的层使用OS提供的非阻塞I/O和/dev/poll事件传递机制[46]。 将其与使用阻塞套接字的兼容性层和用于模拟异步I/O的线程池进行比较。该层为每个连接创建一个线程来处理套接字读取事件和一个固定大小的120个线程池来处理套接字写入。此兼容层最初是为了在Java下提供异步I / O而开发的，它不直接提供此功能。<br>      非阻塞实现明显优于线程版本，随着连接数量的增加，线程版本迅速降级。实际上，当接收超过400个连接时，线程实现会崩溃，因为所需的线程数超过了Linux中的每用户线程限制。非阻塞层的轻微吞吐量降低部分是由于Linux网络堆栈缺乏可扩展性。即使使用高度优化的/dev/poll机制[46]进行套接字I/O事件通知，随着套接字数量的增加，来自操作系统的轮询准备事件所涉及的开销也会显着增加[29]。</p><h3 id="异步文件I-O"><a href="#异步文件I-O" class="headerlink" title="异步文件I/O."></a>异步文件I/O.</h3><p>​      Sandstorm文件I/O（asyncFile）层展示与asyncSocket非常不同的设计点。由于底层操作系统不提供非阻塞文件I/O原语，因此我们不得不利用阻塞I/O和有界线程池来实现该层.3用户通过asyncFile对象执行文件I/O，该对象支持熟悉的接口读，写，寻找，统计和关闭。这些操作中的每一个都转换为asyncFile阶段的事件队列中的请求。asyncFile线程将每个请求出列并对文件执行相应的（阻塞）I/O操作。 为确保对同一文件上的多个I/O请求进行串行执行，一次只有一个线程可以处理特定文件的事件。当I/O请求完成时，相应的完成事件将排入用户的事件队列。<br>​      asyncFile阶段在其线程池中使用单个线程进行初始化。 SEDA线程池控制器负责根据观察到的并发需求动态调整线程池的大小。图8显示了在运行第5.1节中描述的基于SEDA的Web服务器期间工作的线程池控制器。运行分为三个阶段，每个阶段对应越来越多的客户;请注意，客户端负载是非常突发的。随着文件访问的突发到来，控制器将线程添加到每个阶段的线程池，直到最多20个线程饱和。在这之间，不需要I / O，并且线程池缩小。虽然PageCache和CacheMiss阶段需要更多线程且客户端负载增加，但服务文件I / O所需的线程数实际上会减少。这是因为底层文件系统缓冲区缓存正在预热，并且能够更快地为磁盘请求提供服务。线程池控制器推断出需要更少的线程来管理磁盘并发，并避免创建不需要的线程。</p><h2 id="应用和评估"><a href="#应用和评估" class="headerlink" title="应用和评估"></a>应用和评估</h2><p>​      在本节中，我们将介绍两个应用程序的性能和负载调节评估：Haboob，一个高性能的HTTP服务器; 和Gnutella对等文件共享网络的数据包路由器。 Haboob代表客户端发出请求并等待响应的“闭环”服务器，而Gnutella数据包路由器是一个“开环”服务器的例子，其中服务器性能不会成为提供负载的限制因素。</p><h3 id="Haboob：高性能HTTP服务器"><a href="#Haboob：高性能HTTP服务器" class="headerlink" title="Haboob：高性能HTTP服务器"></a>Haboob：高性能HTTP服务器</h3><p>​      Web服务器构成了可扩展的Internet服务的原型组件。许多先前的工作已经研究了构建高性能HTTP服务器的工程方面，但很少有关于负载调节，稳健性和易于构造的说法。研究HTTP服务器的一个好处是，存在各种行业标准的基准来衡量它们的性能。我们选择了SPECweb99基准套件[50]中的负载模型作为我们测量的基础，并进行了两项重要修改。首先，我们仅测量静态网页访问的性能（构成SPECweb99负载混合的70％）。其次，我们将网页文件集固定为3.31 GB的磁盘文件，对应于SPECweb99目标负载1000个连接。文件大小从102到921600字节，可以使用SPECweb99规定的基于Zipf的请求分发进行访问。更多细节可以在[50]中找到。</p><p> <strong>Haboob架构</strong></p><p>​      Haboob的整体结构如图5所示。服务器包含10个阶段，其中4个阶段专门用于异步套接字和磁盘I/O，如上一节所述。HttpParse阶段负责接受新的客户端连接和传入数据包的HTTP协议处理。 HttpRecv阶段接受HTTP连接并请求事件并将它们传递到PageCache阶段（如果它们代表磁盘文件）或直接生成响应（对于为收集服务器统计信息而生成的动态页面）。 PageCache实现了使用哈希表实现的内存中网页缓存。<br>​      Haboob的整体结构如图5所示。服务器包含10个阶段，其中4个阶段专门用于异步套接字和磁盘I/O，如上一节所述。HttpParse阶段负责接受新的客户端连接和传入数据包的HTTP协议处理。HttpRecv阶段接受HTTP连接并请求事件并将它们传递到PageCache阶段（如果它们代表磁盘文件）或直接生成响应（对于为收集服务器统计信息而生成的动态页面）。PageCache实现了一个使用由URL索引的哈希表实现的内存网页缓存，其中每个条目包含一个由HTTP头和Web页面有效负载组成的响应数据包。CacheMiss阶段负责处理页面缓存未命中，使用异步文件I/O层从磁盘读取所请求页面的内容。最后，HttpSend向客户端发送响应并处理连接管理和统计信息收集的某些方面。另一个阶段（图中未显示）从HTML模板生成动态Web页面，嵌入的代码用Python脚本语言编写[36]。此功能提供了通用的服务器端脚本，类似于Java Server Pages [26]。<br>​      页面缓存尝试将缓存大小保持在给定阈值以下（对于下面提供的测量，设置为204800 KB）。它积极地回收容量未命中的缓冲区，而不是允许旧的缓冲区被Java运行时垃圾收集; 我们发现这种方法可以产生明显的性能优势。缓存阶段使用特定于应用程序的事件调度来提高性能。特别是，它实现了最短连接优先（SCF）[15]调度，它重新排序请求流以在较长的缓存条目之前发送短缓存条目，并优先考虑缓存命中而不是未命中。由于SCF仅应用于批处理控制器提供的每组事件，因此跨请求的饥饿不是问题。<br>​      将Haboob构建为一组阶段极大地提高了设计的模块性，因为每个阶段都体现了一个强大的，可重复使用的软件组件，可以单独调节负载。 我们能够测试页面缓存的不同实现，而无需对其余代码进行任何修改; 运行时只是实例化一个不同的阶段来代替原始页面缓存。同样，另一位没有Haboob结构知识的开发人员能够花很少的工作将Haboob使用异步文件层替换为备用文件系统接口。不包括Sandstorm平台，Web服务器代码仅包含3283个非注释源语句，其中676个NCSS专用于HTTP协议处理库。</p><p><strong>基准配置</strong></p><p>​      为了进行比较，我们提供了来自流行的Apache [6] Web服务器（版本1.3.14，与Linux Red Hat 6.2系统一起提供）以及Rice大学的Flash [44] Web服务器的性能测量。Apache使用150个进程的固定大小的进程池; 每个进程一次管理一个连接，从磁盘读取文件数据并使用阻塞I/O操作以8 KB块的形式将其发送到客户端。Flash使用高效的事件驱动设计，单个进程处理大多数请求处理任务。一组帮助程序进程执行（阻止）磁盘I/O，路径名解析和其他操作。Flash静态页面缓存的最大大小设置为204800 KB，与Haboob中的大小相同。Apache和Flash都是用C实现的，而Haboob是用Java实现的。<br>​      以下所有测量均在服务器上运行，该服务器运行在具有2 GB RAM和Linux 2.2.14的4路SMP 500 MHz Pentium III系统上。IBM JDK v1.3.0用作Java平台。32台具有类似配置的机器用于生成负载，每台客户机使用多个线程来模拟许多实际客户机。所有机器都通过交换式千兆以太网互连。虽然这种配置不能模拟广域网效果，但我们感兴趣的是服务器在高负载下的性能和稳定性。<br>​      客户端负载生成器循环，不断请求网页（使用SPECweb99套件指定的分发），读取结果，并在请求下一页之前休眠20毫秒的固定时间。 为了更密切地模拟广域中客户端的连接行为，每个客户端在5个HTTP请求之后关闭TCP连接，并在继续之前重新建立连接。该值是根据[39]的HTTP流量观察结果选择的。所有基准测试均使用热文件系统和网页缓存运行。请注意，3.31 GB的文件集大小远远大于物理内存，Haboob和Flash的静态页面缓存仅设置为200 MB; 因此，这些测量包括大量的磁盘I/O.</p><p><strong>性能分析</strong></p><p>​      图12显示了Haboob与Apache和Flash在聚合吞吐量和响应时间方面的性能。还显示了每个客户完成的请求数量的the Jain fairness index(公平指数)[27]。</p><h3 id="Gnutella数据包路由器"><a href="#Gnutella数据包路由器" class="headerlink" title="Gnutella数据包路由器"></a>Gnutella数据包路由器</h3><p>​      我们选择实现Gnutella数据包路由器来演示SEDA在非传统互联网服务中的使用。Gnutella路由器代表了一种与HTTP服务器完全不同的服务方式：在对等文件共享网络中的参与者之间路由数据包。像Gnutella这样的服务的重要性日益增加，因为新的分布式应用程序的开发是为了利用广域内主机的良好连接性。对等模型已被多个分布式存储系统采用，如Freenet [14]，OceanStore [30]和Intermemory [13]。<br>​      Gnutella [19]允许用户搜索和下载来自其他Gnutella用户的文件。该协议完全去中心化的;运行Gnutella客户端的节点形成一个通过TCP/IP分层的adhoc多跳路由网络，节点通过将收到的消息转发给它们的相邻节点来进行通信。Gnutella节点倾向于同时连接到几个（通常是四个或更多）其他节点，并且网络上节点的初始发现是通过众所周知的主机完成的。Gnutella中有五种消息类型：ping用于发现网络上的其他节点; pong是对ping的回应; query用于搜索其他Gnutella主机服务的文件; queryhits是对查询的响应;和push用于允许客户端通过防火墙下载文件。数据包路由器负责向所有其他相邻接点广播接收到的ping和查询消息，并沿着相应的ping或查询消息的路径路由pong，queryhits和push消息。有关消息格式和路由协议的详细信息，请参见[19]。</p><p><strong>架构</strong></p><p>​      除了异步套接字I/O层之外，基于SEDA的Gnutella数据包路由器使用3个阶段实现。该代码由1294个非注释源语句组成，其中880个NCSS专门用于Gnutella协议处理。GnutellaServer阶段接受TCP连接并处理数据包，将数据包事件传递到GnutellaRouter阶段，该阶段执行路由表的实际数据包路由和维护。 GnutellaCatcher是用于连接Gnutella网络的助手阶段，它通过联系周所周知的站点（well-known site）来接收要连接的主机列表。除了由其他广域客户端建立的任何连接之外，它还尝试保持至少4个同时连接到网络的连接。加入“实时”Gnutella网络和路由数据包使我们能够在真实环境中测试SEDA，以及测量通过路由器的流量。在一个37小时的运行期间，路由器处理了2480万个数据包（平均每秒179个数据包），并从网络上的其他主机接收了72,396个连接，在任何给定时间平均有12个同时连接。路由器每秒能够支持超过20,000个数据包。</p><p> <strong>防止慢套接字</strong></p><p>​      我们原始的数据包路由器原型展示了一个有趣的内存泄漏：在通过网络正确路由数据包几个小时之后，服务器会在耗尽内存后崩溃。观察各个阶段队列长度使我们能够轻松地检测问题的根源：大量的传出数据包正在排队等待某些广域连接，导致队列长度（因此内存使用）变得无限制。我们测量了Gnutella消息的平均数据包大小约为32个字节;每秒仅115个数据包的数据包速率可以使28.8千比特的调制解调器链路饱和，这仍然是许多Gnutella软件用户常用的。在这种情况下，解决方案是对每个套接字的传出数据包队列施加一个阈值，并关闭超过其阈值的连接。此解决方案是可以接受的，因为Gnutella客户端会自动发现并连接到网络上的多个主机;跨网络节点的冗余意味着客户端不需要依赖于特定主机来保持连接到网络。</p><p><strong>负载调节行为</strong></p><p>​      为了评估SEDA资源控制器在负载调节中的使用，我们在Gnutella路由器中引入了一个故意的瓶颈，其中每个查询消息都会导致20 ms的服务延迟。这是通过让应用程序事件处理程序在收到查询数据包时休眠20毫秒来实现的。 我们实现了一个负载生成客户端，它连接到服务器并根据与实际Gnutella流量相近的分布生成数据包流。在我们的Gnutella流量模型中，查询消息构成了生成数据包的15％。使用单个线程执行数据包路由，很明显，随着流入服务器的数据包数量的增加，此延迟将导致其他消息的大量积压。<br>​      图14（a）显示了ping和查询数据包通过服务器的平均延迟，提供的负载从100到1000包/秒增加。客户端和服务器计算机使用与HTTP服务器基准测试中相同的配置。当提供的负载超过服务器的容量时，数据包延迟会急剧增加。在1000个数据包/秒的情况下，服务器崩溃（由于内存不足以缓冲传入的数据包），然后才能进行延迟测量。</p><p>​      此时，可以采用若干负载调节策略。一个简单的策略是对每个阶段的传入事件队列进行阈值处理，并在超过阈值时丢弃数据包。或者，可以使用类似于随机早期检测（RED）拥塞避免方案[17]中使用的方法，其中基于输入队列的长度概率地丢弃数据包。虽然这些策略会导致许多数据包在过载期间被丢弃，但由于Gnutella网络流量的有损性质，这可能是一种可接受的解决方案。另一种策略是允许所有数据包进入系统，但让应用程序事件处理程序过滤掉查询数据包（这是过载的来源）。另一个策略是利用asyncSocket输入速率控制器将进入的数据包速率限制在系统中。</p><p>​      另一种方法是利用SEDA的资源控制器自动克服瓶颈。 在这种方法中，线程池控制器在检测到需要额外的并发时将线程添加到GnutellaRouter阶段; 这种机制类似于基于集群的TACC [18]系统中的动态工作者分配。图14（b）显示了启用SEDA线程池控制器的Gnutella路由器的平均延迟。如图14（c）所示，2个线程被添加到GnutellaRouter线程池中，允许服务器处理增加的数据包负载，尽管存在瓶颈。这个数字与从Little的结果中获得的理论值相匹配：如果我们将阶段建模为具有n个线程的排队系统，平均数据包到达率为λ，查询数据包频率为p，查询服务延迟为L秒， 那么维持λ完成率所需的线程数是n =λpL=（1000）（0.15）（20 ms）= 3个线程。</p><h2 id="讨论和结论"><a href="#讨论和结论" class="headerlink" title="讨论和结论"></a>讨论和结论</h2><p>​      因特网服务引发了一系列新的系统设计要求，因为必须以强大，易于编程的方式提供大规模并发，以便优雅地处理负载的巨大变化。 SEDA是为该制度建立设计原则的一步。在本文中，我们介绍了SEDA设计和执行模型，介绍了由显式事件队列连接的阶段的概念。SEDA利用一组动态控制器来管理每个阶段的资源使用和调度; 我们已经描述了几个控制器，包括两个跨阶段的控制线程分配和一个阶段内部使用的批处理程度。我们还分析了两个高效的异步I/O组件，以及使用SEDA设计构建的两个应用程序，表明SEDA在负载下表现出良好的性能和稳健的行为。<br>​      SEDA模型在互联网服务设计领域开辟了新的问题。显式事件队列和动态资源控制器的使用提高了专门针对服务进行调整的新颖调度和资源管理算法的可能性。作为未来的工作，我们计划实施一个广义的流量控制方案，用于各阶段之间的通信; 在此方案中，每个事件都需要一定数量的信用才能排入目标阶段的事件队列。 通过为每个事件分配可变数量的信用，可以实现有趣的负载调节策略。<br>​      我们认为，测量和控制是繁忙的互联网服务中资源管理和过载保护的关键。这与基于资源遏制的长期存在的方法形成对比，后者为系统中的每个任务（例如进程，线程或服务器请求）分配固定资源，并努力控制每个任务消耗的资源。尽管这些技术在互联网服务中提供差异化服务方面已经取得了一些成功[57]，但是遏制通常要求对每项任务进行先验的资源分配，从而限制了适用的负载调节策略的范围。相反，我们认为动态资源控制，加上面对过载的特定应用适应，是接近负载调节的正确方法。<br>​      当控制被视为资源管理的基础时，会出现两个新的挑战。第一个是检测过载情况：许多变量会影响服务的交付性能，而确定服务实际上是过载的以及原因是一个有趣的问题。第二是确定适当的控制策略来抵抗过载。 我们计划对当前实施中的资源控制器进行多项改进，以及针对备用指标进行优化的新控制器。 例如，为了减少资源消耗，可能需要优先考虑释放资源而不是消耗资源的阶段。在SEDA下，控制系统的工作主体[43,45]可以用于服务资源管理，我们只是触及了这种技术潜力的表面。<br>​      关于事件驱动的并发模型的一个共同关注点是易于编程。现代语言和编程工具支持线程应用程序的开发和调试，许多开发人员认为事件驱动编程本质上更加困难。事实上，大多数事件驱动的服务器应用程序通常非常复杂，并且在设计上有点特别，这使得这种观点持续存在。根据我们的经验，SEDA模型中的编程比多线程应用程序设计和传统的事件驱动模型更容易。当线程被隔离到单个阶段时，线程同步和竞争条件等问题更易于管理。阶段之间面向消息的通信建立了明确的排序;在传统的事件驱动设计中，通过系统跟踪事件流程要困难得多。我们认为SEDA是线程和事件驱动设计之间的理想中间点，对编程模型的进一步探索是未来工作的重要方向。<br>​      虽然SEDA有助于在商品操作系统上构建条件良好的服务，但SEDA模型为操作系统设计提供了新的方向。我们设想一个直接支持SEDA执行模型的操作系统，并为应用程序提供对调度和资源使用的更大控制。这种方法类似于各种研究系统[5,11,28,34]中提供的方法，可以实现特定于应用程序的资源管理。更为根本的是，基于SEDA的操作系统无需设计为允许多个应用程序透明地共享资源。Internet服务是高度专业化的，并不是为了与其他应用程序共享机器而设计的：例如，Web服务器通常不希望与数据库引擎在同一台机器上运行（更不用说科学计算或文字处理器）。尽管操作系统可以实施保护（以防止一个阶段破坏内核状态或另一个阶段），但系统不需要以掩盖应用程序可用性的方式虚拟化资源。</p>]]></content>
    
    
    <summary type="html">SEDA论文翻译</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Cpp设计模式</title>
    <link href="https://penge666.github.io/posts/1155b381.html"/>
    <id>https://penge666.github.io/posts/1155b381.html</id>
    <published>2024-05-30T09:04:07.000Z</published>
    <updated>2024-05-30T09:04:55.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计模式：就是在解决某一类问题场景时，有既定的优秀的代码框架可以直接使用，有以下优点可取：</p><p>（1）代码更易于维护，代码的可读性、复用性、可移植性、健壮性更好。</p><p>（2）当软件原有需求有变更或者增加新的需求时，合理的设计模式的应用，能够做到软件设计要求的”开-闭原则”，即对修改关闭，对扩展开放，使软件原有功能修改，新功能扩充非常灵活。</p><p>（3）合理的设计模式的选择，会使软件设计更加模块化，积极的做到软件设计遵循的“高内聚，低耦合”这一根本原则。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式顾名思义，保证一个类仅可以有一个实例化对象，并且提供一个可以访问它的全局接口。这是一个创建性模式（主要是指对象的创建方式）。<strong>单例模式和多线程结合到是很紧密的。包括两种单例模式，以及线程安全的问题</strong>。</p><p><strong>应用</strong></p><p>第一种：日志模块</p><p>假如 这里有一个类，提供了很多方法来封装了一个日志模块。一个软件本身可能有很多的功能模块，那么这么多的模块都要通过日志模块进行写入一些软件运行的日志信息到磁盘内。应该是把这些所有的日志信息都给到一个日志模块的对象上。</p><p>第二种：数据库模块</p><p>作为一个个的数据库客户端，是要通过数据库模块与数据库服务器进行交互通信的。那么这个数据库client就可以设计成一个单例：应用软件的其他功能模块如果要与数据库服务器进行交互通信，可以调用一个数据库模块对象的某一个方法即可，不需要去创建那么多的对象。毕竟数据库的请求那么多，不可能做到 每一次处理请求都生成一个数据库对象，这样会导致数据库模块对象特别特别多和数据库的连接也特别的多，占用大量内存且非常麻烦。</p><p><strong>实现单例模式必须注意一下几点：</strong></p><p>（1）单例类只能有一个实例化对象。</p><p>（2）单例类必须自己提供一个实例化对象。</p><p>（3）单例类必须提供一个可以访问唯一实例化对象的接口。</p><p>（4）单例模式分为懒汉和饿汉两种实现方式。</p><p>单例：</p><p>饿汉式    对象在程序执行时优先创建【线程安全】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::instance;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton *p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// Singleton p = *p1;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &amp;p &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式： 对象的创建在第一次调用getInstance函数时创建【线程不安全】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton *instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton *Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton *p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// Singleton p = *p1;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &amp;p &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述懒汉式如何改成线程安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 锁加双重判断</span></span><br><span class="line">            <span class="built_in">unique_lock</span>&lt;mutex&gt;(mtx);</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton *instance;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton *Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton *p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// Singleton p = *p1;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &amp;p &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂和工厂方法"><a href="#简单工厂和工厂方法" class="headerlink" title="简单工厂和工厂方法"></a>简单工厂和工厂方法</h2><p>简单工厂：它不属于标准的OOP设计模式中，而后面两种是包含在标准的OOP的23种设计模式中的。</p><p><strong>为什么要工厂模式：主要是封装了对象的创建过程。</strong> 创建性模式本身就是体现了：对象的创建过程的封装和隐藏。没有工厂模式的封装就是：对象的new 和 new等。当代码里面出现很多的类，每次创建在对象的时候，都需要通过new 类名称的方式来生成对象。</p><p>先来看个代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="comment">//在构造函数的初始化列表里面给name初始化</span></span><br><span class="line"><span class="built_in">Car</span>(std::string name):_name(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个给派生类（具体的汽车）重写的接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span>:<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BMW</span> (std::string name):<span class="built_in">Car</span>(name)&#123;&#125;</span><br><span class="line"><span class="comment">//重写从基类基类继承过来的纯虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;宝马  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Audi</span>(std::string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line"><span class="comment">//重写从基类基类继承过来的纯虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;奥迪  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Car* p1 = <span class="keyword">new</span> <span class="built_in">BMW</span>(<span class="string">&quot;x1&quot;</span>);</span><br><span class="line">Car* p2 = <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的缺点在于：</span></span><br><span class="line"><span class="comment">1 需要记住派生类的名字，不然没法new对象</span></span><br><span class="line"><span class="comment">2 创建对象的时候，直接使用了对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其实我们不需要去了解对象创建的具体内容</span></span><br><span class="line"><span class="comment">只要给我汽车就OK了，劳资不需要去知道怎么造车的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>简单工厂</strong></p><p>解决办法为：把这些对象都给 封装到一个简单的工厂里面。如下：</p><p>通过下面这个简单的工厂把所有对象的创建给封装起来了，下面造汽车劳资不用管，我只是想要一辆车，通过传入不同的参数，得到不同的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在构造函数的初始化列表里面给name初始化</span></span><br><span class="line">    <span class="built_in">Car</span>(std::string name) : _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个给派生类（具体的汽车）重写的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bmw</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宝马  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Audi</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奥迪  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span></span><br><span class="line">&#123;</span><br><span class="line">    BMW,</span><br><span class="line">    AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(CarType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> BMW:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(<span class="string">&quot;x1&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> AUDI:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SimpleFactory *factory = <span class="keyword">new</span> <span class="built_in">SimpleFactory</span>();</span><br><span class="line">    Car *car1 = factory-&gt;<span class="built_in">createCar</span>(BMW);</span><br><span class="line">    Car *car2 = factory-&gt;<span class="built_in">createCar</span>(AUDI);</span><br><span class="line">    car1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    car2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> factory;</span><br><span class="line">    <span class="keyword">delete</span> car1;</span><br><span class="line">    <span class="keyword">delete</span> car2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用智能指针管理对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在构造函数的初始化列表里面给name初始化</span></span><br><span class="line">    <span class="built_in">Car</span>(std::string name) : _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个给派生类（具体的汽车）重写的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bmw</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宝马  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Audi</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奥迪  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span></span><br><span class="line">&#123;</span><br><span class="line">    BMW,</span><br><span class="line">    AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(CarType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> BMW:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(<span class="string">&quot;x1&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> AUDI:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SimpleFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpleFactory())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleFactory *factory = new SimpleFactory();</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">car1</span><span class="params">(factory-&gt;createCar(BMW))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">car2</span><span class="params">(factory-&gt;createCar(AUDI))</span></span>;</span><br><span class="line">    car1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    car2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂的缺点：</p><p>同一个工厂既建宝马，也整奥迪。不可能用一个工厂把所有对象的创建都封装起来。而且工厂里面的设计也不符合 <strong>开闭原则</strong>。</p><p><strong>开闭原则</strong></p><p>开闭原则是面向对象设计的一种重要原则，它的全称是“对扩展开放，对修改关闭”。这个原则的核心思想是，当应用的需求改变时，我们应该尽量通过添加新的代码进行扩展，而不是去修改已有的代码。</p><p>具体来说，开闭原则包含两个方面：</p><ul><li>对扩展开放：意味着我们应该设计出可以容易添加新功能的系统，只需要添加新的代码，而不需要修改原有的代码。</li><li>对修改关闭：意味着一旦我们完成了系统的设计和编码，应该尽量避免对已有的代码进行修改。因为修改已有的代码会带来很多风险，可能会引入新的错误。</li></ul><p>遵守开闭原则的好处是，可以使得系统更加稳定，更具有弹性，更容易进行维护和扩展。但同时，实现开闭原则也需要一定的设计和编码技巧，可能会增加系统的设计和实现的复杂性。</p><p>因此，需要根据上述根据<strong>对修改关闭，对扩展开放</strong>的原则进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在构造函数的初始化列表里面给name初始化</span></span><br><span class="line">    <span class="built_in">Car</span>(std::string name) : _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个给派生类（具体的汽车）重写的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bmw</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宝马  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Audi</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奥迪  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span></span><br><span class="line">&#123;</span><br><span class="line">    BMW,</span><br><span class="line">    AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car *<span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BmwFactoryMethod</span> : <span class="keyword">public</span> SimpleFactory</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AUDIFactoryMethod</span> : <span class="keyword">public</span> SimpleFactory</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SimpleFactory&gt; <span class="title">Afactory</span><span class="params">(<span class="keyword">new</span> AUDIFactoryMethod())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SimpleFactory&gt; <span class="title">Bfactory</span><span class="params">(<span class="keyword">new</span> BmwFactoryMethod())</span></span>;</span><br><span class="line">    <span class="comment">// SimpleFactory *factory = new SimpleFactory();</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">car1</span><span class="params">(Afactory-&gt;createCar(<span class="string">&quot;x1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">car2</span><span class="params">(Bfactory-&gt;createCar(<span class="string">&quot;A5&quot;</span>))</span></span>;</span><br><span class="line">    car1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    car2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把工厂划分为一个继承结构：封装了一个工厂方法（纯虚函数）。派生类代表具体的工厂，产生具体的产品。（相应的工厂创建相应的产品），达到了一个工厂其相应的产品。</p><p>这就是对已有的功能进行封闭。开闭原则：对修改关闭，对扩展开放 此时要是删除一种产品的工厂，直接删除相应的派生类即可（也不会改动其他的类）。在调用的时候，想要获取一个对象，只需要调用 工厂相应的工厂方法就可以了，不需要去了解派生类叫什么名字、也不需要知道对象是怎么创建的（这些细节由工厂进行维护）。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>简单工厂的缺点如下：</p><p>比如说是 一类有关联关系的产品：手机、手机上的耳机等。根据上面的工厂方法，创建耳机，也得整上一个相应的耳机工厂，这样做 就有些不太现实（具体的一个个工厂类就太多了）。也就是这些一系列有关联关系的产品 应该放在一个工厂进行创建的。 毕竟有关联关系的产品太多了，不可能各个产品都创建相对应的工厂（工厂类将会极为庞大）。</p><p><strong>解决方法：将工厂方法升级为抽象工厂。抽象工厂也是需要工厂方法的，抽象工厂：对一系列有关联关系的产品簇提供产品对象的统一创建。</strong></p><p>就可以把一组有关联关系的产品簇提供产品对象的统一创建 放到一个工厂里面做了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列产品1 汽车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在构造函数的初始化列表里面给name初始化</span></span><br><span class="line">    <span class="built_in">Car</span>(std::string name) : _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个给派生类（具体的汽车）重写的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bmw</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宝马  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Audi</span>(std::string name) : <span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奥迪  &quot;</span> &lt;&lt; _name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一系列产品2  车灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarLight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">light</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BmwLight</span> : <span class="keyword">public</span> CarLight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">light</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宝马车灯  &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiLight</span> : <span class="keyword">public</span> CarLight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写从基类基类继承过来的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">light</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奥迪车灯  &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工厂方法 升级为 抽象工厂</span></span><br><span class="line"><span class="comment">// 抽象工厂：对有一组关联关系的产品簇提供产品对象的统一创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 下面是工厂方法,提供多个产品创建的抽象接口</span></span><br><span class="line">    <span class="comment">// 车子产品方法 创建车子</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car *<span class="title">createOneCar</span><span class="params">(std::string)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 车灯产品方法 创建车灯</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CarLight *<span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面是宝马工厂，负责创建宝马系列的产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWAbstractFactory</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Car *<span class="title">createOneCar</span><span class="params">(std::string name)</span> <span class="comment">// 创建车子</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">CarLight *<span class="title">createCarLight</span><span class="params">()</span> <span class="comment">// 创建车灯</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BmwLight</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面是奥迪工厂，负责创建奥迪系列的产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AUDIAbstractFactory</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Car *<span class="title">createOneCar</span><span class="params">(std::string name)</span> <span class="comment">// 创建车子</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">CarLight *<span class="title">createCarLight</span><span class="params">()</span> <span class="comment">// 创建车灯</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudiLight</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里相较于简单工厂：使用一个工厂，通过传入不同的标识 来创建不同的对象</span></span><br><span class="line"><span class="comment">相当于给了一个工厂的基类，然后通过实现具体的产品的工厂。用这个具体产品的工厂</span></span><br><span class="line"><span class="comment">来创建具体的产品对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwAbstractFactory</span><span class="params">(<span class="keyword">new</span> BMWAbstractFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;AbstractFactory&gt; <span class="title">audiAbstractFactory</span><span class="params">(<span class="keyword">new</span> AUDIAbstractFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwAbstractFactory-&gt;createOneCar(<span class="string">&quot;x1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audiAbstractFactory-&gt;createOneCar(<span class="string">&quot;A5&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;CarLight&gt; <span class="title">p3</span><span class="params">(bmwAbstractFactory-&gt;createCarLight())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;CarLight&gt; <span class="title">p4</span><span class="params">(audiAbstractFactory-&gt;createCarLight())</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    p3-&gt;<span class="built_in">light</span>();</span><br><span class="line">    p4-&gt;<span class="built_in">light</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>结构型模式：（不是关注于对象的产生，关注于最后通过类与类的组合之后，功能上该怎么使用？以及对问题场景的符合与否？）</p><p> 这些设计模式关注于类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><p>代理模式：Proxy Pattern 。主要体现的是 对象访问权限的控制。这个Proxy代理可以把那些访问对象的权限不够的用户 都给挡回去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VedioWebSite</span> <span class="comment">// 抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">// 免费电影</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">// VIP电影</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// VIP + 券电影</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的 操作视频服务器后台的所有电影</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperatorMovieBoss</span> : <span class="keyword">public</span> VedioWebSite <span class="comment">// 这个是 委托类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> <span class="comment">// 免费电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你可以看免费电影&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> <span class="comment">// VIP电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你可以看VIP电影&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> <span class="comment">// VIP + 券电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你可以看VIP + 券电影&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代理OperatorMovieBoss的代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeMovieProxy</span> : <span class="keyword">public</span> VedioWebSite <span class="comment">// 免费电影代理类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreeMovieProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指针指向代理的对象</span></span><br><span class="line">        pvedio = <span class="keyword">new</span> <span class="built_in">OperatorMovieBoss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FreeMovieProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pvedio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通过代理对象的freeMovie来访问真正委托类对象的freeMovie方法</span></span><br><span class="line">        pvedio-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> <span class="comment">// VIP电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你只是普通用户，不可以看VIP电影,请升级为会员&quot;</span></span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> <span class="comment">// VIP + 券电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你没有电源券，不可以观看电影,请先升级为会员然后购买影券&quot;</span></span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这里需要一个组合的对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    基类指针指向派生类对象，只是这里不直接指向委托类对象</span></span><br><span class="line"><span class="comment">    而是直接访问代理对象，用代理对象来控制用户对委托类对象</span></span><br><span class="line"><span class="comment">    访问权限的问题。既然也是从抽象类继承来的，3个纯虚函数都要去</span></span><br><span class="line"><span class="comment">    重写一下。不然这个代理类也成了抽象类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VedioWebSite *pvedio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代理OperatorMovieBoss的代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VIPMovieProxy</span> : <span class="keyword">public</span> VedioWebSite <span class="comment">// VIP电影代理类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VIPMovieProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指针指向代理的对象</span></span><br><span class="line">        pvedio = <span class="keyword">new</span> <span class="built_in">OperatorMovieBoss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">VIPMovieProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pvedio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通过代理对象的freeMovie来访问真正委托类对象的freeMovie方法</span></span><br><span class="line">        pvedio-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> <span class="comment">// VIP电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pvedio-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> <span class="comment">// VIP + 券电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你没有电源券，不可以观看电影,请先购买影券&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这里需要一个组合的对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    基类指针指向派生类对象，只是这里不直接指向委托类对象</span></span><br><span class="line"><span class="comment">    而是直接访问代理对象，用代理对象来控制用户对委托类对象</span></span><br><span class="line"><span class="comment">    访问权限的问题。既然也是从抽象类继承来的，3个纯虚函数都要去</span></span><br><span class="line"><span class="comment">    重写一下。不然这个代理类也成了抽象类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VedioWebSite *pvedio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WhoWatchMovie</span><span class="params">(std::unique_ptr&lt;VedioWebSite&gt; &amp;ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基类指针 指向 普通用户级别的代理类</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;VedioWebSite&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> FreeMovieProxy())</span></span>;</span><br><span class="line">    <span class="built_in">WhoWatchMovie</span>(p1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*****************************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 基类指针 指向 VIP用户级别的代理类</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;VedioWebSite&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> VIPMovieProxy())</span></span>;</span><br><span class="line">    <span class="built_in">WhoWatchMovie</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<strong>代理模式涉及到了 抽象类（公共类），委托类（需要从抽象类继承而来），代理类（需要从抽象类继承而来），以组合的方式 使用代理对象，在实际的使用中客户直接访问的是代理对象。</strong></p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>结构型模式的一种：Decorator Pattern</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 装饰器模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="comment">// 抽象基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面是三个 汽车实体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是宝马汽车的配置为:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是奥迪汽车的配置为:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bnze</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是奔驰汽车的配置为:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*进行功能增强了，如下：*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBaseDecorator</span> : <span class="keyword">public</span> Car <span class="comment">// 装饰器的基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 装饰器里面，先把基本的功能装饰写好，给谁添加 先不重要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰器的基类，具体的功能装饰还没有出来呢</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实对于装饰器基类，如果要有一些装饰器公共的方法的话，</span></span><br><span class="line"><span class="comment">可以在装饰器的基类里面进行实现。</span></span><br><span class="line"><span class="comment">这里各个装饰器类没有一些公有的方法需要在统一地在基类书写的</span></span><br><span class="line"><span class="comment">情况下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例如这里 就没有公共的方法，这种情况下就可以把装饰器的</span></span><br><span class="line"><span class="comment">基类CarBaseDecorator给省略掉。直接让下面的CarChildDecorator们</span></span><br><span class="line"><span class="comment">直接继承于Car类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是我选择不省略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能装饰器1：定速巡航功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarChildDecorator1</span> : <span class="keyword">public</span> CarBaseDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CarChildDecorator1</span>(Car *p)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 定速巡航功能&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能装饰器2：自动驾驶功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarChildDecorator2</span> : <span class="keyword">public</span> CarBaseDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CarChildDecorator2</span>(Car *p)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 自动驾驶功能&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 功能装饰器3：车道偏离功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarChildDecorator3</span> : <span class="keyword">public</span> CarBaseDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CarChildDecorator3</span>(Car *p)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 车道偏离功能&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car *p1 = <span class="keyword">new</span> <span class="built_in">CarChildDecorator1</span>(<span class="keyword">new</span> <span class="built_in">Bmw</span>());</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="built_in">CarChildDecorator2</span>(p1);</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="built_in">CarChildDecorator3</span>(p1);</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Car *p2 = <span class="keyword">new</span> <span class="built_in">CarChildDecorator2</span>(<span class="keyword">new</span> <span class="built_in">Audi</span>());</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Car *p3 = <span class="keyword">new</span> <span class="built_in">CarChildDecorator3</span>(<span class="keyword">new</span> <span class="built_in">Bnze</span>());</span><br><span class="line">    p3-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从深入理解对象模型的角度看有点套娃的味了，应用了虚函数指针的运行时多态实现。</p><p>上述代码详细解释：</p><p>在这个代码中，我们使用了装饰器模式，也称为包装器模式。装饰器模式允许我们在运行时动态地添加行为或状态到现有的对象中，而不需要修改其原始类的源代码。</p><p>当我们执行 <code>p1-&gt;show();</code> 时，输出的结果是 “这是宝马汽车的配置为: 定速巡航功能 自动驾驶功能 车道偏离功能”，这是因为我们在创建 <code>p1</code> 时，逐步地向它添加了这些功能：</p><ol><li><code>Car *p1 = new CarChildDecorator1(new Bmw());</code> 在这一步，我们创建了一个 <code>Bmw</code> 对象，并将其作为参数传递给 <code>CarChildDecorator1</code> 的构造函数。这个操作把 “定速巡航功能” 添加到了 <code>Bmw</code> 对象中。</li><li><code>p1 = new CarChildDecorator2(p1);</code> 在这一步，我们创建了一个 <code>CarChildDecorator2</code> 对象，并将已经包含了 “定速巡航功能” 的 <code>p1</code> 作为参数传递给 <code>CarChildDecorator2</code> 的构造函数。这个操作把 “自动驾驶功能” 添加到了 <code>p1</code> 中。</li><li><code>p1 = new CarChildDecorator3(p1);</code> 在这一步，我们创建了一个 <code>CarChildDecorator3</code> 对象，并将已经包含了 “定速巡航功能” 和 “自动驾驶功能” 的 <code>p1</code> 作为参数传递给 <code>CarChildDecorator3</code> 的构造函数。这个操作把 “车道偏离功能” 添加到了 <code>p1</code> 中。</li></ol><p>因此，当我们调用 <code>p1-&gt;show();</code> 时，<code>p1</code> 中的每个装饰器都会调用其内部存储的 <code>Car</code> 对象的 <code>show</code> 方法，并在此基础上添加自己的功能描述，从而得到了 “这是宝马汽车的配置为: 定速巡航功能 自动驾驶功能 车道偏离功能” 这个结果。</p><p><strong>这就是装饰器模式的魅力，它允许我们动态地添加和组合功能，而不需要修改原始类的代码</strong>。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>这个适配器有点意思。</p><p>在项目中 使用到第三方的插件或者库，但是因为<strong>接口不兼容</strong> 就需要去添加很多的适配器类。</p><p>例如场景：电脑使用一个<strong>接口</strong>，把桌面演示投影到 投影仪上。</p><p>假如：现在有三种类型的接口：VGA HDMI TypeC 。但是目前电脑就用VGA，那么我们就需要用适配器将HDMI转成VGA的格式。把它想成显卡适配器就好理解了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 适配器模式：让不兼容的接口可以在一起工作</span></span><br><span class="line"><span class="comment">// 电脑 = 》   投影到 = 》   投影仪上   VGA  HDMI  TypeC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// VGA接口的电脑，(TV)投影仪也是VGA接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGA</span> <span class="comment">// VGA接口   抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TV01表示支持VGA接口的投影仪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV01</span> : <span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;通过VGA接口连接投影仪，进行视频播放&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个电脑类(只支持VGA接口)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 由于电脑只支持VGA接口，所以该方法的参数也只能支持VGA接口的指针/引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">(VGA *pVGA)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVGA-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法1：换一个支持HDMI接口的电脑，这个就叫代码重构</span></span><br><span class="line"><span class="comment">方法2：买一个转换头（适配器），能够把VGA信号转成HDMI信号，这个叫添加适配器类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进了一批新的投影仪，但是新的投影仪都是只支持HDMI接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HDMI</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV02</span> : <span class="keyword">public</span> HDMI</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;通过HDMI接口连接投影仪，进行视频播放&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于电脑（VGA接口）和投影仪（HDMI接口）无法直接相连，所以需要添加适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGAToHDMIAdapter</span> : <span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VGAToHDMIAdapter</span>(HDMI *p) : <span class="built_in">pHdmi</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span> <span class="comment">// 该方法相当于就是转换头，做不同接口的信号转换的</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pHdmi-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HDMI *pHdmi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Computer computer;</span><br><span class="line">    <span class="comment">// computer.playVideo(new TV01());</span></span><br><span class="line">    <span class="comment">// 不可以直接在里面传入TV02对象的指针，所以需要加上一层转换适配</span></span><br><span class="line">    <span class="comment">// 因为playVideo方法接收的还是VGA接口，而适配器也是从VGA 继承而来的</span></span><br><span class="line">    <span class="comment">// 适配器类的构造函数接收的是HDMI接口的对象指针 所以这里传入的是newTV02()对象指针</span></span><br><span class="line">    computer.<span class="built_in">playVideo</span>(<span class="keyword">new</span> <span class="built_in">VGAToHDMIAdapter</span>(<span class="keyword">new</span> <span class="built_in">TV02</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者-监听者模式（发布订阅模式），隶属于行为型模式。</p><p>行为型模式：主要关注的是对象之间的通信，例如：对象A调用对象B的成员方法等。</p><p>观察者-监听者模式：主要处理 对象的一对多的关系，也就是多个对象都依赖于一个对象。<strong>当该对象的状态发生改变时，其他对象都可以接受到相应的通知</strong>。假如现在一个类表示了一组数据，生成一个对象。通过这同一个数据对象， 可以得到一组 圆饼图、柱状图、条形图等。</p><p>简单解释：</p><p>这段代码实现的是发布-订阅模式，也称为观察者模式。这是一种在对象之间定义一对多的依赖关系，当一个对象状态改变时，所有依赖于它的对象都会受到通知并被自动更新。</p><p>在这个代码中，<code>Observer</code> 是观察者的抽象基类，<code>Observer1</code>、<code>Observer2</code> 和 <code>Observer3</code> 都是具体的观察者，他们分别对1、2、3号的消息感兴趣。<code>Subject</code> 是主题类，用来存储每个观察者对哪个消息感兴趣。</p><p>当一个消息发生改变时，主题类 <code>Subject</code> 会通过 <code>dispatch</code> 方法找到对这个消息感兴趣的所有观察者，然后调用它们的 <code>upData</code> 方法，通知它们消息已经发生改变。这就是观察者模式的核心。</p><p>例如，如果1号消息发生改变，主题类就会找到对1号消息感兴趣的 <code>Observer1</code> 和 <code>Observer2</code>，然后通知他们。如果2号消息发生改变，主题类就会找到对2号消息感兴趣的 <code>Observer1</code> 和 <code>Observer3</code>，然后通知他们。如果3号消息发生改变，主题类就会找到对3号消息感兴趣的 <code>Observer2</code> 和 <code>Observer3</code>，然后通知他们。</p><p>这种模式在很多实际应用中都非常有用，比如在GUI编程中，一个按钮的点击事件就可以看作是一个主题，而对这个点击事件感兴趣的所有监听器就是观察者。当用户点击按钮时，所有的监听器都会收到通知。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="comment">// 观察者接收到消息之后，就要去处理消息，更新图像</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> <span class="comment">// 观察者抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 统一的处理事件,messageid表示消息    回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">upData</span><span class="params">(<span class="type">int</span> messageid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下全部是观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upData</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;观察者1 对1 和 2号消息感兴趣.1号消息发生改变&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;观察者1 对1 和 2号消息感兴趣.2号消息发生改变&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upData</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;观察者2 对1 和 3号消息感兴趣.1号消息发生改变&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;观察者2 对1 和 3号消息感兴趣.3号消息发生改变&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer3</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upData</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;观察者3 对2 和 3号消息感兴趣.2号消息发生改变&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;观察者3 对2 和 3号消息感兴趣.3号消息发生改变&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题类</span></span><br><span class="line"><span class="comment">// 需要存储一下 每个Observer对哪个id感兴趣</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向list里面添加一个Observer 还有其感兴趣消息id</span></span><br><span class="line">    <span class="comment">// 给主题添加观察者对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer *obser, <span class="type">int</span> messageid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// mapping[messageid].push_back(obser);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        上面的这一句话</span></span><br><span class="line"><span class="comment">        map的【】运算符重载函数</span></span><br><span class="line"><span class="comment">        messageid存在 则返回键对应值的引用，插入到list。</span></span><br><span class="line"><span class="comment">        键不存在的话，则默认插入一对。（新增加一个messageid，其值为</span></span><br><span class="line"><span class="comment">        默认构造的list，把obser添加进去）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, list&lt;Observer *&gt;&gt;::iterator it = mapping.<span class="built_in">find</span>(messageid);</span><br><span class="line">        <span class="keyword">if</span> (it != mapping.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it-&gt;second.<span class="built_in">push_back</span>(obser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list&lt;Observer *&gt; mylist;</span><br><span class="line">            mylist.<span class="built_in">push_back</span>(obser);</span><br><span class="line">            mapping.<span class="built_in">insert</span>(&#123;messageid, mylist&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主题发生改变，给相应的观察者进行广播</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(<span class="type">int</span> messageid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 看看  谁对这个消息主题感兴趣</span></span><br><span class="line">        <span class="keyword">auto</span> it = mapping.<span class="built_in">find</span>(messageid);</span><br><span class="line">        <span class="keyword">if</span> (it != mapping.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有人对这个消息感兴趣，进行查看list 分发</span></span><br><span class="line">            <span class="keyword">for</span> (Observer *pObserver : it-&gt;second)</span><br><span class="line">            &#123;</span><br><span class="line">                pObserver-&gt;<span class="built_in">upData</span>(messageid); <span class="comment">// 最核心的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 消息id 具体感兴趣的Observer</span></span><br><span class="line">    <span class="comment">// 但是对于一个id的消息，可能有多个Observer</span></span><br><span class="line">    <span class="comment">// 所以 很多个观察者串成一个列表</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Observer *&gt;&gt; mapping;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject subject; <span class="comment">// 消息主题对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察者1 对1 和 2号消息感兴趣</span></span><br><span class="line">    subject.<span class="built_in">addObserver</span>(<span class="keyword">new</span> <span class="built_in">Observer1</span>(), <span class="number">1</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(<span class="keyword">new</span> <span class="built_in">Observer1</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察者2 对1 和 3号消息感兴趣</span></span><br><span class="line">    subject.<span class="built_in">addObserver</span>(<span class="keyword">new</span> <span class="built_in">Observer2</span>(), <span class="number">1</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(<span class="keyword">new</span> <span class="built_in">Observer2</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察者3 对2 和 3号消息感兴趣</span></span><br><span class="line">    subject.<span class="built_in">addObserver</span>(<span class="keyword">new</span> <span class="built_in">Observer3</span>(), <span class="number">2</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(<span class="keyword">new</span> <span class="built_in">Observer3</span>(), <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> changeMessid;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个发生改变的消息  输入-1结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;哪个消息改变了：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; changeMessid &amp;&amp; changeMessid != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subject.<span class="built_in">dispatch</span>(changeMessid);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;哪个消息改变了：&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习自：</p><ul><li><p><a href="https://refactoringguru.cn/design-patterns/proxy">https://refactoringguru.cn/design-patterns/proxy</a></p></li><li><p><a href="https://rng-songbaobao.blog.csdn.net/article/details/97764912">C++的学习心得和知识总结 第十三章（完）</a></p></li><li><a href="https://blog.csdn.net/weixin_45712636/article/details/124328504">C++设计模式（全23种）</a></li></ul>]]></content>
    
    
    <summary type="html">Cpp常用设计模式</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>云风coroutine协程库</title>
    <link href="https://penge666.github.io/posts/7dd61686.html"/>
    <id>https://penge666.github.io/posts/7dd61686.html</id>
    <published>2024-05-29T14:39:34.000Z</published>
    <updated>2024-05-30T01:53:12.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote><p><strong>库介绍</strong></p></blockquote><p>协程是一种共享堆，不共享栈，由用户主动调度的执行体（一般需要提供 yield 和 resume 语义）。</p><p>这个coroutine协程库实现是基于多个协程共享栈的方式。但是每个 coroutine 都会从 heap 上分配内存来保存自己 stack 的内容，当前运行实只有一个 stack。</p><p>随着 Golang 的兴起，协程尤其是有栈协程 (stackful coroutine) 越来越受到程序员的关注。协程几乎成了程序员的一套必备技能。</p><p>云风实现了一套 <a href="https://github.com/cloudwu/coroutine/">C 语言的协程库</a>，整体背景可以参考其 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html">博客</a>。</p><p>这个协程库非常轻量级，一共也才 200 多行代码，使用上更贴近于 lua 的写法（众所周知，云风是知名的 lua 粉)。整体基于 ucontext 和共享栈模型实现了有栈协程，代码质量毋庸置疑，本文将详细剖析该协程库的实现原理。</p><blockquote><p><strong>协程的几种实现方式及原理</strong></p></blockquote><p>协程又可以称为用户线程,微线程，可以将其理解为单个进程或线程中的多个<strong>用户态线程</strong>，这些微线程在用户态进程控制和调度.协程的实现方式有很多种，包括</p><ol><li>使用glibc中的ucontext库实现</li><li>利用汇编代码切换上下文</li><li>利用C语言语法中的switch-case的奇淫技巧实现(protothreads)</li><li>利用C语言的setjmp和longjmp实现</li></ol><p>实际上，无论是上述那种方式实现协程,其原理是相同的，都是通过保存和恢复寄存器的状态，来进行各协程上下文的保存和切换。</p><blockquote><p><strong>协程较于函数和线程的优点</strong></p></blockquote><ul><li>相比于函数:协程避免了传统的函数调用栈，几乎可以无限地递归</li><li>相比与线程:协程没有内核态的上下文切换，近乎可以无限并发。协程在用户态进程显式的调度，可以把异步操作转换为同步操作，也意味着不需要加锁,避免了加锁过程中不必要的开销。</li></ul><p>进程,线程以及协程的设计都是为了并发任务可以更好的利用CPU资源，他们之间最大的区别在于CPU资源的使用上:</p><ul><li>进程和线程的任务调度是由内核控制的，是抢占式的；</li><li>协程的任务调度是在用户态完成,需要代码里显式地将CPU交给其他协程,是协作式的</li></ul><p>由于我们可以在用户态调度协程任务，所以我们可以把<strong>一组相互依赖的任务设计为协程。这样,当一个协程任务完成之后,可以手动的进行任务切换，把当前任务挂起(yield),切换到另一个协程区工作</strong>.由于我们可以控制程序主动让出资源，很多情况下将不需要对资源进行加锁。</p><h2 id="前置知识">前置知识</h2><h3 id="ucontext-函数族">ucontext 函数族</h3><p>ucontext 函数有 4 个，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户上下文的获取和设置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操纵用户上下文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp, <span class="type">void</span> (*func)(<span class="type">void</span>), <span class="type">int</span> argc, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *oucp, <span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br></pre></td></tr></table></figure><p>ucontext 函数用户进程内部的 context 控制，帮助用户更方便实现 coroutine，可视为更先进的 setjmp/longjmp。</p><p>4 个函数都依赖于 <code>ucontext_t</code> 类型，这个类型大致为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">ucontext_t</span> *uc_link;</span><br><span class="line">    <span class="type">sigset_t</span>    uc_sigmask;</span><br><span class="line">    <span class="type">stack_t</span>     uc_stack;</span><br><span class="line">    <span class="type">mcontext_t</span>  uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>uc_link</code>：当前上下文结束时要恢复到的上下文，其中上下文由 <code>makecontext()</code> 创建；</li><li><code>uc_sigmask</code>：上下文要阻塞的信号集合；</li><li><code>uc_stack</code>：上下文所使用的 stack；</li><li><code>uc_mcontext</code>：其中 <code>mcontext_t</code></li></ul><p>类型与机器相关的类型。这个字段是机器特定的保护上下文的表示，包括协程的机器寄存器；</p><p>这几个 API 的作用：</p><p><code>getcontext(ucontext_t *ucp)</code></p><p>将当前的 context 保存在 <code>ucp</code> 中。成功返回 0，错误时返回 -1 并设置 errno；</p><p><code>setcontext(const ucontext_t *ucp)</code></p><p>恢复用户上下文为 <code>ucp</code> 所指向的上下文，成功调用<strong>不用返回</strong>。错误时返回 -1 并设置 errno。 <code>ucp</code> 所指向的上下文应该是 <code>getcontext()</code> 或者 <code>makecontext()</code> 产生。 如果上下文是由 <code>getcontext()</code> 产生，则切换到该上下文后，程序的执行在 <code>getcontext()</code> 后继续执行。比如下面这个例子每隔 1 秒将打印 1 个字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ucontext_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上下文是由 <code>makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)</code> 产生，切换到该上下文，程序的执行切换到 <code>makecontext()</code> 调用所指定的第二个参数的函数上。当函数返回后，如果 <code>ucp.uc_link</code> 为 NULL，则结束运行；反之跳转到对应的上下文。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ucontext_t</span> context;</span><br><span class="line">    <span class="type">char</span> stack[<span class="number">1024</span>];</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context);</span><br><span class="line">    context.uc_stack.ss_sp = stack;</span><br><span class="line">    context.uc_stack.ss_size = <span class="built_in">sizeof</span>(stack);</span><br><span class="line">    context.uc_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">makecontext</span>(&amp;context, foo, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出 <code>Hello world</code> 之后会执行 <code>foo()</code>，然后由于 <code>uc_link</code> 为 NULL，将结束运行。</p><p>下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bar\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ucontext_t</span> context1, context2;</span><br><span class="line">    <span class="type">char</span> stack1[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> stack2[<span class="number">1024</span>];</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context1);</span><br><span class="line">    context.uc_stack.ss_sp = stack1;</span><br><span class="line">    context.uc_stack.ss_size = <span class="built_in">sizeof</span>(stack1);</span><br><span class="line">    context.uc_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">makecontext</span>(&amp;context1, foo, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context2);</span><br><span class="line">    context.uc_stack.ss_sp = stack2;</span><br><span class="line">    context.uc_stack.ss_size = <span class="built_in">sizeof</span>(stack2);</span><br><span class="line">    context.uc_link = &amp;context1;</span><br><span class="line">    <span class="built_in">makecontext</span>(&amp;context1, bar, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;context2);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用 <code>makecontext()</code> 后将切换到 <code>context2</code> 执行 <code>bar()</code>，然后再调用 <code>context1</code> 的 <code>foo()</code>。由于 <code>context1</code> 的 <code>uc_link</code> 为 <code>NULL</code>，程序停止。</p><p><code>makecontext()</code></p><p>修改 <code>ucp</code> 所指向的上下文；</p><p><code>swapcontext(ucontext_t *oucp, const ucontext_t *ucp)</code></p><p>保存当前的上下文到 <code>ocup</code>，并且设置到 <code>ucp</code> 所指向的上下文。成功返回 0，失败返回 -1 并设置 errno。</p><p>如下面这个例子所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">ucontext_t</span> ctx[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">f1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start f1\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 将当前 context 保存到 ctx[1]，切换到 ctx[2]</span></span><br><span class="line">    <span class="built_in">swapcontext</span>(&amp;ctx[<span class="number">1</span>], &amp;ctx[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish f1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">f2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start f2\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 将当前 context 保存到 ctx[2]，切换到 ctx[1]</span></span><br><span class="line">    <span class="built_in">swapcontext</span>(&amp;ctx[<span class="number">2</span>], &amp;ctx[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish f2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> stack1[<span class="number">8192</span>];</span><br><span class="line">    <span class="type">char</span> stack2[<span class="number">8192</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;ctx[<span class="number">1</span>]);</span><br><span class="line">    ctx[<span class="number">1</span>].uc_stack.ss_sp = stack1;</span><br><span class="line">    ctx[<span class="number">1</span>].uc_stack.ss_size = <span class="built_in">sizeof</span>(stack1);</span><br><span class="line">    ctx[<span class="number">1</span>].uc_link = &amp;ctx[<span class="number">0</span>]; <span class="comment">// 将执行 return 0</span></span><br><span class="line">    <span class="built_in">makecontext</span>(&amp;ctx[<span class="number">1</span>], f1, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;ctx[<span class="number">2</span>]);</span><br><span class="line">    ctx[<span class="number">2</span>].uc_stack.ss_sp = stack2;</span><br><span class="line">    ctx[<span class="number">2</span>].uc_stack.ss_size = <span class="built_in">sizeof</span>(stack2);</span><br><span class="line">    ctx[<span class="number">2</span>].uc_link = &amp;ctx[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">makecontext</span>(&amp;ctx[<span class="number">2</span>], f2, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前 context 保存到 ctx[0]，切换到 ctx[2]</span></span><br><span class="line">    <span class="built_in">swapcontext</span>(&amp;ctx[<span class="number">0</span>], &amp;ctx[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p>此时将输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start f2</span><br><span class="line">start f1</span><br><span class="line">finish f2</span><br><span class="line">finish f1</span><br></pre></td></tr></table></figure><h3 id="无栈协程">无栈协程</h3><p>无栈协程，顾名思义，就是不需要使用栈的协程。在常规的协程或者线程中，我们通常会为每一个协程或线程分配一个栈。这个栈用于存储协程的执行状态，包括局部变量、函数调用关系等。当我们从一个协程切换到另一个协程时，我们会保存当前协程的栈信息，以便在切换回来时能够恢复到切换前的状态。</p><p>然而，在无栈协程中，我们并不为每个协程分配一个栈。相反，所有的协程共享全局的执行状态。这意味着，在无栈协程中，协程的执行状态不是保存在栈上，而是保存在堆上。换句话说，协程的栈帧内保存的不是状态，而是指向状态的指针。当我们需要切换协程时，我们只需要改变这些指针的指向，而不需要保存和恢复栈信息。</p><p>无栈协程的优点是节省了内存空间，因为我们不需要为每个协程分配一个栈。此外，因为不需要保存和恢复栈信息，所以无栈协程的切换速度更快。然而，无栈协程的缺点是编程模型更复杂，因为我们需要自己管理协程的执行状态。</p><p>总的来说，无栈协程是一种更轻量级的协程实现方式，它通过共享全局的执行状态，避免了栈的使用，从而实现了更快速的协程切换和更小的内存占用。</p><h2 id="coroutine-的使用">coroutine 的使用</h2><p>我们首先基于 coroutine 的例子来讲下 coroutine 的基本使用，以方便后面原理的讲解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">args</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">struct</span> schedule * S, <span class="type">void</span> *ud)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">args</span> * arg = ud;</span><br><span class="line"><span class="type">int</span> start = arg-&gt;n;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;coroutine %d : %d\n&quot;</span>,<span class="built_in">coroutine_running</span>(S) , start + i);</span><br><span class="line"><span class="comment">// 切出当前协程</span></span><br><span class="line"><span class="built_in">coroutine_yield</span>(S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="keyword">struct</span> schedule *S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">args</span> arg1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">args</span> arg2 = &#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个协程</span></span><br><span class="line"><span class="type">int</span> co1 = <span class="built_in">coroutine_new</span>(S, foo, &amp;arg1);</span><br><span class="line"><span class="type">int</span> co2 = <span class="built_in">coroutine_new</span>(S, foo, &amp;arg2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">coroutine_status</span>(S,co1) &amp;&amp; <span class="built_in">coroutine_status</span>(S,co2)) &#123;</span><br><span class="line"><span class="comment">// 使用协程 co1</span></span><br><span class="line"><span class="built_in">coroutine_resume</span>(S,co1);</span><br><span class="line"><span class="comment">// 使用协程 co2</span></span><br><span class="line"><span class="built_in">coroutine_resume</span>(S,co2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个协程调度器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">schedule</span> * S = <span class="built_in">coroutine_open</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>(S);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭协程调度器</span></span><br><span class="line"><span class="built_in">coroutine_close</span>(S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/coroutine$ ./main</span><br><span class="line">main start</span><br><span class="line">coroutine 0 : 0</span><br><span class="line">coroutine 1 : 100</span><br><span class="line">coroutine 0 : 1</span><br><span class="line">coroutine 1 : 101</span><br><span class="line">coroutine 0 : 2</span><br><span class="line">coroutine 1 : 102</span><br><span class="line">coroutine 0 : 3</span><br><span class="line">coroutine 1 : 103</span><br><span class="line">coroutine 0 : 4</span><br><span class="line">coroutine 1 : 104</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>从代码看来，首先利用 <code>coroutine_open</code> 创建了协程调度器 S，用来统一管理全部的协程。<br>同时在 test 函数中，创建了两个协程 co1 和 co2，不断的反复 yield 和 resume 协程，直至两个协程执行完毕。</p><p>可以看出，最核心的几个对象和函数是:</p><ol><li><code>struct schedule* S</code> 协程调度器</li><li><code>coroutine_resume(S,co1);</code> 切入该协程</li><li><code>coroutine_yield(S);</code> 切出该协程</li></ol><p>接下来，会从这几点出发，分析 coroutine 的原理。</p><h2 id="struct-schedule-协程调度器">struct schedule 协程调度器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 协程调度器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">schedule</span> &#123;</span><br><span class="line"><span class="type">char</span> stack[STACK_SIZE];<span class="comment">// 运行时栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">ucontext_t</span> main; <span class="comment">// 主协程的上下文</span></span><br><span class="line"><span class="type">int</span> nco; <span class="comment">// 当前存活的协程个数</span></span><br><span class="line"><span class="type">int</span> cap; <span class="comment">// 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行扩容</span></span><br><span class="line"><span class="type">int</span> running; <span class="comment">// 正在运行的协程ID</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> **co; <span class="comment">// 一个一维数组，用于存放协程 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>协程调度器 schedule 负责管理所有协程，有几个属性非常重要：</p><ol><li><code>struct coroutine **co;</code> 是一个一维数组，存放了目前所有的协程。</li><li><code>ucontext_t main;</code> 主协程的上下文，方便后面协程执行完后切回到主协程。</li><li><code>char stack[STACK_SIZE];</code> 这个非常重要，是所有协程的运行时栈。具体共享栈的原理会在下文讲到。</li></ol><p>此外，<code>coroutine_open</code> 负责创建并初始化一个协程调度器，<code>coroutine_close</code> 负责销毁协程调度器以及清理其管理的所有协程。</p><h2 id="协程的创建-coroutine-new">协程的创建: coroutine_new</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 协程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> &#123;</span><br><span class="line">coroutine_func func; <span class="comment">// 协程所用的函数</span></span><br><span class="line"><span class="type">void</span> *ud;  <span class="comment">// 协程参数</span></span><br><span class="line"><span class="type">ucontext_t</span> ctx; <span class="comment">// 协程上下文</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">schedule</span> * sch; <span class="comment">// 该协程所属的调度器</span></span><br><span class="line"><span class="type">ptrdiff_t</span> cap;  <span class="comment">// 已经分配的内存大小</span></span><br><span class="line"><span class="type">ptrdiff_t</span> size; <span class="comment">// 当前协程运行时栈，保存起来后的大小</span></span><br><span class="line"><span class="type">int</span> status;<span class="comment">// 协程当前的状态</span></span><br><span class="line"><span class="type">char</span> *stack; <span class="comment">// 当前协程的保存起来的运行时栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建协程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">coroutine_new</span><span class="params">(<span class="keyword">struct</span> schedule *S, coroutine_func func, <span class="type">void</span> *ud)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> *co = _co_new(S, func , ud);</span><br><span class="line"><span class="keyword">if</span> (S-&gt;nco &gt;= S-&gt;cap) &#123;</span><br><span class="line"><span class="comment">// 如果目前协程的数量已经大于调度器的容量，那么进行扩容</span></span><br><span class="line"><span class="type">int</span> id = S-&gt;cap;<span class="comment">// 新的协程的id直接为当前容量的大小</span></span><br><span class="line"><span class="comment">// 扩容的方式为，扩大为当前容量的2倍，这种方式和Hashmap的扩容略像</span></span><br><span class="line">S-&gt;co = <span class="built_in">realloc</span>(S-&gt;co, S-&gt;cap * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> coroutine *));</span><br><span class="line"><span class="comment">// 初始化内存</span></span><br><span class="line"><span class="built_in">memset</span>(S-&gt;co + S-&gt;cap , <span class="number">0</span> , <span class="built_in">sizeof</span>(<span class="keyword">struct</span> coroutine *) * S-&gt;cap);</span><br><span class="line"><span class="comment">//将协程放入调度器</span></span><br><span class="line">S-&gt;co[S-&gt;cap] = co;</span><br><span class="line"><span class="comment">// 将容量扩大为两倍</span></span><br><span class="line">S-&gt;cap *= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 尚未结束运行的协程的个数 </span></span><br><span class="line">++S-&gt;nco; </span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果目前协程的数量小于调度器的容量，则取一个为NULL的位置，放入新的协程</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;S-&gt;cap;i++) &#123;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 为什么不 i%S-&gt;cap,而是要从nco+i开始呢 </span></span><br><span class="line"><span class="comment"> * 这其实也算是一种优化策略吧，因为前nco有很大概率都非NULL的，直接跳过去更好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> id = (i+S-&gt;nco) % S-&gt;cap;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;co[id] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">S-&gt;co[id] = co;</span><br><span class="line">++S-&gt;nco;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>coroutine_new</code> 负责创建并初始化一个新协程对象，同时将该协程对象放到协程调度器里面。</p><p>这里的实现有两个非常有意思的点：</p><ol><li><strong>扩容</strong>：当目前尚存活的线程个数 <code>nco</code> 已经等于协程调度器的容量 <code>cap</code> 了，这个时候需要对协程调度器进行扩容，这里直接就是非常经典简单的 2 倍扩容。</li><li><strong>如果无需扩容，则需要找到一个空的位置，放置初始化好的协程</strong>。这里一般直接从数组第一位开始找，直到找到空的位置即可。但是云风把这里处理成从第 <code>nco</code> 位开始寻找（<code>nco</code> 代表当前存活的个数。因为一般来说，前面几位最开始都是存活的，从第 <code>nco</code> 位开始找，效率会更高。</li></ol><p>这样，一个协程对象就被创建好，此时该协程的状态是 <code>READY</code>，但尚未正式执行。</p><p><code>coroutine_resume</code> 函数会切入到指定协程中执行。当前正在执行的协程的上下文会被保存起来，同时上下文替换成新的协程，该协程的状态将被置为 <code>RUNNING</code>。</p><p>进入 <code>coroutine_resume</code> 函数的前置状态有两个 <code>READY</code> 和 <code>SUSPEND</code>，这两个状态下 <code>coroutine_resume</code> 的处理方法也是有很大不同。我们先看下协程在 READY 状态下进行 <code>coroutine_resume</code> 的流程。</p><h2 id="coroutine-resume-READY-RUNNING）">coroutine_resume(READY -&gt; RUNNING）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 切换到对应协程中执行</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param S 协程调度器</span></span><br><span class="line"><span class="comment">* @param id 协程ID</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">coroutine_resume</span><span class="params">(<span class="keyword">struct</span> schedule * S, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(S-&gt;running == <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">assert</span>(id &gt;=<span class="number">0</span> &amp;&amp; id &lt; S-&gt;cap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出协程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> *C = S-&gt;co[id];</span><br><span class="line"><span class="keyword">if</span> (C == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> status = C-&gt;status;</span><br><span class="line"><span class="keyword">switch</span>(status) &#123;</span><br><span class="line"><span class="keyword">case</span> COROUTINE_READY:</span><br><span class="line">    <span class="comment">//初始化ucontext_t结构体,将当前的上下文放到C-&gt;ctx里面</span></span><br><span class="line"><span class="built_in">getcontext</span>(&amp;C-&gt;ctx);</span><br><span class="line"><span class="comment">// 将当前协程的运行时栈的栈顶设置为S-&gt;stack</span></span><br><span class="line"><span class="comment">// 每个协程都这么设置，这就是所谓的共享栈。（注意，这里是栈顶）</span></span><br><span class="line">C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack; </span><br><span class="line">C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;</span><br><span class="line">C-&gt;ctx.uc_link = &amp;S-&gt;main; <span class="comment">// 如果协程执行完，将切换到主协程中执行</span></span><br><span class="line">S-&gt;running = id;</span><br><span class="line">C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置执行C-&gt;ctx函数, 并将S作为参数传进去</span></span><br><span class="line"><span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>)S;</span><br><span class="line"><span class="built_in">makecontext</span>(&amp;C-&gt;ctx, (<span class="built_in">void</span> (*)(<span class="type">void</span>)) mainfunc, <span class="number">2</span>, (<span class="type">uint32_t</span>)ptr, (<span class="type">uint32_t</span>)(ptr&gt;&gt;<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前的上下文放入S-&gt;main中，并将C-&gt;ctx的上下文替换到当前上下文</span></span><br><span class="line"><span class="built_in">swapcontext</span>(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> COROUTINE_SUSPEND:</span><br><span class="line">    <span class="comment">// 将协程所保存的栈的内容，拷贝到当前运行时栈中</span></span><br><span class="line"><span class="comment">// 其中C-&gt;size在yield时有保存</span></span><br><span class="line">        <span class="comment">// 这块这里先不看</span></span><br><span class="line"><span class="built_in">memcpy</span>(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);</span><br><span class="line">S-&gt;running = id;</span><br><span class="line">C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line"><span class="built_in">swapcontext</span>(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数非常的重要，有几个不可忽视的点：</p><ol><li><code>getcontext(&amp;C-&gt;ctx);</code> 初始化 ucontext_t 结构体，将当前的上下文放到 C-&gt;ctx 里面</li><li><code>C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack;</code> 设置当前协程的运行时栈，也是共享栈。</li><li><code>C-&gt;ctx.uc_link = &amp;S-&gt;main;</code> 如果协程执行完，则切换到 <code>S-&gt;main</code> 主协程中进行执行。如果不设置, 则默认为 NULL，那么协程执行完，整个程序就结束了。</li></ol><p>接下来是 makecontext，这个函数用来设置对应 ucontext 的执行函数。如上，将 <code>C-&gt;ctx</code> 的执行函数体设置为了 mainfunc。</p><p>makecontext 后面的两个参数也非常有意思，这个可以看出来是把一个指针掰成了两个 int 作为参数传给 mainfunc 了。而在 mainfunc 的实现可以看出来，又会把这两个 int 拼成了一个 <code>struct schedule*</code>。</p><p>那么，为什么不直接传 <code>struct schedule*</code> 呢，而要这么做，通过先拆两半，再在函数中拼起来？</p><p>这是因为 makecontext 的函数指针的参数是 <code>uint32_t</code> 类型，在 64 位系统下，一个 <code>uint32_t</code> 没法承载一个指针, 所以基于兼容性的考虑，才采用了这种做法。</p><p>接下来调用了 <code>swapcontext</code> 函数，这个函数比较简单，但也非常核心。作用是将当前的上下文内容放入 <code>S-&gt;main</code> 中，并将 <code>C-&gt;ctx</code> 的上下文替换到当前上下文。这样的话，将会执行新的上下文对应的程序了。在 coroutine 中, 也就是开始执行 <code>mainfunc</code> 这个函数。(<code>mainfunc</code> 是对用户提供的协程函数的封装)。</p><p><strong>mainfunc</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过low32和hi32 拼出了struct schedule的指针，这里为什么要用这种方式，而不是直接传struct schedule*呢？</span></span><br><span class="line"><span class="comment"> * 因为makecontext的函数指针的参数是int可变列表，在64位下，一个int没法承载一个指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mainfunc</span><span class="params">(<span class="type">uint32_t</span> low32, <span class="type">uint32_t</span> hi32)</span> </span>&#123;</span><br><span class="line"><span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>)low32 | ((<span class="type">uintptr_t</span>)hi32 &lt;&lt; <span class="number">32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">schedule</span> *S = (<span class="keyword">struct</span> schedule *)ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id = S-&gt;running;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> *C = S-&gt;co[id];</span><br><span class="line">C-&gt;<span class="built_in">func</span>(S,C-&gt;ud);<span class="comment">// 中间有可能会有不断的yield</span></span><br><span class="line">_co_delete(C);</span><br><span class="line">S-&gt;co[id] = <span class="literal">NULL</span>;</span><br><span class="line">--S-&gt;nco;</span><br><span class="line">S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程的切出：coroutine-yield">协程的切出：coroutine_yield</h2><p>用 <code>coroutine_yield</code> 可以使当前正在运行的协程切换到主协程中运行。此时，该协程会进入 <code>SUSPEND</code> 状态</p><p><code>coroutine_yield</code> 的具体实现依赖于两个行为：</p><ol><li>调用 <code>_save_stack</code> 将当前协程的栈保存起来。因为 coroutine 是基于共享栈的，所以协程的栈内容需要单独保存起来。</li><li><code>swapcontext</code> 将当前上下文保存到当前协程的 ucontext 里面，同时替换当前上下文为主协程的上下文。 这样的话，当前协程会被挂起，主协程会被继续执行。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将当前正在运行的协程让出，切换到主协程上</span></span><br><span class="line"><span class="comment">* @param S 协程调度器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">coroutine_yield</span><span class="params">(<span class="keyword">struct</span> schedule * S)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 取出当前正在运行的协程</span></span><br><span class="line"><span class="type">int</span> id = S-&gt;running;</span><br><span class="line"><span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> * C = S-&gt;co[id];</span><br><span class="line"><span class="built_in">assert</span>((<span class="type">char</span> *)&amp;C &gt; S-&gt;stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前运行的协程的栈内容保存起来</span></span><br><span class="line">_save_stack(C,S-&gt;stack + STACK_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前栈的状态改为 挂起</span></span><br><span class="line">C-&gt;status = COROUTINE_SUSPEND;</span><br><span class="line">S-&gt;running = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以这里可以看到，只能从协程切换到主协程中</span></span><br><span class="line"><span class="built_in">swapcontext</span>(&amp;C-&gt;ctx , &amp;S-&gt;main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也有个点极其关键, 就是如何保存当前协程的运行时栈, 也就是如何获取整个栈的内存空间。</p><p>这里我们需要了解下栈内存空间的布局，即栈的生长方向是从高地址往低地址。我们只要找到栈的栈顶和栈底的地址，就可以找到整个栈内存空间了。</p><p>在 coroutine 中，因为协程的运行时栈的内存空间是自己分配的。在 coroutine_resume 阶段设置了 <code>C-&gt;ctx.uc_stack.ss_sp = S.S-&gt;stack</code>。根据以上理论，栈的生长方向是高地址到低地址，因此栈底的就是内存地址最大的位置，即 <code>S-&gt;stack + STACK_SIZE</code> 就是栈底位置。</p><p>那么，如何找到栈顶的位置呢？coroutine 是基于以下方法做的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将本协程的栈内容保存起来</span></span><br><span class="line"><span class="comment">* @top 栈顶 </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_save_stack(<span class="keyword">struct</span> coroutine *C, <span class="type">char</span> *top) &#123;</span><br><span class="line">    <span class="comment">// 这个dummy很关键，是求取整个栈的关键</span></span><br><span class="line">    <span class="comment">// dummy变量在栈上分配，其地址即为当前栈顶地址</span></span><br><span class="line">    <span class="type">char</span> dummy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前协程的栈大小是否超过了最大栈大小</span></span><br><span class="line">    <span class="comment">// 如果超过，程序将终止运行</span></span><br><span class="line">    <span class="built_in">assert</span>(top - &amp;dummy &lt;= STACK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前协程的栈容量不足以保存所有的栈内容</span></span><br><span class="line">    <span class="comment">// 那么就需要重新分配一个更大的栈空间</span></span><br><span class="line">    <span class="keyword">if</span> (C-&gt;cap &lt; top - &amp;dummy) &#123;</span><br><span class="line">        <span class="comment">// 释放原来的栈空间</span></span><br><span class="line">        <span class="built_in">free</span>(C-&gt;stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算新的栈容量</span></span><br><span class="line">        C-&gt;cap = top - &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配新的栈空间</span></span><br><span class="line">        C-&gt;stack = <span class="built_in">malloc</span>(C-&gt;cap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前协程的栈大小</span></span><br><span class="line">    C-&gt;size = top - &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前协程的栈内容复制到新的栈空间中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(C-&gt;stack, &amp;dummy, C-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里特意用到了一个 dummy 变量，这个 dummy 的作用非常关键也非常巧妙，大家可以细细体会下。因为 dummy 变量是刚刚分配到栈上的，此时就位于 <strong>栈的最顶部位置</strong>。整个内存布局如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240529225723491.png" alt="image-20240529225723491"></p><p>因此整个栈的大小就是从栈底到栈顶，<code>S-&gt;stack + STACK_SIZE - &amp;dummy</code>。</p><p>最后又调用了 memcpy 将当前运行时栈的内容，拷贝到了 <code>C-&gt;stack</code> 中保存了起来。</p><h2 id="coroutine-resume-SUSPEND-RUNNING）">coroutine_resume(SUSPEND -&gt; RUNNING）</h2><p>当协程被 yield 之后会进入 <code>SUSPEND</code> 阶段，对该协程调用 <code>coroutine_resume</code> 会再次切入该协程。</p><p>这里的实现有两个重要的点：</p><ol><li><code>memcpy(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);</code><br>我们知道，在 yield 的时候，协程的栈内容保存到了 C-&gt;stack 数组中。<br>这个时候，就是用 memcpy 把协程的之前保存的栈内容，重新拷贝到运行时栈里面。这里有个点，拷贝的开始位置，需要简单计算下<br><code>S-&gt;stack + STACK_SIZE - C-&gt;size</code> 这个位置就是之前协程的栈顶位置。</li><li><code>swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</code> 交换上下文。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 切换到对应协程中执行</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param S 协程调度器</span></span><br><span class="line"><span class="comment">* @param id 协程ID</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">coroutine_resume</span><span class="params">(<span class="keyword">struct</span> schedule * S, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(S-&gt;running == <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">assert</span>(id &gt;=<span class="number">0</span> &amp;&amp; id &lt; S-&gt;cap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出协程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> *C = S-&gt;co[id];</span><br><span class="line"><span class="keyword">if</span> (C == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> status = C-&gt;status;</span><br><span class="line"><span class="keyword">switch</span>(status) &#123;</span><br><span class="line"><span class="keyword">case</span> COROUTINE_READY:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> COROUTINE_SUSPEND:</span><br><span class="line">    <span class="comment">// 将协程所保存的栈的内容，拷贝到当前运行时栈中</span></span><br><span class="line"><span class="comment">// 其中C-&gt;size在yield时有保存</span></span><br><span class="line"><span class="built_in">memcpy</span>(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);</span><br><span class="line">S-&gt;running = id;</span><br><span class="line">C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line"><span class="built_in">swapcontext</span>(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态机转换">状态机转换</h2><p>在 coroutine 中协程定义了四种状态，整个运行期间，也是根据这四种状态进行轮转。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240529225836906.png" alt=""></p><p>简单点说，就是每个协程的调用信息保存在堆内，然后共享一个栈进行运行。</p><p>有个疑问： 为什么要有这个S-&gt;stack结构？</p><p><code>context.uc_stack.ss_sp = stack;</code> 这行代码是设置协程的栈的起始位置为 <code>stack</code>，也就是 <code>stack</code> 数组的起始地址。这个 <code>stack</code> 数组就是协程的运行时栈，协程可以在这个栈上存储自己的局部变量和函数调用关系。</p><p>我的理解是专门指定一个空间，让其将上下文的信息放进去。</p><p>强烈推荐这篇：<a href="https://www.cyhone.com/articles/analysis-of-libco/">微信 libco 协程库源码分析</a></p><p>本文学习自：<a href="https://chenyahui.github.io/articles/analysis-of-cloudwu-coroutine/">云风 coroutine 协程库源码分析</a></p>]]></content>
    
    
    <summary type="html">云风coroutine协程库源码剖析</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>分布式基础理论</title>
    <link href="https://penge666.github.io/posts/76302eca.html"/>
    <id>https://penge666.github.io/posts/76302eca.html</id>
    <published>2024-05-28T08:28:59.000Z</published>
    <updated>2024-05-28T08:29:31.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拜占庭将军问题">拜占庭将军问题</h2><h3 id="简介">简介</h3><p>拜占庭错误是莱斯利·兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了一个完全不可信的场景，除了存在故障行为，还存在恶意行为。顾名思义，<strong>拜占庭容错（Byzantine Fault Tolerance，BFT），就是指能容忍拜占庭错误了</strong>。莱斯利·兰伯特（ Leslie Lamport ）通过这个比喻，表达了计算机网络中所存在的一致性问题。</p><p><strong>非拜占庭容错，又叫故障容错（Crash Fault Tolerance，CFT），解决的是分布式系统中存在故障，但不存在恶意节点的共识问题</strong>，比如进程奔溃，服务器硬件故障等等。</p><h3 id="问题描述">问题描述</h3><p><strong>共识问题</strong></p><p>共识难题，也就是如何在可能有误导信息的情况下，采用合适的通讯机制，让多个将军达成共识，制定一致性的作战计划？</p><p>李牧作为合纵长，燕，齐，韩三国合纵想要攻打秦国，但是只有3国出半数以上的将军才能打赢秦国。</p><p>共识在这里表示的就是三国将军都收到准确的消息，达成一致性决定在某个时间攻打。一般情况下，每国投票，最后少数服从多数即可达成一致决定，例如：</p><p>燕，齐将军决定要打秦国</p><p>韩国将军想撤退</p><p><strong>按照少数服从多数的原则</strong>，韩国将军也会出兵攻打秦国。</p><p><strong>两忠一叛</strong></p><p>可以看到，在正常情况下，信息一致，是能够形成共识的。但是，只要一旦燕，齐国将军有其中一国通秦，就会形成作战计划不一致的问题。例如燕国将军通秦，燕国将军向韩国将军发攻打，给齐国将军发送撤退：</p><ul><li>韩国将军收到的信息就是，2攻打：1撤退</li><li>齐国将军看到的信息就是，1攻打：2撤退</li></ul><p>按照少数服从多数的原则，最终就是韩国将军自己面对秦国，最后败于秦国。这里的问题就出在，其中里面有一国出了叛徒，导致发送了错误的信息。</p><h3 id="解决方案">解决方案</h3><p><strong>口信消息型拜占庭问题之解</strong></p><p>首先，3位将军都分拨一部分军队，由李牧率领，李牧参与作战计划讨论并执行作战指令。这样，3 位将军的作战讨论，就变为了 4位将军的作战讨论，这能够增加讨论中忠诚国家的数量。</p><p>然后，4 位将军还约定了，如果没有收到命令，就执行预设的默认命令，比如“撤退”。除此之外，还约定一些流程来发送作战信息、执行作战指令。</p><p><strong>第一轮</strong></p><p>先发送作战信息的将军作为指挥官，其他的将军作为副官；指挥官将他的作战信息发送给每位副官；每位副官，将从指挥官处收到的作战信息，作为他的作战指令；如果没有收到作战信息，将把默认的“撤退”作为作战指令。</p><p><strong>第二轮</strong></p><p>除了第一轮的指挥官外，剩余的 3 位将军将分别作为指挥官，向另外 2 位将军发送作战信息；然后，这 3 位将军按照“少数服从多数”，执行收到的作战指令。</p><p><strong>忠诚将军先发起命令</strong></p><p>假设先由李牧向3个将军发起进攻的命令，在第一轮作战信息协商中，李牧向燕、齐、韩发送作战指令“进攻”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528153829489.png" alt="image-20240528153829489"></p><p>在第二轮作战信息协商中，燕、齐、韩分别作为指挥官，向另外 2 位发送作战信息“进攻”，因为韩国将军已经通敌了，所以，为了干扰作战计划，韩国将军发送“撤退”作战指令。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528153851640.png" alt="image-20240528153851640"></p><p>最终，齐和燕收到的作战信息都是“进攻、进攻、撤退”，按照原则，齐和燕与李牧一起执行作战指令“进攻”，实现了作战计划的一致性，保证了作战的胜利。</p><p><strong>通敌国先发送作战命令</strong></p><p>假设先由韩过将军向3个将军发起进攻的命令，在第一轮作战信息协商中，韩国将军向李牧、燕发送作战指令“撤退”，向齐国将军发送作战指令&quot;进攻&quot;。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528154005852.png" alt="image-20240528154005852"></p><p>然后，在第二轮作战信息协商中，李牧、赵、燕分别作为指挥官，向另外两位发送作战信息。.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528154020184.png" alt="image-20240528154020184"></p><p>最终，李牧、燕和齐收到的作战信息都是“撤退、撤退、进攻”，按照原则，李牧、齐和燕一起执行作战指令“撤退”，实现了作战计划的一致性。也就是说，无论叛将楚如何捣乱，李牧、齐和燕，都执行一致的作战计划，保证作战的胜利。</p><p>这个解决办法，其实是兰伯特在论文《The Byzantine Generals Problem》中提到的口信消息型拜占庭问题之解：如果叛将人数为 m，将军人数不能少于 3m + 1 ，那么拜占庭将军问题就能解决了。</p><p>这个算法有个前提，也就是叛将人数 m，或者说能容忍的叛将数 m，是已知的。在这个算法中，叛将数 m 决定递归循环的次数（也就是说，叛将数 m 决定将军们要进行多少轮作战信息协商），即 m+1 轮（所以，你看，只有魏是叛变的，那么就进行了两轮）。你也可以从另外一个角度理解：n 位将军，最多能容忍 (n - 1) / 3 位叛将。</p><p>不过，这个算法虽然能解决拜占庭将军问题，但它有一个限制：如果叛将人数为 m，那么将军总人数必须不小于 3m + 1。</p><p><strong>签名消息型拜占庭问题之解</strong></p><p>口信消息型需要增加更多的忠诚的将军，签名消息型就是允许在不添加新的将军的前提下，达到最后的一致性。</p><p>签名就好比李牧的印章、虎符等信物，并且必须满足以下条件：</p><p>忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现；</p><p>任何人都能验证将军签名的真伪。</p><p><strong>忠诚将军先发起命令</strong></p><p>如果忠诚的将军，比如韩国先发起作战信息协商，一旦齐国修改或伪造收到的作战信息，那么燕国在接收到齐国的作战信息的时候，会发现韩国的作战信息被修改，齐国已叛变，这时他将忽略来自齐国的作战信息，最终执行韩国发送的作战信息。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528154102135.png" alt="image-20240528154102135"></p><p><strong>通敌国先发起命令</strong></p><p>如果叛变将军齐先发送误导的作战信息，那么，韩和燕将按照一定规则（比如取中间的指令）在排序后的所有已接收到的指令中（比如撤退、进攻）中选取一个指令，进行执行，最终执行一致的作战计划。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528154123384.png" alt="image-20240528154123384"></p><p>签名消息的拜占庭问题之解，也是需要进行 m+1 轮（其中 m 为叛将数）。你也可以从另外一个角度理解：n 位将军，能容忍 (n - 2) 位叛将（只有一位忠将没有意义，因为此时不需要达成共识了）。可以尝试去思考在2忠2叛的情况，在这里不做过多的赘述。可能你会觉得怎么可能事先知道叛军的，m根本就不知道。记住，轮次是通过n-1次定义的，而不是通过确定的叛军数确定的。</p><h2 id="CAP-理论">CAP 理论</h2><p>这个理论就是 CAP 理论，先想下面几个问题：</p><ul><li>什么是 CAP，全称是什么，之间的关系是什么？</li><li>CAP 之间是什么关系，场景对应是怎样的？</li><li>P 跟 A 都保证了可用性，但怎么区分？</li><li>如何运用 CAP？</li></ul><p><strong>注意，如果是单体系统，不存在什么 CAP 理论 ，就不存在分区。</strong></p><table><thead><tr><th>属性</th><th>全称</th><th>中文</th><th>描述</th></tr></thead><tbody><tr><td>C</td><td>Consistency</td><td>一致性</td><td>集群节点要么读到集群<strong>最新一致数据</strong>，要么全部都返回读取失败。【所有节点访问<strong>同一份最新</strong>的数据副本】【也叫副本一致性】</td></tr><tr><td>A</td><td>Availability</td><td>可用性</td><td>任何来自客户端的请求，不管访问哪个<strong>非故障节点</strong>，<strong>都能得到响应数据，但不保证是同一份最新数据。</strong></td></tr><tr><td>P</td><td>Partition Tolerance</td><td>分区容错性</td><td>当节点间出现任意数量的消息丢失或高延迟的时候，系统仍然在继续工作</td></tr></tbody></table><p><strong>分区容错性解释</strong>：</p><p>举个例子，假设我们有一个分布式数据库系统，该系统有三个节点，分别是A、B和C。在正常情况下，这三个节点可以互相通信，共享数据。</p><p>现在，假设网络发生了分区，节点A与节点B、C之间的通信被切断，也就是说，A不能与B、C交换信息，但B和C之间的通信仍然正常。</p><p>在这种情况下，如果我们的系统能够继续提供服务（也就是说，客户端可以继续从节点A、B、C读取或写入数据），那么我们就说这个系统具有分区容错性。</p><p>需要注意的是，分区容错性并不意味着系统的所有功能都能在网络分区时正常工作。例如，在上述例子中，由于A不能与B、C交换信息，所以A可能无法获取到B、C最新的数据更新，这就可能影响到系统的一致性。这就是CAP理论中的一个基本权衡：在网络分区的情况下，系统必须在一致性和可用性之间做出选择。</p><p><strong>CAP 不可兼得</strong></p><p>因为分区容错性是前提，P一定有。可以这么理解，一个蓄水池，恒水位，有一个出水口和入水口。入水口坏了，你是想要这个蓄水池先供水，还是先保证水位正确，不要触发水位报警。这个蓄水池，肯定不能在没有入水的前提下，还能让水位保持恒定。因此，CAP 是不能兼容的。要想兼容，除非这个系统不需要分区。</p><p>CAP 不可兼得最初是埃里克·布鲁尔（Eric Brewer）基于自己的工程实践，提出的一个猜想，后被赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）证明，证明过程可以参考论文《Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant web services》，记住结论就好了。</p><p>补充一点：基于证明严谨性的考虑，赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）对指标的含义做了预设和限制，比如，将一致性限制为原子一致性。</p><p><strong>如何使用 CAP 理论</strong></p><p>有网络交互就一定会有延迟和数据丢失，而这种状况我们必须接受，还必须保证系统不能挂掉。所以就像前面提到的，节点间的分区故障是必然发生的。也就是说，分区容错性 P 是前提，是必须要保证的。</p><p>现在就只剩下一致性 C 和可用性 A 可以选择了：要么选择一致性，保证数据正确；要么选择可用性，保证服务可用。</p><p>那么 CP 和 AP 的含义是什么呢？</p><p>选择了一致性 C ：一定会读到最新的数据，不会读到旧数据，但如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的读请求时，为了不破坏一致性，可能会因为无法响应最新数据，而返回出错信息。</p><p>选择了可用性 A ：系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。</p><p>CAP 适用场景</p><p>CA：典型的应用是 Etcd，Consul 和 Hbase，Zookeeper</p><p>AP：Cassandra 和 DynamoDB，服务注册中心。</p><h2 id="ACID理论">ACID理论</h2><p>**ACID 是数据库管理系统为了保证事务的正确性而提出来的一个理论，**ACID 包含四个约束，分别是：</p><p><strong>1.Atomicity（原子性）</strong><br>一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p><strong>2.Consistency（一致性）</strong><br>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p><p><strong>3.Isolation（隔离性）</strong><br>数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p><strong>4.Durability（持久性）</strong></p><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><p><strong>ACID 中的 C 是指数据库的数据完整性，而 CAP 中的 C 是指分布式节点中的数据一致性。ACID 的应用场景是数据库事务，CAP 关注的是分布式系统数据读写。</strong></p><p>但是，这只能保证单个节点上操作的 ACID 特性，无法保证节点间操作的 ACID 特性。因此需要掌握分布式事务协议，比如二阶段提交协议和 TCC（Try-Confirm-Cancel）</p><h3 id="二阶段提交协议">二阶段提交协议</h3><p>2PC(tow phase commit)两阶段提交。所谓的两个阶段是指：</p><ol><li>第一阶段：准备阶段(投票阶段)</li><li>第二阶段：提交阶段（执行阶段）。</li></ol><p>我们将提议的节点称为协调者(coordinator)，其他参与决议节点称为参与者(participants, 或cohorts)。</p><p><strong>2PC第一阶段</strong></p><p>2PC的第一阶段是投票环节，投票由协调者节点发起，可以进一步细分为以下步骤：</p><ol><li>事务询问：协调者向所有的参与者发送事务预处理请求，称之为Prepare，并开始等待各参与者的响应。</li><li>执行本地事务：各个参与者节点执行本地事务操作,但在执行完成后并不会真正提交数据库本地事务，而是先向协调者报告说：“我这边可以处理了/我这边不能处理”。</li><li>各参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行，如果没有参与者成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。</li></ol><p>第一阶段执行完后，会有两种可能。1、所有都返回Yes. 2、有一个或者多个返回No。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528162359332.png" alt="image-20240528162359332"></p><p><strong>2PC第二阶段：正常提交</strong></p><p>如果第一阶段所有的参与者都返回Yes，那么我们就可以继续执行2PC第二阶段的正常提交步骤：</p><ol><li>协调者节点通知所有的参与者Commit事务请求；</li><li>参与者收到Commit请求之后，就会正式执行本地事务Commit操作，并在完成提交之后释放整个事务执行期间占用的事务资源。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528162426879.png" alt="image-20240528162426879"></p><p><strong>2PC第二阶段：异常回滚</strong></p><p>如果任何一个参与者向协调者反馈了No响应，或者等待超时之后，协调者尚未收到所有参与者的反馈响应，那么我们就需要执行2PC第二阶段的回滚操作：</p><ol><li>协调者节点通知所有的参与者Rollback请求；</li><li>参与者收到Rollback请求之后，就会正式执行本地事务Rollback操作，并在完成提交之后释放整个事务执行期间占用的事务资源。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528162442350.png" alt="image-20240528162442350"></p><p><strong>2PC存在的问题</strong></p><p>通过上面的演示，很容易想到2pc所带来的缺陷：</p><ul><li>性能问题：无论是在第一阶段的过程中,还是在第二阶段,所有的参与者资源和协调者资源都是被锁住的,只有当所有节点准备完毕，事务 协调者 才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。</li><li>单节点故障：由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（虽然协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）。</li></ul><h2 id="Base理论">Base理论</h2><p><strong>BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</strong></p><p><strong>1. 基本可用（Basically Available）</strong></p><p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p><p><strong>2. 软状态（Soft State）</strong></p><p>允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</p><p><strong>3. 最终一致性（Eventual Consistency）</strong></p><p>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</p><p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。前面在剖析 CAP 理论时，提到了其实和 BASE 相关的两点：</p><ul><li>CAP 理论是忽略延时的，而实际应用中延时是无法避免的。</li><li>AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性。</li></ul><p>总结，<strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p><p>参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_40242845/article/details/115434216">分布式系统–拜占庭将军问题(The Byzantine Generals Problem)</a></li><li><a href="https://www.cnblogs.com/yuhushen/p/15434594.html">分布式事务（二）之两阶段提交</a></li></ul>]]></content>
    
    
    <summary type="html">分布式基础理论</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree</title>
    <link href="https://penge666.github.io/posts/b5f22718.html"/>
    <id>https://penge666.github.io/posts/b5f22718.html</id>
    <published>2024-05-28T03:30:23.000Z</published>
    <updated>2024-05-28T07:00:16.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言">0 前言</h2><p>对于存储介质为磁盘或SSD的数据库，长期以来主流使用B+树这种索引结构来实现快速数据查找。当数据量不太大时，B+树读写性能表现非常好。<strong>但是在海量数据情况下，B+树越来越高，由于B+树更新和删除数据时需要沿着B+树逐层进行页分裂和页合并，严重影响数据写入性能</strong>。为了应对这种情况，google在论文<code>《Bigtable: A Distributed Storage System for Structured Data》</code>中介绍了一种新的数据组织结构<code>LSM Tree(Log-Structured Merge Tree)</code>，随后，<code>Bigtable</code>主要作者<code>Jeffrey Dean</code>和 <code>Sanjay Ghemawat</code>开源了一款基于<code>LSM Tree</code>实现的数据库<code>LevelDB</code>，让大家对<code>LSM Tree</code>的思想和实现理解得更为透彻、深入。</p><p>当前，比较流行的NoSQL数据库，如Cassandra、<strong>RocksDB、HBase、LevelDB</strong>等，newSQL数据库，如TiDB，均是使用<code>LSM Tree</code>来组织磁盘数据的。</p><ul><li>rocksdb 是 Facebook 使用纯 C++ 研发的嵌入式 kv 存储引擎，依赖的核心数据结构是 lsm tree 存储引擎，底层正是基于追加写策略实现，适用于写多读少的使用场景。</li></ul><p>甚至像SQLite这种传统的关系型数据库和MongoDB这种传统的文档型数据库都提供了<strong>基于<code>LSM Tree</code>的存储引擎作为可选的存储引擎</strong>。</p><p>【读多写少：MySQL引擎、写多读少：LSM Why?】</p><h2 id="1-基本原理简述">1 基本原理简述</h2><p><code>LSM Tree</code>的全称为<code>Log-Structured Merge Tree</code>，是一个分层、有序、针对块存储设备（机械硬盘和SSD）特点而设计的数据存储结构。<strong>它的核心理论基础还是磁盘的顺序写速度比随机写速度快非常多</strong>，即使是SSD，由于块擦除和垃圾回收的影响，顺序写速度还是比随机写速度快很多。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528113331734.png" alt="image-20240528113331734"></p><p>【其实很直观的就知道是追加形式写的，保证顺序性。但是会存在2个问题，<strong>读数据慢以及写的空间浪费</strong>，请看后文是LSM是如何解决这2个问题的~】</p><p><code>LSM Tree</code>将存储数据切分为一系列的<code>SSTable</code>（<code>Sorted String Table</code>），一个<code>SSTable</code>内的数据是有序的任意字节组（即<code>arbitrary byte string</code>，并不是指编程语言中的String字符串），而且，<code>SSTable</code>一但写入磁盘中，就像日志一样不能再修改（这就是<code>Log-Structured Merge Tree</code>名字中<code>Log-Structured</code>一词的由来）。当要修改现有数据时，<code>LSM Tree</code>并不直接修改旧数据，而是直接将新数据写入新的<code>SSTable中</code>。同样的，删除数据时，<code>LSM Tree</code>也不直接删除旧数据，而是写一个相应数据的删除标记的记录到一个新的<code>SSTable</code>中。这样一来，<code>LSM Tree</code>写数据时对磁盘的操作都是顺序块写入操作，而没有随机写操作。</p><p><code>LSM Tree</code>这种独特的写入方式，导致在查找数据时，<code>LSM Tree</code>就不能像<code>B+树</code>那样在一个统一的索引表中进行查找，而是从最新的<code>SSTable</code>到老的<code>SSTable</code>依次进行查找。如果在新<code>SSTable</code>中找到了需查找的数据或相应的删除标记，则直接返回查找结果；如果没有找到，再到老的<code>SSTable</code>中进行查找，直到最老的<code>SSTable</code>查找完。为了提高查找效率，<code>LSM Tree</code>对<code>SSTable</code>进行分层、有序组织，也就是说把<code>SSTable</code>组织成多层，同一层可以有多个<code>SSTable</code>，同一个数据在同一层的多个<code>SSTable</code>中可以不重复，而且数据可以做到在同一层中是有序的，即每一个<code>SSTable</code>内的数据是有序的，前一个<code>SSTable</code>的最大数据值小于后一个<code>SSTable</code>的最小数据值（实际情况比这个复杂，后面会介绍）。这样可以加快在同一层<code>SSTable</code>中的数据查询速度。同时，<code>LSM Tree</code>会将多个<code>SSTable</code>合并（<code>Compact</code>）为一个新的<code>SSTable</code>，这样可以减少<code>SSTable</code>的数量，同时把修改前的数据或删除的数据真正从<code>SSTable</code>中删除，减小了<code>SSTable</code>的大小（这就是<code>Log-Structured Merge Tree</code>名字中<code>Merge</code>一词的由来），对提高查找性能极其重要（<code>SSTable</code>合并（<code>Compact</code>）过程对LSM Tree查找如此重要，以至于把它作为名字的一部分）。</p><h2 id="2-读写过程详述">2 读写过程详述</h2><h3 id="2-1-LSM-Tree框架图">2.1 LSM Tree框架图</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528113731067.png" alt="image-20240528113731067"></p><p>【对着上述图得描述清楚】</p><p>上图中，<code>WAL</code>（<code>Write Ahead LOG</code>）严格来说本身并不是<code>LSM Tree</code>数据结构的一部分，但是实际系统中，<code>WAL</code>是数据库不可或缺的一部分，<code>把WAL</code>包括进来才能更准确的理解<code>LSM Tree</code>。</p><p>从图中可知，<code>LSM Tree</code>的数据由两部分组成：内存部分和持久到磁盘中的部分。<strong>内存部分由一个<code>MemTable</code>和一个或多个<code>Immutable MemTable</code>【防止写阻塞】组成</strong>。磁盘中的部分由分布在多个level的<code>SSTable</code>组成。level级数越小（<code>level 0</code>）表示处于该level的<code>SSTable</code>越新，level级数越大（<code>level 1...level N</code>）表示处于该level的<code>SSTable</code>越老，最大级数（<code>level N</code>）大小由系统设定。在本图中，磁盘中最小的级数为<code>level 0</code>，也有的系统把内存中的<code>Immutable MemTable</code>定义为<code>level 0</code>，而磁盘中的数据从<code>Level 1</code>开始，这只是level定义的不同，并不影响系统的工作流程和对系统的理解。</p><p><code>WAL</code>的结构和作用跟其他数据库一样，是一个只能在尾部以<code>Append Only</code>方式追加记录的日志结构文件，它用来当系统崩溃重启时重放操作，使<code>MemTable</code>和<code>Immutable MemTable</code>中未持久化到磁盘中的数据不会丢失。</p><p><strong><code>MemTable</code>往往是一个跳表（<code>Skip List</code>）组织的有序数据结构（当然，也可以是有序数组或红黑树等二叉搜索树）</strong>，跳表既支持高效的动态插入数据，对数据进行排序，也支持高效的对数据进行精确查找和范围查找。</p><p><code>SSTable</code>一般由一组数据block和一组元数据block组成。元数据block存储了<code>SSTable</code>数据block的描述信息，如索引、BloomFilter、压缩、统计等信息。因为<code>SSTable</code>是不可更改的，且是有序的，索引往往采用二分法数组结构就可以了。为了节省存储空间和提升数据块block的读写效率，可以对数据block进行压缩。</p><p>论文<code>《BigTable》</code>对<code>SSTable</code>的描述我觉得是比较清晰的，现摘录如下，供大家参考：</p><blockquote><p>An SSTable provides a persistent, ordered immutable map from keys to values, where both keys and values are arbitrary byte strings. Operations are provided to look up the value associated with a specified key, and to iterate over all key/value pairs in a specified key range. Internally, each SSTable contains a sequence of blocks (typically each block is 64KB in size, but this is configurable). A block index (stored at the end of the SSTable) is used to locate blocks; the index is loaded into memory when the SSTable is opened. A lookup can be performed with a single disk seek: we first find the appropriate block by performing a binary search in the in-memory index, and then reading the appropriate block from disk. Optionally, an SSTable can be completely mapped into memory, which allows us to perform lookups and scans without touching disk.</p></blockquote><h3 id="2-2-数据写入过程">2.2 数据写入过程</h3><p>如上图所示，<code>LSM Tree</code>写入数据时，先写一条记录到<code>WAL</code>中，然后将数据写入内存中的<code>MemTable</code>中，这样写入操作就完成了。</p><p>写<code>MemTable</code>时，写入新的数据，与修改现有数据的部分字段以及修改现有数据的所有字段，写入操作过程几乎是一样的，都是把传入的数据（合并）写入到<code>MemTable</code>中。删除数据时，则是在<code>MemTable</code>中写入一条删除标记。当<code>MemTable</code>的大小达到设定的大小（典型值是64KB）时，<code>LSM Tree</code>会把当前<code>MemTable</code>冻结为一个不可修改的<code>Immutable MemTable</code>，然后创建一个新的<code>MemTable</code>供新的数据写入。同时，<code>LSM Tree</code>一般会有一些与写入线程（或进程）相独立的背景线程（或进程）负责将<code>Immutable MemTable</code> flush到磁盘中，将数据持久化。已经flush到磁盘中的<code>Immutable MemTable</code>对应的<code>WAL</code>就可以从磁盘中删除了。而内存中<code>Immutable MemTable</code>数量的多少处决于<code>Immutable MemTable</code> flush的速度与<code>Immutable MemTable</code>生成的速度（数据写入速度）的差值</p><p>从<code>LSM Tree</code>数据写入过程可知，<code>LSM Tree</code>数据写入的操作非常简单，过程也非常少，只要写<code>WAL</code>和内存中的<code>MemTable</code>即可。而写<code>WAL</code>是以在文件末尾追加记录方式的顺序写，无需操作任何数据结构，写入速度非常快。写<code>MemTable</code>虽然也需要进行跳表的插入和排序操作，但是MemTable是一个内存数据结构，同时MemTable的大小控制在一个非常非常小的规模（比如64KB），所以写MemTable也是一个非常非常快的过程。</p><p>同时，我们还可以看到，数据的写入速度与数据库中数据总量的多少没有关系。而且，不管是写入新的数据，还是全量修改或部分修改现有数据，或是删除现有数据，<code>LSM Tree</code>的写入速度也几乎没多大差别。也就是说，<code>LSM Tree</code>的写入速度是稳定的，跟数据规模和数据更新类型都没有关系。</p><h3 id="2-3-数据查找过程">2.3 数据查找过程</h3><p>根据<code>LSM Tree</code>的写入特点我们知道，如果一项数据更新多次，这项数据可能会存储在多个不同的<code>SSTable</code>中，甚至一项数据的不同部分的最新数据内容存储在不同的<code>SSTable</code>中（数据部分更新的场景）。<code>LSM Tree</code>把这种现象叫做空间放大（<code>space amplification</code>），因为一项数据在磁盘中存储了多份副本，而老的副本是已经过时了的，不需要的，数据实际占用的存储空间比有效数据需要的大。</p><p>空间放大这种现象导致<code>LSM Tree</code>的查找过程是这样的：按新到老的顺序查找<code>SSTable</code>，直到在某个（或某些个）<code>SSTable</code>中查找到了所需的数据，或者最老的<code>SSTable</code>查找完也没有找到需要的数据。具体查找顺序为：先在内存<code>MemTable</code>中查找，然后在内存中的<code>Immutable MemTable</code>中查找，然后在<code>level 0 SSTable</code>中查找，最后在<code>level N SSTable</code>中查找。</p><p>查找某个具体的SSTable时，一般先把SSTable的元数据block读到内存中，根据BloomFilter可以快速确定数据在当前SSTable中是否存在，如果存在，则采用二分法确定数据在哪个数据block，然后将相应数据block读到内存中进行精确查找。</p><p>从<code>LSM Tree</code>数据查找过程我们可以看到，为了查找到目标数据，我们需要读取并查找不包含目标数据的SSTable，如果目标数据在最底层level N的SSTable中，我们需要读取和查找所有的SSTable！<code>LSM Tree</code>把这种读取和查找了无关SSTable的现象叫做读放大(<code>read amplification</code>)。</p><p><strong>读放大现象严重影响了<code>LSM Tree</code>数据查找性能，甚至是灾难性的（数据压根不存在或在最老的SSTable中），论文《BigTable》提到了几种提升数据查找性能的方法</strong>：【读放大的应对策略】</p><ol><li><p>压缩（Compression）</p><p>介绍SSTable时已经提到了，对数据block进行压缩，通过增加占用CPU压缩和解压缩资源来降低数据block磁盘空间占用和读写时间。</p></li><li><p>BloomFilter</p><p>描述查找过程时也已经提到了，BloomFilter可以快速确定数据不在SSTable中，而不用读取数据block内容</p></li><li><p>缓存（Cache）</p><p>因为SSTable是不可变的，非常适合缓存到内存中，这样热点数据不用访问磁盘</p></li><li><p>SSTable合并(Compaction)</p><p>将多个SSTable合并为一个SSTable，删除旧数据或物理删除已经被删除的数据，降低空间放大；同时减少SSTable数量，降低读放大</p></li></ol><p>其实这些优化措施，除了SSTable合并是<code>LSM Tree</code>独有的，前面三条都是数据库通用的措施，甚至SSTable合并也不是<code>LSM Tree</code>独有的，它与更早出现的lucene的段合并（<code>Segment Merge</code>）的原理和目标其实是有相似的地方的(当然他们的写入和查找过程还是有本质区别的)。下面详细介绍下SSTable合并</p><h2 id="3-SSTable合并">3 SSTable合并</h2><p>【写放大的应对策略】</p><p>这部分学习自：<a href="https://mp.weixin.qq.com/s/kqpBZ2aCC0CGvvL2Lm6mzA">初探 rocksdb 之 lsm tree</a></p><p>所有 disktable 是由内存中的 memtable 溢写得到的，这样 disktable 就天然具有两大优势：</p><ul><li>disktable 内部不存在重复 kv 对数据，因为 memtable 执行的是就地写操作</li><li>disktable 内部的 kv 对数据是有序的，因为 memtable 数据本身就是有序的</li></ul><p>然而，disktable 间还存在一个局限：由于每个 memtable 视野有限，只能做到自身范围内的 k 去重和排序. 因此，不同 disktable 之间可能存在重复冗余的 kv 对数据，且不同 disktable 之间的数据无法做到全局有序.</p><p>理清了现状，我们再在此基础之上，进一步引入磁盘 disktable 分层的概念.</p><ul><li>首先，我们将磁盘整体分为 level0-levelk 共计 k+1层.</li><li>每个 level 层中的 disktable 数量保持一致</li><li>level(i+1) 中 disktable 的容量大小固定为 level(i) 的 T 倍，T 为常量，通常取值为 10 左右</li><li>数据流向是由浅入深，层层递进，即由 level(i) -&gt; level(i+1)</li><li>memtable 溢写的数据落到 level0</li><li>levelk 作为兜底</li><li>当某个 level 内数据总量达到达到阈值时，会发起 level(i) -&gt; level(i+1) 的归并操作</li><li>数据从 level(i) 流向 level(i+1) 过程中，通过归并操作进行去重和排序，保证 level(i+1) 中 kv 数据无重复且全局有序</li></ul><p>结合上述设定，我们可以得出以下结论：</p><ul><li>level0 是特殊的，其中 disktable 之间可能存在冗余的 kv 对数据且不保证全局有序，因为其数据来自 memtable</li><li>level1~levelk 中单层之内没有冗余的 kv 对数据，且保证全局有序</li><li>不同 level 层之间可能存在冗余的 kv 数据</li><li>较热（最近写入）的数据位于浅层，较冷（更早写入）的数据位于深层</li><li>levelk 作为最深的一层，整体沉淀的数量达到全局的百分之九十左右</li></ul><p>下面举一例，说明一下从 level1 到 level2 的数据归并过程.</p><p>假设此时 level1 层的数据总量已经达到阈值，接下来需要发起 level(1) -&gt; level(2) 的归并操作：</p><ul><li>从 level1 中随机选择一个 disktable，尝试将其合并到 level2. 由于数据是有序的，我们可以拿到其中 k 的取值范围. 假设其中最小的 key k_min = 3， 最大的 key k_max = 30，记为[3,30]</li><li>假设 level2 中有 2 个 disktable 的 k 范围和待合并文件存在重叠，分别为 [0,16] 和 [17,32]</li><li>将 level1 的 [3,30] 与 level2 的 [0,10] 和 [11,20] 合并，这个过程本质上是个归并排序操作</li><li>新生成的 disktable [0,30] 不急于插入 level2 ，会根据 level2 中 disktable 的大小规模将其拆分为合适的数量</li><li>假设拆分得到的两个新的 disktable 分别为 [0,15] 和 [16,30]，将其插入到 level2</li><li>对应的老数据 level1 的[3,30] 以及 level2 的 [0,10] 和 [11,20] 都被被新数据替代，因此需要删除</li></ul><p>值得一提的是，倘若因为这一合并操作，导致 level2 的数据容量又超出阈值，则会进一步引起 level 2 到 level 3 的数据合并操作，以此类推，层层递进.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240528114100478.png" alt="image-20240528114100478"></p><h2 id="4-LSM-Tree原理对系统读写性能提升的几点启示">4 LSM Tree原理对系统读写性能提升的几点启示</h2><ol><li>写数据时尽量批量操作。LSM Tree数据写入性能已经很高了，但是批量操作时可以节省网络传输RTT时间。</li><li>将数据进行分片。这样多个分片可以并行写，如果数据路由处理得当，也可以提升数据查询速度。但是增加了维护多个分片数据读写的复杂度。</li><li>选择合适的主键。两个比较流行的选择是：1）采用递增的数字作为主键；2）采用业务本身标识符作为主键。数字作为主键可以减少写入和查询时进行比较、排序等操作的时间，还能提升索引缓存的效率；递增的数字往往保证是顺序写入的，可以减少排序时间。但是递增的数字往往不具备业务语义，业务实际查询时需要先查二级索引，然后进行主键查找。业务标识符往往是业务实际的身份区分符号，业务也往往通过业务标识符进行数据查询。但是业务标识符往往是一个字符串，可能会比较长，这样比较、排序、缓存效率方面不如数字。一般情况下，本人建议LSM Tree数据库采用业务标识符作为主键。因为为业务标识符建立索引以及维护索引的成本是免不了的，与其建立二级索引，不如直接建立主键索引。</li><li>设计合理的二级索引，不建立不需要的二级索引。二级索引可以提升相应数据的查询速度，每增加一个二级索引，就需要额外维护相应的二级索引文件，严重影响写入数据性能。</li><li>根据具体场景使用合适的SSTable合并策略。单次写，频繁读场景选择leveled compaction策略。</li><li>在允许情况下关闭自动SSTable合并，在业务量低的时间段强制执行SSTable合并。</li><li>数据更新时合理选择全量更新（覆盖写）方式还是部分更新（增量写）方式。全量更新方式增加了传输和写入的数据量，但是可以提升数据查询速度。部分更新方式会使数据分布在多个SSTable中，需要查询和合并多个SSTable中的数据才能得到完整的数据，会降低数据查询速度。如果数据修改比较频繁，且需要较高查询速度，建议采用全量更新方式。</li></ol><p>参考资料</p><ul><li><a href="https://www.jianshu.com/p/b43b856e09bb">LSM Tree原理详解</a></li><li><a href="https://wingsxdu.com/posts/database/leveldb/#sstable">LSM-Tree 与 LevelDB 的原理和实现 · Analyze</a></li></ul>]]></content>
    
    
    <summary type="html">LSM Tree：Log-Structured Merge Tree</summary>
    
    
    
    <category term="数据库" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>一致性Hash算法</title>
    <link href="https://penge666.github.io/posts/aca386f3.html"/>
    <id>https://penge666.github.io/posts/aca386f3.html</id>
    <published>2024-05-27T13:58:45.000Z</published>
    <updated>2024-05-27T14:12:20.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hash算法">Hash算法</h2><p>我们想将图片A保存在服务器上，目前有3台服务器。我们只想保存一台服务器上，那么考虑到下次取的话还要到服务器上去取，那么使用hash算法就行。</p><p>但是当服务器数量的变更，就导致算出来的服务器里面没有我们想要的数据，那么会发生缓存雪崩的问题，因此有了下面的方法。</p><h2 id="一致性Hash算法背景">一致性Hash算法背景</h2><p>一致性哈希算法在1997年由麻省理工学院的Karger等人在解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用。</p><p>但现在一致性hash算法在分布式系统中也得到了广泛应用，研究过memcached缓存数据库的人都知道，memcached服务器端本身不提供分布式cache的一致性，而是由客户端来提供，具体在计算一致性hash时采用如下步骤：</p><ol><li>首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li><li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527215930526.png" alt="image-20240527215930526"></p><p>从上图的状态中添加一台memcached服务器。余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527215942900.png" alt="image-20240527215942900"></p><p>分布式一致性哈希的优点，如果缓存服务器的数量发生改变，并不是所有的缓存都会失效，而是只有部分缓存失效，不容易出现。</p><h2 id="一致性Hash性质">一致性Hash性质</h2><p>考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要，良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面：</p><ul><li><strong>平衡性(Balance)</strong></li></ul><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><ul><li><strong>单调性(Monotonicity)</strong></li></ul><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod §，在上式中，P表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从P1到P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新。而在P2P系统内，缓冲的变化等价于Peer加入或退出系统，这一情况在P2P系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。</p><ul><li><strong>分散性(Spread)</strong></li></ul><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p><ul><li><strong>负载(Load)</strong></li></ul><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><ul><li><strong>平滑性(Smoothness)</strong></li></ul><p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p><h3 id="基本概念">基本概念</h3><p>一致性哈希算法（Consistent Hashing）最早在论文《<a href="http://dl.acm.org/citation.cfm?id=258660">Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web</a>》中被提出。简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希空间环如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527220707089.png" alt="image-20240527220707089"></p><p>整个空间按顺时针方向组织。0和232-1在零点中方向重合。</p><p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用ip地址哈希后在环空间的位置如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527220725275.png" alt="image-20240527220725275"></p><p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p><p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527220739718.png" alt="image-20240527220739718"></p><p>根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p><p>下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p><p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527220755417.png" alt="image-20240527220755417"></p><p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p><p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p><p>另外，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下，</p><p>那么，如何解决这个问题呢？一种常见的做法是引入虚拟节点。也就是说，每个真实节点对应多个虚拟节点，每个虚拟节点都有自己在哈希环上的位置。这样，当一个数据项来到时，我们不是将它映射到真实节点，而是映射到虚拟节点。由于虚拟节点明显多于真实节点，这大大增加了在哈希环上的“节点”数量，从而使得数据更加均匀地分布在各个节点上，减轻了数据倾斜的问题。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527221105098.png" alt="image-20240527221105098"></p><p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527221125000.png" alt="image-20240527221125000"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><p>【普通哈希问题，一致性哈希怎么解决，最后存在数据倾斜问题，使用虚拟节点解决】</p><p>学习自：</p><p><a href="https://blog.csdn.net/en_joker/article/details/80690800">论文：一致性Hash算法</a></p>]]></content>
    
    
    <summary type="html">一致性Hash算法</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Memcached笔记</title>
    <link href="https://penge666.github.io/posts/69dcf386.html"/>
    <id>https://penge666.github.io/posts/69dcf386.html</id>
    <published>2024-05-27T13:32:41.000Z</published>
    <updated>2024-05-27T13:58:24.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、NoSQL-介绍">一、NoSQL 介绍</h2><p>NoSQL是对 Not Only SQL、非传统关系型数据库的统称</p><p>NoSQL一词诞生于1998年，2009年这个词汇被再次提出指非关系型、分布式、不提供ACID的数据库设计模式</p><p>随着互联网时代的到来，数据爆发式增长，数据库技术发展日新月异，要适应新的业务需求</p><p>而随着移动互联网、物联网的到来，大数据的技术中NoSQL也同样重要</p><p>NoSQL 分类</p><p>Key-value Store  k/v数据库</p><ul><li>性能好 O(1) , 如: redis、memcached</li></ul><p>Document Store 文档数据库</p><ul><li>mongodb、CouchDB</li></ul><p>Column Store  列存数据库，Column-Oriented DB</p><ul><li>HBase、Cassandra，大数据领域应用广泛</li></ul><p>Graph DB 图数据库</p><ul><li>Neo4j</li></ul><p>Time Series 时序数据库</p><ul><li>InfluxDB、Prometheus</li></ul><p>注：</p><p>关系型数据库：数据存放在硬盘，调度数据速率慢</p><p>非关系型数据库：数据存放在内存，调度数据速率快</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo apt-get install memcached</span><br></pre></td></tr></table></figure><h2 id="二、Memcached">二、Memcached</h2><h3 id="1、Memcached-介绍">1、Memcached 介绍</h3><h4 id="1-1-Memcached-概念">1.1 Memcached 概念</h4><p>Memcached 只支持能序列化的数据类型，不支持持久化，基于Key-Value的内存缓存系统</p><p>memcached 虽然没有像redis所具备的数据持久化功能，比如RDB和AOF都没有，但是可以通过做集群同步的方式，让各memcached服务器的数据进行同步，从而实现数据的一致性，即保证各memcached的数据是一样的，即使有任何一台 memcached 发生故障，只要集群中有一台 memcached 可用就不会出现数据丢失，当其他memcached 重新加入到集群的时候,可以自动从有数据的memcached 当中自动获取数据并提供服务。</p><p>Memcached 借助了操作系统的 libevent 工具做高效的读写。libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能封装成统一的接口。即使对服务器的连接数增加，也能发挥高性能。memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能</p><p>Memcached 支持最大的内存存储对象为1M，超过1M的数据可以使用客户端压缩或拆分报包放到多个key中，比较大的数据在进行读取的时候需要消耗的时间比较长，memcached 最适合保存用户的session实现session共享</p><p>Memcached存储数据时, Memcached会去申请1MB的内存, 把该块内存称为一个slab, 也称为一个page</p><p>Memcached 支持多种开发语言，包括：JAVA,C,Python,PHP,C#,Ruby,Perl等</p><p>Memcached 是一个高性能、分布式的内存对象缓存系统，用于减轻数据库负载，提升动态Web应用的性能。它基于内存键值存储系统设计，通过在内存中存储数据来减少对慢速数据库的访问次数，从而提高网站或应用程序的速度和响应能力</p><p>尽管 Memcached 在功能上有时被当作一种辅助数据库使用，但其主要角色是作为一个高性能、分布式的缓存层，适用于实时性要求高且数据可以容忍一定程度丢失的应用场景</p><h4 id="1-2-Memcached-特性">1.2 Memcached 特性</h4><p>分布式缓存： 可以在多台服务器上分布数据，允许构建大规模的缓存系统</p><p>内存中存储： 数据存储在内存中，因此读写速度非常快</p><p>简单的键值存储： 它使用简单的键值对存储方式，适合于存储对象、文本和其他数据类型</p><p>缓存数据过期： 可以为缓存的数据设置过期时间，确保缓存中的数据不会永远存在</p><p>支持多种语言： 提供了多种编程语言的客户端库，便于在不同的应用程序中使用</p><p>减轻数据库负载： 通过缓存频繁访问的数据，可以显著减轻数据库的负载，提高网站或应用程序的性能</p><p>LRU（最近最少使用）淘汰策略：当内存达到预设上限时，Memcached 将根据 LRU 算法自动删除最近最少使用的数据，为新数据腾出空间</p><p>非持久化：Memcached 不支持持久化存储，主要用于临时缓存</p><p>高性能： 由于数据存储在内存中，因此具有非常高的读取和写入性能</p><p>开源： Memcached 是一个开源项目，可以自由使用和修改</p><h4 id="1-3-Memcached-和-Redis-区别">1.3 Memcached 和 Redis 区别</h4><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527192201465.png" alt="image-20240527192201465"></p><h4 id="1-4-Memcached-工作机制">1.4 Memcached 工作机制</h4><h5 id="1-4-1-内存分配机制">1.4.1 内存分配机制</h5><p>应用程序运行需要使用内存存储数据，但对于一个缓存系统来说，申请内存、释放内存将十分频繁，非常容易导致大量内存碎片，最后导致无连续可用内存可用。</p><p>Memcached 采用了 Slab Allocator 机制来分配、管理内存。</p><p>Page：分配给 Slab 的内存空间，默认为1MB，分配后就得到一个Slab。Slab分配之后内存按照固定字节大小等分成 chunk。</p><p>Chunk：用于缓存记录 k/v 值的内存空间。Memcached 会根据数据大小选择存到哪一个chunk中，假设chunk有128bytes、64bytes等多种，数据只有100bytes存储在128bytes中，存在少许浪费。</p><p>Chunk 最大就是 Page的大小，即一个Page中就一个Chunk</p><p>Slab Class：Slab 按照 Chunk 的大小分组，就组成不同的 Slab Class, 第一个Chunk大小为 96B的Slab为Class1,Chunk 120B为Class 2,如果有100bytes要存，那么 Memcached 会选择下图中Slab Class 2 存储，因为它是120bytes的Chunk。Slab之间的差异可以使用Growth Factor 控制，默认1.25</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527211045176.png" alt="image-20240527211045176"></p><hr><p>简单说</p><p>Memcached采用的Slab Allocator机制是一种特别适合于处理大量小数据对象的内存管理机制。它把内存划分为多个相同大小的Slab，然后每个Slab再划分为多个相同大小的Chunk，用于存储数据。</p><p>以书店为例，你可以把Memcached想象成一个大书店，Slab就像书店里的书架，Chunk就像书架上的格子，而数据就像书本。</p><p>这个书店里有很多种类型的书架(Slab)，每个书架的大小都是固定的，比如说1MB。每个书架又被划分成很多个大小相同的格子(Chunk)，比如说有的书架的格子大小是96B，有的是120B等等。这些不同格子大小的书架被分别组织在不同的区域(Slab Class)。</p><p>当有一本新书(数据)需要上架时，书店会根据这本书的大小，选择一个合适的书架，然后在这个书架上找一个空的格子来放这本书。比如说，如果这本书的大小是100B，书店就会选择120B的书架来存储，因为96B的格子太小放不下，而120B的格子又是最接近100B的。</p><p>通过这种方式，Memcached可以有效地管理内存，尽量减少内存的浪费，并且由于每个格子的大小是固定的，所以在内存分配和回收时，可以避免复杂的内存管理操作，提高了系统的性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ memcached -u memcached -f 2 -vv</span><br><span class="line">slab class   1: chunk size        96 perslab   10922</span><br><span class="line">slab class   2: chunk size       192 perslab    5461</span><br><span class="line">slab class   3: chunk size       384 perslab    2730</span><br><span class="line">slab class   4: chunk size       768 perslab    1365</span><br><span class="line">slab class   5: chunk size      1536 perslab     682</span><br><span class="line">slab class   6: chunk size      3072 perslab     341</span><br><span class="line">slab class   7: chunk size      6144 perslab     170</span><br><span class="line">slab class   8: chunk size     12288 perslab      85</span><br><span class="line">slab class   9: chunk size     24576 perslab      42</span><br><span class="line">slab class  10: chunk size     49152 perslab      21</span><br><span class="line">slab class  11: chunk size     98304 perslab      10</span><br><span class="line">slab class  12: chunk size    196608 perslab       5</span><br><span class="line">slab class  13: chunk size    524288 perslab       2</span><br><span class="line">&lt;26 server listening (auto-negotiate)</span><br></pre></td></tr></table></figure><h5 id="1-4-2-懒惰期-Lazy-Expiration">1.4.2 懒惰期 Lazy Expiration</h5><p>memcached 不会监视数据是否过期，而是在取数据时才看是否过期，如果过期,把数据有效期限标识为0，并不清除该数据。以后可以覆盖该位置存储其它数据。</p><h5 id="1-4-3-LRU（最近最少使用算法）">1.4.3 LRU（最近最少使用算法）</h5><p>当内存不足时，memcached 会使用 LRU（Least Recently Used）机制来查找可用空间，分配给新记录使用</p><h5 id="1-4-4-集群">1.4.4 集群</h5><p>Memcached 集群，称为基于客户端的分布式集群，即由客户端实现集群功能，即 Memcached本身不支持集群</p><p>Memcached集群内部并不互相通信，一切都需要客户端连接到Memcached服务器后自行组织这些节点，并决定数据存储的节点</p><h3 id="2、安装-Memcached">2、安装 Memcached</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) sv<span class="variable">@sv</span>-<span class="variable constant_">NF5280M5</span><span class="symbol">:/home/sv</span><span class="variable">$ </span>sudo apt-get install memcached</span><br></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta">#rpm -ql memcached   #查看memcached的相关文件</span></span><br></pre></td></tr></table></figure><p>查看memcached信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ apt show memcached</span><br><span class="line">Package: memcached</span><br><span class="line">Version: 1.5.22-2ubuntu0.3</span><br><span class="line">Priority: optional</span><br><span class="line">Section: web</span><br><span class="line">Origin: Ubuntu</span><br><span class="line">Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;</span><br><span class="line">Original-Maintainer: Chris Lamb &lt;lamby@debian.org&gt;</span><br><span class="line">Bugs: https://bugs.launchpad.net/ubuntu/+filebug</span><br><span class="line">Installed-Size: 340 kB</span><br><span class="line">Pre-Depends: init-system-helpers (&gt;= 1.54~)</span><br><span class="line">Depends: adduser, libssl1.1 (&gt;= 1.1.0), lsb-base, perl, perl:any, libc6 (&gt;= 2.17), libevent-2.1-7 (&gt;= 2.1.8-stable), libsasl2-2 (&gt;= 2.1.27+dfsg)</span><br><span class="line">Suggests: libanyevent-perl, libcache-memcached-perl, libmemcached, libterm-readkey-perl, libyaml-perl</span><br><span class="line">Homepage: https://memcached.org/</span><br><span class="line">Download-Size: 128 kB</span><br><span class="line">APT-Manual-Installed: <span class="built_in">yes</span></span><br><span class="line">APT-Sources: http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates/main amd64 Packages</span><br><span class="line">Description: High-performance in-memory object caching system</span><br><span class="line"> Danga Interactive developed memcached to enhance the speed of LiveJournal.com,</span><br><span class="line"> a site <span class="built_in">which</span> was already doing 20 million+ dynamic page views per day <span class="keyword">for</span> 1</span><br><span class="line"> million <span class="built_in">users</span> with a bunch of webservers and a bunch of database servers.</span><br><span class="line"> memcached dropped the database load to almost nothing, yielding faster page</span><br><span class="line"> load <span class="built_in">times</span> <span class="keyword">for</span> <span class="built_in">users</span>, better resource utilization, and faster access to the</span><br><span class="line"> databases on a memcache miss.</span><br><span class="line"> .</span><br><span class="line"> memcached optimizes specific high-load serving applications that are designed</span><br><span class="line"> to take advantage of its versatile no-locking memory access system. Clients</span><br><span class="line"> are available <span class="keyword">in</span> several different programming languages, to suit the needs</span><br><span class="line"> of the specific application. Traditionally this has been used <span class="keyword">in</span> mod_perl</span><br><span class="line"> apps to avoid storing large chunks of data <span class="keyword">in</span> Apache memory, and to share</span><br><span class="line"> this burden across several machines</span><br></pre></td></tr></table></figure><p>在Ubuntu上，Memcached的配置文件通常位于<code>/etc/memcached.conf</code>。如果你想要查看Memcached的配置，你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ <span class="built_in">cat</span> /etc/memcached.conf</span><br><span class="line"><span class="comment"># memcached default config file</span></span><br><span class="line"><span class="comment"># 2003 - Jay Bonci &lt;jaybonci@debian.org&gt;</span></span><br><span class="line"><span class="comment"># This configuration file is read by the start-memcached script provided as</span></span><br><span class="line"><span class="comment"># part of the Debian GNU/Linux distribution.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run memcached as a daemon. This command is implied, and is not needed for the</span></span><br><span class="line"><span class="comment"># daemon to run. See the README.Debian that comes with this package for more</span></span><br><span class="line"><span class="comment"># information.</span></span><br><span class="line">-d</span><br><span class="line"></span><br><span class="line"><span class="comment"># Log memcached&#x27;s output to /var/log/memcached</span></span><br><span class="line">logfile /var/log/memcached.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># Be verbose</span></span><br><span class="line"><span class="comment"># -v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Be even more verbose (print client commands as well)</span></span><br><span class="line"><span class="comment"># -vv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start with a cap of 64 megs of memory. It&#x27;s reasonable, and the daemon default</span></span><br><span class="line"><span class="comment"># Note that the daemon will grow to this size, but does not start out holding this much</span></span><br><span class="line"><span class="comment"># memory</span></span><br><span class="line">-m 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default connection port is 11211</span></span><br><span class="line">-p 11211</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the daemon as root. The start-memcached will default to running as root if no</span></span><br><span class="line"><span class="comment"># -u command is present in this config file</span></span><br><span class="line">-u memcache</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify which IP address to listen on. The default is to listen on all IP addresses</span></span><br><span class="line"><span class="comment"># This parameter is one of the only security measures that memcached has, so make sure</span></span><br><span class="line"><span class="comment"># it&#x27;s listening on a firewalled interface.</span></span><br><span class="line">-l 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Limit the number of simultaneous incoming connections. The daemon default is 1024</span></span><br><span class="line"><span class="comment"># -c 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lock down all paged memory. Consult with the README and homepage before you do this</span></span><br><span class="line"><span class="comment"># -k</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return error when memory is exhausted (rather than removing items)</span></span><br><span class="line"><span class="comment"># -M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximize core file limit</span></span><br><span class="line"><span class="comment"># -r</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a pidfile</span></span><br><span class="line">-P /var/run/memcached/memcached.pid</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527211807087.png" alt="image-20240527211807087"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ systemctl start memcached.service</span><br><span class="line">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</span><br><span class="line">启动“memcached.service”需要认证。</span><br><span class="line">Authenticating as: sv,,, (sv)</span><br><span class="line">Password:</span><br><span class="line">==== AUTHENTICATION COMPLETE ===</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ systemctl status memcached.service</span><br><span class="line">● memcached.service - memcached daemon</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/memcached.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Mon 2024-05-27 19:15:06 CST; 2h 3min ago</span><br><span class="line">       Docs: man:memcached(1)</span><br><span class="line">   Main PID: 89046 (memcached)</span><br><span class="line">      Tasks: 10 (<span class="built_in">limit</span>: 76739)</span><br><span class="line">     Memory: 1.5M</span><br><span class="line">     CGroup: /system.slice/memcached.service</span><br><span class="line">             └─89046 /usr/bin/memcached -m 64 -p 11211 -u memcache -l 127.0.0.1 -P /var/run/memcached/memcached.pid</span><br><span class="line"></span><br><span class="line">5月 27 19:15:06 sv-NF5280M5 systemd[1]: Started memcached daemon.</span><br><span class="line">(base) sv@sv-NF5280M5:/home/sv$ ss -natp | grep memcached</span><br><span class="line">LISTEN   0        1024                  [::]:11211                 [::]:*        <span class="built_in">users</span>:((&quot;memcached&quot;,pid=<span class="number">89397</span>,fd=<span class="number">26</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、memcached选项">3、memcached选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ memcached -h</span><br><span class="line">memcached 1.5.22</span><br><span class="line">-p, --port=&lt;num&gt;          TCP port to listen on (default: 11211)</span><br><span class="line">-U, --udp-port=&lt;num&gt;      UDP port to listen on (default: 0, off)</span><br><span class="line">-s, --unix-socket=&lt;file&gt;  UNIX socket to listen on (disables network support)</span><br><span class="line">-A, --enable-shutdown     <span class="built_in">enable</span> ascii <span class="string">&quot;shutdown&quot;</span> <span class="built_in">command</span></span><br><span class="line">-a, --unix-mask=&lt;mask&gt;    access mask <span class="keyword">for</span> UNIX socket, <span class="keyword">in</span> octal (default: 700)</span><br><span class="line">-l, --listen=&lt;addr&gt;       interface to listen on (default: INADDR_ANY)</span><br><span class="line">                          <span class="keyword">if</span> TLS/SSL is enabled, <span class="string">&#x27;notls&#x27;</span> prefix can be used to</span><br><span class="line">                          <span class="built_in">disable</span> <span class="keyword">for</span> specific listeners (-l notls:&lt;ip&gt;:&lt;port&gt;)</span><br><span class="line">-d, --daemon              run as a daemon</span><br><span class="line">-r, --enable-coredumps    maximize core file <span class="built_in">limit</span></span><br><span class="line">-u, --user=&lt;user&gt;         assume identity of &lt;username&gt; (only when run as root)</span><br><span class="line">-m, --memory-limit=&lt;num&gt;  item memory <span class="keyword">in</span> megabytes (default: 64)</span><br><span class="line">-M, --disable-evictions   <span class="built_in">return</span> error on memory exhausted instead of evicting</span><br><span class="line">-c, --conn-limit=&lt;num&gt;    max simultaneous connections (default: 1024)</span><br><span class="line">-k, --lock-memory         lock down all paged memory</span><br><span class="line">-v, --verbose             verbose (<span class="built_in">print</span> errors/warnings <span class="keyword">while</span> <span class="keyword">in</span> event loop)</span><br><span class="line">-vv                       very verbose (also <span class="built_in">print</span> client commands/responses)</span><br><span class="line">-vvv                      extremely verbose (internal state transitions)</span><br><span class="line">-h, --<span class="built_in">help</span>                <span class="built_in">print</span> this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">-i, --license             <span class="built_in">print</span> memcached and libevent license</span><br><span class="line">-V, --version             <span class="built_in">print</span> version and <span class="built_in">exit</span></span><br><span class="line">-P, --pidfile=&lt;file&gt;      save PID <span class="keyword">in</span> &lt;file&gt;, only used with -d option</span><br><span class="line">-f, --slab-growth-factor=&lt;num&gt; chunk size growth <span class="built_in">factor</span> (default: 1.25)</span><br><span class="line">-n, --slab-min-size=&lt;bytes&gt; min space used <span class="keyword">for</span> key+value+flags (default: 48)</span><br><span class="line">-L, --enable-largepages  try to use large memory pages (<span class="keyword">if</span> available)</span><br><span class="line">-D &lt;char&gt;     Use &lt;char&gt; as the delimiter between key prefixes and IDs.</span><br><span class="line">              This is used <span class="keyword">for</span> per-prefix stats reporting. The default is</span><br><span class="line">              <span class="string">&quot;:&quot;</span> (colon). If this option is specified, stats collection</span><br><span class="line">              is turned on automatically; <span class="keyword">if</span> not, <span class="keyword">then</span> it may be turned on</span><br><span class="line">              by sending the <span class="string">&quot;stats detail on&quot;</span> <span class="built_in">command</span> to the server.</span><br><span class="line">-t, --threads=&lt;num&gt;       number of threads to use (default: 4)</span><br><span class="line">-R, --max-reqs-per-event  maximum number of requests per event, limits the</span><br><span class="line">                          requests processed per connection to prevent</span><br><span class="line">                          starvation (default: 20)</span><br><span class="line">-C, --disable-cas         <span class="built_in">disable</span> use of CAS</span><br><span class="line">-b, --listen-backlog=&lt;num&gt; <span class="built_in">set</span> the backlog queue <span class="built_in">limit</span> (default: 1024)</span><br><span class="line">-B, --protocol=&lt;name&gt;     protocol - one of ascii, binary, or auto (default: auto-negotiate)</span><br><span class="line">-I, --max-item-size=&lt;num&gt; adjusts max item size</span><br><span class="line">                          (default: 1m, min: 1k, max: 1024m)</span><br><span class="line">-S, --enable-sasl         turn on Sasl authentication</span><br><span class="line">-F, --disable-flush-all   <span class="built_in">disable</span> flush_all <span class="built_in">command</span></span><br><span class="line">-X, --disable-dumping     <span class="built_in">disable</span> stats cachedump and lru_crawler metadump</span><br><span class="line">-W  --disable-watch       <span class="built_in">disable</span> watch commands (live logging)</span><br><span class="line">-Y, --auth-file=&lt;file&gt;    (EXPERIMENTAL) <span class="built_in">enable</span> ASCII protocol authentication. format:</span><br><span class="line">                          user:pass\nuser2:pass2\n</span><br><span class="line">-e, --memory-file=&lt;file&gt;  (EXPERIMENTAL) mmap a file <span class="keyword">for</span> item memory.</span><br><span class="line">                          use only <span class="keyword">in</span> ram disks or persistent memory mounts!</span><br><span class="line">                          enables restartable cache (stop with SIGUSR1)</span><br><span class="line">-Z, --enable-ssl          <span class="built_in">enable</span> TLS/SSL</span><br><span class="line">-o, --extended            comma separated list of extended options</span><br><span class="line">                          most options have a <span class="string">&#x27;no_&#x27;</span> prefix to <span class="built_in">disable</span></span><br><span class="line">   - maxconns_fast:       immediately close new connections after <span class="built_in">limit</span> (default: enabled)</span><br><span class="line">   - hashpower:           an <span class="built_in">integer</span> multiplier <span class="keyword">for</span> how large the <span class="built_in">hash</span></span><br><span class="line">                          table should be. normally grows at runtime. (default starts at: 0)</span><br><span class="line">                          <span class="built_in">set</span> based on <span class="string">&quot;STAT hash_power_level&quot;</span></span><br><span class="line">   - tail_repair_time:    time <span class="keyword">in</span> seconds <span class="keyword">for</span> how long to <span class="built_in">wait</span> before</span><br><span class="line">                          forcefully killing LRU <span class="built_in">tail</span> item.</span><br><span class="line">                          disabled by default; very dangerous option.</span><br><span class="line">   - hash_algorithm:      the <span class="built_in">hash</span> table algorithm</span><br><span class="line">                          default is murmur3 <span class="built_in">hash</span>. options: jenkins, murmur3</span><br><span class="line">   - no_lru_crawler:      <span class="built_in">disable</span> LRU Crawler background thread.</span><br><span class="line">   - lru_crawler_sleep:   microseconds to <span class="built_in">sleep</span> between items</span><br><span class="line">                          default is 100.</span><br><span class="line">   - lru_crawler_tocrawl: max items to crawl per slab per run</span><br><span class="line">                          default is 0 (unlimited)</span><br><span class="line">   - no_lru_maintainer:   <span class="built_in">disable</span> new LRU system + background thread.</span><br><span class="line">   - hot_lru_pct:         pct of slab memory to reserve <span class="keyword">for</span> hot lru.</span><br><span class="line">                          (requires lru_maintainer, default pct: 20)</span><br><span class="line">   - warm_lru_pct:        pct of slab memory to reserve <span class="keyword">for</span> warm lru.</span><br><span class="line">                          (requires lru_maintainer, default pct: 40)</span><br><span class="line">   - hot_max_factor:      items idle &gt; cold lru age * drop from hot lru. (default: 0.20)</span><br><span class="line">   - warm_max_factor:     items idle &gt; cold lru age * this drop from warm. (default: 2.00)</span><br><span class="line">   - temporary_ttl:       TTL<span class="string">&#x27;s below get separate LRU, can&#x27;</span>t be evicted.</span><br><span class="line">                          (requires lru_maintainer, default: 61)</span><br><span class="line">   - idle_timeout:        <span class="built_in">timeout</span> <span class="keyword">for</span> idle connections. (default: 0, no <span class="built_in">timeout</span>)</span><br><span class="line">   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size <span class="keyword">in</span> kilobytes. use extreme care. (default: 512)</span><br><span class="line">   - watcher_logbuf_size: size <span class="keyword">in</span> kilobytes of per-watcher write buffer. (default: 256)</span><br><span class="line">   - worker_logbuf_size:  size <span class="keyword">in</span> kilobytes of per-worker-thread buffer</span><br><span class="line">                          <span class="built_in">read</span> by background thread, <span class="keyword">then</span> written to watchers. (default: 64)</span><br><span class="line">   - track_sizes:         <span class="built_in">enable</span> dynamic reports <span class="keyword">for</span> <span class="string">&#x27;stats sizes&#x27;</span> <span class="built_in">command</span>.</span><br><span class="line">   - no_hashexpand:       disables <span class="built_in">hash</span> table expansion (dangerous)</span><br><span class="line">   - modern:              enables options <span class="built_in">which</span> will be default <span class="keyword">in</span> future.</span><br><span class="line">                          currently: nothing</span><br><span class="line">   - no_modern:           uses defaults of previous major version (1.4.x)</span><br><span class="line">   - ssl_chain_cert:      certificate chain file <span class="keyword">in</span> PEM format</span><br><span class="line">   - ssl_key:             private key, <span class="keyword">if</span> not part of the -ssl_chain_cert</span><br><span class="line">   - ssl_keyformat:       private key format (PEM, DER or ENGINE) (default: PEM)</span><br><span class="line">   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).</span><br><span class="line">                          valid values are 0(None), 1(Request), 2(Require)</span><br><span class="line">                          or 3(Once)</span><br><span class="line">   - ssl_ciphers:         specify cipher list to be used</span><br><span class="line">   - ssl_ca_cert:         PEM format file of acceptable client CA<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer</span></span><br><span class="line"><span class="string">                          (default: 16)</span></span><br></pre></td></tr></table></figure><p>修改memcached 运行参数，可以使用下面的选项修改/etc/sysconfig/memcached文件</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527212039815.png" alt="image-20240527212039815"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#memcached -u memcached -m 1024 -c 65536 -f 2 -vv</span></span><br><span class="line"><span class="comment">#设置默认前台执行，</span></span><br><span class="line">-u memcached：设置 Memcached 以 memcached 用户身份运行</span><br><span class="line">-m 1024：为 Memcached 分配最大内存为 1024 MB（即1GB），用于缓存数据</span><br><span class="line">-c 65536：设置最大并发连接数为 65536，这意味着同时可以有这么多的客户端连接到 Memcached 实例</span><br><span class="line">-f 2：设置核心文件大小限制，这里的“2”表示如果 Memcached 进程崩溃，将创建一个大小为当前内存两倍的核心转储文件，以便于调试。但在一些系统中，这个参数可能已经被弃用或不支持</span><br><span class="line">-vv：开启详细模式（verbose mode），让 Memcached 在运行时输出更多的信息和日志</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ memcached -u memcached -m 1024 -c 65536 -f 2 -vv</span><br><span class="line">slab class   1: chunk size        96 perslab   10922</span><br><span class="line">slab class   2: chunk size       192 perslab    5461</span><br><span class="line">slab class   3: chunk size       384 perslab    2730</span><br><span class="line">slab class   4: chunk size       768 perslab    1365</span><br><span class="line">slab class   5: chunk size      1536 perslab     682</span><br><span class="line">slab class   6: chunk size      3072 perslab     341</span><br><span class="line">slab class   7: chunk size      6144 perslab     170</span><br><span class="line">slab class   8: chunk size     12288 perslab      85</span><br><span class="line">slab class   9: chunk size     24576 perslab      42</span><br><span class="line">slab class  10: chunk size     49152 perslab      21</span><br><span class="line">slab class  11: chunk size     98304 perslab      10</span><br><span class="line">slab class  12: chunk size    196608 perslab       5</span><br><span class="line">slab class  13: chunk size    524288 perslab       2</span><br><span class="line">failed to listen on TCP port 11211: Address already <span class="keyword">in</span> use</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#memcached -u memcached -m 1024 -c 65536 -d</span></span><br><span class="line"><span class="comment">#设置默认后台执行，</span></span><br><span class="line">-d：该选项会让 Memcached 在后台作为守护进程运行（daemonize），这样在终端窗口关闭后，Memcached 服务依然会继续运行，提供缓存服务</span><br></pre></td></tr></table></figure><h3 id="4、Memcached的基本使用方法">4、Memcached的基本使用方法</h3><h4 id="4-1-Memcached开发库和工具">4.1 Memcached开发库和工具</h4><p>与memcached通信的不同语言的连接器。libmemcached提供了C库和命令行工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#yum install  libmemcached -y </span></span><br><span class="line"><span class="comment">#安装工具包</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#memping --servers 172.16.12.10    #检测172.16.12.10设备的memcached服务是否能通</span></span><br><span class="line">[root@localhost ~]<span class="comment">#echo $?</span></span><br><span class="line">[root@localhost ~]<span class="comment">#systemctl stop memcached.service </span></span><br><span class="line">[root@localhost ~]<span class="comment">#memping --servers 172.16.12.10</span></span><br></pre></td></tr></table></figure><h5 id="4-1-2-Memstat">4.1.2 Memstat</h5><p>用于获取 Memcached 服务的统计信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#memstat --servers=172.16.12.10</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527212252442.png" alt="image-20240527212252442"></p><p>4.2 memcached操作命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/doc/memcached-1.4.15//protocol.txt</span><br><span class="line"><span class="comment">#操作命令帮助文档</span></span><br></pre></td></tr></table></figure><p><strong>Memcached服务只支持Telnet连接</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta">#yum install -y telnet   #安装telnet服务</span></span><br></pre></td></tr></table></figure><p>五种基本 memcached 命令执行最简单的操作。这些命令和操作包括：</p><ul><li>set</li><li>add</li><li>flush</li><li>get</li><li>delete</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#前三个命令是用于操作存储在 memcached 中的键值对的标准修改命令,都使用如下所示的语法：</span></span><br><span class="line"><span class="built_in">command</span> &lt;key&gt; &lt;flags&gt; &lt;expiration time&gt; &lt;bytes&gt;</span><br><span class="line">&lt;value&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#参数说明：</span></span><br><span class="line"><span class="built_in">command</span>：一般为<span class="built_in">set</span>/add/replace</span><br><span class="line">key：key 用于查找缓存值</span><br><span class="line">flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息</span><br><span class="line">expiration time：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）</span><br><span class="line">bytes：在缓存中存储的字节数</span><br><span class="line">value：存储的值（始终位于第二行）</span><br><span class="line"> </span><br><span class="line"><span class="comment">#如</span></span><br><span class="line"><span class="comment">#增加key，过期时间为秒，bytes为存储数据的字节数</span></span><br><span class="line">add key flags exptime bytes  </span><br></pre></td></tr></table></figure><h5 id="4-2-1-显示服务状态">4.2.1 显示服务状态</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#telnet 172.16.12.10 11211</span></span><br><span class="line">stats       <span class="comment">#显示服务状态</span></span><br><span class="line"> </span><br><span class="line">stats items <span class="comment">#显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。</span></span><br><span class="line"> </span><br><span class="line">stats slabs <span class="comment">#用于显示各个slab的信息，包括chunk的大小、数目、使用情况等</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527212638674.png" alt="image-20240527212638674"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527212646738.png" alt="image-20240527212646738"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527212656266.png" alt="image-20240527212656266"></p><h5 id="4-2-2-添加数据">4.2.2 添加数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#telnet 172.16.12.10 11211</span></span><br><span class="line">add name 1 10 5</span><br><span class="line">hello </span><br><span class="line"> </span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">add  添加</span><br><span class="line">name  键的名字</span><br><span class="line">1    flages标志，描述信息</span><br><span class="line">10   超时时间，默认0秒代表永久有效</span><br><span class="line">4    字节数，数据的大小</span><br><span class="line">hello 具体的值</span><br></pre></td></tr></table></figure><h5 id="4-2-3-修改数据">4.2.3 修改数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name 1 0 5</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改键名为name的键，flages标志位1，永不超时，且长度为5字节</span></span><br><span class="line"></span><br><span class="line">world</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改的内容为world</span></span><br></pre></td></tr></table></figure><h5 id="4-2-4-调用数据">4.2.4 调用数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用键名为name的数据</span></span><br></pre></td></tr></table></figure><h5 id="4-2-5-删除数据">4.2.5 删除数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete name</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除键名为name的数据</span></span><br></pre></td></tr></table></figure><h5 id="4-2-6-清空数据">4.2.6 清空数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush_all</span><br><span class="line"></span><br><span class="line"><span class="comment">#清空所有的数据</span></span><br></pre></td></tr></table></figure><h3 id="三、memcached-集群部署架构">三、memcached 集群部署架构</h3><h4 id="1、基于magent的部署架构">1、基于magent的部署架构</h4><p>Magent 是google开发的项目,应用端通过负载均衡服务器连接到 magent，然后再由 magent 代理用户应用请求到 memcached 处理，底层的 memcached 为双主结构会自动同步数据，本部署方式存在 magent 单点问题，因此需要两个 magent 做高可用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527212832617.png" alt="image-20240527212832617"></p><h4 id="2、Repcached实现原理">2、Repcached实现原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目站点：http://repcached.sourceforge.net/</span><br></pre></td></tr></table></figure><p>在 master上可以通过 -X 选项指定 replication port(默认为11212/tcp)，在 slave上通过 -x 指定复制的master并连接，事实上，如果同时指定了 -x/-X， repcached先会尝试连接对端的master，但如果连接失败，它就会用 -X参数来自己 listen（成为master）；如果 master坏掉， slave侦测到连接断了，它会自动 listen而成为 master；而如果 slave坏掉，master也会侦测到连接断开，它就会重新 listen等待新的 slave加入。</p><p>从这方案的技术实现来看，其实它是一个单 master单 slave的方案，但它的 master/slave都是可读写的，而且可以相互同步，所以从功能上看，也可以认为它是双机 master-master方案。</p><p><strong>简单说</strong></p><p>这段描述主要在解释repcached（一个memcached的复制版本）中的master-slave复制机制，以及如何通过-X和-x选项来设置复制端口和复制的master。</p><p>首先，我们可以将master和slave理解为一对伙伴，他们之间通过网络互相通信和协调工作。在repcached中，master负责提供数据，而slave则从master那里复制数据。</p><p>在启动repcached的时候，可以通过-X选项在master上指定复制端口（默认为11212/tcp），这个端口就像是master的“电话号码”，slave可以通过这个“电话号码”连接到master。同样，可以通过-x选项在slave上指定要复制的master，也就是告诉slave要向哪个master“打电话”。</p><p>有一个有趣的地方是，如果同时指定了-X和-x，repcached会先尝试作为slave连接到master，但如果连接失败，它就会变成master，开始等待别的slave来连接。</p><p>另外，repcached还有一个自动故障转移的特性。如果master坏掉了，slave会侦测到连接断了，然后它会自动变成master，开始等待新的slave加入。而如果slave坏掉了，master也会侦测到连接断开，它就会重新等待新的slave加入。</p><p>这种机制保证了当一方出现故障时，系统仍然可以继续运行，只不过角色会发生变化。这就是repcached的master-slave复制机制和故障转移机制。</p><h4 id="3、简化后的部署架构">3、简化后的部署架构</h4><p>magent 已经有很长时间没有更新，因此可以不再使用 magent，直接通过负载均衡连接到memcached，仍然有两台 memcached 做高可用，repcached 版本的 memcached 之间会自动同步数据，以保持数据一致性，即使其中的一台 memcached 故障也不影响业务正常运行，故障的memcached 修复上线后再自动从另外一台同步数据即可保持数据一致性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527213406322.png" alt="image-20240527213406322"></p><p>关注：和redis的对比，内存机制，libevent，分布式集群</p><p><strong>为什么memcached的QPS比redis高？</strong></p><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p>Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</p><hr><p>Memcached和Redis在设计和使用上都有一些不同，这些不同可能会影响它们的QPS（每秒查询率）。</p><p>Memcached可以利用多核处理器的优势，因为它可以在多个核心中运行多个线程。这使得Memcached在处理大量并发请求时，能够更好地分摊负载，从而提高了QPS。</p><p>而对于Redis来说，它是单线程的，只会使用一个核心。尽管Redis在小数据存储时的性能可能会优于Memcached，但在处理大数据时，尤其是在100k以上的数据中，Memcached的性能可能会更高。</p><p>因此，如果你的应用主要处理大型数据并且需要高并发，Memcached可能会是一个更好的选择，它的QPS可能会比Redis高。</p><p><strong>memcached关机数据就没有了</strong></p><p><strong>内存机制？</strong></p><p><strong>Memcacahed的Slab Allocation机制</strong></p><p>首先对于开发人员来说不匹配的malloc和free容易造成内存泄露；其次频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率；</p><p>然后作为系统调用，其系统开销远远大于一般函数调用。所以，为了提高内存的管理效率，高效的内存管理方案都不会直接使用malloc/free调用。</p><p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。</p><p>Slab Allocation机制只为<strong>存储外部数据</strong>而设计，也就是说所有的key-value数据都存储在Slab Allocation系统里，而Memcached的其它内存请求则通过普通的malloc/free来申请，因为这些请求的数量和频率决定了它们不会对整个系统的性能造成影响。</p><p><strong>Redis内存分配机制</strong></p><p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。</p><p><strong>集群与分布式方面？</strong></p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储，关于分布式一致性哈希算法见总结：【<strong>分布式一致性hash算法</strong>】。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><p><strong>Redis主从复制</strong></p><p>学习自：</p><p><a href="https://blog.csdn.net/m0_71815887/article/details/136722664">Memcached-分布式内存对象缓存系统</a></p><p><a href="https://www.cnblogs.com/Courage129/p/14331520.html">Memcached与Redis对比及其优劣分析</a></p>]]></content>
    
    
    <summary type="html">Memcached：一个高性能的分布式内存对象缓存系统</summary>
    
    
    
    <category term="数据库" scheme="https://penge666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://penge666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>libevent源码剖析</title>
    <link href="https://penge666.github.io/posts/32933883.html"/>
    <id>https://penge666.github.io/posts/32933883.html</id>
    <published>2024-05-24T11:02:48.000Z</published>
    <updated>2024-05-27T11:04:34.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-序幕">一 序幕</h2><h3 id="1-前言">1 前言</h3><p>libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分享心得；二则对libevent代码和设计思想做系统的、更深层次的分析，写出来，也可供后来者参考。</p><blockquote><p>libevent是用c语言编写的（MS大牛们都偏爱c语言哪），而且几乎是无处不函数指针，学习其源代码也需要相当的c语言基础。</p></blockquote><h3 id="2-libevent简介">2 libevent简介</h3><p>上来当然要先夸奖啦，libevent 有几个显著的亮点：<br>1）事件驱动（event-driven），高性能;<br>2）轻量级，专注于网络，不如ACE那么臃肿庞大；<br>3）源代码相当精炼、易读；<br>4）跨平台，支持Windows、Linux、*BSD和Mac Os；<br>5）支持多种I/O多路复用技术， epoll、poll、dev/poll、select和kqueue等；<br>6）支持I/O，定时器和信号等事件；<br>7）注册事件优先级；</p><p>libevent已经被广泛的应用，作为底层的网络库；比如memcached、Vomit、Nylon、Netchat等等。<br>libevent当前的最新稳定版是1.4.13；这也是本文参照的版本。</p><h3 id="3-学习的好处">3 学习的好处</h3><p>学习libevent有助于提升程序设计功力，除了网络程序设计方面外，libevent的代码里有很多有用的设计技巧和基础数据结构，比如信息隐藏、函数指针、c语言的多态支持、链表和堆等等，都有助于提升自身的程序功力。</p><p>程序设计不止要了解框架，很多细节之处恰恰也是事关整个系统成败的关键。只对libevent本身的框架大概了解，那或许仅仅是一知半解，不深入代码分析，就难以了解其设计的精巧之处，也就难以为自己所用。</p><p>事实上libevent本身就是一个典型的Reactor模型，理解Reactor模式是理解libevent的基石；因此下一节将介绍典型的事件驱动设计模式—Reactor模式。</p><p>参考资料：<br>libevent: <a href="http://monkey.org/~provos/libevent/">http://monkey.org/~provos/libevent/</a></p><h2 id="二-reactor模式">二 reactor模式</h2><p>前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，并列出libevent中的几个重要组件和Reactor的对应关系，在后面的章节中可能还会提到本节介绍的基本概念。</p><h3 id="1-reactor的事件处理机制">1 reactor的事件处理机制</h3><p>首先来回想一下普通函数调用的机制：程序调用某函数?函数执行，程序等待?函数将结果和控制权返回给程序?程序继续处理。</p><p>reactor释义“反应堆”，是一种事件驱动机制。和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到reactor上，如果相应的时间发生，reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。使用libevent也是想libevent框架注册相应的事件和回调函数；当这些时间发声时，libevent会调用这些回调函数处理相应的事件（I/O读写、定时和信号）。用“<strong>好莱坞原则</strong>”来形容reactor再合适不过了：<strong>不要打电话给我们，我们会打电话通知你。</strong></p><p>举个例子：你去应聘某xx公司，面试结束后。“普通函数调用机制”公司HR比较懒，不会记你的联系方式，那怎么办呢，你只能面试完后自己打电话去问结果；有没有被录取啊，还是被据了；</p><p>“reactor”公司HR就记下了你的联系方式，结果出来后会主动打电话通知你：有没有被录取啊，还是被据了；你不用自己打电话去问结果，事实上也不能，你没有HR的留联系方式。</p><h3 id="2-reactor模式的优点">2 reactor模式的优点</h3><p>reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：<br>1）响应快，不必为单个同步时间所阻塞，虽然reactor本身依然是同步的；<br>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；<br>3）可扩展性，可以方便的通过增加reactor实例个数来充分利用CPU资源；<br>4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p><h3 id="3-reactor模式框架">3 reactor模式框架</h3><p>使用reactor模型，必备的几个组件：事件源、reactor框架、多路复用机制和事件处理程序，先来看看reactor模型的整体框架，接下来再对每个组件做逐一说明。</p><p><img src="https://img-blog.csdnimg.cn/20200413154107911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hwMTc4MTcxNjQw,size_16,color_FFFFFF,t_70" alt="components"></p><p>1）事件源<br>Linux上是文件描述符，Windows上就是Socket或者Handle了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I/O事件。</p><p>2）event demultiplexer——事件多路分发机制<br>由操作系统提供的I/O多路复用机制，比如select和epoll。程序首先将其关心的句柄（事件源）及其事件注册到event demultiplexer上；<br>当有事件到达时，event demultiplexer会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”；程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。对应到libevent中，依然是select、poll、epoll等，但是libevent使用结构体eventop进行了封装，以统一的接口来支持这些I/O多路复用机制，达到了对外隐藏底层系统机制的目的。</p><p>3）reactor——反应器<br>reactor，是事件管理的接口，内部使用event demultiplexer注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到libevent中，就是event_base结构体。一个典型的Reactor声明方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reactor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">register_handler</span><span class="params">(Event_Handler *pHandler, <span class="type">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove_handler</span><span class="params">(Event_Handler *pHandler, <span class="type">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_events</span><span class="params">(timeval *ptv)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反应器的理解：</p><p>这段代码是描述了一个典型的Reactor（反应器）设计模式在事件驱动编程中的应用。</p><p>Reactor设计模式是一种事件处理模式，用于处理服务请求，这些服务请求被发送至一个或多个服务处理程序。</p><p>在这个类中：</p><ul><li><code>register_handler</code>方法用于注册事件处理程序，当某个事件发生时，将调用该事件处理程序。</li><li><code>remove_handler</code>方法用于移除事件处理程序，不再对该事件进行处理。</li><li><code>handle_events</code>方法是事件循环，用于处理所有已经就绪的事件。</li></ul><p>通俗易懂的说，Reactor就像是一个电话交换员或者邮局。当有电话打入或者邮件发送到邮局时，交换员或者邮局就会根据电话或者邮件的目的地，将它们转发给对应的接收者。在这个过程中，电话交换员或者邮局就扮演了Reactor的角色，电话或者邮件就是事件，接收者就是事件处理程序。当电话打入或者邮件到达时（事件发生），交换员或者邮局就会调用对应的接收者（事件处理程序）来处理电话或者邮件（处理事件）。</p><p>4）Event Handler——事件处理程序<br>事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。对应到libevent中，就是event结构体。</p><p>下面是两种典型的Event Handler类声明方式，二者互有优缺点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Event_Handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_read</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_write</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_timeout</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_close</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HANDLE <span class="title">get_handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event_Handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// events maybe read/write/timeout/close .etc</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_events</span><span class="params">(<span class="type">int</span> events)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HANDLE <span class="title">get_handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-reactor事件处理流程">4 reactor事件处理流程</h3><p>前面说过reactor将事件流“逆置”了，那么使用reactor模式后，事件控制流是什么样子呢？<br>可以参见下面的序列图。</p><p><img src="https://img-blog.csdnimg.cn/20200413154228432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hwMTc4MTcxNjQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-小结">5 小结</h3><p>上面讲到了reactor的基本概念、框架和处理流程，对reactor有个基本清晰的了解后，再来对比看libevent就会更容易理解了，接下来就正式进入到libevent的代码世界了，加油！</p><p>参考资料：<br>Pattern-Oriented Software Architecture, Patterns for Concurrent and Networked Objects, Volume 2</p><h2 id="三-libevent基本使用场景和事件流程">三 libevent基本使用场景和事件流程</h2><h3 id="1-前言-2">1 前言</h3><p>学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不错的方法，至少从个人的经验上讲，用此方法分析libevent是比较有效的。</p><h3 id="2-基本应用场景">2 基本应用场景</h3><p>基本应用场景也是使用libevnet的基本流程，下面来考虑一个最简单的场景，使用livevent设置定时器，应用程序只需要执行下面几个简单的步骤即可。</p><p>1）首先初始化libevent库，并保存返回的指针<br><code>struct event_base * base = event_init();</code>实际上这一步相当于初始化一个reactor实例；在初始化libevent后，就可以注册事件了。</p><p>2）初始化事件event，设置回调函数和关注的事件<br><code>evtimer_set(&amp;ev, timer_cb, NULL);</code>事实上这等价于调用<code>event_set(&amp;ev, -1, 0, timer_cb, NULL);</code><br>event_set的函数原型是：<br><code>void event_set(struct event *ev, int fd, short event, void (*cb)(int, short, void *), void *arg)</code><br>ev：执行要初始化的event对象；<br>fd：该event绑定的“句柄”，对于信号事件，它就是关注的信号；<br>event：在该fd上关注的事件类型，它可以是EV_READ, EV_WRITE, EV_SIGNAL；<br>cb：这是一个函数指针，当fd上的事件event发生时，调用该函数执行处理，它有三个参数，调用时由event_base负责传入，按顺序，实际上就是event_set时的fd, event和arg；<br>arg：传递给cb函数指针的参数；<br>由于定时事件不需要fd，并且定时事件是根据添加时（event_add）的超时值设定的，因此这里event也不需要设置。这一步相当于初始化一个event handler，在libevent中事件类型保存在event结构体中。<br>注意：libevent并不会管理event事件集合，这需要应用程序自行管理；</p><p>3）设置event从属的event_base<br><code>event_base_set(base, &amp;ev);</code><br>这一步相当于指明event要注册到哪个event_base实例上；</p><p>4）是正式的添加事件的时候了<br><code>event_add(&amp;ev, timeout);</code><br>基本信息都已设置完成，只要简单的调用event_add()函数即可完成，其中timeout是定时值；<br>这一步相当于调用Reactor::register_handler()函数注册事件。</p><p>5）程序进入无限循环，等待就绪事件并执行事件处理<br><code>event_base_dispatch(base);</code></p><h3 id="3-实例代码">3 实例代码</h3><p>上面例子的程序代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> ev;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span> *argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timer wakeup/n&quot;</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv); <span class="comment">// reschedule timer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">event_init</span>();</span><br><span class="line">    tv.tv_sec = <span class="number">10</span>; <span class="comment">// 10s period</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">evtimer_set</span>(&amp;ev, time_cb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv);</span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-事件处理流程">4 事件处理流程</h3><p>当应用程序向libevent注册一个事件后，libevent内部是怎么样进行处理的呢？下面的图就给出了这一基本流程。</p><p><img src="https://img-blog.csdnimg.cn/20200413215432528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hwMTc4MTcxNjQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1）首先应用程序准备并初始化event，设置好事件类型和回调函数；这对应于前面第步骤2和3；<br>2）向libevent添加该事件event。对于定时事件，libevent使用一个小根堆管理，key为超时时间；对于Signal和I/O事件，libevent将其放入到等待链表（wait list）中，这是一个双向链表结构；<br>3）程序调用event_base_dispatch()系列函数进入无限循环，等待事件，以select()函数为例；每次循环前libevent会检查定时事件的最小超时时间tv，根据tv设置select()的最大等待时间，以便于后面及时处理超时事件；当select()返回后，首先检查超时事件，然后检查I/O事件；libevent将所有的就绪事件，放入到激活链表中；然后对激活链表中的事件，调用事件的回调函数执行事件处理；、</p><p><strong>解释1</strong>：每次循环前libevent会检查定时事件的最小超时时间tv，根据tv设置select()的最大等待时间，以便于后面及时处理超时事件。</p><p>【重点】举个例子，假设我们有一个定时事件，10秒后触发。我们调用event_base_dispatch开始事件循环，然后libevent检查定时事件的最小超时时间，发现是10秒后。于是，libevent调用select函数，设置最大等待时间为10秒。10秒后，即使没有I/O事件发生，select函数也会返回，然后libevent就知道这个定时事件已经就绪，就会调用相应的回调函数处理这个定时事件。</p><h3 id="5-小结-2">5 小结</h3><p>本节介绍了libevent的简单实用场景，并介绍了libevent的事件处理流程，读者应该对libevent有了基本的印象，下面将会详细介绍libevent的事件管理框架（reactor模式中的reactor框架），在此之前会对源代码文件做简单的分类。</p><h2 id="四-libevent源代码文件组织">四 libevent源代码文件组织</h2><h3 id="1-前言-3">1 前言</h3><p>详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，但并不是说它不重要！</p><h3 id="2-源代码组织结构">2 源代码组织结构</h3><p>libevent的源代码虽然都在一层文件夹下面，但是其代码分类还是相当清晰的，主要可分为头文件、内部使用的头文件、辅助功能函数、日志、libevent框架、对系统I/O多路复用机制的封装、信号管理、定时事件管理、缓冲区管理、基本数据结构和基于libevent的两个实用库等几个部分，有些部分可能就是一个源文件。</p><p>源代码中的test部分就不在我们关注的范畴了。<br>1）头文件<br>主要就是<strong>event.h</strong>：事件宏定义、接口函数声明，主要结构体event的声明；</p><p>2）内部头文件<br><strong>xxx-internal.h</strong>：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；</p><p>3）libevent框架<br><strong>event.c</strong>：event整体框架的代码实现；</p><p>4）对系统I/O多路复用机制的封装<br><strong>epoll.c</strong>：对epoll的封装；<br><strong>select.c</strong>：对select的封装；<br><strong>devpoll.c</strong>：对dev/poll的封装;<br><strong>kqueue.c</strong>：对kqueue的封装；</p><p>5）定时事件管理<br><strong>min-heap.h</strong>：其实就是一个以时间作为key的小根堆结构；</p><p>6）信号管理<br><strong>signal.c</strong>：对信号事件的处理；</p><p>7）辅助功能函数<br><strong>evutil.h 和evutil.c</strong>：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。</p><p>8）日志<br>log.h和log.c：log日志函数</p><p>9）缓冲区管理<br><strong>evbuffer.c</strong>和<strong>buffer.c</strong>：libevent对缓冲区的封装；</p><p>10）基本数据结构<br>compat/sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；</p><p>11）实用网络库<br>http和evdns：是基于libevent实现的http服务器和异步dns查询库；</p><h3 id="3-小结">3 小结</h3><p>本节介绍了libevent的组织和分类，下面将会详细介绍libevent的核心部分event结构。</p><h2 id="五-libevent的核心：事件event">五 libevent的核心：事件event</h2><p>对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理。</p><h3 id="1-libevent的核心-event">1 libevent的核心-event</h3><p>libevent是基于事件驱动（event-driven）的，从名字也可以看到event是整个库的核心。event就是reactor框架中的事件处理程序组件；它提供了函数接口，供reactor在事件发生时调用，以执行相应的事件处理，通常它会绑定一个有效的句柄。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TAILQ_ENTRY</span> (event) ev_next;</span><br><span class="line"><span class="built_in">TAILQ_ENTRY</span> (event) ev_active_next;</span><br><span class="line"><span class="built_in">TAILQ_ENTRY</span> (event) ev_signal_next;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> min_heap_idx; <span class="comment">/* for managing timeouts */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span> *ev_base;</span><br><span class="line"><span class="type">int</span> ev_fd;</span><br><span class="line"><span class="type">short</span> ev_events;</span><br><span class="line"><span class="type">short</span> ev_ncalls;</span><br><span class="line"><span class="type">short</span> *ev_pncalls; <span class="comment">/* Allows deletes in callback */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> ev_timeout;</span><br><span class="line"><span class="type">int</span> ev_pri;  <span class="comment">/* smaller numbers are higher priority */</span></span><br><span class="line"><span class="built_in">void</span> (*ev_callback)(<span class="type">int</span>, <span class="type">short</span>, <span class="type">void</span> *arg);</span><br><span class="line"><span class="type">void</span> *ev_arg;</span><br><span class="line"><span class="type">int</span> ev_res;  <span class="comment">/* result passed to event callback */</span></span><br><span class="line"><span class="type">int</span> ev_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先给出event结构体的声明，它位于event.h文件中：</p><p>下面简单解释一下结构体中各字段的含义。</p><p>1）<strong>ev_events</strong>：event关注的事件类型，它可以是以下3种类型：<br>I/O事件： EV_WRITE和EV_READ<br>定时事件：EV_TIMEOUT<br>信号： EV_SIGNAL<br>辅助选项：EV_PERSIST，表明是一个永久事件</p><p>libevent中的定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_TIMEOUT 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_READ    0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_WRITE   0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SIGNAL  0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PERSIST 0x10 <span class="comment">/* Persistant event */</span></span></span><br></pre></td></tr></table></figure><p>可以看出事件类型可以使用“|”运算符进行组合，需要说明的是，信号和I/O事件不能同时设置；还可以看出libevent使用event结构体将这3种事件的处理统一起来；</p><p>2）<strong>ev_next</strong>，<strong>ev_active_nex</strong>t和<strong>ev_signal_next</strong>都是双向链表节点指针；它们是libevent对不同事件类型和在不同的时期，对事件的管理时使用到的字段。libevent使用双向链表保存所有注册的I/O和Signal事件，ev_next就是该I/O事件在链表中的位置；称此链表为“已注册事件链表”；同样ev_signal_next就是signal事件在signal事件链表中的位置；ev_active_next：libevent将所有的激活事件放入到链表active list中，然后遍历active list执行调度，ev_active_next就指明了event在active list中的位置；</p><p>2）<strong>min_heap_idx</strong>和<strong>ev_timeout</strong>，如果是timeout事件，它们是event在小根堆中的索引和超时值，libevent使用小根堆来管理定时事件，这将在后面定时事件处理时专门讲解。</p><p>3）<strong>ev_base</strong>该事件所属的反应堆实例，这是一个event_base结构体，下一节将会详细讲解；</p><p>4）<strong>ev_fd</strong>，对于I/O事件，是绑定的文件描述符；对于signal事件，是绑定的信号；</p><p>5）<strong>ev_callback</strong>，event的回调函数，被ev_base调用，执行事件处理程序，这是一个函数指针，原型为：<br><code>void (*ev_callback)(int fd, short events, void *arg);</code>其中参数fd对应于ev_fd；events对应于ev_events；arg对应于ev_arg；</p><p>6）<strong>ev_arg</strong>：void*，表明可以是任意类型的数据，在设置event时指定；</p><p>7）<strong>eb_flags</strong>：libevent用于标记event信息的字段，表明其当前的状态，可能的值有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_TIMEOUT  0x01 <span class="comment">// event在time堆中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_INSERTED 0x02 <span class="comment">// event在已注册事件链表中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_SIGNAL   0x04 <span class="comment">// 未见使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_ACTIVE   0x08 <span class="comment">// event在激活链表中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_INTERNAL 0x10 <span class="comment">// 内部使用标记</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVLIST_INIT     0x80 <span class="comment">// event已被初始化</span></span></span><br></pre></td></tr></table></figure><p>8）<strong>ev_ncalls</strong>：事件就绪执行时，调用ev_callback的次数，通常为1；</p><p>9）<strong>ev_pncalls</strong>：指针，通常指向ev_ncalls或者为NULL；</p><p>10）<strong>ev_res</strong>：记录了当前激活事件的类型；</p><h3 id="2-libevent对event的管理">2 libevent对event的管理</h3><p>从event结构体中的3个链表节点指针和一个堆索引出发，大体上也能窥出libevent对event的管理方法了，可以参见下面的示意图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240526115502487.png" alt="image-20240526115502487"></p><p>每次当有事件event转变为就绪状态时，libevent就会把它移入到active event list[priority]中，其中priority是event的优先级；接着libevent会根据自己的调度策略选择就绪事件，调用其cb_callback()函数执行事件处理；并根据就绪的句柄和事件类型填充cb_callback函数的参数。</p><h3 id="3-事件设置的接口函数">3 事件设置的接口函数</h3><p>要向libevent添加一个事件，需要首先设置event对象，这通过调用libevent提供的函数有：event_set(), event_base_set(), event_priority_set()来完成；下面分别进行讲解。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set</span>(<span class="params"><span class="keyword">struct</span> <span class="keyword">event</span> *ev, <span class="built_in">int</span> fd, <span class="built_in">short</span> events, <span class="keyword">void</span> (*callback</span>)(<span class="params"><span class="built_in">int</span>, <span class="built_in">short</span>, <span class="keyword">void</span> *</span>), <span class="keyword">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>1）设置事件ev绑定的文件描述符或者信号，对于定时事件，设为-1即可；<br>2）设置事件类型，比如EV_READ|EV_PERSIST, EV_WRITE, EV_SIGNAL等；<br>3）设置事件的回调函数以及参数arg；<br>4）初始化其它字段，比如缺省的event_base和优先级；</p><p><code>int event_base_set(struct event_base *base, struct event *ev)</code><br>设置event ev将要注册到的event_base；libevent有一个全局event_base指针current_base，默认情况下事件ev将被注册到current_base上，使用该函数可以指定不同的event_base；如果一个进程中存在多个libevent实例，则必须要调用该函数为event设置不同的event_base；</p><p><code>int event_priority_set(struct event *ev, int pri);</code><br>设置event ev的优先级，没什么可说的，注意的一点就是：当ev正处于就绪状态时，不能设置，返回-1。</p><h3 id="4-小结">4 小结</h3><p>本节讲述了libevent的核心event结构，以及libevent支持的事件类型和libevent对event的管理模型；接下来将会描述libevent的事件处理框架，以及其中使用的重要的结构体event_base；</p><h2 id="六-初见事件处理框架">六 初见事件处理框架</h2><p>前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细处理流程了，本节将分析libevent的事件处理框架event_base和libevent注册、删除事件的具体流程，可结合前一节libevent对event的管理。</p><h3 id="1-事件处理框架-event-base">1 事件处理框架-event_base</h3><p>回想Reactor模式的几个基本组件，本节讲解的部分对应于reactor框架组件。在libevent中，这就表现为event_base结构体，结构体声明如下，它位于event-internal.h文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *evsel;</span><br><span class="line"> <span class="type">void</span> *evbase;　</span><br><span class="line"> <span class="type">int</span> event_count;  <span class="comment">/* counts number of total events */</span></span><br><span class="line"> <span class="type">int</span> event_count_active; <span class="comment">/* counts number of active events */</span></span><br><span class="line"> <span class="type">int</span> event_gotterm;  <span class="comment">/* Set to terminate loop */</span></span><br><span class="line"> <span class="type">int</span> event_break;  <span class="comment">/* Set to terminate loop immediately */</span></span><br><span class="line"> <span class="comment">/* active event management */</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">event_list</span> **activequeues;</span><br><span class="line"> <span class="type">int</span> nactivequeues;</span><br><span class="line"> <span class="comment">/* signal handling info */</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">evsignal_info</span> sig;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">event_list</span> eventqueue;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">timeval</span> event_tv;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">min_heap</span> timeheap;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">timeval</span> tv_cache;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面详细解释一下结构体中各字段的含义。</p><p>1）<strong>evsel</strong>和<strong>evbase</strong>这两个字段的设置可能会让人有些迷惑，这里你可以把evsel和evbase看作是类和静态函数的关系，比如添加事件时的调用行为：evsel-&gt;add(evbase, ev)，实际执行操作的是evbase；这相当于class::add(instance, ev)，instance就是class的一个对象实例。<br>evsel指向了全局变量static const struct eventop *eventops[]中的一个；</p><p>前面也说过，libevent将系统提供的I/O demultiplex机制统一封装成了eventop结构；因此eventops[]包含了select、poll、kequeue和epoll等等其中的若干个全局实例对象。evbase实际上是一个eventop实例对象；先来看看eventop结构体，它的成员是一系列的函数指针, 在event-internal.h文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventop</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">void</span> *(*init)(<span class="keyword">struct</span> event_base *); <span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">int</span> (*add)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 注册事件</span></span><br><span class="line"><span class="built_in">int</span> (*del)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 删除事件</span></span><br><span class="line"><span class="built_in">int</span> (*dispatch)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *, <span class="keyword">struct</span> timeval *); <span class="comment">// 事件分发</span></span><br><span class="line"><span class="built_in">void</span> (*dealloc)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *); <span class="comment">// 注销，释放资源</span></span><br><span class="line"><span class="comment">/* set if we need to reinitialize the event base */</span></span><br><span class="line"><span class="type">int</span> need_reinit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说，在libevent中，每种I/O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I/O demultiplex机制了，这个在后面会再次提到。</p><p>2）<strong>activequeues</strong>是一个二级指针，前面讲过libevent支持事件优先级，因此你可以把它看作是数组，其中的元素activequeues[priority]是一个链表，链表的每个节点指向一个优先级为priority的就绪事件event。</p><p>3）<strong>eventqueue</strong>，链表，保存了所有的注册事件event的指针。</p><p>4）<strong>sig</strong>是由来管理信号的结构体，将在后面信号处理时专门讲解；</p><p>5）<strong>timeheap</strong>是管理定时事件的小根堆，将在后面定时事件处理时专门讲解；</p><p>6）<strong>event_tv</strong>和<strong>tv_cache</strong>是libevent用于时间管理的变量，将在后面讲到；</p><p>其它各个变量都能因名知意，就不再啰嗦了。</p><h3 id="2-创建和初始化event-base">2 创建和初始化event_base</h3><p>创建一个event_base对象也既是创建了一个新的libevent实例，程序需要通过调用<code>event_init()</code>（内部调用event_base_new函数执行具体操作）函数来创建，该函数同时还对新生成的libevent实例进行了初始化。该函数首先为event_base实例申请空间，然后初始化timer mini-heap，选择并初始化合适的系统I/O 的demultiplexer机制，初始化各事件链表；函数还检测了系统的时间设置，为后面的时间管理打下基础。</p><h3 id="3-接口函数">3 接口函数</h3><p>前面提到reactor框架的作用就是提供事件的注册、注销接口；根据系统提供的事件多路分发机制执行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数来处理事件。libevent中对应的接口函数主要就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">event_add</span><span class="params">(<span class="keyword">struct</span> event *ev, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">event_del</span><span class="params">(<span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> loops)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_active</span><span class="params">(<span class="keyword">struct</span> event *event, <span class="type">int</span> res, <span class="type">short</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_process_active</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span></span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>本节将按介绍事件注册和删除的代码流程，libevent的事件循环框架将在下一节再具体描述。<br>对于定时事件，这些函数将调用timer heap管理接口执行插入和删除操作；对于I/O和Signal事件将调用eventopadd和delete接口函数执行插入和删除操作（eventop会对Signal事件调用Signal处理接口执行操作）；这些组件将在后面的内容描述。</p><p>1）注册事件<br>函数原型：<code>int event_add(struct event *ev, const struct timeval *tv);</code><br>参数：<br>ev：指向要注册的事件；<br>tv：超时时间；<br>函数将ev注册到ev-&gt;ev_base上，事件类型由ev-&gt;ev_events指明，如果注册成功，ev将被插入到已注册链表中；如果tv不是NULL，则会同时注册定时事件，将ev添加到timer堆上；<br>如果其中有一步操作失败，那么函数保证没有事件会被注册，可以讲这相当于一个原子操作。这个函数也体现了libevent细节之处的巧妙设计，且仔细看程序代码，部分有省略，注释直接附在代码中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_add</span><span class="params">(<span class="keyword">struct</span> event *ev, <span class="type">const</span> <span class="keyword">struct</span> timeval *tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span> *base = ev-&gt;ev_base; <span class="comment">// 要注册到的event_base</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *evsel = base-&gt;evsel;</span><br><span class="line"><span class="type">void</span> *evbase = base-&gt;evbase; <span class="comment">// base使用的系统I/O策略</span></span><br><span class="line"> <span class="comment">// 新的timer事件，调用timer heap接口在堆上预留一个位置</span></span><br><span class="line"> <span class="comment">// 注：这样能保证该操作的原子性：</span></span><br><span class="line"> <span class="comment">// 向系统I/O机制注册可能会失败，而当在堆上预留成功后，</span></span><br><span class="line"> <span class="comment">// 定时事件的添加将肯定不会失败；</span></span><br><span class="line"> <span class="comment">// 而预留位置的可能结果是堆扩充，但是内部元素并不会改变</span></span><br><span class="line"><span class="keyword">if</span> (tv != <span class="literal">NULL</span> &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">min_heap_reserve</span>(&amp;base-&gt;timeheap,</span><br><span class="line"><span class="number">1</span> + <span class="built_in">min_heap_size</span>(&amp;base-&gt;timeheap)) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);  <span class="comment">/* ENOMEM == errno */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果事件ev不在已注册或者激活链表中，则调用evbase注册事件</span></span><br><span class="line"><span class="keyword">if</span> ((ev-&gt;ev_events &amp; (EV_READ | EV_WRITE | EV_SIGNAL)) &amp;&amp;</span><br><span class="line">!(ev-&gt;ev_flags &amp; (EVLIST_INSERTED | EVLIST_ACTIVE))) &#123;</span><br><span class="line">res = evsel-&gt;<span class="built_in">add</span>(evbase, ev);</span><br><span class="line"><span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="comment">// 注册成功，插入event到已注册链表中</span></span><br><span class="line"><span class="built_in">event_queue_insert</span>(base, ev, EVLIST_INSERTED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 准备添加定时事件</span></span><br><span class="line"><span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; tv != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> now;</span><br><span class="line"><span class="comment">// EVLIST_TIMEOUT表明event已经在定时器堆中了，删除旧的</span></span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)</span><br><span class="line"><span class="built_in">event_queue_remove</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line"><span class="comment">// 如果事件已经是就绪状态则从激活链表中删除</span></span><br><span class="line"><span class="keyword">if</span> ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;</span><br><span class="line">(ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123;</span><br><span class="line"><span class="comment">// 将ev_callback调用次数设置为0</span></span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;</span><br><span class="line">*ev-&gt;ev_pncalls = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">event_queue_remove</span>(base, ev, EVLIST_ACTIVE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算时间，并插入到timer小根堆中</span></span><br><span class="line"><span class="built_in">gettime</span>(base, &amp;now);</span><br><span class="line"><span class="built_in">evutil_timeradd</span>(&amp;now, tv, &amp;ev-&gt;ev_timeout);</span><br><span class="line"><span class="built_in">event_queue_insert</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">event_queue_insert</span>()负责将事件插入到对应的链表中，下面是程序代码；</span><br><span class="line"><span class="built_in">event_queue_remove</span>()负责将事件从对应的链表中删除，这里就不再重复贴代码了；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_queue_insert</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> event *ev, <span class="type">int</span> queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ev可能已经在激活列表中了，避免重复插入</span></span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_flags &amp; queue) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue &amp; EVLIST_ACTIVE)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ev-&gt;ev_flags |= queue; <span class="comment">// 记录queue标记</span></span><br><span class="line"><span class="keyword">switch</span> (queue) &#123;</span><br><span class="line"><span class="keyword">case</span> EVLIST_INSERTED: <span class="comment">// I/O或Signal事件，加入已注册事件链表</span></span><br><span class="line"><span class="built_in">TAILQ_INSERT_TAIL</span>(&amp;base-&gt;eventqueue, ev, ev_next);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVLIST_ACTIVE: <span class="comment">// 就绪事件，加入激活链表</span></span><br><span class="line">base-&gt;event_count_active++;</span><br><span class="line"><span class="built_in">TAILQ_INSERT_TAIL</span>(base-&gt;activequeues[ev-&gt;ev_pri], ev, ev_active_next);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVLIST_TIMEOUT: <span class="comment">// 定时事件，加入堆</span></span><br><span class="line"><span class="built_in">min_heap_push</span>(&amp;base-&gt;timeheap, ev);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）删除事件：<br>函数原型为：int event_del(struct event *ev);<br>该函数将删除事件ev，对于I/O事件，从I/O 的demultiplexer上将事件注销；对于Signal事件，将从Signal事件链表中删除；对于定时事件，将从堆上删除；<br>同样删除事件的操作则不一定是原子的，比如删除时间事件之后，有可能从系统I/O机制中注销会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_del</span><span class="params">(<span class="keyword">struct</span> event *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span> *base;</span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *evsel;</span><br><span class="line"><span class="type">void</span> *evbase;</span><br><span class="line"><span class="comment">// ev_base为NULL，表明ev没有被注册</span></span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_base == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 取得ev注册的event_base和eventop指针</span></span><br><span class="line">base = ev-&gt;ev_base;</span><br><span class="line">evsel = base-&gt;evsel;</span><br><span class="line">evbase = base-&gt;evbase;</span><br><span class="line"><span class="comment">// 将ev_callback调用次数设置为</span></span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;</span><br><span class="line">*ev-&gt;ev_pncalls = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从对应的链表中删除</span></span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)</span><br><span class="line"><span class="built_in">event_queue_remove</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE)</span><br><span class="line"><span class="built_in">event_queue_remove</span>(base, ev, EVLIST_ACTIVE);</span><br><span class="line"><span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_INSERTED) &#123;</span><br><span class="line"><span class="built_in">event_queue_remove</span>(base, ev, EVLIST_INSERTED);</span><br><span class="line"><span class="comment">// EVLIST_INSERTED表明是I/O或者Signal事件，</span></span><br><span class="line"><span class="comment">// 需要调用I/O demultiplexer注销事件</span></span><br><span class="line"><span class="keyword">return</span> (evsel-&gt;<span class="built_in">del</span>(evbase, ev));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-小节">4 小节</h3><p>分析了event_base这一重要结构体，初步看到了libevent对系统的I/O demultiplex机制的封装event_op结构，并结合源代码分析了事件的注册和删除处理，下面将会接着分析事件管理框架中的主事件循环部分。</p><h2 id="七-事件主循环">七 事件主循环</h2><p><strong>事件主循环</strong></p><p>现在我们已经初步了解了libevent的Reactor组件——<strong>event_base</strong>和<strong>事件管理框架</strong>，接下来就是libevent事件处理的中心部分——<strong>事件主循环</strong>，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。</p><h3 id="1-阶段性的胜利">1. 阶段性的胜利</h3><p>libevent将I/O事件、定时器和信号事件处理很好的结合到了一起，本节也会介绍libevent是如何做到这一点的。<br>在看完本节的内容后，读者应该会对Libevent的基本框架：事件管理和主循环有比较清晰的认识了，并能够把libevent的事件控制流程清晰的串通起来，剩下的就是一些细节的内容了。</p><h3 id="2-事件处理主循环">2. 事件处理主循环</h3><p>libevent的事件主循环主要是通过**event_base_loop ()**函数完成的，其主要操作如下面的流程图所示，<strong>event_base_loop</strong>所作的就是持续执行下面的循环。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240526121015838.png" alt="image-20240526121015838"></p><p>清楚了event_base_loop所作的主要操作，就可以对比源代码看个究竟了，代码结构还是相当清晰的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> =</span> base-&gt;evsel;</span><br><span class="line">    <span class="type">void</span> *evbase = base-&gt;evbase;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="type">int</span> res, done;</span><br><span class="line">    <span class="comment">// 清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;sig.ev_signal_added)</span><br><span class="line">        evsignal_base = base;</span><br><span class="line">    done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123; <span class="comment">// 事件主循环</span></span><br><span class="line">        <span class="comment">// 查看是否需要跳出循环，程序可以调用event_loopexit_cb()设置event_gotterm标记</span></span><br><span class="line">        <span class="comment">// 调用event_base_loopbreak()设置event_break标记</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_gotterm) &#123;</span><br><span class="line">            base-&gt;event_gotterm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_break) &#123;</span><br><span class="line">            base-&gt;event_break = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校正系统时间，如果系统使用的是非MONOTONIC时间，用户可能会向后调整了系统时间</span></span><br><span class="line">        <span class="comment">// 在timeout_correct函数里，比较last wait time和当前时间，如果当前时间&lt; last wait time</span></span><br><span class="line">        <span class="comment">// 表明时间有问题，这是需要更新timer_heap中所有定时事件的超时时间。</span></span><br><span class="line">        timeout_correct(base, &amp;tv);</span><br><span class="line">        <span class="comment">// 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间</span></span><br><span class="line">        tv_p = &amp;tv;</span><br><span class="line">        <span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class="line">            timeout_next(base, &amp;tv_p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 依然有未处理的就绪时间，就让I/O demultiplexer立即返回，不必等待</span></span><br><span class="line">            <span class="comment">// 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理</span></span><br><span class="line">            evutil_timerclear(&amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前没有注册事件，就退出</span></span><br><span class="line">        <span class="keyword">if</span> (!event_haveevents(base)) &#123;</span><br><span class="line">            event_debug((<span class="string">&quot;%s: no events registered.&quot;</span>, __func__));</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新last wait time，并清空time cache</span></span><br><span class="line">        gettime(base, &amp;base-&gt;event_tv);</span><br><span class="line">        base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；</span></span><br><span class="line">        <span class="comment">// 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中</span></span><br><span class="line">        res = evsel-&gt;dispatch(base, evbase, tv_p);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 将time cache赋值为当前系统时间</span></span><br><span class="line">        gettime(base, &amp;base-&gt;tv_cache);</span><br><span class="line">        <span class="comment">// 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中</span></span><br><span class="line">        timeout_process(base);</span><br><span class="line">        <span class="comment">// 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理</span></span><br><span class="line">        <span class="comment">// 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，</span></span><br><span class="line">        <span class="comment">// 然后处理链表中的所有就绪事件；</span></span><br><span class="line">        <span class="comment">// 因此低优先级的就绪事件可能得不到及时处理；</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_count_active) &#123;</span><br><span class="line">            event_process_active(base);</span><br><span class="line">            <span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; (flags &amp; EVLOOP_ONCE))</span><br><span class="line">                done = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; EVLOOP_NONBLOCK)</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束，清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    event_debug((<span class="string">&quot;%s: asked to terminate loop.&quot;</span>, __func__));</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-I-O和Timer事件的统一">3. I/O和Timer事件的统一</h3><p>libevent将Timer和Signal事件都统一到了系统的I/O 的<strong>demultiplex</strong>机制中了，相信读者从上面的流程和代码中也能窥出一斑了，下面就再啰嗦一次了。<br>首先将Timer事件融合到系统I/O多路复用机制中，还是相当清晰的，因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）<strong>timeout</strong>，即使没有I/O事件发生，它们也保证能在timeout时间内返回。<br>那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。<br>这是在Reactor和Proactor模式（主动器模式，比如Windows上的IOCP）中处理Timer事件的经典方法了，ACE采用的也是这种方法，大家可以参考POSA vol2书中的Reactor模式一节。<br>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选（当然是非唯一的），libevent就是采用的堆结构。</p><h3 id="4-I-O和Signal事件的统一">4. I/O和Signal事件的统一</h3><p>Signal是异步事件的经典事例，将Signal事件统一到系统的I/O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。<br>如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理，不就可以了嘛。是的，这也是libevent中使用的方法。<br>问题的核心在于，当Signal发生时，如何通知系统的I/O多路复用机制，这里先买个小关子，放到信号处理一节再详细说明，我想读者肯定也能想出通知的方法，比如使用<strong>pipe</strong>。</p><h3 id="5-小节">5 小节</h3><p>介绍了libevent的事件主循环，描述了libevent是如何处理就绪的I/O事件、定时器和信号事件，以及如何将它们无缝的融合到一起。</p><h2 id="八-集成信号处理">八 集成信号处理</h2><p>简单说</p><p>Libevent处理信号事件的方式类似于它处理socket事件的方式。它提供了一个统一的接口，使得你可以在一次事件循环中等待多个不同类型的事件，包括信号事件。</p><p>在libevent中，你可以通过<code>event_new</code>函数创建一个信号事件。这个函数需要你提供一个信号号码（如SIGINT，代表终端中断信号），一个回调函数，以及一个可选的回调函数参数。当这个信号发生时，libevent会调用你指定的回调函数。</p><p>创建信号事件后，你需要通过<code>event_add</code>函数将这个事件添加到事件循环中。这个函数需要你提供一个事件，以及一个可选的超时参数（如果你希望这个事件在一段时间后自动超时）。</p><p>在事件循环中，libevent使用<code>sigaction</code>系统调用来接收信号。当一个信号发生时，libevent的内部信号处理函数会被调用。这个函数会查看每个信号事件，看看是否有任何事件的信号号码与当前发生的信号相匹配。如果有，libevent就会将这个事件添加到“就绪”队列中，等待事件循环下一次迭代时被处理。</p><p>在事件循环的每次迭代中，libevent会检查“就绪”队列中的事件，调用每个事件的回调函数。这个过程会一直持续，直到没有更多的就绪事件，或者你停止了事件循环。</p><p>总的来说，libevent通过提供一个统一的事件处理接口，以及内部的信号处理机制，使得处理信号事件变得相当简单。你只需要创建一个信号事件，提供一个回调函数，然后将事件添加到事件循环中，libevent就会在相应的信号发生时调用你的回调函数，处理事件。</p><hr><p>现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和Signal以及Timer事件的集成，这一节将分析如何将Signal集成到事件主循环的框架中。</p><h3 id="1-集成策略——使用socket-pair">1 集成策略——使用socket pair</h3><p>前一节已经做了足够多的介绍了，基本方法就是采用“消息机制”。在libevent中这是通过socket pair完成的，下面就来详细分析一下。<br>Socket pair就是一个socket对，包含两个socket，一个读socket，一个写socket。工作方式如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527184944634.png" alt="image-20240527184944634"></p><p>创建一个socket pair并不是复杂的操作，可以参见下面的流程图，清晰起见，其中忽略了一些错误处理和检查。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185026436.png" alt="image-20240527185026436"></p><p>Libevent提供了辅助函数evutil_socketpair()来创建一个socket pair，可以结合上面的创建流程来分析该函数。</p><h3 id="2-集成到事件主循环——通知event-base">2 集成到事件主循环——通知event_base</h3><p>Socket pair创建好了，可是libevent的事件主循环还是不知道Signal是否发生了啊，看来我们还差了最后一步，那就是：为socket pair的读socket在libevent的event_base实例上注册一个persist的读事件。</p><p>这样当向写socket写入数据时，读socket就会得到通知，触发读事件，从而event_base就能相应的得到通知了。<br>前面提到过，Libevent会在事件主循环中检查标记，来确定是否有触发的signal，如果标记被设置就处理这些signal，这段代码在各个具体的I/O机制中，以Epoll为例，在epoll_dispatch()函数中，代码片段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">epoll_wait</span>(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line"><span class="built_in">event_warn</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">evsignal_process</span>(base);<span class="comment">// 处理signal事件</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base-&gt;sig.evsignal_caught) &#123;</span><br><span class="line"><span class="built_in">evsignal_process</span>(base);<span class="comment">// 处理signal事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的处理框架如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185103712.png" alt="image-20240527185103712"></p><p>注1：libevent中，初始化阶段并不注册读socket的读事件，而是在注册信号阶段才会测试并注册；<br>注2：libevent中，检查I/O事件是在各系统I/O机制的dispatch()函数中完成的，该dispatch()函数在event_base_loop()函数中被调用；</p><h3 id="3-evsignal-info结构体">3 evsignal_info结构体</h3><p>Libevent中Signal事件的管理是通过结构体evsignal_info完成的，结构体位于evsignal.h文件中，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">evsignal_info</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> ev_signal;</span><br><span class="line">    <span class="type">int</span> ev_signal_pair[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ev_signal_added;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> evsignal_caught;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_list</span> evsigevents[NSIG];</span><br><span class="line">    <span class="type">sig_atomic_t</span> evsigcaught[NSIG];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_SIGACTION</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> **sh_old;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">ev_sighandler_t</span> **sh_old;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> sh_old_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面详细介绍一下个字段的含义和作用：<br>1）ev_signal， 为socket pair的读socket向event_base注册读事件时使用的event结构体；<br>2）ev_signal_pair，socket pair对，作用见第一节的介绍；<br>3）ev_signal_added，记录ev_signal事件是否已经注册了；<br>4）evsignal_caught，是否有信号发生的标记；是volatile类型，因为它会在另外的线程中被修改；<br>5）evsigvents[NSIG]，数组，evsigevents[signo]表示注册到信号signo的事件链表；<br>6）evsigcaught[NSIG]，具体记录每个信号触发的次数，evsigcaught[signo]是记录信号signo被触发的次数；<br>7）sh_old记录了原来的signal处理函数指针，当信号signo注册的event被清空时，需要重新设置其处理函数；<br>evsignal_info的初始化包括，创建socket pair，设置ev_signal事件（但并没有注册，而是等到有信号注册时才检查并注册），并将所有标记置零，初始化信号的注册事件链表指针等。</p><h3 id="4-注册、注销signal事件">4 注册、注销signal事件</h3><p>注册signal事件是通过evsignal_add(struct event *ev)函数完成的，libevent对所有的信号注册同一个处理函数evsignal_handler()，该函数将在下一段介绍，注册过程如下：<br>1）取得ev要注册到的信号signo；<br>2） 如果信号signo未被注册，那么就为signo注册信号处理函数evsignal_handler()；<br>3） 如果事件ev_signal还没哟注册，就注册ev_signal事件；<br>4） 将事件ev添加到signo的event链表中；</p><p>从signo上注销一个已注册的signal事件就更简单了，直接从其已注册事件的链表中移除即可。如果事件链表已空，那么就恢复旧的处理函数；</p><p>下面的讲解都以signal()函数为例，sigaction()函数的处理和signal()相似。<br>处理函数evsignal_handler()函数做的事情很简单，就是记录信号的发生次数，并通知event_base有信号触发，需要处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">evsignal_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno; <span class="comment">// 不覆盖原来的错误代码</span></span><br><span class="line">    <span class="keyword">if</span> (evsignal_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">event_warn</span>(<span class="string">&quot;%s: received signal %d, but have no base configured&quot;</span>, __func__, sig);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录信号sig的触发次数，并设置event触发标记</span></span><br><span class="line">    evsignal_base-&gt;sig.evsigcaught[sig]++;</span><br><span class="line">    evsignal_base-&gt;sig.evsignal_caught = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_SIGACTION</span></span><br><span class="line">    <span class="built_in">signal</span>(sig, evsignal_handler); <span class="comment">// 重新注册信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 向写socket写一个字节数据，触发event_base的I/O事件，从而通知其有信号触发，需要处理</span></span><br><span class="line">    <span class="built_in">send</span>(evsignal_base-&gt;sig.ev_signal_pair[<span class="number">0</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno; <span class="comment">// 错误代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-小节-2">5 小节</h3><p>本节介绍了libevent对signal事件的具体处理框架，包括事件注册、删除和socket pair通知机制，以及是如何将Signal事件集成到事件主循环之中的。</p><h2 id="九-集成定时器事件">九 集成定时器事件</h2><p>现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libevent对堆的调整操作做了一些优化，本节还会描述这些优化方法。</p><h3 id="1-集成到事件主循环">1 集成到事件主循环</h3><p>因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I/O事件发生，它们也保证能在timeout时间内返回。</p><p>那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。</p><p>具体的代码在源文件event.c的event_base_loop()中，现在就对比代码来看看这一处理方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据Timer事件计算evsel-&gt;dispatch的最大等待时间</span></span><br><span class="line"><span class="built_in">timeout_next</span>(base, &amp;tv_p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 如果还有活动事件，就不要等待，让evsel-&gt;dispatch立即返回</span></span><br><span class="line"><span class="built_in">evutil_timerclear</span>(&amp;tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 调用select() or epoll_wait() 等待就绪I/O事件</span></span><br><span class="line">res = evsel-&gt;<span class="built_in">dispatch</span>(base, evbase, tv_p);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 处理超时事件，将超时事件插入到激活链表中</span></span><br><span class="line"><span class="built_in">timeout_process</span>(base);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>timeout_next()函数根据堆中具有最小超时值的事件和当前时间来计算等待时间，下面看看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">timeout_next</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> timeval **tv_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> *tv = *tv_p;</span><br><span class="line">    <span class="comment">// 堆的首元素具有最小的超时值</span></span><br><span class="line">    <span class="keyword">if</span> ((ev = <span class="built_in">min_heap_top</span>(&amp;base-&gt;timeheap)) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有定时事件，将等待时间设置为NULL,表示一直阻塞直到有I/O事件发生</span></span><br><span class="line">        *tv_p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得当前时间</span></span><br><span class="line">    <span class="built_in">gettime</span>(base, &amp;now);</span><br><span class="line">    <span class="comment">// 如果超时时间&lt;=当前值，不能等待，需要立即返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">evutil_timercmp</span>(&amp;ev-&gt;ev_timeout, &amp;now, &lt;=)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">evutil_timerclear</span>(tv);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算等待的时间=当前时间-最小的超时时间</span></span><br><span class="line">    <span class="built_in">evutil_timersub</span>(&amp;ev-&gt;ev_timeout, &amp;now, tv);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-Timer小根堆">2 Timer小根堆</h3><p>Libevent使用堆来管理Timer事件，其key值就是事件的超时时间，源代码位于文件min_heap.h中。</p><p>所有的数据结构书中都有关于堆的详细介绍，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)。堆是一个完全二叉树，基本存储方式是一个数组。</p><p>Libevent实现的堆还是比较轻巧的，虽然我不喜欢这种编码方式（搞一些复杂的表达式）。轻巧到什么地方呢，就以插入元素为例，来对比说明，下面伪代码中的size表示当前堆的元素个数：</p><p>典型的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap[size++] = <span class="keyword">new</span>; <span class="comment">// 先放到数组末尾，元素个数+1</span></span><br><span class="line"><span class="comment">// 下面就是shift_up()的代码逻辑，不断的将new向上调整</span></span><br><span class="line">_child = size;</span><br><span class="line"><span class="keyword">while</span>(_child&gt;<span class="number">0</span>) <span class="comment">// 循环</span></span><br><span class="line">&#123;</span><br><span class="line">   _parent = (_child<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// 计算parent</span></span><br><span class="line">   <span class="keyword">if</span>(Heap[_parent].key &lt; Heap[_child].key)</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// 调整结束，跳出循环</span></span><br><span class="line">   <span class="built_in">swap</span>(_parent, _child); <span class="comment">// 交换parent和child</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而libevent的heap代码对这一过程做了优化，在插入新元素时，只是为新元素预留了一个位置hole（初始时hole位于数组尾部），但并不立刻将新元素插入到hole上，而是不断向上调整hole的值，将父节点向下调整，最后确认hole就是新元素的所在位置时，才会真正的将新元素插入到hole上，因此在调整过程中就比上面的代码少了一次赋值的操作，代码逻辑是：</p><p>下面就是shift_up()的代码逻辑，不断的将new的“预留位置”向上调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面就是shift_up()的代码逻辑，不断的将new的“预留位置”向上调整</span></span><br><span class="line">_hole = size; <span class="comment">// _hole就是为new预留的位置，但并不立刻将new放上</span></span><br><span class="line"><span class="keyword">while</span>(_hole&gt;<span class="number">0</span>) <span class="comment">// 循环</span></span><br><span class="line">&#123;</span><br><span class="line">    _parent = (_hole<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// 计算parent</span></span><br><span class="line">    <span class="keyword">if</span>(Heap[_parent].key &lt; <span class="keyword">new</span>.key)</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 调整结束，跳出循环</span></span><br><span class="line">    Heap[_hole] = Heap[_parent]; <span class="comment">// 将parent向下调整</span></span><br><span class="line">    _hole = _parent; <span class="comment">// 将_hole调整到_parent</span></span><br><span class="line">&#125;</span><br><span class="line">Heap[_hole] = <span class="keyword">new</span>; <span class="comment">// 调整结束，将new插入到_hole指示的位置</span></span><br><span class="line">size++; <span class="comment">// 元素个数+1</span></span><br></pre></td></tr></table></figure><p>由于每次调整都少做一次赋值操作，在调整路径比较长时，调整效率会比第一种有所提高。libevent中的min_heap_shift_up_()函数就是上面逻辑的具体实现，对应的向下调整函数是min_heap_shift_down_()。</p><p>举个例子，向一个小根堆3, 5, 8, 7, 12中插入新元素2，使用第一中典型的代码逻辑，其调整过程如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185307526.png" alt="image-20240527185307526"></p><p>使用libevent中的堆调整逻辑，调整过程如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185319336.png" alt="image-20240527185319336"></p><p>对于删除和元素修改操作，也遵从相同的逻辑，就不再罗嗦了。</p><h3 id="3-小节">3 小节</h3><p>通过设置系统I/O机制的wait时间，从而简捷的集成Timer事件；主要分析了libevent对堆调整操作的优化。</p><h2 id="十-支持I-O多路复用技术">十 支持I/O多路复用技术</h2><p>Libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而这些在Windows、Linux、Unix等不同平台上却各有不同，如何能提供优雅而统一的支持方式，是首要关键的问题，这其实不难，本节就来分析一下。</p><h3 id="1-统一的关键">1 统一的关键</h3><p>Libevent支持多种I/O多路复用技术的关键就在于结构体eventop，这个结构体前面也曾提到过，它的成员是一系列的函数指针, 定义在event-internal.h文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventop</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> *(*init)(<span class="keyword">struct</span> event_base *); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">int</span> (*add)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 注册事件</span></span><br><span class="line">    <span class="built_in">int</span> (*del)(<span class="type">void</span> *, <span class="keyword">struct</span> event *); <span class="comment">// 删除事件</span></span><br><span class="line">    <span class="built_in">int</span> (*dispatch)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *, <span class="keyword">struct</span> timeval *); <span class="comment">// 事件分发</span></span><br><span class="line">    <span class="built_in">void</span> (*dealloc)(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *); <span class="comment">// 注销，释放资源</span></span><br><span class="line">    <span class="comment">/* set if we need to reinitialize the event base */</span></span><br><span class="line">    <span class="type">int</span> need_reinit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在libevent中，每种I/O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。</p><p>比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I/O demultiplex机制了。</p><h3 id="2-设置I-O-demultiplex机制">2 设置I/O demultiplex机制</h3><p>Libevent把所有支持的I/O demultiplex机制存储在一个全局静态数组eventops中，并在初始化时选择使用何种机制，数组内容根据优先级顺序声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In order of preference */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> *eventops[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EVENT_PORTS</span></span><br><span class="line">    &amp;evportops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_WORKING_KQUEUE</span></span><br><span class="line">    &amp;kqops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    &amp;epollops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_DEVPOLL</span></span><br><span class="line">    &amp;devpollops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_POLL</span></span><br><span class="line">    &amp;pollops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_SELECT</span></span><br><span class="line">    &amp;selectops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    &amp;win32ops,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>然后libevent根据系统配置和编译选项决定使用哪一种I/O demultiplex机制，这段代码在函数event_base_new()中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base-&gt;evbase = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; eventops[i] &amp;&amp; !base-&gt;evbase; i++) </span><br><span class="line">&#123;</span><br><span class="line">    base-&gt;evsel = eventops[i];</span><br><span class="line">    base-&gt;evbase = base-&gt;evsel-&gt;<span class="built_in">init</span>(base);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看出，libevent在编译阶段选择系统的I/O demultiplex机制，而不支持在运行阶段根据配置再次选择。<br>以Linux下面的epoll为例，实现在源文件epoll.c中，eventops对象epollops定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">eventop</span> epollops = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;epoll&quot;</span>,</span><br><span class="line">    epoll_init,</span><br><span class="line">    epoll_add,</span><br><span class="line">    epoll_del,</span><br><span class="line">    epoll_dispatch,</span><br><span class="line">    epoll_dealloc,</span><br><span class="line">    <span class="number">1</span> <span class="comment">/* need reinit */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>变量epollops中的函数指针具体声明如下，注意到其返回值和参数都和eventop中的定义严格一致，这是函数指针的语法限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">epoll_init</span>    <span class="params">(<span class="keyword">struct</span> event_base *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epoll_add</span>    <span class="params">(<span class="type">void</span> *, <span class="keyword">struct</span> event *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epoll_del</span>    <span class="params">(<span class="type">void</span> *, <span class="keyword">struct</span> event *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epoll_dispatch</span><span class="params">(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *, <span class="keyword">struct</span> timeval *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">epoll_dealloc</span>    <span class="params">(<span class="keyword">struct</span> event_base *, <span class="type">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>那么如果选择的是epoll，那么调用结构体eventop的init和dispatch函数指针时，实际调用的函数就是epoll的初始化函数epoll_init()和事件分发函数epoll_dispatch()了；</p><p>关于epoll的具体用法这里就不多说了，可以参见介绍epoll的文章（本人的哈哈）：<br><a href="http://blog.csdn.net/sparkliang/archive/2009/11/05/4770655.aspx">http://blog.csdn.net/sparkliang/archive/2009/11/05/4770655.aspx</a></p><p>C++语言提供了虚函数来实现多态，在C语言中，这是通过函数指针实现的。对于各类函数指针的详细说明可以参见文章：<br><a href="http://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx">http://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx</a></p><p>同样的，上面epollops以及epoll的各种函数都直接定义在了epoll.c源文件中，对外都是不可见的。对于libevent的使用者而言，完全不会知道它们的存在，对epoll的使用也是通过eventop来完成的，达到了信息隐藏的目的。</p><h3 id="3-小节-2">3 小节</h3><p>支持多种I/O demultiplex机制的方法其实挺简单的，借助于函数指针就OK了。通过对源代码的分析也可以看出，Libevent是在编译阶段选择系统的I/O demultiplex机制的，而不支持在运行阶段根据配置再次选择。</p><h2 id="十一-时间管理">十一 时间管理</h2><p>为了支持定时器，Libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的时间值调整等。下面就结合源代码来分析一下。</p><h3 id="1-初始化检测">1 初始化检测</h3><p>Libevent在初始化时会检测系统时间的类型，通过调用函数detect_monotonic()完成，它通过调用clock_gettime()来检测系统是否支持monotonic时钟类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">detect_monotonic</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>    ts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;ts) == <span class="number">0</span>)</span><br><span class="line">        use_monotonic = <span class="number">1</span>; <span class="comment">// 系统支持monotonic时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Monotonic时间指示的是系统从boot后到现在所经过的时间，如果系统支持Monotonic时间就将全局变量use_monotonic设置为1，设置use_monotonic到底有什么用，这个在后面说到时间校正时就能看出来了。</p><h3 id="2-时间缓存">2 时间缓存</h3><p>结构体event_base中的tv_cache，用来记录时间缓存。这个还要从函数gettime()说起，先来看看该函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gettime</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> timeval *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果tv_cache时间缓存已设置，就直接使用</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tv_cache.tv_sec) &#123;</span><br><span class="line">        *tp = base-&gt;tv_cache;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果支持monotonic，就用clock_gettime获取monotonic时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line">    <span class="keyword">if</span> (use_monotonic) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span>    ts;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;ts) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        tp-&gt;tv_sec = ts.tv_sec;</span><br><span class="line">        tp-&gt;tv_usec = ts.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 否则只能取得系统当前时间</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">evutil_gettimeofday</span>(tp, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果tv_cache已经设置，那么就直接使用缓存的时间；否则需要再次执行系统调用获取系统时间。</p><p>函数evutil_gettimeofday()用来获取当前系统时间，在Linux下其实就是系统调用gettimeofday()；Windows没有提供函数gettimeofday，而是通过调用_ftime()来完成的。</p><p>在每次系统事件循环中，时间缓存tv_cache将会被相应的清空和设置，再次来看看下面event_base_loop的主要代码逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">        <span class="built_in">timeout_correct</span>(base, &amp;tv); <span class="comment">// 时间校正</span></span><br><span class="line">        <span class="comment">// 更新event_tv到tv_cache指示的时间或者当前时间（第一次）</span></span><br><span class="line">         <span class="comment">// event_tv &lt;--- tv_cache</span></span><br><span class="line">        <span class="built_in">gettime</span>(base, &amp;base-&gt;event_tv);</span><br><span class="line">        <span class="comment">// 清空时间缓存-- 时间点1</span></span><br><span class="line">        base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 等待I/O事件就绪</span></span><br><span class="line">        res = evsel-&gt;<span class="built_in">dispatch</span>(base, evbase, tv_p);</span><br><span class="line">        <span class="comment">// 缓存tv_cache存储了当前时间的值-- 时间点2</span></span><br><span class="line">         <span class="comment">// tv_cache &lt;--- now</span></span><br><span class="line">        <span class="built_in">gettime</span>(base, &amp;base-&gt;tv_cache);</span><br><span class="line">        <span class="comment">// .. 处理就绪事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时也要清空时间缓存</span></span><br><span class="line">    base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间event_tv指示了dispatch()上次返回，也就是I/O事件就绪时的时间，第一次进入循环时，由于tv_cache被清空，因此gettime()执行系统调用获取当前系统时间；而后将会更新为tv_cache指示的时间。</p><p>时间tv_cache在dispatch()返回后被设置为当前系统时间，因此它缓存了本次I/O事件就绪时的时间（event_tv）。<br>从代码逻辑里可以看出event_tv取得的是tv_cache上一次的值，因此event_tv应该小于tv_cache的值。</p><p>设置时间缓存的优点是不必每次获取时间都执行系统调用，这是个相对费时的操作；在上面标注的时间点2到时间点1的这段时间（处理就绪事件时），调用gettime()取得的都是tv_cache缓存的时间。</p><h3 id="3-时间校正">3 时间校正</h3><p>如果系统支持monotonic时间，该时间是系统从boot后到现在所经过的时间，因此不需要执行校正。<br>根据前面的代码逻辑，如果系统不支持monotonic时间，用户可能会手动的调整时间，如果时间被向前调整了（MS前面第7部分讲成了向后调整，要改正），比如从5点调整到了3点，那么在时间点2取得的值可能会小于上次的时间，这就需要调整了，下面来看看校正的具体代码，由函数timeout_correct()完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">timeout_correct</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="keyword">struct</span> timeval *tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> **pev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> off;</span><br><span class="line">    <span class="keyword">if</span> (use_monotonic) <span class="comment">// monotonic时间就直接返回，无需调整</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">gettime</span>(base, tv); <span class="comment">// tv &lt;---tv_cache</span></span><br><span class="line">    <span class="comment">// 根据前面的分析可以知道event_tv应该小于tv_cache</span></span><br><span class="line">    <span class="comment">// 如果tv &lt; event_tv表明用户向前调整时间了，需要校正时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">evutil_timercmp</span>(tv, &amp;base-&gt;event_tv, &gt;=)) &#123;</span><br><span class="line">        base-&gt;event_tv = *tv;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算时间差值</span></span><br><span class="line">    <span class="built_in">evutil_timersub</span>(&amp;base-&gt;event_tv, tv, &amp;off);</span><br><span class="line">    <span class="comment">// 调整定时事件小根堆</span></span><br><span class="line">    pev = base-&gt;timeheap.p;</span><br><span class="line">    size = base-&gt;timeheap.n;</span><br><span class="line">    <span class="keyword">for</span> (; size-- &gt; <span class="number">0</span>; ++pev) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> *ev_tv = &amp;(**pev).ev_timeout;</span><br><span class="line">        <span class="built_in">evutil_timersub</span>(ev_tv, &amp;off, ev_tv);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;event_tv = *tv; <span class="comment">// 更新event_tv为tv_cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调整小根堆时，因为所有定时事件的时间值都会被减去相同的值，因此虽然堆中元素的时间键值改变了，但是相对关系并没有改变，不会改变堆的整体结构。因此只需要遍历堆中的所有元素，将每个元素的时间键值减去相同的值即可完成调整，不需要重新调整堆的结构。<br>当然调整完后，要将event_tv值重新设置为tv_cache值了。</p><h3 id="4-小节-2">4 小节</h3><p>主要分析了一下libevent对系统时间的处理，时间缓存、时间校正和定时堆的时间值调整等，逻辑还是很简单的，时间的加减、设置等辅助函数则非常简单，主要在头文件evutil.h中，就不再多说了。</p><h2 id="十二-让libevent支持多线程">十二 让libevent支持多线程</h2><p>Libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代码并没有太大的关系，纯粹是使用上的技巧。</p><h3 id="1-错误使用示例">1 错误使用示例</h3><p>在多核的CPU上只使用一个线程始终是对不起CPU的处理能力啊，那好吧，那就多创建几个线程，比如下面的简单服务器场景。<br>1）主线程创建工作线程1；<br>2）接着主线程监听在端口上，等待新的连接；<br>3）在线程1中执行event事件循环，等待事件到来；<br>4）新连接到来，主线程调用libevent接口event_add将新连接注册到libevent上；<br>… …<br>上面的逻辑看起来没什么错误，在很多服务器设计中都可能用到主线程和工作线程的模式….<br>可是就在线程1注册事件时，主线程很可能也在操作事件，比如删除，修改，通过libevent的源代码也能看到，没有同步保护机制，问题麻烦了，看起来不能这样做啊，难道只能使用单线程不成！？</p><h3 id="2-支持多线程的几种模式">2 支持多线程的几种模式</h3><p>Libevent并不是线程安全的，但这不代表libevent不支持多线程模式，其实方法在前面已经将signal事件处理时就接触到了，那就是消息通知机制。</p><p>一句话，“你发消息通知我，然后再由我在合适的时间来处理”；<br>说到这就再多说几句，再打个比方，把你自己比作一个工作线程，而你的头是主线程，你有一个消息信箱来接收别人发给你的消息，当时头有个新任务要指派给你。</p><h4 id="2-1-暴力抢占">2.1 暴力抢占</h4><p>那么第一节中使用的多线程方法相当下面的流程：<br>1）当时你正在做事，比如在写文档；<br>2）你的头找到了一个任务，要指派给你，比如帮他搞个PPT，哈；<br>3）头命令你马上搞PPT，你这是不得不停止手头的工作，把PPT搞定了再接着写文档；<br>…</p><h4 id="2-2-纯粹的消息通知机制">2.2 纯粹的消息通知机制</h4><p>那么基于纯粹的消息通知机制的多线程方式就像下面这样：<br>1 当时你正在写文档；<br>2 你的头找到了一个任务，要指派给你，帮他搞个PPT；<br>3 头发个消息到你信箱，有个PPT要帮他搞定，这时你并不鸟他；<br>4 你写好文档，接着检查消息发现头有个PPT要你搞定，你开始搞PPT；<br>…</p><p>第一种的好处是消息可以立即得到处理，但是很方法很粗暴，你必须立即处理这个消息，所以你必须处理好切换问题，省得把文档上的内容不小心写到PPT里。在操作系统的进程通信中，消息队列（消息信箱）都是操作系统维护的，你不必关心。<br>第二种的优点是通过消息通知，切换问题省心了，不过消息是不能立即处理的（基于消息通知机制，这个总是难免的），而且所有的内容都通过消息发送，比如PPT的格式、内容等等信息，这无疑增加了通信开销。</p><h4 id="2-3-消息通知-同步层">2.3 消息通知+同步层</h4><p>有个折中机制可以减少消息通信的开销，就是提取一个同步层，还拿上面的例子来说，你把工作安排都存放在一个工作队列中，而且你能够保证“任何人把新任务扔到这个队列”，“自己取出当前第一个任务”等这些操作都能够保证不会把队列搞乱（其实就是个加锁的队列容器）。<br>再来看看处理过程和上面有什么不同：<br>1）当时你正在写文档；<br>2）你的头找到了一个任务，要指派给你，帮他搞个PPT；<br>3) 头有个PPT要你搞定，他把任务push到你的工作队列中，包括了PPT的格式、内容等信息；<br>4) 头发个消息（一个字节）到你信箱，有个PPT要帮他搞定，这时你并不鸟他；<br>5) 你写好文档，发现有新消息（这预示着有新任务来了），检查工作队列知道头有个PPT要你搞定，你开始搞PPT；<br>…</p><p>工作队列其实就是一个加锁的容器（队列、链表等等），这个很容易实现实现；而消息通知仅需要一个字节，具体的任务都push到了在工作队列中，因此想比2.2减少了不少通信开销。</p><p>多线程编程有很多陷阱，线程间资源的同步互斥不是一两句能说得清的，而且出现bug很难跟踪调试；这也有很多的经验和教训，因此如果让我选择，在绝大多数情况下都会选择机制3作为实现多线程的方法。</p><h3 id="3例子——memcached">3例子——memcached</h3><p>Memcached中的网络部分就是基于libevent完成的，其中的多线程模型就是典型的消息通知+同步层机制。下面的图足够说明其多线程模型了，其中有详细的文字说明。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185527228.png" alt="image-20240527185527228"></p><h3 id="4-小节-3">4 小节</h3><p>本节更是libevent的使用方面的技巧，讨论了一下如何让libevent支持多线程，以及几种支持多线程的机制，和memcached使用libevent的多线程模型。</p><blockquote><p><strong>libevent解决了网络编程哪些痛点？</strong></p></blockquote><p><strong>高效的网络缓冲区</strong><br>在内核中有读缓冲区和写缓冲区，减少用户态和内核态的切换。<br>用户态读缓冲区的存在是为了处理粘包的问题，因为网络协议栈是不知道用户界定数据包的格式，没法确定一个完整的数据包。<br>用户态写缓冲区的存在是因为用户根本不清楚内核写缓存区的状态，需要把没有写出去的数据缓存起来等待下次写事件时把数据写出去。<br>buffer的设计有三种类型：<br>（1）固定数组，固定长度。限定了处理数据包的能力，没有动态伸缩的能力；需要<strong>频繁挪动数据。</strong><br>（2）ring buffer。可伸缩性差。<br>（3）chain buffer。解决可伸缩性差的问题，避免频繁挪动数据；同时也引进了新的问题，一个数据可能在多个buffer中都有，即数据分割，这会导致多次系统调用，从而引起中断上下文的切换。解决办法是使用readv()将内核中连续的buffer读到用户态不连续的buffer中，writev()把用户态不连续的buffer写到内核连续的buffer中；从而减少<strong>系统调用</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240527185935359.png" alt="image-20240527185935359"></p><p>evbuffer就是chain buffer类型的缓冲区。</p><p><strong>IO函数使用与网络原理</strong><br>（1）有了libevent可以不使用IO函数。因为如果使用IO函数，既需要知道这些IO函数里面的系统调用返回值的含义。<br>（2）有了libevent就可以不清楚数据拷贝原理。<br>（3）有了libevent就可以不清楚网络原理以及网络编程流程。<br>（4）有了libevent只需要知道事件处理，IO操作完全交由libevent处理。</p><p><strong>多线程</strong><br>加锁的效果比较好。<br>一个线程尽量只处理一个reactor的事件。<br>（1）buffer加锁时，读要读出一个完整的数据包。<br>（2）buffer加锁时，写要写一个完整的数据包。</p>]]></content>
    
    
    <summary type="html">libevent源码剖析</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>模块5:数据中心</title>
    <link href="https://penge666.github.io/posts/d696d4de.html"/>
    <id>https://penge666.github.io/posts/d696d4de.html</id>
    <published>2024-05-23T08:13:23.000Z</published>
    <updated>2024-05-23T08:46:38.010Z</updated>
    
    <content type="html"><![CDATA[<p>胸有惊雷而面如平湖者，可拜上将军！</p><h2 id="第18讲-DNS协议：网络世界的地址簿">第18讲 | DNS协议：网络世界的地址簿</h2><h3 id="18-1-DNS-服务器">18.1 DNS 服务器</h3><p>你肯定记得住网站的名称，但是很难记住网站的 IP 地址，因而也需要一个地址簿，就是<strong>DNS 服务器</strong>。</p><p>由此可见，DNS 在日常生活中多么重要。每个人上网，都需要访问它，但是同时，这对它来讲也是非常大的挑战。一旦它出了故障，整个互联网都将瘫痪。另外，上网的人分布在全世界各地，如果大家都去同一个地方访问某一台服务器，时延将会非常大。因而，<strong>DNS 服务器，一定要设置成高可用、高并发和分布式的</strong>。</p><p>于是，就有了这样树状的层次结构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523161658954.png" alt="image-20240523161658954"></p><ul><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ul><h3 id="18-2-DNS-解析流程">18.2 DNS 解析流程</h3><p>为了提高 DNS 的解析性能，很多网络都会就近部署 DNS 缓存服务器。于是，就有了以下的 DNS 解析流程。</p><ol><li>电脑客户端会发出一个 DNS 请求，问 <a href="http://www.163.com">www.163.com</a> 的 IP 是啥啊，并发给本地域名服务器 (本地 DNS)。那本地域名服务器 (本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。</li><li>本地 DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大表格。如果能找到 <a href="http://www.163.com">www.163.com</a>，它直接就返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：”老大，能告诉我 <a href="http://www.163.com">www.163.com</a> 的 IP 地址吗？”根域名服务器是最高层次的，全球共有 13 套。它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求，发现后缀是 .com，说：”哦，<a href="http://www.163.com">www.163.com</a> 啊，<a href="http://xn--ciq66l2rd1tt4vryr0b.com">这个域名是由.com</a> 区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。”</li><li>本地 DNS 转向问顶级域名服务器：”老二，你能告诉我 <a href="http://www.163.com">www.163.com</a> 的 IP 地址吗？”顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org 这些一级域名，它负责管理二级域名，比如 <a href="http://163.com">163.com</a>，所以它能提供一条更清晰的方向。</li><li>顶级域名服务器说：”我给你负责 <a href="http://www.163.com">www.163.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到。”</li><li>本地 DNS 转向问权威 DNS 服务器：”您好，<a href="http://www.163.com">www.163.com</a> 对应的 IP 是啥呀？”<a href="http://163.com">163.com</a> 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权限 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523161727131.png" alt="image-20240523161727131"></p><h3 id="18-3-负载均衡">18.3 负载均衡</h3><p>站在客户端角度，这是一次<strong>DNS 递归查询过程</strong>。因为本地 DNS 全权为它效劳，它只要坐等结果即可。在这个过程中，DNS 除了可以通过名称映射为 IP 地址，它还可以做另外一件事，就是<strong>负载均衡</strong>。</p><p>DNS 首先可以做<strong>内部负载均衡</strong>。</p><p>例如，一个应用要访问数据库，在这个应用里面应该配置这个数据库的 IP 地址，还是应该配置这个数据库的域名呢？显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如果有多个应用都配置了这台数据库的话，一换 IP 地址，就需要将这些应用全部修改一遍。但是如果配置了域名，则只要在 DNS 服务器里，将域名映射为新的 IP 地址，这个工作就完成了，大大简化了运维。</p><p>在这个基础上，我们可以再进一步。例如，某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p><p>另外一个更加重要的是，DNS 还可以做<strong>全局负载均衡</strong>。</p><p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。</p><p>另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。</p><h3 id="18-3-负载均衡-2">18.3 负载均衡</h3><p>站在客户端角度，这是一次<strong>DNS 递归查询过程</strong>。因为本地 DNS 全权为它效劳，它只要坐等结果即可。在这个过程中，DNS 除了可以通过名称映射为 IP 地址，它还可以做另外一件事，就是<strong>负载均衡</strong>。</p><p>DNS 首先可以做<strong>内部负载均衡</strong>。</p><p>例如，一个应用要访问数据库，在这个应用里面应该配置这个数据库的 IP 地址，还是应该配置这个数据库的域名呢？显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如果有多个应用都配置了这台数据库的话，一换 IP 地址，就需要将这些应用全部修改一遍。但是如果配置了域名，则只要在 DNS 服务器里，将域名映射为新的 IP 地址，这个工作就完成了，大大简化了运维。</p><p>在这个基础上，我们可以再进一步。例如，某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p><p>另外一个更加重要的是，DNS 还可以做<strong>全局负载均衡</strong>。</p><p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。</p><p>另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。</p><h3 id="18-4-示例：DNS-访问数据中心中对象存储上的静态资源">18.4 示例：DNS 访问数据中心中对象存储上的静态资源</h3><p>我们通过 DNS 访问数据中心中对象存储上的静态资源为例，看一看整个过程。</p><p>假设全国有多个数据中心，托管在多个运营商，每个数据中心三个可用区（Available Zone）。对象存储通过跨可用区部署，实现高可用性。在每个数据中心中，都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器（Proxy-server）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523161924726.png" alt="image-20240523161924726"></p><ol><li>当一个客户端要访问 <a href="http://object.yourcompany.com">object.yourcompany.com</a> 的时候，需要将域名转换为 IP 地址进行访问，所以它要请求本地 DNS 解析器。</li><li>本地 DNS 解析器先查看看本地的缓存是否有这个记录。如果有则直接使用，因为上面的过程太复杂了，如果每次都要递归解析，就太麻烦了。</li><li>如果本地无缓存，则需要请求本地的 DNS 服务器。</li><li>本地的 DNS 服务器一般部署在你的数据中心或者你所在的运营商的网络中，本地 DNS 服务器也需要看本地是否有缓存，如果有则返回，因为它也不想把上面的递归过程再走一遍。</li><li>至 7. 如果本地没有，本地 DNS 才需要递归地从根 DNS 服务器，<a href="http://xn--rcrz24c.com">查到.com</a> 的顶级域名服务器，最终查到 <a href="http://yourcompany.com">yourcompany.com</a> 的权威 DNS 服务器，给本地 DNS 服务器，权威 DNS 服务器按说会返回真实要访问的 IP 地址。</li></ol><p>对于不需要做全局负载均衡的简单应用来讲，<a href="http://yourcompany.com">yourcompany.com</a> 的权威 DNS 服务器可以直接将 <a href="http://object.yourcompany.com">object.yourcompany.com</a> 这个域名解析为一个或者多个 IP 地址，然后客户端可以通过多个 IP 地址，进行简单的轮询，实现简单的负载均衡。</p><p>但是对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而需要专门的设备或者服务器来做这件事情，这就是<strong>全局负载均衡器（GSLB，Global Server Load Balance）</strong>。</p><p>在 <a href="http://yourcompany.com">yourcompany.com</a> 的 DNS 服务器中，一般是通过配置 CNAME 的方式，给 <a href="http://object.yourcompany.com">object.yourcompany.com</a> 起一个别名，例如 <a href="http://object.vip.yourcomany.com">object.vip.yourcomany.com</a>，然后告诉本地 DNS 服务器，让它请求 GSLB 解析这个域名，GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡。</p><p>图中画了两层的 GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问相同运营商机房中的资源，这样不跨运营商访问，有利于提高吞吐量，减少时延。</p><ol><li>第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别名 <a href="http://object.yd.yourcompany.com">object.yd.yourcompany.com</a>，告诉本地 DNS 服务器去请求第二层的 GSLB。</li><li>第二层 GSLB，通过查看请求它的本地 DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，六个**内部负载均衡（SLB，Server Load Balancer）**的地址，返回给本地 DNS 服务器。</li><li>本地 DNS 服务器将结果返回给本地 DNS 解析器。</li><li>本地 DNS 解析器将结果缓存后，返回给客户端。</li><li>客户端开始访问属于相同运营商的距离较近的 Region 1 中的对象存储，当然客户端得到了六个 IP 地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。</li></ol><h3 id="18-5-小结">18.5 小结</h3><p>总结一下：</p><ul><li>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</li><li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li></ul><h2 id="第19讲-HTTPDNS：网络世界的地址簿也会指错路">第19讲 | HTTPDNS：网络世界的地址簿也会指错路</h2><p>上一节我们知道了 DNS 的两项功能，第一是根据名称查到具体的地址，另外一个是可以针对多个地址做负载均衡，而且可以在多个地址中选择一个距离你近的地方访问。</p><p>然而有时候这个地址簿也经常给你指错路，明明距离你 500 米就有个吃饭的地方，非要把你推荐到 5 公里外。为什么会出现这样的情况呢？</p><p>还记得吗？当我们发出请求解析 DNS 的时候，首先，会先连接到运营商本地的 DNS 服务器，由这个服务器帮我们去整棵 DNS 树上进行解析，然后将解析的结果返回给客户端。但是本地的 DNS 服务器，作为一个本地导游，往往有自己的”小心思”。</p><h3 id="19-1-传统-DNS-存在哪些问题？">19.1 传统 DNS 存在哪些问题？</h3><ol><li><p>域名缓存问题【简单来说，就是缓存失效】</p><p>它可以在本地做一个缓存，也就是说，不是每一个请求，它都会去访问权威 DNS 服务器，而是访问过一次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。</p><p>这就相当于导游去过一个饭店，自己脑子记住了地址，当有一个游客问的时候，他就凭记忆回答了，不用再去查地址簿。这样经常存在的一个问题是，人家那个饭店明明都已经搬了，结果作为导游，他并没有刷新这个缓存，结果你辛辛苦苦到了这个地点，发现饭店已经变成了服装店，你是不是会非常失望？</p><p>另外，有的运营商会把一些静态页面，缓存到本运营商的服务器内，这样用户请求的时候，就不用跨运营商进行访问，这样既加快了速度，也减少了运营商之间流量计算的成本。在域名解析的时候，不会将用户导向真正的网站，而是指向这个缓存的服务器。</p><p>很多情况下是看不出问题的，但是当页面更新，用户会访问到老的页面，问题就出来了。例如，你听说一个餐馆推出了一个新菜，你想去尝一下。结果导游告诉你，在这里吃也是一样的。有的游客会觉得没问题，但是对于想尝试新菜的人来说，如果导游说带你去，但其实并没有吃到新菜，你是不是也会非常失望呢？</p><p>再就是本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路。</p><p>就像上一次客户要吃西湖醋鱼的事，导游知道西湖边有一家，因为当时游客就在西湖边，可是，下一次客户在灵隐寺，想吃西湖醋鱼的时候，导游还指向西湖边的那一家，那这就绕的太远了。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523162219587.png" alt="image-20240523162219587"></p><p>2.域名转发问题</p><p>缓存问题还是说本地域名解析服务，还是会去权威 DNS 服务器中查找，只不过不是每次都要查找。可以说这还是大导游、大中介。还有一些小导游、小中介，有了请求之后，直接转发给其他运营商去做解析，自己只是外包了出去。</p><p>这样的问题是，如果是 A 运营商的客户，访问自己运营商的 DNS 服务器，如果 A 运营商去权威 DNS 服务器查询的话，权威 DNS 服务器知道你是 A 运营商的，就返回给一个部署在 A 运营商的网站地址，这样针对相同运营商的访问，速度就会快很多。</p><p>但是 A 运营商偷懒，将解析的请求转发给 B 运营商，B 运营商去权威 DNS 服务器查询的话，权威服务器会误认为，你是 B 运营商的，那就返回给你一个在 B 运营商的网站地址吧，结果客户的每次访问都要跨运营商，速度就会很慢。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523162815367.png" alt="image-20240523162815367"></p><p>3.出口 NAT 问题</p><p>前面讲述网关的时候，我们知道，出口的时候，很多机房都会配置NAT，也即网络地址转换，使得从这个网关出去的包，都换成新的 IP 地址，当然请求返回的时候，在这个网关，再将 IP 地址转换回去，所以对于访问来说是没有任何问题。</p><p>但是一旦做了网络地址的转换，权威的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问。</p><p>4.域名更新问题</p><p>本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的 TTL 时间限制，在权威 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。但是有的时候，在 DNS 的切换中，场景对生效时间要求比较高。</p><p>例如双机房部署的时候，跨机房的负载均衡和容灾多使用 DNS 来做。当一个机房出问题之后，需要修改权威 DNS，将域名指向新的 IP 地址，但是如果更新太慢，那很多用户都会出现访问异常。</p><p>这就像，有的导游比较勤快、敬业，时时刻刻关注酒店、餐馆、交通的变化，问他的时候，往往会得到最新情况。有的导游懒一些，8 年前背的导游词就没换过，问他的时候，指的路往往就是错的。</p><p>5.解析延迟问题</p><p>从上一节的 DNS 查询过程来看，DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。</p><h3 id="19-2-HTTPDNS-的工作模式">19.2 HTTPDNS 的工作模式</h3><p>既然 DNS 解析中有这么多问题，那怎么办呢？难不成退回到直接用 IP 地址？这样显然不合适，所以就有了<strong>HTTPDNS</strong>。</p><p><strong>HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址</strong>。</p><p>这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因而使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户端 SDK。</p><p>通过自己的 HTTPDNS 服务器和自己的 SDK，实现了从依赖本地导游，到自己上网查询做旅游攻略，进行自由行，爱怎么玩怎么玩。这样就能够避免依赖导游，而导游又不专业，你还不能把他怎么样的尴尬。</p><p>下面我来解析一下<strong>HTTPDNS 的工作模式</strong>。</p><p>在客户端的 SDK 里动态请求服务端，获取 HTTPDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。</p><p>当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。</p><p>如果本地没有，就需要请求 HTTPDNS 的服务器，在本地 HTTPDNS 服务器的 IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表。</p><p>请求的方式是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://106.2.xxx.xxx/d?dn=c.m.163.com</span><br><span class="line">&#123;<span class="string">&quot;dns&quot;</span>:[&#123;<span class="string">&quot;host&quot;</span>:<span class="string">&quot;c.m.163.com&quot;</span>,<span class="string">&quot;ips&quot;</span>:[<span class="string">&quot;223.252.199.12&quot;</span>],<span class="string">&quot;ttl&quot;</span>:300,<span class="string">&quot;http2&quot;</span>:0&#125;],<span class="string">&quot;client&quot;</span>:&#123;<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;106.2.81.50&quot;</span>,<span class="string">&quot;line&quot;</span>:269692944&#125;&#125;</span><br></pre></td></tr></table></figure><p>手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的 HTTP 通信，HTTPDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523163048109.png" alt="image-20240523163048109"></p><p>当然，当所有这些都不工作的时候，可以切换到传统的 LocalDNS 来解析，慢也比访问不到好。那 HTTPDNS 是如何解决上面的问题的呢？</p><p>其实归结起来就是两大问题。一是解析速度和更新速度的平衡问题，二是智能调度的问题，对应的解决方案是 HTTPDNS 的缓存设计和调度设计。</p><h3 id="19-3-HTTPDNS-的缓存设计">19.3 HTTPDNS 的缓存设计</h3><p>解析 DNS 过程复杂，通信次数多，对解析速度造成很大影响。为了加快解析，因而有了缓存，但是这又会产生缓存更新速度不及时的问题。最要命的是，这两个方面都掌握在别人手中，也即本地 DNS 服务器手中，它不会为你定制，你作为客户端干着急没办法。</p><p>而 HTTPDNS 就是将解析速度和更新速度全部掌控在自己手中。一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制。</p><p>HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层。</p><ul><li>对于应用架构来讲，就是应用、缓存、数据库。常见的是 Tomcat、Redis、MySQL。</li><li>对于 HTTPDNS 来讲，就是手机客户端、DNS 缓存、HTTPDNS 服务器。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523163104850.png" alt="image-20240523163104850"></p><p>只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。</p><p>例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次都全部解析一遍，再变成缓存。这有点像 Redis 是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。</p><p>SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。</p><p>解析可以<strong>同步进行</strong>，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以<strong>异步进行</strong>，添加一个解析任务到后台，由后台任务调用 HTTPDNS 的接口。</p><p>同步更新的优点是实时性好，缺点是如果有多个请求都发现过期的时候，同时会请求 HTTPDNS 多次，其实是一种浪费。</p><p>同步更新的方式对应到应用架构中缓存的<strong>Cache-Aside 机制</strong>，也即先读缓存，不命中读数据库，同时将结果写入缓存。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523163132939.png" alt="image-20240523163132939"></p><p>异步更新的优点是，可以将多个请求都发现过期的情况，合并为一个对于 HTTPDNS 的请求任务，只执行一次，减少 HTTPDNS 的压力。同时可以在即将过期的时候，就创建一个任务进行预加载，防止过期之后再刷新，称为<strong>预加载</strong>。</p><p>它的缺点是当前请求拿到过期数据的时候，如果客户端允许使用过期数据，需要冒一次风险。如果过期的数据还能请求，就没问题；如果不能请求，则失败一次，等下次缓存更新后，再请求方能成功。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523163149681.png" alt="image-20240523163149681"></p><p>异步更新的机制对应到应用架构中缓存的Refresh-Ahead 机制，即业务仅仅访问缓存，当过期的时候定期刷新。在著名的应用缓存 Guava Cache 中，有个 RefreshAfterWrite 机制，对于并发情况下，多个缓存访问不命中从而引发并发回源的情况，可以采取只有一个请求回源的模式。在应用架构的缓存中，也常常用<strong>数据预热</strong>或者<strong>预加载</strong>的机制。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523163204576.png" alt="image-20240523163204576"></p><h3 id="19-4-HTTPDNS-的调度设计">19.4 HTTPDNS 的调度设计</h3><p>由于客户端嵌入了 SDK，因而就不会因为本地 DNS 的各种缓存、转发、NAT，让权威 DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料。</p><p>在<strong>客户端</strong>，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS 服务端可以根据这些信息，选择最佳的服务节点返回。</p><p>如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换。</p><p>要做到这一点，需要客户端使用 HTTPDNS 返回的 IP 访问业务应用。客户端的 SDK 会收集网络请求数据，如错误率、请求时间等网络请求质量数据，并发送到统计后台，进行分析、聚合，以此查看不同的 IP 的服务质量。</p><p>在<strong>服务端</strong>，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。</p><p>HTTPDNS 通过智能调度之后返回的结果，也会缓存在客户端。为了不让缓存使得调度失真，客户端可以根据不同的移动网络运营商 WIFI 的 SSID 来分维度缓存。不同的运营商或者 WIFI 解析出来的结果会不同。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523163220546.png" alt="image-20240523163220546"></p><h3 id="19-5-小结">19.5 小结</h3><p>两个重点：</p><ul><li>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</li><li>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</li></ul><h2 id="第20讲-CDN：你去小卖部取过快递么？">第20讲 | CDN：你去小卖部取过快递么？</h2><p>当一个用户想访问一个网站的时候，指定这个网站的域名，DNS 就会将这个域名解析为地址，然后用户请求这个地址，返回一个网页。就像你要买个东西，首先要查找商店的位置，然后去商店里面找到自己想要的东西，最后拿着东西回家。</p><p><strong>那这里面还有没有可以优化的地方呢？</strong></p><p>例如你去电商网站下单买个东西，这个东西一定要从电商总部的中心仓库送过来吗？原来基本是这样的，每一单都是单独配送，所以你可能要很久才能收到你的宝贝。但是后来电商网站的物流系统学聪明了，他们在全国各地建立了很多仓库，而不是只有总部的中心仓库才可以发货。</p><p>电商网站根据统计大概知道，北京、上海、广州、深圳、杭州等地，每天能够卖出去多少书籍、卫生纸、包、电器等存放期比较长的物品。这些物品用不着从中心仓库发出，所以平时就可以将它们分布在各地仓库里，客户一下单，就近的仓库发出，第二天就可以收到了。</p><p>这样，用户体验大大提高。当然，这里面也有个难点就是，生鲜这类东西保质期太短，如果提前都备好货，但是没有人下单，那肯定就坏了。这个问题，我后文再说。</p><p><strong>我们先说，我们的网站访问可以借鉴”就近配送”这个思路</strong>。</p><p>全球有这么多的数据中心，无论在哪里上网，临近不远的地方基本上都有数据中心。是不是可以在这些数据中心里部署几台机器，形成一个缓存的集群来缓存部分数据，那么用户访问数据的时候，就可以就近访问了呢？</p><p>当然是可以的。这些分布在各个地方的各个数据中心的节点，就称为<strong>边缘节点</strong>。</p><p>由于边缘节点数目比较多，但是每个集群规模比较小，不可能缓存下来所有东西，因而可能无法命中，这样就会在边缘节点之上。有区域节点，规模就要更大，缓存的数据会更多，命中的概率也就更大。在区域节点之上是中心节点，规模更大，缓存数据更多。如果还不命中，就只好回源网站访问了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164056912.png" alt="image-20240523164056912"></p><p>这就是<strong>CDN 的分发系统的架构</strong>。CDN 系统的缓存，也是一层一层的，能不访问后端真正的源，就不打扰它。这也是电商网站物流系统的思路，北京局找不到，找华北局，华北局找不到，再找北方局。</p><p>有了这个分发系统之后，接下来就是，<strong>客户端如何找到相应的边缘节点进行访问呢？</strong></p><p>还记得我们讲过的基于 DNS 的全局负载均衡吗？这个负载均衡主要用来选择一个就近的同样运营商的服务器进行访问。你会发现，CDN 分发网络也是一个分布在多个区域、多个运营商的分布式系统，也可以用相同的思路选择最合适的边缘节点。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164112433.png" alt="image-20240523164112433"></p><p><strong>在没有 CDN 的情况下</strong>，用户向浏览器输入 <a href="http://www.web.com">www.web.com</a> 这个域名，客户端访问本地 DNS 服务器的时候，如果本地 DNS 服务器有缓存，则返回网站的地址；如果没有，递归查询到网站的权威 DNS 服务器，这个权威 DNS 服务器是负责 <a href="http://web.com">web.com</a> 的，它会返回网站的 IP 地址。本地 DNS 服务器缓存下 IP 地址，将 IP 地址返回，然后客户端直接访问这个 IP 地址，就访问到了这个网站。</p><p>然而<strong>有了 CDN 之后，情况发生了变化</strong>。在 <a href="http://web.com">web.com</a> 这个权威 DNS 服务器上，会设置一个 CNAME 别名，指向另外一个域名 <a href="http://www.web.cdn.com">www.web.cdn.com</a>，返回给本地 DNS 服务器。</p><p>当本地 DNS 服务器拿到这个新的域名时，需要继续解析这个新的域名。这个时候，再访问的就不是 <a href="http://web.com">web.com</a> 的权威 DNS 服务器了，而是 <a href="http://web.cdn.com">web.cdn.com</a> 的权威 DNS 服务器，这是 CDN 自己的权威 DNS 服务器。在这个服务器上，还是会设置一个 CNAME，指向另外一个域名，也即 CDN 网络的全局负载均衡器。</p><p>接下来，本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：</p><ul><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>用户所处的运营商；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li></ul><p>基于以上这些条件，进行综合分析之后，全局负载均衡器会返回一台缓存服务器的 IP 地址。</p><p>本地 DNS 服务器缓存这个 IP 地址，然后将 IP 返回给客户端，客户端去访问这个边缘节点，下载资源。缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p><p><strong>CDN 可以进行缓存的内容有很多种。</strong></p><p>保质期长的日用品比较容易缓存，因为不容易过期，对应到就像电商仓库系统里，就是静态页面、图片等，因为这些东西也不怎么变，所以适合缓存.</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164208297.png" alt="image-20240523164208297"></p><p>还记得这个<strong>接入层缓存的架构</strong>吗？在进入数据中心的时候，我们希望通过最外层接入层的缓存，将大部分静态资源的访问拦在边缘。而 CDN 则更进一步，将这些静态资源缓存到离用户更近的数据中心外。越接近客户，访问性能越好，时延越低。</p><p>但是静态内容中，有一种特殊的内容，也大量使用了 CDN，这个就是前面讲过的流媒体。</p><p>CDN 支持<strong>流媒体协议</strong>，例如前面讲过的 RTMP 协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。</p><p>对于静态页面来讲，内容的分发往往采取<strong>拉取</strong>的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现<strong>回源</strong>，压力会比较大，所以往往采取主动<strong>推送</strong>的模式，将热点数据主动推送到边缘节点。</p><p>对于流媒体来讲，很多 CDN 还提供<strong>预处理服务</strong>，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，”我要看超清、标清、流畅等”。</p><p>对于流媒体 CDN 来讲，有个关键的问题是<strong>防盗链</strong>问题。因为视频是要花大价钱买版权的，为了挣点钱，收点广告费，如果流媒体被其他的网站盗走，在人家的网站播放，那损失可就大了。</p><p>最常用也最简单的方法就是<strong>HTTP 头的 refer 字段</strong>， 当浏览器发送请求的时候，一般会带上 referer，告诉服务器是从哪个页面链接过来的，服务器基于此可以获得一些信息用于处理。如果 refer 信息不是来自本站，就阻止访问或者跳到其它链接。</p><p><strong>refer 的机制相对比较容易破解，所以还需要配合其他的机制。</strong></p><p>一种常用的机制是<strong>时间戳防盗链</strong>。使用 CDN 的管理员可以在配置界面上，和 CDN 厂商约定一个加密字符串。</p><p>客户端取出当前的时间戳，要访问的资源及其路径，连同加密字符串进行签名算法得到一个字符串，然后生成一个下载链接，带上这个签名字符串和截止时间戳去访问 CDN。</p><p>在 CDN 服务端，根据取出过期时间，和当前 CDN 节点时间进行比较，确认请求是否过期。然后 CDN 服务端有了资源及路径，时间戳，以及约定的加密字符串，根据相同的签名算法计算签名，如果匹配则一致，访问合法，才会将资源返回给客户。</p><p>然而比如在电商仓库中，我在前面提过，有关生鲜的缓存就是非常麻烦的事情，这对应着就是动态的数据，比较难以缓存。怎么办呢？现在也有<strong>动态 CDN，主要有两种模式</strong>。</p><ul><li>一种为<strong>生鲜超市模式</strong>，也即<strong>边缘计算的模式</strong>。既然数据是动态生成的，所以数据的逻辑计算和存储，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。</li><li>另一种是<strong>冷链运输模式</strong>，也即<strong>路径优化的模式</strong>。数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。</li></ul><p>对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。</p><p>可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。</p><p>所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。</p><h3 id="20-1-小结">20.1 小结</h3><p>总结一下：</p><ul><li>CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。</li><li>CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。</li></ul><h2 id="第21讲-数据中心：我是开发商，自己拿地盖别墅">第21讲 | 数据中心：我是开发商，自己拿地盖别墅</h2><p>无论你是看新闻、下订单、看视频、下载文件，最终访问的目的地都在数据中心里面。我们前面学了这么多的网络协议和网络相关的知识，你是不是很好奇，数据中心究竟长啥样呢？</p><p>数据中心是一个大杂烩，几乎要用到前面学过的所有知识。</p><p>前面讲办公室网络的时候，我们知道办公室里面有很多台电脑。如果要访问外网，需要经过一个叫<strong>网关</strong>的东西，而网关往往是一个路由器。</p><p>数据中心里面也有一大堆的电脑，但是它和咱们办公室里面的笔记本或者台式机不一样。数据中心里面是服务器。服务器被放在一个个叫作**机架（Rack）**的架子上面。</p><p>数据中心的入口和出口也是路由器，由于在数据中心的边界，就像在一个国家的边境，称为<strong>边界路由器（Border Router）</strong>。为了高可用，边界路由器会有多个。</p><p>一般家里只会连接一个运营商的网络，而为了高可用， 为了当一个运营商出问题的时候，还可以通过另外一个运营商来提供服务，所以数据中心的边界路由器会连接多个运营商网络。</p><p>既然是路由器，就需要跑路由协议，数据中心往往就是路由协议中的自治区域（AS）。数据中心里面的机器要想访问外面的网站，数据中心里面也是有对外提供服务的机器，都可以通过 BGP 协议，获取内外互通的路由信息。这就是我们常听到的<strong>多线 BGP</strong>的概念。</p><p>如果数据中心非常简单，没几台机器，那就像家里或者宿舍一样，所有的服务器都直接连到路由器上就可以了。但是数据中心里面往往有非常多的机器，当塞满一机架的时候，需要有交换机将这些服务器连接起来，可以互相通信。</p><p>这些交换机往往是放在机架顶端的，所以经常称为<strong>TOR（Top Of Rack）交换机</strong>。这一层的交换机常常称为<strong>接入层（Access Layer）</strong>。注意这个接入层和原来讲过的应用的接入层不是一个概念。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164315816.png" alt="image-20240523164315816"></p><p>当一个机架放不下的时候，就需要多个机架，还需要有交换机将多个机架连接在一起。这些交换机对性能的要求更高，带宽也更大。这些交换机称为<strong>汇聚层交换机（Aggregation Layer）</strong>。</p><p>数据中心里面的每一个连接都是需要考虑高可用的。这里首先要考虑的是，如果一台机器只有一个网卡，上面连着一个网线，接入到 TOR 交换机上。如果网卡坏了，或者不小心网线掉了，机器就上不去了。所以，需要至少两个网卡、两个网线插到 TOR 交换机上，但是两个网卡要工作得像一张网卡一样，这就是常说的<strong>网卡绑定（bond）</strong>。</p><p>这就需要服务器和交换机都支持一种协议<strong>LACP（Link Aggregation Control Protocol）</strong>。它们互相通信，将多个网卡聚合称为一个网卡，多个网线聚合成一个网线，在网线之间可以进行负载均衡，也可以为了高可用作准备。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164339792.png" alt="image-20240523164339792"></p><p>网卡有了高可用保证，但交换机还有问题。如果一个机架只有一个交换机，它挂了，那整个机架都不能上网了。因而 TOR 交换机也需要高可用，同理接入层和汇聚层的连接也需要高可用性，也不能单线连着。</p><p>最传统的方法是，部署两个接入交换机、两个汇聚交换机。服务器和两个接入交换机都连接，接入交换机和两个汇聚都连接，当然这样会形成环，所以需要启用 STP 协议，去除环，但是这样两个汇聚就只能一主一备了。STP 协议里我们学过，只有一条路会起作用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164353521.png" alt="image-20240523164353521"></p><p>交换机有一种技术叫作<strong>堆叠</strong>，所以另一种方法是，将多个交换机形成一个逻辑的交换机，服务器通过多根线分配连到多个接入层交换机上，而接入层交换机多根线分别连接到多个交换机上，并且通过堆叠的私有协议，形成<strong>双活</strong>的连接方式。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164404687.png" alt="image-20240523164404687"></p><p>由于对带宽要钱求更大，而且挂了影响也更大，所以两个堆叠可能就不够了，可以就会有更多的，比如四个堆叠为一个逻辑的交换机。</p><p>汇聚层将大量的计算节点相互连接在一起，形成一个集群。在这个集群里面，服务器之间通过二层互通，这个区域常称为一个<strong>POD（Point Of Delivery）</strong>，有时候也称为一个<strong>可用区（Available Zone）</strong>。</p><p>当节点数目再多的时候，一个可用区放不下，需要将多个可用区连在一起，连接多个可用区的交换机称为<strong>核心交换机</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164426258.png" alt="image-20240523164426258"></p><p>核心交换机吞吐量更大，高可用要求更高，肯定需要堆叠，但是往往仅仅堆叠，不足以满足吞吐量，因而还是需要部署多组核心交换机。核心和汇聚交换机之间为了高可用，也是全互连模式的。</p><p>这个时候还存在那个问题，出现环路怎么办？</p><p>一种方式是，不同的可用区在不同的二层网络，需要分配不同的网段。汇聚和核心之间通过三层网络互通的，二层都不在一个广播域里面，不会存在二层环路的问题。三层有环是没有问题的，只要通过路由协议选择最佳的路径就可以了。那为啥二层不能有环路，而三层可以呢？你可以回忆一下二层环路的情况。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164436601.png" alt="image-20240523164436601"></p><p>如图，核心层和汇聚层之间通过内部的路由协议 OSPF，找到最佳的路径进行访问，而且还可以通过 ECMP 等价路由，在多个路径之间进行负载均衡和高可用。</p><p>但是随着数据中心里面的机器越来越多，尤其是有了云计算、大数据，集群规模非常大，而且都要求在一个二层网络里面。这就需要二层互连从<strong>汇聚层</strong>上升为<strong>核心层</strong>，也即在核心以下，全部是二层互连，全部在一个广播域里面，这就是常说的<strong>大二层</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164447725.png" alt="image-20240523164447725"></p><p>如果大二层横向流量不大，核心交换机数目不多，可以做堆叠，但是如果横向流量很大，仅仅堆叠满足不了，就需要部署多组核心交换机，而且要和汇聚层进行全互连。由于堆叠只解决一个核心交换机组内的无环问题，而组之间全互连，还需要其他机制进行解决。</p><p>如果是 STP，那部署多组核心无法扩大横向流量的能力，因为还是只有一组起作用。</p><p>于是大二层就引入了<strong>TRILL（Transparent Interconnection of Lots of Link），即多链接透明互联协议</strong>。它的基本思想是，二层环有问题，三层环没有问题，那就把三层的路由能力模拟在二层实现。</p><p>运行 TRILL 协议的交换机称为<strong>RBridge</strong>，是<strong>具有路由转发特性的网桥设备</strong>，只不过这个路由是根据 MAC 地址来的，不是根据 IP 来的。</p><p>Rbridage 之间通过<strong>链路状态协议</strong>运作。记得这个路由协议吗？通过它可以学习整个大二层的拓扑，知道访问哪个 MAC 应该从哪个网桥走；还可以计算最短的路径，也可以通过等价的路由进行负载均衡和高可用性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164459752.png" alt="image-20240523164459752"></p><p>TRILL 协议在原来的 MAC 头外面加上自己的头，以及外层的 MAC 头。TRILL 头里面的 Ingress RBridge，有点像 IP 头里面的源 IP 地址，Egress RBridge 是目标 IP 地址，这两个地址是端到端的，在中间路由的时候，不会发生改变。而外层的 MAC，可以有下一跳的 Bridge，就像路由的下一跳，也是通过 MAC 地址来呈现的一样。</p><p>如图中所示的过程，有一个包要从主机 A 发送到主机 B，中间要经过 RBridge 1、RBridge 2、RBridge X 等等，直到 RBridge 3。在 RBridge 2 收到的包里面，分内外两层，内层就是传统的主机 A 和主机 B 的 MAC 地址以及内层的 VLAN。</p><p>在外层首先加上一个 TRILL 头，里面描述这个包从 RBridge 1 进来的，要从 RBridge 3 出去，并且像三层的 IP 地址一样有跳数。然后再外面，目的 MAC 是 RBridge 2，源 MAC 是 RBridge 1，以及外层的 VLAN。</p><p>当 RBridge 2 收到这个包之后，首先看 MAC 是否是自己的 MAC，如果是，要看自己是不是 Egress RBridge，也即是不是最后一跳；如果不是，查看跳数是不是大于 0，然后通过类似路由查找的方式找到下一跳 RBridge X，然后将包发出去。</p><p>RBridge 2 发出去的包，内层的信息是不变的，外层的 TRILL 头里面。同样，描述这个包从 RBridge 1 进来的，要从 RBridge 3 出去，但是跳数要减 1。外层的目标 MAC 变成 RBridge X，源 MAC 变成 RBridge 2。</p><p>如此一直转发，直到 RBridge 3，将外层解出来，发送内层的包给主机 B。</p><p>这个过程是不是和 IP 路由很像？</p><p>对于大二层的广播包，也需要通过分发树的技术来实现。我们知道 STP 是将一个有环的图，通过去掉边形成一棵树，而分发树是一个有环的图形成多棵树，不同的树有不同的 VLAN，有的广播包从 VLAN A 广播，有的从 VLAN B 广播，实现负载均衡和高可用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164513430.png" alt="image-20240523164513430"></p><p>核心交换机之外，就是边界路由器了。至此从服务器到数据中心边界的层次情况已经清楚了。</p><p>在核心交换上面，往往会挂一些安全设备，例如入侵检测、DDoS 防护等等。这是整个数据中心的屏障，防止来自外来的攻击。核心交换机上往往还有负载均衡器，原理前面的章节已经说过了。</p><p>在有的数据中心里面，对于存储设备，还会有一个存储网络，用来连接 SAN 和 NAS。但是对于新的云计算来讲，往往不使用传统的 SAN 和 NAS，而使用部署在 x86 机器上的软件定义存储，这样存储也是服务器了，而且可以和计算节点融合在一个机架上，从而更加有效率，也就没有了单独的存储网络了。</p><p>于是整个数据中心的网络如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164529974.png" alt="image-20240523164529974"></p><p>这是一个典型的三层网络结构。这里的三层不是指 IP 层，而是指接入层、汇聚层、核心层三层。这种模式非常有利于外部流量请求到内部应用。这个类型的流量，是从外到内或者从内到外，对应到上面那张图里，就是从上到下，从下到上，上北下南，所以称为<strong>南北流量</strong>。</p><p>但是随着云计算和大数据的发展，节点之间的交互越来越多，例如大数据计算经常要在不同的节点将数据拷贝来拷贝去，这样需要经过交换机，使得数据从左到右，从右到左，左西右东，所以称为<strong>东西流量</strong>。</p><p>为了解决东西流量的问题，演进出了<strong>叶脊网络（Spine/Leaf）</strong>。</p><ul><li><strong>叶子交换机（leaf）</strong>，直接连接物理服务器。L2/L3 网络的分界点在叶子交换机上，叶子交换机之上是三层网络。</li><li><strong>脊交换机（spine switch）</strong>，相当于核心交换机。叶脊之间通过 ECMP 动态选择多条路径。脊交换机现在只是为叶子交换机提供一个弹性的 L3 路由网络。南北流量可以不用直接从脊交换机发出，而是通过与 leaf 交换机并行的交换机，再接到边界路由器出去。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523164541601.png" alt="image-20240523164541601"></p><p>传统的三层网络架构是垂直的结构，而叶脊网络架构是扁平的结构，更易于水平扩展。</p><h4 id="21-1-小结">21.1 小结</h4><p>三个重点：</p><ul><li>数据中心分为三层。服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。</li><li>数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过 TRILL 协议。</li><li>随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。</li></ul><h2 id="第22讲-VPN：朝中有人好做官">第22讲 | VPN：朝中有人好做官</h2><p>待填坑~</p>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块4:应用层</title>
    <link href="https://penge666.github.io/posts/1dfac2eb.html"/>
    <id>https://penge666.github.io/posts/1dfac2eb.html</id>
    <published>2024-05-23T08:04:29.000Z</published>
    <updated>2024-05-23T08:05:29.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第14讲-HTTP协议：看个新闻原来这么麻烦">第14讲 | HTTP协议：看个新闻原来这么麻烦</h2><p>前面讲述完传输层，接下来开始讲应用层的协议。从哪里开始讲呢，就从咱们最常用的 HTTP 协议开始。</p><p>HTTP 协议，几乎是每个人上网用的第一个协议，同时也是很容易被人忽略的协议。</p><p>既然说看新闻，咱们就先登录 <a href="http://www.163.com/">http://www.163.com</a> 。</p><p><a href="http://www.163.com/">http://www.163.com</a> 是个 URL，叫作统一资源定位符。之所以叫统一，是因为它是有格式的。HTTP 称为协议，<a href="http://www.163.com">www.163.com</a> 是一个域名，表示互联网上的一个位置。有的 URL 会有更详细的位置标识，例如 <a href="http://www.163.com/index.html">http://www.163.com/index.html</a> 。正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。</p><h3 id="14-1-HTTP-请求的准备">14.1 HTTP 请求的准备</h3><p>浏览器会将 <a href="http://www.163.com">www.163.com</a> 这个域名发送给 DNS 服务器，让它解析为 IP 地址。有关 DNS 的过程，其实非常复杂，这个在后面专门介绍 DNS 的时候，我会详细描述，这里我们先不管，反正它会被解析成为 IP 地址。那接下来是发送 HTTP 请求吗？</p><p>不是的，HTTP 是基于 TCP 协议的，当然是要先建立 TCP 连接了，怎么建立呢？还记得第 11 节讲过的三次握手吗？</p><p>目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。</p><p>学习了 TCP 之后，你应该知道，TCP 的三次握手和四次挥手，还是挺费劲的。如果好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。</p><h3 id="14-2-HTTP-请求的构建">14.2 HTTP 请求的构建</h3><p>建立了连接以后，浏览器就要发送 HTTP 的请求。</p><p>请求的格式就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150326073.png" alt="image-20240523150326073"></p><p>HTTP 的报文大概分为三大部分。第一部分是<strong>请求行</strong>，第二部分是请求的<strong>首部</strong>，第三部分才是请求的<strong>正文实体</strong>。</p><ol><li><p>第一部分：请求行</p><p>在请求行中，URL 就是 <a href="http://www.163.com/">http://www.163.com</a> ，版本为 HTTP 1.1。这里要说一下的，就是方法。方法有几种类型。</p><p>对于访问网页来讲，最常用的类型就是<strong>GET</strong>。顾名思义，GET 就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 JSON 字符串，到底要返回什么，是由服务器端的实现决定的。</p><p>例如，在云计算中，如果我们的服务器端要提供一个基于 HTTP 协议的 API，获取所有云主机的列表，这就会使用 GET 方法得到，返回的可能是一个 JSON 字符串。字符串里面是一个列表，列表里面是一项的云主机的信息。</p><p>另外一种类型叫做<strong>POST</strong>。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON。</p><p>例如，我们下一节要讲的支付场景，客户端就需要把”我是谁？我要支付多少？我要买啥？”告诉服务器，这就需要通过 POST 方法。</p><p>再如，在云计算里，如果我们的服务器端，要提供一个基于 HTTP 协议的创建云主机的 API，也会用到 POST 方法。这个时候往往需要将”我要创建多大的云主机？多少 CPU 多少内存？多大硬盘？”这些信息放在 JSON 字符串里面，通过 POST 的方法告诉服务器端。</p><p>还有一种类型叫<strong>PUT</strong>，就是向指定资源位置上传最新内容。但是，HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 就都变成了要传给服务器东西的方法。</p><p>在实际使用过程中，这两者还会有稍许的区别。POST 往往是用来创建一个资源的，而 PUT 往往是用来修改一个资源的。</p><p>例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用 PUT 方法。</p><p>再有一种常见的就是<strong>DELETE</strong>。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用 DELETE 方法。</p></li><li><p>第二部分：首部字段</p><p>请求行下面就是我们的首部字段。首部是 key value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。</p><p>例如，<strong>Accept-Charset</strong>，表示<strong>客户端可以接受的字符集</strong>。防止传过来的是另外的字符集，从而导致出现乱码。</p><p>再如，<strong>Content-Type</strong>是指<strong>正文的格式</strong>。例如，我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。</p><p>这里需要重点说一下的就是缓存。为啥要使用<strong>缓存</strong>呢？那是因为一个非常大的页面有很多东西。</p><p>例如，我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等。商品的展示图片会保持较长时间不变，而库存会根据用户购买的情况经常改变。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。</p><p>对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。</p><p>这个架构的图就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150519760.png" alt="image-20240523150519760"></p><p>其中 DNS、CDN 我在后面的章节会讲。和这一节关系比较大的就是 Nginx 这一层，它如何处理 HTTP 协议呢？对于静态资源，有 Vanish 缓存层。当缓存过期的时候，才会访问真正的 Tomcat 应用集群。</p><p>在 HTTP 头里面，Cache-control是用来控制缓存的。当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。</p><p>另外，If-Modified-Since也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回”304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。</p><p>到此为止，我们仅仅是拼凑起了 HTTP 请求的报文格式，接下来，浏览器会把它交给下一层传输层。怎么交给传输层呢？其实也无非是用 Socket 这些东西，只不过用的浏览器里，这些程序不需要你自己写，有人已经帮你写好了。</p></li></ol><h3 id="14-3-HTTP-请求的发送">14.3 HTTP 请求的发送</h3><p>HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。当然，到了 TCP 层，它会把二进制流变成一个的报文段发送给服务器。</p><p>在发送给每个报文段的时候，都需要对方有一个回应 ACK，来保证报文可靠地到达了对方。如果没有回应，那么 TCP 这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是 HTTP 这一层不需要知道这一点，因为是 TCP 这一层在埋头苦干。</p><p>TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 IP 层进行传输。</p><p>IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。</p><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。</p><p>这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去。</p><p>目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。</p><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。</p><h3 id="14-4-HTTP-返回的构建">14.4 HTTP 返回的构建</h3><p>HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150716333.png" alt="image-20240523150716333"></p><p>状态码会反应 HTTP 请求的结果。”200”意味着大吉大利；而我们最不想见的，就是”404”，也就是”服务端无法响应这个请求”。然后，短语会大概说一下原因。</p><p>接下来是返回首部的<strong>key value</strong>。</p><p>这里面，<strong>Retry-After</strong>表示，告诉客户端应该在多长时间以后再次尝试一下。”503 错误”是说”服务暂时不再和这个值配合使用”。</p><p>在返回的头部里面也会有<strong>Content-Type</strong>，表示返回的是 HTML，还是 JSON。</p><p>构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去。还是交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达。</p><p>这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。</p><p>客户端发现 MAC 地址符合、IP 地址符合，于是就会交给 TCP 层。根据序列号看是不是自己要的报文段，如果是，则会根据 TCP 头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。</p><p>当浏览器拿到了 HTTP 的报文。发现返回”200”，一切正常，于是就从正文中将 HTML 拿出来。HTML 是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。</p><p>这就是一个正常的 HTTP 请求和返回的完整过程。</p><h3 id="14-5-HTTP-2-0">14.5 HTTP 2.0</h3><p>当然 HTTP 协议也在不断地进化过程中，在 HTTP1.1 基础上便有了 HTTP 2.0。</p><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。</p><p>为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</p><p>另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。</p><p>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有<strong>Header 帧</strong>，用于传输 Header 内容，并且会开启一个新的流。再就是<strong>Data 帧</strong>，用来传输正文实体。多个 Data 帧属于同一个流。</p><p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p><p>我们来举一个例子。</p><p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150832889.png" alt="image-20240523150832889"></p><p>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523150855992.png" alt="image-20240523150855992"></p><p>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p><h3 id="14-6-QUIC-协议的”城会玩”">14.6 QUIC 协议的”城会玩”</h3><p>HTTP 2.0 虽然大大增加了并发性，但还是有问题的。因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。</p><p>当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。</p><p>于是，就又到了从 TCP 切换到 UDP，进行”城会玩”的时候了。这就是 Google 的 QUIC 协议，接下来我们来看它是如何”城会玩”的。</p><ol><li><p>机制一：自定义连接机制</p><p>我们都知道，一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的 IP、目的端口。一旦一个元素发生变化时，就需要断开重连，重新连接。在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延。</p><p>这在 TCP 是没有办法的，但是基于 UDP，就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。</p></li><li><p>机制二：自定义重传机制</p><p>前面我们讲过，TCP 为了保证可靠性，通过使用<strong>序号</strong>和<strong>应答</strong>机制，来解决顺序问题和丢包问题。</p><p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包。那怎么样才算超时呢？还记得我们提过的<strong>自适应重传算法</strong>吗？这个超时是通过<strong>采样往返时间 RTT</strong>不断调整的。</p><p>其实，在 TCP 里面超时的采样存在不准确的问题。例如，发送一个包，序号为 100，发现没有返回，于是再发送一个 100，过一阵返回一个 ACK101。这个时候客户端知道这个包肯定收到了，但是往返时间是多少呢？是 ACK 到达的时间减去后一个 100 发送的时间，还是减去前一个 100 发送的时间呢？事实是，第一种算法把时间算短了，第二种算法把时间算长了。</p><p>QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK 100，就是对第一个包的响应。如果返回 ACK 101 就是对第二个包的响应，RTT 计算相对准确。</p><p>但是这里有一个问题，就是怎么知道包 100 和包 101 发送的是同样的内容呢？QUIC 定义了一个 offset 概念。QUIC 既然是面向连接的，也就像 TCP 一样，是一个数据流，发送的数据在这个数据流里面有个偏移量 offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发；如果来了，按照 offset 拼接，还是能够拼成一个流。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523153054377.png" alt="image-20240523153054377"></p><ol start="3"><li>机制三：无阻塞的多路复用</li></ol><p>有了自定义的连接和重传机制，我们就可以解决上面 HTTP 2.0 的多路复用问题。</p><p>同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。</p><ol start="4"><li><p>机制四：自定义流量控制</p><p>TCP 的流量控制是通过滑动窗口协议。QUIC 的流量控制也是通过 window_update，来告诉对端它可以接受的字节数。但是 QUIC 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。</p><p>还记得吗？在 TCP 协议中，接收端的窗口的起始点是下一个要接收并且 ACK 的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为 TCP 的 ACK 机制是基于序列号的累计应答，一旦 ACK 了一个系列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能 ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。</p><p>QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523153744155.png" alt="image-20240523153744155"></p><ol><li>另外，还有整个连接的窗口，需要对于所有的 stream 的窗口做一个统计。</li></ol><h3 id="14-7-小结">14.7 小结</h3><p>总结一下：</p><ul><li>HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；</li><li>HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；</li><li>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</li></ul><h2 id="第15讲-HTTPS协议：点外卖的过程原来这么复杂">第15讲 | HTTPS协议：点外卖的过程原来这么复杂</h2><p>用 HTTP 协议，看个新闻还没有问题，但是换到更加严肃的场景中，就存在很多的安全风险。例如，你要下单做一次支付，如果还是使用普通的 HTTP 协议，那你很可能会被黑客盯上。</p><p>你发送一个请求，说我要点个外卖，但是这个网络包被截获了，于是在服务器回复你之前，黑客先假装自己就是外卖网站，然后给你回复一个假的消息说：”好啊好啊，来来来，银行卡号、密码拿来。”如果这时候你真把银行卡密码发给它，那你就真的上套了。</p><p>那怎么解决这个问题呢？当然一般的思路就是<strong>加密</strong>。加密分为两种方式一种是<strong>对称加密</strong>，一种是<strong>非对称加密</strong>。</p><p>在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。</p><p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。</p><p>因为对称加密算法相比非对称加密算法来说，效率要高得多，性能也好，所以交互的场景下多用对称加密。</p><h3 id="15-1-对称加密">15.1 对称加密</h3><p>假设你和外卖网站约定了一个密钥，你发送请求的时候用这个密钥进行加密，外卖网站用同样的密钥进行解密。这样就算中间的黑客截获了你的请求，但是它没有密钥，还是破解不了。</p><p>这看起来很完美，但是中间有个问题，你们两个怎么来约定这个密钥呢？如果这个密钥在互联网上传输，也是很有可能让黑客截获的。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。</p><p>我们在谍战剧里面经常看到这样的场景，就是特工破译的密码会有个密码本，截获无线电台，通过密码本就能将原文破解出来。怎么把密码本给对方呢？只能通过线下传输。</p><p>比如，你和外卖网站偷偷约定时间地点，它给你一个纸条，上面写着你们两个的密钥，然后说以后就用这个密钥在互联网上定外卖了。当然你们接头的时候，也会先约定一个口号，什么”天王盖地虎”之类的，口号对上了，才能把纸条给它。但是，”天王盖地虎”同样也是对称加密密钥，同样存在如何把”天王盖地虎”约定成口号的问题。而且在谍战剧中一对一接头可能还可以，在互联网应用中，客户太多，这样是不行的。</p><h3 id="15-2-非对称加密">15.2 非对称加密</h3><p>所以，只要是对称加密，就会永远在这个死循环里出不来，这个时候，就需要非对称加密介入进来。</p><p>非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。但是，对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。</p><p>比如说你用公钥加密，说”我要定外卖”，黑客在中间就算截获了这个报文，因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站，外卖网站用私钥把这个报文解出来，然后回复，”那给我银行卡和支付密码吧”。</p><p>先别太乐观，这里还是有问题的。回复的这句话，是外卖网站拿私钥加密的，互联网上人人都可以把它打开，当然包括黑客。那外卖网站可以拿公钥加密吗？当然不能，因为它自己的私钥只有它自己知道，谁也解不开。</p><p>另外，这个过程还有一个问题，黑客也可以模拟发送”我要定外卖”这个过程的，因为它也有外卖网站的公钥。</p><p>为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥，并且客户端要把自己的公钥，给外卖网站。</p><p>这样，客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候，使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。</p><h3 id="15-3-数字证书">15.3 数字证书</h3><p>不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。</p><p>这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。</p><p>例如，我自己搭建了一个网站 cliu8site，可以通过这个命令先创建私钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out cliu8siteprivate.key 1024</span><br></pre></td></tr></table></figure><p>然后，再根据这个私钥，创建对应的公钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> cliu8siteprivate.key -pubout -outcliu8sitepublic.pem</span><br></pre></td></tr></table></figure><p>这个时候就需要权威部门的介入了，就像每个人都可以打印自己的简历，说自己是谁，但是有公安局盖章的，就只有户口本，这个才能证明你是你。这个由权威部门颁发的称为<strong>证书（Certificate）</strong>。</p><p>证书里面有什么呢？当然应该有<strong>公钥</strong>，这是最重要的；还有证书的<strong>所有者</strong>，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的<strong>发布机构</strong>和证书的<strong>有效期</strong>，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。</p><p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为<strong>CA（ Certificate Authority）</strong>。</p><p>证书请求可以通过这个命令生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req</span><br></pre></td></tr></table></figure><p>将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为 <strong>签名算法</strong> 。 问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。</p><p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。</p><p>权威机构给证书签名的命令是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem</span><br></pre></td></tr></table></figure><p>这个命令会返回 Signature ok，而 cliu8sitecertificate.pem 就是签过名的证书。CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。</p><p>我们来查看这个证书的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cliu8sitecertificate.pem -noout -text</span><br></pre></td></tr></table></figure><p>这里面有个 Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity 是证书期限；Public-key 是公钥内容；Signature Algorithm 是签名算法。</p><p>这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。</p><p>你有没有发现，又有新问题了。要想验证证书，需要 CA 的公钥，问题是，你怎么确定 CA 的公钥就是对的呢？</p><p>所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大 CA，称为<strong>root CA</strong>，做最后的背书。通过这种<strong>层层授信背书</strong>的方式，从而保证了非对称加密模式的正常运转。</p><p>除此之外，还有一种证书，称为<strong>Self-Signed Certificate</strong>，就是自己给自己签名。这个给人一种”我就是我，你爱信不信”的感觉。这里我就不多说了。</p><h3 id="15-4-HTTPS-的工作模式">15.4 HTTPS 的工作模式</h3><p>我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。</p><p>当然是可以的。这就是 HTTPS 协议的总体思路。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523154846962.png" alt="image-20240523154846962"></p><p>当你登录一个外卖网站的时候，由于是 HTTPS，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有一个随机数，在协商对称密钥的时候使用。</p><p>这就类似在说：”您好，我想定外卖，但你要保密我吃的是什么。这是我的加密套路，再给你个随机数，你留着。”</p><p>然后，外卖网站返回 Server Hello 消息, 告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。</p><p>这就类似在说：”您好，保密没问题，你的加密套路还挺多，咱们就按套路 2 来吧，我这里也有个随机数，你也留着。”</p><p>然后，外卖网站会给你一个服务器端的证书，然后说：”Server Hello Done，我这里就这些信息了。”</p><p>你当然不相信这个证书，于是你从自己信任的 CA 仓库中，拿 CA 的证书里面的公钥去解密外卖网站的证书。如果能够成功，则说明外卖网站是可信的。这个过程中，你可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，反正直到一个授信的 CA，就可以了。</p><p>证书验证完毕之后，觉得这个外卖网站可信，于是客户端计算产生随机数字 Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密出来。</p><p>到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。</p><p>有了对称密钥，客户端就可以说：”Change Cipher Spec，咱们以后都采用协商的通信密钥和加密算法进行加密通信了。”</p><p>然后发送一个 Encrypted Handshake Message，将已经商定好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。</p><p>同样，服务器也可以发送 Change Cipher Spec，说：”没问题，咱们以后都采用协商的通信密钥和加密算法进行加密通信了”，并且也发送 Encrypted Handshake Message 的消息试试。当双方握手结束之后，就可以通过对称密钥进行加密传输了。</p><p>这个过程除了加密解密之外，其他的过程和 HTTP 是一样的，过程也非常复杂。</p><p>上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。</p><h3 id="15-5-重放与篡改">15.5 重放与篡改</h3><p>其实，这里还有一些没有解决的问题，例如重放和篡改的问题。</p><p>没错，有了加密和解密，黑客截获了包也打不开了，但是它可以发送 N 次。这个往往通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。</p><p>Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的，请求只接受一次，于是服务器多次受到相同的 Timestamp 和 Nonce，则视为无效即可。</p><p>如果有人想篡改 Timestamp 和 Nonce，还有签名保证不可篡改性，如果改了用签名算法解出来，就对不上了，可以丢弃了。</p><h3 id="15-6-小结">15.6 小结</h3><p>总结一下。</p><ul><li>加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。</li><li>非对称加密需要通过证书和权威机构来验证公钥的合法性。</li><li>HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。</li></ul><h2 id="第16讲-流媒体协议：如何在直播里看到美女帅哥？">第16讲 | 流媒体协议：如何在直播里看到美女帅哥？</h2><h3 id="16-1-三个名词系列">16.1 三个名词系列</h3><p>我这里列三个名词系列，你先大致有个印象。</p><ul><li><strong>名词系列一</strong>：AVI、MPEG、RMVB、MP4、MOV、FLV、WebM、WMV、ASF、MKV。例如 RMVB 和 MP4，看着是不是很熟悉？</li><li><strong>名词系列二</strong>：H.261、 H.262、H.263、H.264、H.265。这个是不是就没怎么听过了？别着急，你先记住，要重点关注 H.264。</li><li><strong>名词系列三</strong>：MPEG-1、MPEG-2、MPEG-4、MPEG-7。MPEG 好像听说过，但是后面的数字是怎么回事？是不是又熟悉又陌生？</li></ul><p>这里，我想问你个问题，视频是什么？我说，其实就是快速播放一连串连续的图片。</p><p>每一张图片，我们称为一<strong>帧</strong>。只要每秒钟帧的数据足够多，也即播放得足够快。比如每秒 30 帧，以人的眼睛的敏感程度，是看不出这是一张张独立的图片的，这就是我们常说的<strong>帧率（FPS）</strong>。</p><p>每一张图片，都是由<strong>像素</strong>组成的，假设为 1024*768（这个像素数不算多）。每个像素由 RGB 组成，每个 8 位，共 24 位。</p><p>我们来算一下，每秒钟的视频有多大？</p><p>30 帧 × 1024 × 768 × 24 = 566,231,040Bits = 70,778,880Bytes</p><p>如果一分钟呢？4,246,732,800Bytes，已经是 4 个 G 了。</p><p>是不是不算不知道，一算吓一跳？这个数据量实在是太大，根本没办法存储和传输。如果这样存储，你的硬盘很快就满了；如果这样传输，那多少带宽也不够用啊！</p><p>怎么办呢？人们想到了<strong>编码</strong>，就是看如何用尽量少的 Bit 数保存视频，使播放的时候画面看起来仍然很精美。<strong>编码是一个压缩的过程</strong>。</p><h3 id="16-2-视频和图片的压缩过程有什么特点？">16.2 视频和图片的压缩过程有什么特点？</h3><ol><li>空间冗余：图像的相邻像素之间有较强的相关性，一张图片相邻像素往往是渐变的，不是突变的，没必要每个像素都完整地保存，可以隔几个保存一个，中间的用算法计算出来。</li><li>时间冗余：视频序列的相邻图像之间内容相似。一个视频中连续出现的图片也不是突变的，可以根据已有的图片进行预测和推断。</li><li>视觉冗余：人的视觉系统对某些细节不敏感，因此不会每一个细节都注意到，可以允许丢失一些数据。</li><li>编码冗余：不同像素值出现的概率不同，概率高的用的字节少，概率低的用的字节多，类似霍夫曼编码（Huffman Coding）的思路。</li></ol><p>总之，用于编码的算法非常复杂，而且多种多样，但是编码过程其实都是类似的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155047425.png" alt="image-20240523155047425"></p><h3 id="16-3-视频编码的两大流派">16.3 视频编码的两大流派</h3><p>能不能形成一定的标准呢？要不然开发视频播放的人得累死了。当然能，我这里就给你介绍，视频编码的两大流派。</p><ul><li>流派一：ITU（International Telecommunications Union）的 VCEG（Video Coding Experts Group），这个称为<strong>国际电联下的 VCEG</strong>。既然是电信，可想而知，他们最初做视频编码，主要侧重传输。名词系列二，就是这个组织制定的标准。</li><li>流派二：ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），这个是<strong>ISO 旗下的 MPEG</strong>，本来是做视频存储的。例如，编码后保存在 VCD 和 DVD 中。当然后来也慢慢侧重视频传输了。名词系列三，就是这个组织制定的标准。</li></ul><p>后来，ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC，这才是我们这一节要重点关注的。</p><h3 id="16-4-如何在直播里看到帅哥美女？">16.4 如何在直播里看到帅哥美女？</h3><p>网络协议将<strong>编码</strong>好的视频流，从主播端推送到服务器，在服务器上有个运行了同样协议的服务端来接收这些网络包，从而得到里面的视频流，这个过程称为<strong>接流</strong>。</p><p>服务端接到视频流之后，可以对视频流进行一定的处理，例如<strong>转码</strong>，也即从一个编码格式，转成另一种格式。因为观众使用的客户端千差万别，要保证他们都能看到直播。</p><p><strong>流处理</strong>完毕之后，就可以等待观众的客户端来请求这些视频流。观众的客户端请求的过程称为<strong>拉流</strong>。</p><p>如果有非常多的观众，同时看一个视频直播，那都从一个服务器上<strong>拉流</strong>，压力太大了，因而需要一个视频的<strong>分发</strong>网络，将视频预先加载到就近的边缘节点，这样大部分观众看的视频，是从边缘节点拉取的，就能降低服务器的压力。</p><p>当观众的客户端将视频流拉下来之后，就需要进行<strong>解码</strong>，也即通过上述过程的逆过程，将一串串看不懂的二进制，再转变成一帧帧生动的图片，在客户端<strong>播放</strong>出来，这样你就能看到美女帅哥啦。</p><p>整个直播过程，可以用这个的图来描述。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155206978.png" alt="image-20240523155206978"></p><h3 id="16-5-编码：如何将丰富多彩的图片变成二进制流？">16.5 编码：如何将丰富多彩的图片变成二进制流？</h3><p>虽然我们说视频是一张张图片的序列，但是如果每张图片都完整，就太大了，因而会将视频序列分成三种帧。</p><ul><li><strong>I 帧</strong>，也称关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。</li><li><strong>P 帧</strong>，前向预测编码帧。P 帧表示的是这一帧跟之前的一个关键帧（或 P 帧）的差别，解码时需要用之前缓存的画面，叠加上和本帧定义的差别，生成最终画面。</li><li><strong>B 帧</strong>，双向预测内插编码帧。B 帧记录的是本帧与前后帧的差别。要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据与本帧数据的叠加，取得最终的画面。</li></ul><p>可以看出，I 帧最完整，B 帧压缩率最高，而压缩后帧的序列，应该是在 IBBP 的间隔出现的。这就是<strong>通过时序进行编码</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155222287.png" alt="image-20240523155222287"></p><p>在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，可以方便进行<strong>空间上的编码</strong>。</p><p>尽管时空非常立体的组成了一个序列，但是总归还是要压缩成一个二进制流。这个流是有结构的，是一个个的<strong>网络提取层单元（NALU，Network Abstraction Layer Unit）</strong>。变成这种格式就是为了传输，因为网络上的传输，默认的是一个个的包，因而这里也就分成了一个个的单元。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155235317.png" alt="image-20240523155235317"></p><p>每一个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔；然后是 NALU 的头，里面主要配置了 NALU 的类型；最终 Payload 里面是 NALU 承载的数据。</p><p>在 NALU 头里面，主要的内容是类型<strong>NAL Type</strong>。</p><ul><li>0x07 表示 SPS，是序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。</li><li>0x08 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。</li></ul><p>在传输视频流之前，必须要传输这两类参数，不然无法解码。为了保证容错性，每一个 I 帧前面，都会传一遍这两个参数集合。</p><p>如果 NALU Header 里面的表示类型是 SPS 或者 PPS，则 Payload 中就是真正的参数集的内容。</p><p>如果类型是帧，则 Payload 中才是正的视频数据，当然也是一帧一帧存放的，前面说了，一帧的内容还是挺多的，因而每一个 NALU 里面保存的是一片。对于每一片，到底是 I 帧，还是 P 帧，还是 B 帧，在片结构里面也有个 Header，这里面有个类型，然后是片的内容。</p><p>这样，整个格式就出来了，<strong>一个视频，可以拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个 NALU 里面，NALU 之间都是通过特殊的起始标识符分隔，在每一个 I 帧的第一片前面，要插入单独保存 SPS 和 PPS 的 NALU，最终形成一个长长的 NALU 序列</strong>。</p><h3 id="16-6-推流：如何把数据流打包传输到对端？">16.6 推流：如何把数据流打包传输到对端？</h3><p>那这个格式是不是就能够直接在网上传输到对端，开始直播了呢？其实还不是，还需要将这个二进制的流打包成网络包进行发送，这里我们使用<strong>RTMP 协议</strong>。这就进入了第二个过程，<strong>推流</strong>。</p><p>RTMP 是基于 TCP 的，因而肯定需要双方建立一个 TCP 的连接。在有 TCP 的连接的基础上，还需要建立一个 RTMP 的连接，也即在程序里面，你需要调用 RTMP 类库的 Connect 函数，显示创建一个连接。</p><p>RTMP 为什么需要建立一个单独的连接呢？</p><p>因为它们需要商量一些事情，保证以后的传输能正常进行。主要就是两个事情，一个是<strong>版本号</strong>，如果客户端、服务器的版本号不一致，则不能工作。另一个就是<strong>时间戳</strong>，视频播放中，时间是很重要的，后面的数据流互通的时候，经常要带上时间戳的差值，因而一开始双方就要知道对方的时间戳。</p><p>未来沟通这些事情，需要发送六条消息：客户端发送 C0、C1、 C2，服务器发送 S0、 S1、 S2。</p><p>首先，客户端发送 C0 表示自己的版本号，不必等对方的回复，然后发送 C1 表示自己的时间戳。</p><p>服务器只有在收到 C0 的时候，才能返回 S0，表明自己的版本号，如果版本不匹配，可以断开连接。</p><p>服务器发送完 S0 后，也不用等什么，就直接发送自己的时间戳 S1。客户端收到 S1 的时候，发一个知道了对方时间戳的 ACK C2。同理服务器收到 C1 的时候，发一个知道了对方时间戳的 ACK S2。</p><p>于是，握手完成。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155252712.png" alt="image-20240523155252712"></p><p>握手之后，双方需要互相传递一些控制信息，例如 Chunk 块的大小、窗口大小等。</p><p>真正传输数据的时候，还是需要创建一个流 Stream，然后通过这个 Stream 来推流 publish。</p><p>推流的过程，就是将 NALU 放在 Message 里面发送，这个也称为<strong>RTMP Packet 包</strong>。Message 的格式就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155302680.png" alt="image-20240523155302680"></p><p>发送的时候，去掉 NALU 的起始标识符。因为这部分对于 RTMP 协议来讲没有用。接下来，将 SPS 和 PPS 参数集封装成一个 RTMP 包发送，然后发送一个个片的 NALU。</p><p>RTMP 在收发数据的时候并不是以 Message 为单位的，而是把 Message 拆分成 Chunk 发送，而且必须在一个 Chunk 发送完成之后，才能开始发送下一个 Chunk。每个 Chunk 中都带有 Message ID，表示属于哪个 Message，接收端也会按照这个 ID 将 Chunk 组装成 Message。</p><p>前面连接的时候，设置的 Chunk 块大小就是指这个 Chunk。将大的消息变为小的块再发送，可以在低带宽的情况下，减少网络拥塞。</p><p>这有一个分块的例子，你可以看一下。</p><p>假设一个视频的消息长度为 307，但是 Chunk 大小约定为 128，于是会拆分为三个 Chunk。</p><ul><li>第一个 Chunk 的 Type＝0，表示 Chunk 头是完整的；头里面 Timestamp 为 1000，总长度 Length 为 307，类型为 9，是个视频，Stream ID 为 12346，正文部分承担 128 个字节的 Data。</li><li>第二个 Chunk 也要发送 128 个字节，Chunk 头由于和第一个 Chunk 一样，因此采用 Chunk Type＝3，表示头一样就不再发送了。</li><li>第三个 Chunk 要发送的 Data 的长度为 307-128-128=51 个字节，还是采用 Type＝3。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155314600.png" alt="image-20240523155314600"></p><p>就这样数据就源源不断到达流媒体服务器，整个过程就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155326858.png" alt="image-20240523155326858"></p><p>这个时候，大量观看直播的观众就可以通过 RTMP 协议从流媒体服务器上拉取，但是这么多的用户量，都去同一个地方拉取，服务器压力会很大，而且用户分布在全国甚至全球，如果都去统一的一个地方下载，也会时延比较长，需要有分发网络。</p><p>分发网络分为<strong>中心</strong>和<strong>边缘</strong>两层。边缘层服务器部署在全国各地及横跨各大运营商里，和用户距离很近。中心层是流媒体服务集群，负责内容的转发。智能负载均衡系统，根据用户的地理位置信息，就近选择边缘服务器，为用户提供推 / 拉流服务。中心层也负责转码服务，例如，把 RTMP 协议的码流转换为 HLS 码流。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155351892.png" alt="image-20240523155351892"></p><p>这套机制在后面的 DNS、HTTPDNS、CDN 的章节会更有详细的描述。</p><h3 id="16-7-拉流：观众的客户端如何看到视频？">16.7 拉流：观众的客户端如何看到视频？</h3><p>接下来，我们再来看观众的客户端通过 RTMP 拉流的过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523155422589.png" alt="image-20240523155422589"></p><p>先读到的是 H.264 的解码参数，例如 SPS 和 PPS，然后对收到的 NALU 组成的一个个帧，进行解码，交给播发器播放，一个绚丽多彩的视频画面就出来了。</p><h3 id="16-8-小结">16.8 小结</h3><p>总结一下：</p><ul><li>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</li><li>压缩好的数据，为了传输组成一系列 NALU，按照帧和片依次排列；</li><li>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成 Chunk 进行传输；</li><li>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。</li></ul><h2 id="第17讲-P2P协议：我下小电影，99-急死你">第17讲 | P2P协议：我下小电影，99%急死你</h2><p>如果你想下载一个电影，一般会通过什么方式呢？</p><p>当然，最简单的方式就是通过<strong>HTTP</strong>进行下载。但是相信你有过这样的体验，通过浏览器下载的时候，只要文件稍微大点，下载的速度就奇慢无比。</p><p>还有种下载文件的方式，就是通过<strong>FTP</strong>，也即<strong>文件传输协议</strong>。FTP 采用两个 TCP 连接来传输一个文件。</p><ul><li><strong>控制连接</strong>：服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将命令从客户端传给服务器，并传回服务器的应答。常用的命令有：list——获取文件目录；reter——取一个文件；store——存一个文件。</li><li><strong>数据连接</strong>：每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。</li></ul><h3 id="17-1-FTP-的两种工作模式">17.1 FTP 的两种工作模式</h3><p>每传输一个文件，都要建立一个全新的数据连接。FTP 有两种工作模式，分别是<strong>主动模式（PORT）<strong>和</strong>被动模式（PASV）</strong>，这些都是站在 FTP 服务器的角度来说的。</p><p>主动模式下，客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1。</p><p>被动模式下，当开启一个 FTP 连接时，客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回”227 entering passive mode”消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。</p><h3 id="17-2-P2P-是什么？">17.2 P2P 是什么？</h3><p>但是无论是 HTTP 的方式，还是 FTP 的方式，都有一个比较大的缺点，就是<strong>难以解决单一服务器的带宽压力</strong>， 因为它们使用的都是传统的客户端服务器的方式。</p><p>后来，一种创新的、称为 P2P 的方式流行起来。<strong>P2P</strong>就是<strong>peer-to-peer</strong>。资源开始并不集中地存储在某些设备上，而是分散地存储在多台设备上。这些设备我们姑且称为 peer。</p><p>想要下载一个文件的时候，你只要得到那些已经存在了文件的 peer，并和这些 peer 之间，建立点对点的连接，而不需要到中心服务器上，就可以就近下载文件。一旦下载了文件，你也就成为 peer 中的一员，你旁边的那些机器，也可能会选择从你这里下载文件，所以当你使用 P2P 软件的时候，例如 BitTorrent，往往能够看到，既有下载流量，也有上传的流量，也即你自己也加入了这个 P2P 的网络，自己从别人那里下载，同时也提供给其他人下载。可以想象，这种方式，参与的人越多，下载速度越快，一切完美。</p><h3 id="17-3-种子（-torrent）文件">17.3 种子（.torrent）文件</h3><p>但是有一个问题，当你想下载一个文件的时候，怎么知道哪些 peer 有这个文件呢？</p><p>这就用到<strong>种子</strong>啦，也即咱们比较熟悉的**.torrent** 文件。.torrent 文件由两部分组成，分别是：<strong>announce（tracker URL）<strong>和</strong>文件信息</strong>。</p><p>文件信息里面有这些内容。</p><ul><li><strong>info 区</strong>：这里指定的是该种子有几个文件、文件有多长、目录结构，以及目录和文件的名字。</li><li><strong>Name 字段</strong>：指定顶层目录名字。</li><li><strong>每个段的大小</strong>：BitTorrent（简称 BT）协议把一个文件分成很多个小段，然后分段下载。</li><li><strong>段哈希值</strong>：将整个种子中，每个段的 SHA-1 哈希值拼在一起。</li></ul><p>下载时，BT 客户端首先解析.torrent 文件，得到 tracker 地址，然后连接 tracker 服务器。tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者。下载者再连接其他下载者，根据.torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。</p><p>下载者每得到一个块，需要算出下载块的 Hash 验证码，并与.torrent 文件中的对比。如果一样，则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。</p><p>从这个过程也可以看出，这种方式特别依赖 tracker。tracker 需要收集下载者信息的服务器，并将此信息提供给其他下载者，使下载者们相互连接起来，传输数据。虽然下载的过程是非中心化的，但是加入这个 P2P 网络的时候，都需要借助 tracker 中心服务器，这个服务器是用来登记有哪些用户在请求哪些资源。</p><p>所以，这种工作方式有一个弊端，一旦 tracker 服务器出现故障或者线路遭到屏蔽，BT 工具就无法正常工作了。</p><h3 id="17-4-去中心化网络（DHT）">17.4 去中心化网络（DHT）</h3><p>于是，后来就有了一种叫作**DHT（Distributed Hash Table）**的去中心化网络。每个加入这个 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。</p><p>有一种著名的 DHT 协议，叫<strong>Kademlia 协议</strong>。这个和区块链的概念一样，很抽象，我来详细讲一下这个协议。</p><p>任何一个 BitTorrent 启动之后，它都有两个角色。一个是<strong>peer</strong>，监听一个 TCP 端口，用来上传和下载文件，这个角色表明，我这里有某个文件。另一个角色<strong>DHT node</strong>，监听一个 UDP 的端口，通过这个角色，这个节点加入了一个 DHT 的网络。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523160112112.png" alt="image-20240523160112112"></p><p>在 DHT 网络里面，每一个 DHT node 都有一个 ID。这个 ID 是一个很长的串。每个 DHT node 都有责任掌握一些知识，也就是<strong>文件索引</strong>，也即它应该知道某些文件是保存在哪些节点上。它只需要有这些知识就可以了，而它自己本身不一定就是保存这个文件的节点。</p><h3 id="17-5-哈希值">17.5 哈希值</h3><p>当然，每个 DHT node 不会有全局的知识，也即不知道所有的文件保存在哪里，它只需要知道一部分。那应该知道哪一部分呢？这就需要用哈希算法计算出来。</p><p>每个文件可以计算出一个哈希值，而<strong>DHT node 的 ID 是和哈希值相同长度的串</strong>。</p><p>DHT 算法是这样规定的：<strong>如果一个文件计算出一个哈希值，则和这个哈希值一样的那个 DHT node，就有责任知道从哪里下载这个文件，即便它自己没保存这个文件</strong>。</p><p>当然不一定这么巧，总能找到和哈希值一模一样的，有可能一模一样的 DHT node 也下线了，所以 DHT 算法还规定：除了一模一样的那个 DHT node 应该知道，ID 和这个哈希值非常接近的 N 个 DHT node 也应该知道。</p><p>什么叫和哈希值接近呢？例如只修改了最后一位，就很接近；修改了倒数 2 位，也不远；修改了倒数 3 位，也可以接受。总之，凑齐了规定的 N 这个数就行。</p><p>刚才那个图里，文件 1 通过哈希运算，得到匹配 ID 的 DHT node 为 node C，当然还会有其他的，我这里没有画出来。所以，node C 有责任知道文件 1 的存放地址，虽然 node C 本身没有存放文件 1。</p><p>同理，文件 2 通过哈希运算，得到匹配 ID 的 DHT node 为 node E，但是 node D 和 E 的 ID 值很近，所以 node D 也知道。当然，文件 2 本身没有必要一定在 node D 和 E 里，但是碰巧这里就在 E 那有一份。</p><p>接下来一个新的节点 node new 上线了。如果想下载文件 1，它首先要加入 DHT 网络，如何加入呢？</p><p>在这种模式下，种子.torrent 文件里面就不再是 tracker 的地址了，而是一个 list 的 node 的地址，而所有这些 node 都是已经在 DHT 网络里面的。当然随着时间的推移，很可能有退出的，有下线的，但是我们假设，不会所有的都联系不上，总有一个能联系上。</p><p>node new 只要在种子里面找到一个 DHT node，就加入了网络。</p><p>node new 会计算文件 1 的哈希值，并根据这个哈希值了解到，和这个哈希值匹配，或者很接近的 node 上知道如何下载这个文件，例如计算出来的哈希值就是 node C。</p><p>但是 node new 不知道怎么联系上 node C，因为种子里面的 node 列表里面很可能没有 node C，但是它可以问，DHT 网络特别像一个社交网络，node new 只有去它能联系上的 node 问，你们知道不知道 node C 的联系方式呀？</p><p>在 DHT 网络中，每个 node 都保存了一定的联系方式，但是肯定没有 node 的所有联系方式。DHT 网络中，节点之间通过互相通信，也会交流联系方式，也会删除联系方式。和人们的方式一样，你有你的朋友圈，你的朋友有它的朋友圈，你们互相加微信，就互相认识了，过一段时间不联系，就删除朋友关系。</p><p>有个理论是，社交网络中，任何两个人直接的距离不超过六度，也即你想联系比尔盖茨，也就六个人就能够联系到了。</p><p>所以，node new 想联系 node C，就去万能的朋友圈去问，并且求转发，朋友再问朋友，很快就能找到。如果找不到 C，也能找到和 C 的 ID 很像的节点，它们也知道如何下载文件 1。</p><p>在 node C 上，告诉 node new，下载文件 1，要去 B、D、 F，于是 node new 选择和 node B 进行 peer 连接，开始下载，它一旦开始下载，自己本地也有文件 1 了，于是 node new 告诉 node C 以及和 node C 的 ID 很像的那些节点，我也有文件 1 了，可以加入那个文件拥有者列表了。</p><p>但是你会发现 node new 上没有文件索引，但是根据哈希算法，一定会有某些文件的哈希值是和 node new 的 ID 匹配上的。在 DHT 网络中，会有节点告诉它，你既然加入了咱们这个网络，你也有责任知道某些文件的下载地址。</p><p>好了，一切都分布式了。</p><p>这里面遗留几个细节的问题。</p><ol><li><p>DHT node ID 以及文件哈希是个什么东西？</p><p>节点 ID 是一个随机选择的 160bits（20 字节）空间，文件的哈希也使用这样的 160bits 空间。</p></li><li><p>所谓 ID 相似，具体到什么程度算相似？</p><p>在 Kademlia 网络中，距离是通过异或（XOR）计算的。我们就不以 160bits 举例了。我们以 5 位来举例。</p><p>01010 与 01000 的距离，就是两个 ID 之间的异或值，为 00010，也即为 2。 01010 与 00010 的距离为 01000，也即为 8,。01010 与 00011 的距离为 01001，也即 8+1=9 。以此类推，高位不同的，表示距离更远一些；低位不同的，表示距离更近一些，总的距离为所有的不同的位的距离之和。</p><p>这个距离不能比喻为地理位置，因为在 Kademlia 网络中，位置近不算近，ID 近才算近，所以我把这个距离比喻为社交距离，也即在朋友圈中的距离，或者社交网络中的距离。这个和你住的位置没有关系，和人的经历关系比较大。</p><p>还是以 5 位 ID 来举例，就像在领英中，排第一位的表示最近一份工作在哪里，第二位的表示上一份工作在哪里，然后第三位的是上上份工作，第四位的是研究生在哪里读，第五位的表示大学在哪里读。</p><p>如果你是一个猎头，在上面找候选人，当然最近的那份工作是最重要的。而对于工作经历越丰富的候选人，大学在哪里读的反而越不重要。</p></li></ol><h3 id="17-6-DHT-网络中的朋友圈是怎么维护的？">17.6 DHT 网络中的朋友圈是怎么维护的？</h3><p>就像人一样，虽然我们常联系人的只有少数，但是朋友圈里肯定是远近都有。DHT 网络的朋友圈也是一样，远近都有，并且按<strong>距离分层</strong>。</p><p>假设某个节点的 ID 为 01010，如果一个节点的 ID，前面所有位数都与它相同，只有最后 1 位不同。这样的节点只有 1 个，为 01011。与基础节点的异或值为 00001，即距离为 1；对于 01010 而言，这样的节点归为”k-bucket 1”。</p><p>如果一个节点的 ID，前面所有位数都相同，从倒数第 2 位开始不同，这样的节点只有 2 个，即 01000 和 01001，与基础节点的异或值为 00010 和 00011，即距离范围为 2 和 3；对于 01010 而言，这样的节点归为”k-bucket 2”。</p><p>如果一个节点的 ID，前面所有位数相同，从倒数第 i 位开始不同，这样的节点只有 2^(i-1) 个，与基础节点的距离范围为 [2^(i-1), 2^i)；对于 01010 而言，这样的节点归为”k-bucket i”。</p><p>最终到从倒数 160 位就开始都不同。</p><p>你会发现，差距越大，陌生人越多，但是朋友圈不能都放下，所以每一层都只放 K 个，这是参数可以配置。</p><h3 id="17-7-DHT-网络是如何查找朋友的？">17.7 DHT 网络是如何查找朋友的？</h3><p>假设，node A 的 ID 为 00110，要找 node B ID 为 10000，异或距离为 10110，距离范围在 [2^4, 2^5)，所以这个目标节点可能在”k-bucket 5”中，这就说明 B 的 ID 与 A 的 ID 从第 5 位开始不同，所以 B 可能在”k-bucket 5”中。</p><p>然后，A 看看自己的 k-bucket 5 有没有 B。如果有，太好了，找到你了；如果没有，在 k-bucket 5 里随便找一个 C。因为是二进制，C、B 都和 A 的第 5 位不同，那么 C 的 ID 第 5 位肯定与 B 相同，即它与 B 的距离会小于 2^4，相当于比 A、B 之间的距离缩短了一半以上。</p><p>再请求 C，在它自己的通讯录里，按同样的查找方式找一下 B。如果 C 知道 B，就告诉 A；如果 C 也不知道 B，那 C 按同样的搜索方法，可以在自己的通讯录里找到一个离 B 更近的 D 朋友（D、B 之间距离小于 2^3），把 D 推荐给 A，A 请求 D 进行下一步查找。</p><p>Kademlia 的这种查询机制，是通过折半查找的方式来收缩范围，对于总的节点数目为 N，最多只需要查询 log2(N) 次，就能够找到。</p><p>例如，图中这个最差的情况。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523160146516.png" alt="image-20240523160146516"></p><p>A 和 B 每一位都不一样，所以相差 31，A 找到的朋友 C，不巧正好在中间。和 A 的距离是 16，和 B 距离为 15，于是 C 去自己朋友圈找的时候，不巧找到 D，正好又在中间，距离 C 为 8，距离 B 为 7。于是 D 去自己朋友圈找的时候，不巧找到 E，正好又在中间，距离 D 为 4，距离 B 为 3，E 在朋友圈找到 F，距离 E 为 2，距离 B 为 1，最终在 F 的朋友圈距离 1 的地方找到 B。当然这是最最不巧的情况，每次找到的朋友都不远不近，正好在中间。</p><p>如果碰巧了，在 A 的朋友圈里面有 G，距离 B 只有 3，然后在 G 的朋友圈里面一下子就找到了 B，两次就找到了。</p><h3 id="17-8-在-DHT-网络中，朋友之间怎么沟通呢？">17.8 在 DHT 网络中，朋友之间怎么沟通呢？</h3><ul><li>PING：测试一个节点是否在线，还活着没，相当于打个电话，看还能打通不。</li><li>STORE：要求一个节点存储一份数据，既然加入了组织，有义务保存一份数据。</li><li>FIND_NODE：根据节点 ID 查找一个节点，就是给一个 160 位的 ID，通过上面朋友圈的方式找到那个节点。</li><li>FIND_VALUE：根据 KEY 查找一个数据，实则上跟 FIND_NODE 非常类似。KEY 就是文件对应的 160 位的 ID，就是要找到保存了文件的节点。</li></ul><h3 id="17-9-DHT-网络中，朋友圈如何更新呢？">17.9 DHT 网络中，朋友圈如何更新呢？</h3><ul><li>每个 bucket 里的节点，都按最后一次接触的时间倒序排列，这就相当于，朋友圈里面最近联系过的人往往是最熟的。</li><li>每次执行四个指令中的任意一个都会触发更新。</li><li>当一个节点与自己接触时，检查它是否已经在 k-bucket 中，也就是说是否已经在朋友圈。如果在，那么将它挪到 k-bucket 列表的最底，也就是最新的位置，刚联系过，就置顶一下，方便以后多联系；如果不在，新的联系人要不要加到通讯录里面呢？假设通讯录已满的情况，PING 一下列表最上面，也即最旧的一个节点。如果 PING 通了，将旧节点挪到列表最底，并丢弃新节点，老朋友还是留一下；如果 PING 不通，删除旧节点，并将新节点加入列表，这人联系不上了，删了吧。</li></ul><p>这个机制保证了任意节点加入和离开都不影响整体网络。</p><h3 id="17-10-小结">17.10 小结</h3><p>总结一下：</p><ul><li>下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；</li><li>P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散</li></ul><p><strong>Note：</strong></p><p><strong>FTP 采用两个 TCP 连接来传输一个文件。这是为什么呢?</strong></p><p>FTP（文件传输协议）使用两个TCP连接进行文件传输的原因是为了隔离命令交流和数据传输。这两个连接分别是命令连接（也称为控制连接）和数据连接。</p><ol><li>命令连接：在FTP客户端和服务器之间建立的持久连接，用于发送控制信息，比如登陆认证、改变远程目录、获取文件列表等命令。这个连接在FTP会话期间始终保持打开状态。</li><li>数据连接：用于实际的文件传输。每次需要传输文件或文件列表时，FTP服务器会建立一个新的数据连接。文件传输完成后，这个数据连接就会被关闭。</li></ol><p>这种设计的好处是，命令连接和数据连接可以并行工作，提高了效率。例如，在传输大文件的过程中，用户仍然可以通过命令连接发送其他命令，比如暂停当前的文件传输，或者请求另一个文件的传输。这就需要两个独立的TCP连接来实现。</p><p><strong>P2P协议原理</strong></p><p>P2P（Peer-to-Peer）协议是一种网络通信模型，其中每一个节点（Peer）既是客户端又是服务器，可以直接与其他节点进行数据交换，而无需通过中间服务器。这种协议的核心思想是资源共享，每个节点都可以提供和接受服务。</p><p>下面是P2P协议的工作原理的解释：</p><ol><li><strong>资源发现</strong>：首先，当一个节点需要某个资源时，它会在网络中广播一个请求，寻找拥有这个资源的其他节点。</li><li><strong>连接建立</strong>：当一个节点接收到资源请求后，如果它拥有所请求的资源，它会与请求节点建立直接的连接。</li><li><strong>资源共享</strong>：一旦连接建立，资源就可以直接从拥有资源的节点传输到请求节点。这种传输是对等的，也就是说，任何节点都可以成为数据的发送者或接收者。</li><li><strong>动态性</strong>：P2P网络是动态的，节点可以随时加入和离开网络，资源的位置也可能随时改变。因此，P2P协议需要能够处理这种动态性，例如通过实时更新资源的位置信息。</li></ol><p>总的来说，P2P协议利用了网络中每个节点的资源，通过去中心化的方式实现了高效的数据传输。它在文件分享、流媒体传输、分布式存储等领域有广泛的应用。</p>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块3:传输层</title>
    <link href="https://penge666.github.io/posts/e4f4b13d.html"/>
    <id>https://penge666.github.io/posts/e4f4b13d.html</id>
    <published>2024-05-23T03:40:28.000Z</published>
    <updated>2024-05-23T03:41:30.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第10讲-UDP协议：因性善而简单，难免碰到”城会玩”">第10讲 | UDP协议：因性善而简单，难免碰到”城会玩”</h2><h3 id="10-1-TCP-和-UDP-有哪些区别？">10.1 TCP 和 UDP 有哪些区别？</h3><p>一般面试的时候我问这两个协议的区别，大部分人会回答，TCP 是面向连接的，UDP 是面向无连接的。</p><p>什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会。为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？</p><p><strong>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</strong></p><p>例如，<strong>TCP 提供可靠交付</strong>。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。我们都知道 IP 包是没有任何可靠性保证的，一旦发出去，就像西天取经，走丢了、被妖怪吃了，都只能随它去。但是 TCP 号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。而<strong>UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达</strong>。</p><p>再如，<strong>TCP 是面向字节流的</strong>。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而<strong>UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</strong>。</p><p>还有<strong>TCP 是可以有拥塞控制的</strong>。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。<strong>UDP 就不会，应用让我发，我就发，管它洪水滔天</strong>。</p><p>因而<strong>TCP 其实是一个有状态服务</strong>，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 <strong>UDP 则是无状态服务。</strong> 通俗地说是没脑子的，天真无邪的，发出去就发出去了。</p><p>我们可以这样比喻，如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p><h3 id="10-2-UDP-包头是什么样的？">10.2 UDP 包头是什么样的？</h3><p>前面章节我已经讲过包的传输过程，这里不再赘述。当我发送的 UDP 包到达目标机器后，发现 MAC 地址匹配，于是就取下来，将剩下的包传给处理 IP 层的代码。把 IP 头取下来，发现目标 IP 匹配，接下来呢？这里面的数据包是给谁呢？</p><p>发送的时候，我知道我发的是一个 UDP 的包，收到的那台机器咋知道的呢？所以在 IP 头里面有个 8 位协议，这里会存放，数据里面到底是 TCP 还是 UDP，当然这里是 UDP。于是，如果我们知道 UDP 头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？</p><p>处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？</p><p>无论应用程序写的使用 TCP 传数据，还是 UDP 传数据，都要监听一个端口。正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？所以，按理说，无论是 TCP 还是 UDP 包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523105421463.png" alt="image-20240523105421463"></p><p>当我们看到 UDP 包头的时候，发现的确有端口号，有源端口号和目标端口号。因为是两端通信嘛，这很好理解。但是你还会发现，UDP 除了端口号，再没有其他的了。和下两节要讲的 TCP 头比起来，这个简直简单得一塌糊涂啊！</p><h3 id="10-3-UDP-的三大特点">10.3 UDP 的三大特点</h3><p>第一，<strong>沟通简单</strong>，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。</p><p>第二，<strong>轻信他人</strong>。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。</p><p>第三，<strong>愣头青</strong>，做事不懂权变。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</p><h3 id="10-4-UDP-的三大使用场景">10.4 UDP 的三大使用场景</h3><p>基于 UDP 这种”小孩子”的特点，我们可以考虑在以下的场景中使用。</p><p>第一，<strong>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</strong>。这很好理解，就像如果你是领导，你会让你们组刚毕业的小朋友去做一些没有那么难的项目，打一些没有那么难的客户，或者做一些失败了也能忍受的实验性项目。</p><p>我们在第四节讲的 <strong>DHCP 就是基于 UDP 协议的</strong>。一般的获取 IP 地址都是内网请求，而且一次获取不到 IP 又没事，过一会儿还有机会。我们讲过 PXE 可以在启动的时候自动安装操作系统，操作系统镜像的下载使用的 TFTP，这个也是基于 UDP 协议的。在还没有操作系统的时候，客户端拥有的资源很少，不适合维护一个复杂的状态机，而是因为是内网，一般也没啥问题。</p><p>第二，<strong>不需要一对一沟通，建立连接，而是可以广播的应用</strong>。咱们小时候人都很简单，大家在班级里面，谁成绩好，谁写作好，应该表扬谁惩罚谁，谁得几个小红花都是当着全班的面讲的，公平公正公开。长大了人心复杂了，薪水、奖金要背靠背，和员工一对一沟通。</p><p>UDP 的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP 就是一种广播的形式，就是基于 UDP 协议的，而广播包的格式前面说过了。</p><p>对于多播，我们在讲 IP 地址的时候，讲过一个 D 类地址，也即组播地址，使用这个地址，可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送 IGMP 包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。</p><p>在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。</p><p>第三，<strong>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong>。记得曾国藩建立湘军的时候，专门招出生牛犊不怕虎的新兵，而不用那些”老油条”的八旗兵，就是因为八旗兵经历的事情多，遇到敌军不敢舍死忘生。</p><p>同理，UDP 简单、处理速度快，不像 TCP 那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而 TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。</p><p>当前很多应用都是要求低时延的，它们可不想用 TCP 如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于 TCP。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达。</p><p>由于 UDP 十分简单，基本啥都没做，也就给了应用”城会玩”的机会。就像在和平年代，每个人应该有独立的思考和行为，应该可靠并且礼让；但是如果在战争年代，往往不太需要过于独立的思考，而需要士兵简单服从命令就可以了。</p><p>曾国藩说哪支部队需要诱敌牺牲，也就牺牲了，相当于包丢了就丢了。两军狭路相逢的时候，曾国藩说上，没有带宽也要上，这才给了曾国藩运筹帷幄，城会玩的机会。同理如果你实现的应用需要有自己的连接策略，可靠保证，时延要求，使用 UDP，然后再应用层实现这些是再好不过了。</p><h3 id="10-5-基于-UDP-的”城会玩”的五个例子">10.5 基于 UDP 的”城会玩”的五个例子</h3><ol><li><p>“城会玩”一：网页或者 APP 的访问</p><p>原来访问网页和手机 APP 都是基于 HTTP 协议的。HTTP 协议是基于 TCP 的，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，TCP 可能还会断了重连，也是很耗时的。而且目前的 HTTP 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。</p><p>而QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</p><p>QUIC 在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制，是应用层”城会玩”的代表。这一节主要是讲 UDP，QUIC 我们放到应用层去讲。</p></li><li><p>“城会玩”二：流媒体的协议</p><p>现在直播比较火，直播协议多使用 RTMP，这个协议我们后面的章节也会讲，而这个 RTMP 协议也是基于 TCP 的。TCP 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。对于直播来讲，这显然是不合适的，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，新的也看不了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。</p><p>另外，对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。</p><p>还有就是当网络不好的时候，TCP 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。</p></li><li><p>“城会玩”三：实时游戏</p><p>游戏有一个特点，就是实时性比较高。快一秒你干掉别人，慢一秒你被别人爆头，所以很多职业玩家会买非常专业的鼠标和键盘，争分夺秒。</p><p>因而，实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护 TCP 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 TCP 连接数目是有限的，然后 UDP 由于是没有连接的，在异步 IO 机制引入之前，常常是应对海量客户端连接的策略。</p><p>另外还是 TCP 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。</p><p>如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。</p><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p></li><li><p>“城会玩”四：IoT 物联网</p><p>一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大；另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的。</p></li><li><p>“城会玩”五：移动通信领域</p><p>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的。因为移动网络协议比较复杂，而 GTP 协议本身就包含复杂的手机上线下线的通信协议。如果基于 TCP，TCP 的机制就显得非常多余，这部分协议我会在后面的章节单独讲解。</p></li></ol><h3 id="10-6-小结">10.6 小结</h3><p>总结一下：</p><ol><li>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；</li><li>UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</li></ol><h2 id="第11讲-TCP协议（上）：因性恶而复杂，先恶后善反轻松">第11讲 | TCP协议（上）：因性恶而复杂，先恶后善反轻松</h2><h3 id="11-1-TCP-包头格式">11.1 TCP 包头格式</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110216648.png" alt="image-20240523110216648"></p><p>首先，源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。</p><p>接下来是包的序号。为什么要给包编号呢？当然是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。既然是社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。</p><p>还应该有的就是确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。</p><p>TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。</p><p>这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。</p><p>接下来有一些状态位。例如 <strong>SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等</strong>。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>作为老司机，做事情要有分寸，待人要把握尺度，既能适当提出自己的要求，又不强人所难。除了做流量控制以外，TCP 还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：</p><ul><li>顺序问题，稳重不乱；</li><li>丢包问题，承诺靠谱；</li><li>连接维护，有始有终；</li><li>流量控制，把握分寸；</li><li>拥塞控制，知进知退。</li></ul><h3 id="11-2-TCP-的三次握手">11.2 TCP 的三次握手</h3><p>TCP 的连接建立，我们常常称为三次握手。</p><ul><li>A：您好，我是 A。</li><li>B：您好 A，我是 B。</li><li>A：您好 B。</li></ul><p>我们也常称为”请求 -&gt; 应答 -&gt; 应答之应答”的三个回合。这个看起来简单，其实里面还是有很多的学问，很多的细节。</p><p>首先，为什么要三次，而不是两次？按说两个人打招呼，一来一回就可以了啊？为了可靠，为什么不是四次？</p><p>我们还是假设这个通路是非常不可靠的，A 要发起一个连接，当发了第一个请求杳无音信的时候，会有很多的可能性，比如第一个请求包丢了，再如没有丢，但是绕了弯路，超时了，还有 B 没有响应，不想和我连接。</p><p>A 不能确认结果，于是再发，再发。终于，有一个请求包到了 B，但是请求包到了 B 的这个事情，目前 A 还是不知道的，A 还有可能再发。</p><p>B 收到了请求包，就知道了 A 的存在，并且知道 A 要和它建立连接。如果 B 不乐意建立连接，则 A 会重试一阵后放弃，连接建立失败，没有问题；如果 B 是乐意建立连接的，则会发送应答包给 A。</p><p>当然对于 B 来说，这个应答包也是一入网络深似海，不知道能不能到达 A。这个时候 B 自然不能认为连接是建立好了，因为应答包仍然会丢，会绕弯路，或者 A 已经挂了都有可能。</p><p>而且这个时候 B 还能碰到一个诡异的现象就是，A 和 B 原来建立了连接，做了简单通信后，结束了连接。还记得吗？A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了，B 会认为这也是一个正常的的请求的话，因此建立了连接，可以想象，这个连接不会进行下去，也没有个终结的时候，纯属单相思了。因而两次握手肯定不行。</p><p>B 发送的应答可能会发送多次，但是只要一次到达 A，A 就认为连接已经建立了，因为对于 A 来讲，他的消息有去有回。A 会给 B 发送应答之应答，而 B 也在等这个消息，才能确认连接的建立，只有等到了这个消息，对于 B 来讲，才算它的消息有去有回。</p><p>当然 A 发给 B 的应答之应答也会丢，也会绕路，甚至 B 挂了。按理来说，还应该有个应答之应答之应答，这样下去就没底了。所以四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。</p><p>好在大部分情况下，A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决。例如 A 发给 B 的应答丢了，当 A 后续发送的数据到达的时候，B 可以认为这个连接已经建立，或者 B 压根就挂了，A 发送的数据，会报错，说 B 不可达，A 就知道 B 出事情了。</p><p>当然你可以说 A 比较坏，就是不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启 keepalive 机制，即使没有真实的数据包，也有探活包。</p><p>另外，你作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。</p><p>三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是<strong>TCP 包的序号的问题</strong>。</p><p>A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。</p><p>例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。</p><p>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4ms 加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 TTL，也即生存时间。</p><p>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110514867.png" alt="image-20240523110514867"></p><p>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。然后客户端主动发起连接 SYN，之后处于 <code>SYN-SENT</code> 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 <code>SYN-RCVD</code> 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</p><h3 id="11-3-TCP-四次挥手">11.3 TCP 四次挥手</h3><p>好了，说完了连接，接下来说一说”拜拜”，好说好散。这常被称为四次挥手。</p><ul><li>A：B 啊，我不想玩了。</li><li>B：哦，你不想玩了啊，我知道了。</li></ul><p>这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢？当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为半关闭的状态。</p><p>这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。</p><ul><li>B：A 啊，好吧，我也不玩了，拜拜。</li><li>A：好的，拜拜。</li></ul><p>这样整个连接就关闭了。但是这个过程有没有异常情况呢？当然有，上面是和平分手的场面。</p><p>A 开始说”不玩了”，B 说”知道了”，这个回合，是没什么问题的，因为在此之前，双方还处于合作的状态，如果 A 说”不玩了”，没有收到回复，则 A 会重新发送”不玩了”。但是这个回合结束之后，就有可能出现异常情况了，因为已经有一方率先撕破脸。</p><p>一种情况是，A 说完”不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了。另一种情况是，A 说完”不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束。</p><p>那怎么解决这些问题呢？TCP 协议专门设计了几个状态来处理这些问题。我们来看断开连接的时候的<strong>状态时序图</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110917507.png" alt="image-20240523110917507"></p><p>断开的时候，我们可以看到，当 A 说”不玩了”，就进入 FIN_WAIT_1 的状态，B 收到”A 不玩”的消息后，发送知道了，就进入 CLOSE_WAIT 的状态。</p><p>A 收到”B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p><p>如果 B 没有跑路，发送了”B 也不玩了”的请求到达 A 时，A 发送”知道 B 也不玩了”的 ACK 后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一个”B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而 TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，”B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。</p><p>A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。</p><p>等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</p><p>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p><h3 id="11-4-TCP-状态机">11.4 TCP 状态机</h3><p>将连接建立和连接断开的两个时序状态图综合起来，就是这个著名的 TCP 的状态机。学习的时候比较建议将这个状态机和时序状态机对照着看，不然容易晕。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523110956241.png" alt="image-20240523110956241"></p><p>在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是连接过程中的顺序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端 A 的状态变迁，加粗的虚线是服务端 B 的状态变迁。</p><h3 id="11-5-小结">11.5 小结</h3><p>总结：</p><ul><li>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</li><li>连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。</li></ul><h2 id="第12讲-TCP协议（下）：西行必定多妖孽，恒心智慧消磨难">第12讲 | TCP协议（下）：西行必定多妖孽，恒心智慧消磨难</h2><p>我们前面说到玄奘西行，要出网关。既然出了网关，那就是在公网上传输数据，公网往往是不可靠的，因而需要很多的机制去保证传输的可靠性，这里面需要恒心，也即各种<strong>重传的策略</strong>，还需要有智慧，也就是说，这里面包含着<strong>大量的算法</strong>。</p><h3 id="12-1-如何做个靠谱的人？">12.1 如何做个靠谱的人？</h3><p>TCP 想成为一个成熟稳重的人，成为一个靠谱的人。那一个人怎么样才算靠谱呢？咱们工作中经常就有这样的场景，比如你交代给下属一个事情以后，下属到底能不能做到，做到什么程度，什么时候能够交付，往往就会有应答，有回复。这样，处理事情的过程中，一旦有异常，你也可以尽快知道，而不是交代完之后就石沉大海，过了一个月再问，他说，啊我不记得了。</p><p>对应到网络协议上，就是客户端每发送的一个包，服务器端都应该有个回复，如果服务器端超过一定的时间没有回复，客户端就会重新发送这个包，直到有回复。</p><p>这个发送应答的过程是什么样呢？可以是<strong>上一个收到了应答，再发送下一个</strong>。这种模式有点像两个人直接打电话，你一句，我一句。但是这种方式的缺点是效率比较低。如果一方在电话那头处理的时间比较长，这一头就要干等着，双方都没办法干其他事情。咱们在日常工作中也不是这样的，不能你交代你的下属办一件事情，就一直打着电话看着他做，而是应该他按照你的安排，先将事情记录下来，办完一件回复一件。在他办事情的过程中，你还可以同时交代新的事情，这样双方就并行了。</p><p>如果使⽤这种模式，其实需要你和你的下属就不能靠脑⼦了，⽽是要都准备⼀个本⼦，你每交代下属⼀个事情，双方的本子都要记录⼀下。</p><p>当你的下属做完⼀件事情，就回复你，做完了，你就在你的本⼦上将这个事情划去。同时你的本⼦上每件事情都有时限，如果超过了时限下属还没有回复，你就要主动重新交代⼀下：上次那件事情，你还没回复我，咋样啦？</p><p>既然多件事情可以一起处理，那就需要给每个事情编个号，防止弄错了。例如，程序员平时看任务的时候，都会看 JIRA 的 ID，而不是每次都要描述一下具体的事情。在大部分情况下，对于事情的处理是按照顺序来的，先来的先处理，这就给应答和汇报工作带来了方便。等开周会的时候，每个程序员都可以将 JIRA ID 的列表拉出来，说以上的都做完了，⽽不⽤⼀个个说</p><h3 id="12-2-如何实现一个靠谱的协议？">12.2 如何实现一个靠谱的协议？</h3><p>TCP 协议使用的也是同样的模式。为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为<strong>累计确认</strong>或者<strong>累计应答（cumulative acknowledgment）</strong>。</p><p>为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。</p><ul><li>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的。</li><li>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。</li><li>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的。</li><li>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。</li></ul><p>这里面为什么要区分第三部分和第四部分呢？没交代的，一下子全交代了不就完了吗？</p><p>这就是我们上一节提到的十个词口诀里的”流量控制，把握分寸”。作为项目管理人员，你应该根据以往的工作情况和这个员工反馈的能力、抗压力等，先在心中估测一下，这个人一天能做多少工作。如果工作布置少了，就会不饱和；如果工作布置多了，他就会做不完；如果你使劲逼迫，人家可能就要辞职了。</p><p>到底一个员工能够同时处理多少事情呢？在 TCP 里，接收端会给发送端报一个窗口的大小，叫<strong>Advertised window</strong>。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。</p><p>于是，<strong>发送端</strong>需要保持下面的数据结构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523111205217.png" alt="image-20240523111205217"></p><ul><li>LastByteAcked：第一部分和第二部分的分界线</li><li>LastByteSent：第二部分和第三部分的分界线</li><li>LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线</li></ul><p>对于接收端来讲，它的缓存里记录的内容要简单一些。</p><ul><li>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的。</li><li>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。</li><li>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523111221657.png" alt="image-20240523111221657"></p><ul><li>MaxRcvBuffer：最大缓存的量；</li><li>LastByteRead 之后是已经接收了，但是还没被应用层读取的；</li><li>NextByteExpected 是第一部分和第二部分的分界线。</li></ul><p>第二部分的窗口有多大呢？</p><p>NextByteExpected 和 LastByteRead 的差其实是还没被应用层读取的部分占用掉的 MaxRcvBuffer 的量，我们定义为 A。</p><p>AdvertisedWindow 其实是 MaxRcvBuffer 减去 A。</p><p>也就是：AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead)。</p><p>那第二部分和第三部分的分界线在哪里呢？NextByteExpected 加 AdvertisedWindow 就是第二部分和第三部分的分界线，其实也就是 LastByteRead 加上 MaxRcvBuffer。</p><p>其中第二部分里面，由于受到的包可能不是顺序的，会出现空挡，只有和第一部分连续的，可以马上进行回复，中间空着的部分需要等待，哪怕后面的已经来了</p><h3 id="12-3-顺序问题与丢包问题">12.3 顺序问题与丢包问题</h3><p>接下来我们结合一个例子来看。</p><p>还是刚才的图，在发送端来看，1、2、3 已经发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p><p>在接收端来看，1、2、3、4、5 是已经完成 ACK，但是没读取的；6、7 是等待接收的；8、9 是已经接收，但是没有 ACK 的。</p><p>发送端和接收端当前的状态如下：</p><ul><li>1、2、3 没有问题，双方达成了一致。</li><li>4、5 接收方说 ACK 了，但是发送方还没收到，有可能丢了，有可能在路上。</li><li>6、7、8、9 肯定都发了，但是 8、9 已经到了，但是 6、7 没到，出现了乱序，缓存着但是没办法 ACK。</li></ul><p>根据这个例子，我们可以知道，顺序问题和丢包问题都有可能发生，所以我们先来看<strong>确认与重发的机制</strong>。</p><p>假设 4 的确认到了，不幸的是，5 的 ACK 丢了，6、7 的数据包丢了，这该怎么办呢？</p><p>一种方法就是<strong>超时重试</strong>，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。</p><p>估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为<strong>自适应重传算法（Adaptive Retransmission Algorithm）</strong>。</p><p>如果过一段时间，5、6、7 都超时了，就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，有需要重传的时候，TCP 的策略是<strong>超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</strong>。</p><p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><p>有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。</p><p>例如，接收方发现 6、8、9 都已经接收了，就是 7 没来，那肯定是丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p><p>还有一种方式称为<strong>Selective Acknowledgment （SACK）</strong>。这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。</p><h3 id="12-4-流量控制问题">12.4 流量控制问题</h3><p>我们再来看流量控制机制，在对于包的确认中，同时会携带一个窗口的大小。</p><p>我们先假设窗口不变的情况，窗口始终为 9。4 的确认来的时候，会右移一个，这个时候第 13 个包也可以发送了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523111544852.png" alt="image-20240523111544852"></p><p>这个时候，假设发送端发送过猛，会将第三部分的 10、11、12、13 全部发送完毕，之后就停止发送了，未发送可发送部分为 0。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112548130.png" alt="image-20240523112548130"></p><p>当对于包 5 的确认到达的时候，在客户端相当于窗口再滑动了一格，这个时候，才可以有更多的包可以发送了，例如第 14 个包才可以发送。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112603538.png" alt="image-20240523112603538"></p><p>如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小，甚至可以设置为 0，则发送方将暂时停止发送。</p><p>我们假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口大小就不能再是 9 了，就要缩小一个变为 8。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112620635.png" alt="image-20240523112620635"></p><p>这个新的窗口 8 通过 6 的确认消息到达发送端的时候，你会发现窗口没有平行右移，而是仅仅左面的边右移了，窗口的大小从 9 改成了 8。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112641760.png" alt="image-20240523112641760"></p><p>如果接收端还是一直不处理数据，则随着确认的包越来越多，窗口越来越小，直到为 0。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112659501.png" alt="image-20240523112659501"></p><p>当这个窗口通过包 14 的确认到达发送端的时候，发送端的窗口也调整为 0，停止发送。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523112714826.png" alt="image-20240523112714826"></p><p>如果这样的话，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。</p><p>这就是我们常说的流量控制。</p><h3 id="12-5-拥塞控制问题">12.5 拥塞控制问题</h3><p>最后，我们看一下拥塞控制的问题，也是通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。</p><p>那发送方怎么判断网络是不是满呢？这其实是个挺难的事情，因为对于 TCP 协议来讲，他压根不知道整个网络路径都会经历什么，对他来讲就是一个黑盒。TCP 发送包常被比喻为往一个水管里面灌水，而 TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p><p>水管有粗细，网络有带宽，也即每秒钟能够发送多少数据；水管有长度，端到端有时延。在理想状态下，水管里面水的量 = 水管粗细 x 水管长度。对于到网络上，通道的容量 = 带宽 × 往返延迟。</p><p>如果我们设置发送窗口，使得发送但未确认的包为为通道的容量，就能够撑满整个管道。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113009361.png" alt="image-20240523113009361"></p><p>如图所示，假设往返时间为 8s，去 4s，回 4s，每秒发送一个包，每个包 1024byte。已经过去了 8s，则 8 个包都发出去了，其中前 4 个包已经到达接收端，但是 ACK 还没有返回，不能算发送成功。5-8 后四个包还在路上，还没被接收。这个时候，整个管道正好撑满，在发送端，已发送未确认的为 8 个包，正好等于带宽，也即每秒发送 1 个包，乘以来回时间 8s。</p><p>如果我们在这个基础上再调大窗口，使得单位时间内更多的包可以发送，会出现什么现象呢？</p><p>我们来想，原来发送一个包，从一端到达另一端，假设一共经过四个设备，每个设备处理一个包时间耗费 1s，所以到达另一端需要耗费 4s，如果发送的更加快速，则单位时间内，会有更多的包到达这些中间设备，这些设备还是只能每秒处理一个包的话，多出来的包就会被丢弃，这是我们不想看到的。</p><p>这个时候，我们可以想其他的办法，例如这个四个设备本来每秒处理一个包，但是我们在这些设备上加缓存，处理不过来的在队列里面排着，这样包就不会丢失，但是缺点是会增加时延，这个缓存的包，4s 肯定到达不了接收端了，如果时延达到一定程度，就会超时重传，也是我们不想看到的。</p><p>于是 TCP 的拥塞控制主要来避免两种现象，<strong>包丢失</strong>和<strong>超时重传</strong>。一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？</p><p>如果我们通过漏斗往瓶子里灌水，我们就知道，不能一桶水一下子倒进去，肯定会溅出来，要一开始慢慢的倒，然后发现总能够倒进去，就可以越倒越快。这叫作慢启动。</p><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是<strong>指数性的增长</strong>。</p><p>涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。</p><p>每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。</p><p>但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。</p><p>拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。</p><p>前面我们讲过<strong>快速重传算法</strong>。当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113026917.png" alt="image-20240523113026917"></p><p>就像前面说的一样，正是这种知进退，使得时延很重要的情况下，反而降低了速度。但是如果你仔细想一下，TCP 的拥塞控制主要来避免的两个现象都是有问题的。</p><p><strong>第一个问题</strong>是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。</p><p><strong>第二个问题</strong>是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。</p><p>为了优化这两个问题，后来有了<strong>TCP BBR 拥塞算法</strong>。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113049881.png" alt="image-20240523113049881"></p><h3 id="12-6-小结">12.6 小结</h3><p>总结一下：</p><ul><li>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；</li><li>拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。</li></ul><h2 id="第13讲-套接字Socket：Talk-is-cheap-show-me-the-code">第13讲 | 套接字Socket：Talk is cheap, show me the code</h2><p>前面讲完了 TCP 和 UDP 协议，还没有上手过，这一节咱们讲讲基于 TCP 和 UDP 协议的 Socket 编程。</p><p>在讲 TCP 和 UDP 协议的时候，我们分客户端和服务端，在写程序的时候，我们也同样这样分。</p><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。</p><p>在建立 Socket 的时候，应该设置什么参数呢？Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。</p><p>在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><h3 id="13-1-基于-TCP-协议的-Socket-程序函数调用过程">13.1 基于 TCP 协议的 Socket 程序函数调用过程</h3><p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。</p><p>当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p><p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p><p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p><p>这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作<strong>监听 Socket</strong>，一个叫作<strong>已连接 Socket</strong>。</p><p>连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><p>这个图就是基于 TCP 协议的 Socket 程序函数调用过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113217980.png" alt="image-20240523113217980"></p><p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>在内核中，Socket 是一个文件，那对应就有文件描述符。<strong>每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标</strong>。</p><p><strong>这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构</strong>。</p><p>在这个结构里面，主要的是两个队列，一个是<strong>发送队列</strong>，一个是<strong>接收队列</strong>。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？</p><p>整个数据结构我也画了一张图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113422498.png" alt="image-20240523113422498"></p><h3 id="13-2-基于-UDP-协议的-Socket-程序函数调用过程">13.2 基于 UDP 协议的 Socket 程序函数调用过程</h3><p>对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。</p><p>这个图的内容就是基于 UDP 协议的 Socket 程序函数调用过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113604974.png" alt="image-20240523113604974"></p><h3 id="13-3-服务器如何接更多的项目？">13.3 服务器如何接更多的项目？</h3><p>会了这几个基本的 Socket 函数之后，你就可以轻松地写一个网络交互的程序了。就像上面的过程一样，在建立连接后，进行一个 while 循环。客户端发了收，服务端收了发。</p><p>当然这只是万里长征的第一步，因为如果使用这种方法，基本上只能一对一沟通。如果你是一个服务器，同时只能服务一个客户，肯定是不行的。这就相当于老板成立一个公司，只有自己一个人，自己亲自上来服务客户，只能干完了一家再干下一家，这样赚不来多少钱。</p><p>那作为老板你就要想了，我最多能接多少项目呢？当然是越多越好。</p><p>我们先来算一下理论值，也就是<strong>最大连接数</strong>，系统会用一个四元组来标识一个 TCP 连接。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;本机 <span class="built_in">IP</span>, 本机端口, 对端 <span class="built_in">IP</span>, 对端端口&#125;</span><br></pre></td></tr></table></figure><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，服务端端 TCP 连接四元组中只有对端 IP, 也就是客户端的 IP 和对端的端口，也即客户端的端口是可变的，因此，最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是<strong>文件描述符限制</strong>，按照上面的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是<strong>内存</strong>，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p><p>所以，作为老板，在资源有限的情况下，要想接更多的项目，就需要降低每个项目消耗的资源数目。</p><ol><li><p>方式一：将项目外包给其他公司（多进程方式）</p><p>这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，就会有一个已连接 Socket，这时候你可以创建一个子进程，然后将基于已连接 Socket 的交互交给这个新的子进程来做。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司，招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。</p><p>这里有一个问题是，如何创建子公司，并如何将项目移交给子公司呢？</p><p>在 Linux 下，创建子进程使用 fork 函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。显然，复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>进程复制过程我画在这里。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113622262.png" alt="image-20240523113622262"></p></li><li><p>因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。</p><p>接下来，子进程就可以通过这个已连接 Socket 和客户端进行互通了，当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？还记得 fork 返回的时候，如果是整数就是父进程吗？这个整数就是子进程的 ID，父进程可以通过这个 ID 查看子进程是否完成项目，是否需要退出。</p></li><li><p>方式二：将项目转包给独立的项目组（多线程方式）</p><p>上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司，实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。</p><p>于是你应该想到了，我们可以使用<strong>线程</strong>。相比于进程来讲，这样要轻量级的多。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。</p><p>在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113638212.png" alt="image-20240523113638212"></p></li><li><p>新的线程也可以通过已连接 Socket 处理请求，从而达到并发处理的目的。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。有个C10K，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了。</p><p>其实 C10K 问题就是，你接项目接的太多了，如果每个项目都成立单独的项目组，就要招聘 10 万人，你肯定养不起，那怎么办呢？</p></li><li><p>方式三：一个项目组支撑多个项目（IO 多路复用，一个线程维护多个 Socket）</p><p>当然，一个项目组可以看多个项目了。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度，一旦某个项目有了进展，就派人去盯一下。</p><p>由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，这就是项目进度墙，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。</p></li><li><p>方式四：一个项目组支撑多个项目（IO 多路复用，从”派人盯着”到”有事通知”）</p><p>上面 select 函数还是有问题的，因为每次 Socket 所在的文件描述符集合中有 Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量。因而使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。</p><p>如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目，而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。</p><p>能完成这件事情的函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240523113701157.png" alt="image-20240523113701157"></p><ol><li><p>如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过 epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。</p><p>当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。</p><p>这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p></li></ol><h3 id="13-4-小结">13.4 小结</h3><p>总结一下：</p><ul><li>你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；</li><li>写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。</li></ul>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块2:物链层</title>
    <link href="https://penge666.github.io/posts/e4170501.html"/>
    <id>https://penge666.github.io/posts/e4170501.html</id>
    <published>2024-05-22T13:26:01.000Z</published>
    <updated>2024-05-22T13:35:34.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第5讲-从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？">第5讲 | 从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？</h2><p>上一节，我们见证了 IP 地址的诞生，或者说是整个操作系统的诞生。一旦机器有了 IP，就可以在网络的环境里和其他的机器展开沟通了。</p><p>故事就从我的大学宿舍开始讲起吧。作为一个八零后，我要暴露年龄了。</p><p>我们宿舍四个人，大一的时候学校不让上网，不给开通网络。但是，宿舍有一个人比较有钱，率先买了一台电脑。那买了电脑干什么呢？</p><p>首先，有单机游戏可以打，比如说《拳皇》。两个人用一个键盘，照样打得火热。后来有第二个人买了电脑，那两台电脑能不能连接起来呢？你会说，当然能啊，买个路由器不就行了。</p><p>现在一台家用路由器非常便宜，一百多块的事情。那时候路由器绝对是奢侈品。一直到大四，我们宿舍都没有买路由器。可能是因为那时候技术没有现在这么发达，导致我对网络技术的认知是逐渐深入的，而且每一层都是实实在在接触到的。</p><h3 id="5-1-第一层（物理层）">5.1 第一层（物理层）</h3><p>使用路由器，是在第三层上。我们先从第一层物理层开始说。</p><p>物理层能折腾啥？现在的同学可能想不到，我们当时去学校配电脑的地方买网线，卖网线的师傅都会问，你的网线是要电脑连电脑啊，还是电脑连网口啊？</p><p>我们要的是电脑连电脑。这种方式就是一根网线，有两个头。一头插在一台电脑的网卡上，另一头插在另一台电脑的网卡上。但是在当时，普通的网线这样是通不了的，所以水晶头要做交叉线，用的就是所谓的<strong>1－3、2－6 交叉接法</strong>。</p><p>当然电脑连电脑，除了网线要交叉，还需要配置这两台电脑的 IP 地址、子网掩码和默认网关。这三个概念上一节详细描述过了。要想两台电脑能够通信，这三项必须配置成为一个网络，可以一个是 192.168.0.1/24，另一个是 192.168.0.2/24，否则是不通的。</p><p>这里我想问你一个问题，两台电脑之间的网络包，包含 MAC 层吗？当然包含，要完整。IP 层要封装了 MAC 层才能将包放入物理层。</p><p>到此为止，两台电脑已经构成了一个最小的<strong>局域网</strong>，也即<strong>LAN</strong>。可以玩联机局域网游戏啦！</p><p>等到第三个哥们也买了一台电脑，怎么把三台电脑连在一起呢？</p><p>先别说交换机，当时交换机也贵。有一个叫作<strong>Hub</strong>的东西，也就是<strong>集线器</strong>。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p><p><strong>集线器的概念</strong></p><p>当一台计算机通过网络线向集线器发送数据时，集线器会接收到这些数据，然后将这些数据转发到其它所有连接到这个集线器的网络线上。也就是说，所有连接到集线器的设备都会收到这些数据。然后，这些设备会检查数据是否是发送给自己的，如果是，就会接收和处理这些数据；如果不是，就会忽略这些数据。</p><h3 id="5-2-第二层（数据链路层）">5.2 第二层（数据链路层）</h3><p>你可能已经发现问题了。Hub 采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都能收到，那就麻烦了。这就需要解决几个问题：</p><ul><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ul><p>这几个问题，都是第二层，数据链路层，也即 MAC 层要解决的问题。<strong>MAC</strong>的全称是<strong>Medium Access Control</strong>，即<strong>媒体访问控制</strong>。控制什么呢？其实就是控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱。这解决的是第二个问题。这个问题中的规则，学名叫<strong>多路访问</strong>。有很多算法可以解决这个问题。就像车管所管束马路上跑的车，能想的办法都想过了。</p><p>比如接下来这三种方式：</p><ul><li>方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作<strong>信道划分</strong>；</li><li>方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作<strong>轮流协议</strong>；</li><li>方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作<strong>随机接入协议</strong>。著名的以太网，用的就是这个方式。</li></ul><p><strong>补充</strong></p><p><strong>这里为了理解MAC层解决多路访问的堵车问题的。我举个常见的例子。</strong></p><p>假设我们有一个家庭网络，其中包括多个设备，如电脑、手机、智能电视等，这些设备都连接到一个路由器，希望通过路由器访问互联网。</p><p>如果所有的设备都在同一时间尝试发送数据（比如浏览网页、下载文件等），那么这些数据会在网络中产生冲突，就像是一个拥堵的交通路口，每个设备都试图在同一时间通过同一条路。这就是我们所说的&quot;堵车问题&quot;。</p><p>MAC层就像是一个交通警察，它的任务是管理这些设备发送数据的时机，以避免发生冲突。例如，它可能会让一个设备在一段时间内发送数据，然后再让另一个设备发送数据。这种方法称为时分多路访问（Time-Division Multiple Access，TDMA）。就像是交通警察轮流让每个方向的交通流通过一样。</p><p><strong>over</strong></p><p>解决了第二个问题，就是解决了媒体接入控制的问题，MAC 的问题也就解决好了。这和 MAC 地址没什么关系。</p><p>接下来要解决第一个问题：发给谁，谁接收？这里用到一个物理地址，叫作<strong>链路层地址</strong>。但是因为第二层主要解决媒体接入控制的问题，所以它常被称为<strong>MAC 地址</strong>。</p><p>解决第一个问题就牵扯到第二层的网络包<strong>格式</strong>。对于以太网，第二层的最开始，就是目标的 MAC 地址和源的 MAC 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153040214.png" alt="image-20240522153040214"></p><p>接下来是<strong>类型</strong>，大部分的类型是 IP 数据包，然后 IP 里面包含 TCP、UDP，以及 HTTP 等，这都是里层封装的事情。</p><p>有了这个目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80。</p><p>于是将请求提交给 nginx，nginx 返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。</p><p>对于以太网，第二层的最后面是<strong>CRC</strong>，也就是<strong>循环冗余检测</strong>。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误，主要解决第三个问题。</p><p>这里还有一个没有解决的问题，当源机器知道目标机器的时候，可以将目标地址放入包里面，如果不知道呢？一个广播的网络里面接入了 N 台机器，我怎么知道每个 MAC 地址是谁呢？这就是<strong>ARP 协议</strong>，也就是已知 IP 地址，求 MAC 地址的协议。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153054610.png" alt="image-20240522153054610"></p><p>在一个局域网里面，当知道了 IP 地址，不知道 MAC 怎么办呢？靠”吼”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153110268.png" alt="image-20240522153110268"></p><p>广而告之，发送一个广播包，谁是这个 IP 谁来回答。具体询问和回答的报文就像下面这样：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522153123004.png" alt=""></p><p>为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。</p><h3 id="5-3-局域网">5.3 局域网</h3><p>好了，至此我们宿舍四个电脑就组成了一个局域网。用 Hub 连接起来，就可以玩局域网版的《魔兽争霸》了。</p><p>这种组网的方法，对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了。因为 Hub 是广播的，不管某个接口是否需要，所有的 Bit 都会被发送出去，然后让主机来判断是不是需要。这种方式路上的车少就没问题，车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。看来 Hub 这种不管三七二十一都转发的设备是不行了，需要点儿智能的。因为每个口都只连接一台电脑，这台电脑又不怎么换 IP 和 MAC 地址，只要记住这台电脑的 MAC 地址，如果目标 MAC 地址不是这台电脑的，这个口就不用转发了。</p><p>谁能知道目标 MAC 地址是否就是连接某个口的电脑的 MAC 地址呢？这就需要一个能把 MAC 头拿下来，检查一下目标 MAC 地址，然后根据策略转发的设备，按第二节课中讲过的，这个设备显然是个二层设备，我们称为<strong>交换机</strong>。</p><p>交换机怎么知道每个口的电脑的 MAC 地址呢？这需要交换机会学习。</p><p>一台 MAC1 电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2 的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的，直接发送到这个口就可以了。</p><p>当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为<strong>转发表</strong>，是有一个过期时间的。</p><p>有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题。你可以组个战队了。能上网了，就可以玩网游了。</p><h3 id="5-4-小结">5.4 小结</h3><p>总结：</p><ul><li>第一，MAC 层是用来解决多路访问的堵车问题的；</li><li>第二，ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存；【本地缓存】</li><li>第三，交换机是有 MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。【我认为就是聪明的中间的缓存，hhh】</li></ul><h2 id="第6讲-交换机与VLAN：办公室太复杂，我要回学校">第6讲 | 交换机与VLAN：办公室太复杂，我要回学校</h2><p>上一次，我们在宿舍里组建了一个本地的局域网 LAN，可以愉快地玩游戏了。这是一个非常简单的场景，因为只有一台交换机，电脑数目很少。今天，让我们切换到一个稍微复杂一点的场景，办公室。</p><h3 id="6-1-拓扑结构是怎么形成的？">6.1 拓扑结构是怎么形成的？</h3><p>我们常见到的办公室大多是一排排的桌子，每个桌子都有网口，一排十几个座位就有十几个网口，一个楼层就会有几十个甚至上百个网口。如果算上所有楼层，这个场景自然比你宿舍里的复杂多了。具体哪里复杂呢？我来给你具体讲解。</p><p>首先，这个时候，一个交换机肯定不够用，需要多台交换机，交换机之间连接起来，就形成一个稍微复杂的<strong>拓扑结构</strong>。</p><p>我们先来看<strong>两台交换机</strong>的情形。两台交换机连接着三个局域网，每个局域网上都有多台机器。如果机器 1 只知道机器 4 的 IP 地址，当它想要访问机器 4，把包发出去的时候，它必须要知道机器 4 的 MAC 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522155237730.png" alt="image-20240522155237730"></p><p>于是机器 1 发起广播，机器 2 收到这个广播，但是这不是找它的，所以没它什么事。交换机 A 一开始是不知道任何拓扑信息的，在它收到这个广播后，采取的策略是，除了广播包来的方向外，它还要转发给其他所有的网口。于是机器 3 也收到广播信息了，但是这和它也没什么关系。</p><p>当然，交换机 B 也是能够收到广播信息的，但是这时候它也是不知道任何拓扑信息的，因而也是进行广播的策略，将包转发到局域网三。这个时候，机器 4 和机器 5 都收到了广播信息。机器 4 主动响应说，这是找我的，这是我的 MAC 地址。于是一个 ARP 请求就成功完成了。</p><p>在上面的过程中，交换机 A 和交换机 B 都是能够学习到这样的信息：机器 1 是在左边这个网口的。当了解到这些拓扑信息之后，情况就好转起来。当机器 2 要访问机器 1 的时候，机器 2 并不知道机器 1 的 MAC 地址，所以机器 2 会发起一个 ARP 请求。这个广播消息会到达机器 1，也同时会到达交换机 A。这个时候交换机 A 已经知道机器 1 是不可能在右边的网口的，所以这个广播信息就不会广播到局域网二和局域网三。</p><p>当机器 3 要访问机器 1 的时候，也需要发起一个广播的 ARP 请求。这个时候交换机 A 和交换机 B 都能够收到这个广播请求。交换机 A 当然知道主机 A 是在左边这个网口的，所以会把广播消息转发到局域网一。同时，交换机 B 收到这个广播消息之后，由于它知道机器 1 是不在右边这个网口的，所以不会将消息广播到局域网三。</p><h3 id="6-2-如何解决常见的环路问题？">6.2 如何解决常见的环路问题？</h3><p>这样看起来，两台交换机工作得非常好。随着办公室越来越大，交换机数目肯定越来越多。当整个拓扑结构复杂了，这么多网线，绕过来绕过去，不可避免地会出现一些意料不到的情况。其中常见的问题就是<strong>环路问题</strong>。</p><p>例如这个图，当两个交换机将两个局域网同时连接起来的时候。你可能会觉得，这样反而有了高可用性。但是却不幸地出现了环路。出现了环路会有什么结果呢？</p><p>【简单来说，成环就会一直发】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522155638828.png" alt="image-20240522155638828"></p><p>我们来想象一下机器 1 访问机器 2 的过程。一开始，机器 1 并不知道机器 2 的 MAC 地址，所以它需要发起一个 ARP 的广播。广播到达机器 2，机器 2 会把 MAC 地址返回来，看起来没有这两个交换机什么事情。</p><p>但是问题来了，这两个交换机还是都能够收到广播包的。交换机 A 一开始是不知道机器 2 在哪个局域网的，所以它会把广播消息放到局域网二，在局域网二广播的时候，交换机 B 右边这个网口也是能够收到广播消息的。交换机 B 会将这个广播息信息发送到局域网一。局域网一的这个广播消息，又会到达交换机 A 左边的这个接口。交换机 A 这个时候还是不知道机器 2 在哪个局域网，于是将广播包又转发到局域网二。左转左转左转，好像是个圈哦。</p><p>可能有人会说，当两台交换机都能够逐渐学习到拓扑结构之后，是不是就可以了？</p><p>别想了，压根儿学不会的。机器 1 的广播包到达交换机 A 和交换机 B 的时候，本来两个交换机都学会了机器 1 是在局域网一的，但是当交换机 A 将包广播到局域网二之后，交换机 B 右边的网口收到了来自交换机 A 的广播包。根据学习机制，这彻底损坏了交换机 B 的三观，刚才机器 1 还在左边的网口呢，怎么又出现在右边的网口呢？哦，那肯定是机器 1 换位置了，于是就误会了，交换机 B 就学会了，机器 1 是从右边这个网口来的，把刚才学习的那一条清理掉。同理，交换机 A 右边的网口，也能收到交换机 B 转发过来的广播包，同样也误会了，于是也学会了，机器 1 从右边的网口来，不是从左边的网口来。</p><p>然而当广播包从左边的局域网一广播的时候，两个交换机再次刷新三观，原来机器 1 是在左边的，过一会儿，又发现不对，是在右边的，过一会，又发现不对，是在左边的。</p><p>这还是一个包转来转去，每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走。所以，必须有一个方法解决环路的问题，怎么破除环路呢？</p><h3 id="6-3-STP-协议中那些难以理解的概念">6.3 STP 协议中那些难以理解的概念</h3><p>在数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为<strong>图</strong>。将图中的环破了，就生成了<strong>树</strong>。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称<strong>Spanning Tree Protocol</strong>。</p><p>STP 协议比较复杂，一开始很难看懂，但是其实这是一场血雨腥风的武林比武或者华山论剑，最终决出五岳盟主的方式。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194202439.png" alt="image-20240522194202439"></p><p>在 STP 协议里面有很多概念，译名就非常拗口，但是我一作比喻，你很容易就明白了。</p><ul><li><strong>Root Bridge</strong>，也就是根交换机。这个比较容易理解，可以比喻为”掌门”交换机，是某棵树的老大，是掌门，最大的大哥。</li><li><strong>Designated Bridges</strong>，有的翻译为指定交换机。这个比较难理解，可以想像成一个”小弟”，对于树来说，就是一棵树的树枝。所谓”指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥。这里注意是树枝，不是叶子，因为叶子往往是主机。</li><li><strong>Bridge Protocol Data Units （BPDU）</strong> ，网桥协议数据单元。可以比喻为”相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。BPDU 只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。</li><li><strong>Priority Vector</strong>，优先级向量。可以比喻为实力 （值越小越牛）。实力是啥？就是一组 ID 数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。为什么这样设计呢？这是因为要看怎么来比实力。先看 Root Bridge ID。拿出老大的 ID 看看，发现掌门一样，那就是师兄弟；再比 Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；最后比 Bridge ID，比我自己的 ID，拿自己的本事比。</li></ul><h3 id="6-4-STP-的工作过程是怎样的？">6.4 STP 的工作过程是怎样的？</h3><p>一开始，江湖纷争，异常混乱。大家都觉得自己是掌门，谁也不服谁。于是，所有的交换机都认为自己是掌门，每个网桥都被分配了一个 ID。这个 ID 里有管理员分配的优先级，当然网络管理员知道哪些交换机贵，哪些交换机好，就会给它们分配高的优先级。这种交换机生下来武功就很高，起步就是乔峰。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194227099.png" alt="image-20240522194227099"></p><p>既然都是掌门，互相都连着网线，就互相发送 BPDU 来比功夫呗。这一比就发现，有人是岳不群，有人是封不平，赢的接着当掌门，输的就只好做小弟了。当掌门的还会继续发 BPDU，而输的人就没有机会了。它们只有在收到掌门发的 BPDU 的时候，转发一下，表示服从命令。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194243194.png" alt="image-20240522194243194"></p><p>数字表示优先级。就像这个图，5 和 6 碰见了，6 的优先级低，所以乖乖做小弟。于是一个小门派形成，5 是掌门，6 是小弟。其他诸如 1-7、2-8、3-4 这样的小门派，也诞生了。于是江湖出现了很多小的门派，小的门派，接着合并。</p><p>合并的过程会出现以下四种情形，我分别来介绍。</p><ol><li><p>情形一：掌门遇到掌门</p><p>当 5 碰到了 1，掌门碰见掌门，1 觉得自己是掌门，5 也刚刚跟别人 PK 完成为掌门。这俩掌门比较功夫，最终 1 胜出。于是输掉的掌门 5 就会率领所有的小弟归顺。结果就是 1 成为大掌门。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194309348.png" alt="image-20240522194309348"></p><ol start="2"><li>情形二：同门相遇</li></ol><p>同门相遇可以是掌门与自己的小弟相遇，这说明存在”环”了。这个小弟已经通过其他门路拜在你门下，结果你还不认识，就 PK 了一把。结果掌门发现这个小弟功夫不错，不应该级别这么低，就把它招到门下亲自带，那这个小弟就相当于升职了。</p><p>我们再来看，假如 1 和 6 相遇。6 原来就拜在 1 的门下，只不过 6 的上司是 5，5 的上司是 1。1 发现，6 距离我才只有 2，比从 5 这里过来的 5（=4+1）近多了，那 6 就直接汇报给我吧。于是，5 和 6 分别汇报给 1。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194329985.png" alt="image-20240522194329985"></p><ol><li>同门相遇还可以是小弟相遇。这个时候就要比较谁和掌门的关系近，当然近的当大哥。刚才 5 和 6 同时汇报给 1 了，后来 5 和 6 再比较功夫的时候发现，5 你直接汇报给 1 距离是 4，如果 5 汇报给 6 再汇报给 1，距离只有 2+1=3，所以 5 干脆拜 6 为上司。</li></ol><p>3.情形三：掌门与其他帮派小弟相遇</p><p>小弟拿本帮掌门和这个掌门比较，赢了，这个掌门拜入门来。输了，会拜入新掌门，并且逐渐拉拢和自己连接的兄弟，一起弃暗投明。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194430951.png" alt="image-20240522194430951"></p><ol><li>例如，2 和 7 相遇，虽然 7 是小弟，2 是掌门。就个人武功而言，2 比 7 强，但是 7 的掌门是 1，比 2 牛，所以没办法，2 要拜入 7 的门派，并且连同自己的小弟都一起拜入。</li></ol><p>4.情形四：不同门小弟相遇</p><p>各自拿掌门比较，输了的拜入赢的门派，并且逐渐将与自己连接的兄弟弃暗投明</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194459243.png" alt="image-20240522194459243"></p><ol><li>例如，5 和 4 相遇。虽然 4 的武功好于 5，但是 5 的掌门是 1，比 4 牛，于是 4 拜入 5 的门派。后来当 3 和 4 相遇的时候，3 发现 4 已经叛变了，4 说我现在老大是 1，比你牛，要不你也来吧，于是 3 也拜入 1。</li></ol><p>最终，生成一棵树，武林一统，天下太平。但是天下大势，分久必合，合久必分，天下统一久了，也会有相应的问题。</p><h3 id="6-5-如何解决广播问题和安全问题？">6.5 如何解决广播问题和安全问题？</h3><p>毕竟机器多了，交换机也多了，就算交换机比 Hub 智能一些，但是还是难免有广播的问题，一大波机器，相关的部门、不相关的部门，广播一大堆，性能就下来了。就像一家公司，创业的时候，一二十个人，坐在一个会议室，有事情大家讨论一下，非常方便。但是如果变成了 50 个人，全在一个会议室里面吵吵，就会乱的不得了。</p><p>你们公司有不同的部门，有的部门需要保密的，比如人事部门，肯定要讨论升职加薪的事儿。由于在同一个广播域里面，很多包都会在一个局域网里面飘啊飘，碰到了一个会抓包的程序员，就能抓到这些包，如果没有加密，就能看到这些敏感信息了。还是上面的例子，50 个人在一个会议室里面七嘴八舌的讨论，其中有两个 HR，那他们讨论的问题，肯定被其他人偷偷听走了。</p><p>那咋办，分部门，分会议室呗。那我们就来看看怎么分。</p><p>有两种分的方法，一个是<strong>物理隔离</strong>。每个部门设一个单独的会议室，对应到网络方面，就是每个部门有单独的交换机，配置单独的子网，这样部门之间的沟通就需要路由器了。路由器咱们还没讲到，以后再说。这样的问题在于，有的部门人多，有的部门人少。人少的部门慢慢人会变多，人多的部门也可能人越变越少。如果每个部门有单独的交换机，口多了浪费，少了又不够用。</p><p>另外一种方式是<strong>虚拟隔离</strong>，就是用我们常说的VLAN，或者叫虚拟局域网。使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194517360.png" alt="image-20240522194517360"></p><p>我们只需要在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共 12 位。为什么是 12 位呢？因为 12 位可以划分 4096 个 VLAN。这样是不是还不够啊。现在的情况证明，目前云计算厂商里面绝对不止 4096 个用户。当然每个用户需要一个 VLAN 了啊，怎么办呢，这个我们在后面的章节再说。</p><p>如果我们买的交换机是支持 VLAN 的，当这个交换机把二层的头取下来的时候，就能够识别这个 VLAN ID。这样只有相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的。这样广播问题和安全问题就都能够解决了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194531328.png" alt="image-20240522194531328"></p><p>我们可以设置交换机每个口所属的 VLAN。如果某个口坐的是程序员，他们属于 VLAN 10；如果某个口坐的是人事，他们属于 VLAN 20；如果某个口坐的是财务，他们属于 VLAN 30。这样，财务发的包，交换机只会转发到 VLAN 30 的口上。程序员啊，你就监听 VLAN 10 吧，里面除了代码，啥都没有。</p><p>而且对于交换机来讲，每个 VLAN 的口都是可以重新设置的。一个财务走了，把他所在的作为的口从 VLAN 30 移除掉，来了一个程序员，坐在财务的位置上，就把这个口设置为 VLAN 10，十分灵活。</p><p>有人会问交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么 VLAN 呢？对于支持 VLAN 的交换机，有一种口叫作Trunk 口。它可以转发属于任何 VLAN 的口。交换机之间可以通过这种口相互连接。</p><p>好了，解决这么多交换机连接在一起的问题，办公室的问题似乎搞定了。然而这只是一般复杂的场景，因为你能接触到的网络，到目前为止，不管是你的台式机，还是笔记本所连接的网络，对于带宽、高可用等都要求不高。就算出了问题，一会儿上不了网，也不会有什么大事。</p><p>我们在宿舍、学校或者办公室，经常会访问一些网站，这些网站似乎永远不会”挂掉”。那是因为这些网站都生活在一个叫做数据中心的地方，那里的网络世界更加复杂。在后面的章节，我会为你详细讲解。</p><h3 id="6-6-小结">6.6 小结</h3><p>总结：</p><ul><li>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</li><li>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</li></ul><h2 id="第7讲-ICMP与ping：投石问路的侦察兵">第7讲 | ICMP与ping：投石问路的侦察兵</h2><h3 id="7-1-ICMP-协议的格式">7.1 ICMP 协议的格式</h3><p>ping 是基于 ICMP 协议工作的。<strong>ICMP</strong>全称<strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>。这里面的关键词是”控制”，那具体是怎么控制的呢？</p><p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。当遇到问题的时候，总不能”死个不明不白”，要传出消息来，报告情况，这样才可以调整传输策略。这就相当于我们经常看到的电视剧里，古代行军的时候，为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局。</p><p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522194735874.png" alt="image-20240522194735874"></p><p>ICMP 报文有很多的类型，不同的类型有不同的代码。<strong>最常用的类型是主动请求为 8，主动请求的应答为 0</strong>。</p><h3 id="7-2-查询报文类型">7.2 查询报文类型</h3><p>我们经常在电视剧里听到这样的话：主帅说，来人哪！前方战事如何，快去派人打探，一有情况，立即通报！</p><p>这种是主帅发起的，主动查看敌情，对应 ICMP 的<strong>查询报文类型</strong>。例如，常用的<strong>ping 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议</strong>。所以，ping 发的包也是符合 ICMP 协议格式的，只不过它在后面增加了自己的格式。</p><p>对 ping 的主动请求，进行网络抓包，称为<strong>ICMP ECHO REQUEST</strong>。同理主动请求的回复，称为<strong>ICMP ECHO REPLY</strong>。比起原生的 ICMP，这里面多了两个字段，一个是<strong>标识符</strong>。这个很好理解，你派出去两队侦查兵，一队是侦查战况的，一队是去查找水源的，要有个标识才能区分。另一个是<strong>序号</strong>，你派出去的侦查兵，都要编个号。如果派出去 10 个，回来 10 个，就说明前方战况不错；如果派出去 10 个，回来 2 个，说明情况可能不妙。</p><p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><h3 id="7-3-差错报文类型">7.3 差错报文类型</h3><p>当然也有另外一种方式，就是差错报文。</p><p>主帅骑马走着走着，突然来了一匹快马，上面的小兵气喘吁吁的：报告主公，不好啦！张将军遭遇埋伏，全军覆没啦！这种是异常情况发起的，来报告发生了不好的事情，对应 ICMP 的<strong>差错报文类型</strong>。</p><p>我举几个 ICMP 差错报文的例子：<strong>终点不可达为 3，源抑制为 4，超时为 11，重定向为 5</strong>。这些都是什么意思呢？我给你具体解释一下。</p><p><strong>第一种是终点不可达</strong>。小兵：报告主公，您让把粮草送到张将军那里，结果没有送到。</p><p>如果你是主公，你肯定会问，为啥送不到？具体的原因在代码中表示就是，网络不可达代码为 0，主机不可达代码为 1，协议不可达代码为 2，端口不可达代码为 3，需要进行分片但设置了不分片位代码为 4。</p><p>具体的场景就像这样：</p><ul><li>网络不可达：主公，找不到地方呀？</li><li>主机不可达：主公，找到地方没这个人呀？</li><li>协议不可达：主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说 12345！</li><li>端口不可达：主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。</li><li>需要进行分片但设置了不分片位：主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了。</li></ul><p><strong>第二种是源站抑制</strong>，也就是让源站放慢发送速度。小兵：报告主公，您粮草送的太多了吃不完。</p><p><strong>第三种是时间超时</strong>，也就是超过网络包的生存时间还是没到。小兵：报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。</p><p><strong>第四种是路由重定向</strong>，也就是让下次发给另一个路由器。小兵：报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。</p><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><p>而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。</p><p>侦察兵：报告主公，张将军已经战死沙场，这是张将军的印信和佩剑。<br>主公：神马？张将军是怎么死的（可以查看 ICMP 的前 8 字节）？没错，这是张将军的剑，是他的剑（IP 数据包的头及正文前 8 字节）。</p><h3 id="7-4-ping：查询报文类型的使用">7.4 ping：查询报文类型的使用</h3><p>接下来，我们重点来看 ping 的发送和接收过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522200017978.png" alt="image-20240522200017978"></p><p>假定主机 A 的 IP 地址是 192.168.1.1，主机 B 的 IP 地址是 192.168.1.2，它们都在同一个子网。那当你在主机 A 上运行”ping 192.168.1.2”后，会发生什么呢?</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是<strong>类型字段</strong>，对于请求数据包而言该字段为 8；另外一个是<strong>顺序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。</p><p>接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。这个过程后面几节会详细描述，这里暂时不多说。</p><p>如果在自己的可控范围之内，当遇到网络不通的问题的时候，除了直接 ping 目标的 IP 地址之外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过 tcpdump -i eth0 icmp，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。</p><p>经常会遇到一个问题，如果不在我们的控制范围内，很多中间设备都是禁止 ping 的，但是 ping 不通不代表网络不通。这个时候就要使用 telnet，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。</p><p>说了这么多，你应该可以看出 ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST 和 ECHO REPLY 类型的</p><h3 id="7-5-Traceroute：差错报文类型的使用">7.5 Traceroute：差错报文类型的使用</h3><p>那其他的类型呢？是不是只有真正遇到错误的时候，才能收到呢？那也不是，有一个程序 Traceroute，是个”大骗子”。它会使用 ICMP 的规则，故意制造一些能够产生错误的场景。</p><p>所以，<strong>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</strong>。**Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。**将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它”牺牲”了。</p><p>如果中间的路由器不止一个，当然碰到第一个就”牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。那大军前行就带一顿饭，试一试走多远会被饿死，然后找个哨探回来报告，那我就知道大军只带一顿饭能走多远了。</p><p>接下来，将 TTL 设置为 2。第一关过了，第二关就”牺牲”了，那我就知道第二关有多远。如此反复，直到到达目的主机。这样，Traceroute 就拿到了所有的路由器 IP。当然，有的路由器压根不会回这个 ICMP。这也是 Traceroute 一个公网的地址，看不到中间路由的原因。</p><p><strong>怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份”端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。</strong></p><p>这就相当于故意派人去西天如来那里去请一本《道德经》，结果人家信佛不信道，消息就会被打出来。被打的消息传回来，你就知道西天是能够到达的。为什么不去取《心经》呢？因为 UDP 是无连接的。也就是说这人一派出去，你就得不到任何音信。你无法区别到底是半路走丢了，还是真的信佛遁入空门了，只有让人家打出来，你才会得到消息。</p><p><strong>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU</strong>。要做的工作首先是发送分组，并设置”不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，类型为”需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到 ICMP”不能分片”差错时就减小分组的长度，直到到达目标主机。</p><h3 id="7-6-小结">7.6 小结</h3><p>总结一下：</p><ul><li>ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；</li><li>ping 使用查询报文，Traceroute 使用差错报文。</li></ul><h2 id="第8讲-世界这么大，我想出网关：欧洲十国游与玄奘西行">第8讲 | 世界这么大，我想出网关：欧洲十国游与玄奘西行</h2><h3 id="8-1-怎么在宿舍上网？">8.1 怎么在宿舍上网？</h3><p>还记得咱们在宿舍的时候买了台交换机，几台机器组了一个局域网打游戏吗？可惜啊，只能打局域网的游戏，不能上网啊！盼啊盼啊，终于盼到大二，允许宿舍开通网络了。学校给每个宿舍的网口分配了一个 IP 地址。这个 IP 是校园网的 IP，完全由网管部门控制。宿舍网的 IP 地址多为 192.168.1.x。校园网的 IP 地址，假设是 10.10.x.x。</p><p>补充：为什么一个网卡只能连一个IP？</p><p>A：想想ifconfig，里面的网卡信息，如果配置多个IP，那可能就不知道socket和谁绑定了！</p><p>这个时候，你要在宿舍上网，有两个办法：</p><p>第一个办法，让你们宿舍长再买一个网卡。这个时候，你们宿舍长的电脑里就有两张网卡。一张网卡的线插到你们宿舍的交换机上，另一张网卡的线插到校园网的网口。而且，这张新的网卡的 IP 地址要按照学校网管部门分配的配置，不然上不了网。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着宿舍长的电脑</strong>。</p><p>第二个办法，你们共同出钱买个家庭路由器（反正当时我们买不起）。家庭路由器会有内网网口和外网网口。把外网网口的线插到校园网的网口上，将这个外网网口配置成和网管部的一样。内网网口连上你们宿舍的所有的电脑。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着路由器</strong>。</p><p>这两种方法其实是一样的。只不过第一种方式，让你的宿舍长的电脑，变成一个有多个口的路由器而已。而你买的家庭路由器，里面也跑着程序，和你宿舍长电脑里的功能一样，只不过是一个嵌入式的系统。</p><p>当你的宿舍长能够上网之后，接下来，就是其他人的电脑怎么上网的问题。这就需要配置你们的<strong>网卡</strong>。当然 DHCP 是可以默认配置的。在进行网卡配置的时候，除了 IP 地址，还需要配置一个<strong>Gateway</strong>的东西，这个就是<strong>网关</strong>。</p><h3 id="8-2-你了解-MAC-头和-IP-头的细节吗？">8.2 你了解 MAC 头和 IP 头的细节吗？</h3><p>一旦配置了 IP 地址和网关，往往就能够指定目标地址进行访问了。由于在跨网关访问的时候，牵扯到 MAC 地址和 IP 地址的变化，这里有必要详细描述一下 MAC 头和 IP 头的细节。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522203523058.png" alt="image-20240522203523058"></p><p>在 MAC 头里面，先是目标 MAC 地址，然后是源 MAC 地址，然后有一个协议类型，用来说明里面是 IP 协议。IP 头里面的版本号，目前主流的还是 IPv4，服务类型 TOS 在第三节讲 ip addr 命令的时候讲过，TTL 在第 7 节讲 ICMP 协议的时候讲过。另外，还有 8 位标识协议。这里到了下一层的协议，也就是，是 TCP 还是 UDP。最重要的就是源 IP 和目标 IP。先是源 IP 地址，然后是目标 IP 地址。</p><p>在任何一台机器上，当要访问另一个 IP 地址的时候，都会先判断，这个目标 IP 地址，和当前机器的 IP 地址，是否在同一个网段。怎么判断同一个网段呢？需要 CIDR 和子网掩码，这个在第三节的时候也讲过了。</p><p><strong>如果是同一个网段</strong>，例如，你访问你旁边的兄弟的电脑，那就没网关什么事情，直接将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。</p><p><strong>如果不是同一网段</strong>，例如，你要访问你们校园网里面的 BBS，该怎么办？这就需要发往默认网关 Gateway。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个。例如 192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24 或者 192.168.1.2/24。</p><p>如何发往默认网关呢？网关不是和源 IP 地址是一个网段的么？这个过程就和发往同一个网段的其他机器是一样的：将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关的 MAC 放入 MAC 头中，发送出去。网关所在的端口，例如 192.168.1.1/24 将网络包收进来，然后接下来怎么做，就完全看网关的了。</p><p><strong>网关往往是一个路由器，是一个三层转发的设备</strong>。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。</p><p>在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。</p><p>很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：<strong>路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关</strong>。</p><p>任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。</p><h3 id="8-3-静态路由是什么？">8.3 静态路由是什么？</h3><p>这个时候，问题来了，该选择哪一只手？IP 头和 MAC 头加什么内容，哪些变、哪些不变呢？这个问题比较复杂，大致可以分为两类，一个是<strong>静态路由</strong>，一个是<strong>动态路由</strong>。动态路由下一节我们详细地讲。这一节我们先说静态路由。</p><p><strong>静态路由，其实就是在路由器上，配置一条一条规则</strong>。这些规则包括：想访问 BBS 站（它肯定有个网段），从 2 号口出去，下一跳是 IP2；想访问教学视频站（它也有个自己的网段），从 3 号口出去，下一跳是 IP3，然后保存在路由器里。</p><p>每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳 IPX。</p><h3 id="8-4-IP-头和-MAC-头哪些变、哪些不变？">8.4 IP 头和 MAC 头哪些变、哪些不变？</h3><p>对于 IP 头和 MAC 头哪些变、哪些不变的问题，可以分两种类型。我把它们称为 <strong>“欧洲十国游”型</strong> 和 <strong>“玄奘西行”型</strong> 。</p><p>之前我说过，MAC 地址是一个局域网内才有效的地址。因而，MAC 地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于 IP 地址是否改变。不改变 IP 地址的网关，我们称为<strong>转发网关</strong>；改变 IP 地址的网关，我们称为<strong>NAT 网关</strong>。</p><ol><li><p>“欧洲十国游”型</p><p>结合这个图，我们先来看”欧洲十国游”型。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522203650916.png" alt="image-20240522203650916"></p><p>服务器 A 要访问服务器 B。首先，服务器 A 会思考，192.168.4.101 和我不是一个网段的，因而需要先发给网关。那网关是谁呢？已经静态配置好了，网关是 192.168.1.1。网关的 MAC 地址是多少呢？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：服务器 A 的 MAC</p></li><li><p>目标 MAC：192.168.1.1 这个网口的 MAC</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p><p>包到达 192.168.1.1 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 A 中配置了静态路由之后，要想访问 192.168.4.0/24，要从 192.168.56.1 这个口出去，下一跳为 192.168.56.2。</p><p>于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2，那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址，然后发送包。包的内容是这样的：</p></li><li><p>源 MAC：192.168.56.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.56.2 的 MAC 地址</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p><p>包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 B 中配置了静态路由，要想访问 192.168.4.0/24，要从 192.168.4.1 这个口出去，没有下一跳了。因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.4.1 这个口发出去，发给 192.168.4.101。那 192.168.4.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取 192.168.4.101 的 MAC 地址，然后发送包。包的内容是这样的：</p></li><li><p>源 MAC：192.168.4.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.4.101 的 MAC 地址</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p><p>包到达服务器 B，MAC 地址匹配，将包收进来。</p><p>通过这个过程可以看出，每到一个新的局域网，MAC 都是要变的，但是 IP 地址都不变。在 IP 头里面，不会保存任何网关的 IP 地址。<strong>所谓的下一跳是，某个 IP 要将这个 IP 地址转换为 MAC 放入 MAC 头</strong>。</p><p>之所以将这种模式比喻称为欧洲十国游，是因为在整个过程中，IP 头里面的地址都是不变的。IP 地址在三个局域网都可见，在三个局域网之间的网段都不会冲突。在三个网段之间传输包，IP 头不改变。这就像在欧洲各国之间旅游，一个签证就能搞定。</p></li></ul><ol start="2"><li>“玄奘西行”型</li></ol></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522203721417.png" alt="image-20240522203721417"></p><ol><li><p>这里遇见的第一个问题是，局域网之间没有商量过，各定各的网段，因而 IP 段冲突了。最左面大唐的地址是 192.168.1.101，最右面印度的地址也是 192.168.1.101，如果单从 IP 地址上看，简直是自己访问自己，其实是大唐的 192.168.1.101 要访问印度的 192.168.1.101。</p><p>怎么解决这个问题呢？既然局域网之间没有商量过，你们各管各的，那到国际上，也即中间的局域网里面，就需要使用另外的地址。就像出国，不能用咱们自己的身份证，而要改用护照一样，玄奘西游也要拿着专门取经的通关文牒，而不能用自己国家的身份证。</p><p>首先，目标服务器 B 在国际上要有一个国际的身份，我们给它一个 192.168.56.2。在网关 B 上，我们记下来，国际身份 192.168.56.2 对应国内身份 192.168.1.101。凡是要访问 192.168.56.2，都转成 192.168.1.101。</p><p>于是，源服务器 A 要访问目标服务器 B，要指定的目标地址为 192.168.56.2。这是它的国际身份。服务器 A 想，192.168.56.2 和我不是一个网段的，因而需要发给网关，网关是谁？已经静态配置好了，网关是 192.168.1.1，网关的 MAC 地址是多少？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：服务器 A 的 MAC</p></li><li><p>目标 MAC：192.168.1.1 这个网口的 MAC</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.56.2</p><p>包到达 192.168.1.1 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 A 中配置了静态路由：要想访问 192.168.56.2/24，要从 192.168.56.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2。那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址。</p><p>当网络包发送到中间的局域网的时候，服务器 A 也需要有个国际身份，因而在国际上，源 IP 地址也不能用 192.168.1.101，需要改成 192.168.56.1。发送包的内容是这样的：</p></li><li><p>源 MAC：192.168.56.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.56.2 的 MAC 地址</p></li><li><p>源 IP：192.168.56.1</p></li><li><p>目标 IP：192.168.56.2</p><p>包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>路由器 B 是一个 NAT 网关，它上面配置了，要访问国际身份 192.168.56.2 对应国内身份 192.168.1.101，于是改为访问 192.168.1.101。</p><p>在路由器 B 中配置了静态路由：要想访问 192.168.1.0/24，要从 192.168.1.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.1.1 这个口发出去，发给 192.168.1.101。</p><p>那 192.168.1.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取 192.168.1.101 的 MAC 地址，然后发送包。内容是这样的：</p></li><li><p>源 MAC：192.168.1.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.1.101 的 MAC 地址</p></li><li><p>源 IP：192.168.56.1</p></li><li><p>目标 IP：192.168.1.101</p><p>包到达服务器 B，MAC 地址匹配，将包收进来。</p><p>从服务器 B 接收的包可以看出，源 IP 为服务器 A 的国际身份，因而发送返回包的时候，也发给这个国际身份，由路由器 A 做 NAT，转换为国内身份。</p><p>从这个过程可以看出，IP 地址也会变。这个过程用英文说就是<strong>Network Address Translation</strong>，简称<strong>NAT</strong>。</p><p><strong>其实这第二种方式我们经常见</strong>，现在大家每家都有家用路由器，家里的网段都是 192.168.1.x，所以你肯定访问不了你邻居家的这个私网的 IP 地址的。所以，当我们家里的包发出去的时候，都被家用路由器 NAT 成为了运营商的地址了。</p><p>很多办公室访问外网的时候，也是被 NAT 过的，因为不可能办公室里面的 IP 也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口 IP 地址。你可以通过 <a href="https://www.whatismyip.com/">https://www.whatismyip.com/</a> 查看自己的出口 IP 地址。</p></li></ul></li></ol><h3 id="8-5-小结">8.5 小结</h3><p>总结一下：</p><ul><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则；</li><li>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</li></ul><h2 id="第9讲-路由协议：西出网关无故人，敢问路在何方">第9讲 | 路由协议：西出网关无故人，敢问路在何方</h2><p>俗话说得好，在家千日好，出门一日难。网络包一旦出了网关，就像玄奘西行一样踏上了江湖漂泊的路。</p><p>上一节我们描述的是一个相对简单的情形。出了网关之后，只有一条路可以走。但是，网络世界复杂得多，一旦出了网关，会面临着很多路由器，有很多条道路可以选。如何选择一个更快速的道路求取真经呢？这里面还有很多门道可以讲。</p><h3 id="9-1-如何配置路由？">9.1 如何配置路由？</h3><p>通过上一节的内容，你应该已经知道，路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为<strong>路由表</strong>。</p><p>一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。</p><ul><li>目的网络：这个包想去哪儿？</li><li>出口设备：将包从哪个口扔出去？</li><li>下一跳网关：下一个路由器的地址。</li></ul><p>通过 route 命令和 ip route 命令都可以进行查询或者配置。</p><p>例如，我们设置 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p><p>上一节的例子中，网关上的路由策略就是按照这三项配置信息进行配置的。这种配置方式的一个核心思想是：<strong>根据目的 IP 地址来配置路由</strong>。</p><h3 id="9-2-如何配置策略路由？">9.2 如何配置策略路由？</h3><p>当然，在真实的复杂的网络环境中，除了可以根据目的 ip 地址配置路由外，还可以根据多个参数来配置路由，这就称为<strong>策略路由</strong>。</p><p>可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。</p><p>例如，我们设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 10</span><br><span class="line">ip rule add from 192.168.2.0/24 table 20</span><br></pre></td></tr></table></figure><p>表示从 192.168.1.10/24 这个网段来的，使用 table 10 中的路由表，而从 192.168.2.0/24 网段来的，使用 table20 的路由表。</p><p>在一条路由规则中，也可以走多条路径。例如，在下面的路由规则中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2</span><br></pre></td></tr></table></figure><p>下一跳有两个地方，分别是 100.100.100.1 和 200.200.200.1，权重分别为 1 比 2。</p><p>在什么情况下会用到如此复杂的配置呢？我来举一个现实中的例子。</p><p>我是房东，家里从运营商那儿拉了两根网线。这两根网线分别属于两个运行商。一个带宽大一些，一个带宽小一些。这个时候，我就不能买普通的家用路由器了，得买个高级点的，可以接两个外网的。</p><p>家里的网络呢，就是普通的家用网段 192.168.1.x/24。家里有两个租户，分别把线连到路由器上。IP 地址为 192.168.1.101/24 和 192.168.1.102/24，网关都是 192.168.1.1/24，网关在路由器上。</p><p>就像上一节说的一样，家里的网段是私有网段，出去的包需要 NAT 成公网的 IP 地址，因而路由器是一个 NAT 路由器。</p><p>两个运营商都要为这个网关配置一个公网的 IP 地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212124077.png" alt="image-20240522212124077"></p><p>运行商里面也有一个 IP 地址，在运营商网络里面的网关。不同的运营商方法不一样，有的是 /32 的，也即一个一对一连接。</p><p>例如，运营商 1 给路由器分配的地址是 183.134.189.34/32，而运营商网络里面的网关是 183.134.188.1/32。有的是 /30 的，也就是分了一个特别小的网段。运营商 2 给路由器分配的地址是 60.190.27.190/30，运营商网络里面的网关是 60.190.27.189/30。</p><p>根据这个网络拓扑图，可以将路由配置成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip route list table main</span><br><span class="line">60.190.27.189/30 dev eth3  proto kernel  scope <span class="built_in">link</span>  src 60.190.27.190</span><br><span class="line">183.134.188.1 dev eth2  proto kernel  scope <span class="built_in">link</span>  src 183.134.189.34</span><br><span class="line">192.168.1.0/24 dev eth1  proto kernel  scope <span class="built_in">link</span>  src 192.168.1.1</span><br><span class="line">127.0.0.0/8 dev lo  scope <span class="built_in">link</span></span><br><span class="line">default via 183.134.188.1 dev eth2</span><br></pre></td></tr></table></figure><p>当路由这样配置的时候，就告诉这个路由器如下的规则：</p><ul><li>如果去运营商二，就走 eth3；</li><li>如果去运营商一呢，就走 eth2；</li><li>如果访问内网，就走 eth1；</li><li>如果所有的规则都匹配不上，默认走运营商一，也即走快的网络。</li></ul><p>但是问题来了，租户 A 不想多付钱，他说我就上上网页，从不看电影，凭什么收我同样贵的网费啊？没关系，咱有技术可以解决。</p><p>下面我添加一个 Table，名字叫<strong>chao</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 200 chao &gt;&gt; /etc/iproute2/rt_tables</span><br></pre></td></tr></table></figure><p>添加一条规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip rule add from 192.168.1.101 table chao</span><br><span class="line">$ ip rule <span class="built_in">ls</span></span><br><span class="line">0:    from all lookup <span class="built_in">local</span></span><br><span class="line">32765:    from 192.168.1.101 lookup chao</span><br><span class="line">32766:    from all lookup main</span><br><span class="line">32767:    from all lookup default</span><br></pre></td></tr></table></figure><p>设定规则为：从 192.168.1.101 来的包都查看个 chao 这个新的路由表。</p><p>在 chao 路由表中添加规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add default via 60.190.27.189 dev eth3 table chao</span><br><span class="line">ip route flush cache</span><br></pre></td></tr></table></figure><p>默认的路由走慢的，谁让你不付钱。</p><p>上面说的都是静态的路由，一般来说网络环境简单的时候，在自己的可控范围之内，自己捣鼓还是可以的。但是有时候网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。</p><h3 id="9-3-动态路由算法">9.3 动态路由算法</h3><p>使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。那路由算法是什么样的呢？</p><p>我们可以想象唐僧西天取经，需要解决两大问题，一个是在每个国家如何找到正确的路，去换通关文牒、吃饭、休息；一个是在国家之间，野外行走的时候，如何找到正确的路、水源的问题。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212214388.png" alt="image-20240522212214388"></p><p>无论是一个国家内部，还是国家之间，我们都可以将复杂的路径，抽象为一种叫作图的数据结构。至于唐僧西行取经，肯定想走得路越少越好，道路越短越好，因而这就转化成为<strong>如何在途中找到最短路径</strong>的问题。</p><p>咱们在大学里面学习计算机网络与数据结构的时候，知道求最短路径常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。在计算机网络中基本也是用这两种方法计算的。</p><ol><li><p><strong>距离矢量路由算法</strong></p><p>第一大类的算法称为<strong>距离矢量路由（distance vector routing）</strong>。它是基于 Bellman-Ford 算法的。</p><p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p><p>由此可以看出，每个路由器都是知道全局信息的。那这个信息如何更新呢？每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。</p><p>每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。</p><p>这个算法比较简单，但是还是有问题。</p><p><strong>第一个问题就是好消息传得快，坏消息传得慢</strong>。如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去。要不了多久，整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212237934.png" alt="image-20240522212237934"></p></li><li><p>原来的网络包括两个节点，B 和 C。A 加入了网络，它的邻居 B 很快就发现 A 启动起来了。于是它将自己和 A 的距离设为 1，同样 C 也发现 A 起来了，将自己和 A 的距离设置为 2。但是如果 A 挂掉，情况就不妙了。B 本来和 A 是邻居，发现连不上 A 了，但是 C 还是能够连上，只不过距离远了点，是 2，于是将自己的距离设置为 3。殊不知 C 的距离 2 其实是基于原来自己的距离为 1 计算出来的。C 发现自己也连不上 A，并且发现 B 设置为 3，于是自己改成距离 4。依次类推，数越来越大，直到超过一个阈值，我们才能判定 A 真的挂了。</p><p>这个道理有点像有人走丢了。当你突然发现找不到这个人了。于是你去学校问，是不是在他姨家呀？找到他姨家，他姨说，是不是在他舅舅家呀？他舅舅说，是不是在他姥姥家呀？他姥姥说，是不是在学校呀？总归要问一圈，或者是超过一定的时间，大家才会认为这个人的确走丢了。如果这个人其实只是去见了一个谁都不认识的网友去了，当这个人回来的时候，只要他随便见到其中的一个亲戚，这个亲戚就会拉着他到他的家长那里，说你赶紧回家，你妈都找你一天了。</p><p><strong>这种算法的第二个问题是，每次发送的时候，要发送整个全局路由表</strong>。网络大了，谁也受不了，所以最早的路由协议 RIP 就是这个算法。它适用于小型网络（小于 15 跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了。</p><p>所以上面的两个问题，限制了距离矢量路由的网络规模。</p></li><li><p><strong>链路状态路由算法</strong></p><p>第二大类算法是<strong>链路状态路由（link state routing）</strong>，基于 Dijkstra 算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。</p><p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p></li></ol><h3 id="9-4-动态路由协议">9.4 动态路由协议</h3><ol><li><p><strong>基于链路状态路由算法的 OSPF</strong></p><p><strong>OSPF（Open Shortest Path First，开放式最短路径优先）<strong>就是这样一个基于链路状态路由协议，广泛应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为</strong>内部网关协议（Interior Gateway Protocol，简称IGP）</strong>。</p><p>内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候 OSPF 可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为<strong>等价路由</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212256171.png" alt="image-20240522212256171"></p><ol><li><p>这一点非常重要。有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。这个在后面我们讲数据中心的网络的时候，一般应用的接入层会有负载均衡 LVS。它可以和 OSPF 一起，实现高吞吐量的接入层设计。</p><p>有了内网的路由协议，在一个国家内，唐僧可以想怎么走怎么走了，两条路选一条也行。</p></li><li><p><strong>基于距离矢量路由算法的 BGP</strong></p><p>但是外网的路由协议，也即国家之间的，又有所不同。我们称为<strong>外网路由协议（Border Gateway Protocol，简称BGP）</strong>。</p><p>在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。例如，唐僧去西天取经，有的路近。但是路过的国家看不惯僧人，见了僧人就抓。例如灭法国，连光头都要抓。这样的情况即便路近，也最好绕远点走。</p><p>对于网络包同样，每个数据中心都设置自己的 Policy。例如，哪些外部的 IP 可以让内部知晓，哪些内部的 IP 可以让外部知晓，哪些可以通过，哪些不能通过。这就好比，虽然从我家里到目的地最近，但是不能谁都能从我家走啊！</p><p>在网络世界，这一个个国家成为<strong>自治系统AS（Autonomous System）</strong>。自治系统分几种类型。</p><ul><li><p>Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。</p></li><li><p>Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。</p></li><li><p>Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。</p><p>每个自治系统都有边界路由器，通过它和外面的世界建立联系。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522212314796.png" alt="image-20240522212314796"></p></li></ol></li></ol><p><strong>BGP 又分为两类，eBGP 和 iBGP</strong>。自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。</p><p>BGP 协议使用的算法是<strong>路径矢量路由协议（path-vector protocol）</strong>。它是距离矢量路由协议的升级版。</p><p>前面说了距离矢量路由协议的缺点。其中一个是收敛慢。在 BGP 里面，除了下一跳 hop 之外，还包括了自治系统 AS 的路径，从而可以避免坏消息传的慢的问题，也即上面所描述的，B 知道 C 原来能够到达 A，是因为通过自己，一旦自己都到达不了 A 了，就不用假设 C 还能到达 A 了。</p><p>另外，在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。就像大家都能记住出去玩，从中国出发先到韩国然后到日本，只要不计算细到具体哪一站，就算是发送全局信息，也是没有问题的。</p><ul><li><a href="https://www.nowcoder.com/discuss/574150608358313984?sourceSSR=search">什么是静态路由、OSPF、BGP</a></li></ul><h3 id="9-5-小结">9.5 小结</h3><p>总结：</p><ul><li>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</li><li>动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。</li></ul>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>模块1:通信协议综述</title>
    <link href="https://penge666.github.io/posts/db38782f.html"/>
    <id>https://penge666.github.io/posts/db38782f.html</id>
    <published>2024-05-22T06:39:38.000Z</published>
    <updated>2024-05-22T06:58:15.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1讲-为什么要学习网络协议？">第1讲 | 为什么要学习网络协议？</h2><h3 id="1-1-协议三要素">1.1 协议三要素</h3><p>机器不能直接读懂代码，需要进行翻译，翻译的工作教给编译器，也就是程序员常说的 compile。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144110722.png" alt="image-20240522144110722"></p><p>可以看得出，计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。</p><ul><li>语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。</li><li>语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。</li><li>顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。</li></ul><p>当你想要买一个商品，常规的做法就是打开浏览器，输入购物网站的地址。浏览器就会给你显示一个缤纷多彩的页面。它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自 HTTP 协议的”东西”。我拿网易考拉来举例，格式就像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 27 Mar 2018 16:50:26 GMT</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Language: zh-CN</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://pages.kaola.com/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span> 网易考拉 3 周年主会场 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-我们常用的网络协议有哪些？">1.2 我们常用的网络协议有哪些？</h3><p>接下来揭秘我要说的大事情，”双十一”。这和我们要讲的网络协议有什么关系呢？</p><p>在经济学领域，有个伦纳德·里德（Leonard E. Read）创作的《铅笔的故事》。这个故事通过一个铅笔的诞生过程，来讲述复杂的经济学理论。这里，我也用一个下单的过程，看看互联网世界的运行过程中，都使用了哪些网络协议。</p><p>你先在浏览器里面输入 <a href="https://www.kaola.com/">https://www.kaola.com</a> ，这是一个<strong>URL</strong>。浏览器只知道名字是”<a href="http://www.kaola.com">www.kaola.com</a>”，但是不知道具体的地点，所以不知道应该如何访问。于是，它打开地址簿去查找。可以使用一般的地址簿协议<strong>DNS</strong>去查找，还可以使用另一种更加精准的地址簿查找协议<strong>HTTPDNS</strong>。</p><p>无论用哪一种方法查找，最终都会得到这个地址：106.114.138.24。这个是<strong>IP</strong>地址，是互联网世界的”门牌号”。</p><p>知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览请求，往往会使用<strong>HTTP</strong>协议；但是对于购物的请求，往往需要进行加密传输，因而会使用<strong>HTTPS</strong>协议。无论是什么协议，里面都会写明”你要买什么和买多少”。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144203779.png" alt="image-20240522144203779"></p><p>DNS、HTTP、HTTPS 所在的层我们称为<strong>应用层</strong>。经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过 socket 编程来实现。下一层是<strong>传输层</strong>。传输层有两种协议，一种是无连接的协议<strong>UDP</strong>，一种是面向连接的协议<strong>TCP</strong>。对于支付来讲，往往使用 TCP 协议。所谓的面向连接就是，TCP 会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。</p><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144218240.png" alt="image-20240522144218240"></p><p>传输层封装完毕后，浏览器会将包交给操作系统的<strong>网络层</strong>。网络层的协议是 IP 协议。在 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144233303.png" alt="image-20240522144233303"></p><p>操作系统既然知道了目标 IP 地址，就开始想如何根据这个门牌号找到目标机器。操作系统往往会判断，这个目标 IP 地址是本地人，还是外地人。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本地，而在遥远的地方。</p><p>操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海关，去外地就要去<strong>网关</strong>。而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址 192.168.1.1。</p><p>操作系统如何将 IP 地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 192.168.1.1 啊？网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是<strong>MAC</strong>地址，而大吼的那一声是<strong>ARP</strong>协议。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144248330.png" alt="image-20240522144248330"></p><p>于是操作系统将 IP 包交给了下一层，也就是<strong>MAC 层</strong>。网卡再将包发出去。由于这个包里面是有 MAC 地址的，因而它能够到达网关。</p><p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。</p><p>路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址 MAC 进行通信。</p><p>一旦跨越城关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（就是源 IP 地址），欲往西天拜佛求经（指的是目标 IP 地址）。路过宝地，借宿一晚，明日启行，请问接下来该怎么走啊？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144301759.png" alt="image-20240522144301759"></p><p>城关往往是知道这些”知识”的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为路由协议，常用的有<strong>OSPF</strong>和<strong>BGP</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144316590.png" alt="image-20240522144316590"></p><p>城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的 MAC 地址，通过下一个城关的 MAC 地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。</p><p>最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标 IP 啊？目标服务器就会回复一个 MAC 地址。网络包过关后，通过这个 MAC 地址就能找到目标服务器。</p><p>目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP 也对上了，就取下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即<strong>TCP 层</strong>。</p><p>在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。</p><p>因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，例如进了大沙漠，或者被强盗抢劫杀害怎么办呢？因而到了要报个平安。</p><p>如果过一段时间还是没到，发送端的 TCP 层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。<strong>这个重试绝非你的浏览器重新将下单这个动作重新请求一次</strong>。对于浏览器来讲，就发送了一次下单请求，TCP 层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。</p><p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144330863.png" alt="image-20240522144330863"></p><p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。</p><p>如何告诉相关的进程呢？往往通过 RPC 调用，即远程过程调用的方式来实现。远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间的网络互连问题，会由 RPC 框架统一处理。RPC 框架有很多种，有基于 HTTP 协议放在 HTTP 的报文里面的，有直接封装在 TCP 报文里面的。</p><p>当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。</p><h3 id="1-3-小结">1.3 小结</h3><p>列一下之后要讲的网络协议：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144350426.png" alt="image-20240522144350426"></p><h2 id="第2讲-网络分层的真实含义是什么？">第2讲 | 网络分层的真实含义是什么？</h2><h3 id="2-1-这四个问题你真的懂了吗？">2.1 这四个问题你真的懂了吗？</h3><ol><li>TCP 在进行三次握手的时候，IP 层和 MAC 层对应都有什么操作呢？</li><li>A 知道自己的下一个中转站是 B，那从 A 发出来的包，应该把 B 的 IP 地址放在哪里呢？B 知道自己的下一个中转站是 C，从 B 发出来的包，应该把 C 的 IP 地址放在哪里呢？如果放在 IP 协议中的目标地址，那包到了中转站，怎么知道最终的目的地址是 D 呢？</li><li>二层设备处理的通常是 MAC 层的东西。那我发送一个 HTTP 的包，是在第七层工作的，那是不是不需要经过二层设备？或者即便经过了，二层设备也不处理呢？或者换一种问法，二层设备处理的包里，有没有 HTTP 层的内容呢？</li><li>从你的电脑，通过 SSH 登录到公有云主机里面，都需要经历哪些过程？或者说你打开一个电商网站，都需要经历哪些过程？</li></ol><p>上面的这些问题，有的在这一节就会有一个解释，有的则会贯穿我们整个课程。好在后面一节中我会举一个贯穿的例子，将很多层的细节讲过后，你很容易就能把这些知识点串起来。</p><h3 id="2-2-网络为什么要分层？">2.2 网络为什么要分层？</h3><p>因为，是个复杂的程序都要分层。</p><p>理解计算机网络中的概念，一个很好的角度是，想象网络包就是一段 Buffer，或者一块内存，是有格式的。同时，想象自己是一个处理网络包的程序，而且这个程序可以跑在电脑上，可以跑在服务器上，可以跑在交换机上，也可以跑在路由器上。你想象自己有很多的网口，从某个口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。</p><p>当然网络包的格式很复杂，这个程序也很复杂。<strong>复杂的程序都要分层，这是程序设计的要求</strong>。比如，复杂的电商还会分数据库层、缓存层、Compose 层、Controller 层和接入层，每一层专注做本层的事情。</p><h3 id="2-3-程序是如何工作的？">2.3 程序是如何工作的？</h3><p>我们可以简单地想象”你”这个程序的工作过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144538716.png" alt="image-20240522144538716"></p><p>当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了混杂模式，凡是经过的，全部拿进来。</p><p>拿进来以后，就要交给一段程序来处理。于是，你调用<code>process_layer2(buffer)</code>。当然，这是一个假的函数。但是你明白其中的意思，知道肯定是有这么个函数的。那这个函数是干什么的呢？从 Buffer 中，摘掉二层的头，看一看，应该根据头里面的内容做什么操作。</p><p>假设你发现这个包的 MAC 地址和你的相符，那说明就是发给你的，于是需要调用<code>process_layer3(buffer)</code>。这个时候，Buffer 里面往往就没有二层的头了，因为已经在上一个函数的处理过程中拿掉了，或者将开始的偏移量移动了一下。在这个函数里面，摘掉三层的头，看看到底是发送给自己的，还是希望自己转发出去的。</p><p>如何判断呢？如果 IP 地址不是自己的，那就应该转发出去；如果 IP 地址是自己的，那就是发给自己的。根据 IP 头里面的标示，拿掉三层的头，进行下一层的处理，到底是调用 <code>process_tcp(buffer)</code> 呢，还是调用 <code>process_udp(buffer)</code> 呢？</p><p>假设这个地址是 TCP 的，则会调用<code>process_tcp(buffer)</code>。这时候，Buffer 里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 <code>process_http(buffer)</code> 函数呢？</p><p>没有的，如果你是一个网络包处理程序，你不需要有 <code>process_http(buffer)</code>，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。</p><p>浏览器自然是解析 HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 HTTP 请求了，于是使用端口号，将请求发给了你。</p><p>你应该调用<code>send_tcp(buffer)</code>。不用说，Buffer 里面就是 HTTP 请求的内容。这个函数里面加一个 TCP 的头，记录下源端口号。浏览器会给你目的端口号，一般为 80 端口。</p><p>然后调用<code>send_layer3(buffer)</code>。Buffer 里面已经有了 HTTP 的头和内容，以及 TCP 的头。在这个函数里面加一个 IP 的头，记录下源 IP 的地址和目标 IP 的地址。</p><p>然后调用<code>send_layer2(buffer)</code>。Buffer 里面已经有了 HTTP 的头和内容、TCP 的头，以及 IP 的头。这个函数里面要加一下 MAC 的头，记录下源 MAC 地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。</p><p>万事俱备，只要 Buffer 里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了。</p><h3 id="2-4-揭秘层与层之间的关系">2.4 揭秘层与层之间的关系</h3><p>知道了这个过程之后，我们再来看一下原来困惑的问题。</p><p>首先是分层的比喻。<strong>所有不能表示出层层封装含义的比喻，都是不恰当的</strong>。总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧，但是网络世界不是这样的。正确的应该是，总经理之间沟通的时候，经理将总经理放在自己兜里，然后组长把经理放自己兜里，员工把组长放自己兜里，像套娃娃一样。那员工直接沟通，不带上总经理，就不恰当了。</p><p>现实生活中，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句。但是在网络世界，应该是总经理说话，经理补充两句，组长补充两句，员工再补充两句。</p><p>那 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？当然是 TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍。而你只看到 TCP 三次握手了，其实，IP 层和 MAC 层为此也忙活好久了。</p><p>这里要记住一点：<strong>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层</strong>。</p><p>所以，<strong>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的</strong>。</p><p>经常有人会问这样一个问题，我都知道那台机器的 IP 地址了，直接发给他消息呗，要 MAC 地址干啥？这里的关键就是，没有 MAC 地址消息是发不出去的。</p><p>所以如果一个 HTTP 协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。</p><p>所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个 HTTP 协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面 HTTP、TCP、 IP、 MAC 都有。什么叫二层设备呀，就是只把 MAC 头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着。</p><h3 id="2-5-小结">2.5 小结</h3><p>理解网络协议的工作模式，有两个小窍门：</p><ul><li>始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；</li><li>始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</li></ul><h2 id="第3讲-ifconfig：最熟悉又陌生的命令行">第3讲 | ifconfig：最熟悉又陌生的命令行</h2><p>在 Windows 上是 ipconfig，在 Linux 上是 ifconfig。在 Linux 上 ip addr 也可以。</p><p>那你知道 ifconfig 和 ip addr 的区别吗？这是一个有关 net-tools 和 iproute2 的”历史”故事，你刚来到第三节，暂时不用了解这么细，但这也是一个常考的知识点。</p><p>运行一下 ip addr ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f816:3eff:fec7:7975/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这个命令显示了这台机器上所有的网卡。大部分的网卡都会有一个 IP 地址，当然，这不是必须的。在后面的分享中，我们会遇到没有 IP 地址的情况。</p><p><strong>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码</strong>。既然是门牌号码，不能大家都一样，不然就会起冲突。比方说，假如大家都叫六单元 1001 号，那快递就找不到地方了。所以，有时候咱们的电脑弹出网络地址冲突，出现上不去网的情况，多半是 IP 地址冲突了。</p><p>如上输出的结果，10.100.122.2 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。这样产生的 IP 地址的数量很快就不够用了。因为当时设计 IP 地址的时候，哪知道今天会有这么多的计算机啊！因为不够用，于是就有了 IPv6，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64。这个有 128 位，现在看来是够了，但是未来的事情谁知道呢？</p><p>本来 32 位的 IP 地址就不够，还被分成了 5 类。现在想想，当时分配地址的时候，真是太奢侈了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144631049.png" alt="image-20240522144631049"></p><p>在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是网络号，后面一部分是主机号。这很好理解，大家都是六单元 1001 号，我是小区 A 的六单元 1001 号，而你是小区 B 的六单元 1001 号。</p><p>下面这个表格，详细地展示了 A、B、C 三类地址所能包含的主机的数量。在后文中，我也会多次借助这个表格来讲解。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144644621.png" alt="image-20240522144644621"></p><p>这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B 类地址能包含的最大主机数量又太多了。6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</p><h3 id="3-1-无类型域间选路（CIDR）">3.1 无类型域间选路（CIDR）</h3><p>于是有了一个折中的方式叫作无类型域间选路，简称CIDR。这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。从哪里分呢？你如果注意观察的话可以看到，10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。</p><p>伴随着 CIDR 存在的，一个是<strong>广播地址</strong>，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是<strong>子网掩码</strong>，255.255.255.0。</p><p>将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1 和任何数值取 AND，都是原来数值，因而前三个数不变，为 10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是 0，因而最后一个数变为 0，合起来就是 10.100.122.0。这就是<strong>网络号</strong>。<strong>将子网掩码和 IP 地址按位计算 AND，就可得到网络号</strong>。</p><h3 id="3-2-公有-IP-地址和私有-IP-地址">3.2 公有 IP 地址和私有 IP 地址</h3><p>在日常的工作中，几乎不用划分 A 类、B 类或者 C 类，所以时间长了，很多人就忘记了这个分类，而只记得 CIDR。但是有一点还是要注意的，就是公有 IP 地址和私有 IP 地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144721679.png" alt="image-20240522144721679"></p><p>我们继续看上面的表格。表格最右列是私有 IP 地址段。平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的。</p><p>这就像每个小区有自己的楼编号和门牌号，你们小区可以叫 6 栋，我们小区也叫 6 栋，没有任何问题。但是一旦出了小区，就需要使用公有 IP 地址。就像人民路 888 号，是国家统一分配的，不能两个小区都叫人民路 888 号。</p><p>公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问。</p><p>表格中的 192.168.0.x 是最常用的私有 IP 地址。你家里有 Wi-Fi，对应就会有一个 IP 地址。一般你家里地上网设备不会超过 256 个，所以 /24 基本就够了。有时候我们也能见到 /16 的 CIDR，这两种是最常见的，也是最容易理解的。</p><p>不需要将十进制转换为二进制 32 位，就能明显看出 192.168.0 是网络号，后面是主机号。而整个网络里面的第一个地址 192.168.0.1，往往就是你这个私有网络的出口地址。例如，你家里的电脑连接 Wi-Fi，Wi-Fi 路由器的地址就是 192.168.0.1，而 192.168.0.255 就是广播地址。一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到。</p><p>但是也不总都是这样的情况。因此，其他情况往往就会很难理解，还容易出错。</p><h3 id="3-3-举例：一个容易”犯错”的-CIDR">3.3 举例：一个容易”犯错”的 CIDR</h3><p>我们来看 16.158.165.91/22 这个 CIDR。求一下这个网络的第一个地址、子网掩码和广播地址。</p><p>你要是上来就写 16.158.165.1，那就大错特错了。</p><p>/22 不是 8 的整数倍，不好办，只能先变成二进制来看。16.158 的部分不会动，它占了前 16 位。中间的 165，变为二进制为 <code>10100101</code> 。除了前面的 16 位，还剩 6 位。所以，这 8 位中前 6 位是网络号，<code>16.158.&lt;101001&gt;</code>，而 <code>&lt;01&gt;.91</code> 是机器号。</p><p>第一个地址是 <code>16.158.&lt;101001&gt;&lt;00&gt;.1</code>，即 <code>16.158.164.1</code>。子网掩码是 <code>255.255.&lt;111111&gt;&lt;00&gt;.0</code>，即 <code>255.255.252.0</code>。广播地址为 <code>16.158.&lt;101001&gt;&lt;11&gt;.255</code>，即 <code>16.158.167.255</code>。</p><p>这五类地址中，还有一类 D 类是<strong>组播地址</strong>。使用这一类地址，属于某个组的机器都能收到。这有点类似在公司里面大家都加入了一个邮件组。发送邮件，加入这个组的都能收到。组播地址在后面讲述 VXLAN 协议的时候会提到。</p><p>讲了这么多，才讲了上面的输出结果中很小的一部分，是不是觉得原来并没有真的理解 ip addr 呢？我们接着来分析。</p><p>在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。</p><p>lo 全称是<strong>loopback</strong>，又称<strong>环回接口</strong>，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p><h3 id="3-4-MAC-地址">3.4 MAC 地址</h3><p>在 IP 地址的上一行是 <code>link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff</code>，这个被称为<strong>MAC 地址</strong>，是一个网卡的物理地址，用十六进制，6 个 byte 表示。</p><p>MAC 地址是一个很容易让人”误解”的地址。因为 MAC 地址号称全局唯一，不会有两个网卡有相同的 MAC 地址，而且网卡自生产出来，就带着这个地址。很多人看到这里就会想，既然这样，整个互联网的通信，全部用 MAC 地址好了，只要知道了对方的 MAC 地址，就可以把信息传过去。</p><p>这样当然是不行的。 <strong>一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能</strong>。 而有门牌号码属性的 IP 地址，才是有远程定位功能的。</p><p>例如，你去杭州市网商路 599 号 B 楼 6 层找刘超，你在路上问路，可能被问的人不知道 B 楼是哪个，但是可以给你指网商路怎么去。但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道。</p><p><strong>MAC 地址更像是身份证，是一个唯一的标识</strong>。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。</p><p>MAC 地址是有一定定位功能的，只不过范围非常有限。你可以根据 IP 地址，找到杭州市网商路 599 号 B 楼 6 层，但是依然找不到我，你就可以靠吼了，大声喊身份证 XXXX 的是哪位？我听到了，我就会站起来说，是我啊。但是如果你在上海，到处喊身份证 XXXX 的是哪位，我不在现场，当然不会回答，因为我在杭州不在上海。</p><p>所以，MAC 地址的通信范围比较小，局限在一个子网里面。例如，从 192.168.0.2/24 访问 192.168.0.3/24 是可以用 MAC 地址的。一旦跨子网，即从 192.168.0.2/24 到 192.168.1.2/24，MAC 地址就不行了，需要 IP 地址起作用了。</p><h3 id="3-5-网络设备的状态标识">3.5 网络设备的状态标识</h3><p>解析完了 MAC 地址，我们再来看 <code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code> 是干什么的？这个叫作<strong>net_device flags，网络设备的状态标识</strong>。</p><p>UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指什么意思呢？是哪一层的概念呢？最大传输单元 MTU 为 1500，这是以太网的默认值。</p><p>上一节，我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p><p><code>qdisc pfifo_fast</code> 是什么意思呢？qdisc 全称是<strong>queueing discipline</strong>，中文叫<strong>排队规则</strong>。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。</p><p>最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。<code>pfifo_fast</code> 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</p><p>三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。</p><p>数据包是按照服务类型（<strong>Type of Service，TOS</strong>）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><p>队列是个好东西，后面我们讲云计算中的网络的时候，会有很多用户共享一个网络出口的情况，这个时候如何排队，每个队列有多粗，队列处理速度应该怎么提升，我都会详细为你讲解。</p><h3 id="3-6-小结">3.6 小结</h3><p>知识点：</p><ul><li>IP 是地址，有定位功能；MAC 是身份证，无定位功能；</li><li>CIDR 可以用来判断是不是本地人；</li><li>IP 分公有的 IP 和私有的 IP。后面的章节中我会谈到”出国门”，就与这个有关。</li></ul><h2 id="第4讲-DHCP与PXE：IP是怎么来的，又是怎么没的？">第4讲 | DHCP与PXE：IP是怎么来的，又是怎么没的？</h2><h3 id="4-1-如何配置-IP-地址？">4.1 如何配置 IP 地址？</h3><p>如果有相关的知识和积累，你可以用命令行自己配置一个地址。</p><ol><li><p>使用 net-tools：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth1 10.0.0.1/24</span><br><span class="line">sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure></li><li><p>使用 iproute2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 10.0.0.1/24 dev eth1</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> up eth1</span><br></pre></td></tr></table></figure><p>你可能会问了，自己配置这个自由度太大了吧，我是不是配置什么都可以？如果配置一个和谁都不搭边的地址呢？例如，旁边的机器都是 192.168.1.x，我非得配置一个 16.158.23.6，会出现什么现象呢？</p></li></ol><p>不会出现任何现象，就是包发不出去呗。为什么发不出去呢？我来举例说明。</p><p>192.168.1.6 就在你这台机器的旁边，甚至是在同一个交换机上，而你把机器的地址设为了 16.158.23.6。在这台机器上，你企图去 ping192.168.1.6，你觉得只要将包发出去，同一个交换机的另一台机器马上就能收到，对不对？</p><p>可是 Linux 系统不是这样的，它没你想得那么智能。你用肉眼看到那台机器就在旁边，它则需要根据自己的逻辑进行处理。</p><p>还记得我们在第二节说过的原则吗？<strong>只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层</strong>。</p><p>所以，你看着它有自己的源 IP 地址 16.158.23.6，也有目标 IP 地址 192.168.1.6，但是包发不出去，这是因为 MAC 层还没填。</p><p>自己的 MAC 地址自己知道，这个容易。但是目标 MAC 填什么呢？是不是填 192.168.1.6 这台机器的 MAC 地址呢？</p><p>当然不是。Linux 首先会判断，要去的这个地址和我是一个网段的吗，或者和我的一个网卡是同一网段的吗？只有是一个网段的，它才会发送 ARP 请求，获取 MAC 地址。如果发现不是呢？</p><p><strong>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关</strong>。</p><p>如果你配置了网关的话，Linux 会获取网关的 MAC 地址，然后将包发出去。对于 192.168.1.6 这台机器来讲，虽然路过它家门的这个包，目标 IP 是它，但是无奈 MAC 地址不是它的，所以它的网卡是不会把包收进去的。</p><p>如果没有配置网关呢？那包压根就发不出去。</p><p>如果将网关配置为 192.168.1.6 呢？不可能，Linux 不会让你配置成功的，因为网关要和当前的网络至少一个网卡是同一个网段的，怎么可能 16.158.23.6 的网关是 192.168.1.6 呢？</p><p>所以，当你需要手动配置一台机器的网络 IP 时，一定要好好问问你的网络管理员。如果在机房里面，要去网络管理员那里申请，让他给你分配一段正确的 IP 地址。当然，真正配置的时候，一定不是直接用命令配置的，而是放在一个配置文件里面。<strong>不同系统的配置文件格式不同，但是无非就是 CIDR、子网掩码、广播地址和网关地址</strong>。</p><h3 id="4-2-动态主机配置协议（DHCP）">4.2 动态主机配置协议（DHCP）</h3><p>原来配置 IP 有这么多门道儿啊。你可能会问了，配置了 IP 之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置 IP 地址，那可怎么办？还有人事、行政等非技术人员，如果公司所有的电脑都需要 IT 人员配置，肯定忙不过来啊。</p><p>因此，我们需要有一个自动配置的协议，也就是称<strong>动态主机配置协议（Dynamic Host Configuration Protocol）</strong>，简称<strong>DHCP</strong>。</p><p>有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好就可以了。等人走了，或者用完了，还回去，这样其他的机器也能用。</p><p>所以说，<strong>如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了</strong>。</p><h3 id="4-3-解析-DHCP-的工作方式">4.3 解析 DHCP 的工作方式</h3><p>当一台机器新加入一个网络的时候，肯定一脸懵，啥情况都不知道，只知道自己的 MAC 地址。怎么办？先吼一句，我来啦，有人吗？这时候的沟通基本靠”吼”。这一步，我们称为<strong>DHCP Discover</strong>。</p><p>新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。</p><p>在这个广播包里面，新人大声喊：我是新来的（Boot request），我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144856356.png" alt="image-20240522144856356"></p><p>如果一个网络管理员在网络里面配置了<strong>DHCP Server</strong>的话，他就相当于这些 IP 的管理员。他立刻能知道来了一个”新人”。这个时候，我们可以体会 MAC 地址唯一的重要性了。当一台机器带着自己的 MAC 地址加入一个网络的时候，MAC 是它唯一的身份，如果连这个都重复了，就没办法配置了。</p><p>只有 MAC 唯一，IP 管理员才能知道这是一个新人，需要租给它一个 IP 地址，这个过程我们称为<strong>DHCP Offer</strong>。同时，DHCP Server 为此客户保留为它提供的 IP 地址，从而不会为其他 DHCP 客户分配此 IP 地址。</p><p>DHCP Offer 的格式就像这样，里面有给新人分配的地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144909959.png" alt="image-20240522144909959"></p><p>DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 回复说，我分配了一个可用的 IP 给你，你看如何？除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。</p><p>新来的机器很开心，它的”吼”得到了回复，并且有人愿意租给它一个 IP 地址了，这意味着它可以在网络上立足了。当然更令人开心的是，如果有多个 DHCP Server，这台新机器会收到多个 IP 地址，简直受宠若惊。</p><p>它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144922261.png" alt="image-20240522144922261"></p><p>此时，由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP。</p><p>当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144933703.png" alt="image-20240522144933703"></p><p>最终租约达成的时候，还是需要广播一下，让大家都知道。</p><h3 id="4-4-IP-地址的收回和续租">4.4 IP 地址的收回和续租</h3><p>既然是租房子，就是有租期的。租期到了，管理员就要将 IP 收回。</p><p>如果不用的话，收回就收回了。就像你租房子一样，如果还要续租的话，不能到了时间再续租，而是要提前一段时间给房东说。DHCP 也是这样。</p><p>客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。</p><p>好了，一切看起来完美。DHCP 协议大部分人都知道，但是其实里面隐藏着一个细节，很多人可能不会去注意。接下来，我就讲一个有意思的事情：网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系统！</p><h3 id="4-5-预启动执行环境（PXE）">4.5 预启动执行环境（PXE）</h3><p>普通的笔记本电脑，一般不会有这种需求。因为你拿到电脑时，就已经有操作系统了，即便你自己重装操作系统，也不是很麻烦的事情。但是，在数据中心里就不一样了。数据中心里面的管理员可能一下子就拿到几百台空的机器，一个个安装操作系统，会累死的。</p><p>所以管理员希望的不仅仅是自动分配 IP 地址，还要自动安装系统。装好系统之后自动分配 IP 地址，直接启动就能用了，这样当然最好了！</p><p>这事儿其实仔细一想，还是挺有难度的。安装操作系统，应该有个光盘吧。数据中心里不能用光盘吧，想了一个办法就是，可以将光盘里面要安装的操作系统放在一个服务器上，让客户端去下载。但是客户端放在哪里呢？它怎么知道去哪个服务器上下载呢？客户端总得安装在一个操作系统上呀，可是这个客户端本来就是用来安装操作系统的呀？</p><p>其实，这个过程和操作系统启动的过程有点儿像。首先，启动 BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的 MBR 启动扇区，将 GRUB 启动起来；然后将权力交给 GRUB，GRUB 加载内核、加载作为根文件系统的 initramfs 文件；然后将权力交给内核；最后内核启动，初始化整个操作系统。</p><p>那我们安装操作系统的过程，只能插在 BIOS 启动之后了。因为没安装系统之前，连启动扇区都没有。因而这个过程叫做<strong>预启动执行环境（Pre-boot Execution Environment）</strong>，简称<strong>PXE</strong>。</p><p>PXE 协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在 BIOS 里面。当计算机启动时，BIOS 把 PXE 客户端调入内存里面，就可以连接到服务端做一些操作了。</p><p>首先，PXE 客户端自己也需要有个 IP 地址。因为 PXE 的客户端启动起来，就可以发送一个 DHCP 的请求，让 DHCP Server 给它分配一个地址。PXE 客户端有了自己的地址，那它怎么知道 PXE 服务器在哪里呢？对于其他的协议，都好办，要么人告诉他。例如，告诉浏览器要访问的 IP 地址，或者在配置中告诉它；例如，微服务之间的相互调用。</p><p>但是 PXE 客户端启动的时候，啥都没有。好在 DHCP Server 除了分配 IP 地址以外，还可以做一些其他的事情。这里有一个 DHCP Server 的一个样例配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ddns-update-style interim;</span><br><span class="line">ignore client-updates;</span><br><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">subnet 192.168.1.0 netmask 255.255.255.0</span><br><span class="line">&#123;</span><br><span class="line">    option routers 192.168.1.1;</span><br><span class="line">    option subnet-mask 255.255.255.0;</span><br><span class="line">    option time-offset -18000;</span><br><span class="line">    default-lease-time 21600;</span><br><span class="line">    max-lease-time 43200;</span><br><span class="line">    range dynamic-bootp 192.168.1.240 192.168.1.250;</span><br><span class="line">    filename &quot;pxelinux.0&quot;;</span><br><span class="line">    next-server 192.168.1.180;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的原理，默认的 DHCP Server 是需要配置的，无非是我们配置 IP 的时候所需要的 IP 地址段、子网掩码、网关地址、租期等。如果想使用 PXE，则需要配置 next-server，指向 PXE 服务器的地址，另外要配置初始启动文件 filename。</p><p>这样 PXE 客户端启动之后，发送 DHCP 请求之后，除了能得到一个 IP 地址，还可以知道 PXE 服务器在哪里，也可以知道如何从 PXE 服务器上下载某个文件，去初始化操作系统。</p><h3 id="4-6-解析-PXE-的工作过程">4.6 解析 PXE 的工作过程</h3><p>首先，启动 PXE 客户端。第一步是通过 DHCP 协议告诉 DHCP Server，我刚来，一穷二白，啥都没有。DHCP Server 便租给它一个 IP 地址，同时也给它 PXE 服务器的地址、启动文件 pxelinux.0。</p><p>其次，PXE 客户端知道要去 PXE 服务器下载这个文件后，就可以初始化机器。于是便开始下载，下载的时候使用的是 TFTP 协议。所以 PXE 服务器上，往往还需要有一个 TFTP 服务器。PXE 客户端向 TFTP 服务器请求下载这个文件，TFTP 服务器说好啊，于是就将这个文件传给它。</p><p>然后，PXE 客户端收到这个文件后，就开始执行这个文件。这个文件会指示 PXE 客户端，向 TFTP 服务器请求计算机的配置信息 pxelinux.cfg。TFTP 服务器会给 PXE 客户端一个配置文件，里面会说内核在哪里、initramfs 在哪里。PXE 客户端会请求这些文件。</p><p>最后，启动 Linux 内核。一旦启动了操作系统，以后就啥都好办了。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240522144951662.png" alt="image-20240522144951662"></p><p>简单来说，预启动执行环境（PXE，Preboot eXecution Environment）是一种让计算机通过网络启动的方法。它是由Intel提出的一种行业标准，允许计算机在没有任何硬盘或操作系统的情况下，通过网络接口从网络服务器上下载必要的启动文件，进而启动操作系统。</p><p>具体来说，当启动一个PXE兼容的计算机时，计算机的BIOS会启用它的网络接口，发送一个网络启动请求。这个请求会被网络中的PXE服务器捕获，PXE服务器会回应这个请求，提供一个启动映像。计算机会下载这个映像，并从中启动操作系统。</p><p>总的来说，PXE就是一种让计算机通过网络启动的技术，它可以让计算机在没有硬盘或操作系统的情况下启动，这对于大规模的计算机集群管理和维护，或者无盘工作站等环境非常有用。</p>]]></content>
    
    
    <summary type="html">《趣谈网络协议》</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C10K问题</title>
    <link href="https://penge666.github.io/posts/578383f4.html"/>
    <id>https://penge666.github.io/posts/578383f4.html</id>
    <published>2024-05-21T13:02:39.000Z</published>
    <updated>2024-05-21T13:14:27.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C10K问题">1 C10K问题</h2><p>大家都知道互联网的基础就是网络通信，早期的互联网可以说是一个小群体的集合。互联网还不够普及，用户也不多。一台服务器同时在线100个用户估计在当时已经算是大型应用了。所以并不存在什么C10K的难题。互联网的爆发期应该是在www网站，浏览器，雅虎出现后。最早的互联网称之为Web1.0，互联网大部分的使用场景是下载一个Html页面，用户在浏览器中查看网页上的信息。这个时期也不存在C10K问题。</p><p>Web2.0时代到来后就不同了，一方面是普及率大大提高了，用户群体几何倍增长。另一方面是互联网不再是单纯的浏览万维网网页，逐渐开始进行交互，而且应用程序的逻辑也变的更复杂，从简单的表单提交，到即时通信和在线实时互动。C10K的问题才体现出来了。每一个用户都必须与服务器保持TCP连接才能进行实时的数据交。Facebook这样的网站同一时间的并发TCP连接可能会过亿。</p><blockquote><p>腾讯QQ也是有C10K问题的，只不过他们是用了UDP这种原始的包交换协议来实现的，绕开了这个难题。当然过程肯定是痛苦的。如果当时有epoll技术，他们肯定会用TCP。后来的手机QQ，微信都采用TCP协议。</p></blockquote><p>这时候问题就来了，最初的服务器都是基于进程/线程模型的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，那么操作系统是无法承受的。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook，Google，雅虎才有财力购买如此多的服务器。这就是C10K问题的本质。</p><blockquote><p>实际上当时也有异步模式，如：select/poll模型，这些技术都有一定的缺点，如selelct最大不能超过1024，poll没有限制，但每次收到数据需要遍历每一个连接查看哪个连接有数据请求。</p></blockquote><p><strong>C10K 问题</strong>：如何在一台物理机上同时服务 10000 个用户。这里 C 表示并发，10K 等于 10000。</p><p>注意这里的并发连接和每秒请求数不同，虽然它们是相似的：</p><p>每秒处理许多请求需要很高的吞吐量（快速处理它们），但是更大的数量并发连接需要高效的连接调度。</p><p>C10K 问题是一个优化网络套接字以同时处理大量客户端连接的问题。</p><p>解决这一问题，主要思路有两个：<code>一个是对于每个连接处理分配一个独立的进程/线程；另一个思路是用同一进程/线程来同时处理若干连接</code>。</p><h2 id="2-解决方案">2 解决方案</h2><p>解决这一问题，主要思路有两个：<code>一个是对于每个连接处理分配一个独立的进程/线程；另一个思路是用同一进程/线程来同时处理若干连接</code>。</p><h3 id="2-1-每个进程-线程处理一个连接">2.1 每个进程/线程处理一个连接</h3><p>这一思路最为直接。但是由于申请进程/线程会占用相当可观的系统资源，同时对于多进程/线程的管理会对系统造成压力，因此这种方案不具备良好的可扩展性。</p><p>因此，这一思路在服务器资源还没有富裕到足够程度的时候，是不可行的；即便资源足够富裕，效率也不够高。</p><p><strong><code>问题：资源占用过多，可扩展性差。</code></strong></p><h3 id="2-1-每个进程-线程处理一个连接-2">2.1 每个进程/线程处理一个连接</h3><p>这一思路最为直接。但是由于申请进程/线程会占用相当可观的系统资源，同时对于多进程/线程的管理会对系统造成压力，因此这种方案不具备良好的可扩展性。</p><p>因此，这一思路在服务器资源还没有富裕到足够程度的时候，是不可行的；即便资源足够富裕，效率也不够高。</p><p><strong><code>问题：资源占用过多，可扩展性差。</code></strong></p><h3 id="2-2-每个进程-线程同时处理多个连接（IO多路复用）">2.2 每个进程/线程同时处理多个连接（IO多路复用）</h3><ol><li><strong>传统思路</strong> <code>最简单的方法是循环挨个处理各个连接，每个连接对应一个 socket</code>，当所有 socket 都有数据的时候，这种方法是可行的。 但是当应用读取某个 socket 的文件数据不 ready 的时候，<code>整个应用会阻塞在这里等待该文件句柄</code>，即使别的文件句柄 ready，也无法往下处理。 思路：直接循环处理多个连接。 问题：任一文件句柄的不成功会阻塞住整个应用。</li><li><strong>select</strong> 要解决上面阻塞的问题，思路很简单，如果我在读取文件句柄之前，<code>先查下它的状态，ready 了就进行处理，不 ready 就不进行处理</code>，这不就解决了这个问题了嘛？ 于是有了 select 方案。<code>用一个 fd_set 结构体来告诉内核同时监控多个文件句柄，当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回</code>。之后应用可以<code>使用 FD_ISSET 来逐个查看是哪个文件句柄的状态发生了变化</code>。 这样做，<code>小规模的连接问题不大，但当连接数很多（文件句柄个数很多）的时候，逐个检查状态就很慢了</code>。因此，<code>select 往往存在管理的句柄上限（FD_SETSIZE）</code>。同时，<code>在使用上，因为只有一个字段记录关注和发生事件，每次调用之前要重新初始化 fd_set 结构体</code>。 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 思路：有连接请求抵达了再检查处理。 问题：句柄上限+重复初始化+逐个排查所有文件句柄状态效率不高。</li><li><strong>poll</strong> poll 主要解决 select 的前两个问题：<code>通过一个 pollfd 数组向内核传递需要关注的事件消除文件句柄上限</code>，同时<code>使用不同字段分别标注关注事件和发生事件，来避免重复初始化</code>。 int poll(struct pollfd *fds, nfds_t nfds, int timeout); 思路：设计新的数据结构提供使用效率。 问题：逐个排查所有文件句柄状态效率不高。</li><li><strong>epoll</strong> 既然逐个排查所有文件句柄状态效率不高，很自然的，<code>如果调用返回的时候只给应用提供发生了状态变化（很可能是数据 ready）的文件句柄</code>，进行排查的效率不就高多了么。 epoll 采用了这种设计，适用于大规模的应用场景。 实验表明，<code>当文件句柄数目超过 10 之后，epoll 性能将优于 select 和 poll；当文件句柄数目达到 10K 的时候，epoll 已经超过 select 和 poll 两个数量级</code>。 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 思路：只返回状态变化的文件句柄。 问题：依赖特定平台（Linux）。 因为Linux是互联网企业中使用率最高的操作系统，<code>Epoll就成为C10K killer、高并发、高性能、异步非阻塞这些技术的代名词了</code>。FreeBSD推出了kqueue，Linux推出了epoll，Windows推出了IOCP，Solaris推出了/dev/poll。<code>这些操作系统提供的功能就是为了解决C10K问题</code>。<code>epoll技术的编程模型就是异步非阻塞回调</code>，也可以叫做Reactor，事件驱动，事件轮循（EventLoop）。Nginx，libevent，node.js这些就是Epoll时代的产物。</li><li><strong>libevent</strong> 由于epoll, kqueue, IOCP每个接口都有自己的特点，程序移植非常困难，于是需要对这些接口进行封装，以让它们易于使用和移植，其中libevent库就是其中之一。跨平台，封装底层平台的调用，提供统一的 API，但底层在不同平台上自动选择合适的调用。 按照libevent的官方网站，libevent库提供了以下功能：<code>当一个文件描述符的特定事件（如可读，可写或出错）发生了，或一个定时事件发生了，libevent就会自动执行用户指定的回调函数，来处理事件</code>。目前，libevent已支持以下接口/dev/poll, kqueue, event ports, select, poll 和 epoll。<code>Libevent的内部事件机制完全是基于所使用的接口的</code>。因此libevent非常容易移植，也使它的扩展性非常容易。目前，libevent已在以下操作系统中编译通过：Linux，BSD，Mac OS X，Solaris和Windows。 使用libevent库进行开发非常简单，也很容易在各种unix平台上移植。一个简单的使用libevent库的程序如下：</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240521211111250.png" alt="image-20240521211111250"></p><h2 id="3-协程（coroutine）">3 协程（coroutine）</h2><p>随着技术的演进，epoll 已经可以较好的处理 C10K 问题，但是如果要进一步的扩展，例如支持 10M 规模的并发连接，原有的技术就无能为力了。</p><p>那么，新的瓶颈在哪里呢？</p><p>从前面的演化过程中，我们可以看到，<code>根本的思路是要高效的去阻塞，让 CPU 可以干核心的任务</code>。<strong>所以，千万级并发实现的秘密：内核不是解决方案，而是问题所在！</strong></p><p><strong>这意味着：</strong></p><blockquote><p>不要让内核执行所有繁重的任务。将数据包处理，内存管理，处理器调度等任务从内核转移到应用程序高效地完成。让Linux只处理控制层，数据层完全交给应用程序来处理。</p></blockquote><p><code>当连接很多时，首先需要大量的进程/线程来做事</code>。同时系统中的应用进程/线程们可能大量的都处于 ready 状态，<code>需要系统去不断的进行快速切换</code>，而我们知道<code>系统上下文的切换是有代价的</code>。虽然现在 Linux 系统的调度算法已经设计的很高效了，但对于 10M 这样大规模的场景仍然力有不足。</p><p>所以我们面临的瓶颈有两个，<code>一个是进程/线程作为处理单元还是太厚重了；另一个是系统调度的代价太高了</code>。</p><p>很自然地，我们会想到，<strong><code>如果有一种更轻量级的进程/线程作为处理单元，而且它们的调度可以做到很快（最好不需要锁）</code></strong>，那就完美了。</p><p>这样的技术现在在某些语言中已经有了一些实现，<code>它们就是 coroutine（协程），或协作式例程</code>。具体的，<code>Python、Lua 语言中的 coroutine（协程）模型，Go 语言中的 goroutine（Go 程）模型，都是类似的一个概念</code>。实际上，多种语言（甚至 C 语言）都可以实现类似的模型。</p><p>它们在实现上都是<code>试图用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换</code>。<code>每个协程所独占的系统资源往往只有栈部分</code>。而且，<code>各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种 callback 类似）</code>，不需要内核参与，可以很方便的实现异步。</p><p>这个技术本质上也是<code>异步非阻塞技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环</code>。程序员就像写阻塞代码一样简单。比如调用 client-&gt;recv() 等待接收数据时，就像阻塞代码一样写。<code>实际上是底层库在执行recv时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行。</code></p><p>这就是协程的本质。<code>协程是异步非阻塞的另外一种展现形式</code>。Golang，Erlang，Lua协程都是这个模型。</p><h3 id="3-1-同步阻塞">3.1 同步阻塞</h3><p>不知道大家看完协程是否感觉得到，<code>实际上协程和同步阻塞是一样的</code>。答案是的。<code>所以协程也叫做用户态进/用户态线程</code>。区别就在于<code>进程/线程是操作系统充当了EventLoop调度，而协程是自己用Epoll进行调度</code>。</p><p>协程的优点是它比系统线程开销小，缺点是如果其中一个协程中有密集计算，其他的协程就不运行了。操作系统进程的缺点是开销大，优点是无论代码怎么写，所有进程都可以并发运行。</p><blockquote><p><code>Erlang解决了协程密集计算的问题，它基于自行开发VM，并不执行机器码</code>。即使存在密集计算的场景，<code>VM发现某个协程执行时间过长，也可以进行中止切换</code>。Golang由于是直接执行机器码的，所以无法解决此问题。<code>所以Golang要求用户必须在密集计算的代码中，自行Yield</code>。</p></blockquote><p>实际上同步阻塞程序的性能并不差，它的效率很高，不会浪费资源。当进程发生阻塞后，操作系统会将它挂起，不会分配CPU。直到数据到达才会分配CPU。多进程只是开多了之后副作用太大，<code>因为进程多了互相切换有开销</code>。所以<code>如果一个服务器程序只有1000左右的并发连接，同步阻塞模式是最好的</code>。</p><h3 id="3-2-异步回调和协程哪个性能好">3.2 异步回调和协程哪个性能好</h3><p><code>协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换</code>。所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。<code>而异步回调是没有切换开销的，它等同于顺序执行代码</code>。所以异步回调程序的性能是要优于协程模型的。</p>]]></content>
    
    
    <summary type="html">《浅析C10K问题》</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>RPC实战与核心原理</title>
    <link href="https://penge666.github.io/posts/11ab60d3.html"/>
    <id>https://penge666.github.io/posts/11ab60d3.html</id>
    <published>2024-05-20T03:38:46.000Z</published>
    <updated>2024-05-20T03:40:07.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《RPC实战与核心原理》">《RPC实战与核心原理》</h2><h3 id="开篇">开篇</h3><p><strong>为什么要学习RPC？</strong></p><blockquote><p>RPC是解决分布式系统通信问题的一大利器。 RPC对网络通信的整个过程做了完整包装，在搭建分布式系统时，它会使网络通信逻辑的开发变得更加简单，同时也会让网络通信变得更加安全可靠。</p></blockquote><p><strong>如何学习RPC？</strong></p><p>学习是一个通过不断解决问题来提升能力的过程，学习RPC可以采取“逐步深入”的方法： 1. 摆脱现有封装好的框架，了解RPC基本原理以及关键的网络通信过程。 2. 了解RPC框架中的治理功能以及集群管理功能。 3. 对RPC活学活用，学习如何提升RPC性能以及在分布式环境下如何定位解决问题。</p><h3 id="01-核心原理：能否画张图解释下RPC的通信流程">01|核心原理：能否画张图解释下RPC的通信流程</h3><p>这一讲的标题就是一道很好的面试题呀。</p><p>我们平时工作中，可以熟练使用各种框架，但是，我们也需要掌握框架背后的基本原理。</p><p><strong>什么是RPC？</strong></p><blockquote><p>RPC的全称是Remote Procedure Call，即远程过程调用。它帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地方法一样的体验，我们不需要因为这个方法是远程调用而需要编写很多与业务无关的代码。</p></blockquote><p>RPC框架一般采用TCP作为数据传输协议。</p><p>RPC中的网络传输，会涉及到数据的序列化和反序列化。</p><p><strong>RPC如何实现调用远程方法像调用本地方法一样的体验？</strong></p><blockquote><p>服务提供者给出业务接口声明，在调用方的程序里面，RPC框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到了声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候，就获得了像调用本地接口一样的体验。</p></blockquote><p><strong>RPC通信基本流程图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100006538.png" alt="image-20240520100006538"></p><p><strong>RPC在现代应用架构中的位置是怎样的？</strong></p><blockquote><p>RPC是解决应用间通信的一种方式，无论是在一个大型的分布式应用系统中，还是在中小型系统中，应用架构都会沿着单体-&gt;微服务化的方向演进，这样，整个应用会被拆分成多个不同功能的应用或者服务，这些细粒度的应用或者服务可能会部署到多台服务器中，它们之间的通信，就会通过RPC进行，所以，我们可以说，RPC对应的是整个分布式应用系统，就像是“经络”一样的存在。</p></blockquote><h3 id="02-协议：怎么设计可扩展且向后兼容的协议？">02 | 协议：怎么设计可扩展且向后兼容的协议？</h3><p><strong>我们为什么需要使用协议？</strong></p><blockquote><p>在网络通信的过程中，为了避免语义不一致的情况，我们需要在发送请求时设定一个边界，然后再收到请求时按照设定的边界对请求数据进行分割。这里的边界语义的表达，就是我们所说的协议。</p></blockquote><p><strong>为什么我们在RPC中不使用HTTP作为主要协议？</strong></p><blockquote><p>RPC负责应用间通信，对性能要求高，但HTTP协议的数据包大小相对请求数据来说，要大很多，包含了很多额外字符，例如换行、回车等。<br>HTTP协议属于无状态协议，客户端无法对请求和响应进行关联，不能很好地进行异步处理。</p></blockquote><p>我们在设计协议时，一般会把协议分成两部分：</p><ol><li>协议头，由一堆固定长度的参数组成。</li><li>协议体，根据请求接口和参数构造，长度可变。</li></ol><p><strong>什么是定长协议？</strong></p><p>定长协议是指协议头长度固定。协议头示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100618073.png" alt="image-20240520100618073"></p><p><strong>定长协议有什么缺点？</strong></p><blockquote><p>定长协议的协议头不能添加新参数，否则就会产生兼容性问题。例如我们设计了一个 88Bit 的协议头，其中协议长度占用32bit，然后为了加入新功能，在协议头里面加了2bit，并且放到协议头的最后。升级后的应用，会用新的协议发出请求，然而没有升级的应用收到的请求后，还是按照88bit 读取协议头，新加的2个bit会当作协议体前2个bit数据读出来，但原本的协议体最后2个bit会被丢弃了，这样就会导致协议体的数据是错的。</p></blockquote><p><strong>如何设计一个可扩展的协议？</strong></p><p>我们需要让协议头支持可扩展，扩展后协议头的长度就不能定长了。这样整个协议变成了三部分：固定部分、协议头内容、协议体内容。<br>可扩展协议的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100638612.png" alt="image-20240520100638612"></p><p>设计一个简单的RPC协议不难，难的地方在于怎么设计一个可“升级”的协议，不仅要让我们在扩展新特性的时候能够做到向下兼容，而且要尽可能地减少资源损耗。</p><p><strong>协议头的具体内容是什么？</strong></p><ul><li>Bit Offset：标识协议的起始位置。</li><li>魔术位：标识是什么协议。</li><li>整体长度：标识整个协议有多长，它减去头长度就是协议体长度</li><li>头长度：协议头的长度，因为协议头长度不固定，所以需要标识。</li><li>协议版本：标识协议的版本，主要用于兼容性控制。</li><li>消息类型：标识消息的类型，可能是文本、XML、JSON等。</li><li>序列化方式：标识用来做序列化和反序列化的方式。</li><li>消息ID：用于标识请求和响应的关系。</li><li>协议头扩展字段：用于扩展协议头，这样使得协议具有可扩展性，更加灵活。</li><li>协议体：协议的具体内容，二进制格式。</li></ul><h3 id="03-序列化：对象怎么在网络中传输？"><strong>03 | 序列化：对象怎么在网络中传输？</strong></h3><p><strong>什么是“序列化”和“反序列化”？</strong></p><blockquote><p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是不能直接在网络中传输，所以我们需要提前把它转变成可传输的二进制，并且要求转换算法是可逆的，这个过程称为“序列化”。<br>根据请求类型和序列化类型，服务提供方将请求传来的二进制数据还原成请求对象，这个过程称为“反序列化”。</p></blockquote><p>序列化就是将对象转换成二进制数据的过程，而反序列化就是把二进制数据转换成对象的过程。</p><p><strong>有哪些常用的序列化方式？</strong></p><ul><li>JDK原生序列化</li><li>JSON</li><li>Hessian</li><li>Protobuf</li><li>Protostuff</li><li>Thrift</li><li>Avro</li></ul><p>任何一种序列化框架，核心思想就是设计一种序列化协议，将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个对象，来完成反序列化。</p><p><strong>JSON进行序列化存在哪些问题？</strong></p><ol><li>JSON额外空间开销比较大，对于大数据量服务意味着巨大的内存和磁盘开销。</li><li>JSON没有类型，但Java属于强类型语言，这需要通过反射来解决类型问题，所以会影响性能，这样就要求服务提供者和调用者之间传输的数据量要小。</li></ol><p><strong>Hessian有什么缺点？</strong></p><p>Hessian不支持Java一些常见类型，例如：</p><ol><li>Linked系列</li><li>Locale类</li><li>Byte/Short在反序列化时会变成Integer</li></ol><p><strong>如何选择合适的序列化框架？</strong></p><p>对于服务提供者来说，服务的可靠性要比性能更重要，因此，我们在选择序列化框架时，更关注协议在版本升级后的兼容性是否很好、是否支持更多的对象类型、是否跨平台、跨语言、是否有很多人已经用过并且踩过坑了，其次，我们才会考虑性能、效率和空间开销。<br>另外序列化协议的安全也是需要考虑的一个重要因素。<br>综合考虑，当我们选择序列化协议时，考虑因素如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520100802335.png" alt="image-20240520100802335"></p><p><strong>RPC框架在使用序列化协议时有哪些注意事项？</strong></p><ol><li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚。</li><li>入参对象与返回值对象体积不要太大，更不要传太大的集合。</li><li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类。</li><li>对象不要有复杂的继承关系，最好不要有父子类的情况。</li></ol><h3 id="04-网络通信：RPC框架在网络通信上更倾向于哪种网络IO模型？">04 | 网络通信：RPC框架在网络通信上更倾向于哪种网络IO模型？</h3><p><strong>网络通信在RPC调用中有什么作用？</strong></p><blockquote><p>RPC是解决进程间通信的一种方式，一次RPC调用，本质就是服务消费者与服务提供者之间的一次网络信息交换的过程。服务调用者通过网络IO发送一条请求消息，服务提供者接收并解析，处理完相关的业务逻辑之后，再发送一条响应消息给服务调用者，服务调用者接收并解析响应消息，处理完相关的响应逻辑，一次RPC调用便结束了。我们可以说，网络通信是整个RPC调用流程的基础。</p></blockquote><p><strong>有哪些常见的网络IO模型？</strong></p><blockquote><p>常见的网络IO模型分为四种：同步阻塞IO（BIO）、同步非阻塞IO（NIO）、IO多路复用和异步非阻塞IO（AIO）。其中AIO是异步IO，其他三种都是同步IO。<br>最常用的IO模型是同步阻塞IO和IO多路复用。</p></blockquote><p><strong>阻塞IO的工作流程是怎样的？</strong></p><blockquote><p>应用进程发起IO系统调用后，应用进程被阻塞，转到内核空间处理。内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中，整个IO处理完毕后返回进程。最后应用进程解除阻塞状态，运行业务逻辑。<br>系统内核在处理IO操作时，主要分为两个阶段：等待数据和拷贝数据。在此期间，应用进程中进行IO操作的线程一直会处于阻塞状态。</p></blockquote><p><strong>什么是IO多路复用？</strong></p><blockquote><p>多路就是指多个通道，也就是多个网络连接的IO，复用指多个通道复用在一个复用器上。 多个网络连接的IO可以注册到一个复用器（select）上，当用户进程调用了select，整个进程会被阻塞，同时，内核会监视所有socket负责的socket，当任何一个socket中的数据准备好了，select就会返回。这时用户进程再调用read操作，将数据从内核中拷贝到用户进程。<br>IO多路复用的优势在于用户可以在一个线程内同时处理多个socket的IO请求，用户可以注册多个socket，然后不断地调用select读取被激活的socket，这样可以达到在同一个线程内同时处理多个IO请求的目的。</p></blockquote><p><strong>有哪些常见的框架或者工具会使用IO多路复用？</strong></p><blockquote><p>Java中的NIO、Redis、Nginx、Reactor模式等。</p></blockquote><p>在高性能的网络编程框架的编写上，大多数都是基于Reactor模式做的，其中的典型就是Java的Netty框架。</p><p><strong>RPC调用在大多数情况下，是一个高并发调用的场景，考虑到系统内核的支持、编程语言的支持以及IO模型本身的特点，在RPC框架的实现中，我们选择IO多路复用作为网络通信采用的IO模型。</strong></p><p><strong>什么是“零拷贝”？</strong></p><p>在没有零拷贝之前，应用进程的每一次写操作，都会把数据写到用户空间的缓冲区内，再由CPU将数据拷贝到系统内核的缓冲区中，之后再由DMA将这份数据拷贝到网卡中，最后由网卡发送出去，这样一次写操作数据需要拷贝两次，而数据读操作也是类似的流程。 应用进程的一次完整的写操作，都需要在用户空间和内核空间中来回拷贝，并且每一次拷贝，都需要CPU进行一次上下文切换。<br>网络数据读写操作示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520101053670.png" alt="image-20240520101053670"></p><p>所谓零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，之后再通过DMA将内核中的数据拷贝到网卡，或者将网卡中的数据拷贝到内核。<br>零拷贝的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520101200527.png" alt="image-20240520101200527"></p><p><strong>零拷贝有哪些实现方式？</strong></p><blockquote><p>零拷贝有两种方式：</p><ol><li><p>mmmap+write</p></li><li><p>sendfile</p></li></ol></blockquote><h3 id="05-动态代理：面向接口编程，屏蔽RPC处理流程">05 | 动态代理：面向接口编程，屏蔽RPC处理流程</h3><p>在Java中，动态代理是一种设计模式，它允许开发者在运行时创造和使用代理对象。这个代理对象可以用来拦截对其他对象的方法调用，添加额外的处理，然后将调用转发给实际的对象。这种机制在很多场景下都非常有用，例如添加日志、权限检查、事务处理等。</p><p><strong>RPC和动态代理有什么关系？</strong></p><blockquote><p>当我们使用RPC时，我们一般会先找到服务提供方要接口，然后将接口依赖配置到项目中，我们在编写业务逻辑时，当需要调用提供方接口时，我们只需要通过依赖注入的方式把接口注入到项目中，然后再代码里面直接调用接口的方法。 但是我们的代码中，接口并没有包含真实的业务逻辑，相关的业务逻辑代码是在服务提供方应用汇总，但是我们只是调用了接口方法，就正常执行了业务逻辑，这是就是动态代理帮助我们实现的。 总的来说，RPC会自动给接口生成一个代理类，当我们在项目中注入接口时，运行过程中实际绑定的是这个接口生成的代理类，这样接口方法被调用的时候，它实际上是被代理类拦截到了，这样我们就可以在代理类中，加入远程调用逻辑。</p></blockquote><p><strong>在Java中，有哪些技术可以实现动态代理？</strong></p><ul><li>JDK提供的InvocationHandler</li><li>Javassist</li><li>Byte Buddy</li></ul><p>上述三个工具的区别在于通过什么方式生成代理类以及在生成的代理类中怎么完成方法调用。</p><p><strong>动态代理技术选型需要考虑什么因素？</strong></p><ul><li>生成代理类的速度、字节码大小。</li><li>生成的代理类的执行效率。</li><li>是否易用，API设计是否好理解、社区活跃度、依赖复杂度。</li></ul><p><strong>如果没有动态代理帮我们完成方法调用拦截，我们应该怎样完成RPC调用？</strong></p><p>如果没有动态代理，那么我们需要使用静态代理来实现，需要对原始类中所有的方法都实现一遍，并且为每个方法附加相似的代码逻辑。</p><h3 id="06-RPC实战：剖析gRPC源码，动手实现一个完整的RPC">06 | RPC实战：剖析gRPC源码，动手实现一个完整的RPC</h3><p>我们通过动态代理技术，屏蔽RPC调用的细节，从而让使用者能够面向接口编程。</p><p><strong>什么是gRPC？</strong></p><blockquote><p>gRPC是由Google开发并且开源的一款高性能、跨语言的RPC框架，当前支持C、Java和Go语言，当前Java版本最新Release版是1.51.3。</p></blockquote><p><strong>什么是protobuf？</strong></p><blockquote><p>protocol buffers是一种语言无关、平台无关、可扩展的序列化结构数据方法，可用于通信协议、数据存储等。 我们可以定义数据结构，然后使用特殊生成的源代码在各种数据流中使用各种语言进行编写和读取数据结构，也可以更新数据结构。</p></blockquote><p>protobuf的三大特点：</p><ol><li><p>语言无关，平台无关</p></li><li><p>灵活、高效</p></li><li><p>扩展性、兼容性好</p></li></ol><p>下面我们来看一下如何使用gRPC。</p><p>首先我们需要安装protobuf，如果你使用Mac电脑，那么可以运行下面的命令来安装protobuf。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><p>执行成功后，可以运行下面的命令来查看相关版本信息。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.21.9</span><br></pre></td></tr></table></figure><p>然后我们来创建下面的proto文件hello.proto。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_generic_services = true;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;</span><br><span class="line"></span><br><span class="line">// The greeting service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The request message containing the user&#x27;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用下面的命令来自动生成Java代码文件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc ./hello.proto --java_out=./</span><br></pre></td></tr></table></figure><p>命令执行完成后，会在当前目录下，生成代码文件，对应的目录结构如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tree .</span><br><span class="line">.</span><br><span class="line">├── hello.proto</span><br><span class="line">└── io</span><br><span class="line">    └── grpc</span><br><span class="line">        └── examples</span><br><span class="line">            └── helloworld</span><br><span class="line">                ├── Greeter.java</span><br><span class="line">                ├── Hello.java</span><br><span class="line">                ├── HelloReply.java</span><br><span class="line">                ├── HelloReplyOrBuilder.java</span><br><span class="line">                ├── HelloRequest.java</span><br><span class="line">                └── HelloRequestOrBuilder.java</span><br></pre></td></tr></table></figure><p>上面就完成了proto文件转换的过程。</p><p>接下来，我们看怎么在Java工程中完整的使用gRPC。</p><p>我们创建一个空的Maven工程，在pom.xml中引用必要的依赖以及protobuf Maven插件， 完整的pom.xml内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;sample.grpc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;grpc-sample&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;grpc.version&gt;1.52.1&lt;/grpc.version&gt;</span><br><span class="line">        &lt;protobuf.version&gt;3.21.9&lt;/protobuf.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.29.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.29.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.29.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;annotations-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.0.53&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;extensions&gt;</span><br><span class="line">            &lt;extension&gt;</span><br><span class="line">                &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">            &lt;/extension&gt;</span><br><span class="line">        &lt;/extensions&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;0.6.1&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;protocArtifact&gt;com.google.protobuf:protoc:3.11.0:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">                    &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">                    &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.29.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>然后将上面的hello.proto文件复制到src/main/proto目录下面创建hello.proto目录下， 这个目录是固定的。</p><p>pom.xml文件准备好以后，我们来运行下面的工程编译命令。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven compile</span><br></pre></td></tr></table></figure><p>编译结束后，会在target/generated-sources目录下维护自动生成的代码，目录结构如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree target/generated-sources</span><br><span class="line">target/generated-sources</span><br><span class="line">└── protobuf</span><br><span class="line">    ├── grpc-java</span><br><span class="line">    │   └── io</span><br><span class="line">    │       └── grpc</span><br><span class="line">    │           └── examples</span><br><span class="line">    │               └── helloworld</span><br><span class="line">    │                   └── GreeterGrpc.java</span><br><span class="line">    └── java</span><br><span class="line">        └── io</span><br><span class="line">            └── grpc</span><br><span class="line">                └── examples</span><br><span class="line">                    └── helloworld</span><br><span class="line">                        ├── Greeter.java</span><br><span class="line">                        ├── Hello.java</span><br><span class="line">                        ├── HelloReply.java</span><br><span class="line">                        ├── HelloReplyOrBuilder.java</span><br><span class="line">                        ├── HelloRequest.java</span><br><span class="line">                        └── HelloRequestOrBuilder.java</span><br><span class="line"></span><br><span class="line">11 directories, 7 files</span><br></pre></td></tr></table></figure><p>接下来，我们来编写服务器端，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.grpc.examples.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">                System.err.println(<span class="string">&quot;*** shutting down gRPC server since JVM is shutting down&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    HelloWorldServer.<span class="built_in">this</span>.stop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace(System.err);</span><br><span class="line">                &#125;</span><br><span class="line">                System.err.println(<span class="string">&quot;*** server shut down&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            server.shutdown().awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Await termination on the main thread since the grpc library uses daemon threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main launches the server from the command line.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">HelloWorldServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GreeterImpl</span> <span class="keyword">extends</span> <span class="title class_">GreeterGrpc</span>.GreeterImplBase &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">            <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder().setMessage(<span class="string">&quot;Hello &quot;</span> + req.getName()).build();</span><br><span class="line">            System.out.println(<span class="string">&quot;=====server=====&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;server: Hello &quot;</span> + req.getName());</span><br><span class="line">            responseObserver.onNext(reply);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完成后，直接运行，这样会启动一个Server，端口是50051。</p><p>最后，我们来编写客户端，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.grpc.examples.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Channel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.StatusRuntimeException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Construct client for accessing HelloWorld server using the existing channel. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorldClient</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Say hello to server. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">        HelloReply response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = blockingStub.sayHello(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Greeting: &quot;</span> + response.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;hahahahaha&quot;</span>;</span><br><span class="line">        <span class="comment">// Access a service running on the local machine on port 50051</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;localhost:50051&quot;</span>;</span><br><span class="line">        <span class="comment">// Allow passing in the user and target strings as command line arguments</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;--help&quot;</span>.equals(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Usage: [name [target]]&quot;</span>);</span><br><span class="line">                System.err.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.err.println(<span class="string">&quot;  name    The name you wish to be greeted by. Defaults to &quot;</span> + user);</span><br><span class="line">                System.err.println(<span class="string">&quot;  target  The server to connect to. Defaults to &quot;</span> + target);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            user = args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            target = args[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ManagedChannelBuilder.forTarget(target)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HelloWorldClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldClient</span>(channel);</span><br><span class="line">            client.greet(user);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            channel.shutdownNow().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们多次运行客户端程序后，我们可以在服务器端的控制台上，看到如下输出。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====server=====</span><br><span class="line">server: Hello hahahahah</span><br><span class="line">=====server=====</span><br><span class="line">server: Hello hahahahah</span><br><span class="line">=====server=====</span><br><span class="line">server: Hello hahahahah</span><br></pre></td></tr></table></figure><h3 id="07-架构设计：设计一个灵活的RPC框架">07 | 架构设计：设计一个灵活的RPC框架</h3><p>RPC就是把拦截到的方法参数，转成可以在网络中传输的二进制，并保证在服务提供方能正确地还原出语义，最终实现像调用本地一样地调用远程的目的。</p><p>RPC的本质是一个远程调用，需要通过网络来传输数据，我们一般采用TCP协议作为数据通信协议，为了屏蔽网络传输的复杂性，我们需要封装一个独立的数据传输模块来收发二进制数据，这个模块被称为<strong>传输模块</strong>。</p><p>我们在调用方法时，方法的出入参数都是对象数据，我们需要将对象转换成二进制，即进行序列化操作，同时，我们还需要在方法调用参数的二进制数据后面增加“断句”符号来分隔出不同的请求，这个过程被称为<strong>协议封装</strong>。</p><p>传输模块和协议封装都是为了保证数据在网络中可以正确传输，我们将这两个模块放在一起，称为<strong>协议模块</strong>。</p><p>我们还可以在协议模块中添加压缩功能，在方法调用参数或者返回值的二进制数据大于某个阈值时，我们使用压缩框架对数据进行无损压缩，然后再另外一段使用同样的压缩机制进行解压处理，保证数据可以还原。</p><p>传输模块和协议模块是RPC中最基础的功能，它们使得对象可以正确的传输到服务提供方。但是为了让这两个模块可以同时工作，我们还需要手写一些粘合代码，这些代码对于RPC框架的使用者来说是没有意义的，属于重复工作，我们将这些事情进行封装处理，形成RPC调用的入口，一般称为<strong>Bootstrap模块</strong>。</p><p><strong>什么是”服务发现“？</strong></p><blockquote><p>针对同一个接口有多个服务提供者，但这多个服务提供者对于我们的调用方来说是透明的，所以在RPC里面我们还需要给调用方找到所有的服务提供方，并需要在RPC里面维护好借口和服务提供者地址间的关系，这样调用方在发起请求时才能快速找到对应的接收地址。</p></blockquote><p>一个划分为四层的RPC基础架构的示意图如下。</p><p>上面的框架有什么问题吗？最主要的问题就是扩展性不高，当我们有需求变更时，很容易需要大范围调整框架。</p><p>我们可以尝试使用<strong>插件化架构</strong>的方法论来优化我们的RPC架构。</p><p><strong>我们怎么在RPC框架里面支持插件化架构？</strong></p><blockquote><p>我们可以将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的借口与功能的实现分离，并提供接口的默认实现。</p></blockquote><p>加入插件功能后，RPC框架就包含了两大核心体系：<strong>核心功能体系</strong>和<strong>插件体系</strong>，示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520101947432.png" alt="image-20240520101947432"></p><h3 id="08-服务发现：到底是要CP还是AP？">08 | 服务发现：到底是要CP还是AP？</h3><p><strong>我们为什么需要“服务发现”？</strong></p><blockquote><p>从高可用的角度出发，在生产环境中，服务提供方通常会以集群的方式对外提供服务，集群中的IP地址随时可能发生变化，因此我们需要一本“通讯录”来及时获取对应的服务节点信息，维护“通讯录”以及或者节点信息的过程，我们称之为“服务发现”。</p></blockquote><p>服务发现包括2个核心模块：</p><ul><li>服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心中，注册中心将这个服务节点的IP和接口保存下来。</li><li>服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的IP，然后缓存到本地，并用于后续远程调用。</li></ul><p><strong>我们为什么不采用基于DNS的服务发现机制？</strong></p><p>我们来看一下DNS查询流程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103411280.png" alt="image-20240520103411280"></p><p>它存在的两个主要问题：</p><ol><li>如果服务节点的IP端口下线了，服务调用者能否及时摘除服务节点？</li><li>如果之前已经上线了一部分服务节点，这时突然对这个服务进行扩容，那么新上线的服务节点能否及时接收到流程呢？</li></ol><p><strong>为什么VIP方案也不能用于服务发现？</strong> VIP方案如下所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103437431.png" alt="image-20240520103437431"></p><p>它主要有以下几个问题：</p><ul><li>搭建负载均衡设备或者TCP/IP四层代理，需要额外成本。</li><li>请求流程都经过负载均衡设备，多经过一次网络传输，会额外浪费性能。</li><li>负载均衡添加节点和摘除节点，一般都需要手动添加，当大批量扩容和下线时，会有大量的人工操作和生效延迟。</li><li>不能支持更灵活的负载均衡策略。</li></ul><p><strong>基于ZooKeeper的服务发现机制的工作流程是怎样的？</strong> 基于ZooKeeper的服务发现结构图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103453805.png" alt="image-20240520103453805"></p><p>它的工作流程如下：</p><ol><li>服务平台管理端现在ZooKeeper中创建一个服务根路径，在这个路径下面再创建服务提供方目录和服务调用方目录。</li><li>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</li><li>当服务调用方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</li><li>当服务提供方目录下有节点数据发生变更时，ZooKeeper就会通知给发起订阅的服务调用方。</li></ol><p><strong>基于ZooKeeper的服务发现有什么问题？</strong></p><p>当有超大批量的服务节点在同时发起注册操作，ZooKeeper集群的CPU使用率会飙升，导致ZooKeeper集群无法工作。</p><p>这本身就是ZooKeeper的性能问题，当连接到ZooKeeper的节点数量特别多，对ZooKeeper的读写操作会特别频繁，而且当ZooKeeper存储的目录达到一定数量时，ZooKeeper就会变得不稳定，CPU使用率持续升高，直到宕机。</p><p>ZooKeeper的一大特点就是强一致性，集群中的每个节点的数据每次发生变更操作时，都会通知其他节点同时执行跟新，这样它就要求每个节点的数据能够实时的完全一致，从而导致了ZooKeeper集群性能的下降。</p><p><strong>基于消息总线的服务发现机制的工作流程是怎样的？</strong></p><p>基于消息总线的服务发现流程图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520103501069.png" alt="image-20240520103501069"></p><p>它的工作流程如下：</p><ol><li>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有一个整体递增版本。</li><li>消息总线会主动推送消息到各个注册中心，同时注册中心也会定期拉取消息。对于获取到消息的在消息回放模块里面回放只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。</li><li>消费者定于可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存中。</li><li>采取推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的混存数据进行合并。</li></ol><p>通过消息总线的方式，我们就可以完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作。</p><p><strong>服务发现的特性是允许我们在设计超大规模集群服务发现系统的时候，舍弃一致性，更多的考虑系统的健壮性，因此，在实际工作中，最终一致性是更为常用的策略。</strong></p><h3 id="09-健康监测：这个节点挂了，为啥还要疯狂发请求？">09 | 健康监测：这个节点挂了，为啥还要疯狂发请求？</h3><p>服务调用方在每次调用服务提供方的服务时，RPC框架会根据路由和负载均衡算法选择一个具体的IP地址，为了保证请求成功，我们需要确保每次选择出来的IP对应的连接是健康的。</p><p>调用方和集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏的情况，为了解决这个问题，我们的终极解决方案就是让调用方实时感知到节点的变化。</p><p>业内经常用来检测服务节点是否可用的方法是用心跳机制。心跳机制就是服务调用方每隔一段时间就问一下服务提供方，“兄弟，你还好吗？”，然后服务提供方诚实地告诉调用方它目前的状态。</p><p>服务提供方的状态一般会有三种情况：</p><ol><li>健康状态：建立连接成功，并且心跳探活也一直成功。</li><li>亚健康状态：建立连接成功，但是心跳请求连续失败。</li><li>死亡状态：建立连接失败。</li></ol><p>上述三种状态是可以变转变的。</p><p>一个节点从健康状态过渡到亚健康状态的前提是连续“心跳失次数必须达到某个阈值。</p><p>只关心服务节点网络稳定，会有2个问题：</p><ol><li>调用方每个接口的调用频次不一样，有的接口可能1秒内调用上百次，有的接口可能半个小时才会被调用一次，所以我们不能简单的把失败总次数当做判断条件。</li><li>服务的借口响应时间也不一样，有的接口可能1ms，有的可能是10s，我们不能使用TPS来作为谈判条件。</li></ol><p>我们可以使用”可用率“，它的计算方式是某一个时间窗口内接口调用的成功次数的百分比。当可用率低于某个比例就认为这个节点存在问题，需要把它转移到亚健康列表，这样既考虑了高低频的调用接口，也兼顾了接口响应时间不同的问题。</p><p>我们在部署时，需要注意将检测程序部署到多个机器里面，分布在不同的机架，甚至不同的机房。</p><h3 id="10-路由策略：怎么让请求按照设计的规则发到不同的节点上？">10 | 路由策略：怎么让请求按照设计的规则发到不同的节点上？</h3><p>我们在真实的环境中，服务提供方是以集群的方式对外提供服务，这对于服务调用方来说，就是一个借口会有多个服务提供方同时提供服务，所以RCP在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发送请求。</p><p>当服务在线上运行时，我们如果有变更，会涉及到如何升级，升级过程中可能会影响服务接口，这样会导致系统变的不稳定，甚至系统崩溃，为了减少这种风向，我们一般会选择<strong>灰度发布</strong>的方式来升级我们的服务实例，例如我们可以发布少量实例来观察是否有异常，然后根据观察的结果，来决定是发布更多实例还是回滚到旧版本。</p><p>虽然我们的服务在上线前会有测试的过程，但是因为线上环境太复杂了，测试只能是降低出现风险的概率，想要彻底验证所有场景是不可能的。</p><p>我们可以考虑在上线完成后，先让一小部分调用方请求过来进行逻辑验证，待没有问题后再接入其他调用方，从而实现流量隔离的效果。</p><p>因为注册中心会维护所有服务提供方的信息，所以我们可以在注册中心中来做流量隔离吗？一般不采用这种方式，注册中心在RPC中的定位是用来存储数据并保证数据一致性，如果把复杂的请求隔离的计算逻辑放到注册中心里面，那么当集群节点变多时，会导致注册中心压力过大，而且大部分时候，我们采用开源软件来打架注册中心，要加入其他计算逻辑的话，还需要进行二次开发，所以从实际的角度出发，在注册中心中实现请求隔离是不划算的。</p><p>调用法发起RPC调用的整个流程中，在RPC发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（也就是负载均衡），那么我们可以考虑在这个节点之前，加入一个“筛选逻辑”，把符合我们要求的节点筛选出来。</p><p>这个“筛选过程”，我们称之为“<strong>路由策略</strong>”。</p><p>我们可以设计不同得分路由策略：</p><ol><li><strong>IP路由</strong>*，根据服务调用方的IP地址，来决定哪些服务提供方的实例可以处理相关请求。*</li><li><strong>参数路由</strong>，根据服务调用方发送请求中的参数值，来决定哪些服务提供方的实例可以处理相关请求。</li></ol><p>参数路由是比IP路由更灵活、粒度更细的路由规则，它为服务提供方应用提供了另外一个服务治理的手段。</p><p>灰度发布功能是RPC路由功能的一个典型应用场景，通过RPC的路由策略的组合使用可以让服务提供方更加灵活的管理、调用自己的流量，进一步降低可能导致的风险。</p><p>在RPC里面，不论是哪种路由策略，其核心思想是一样的，就是让请求按照我们设定的规则发送到目标节点上，从而实现流量隔离的效果。</p><h3 id="11-负载均衡：节点负载差距这么大，为什么收到的流量还一样？">11 | 负载均衡：节点负载差距这么大，为什么收到的流量还一样？</h3><p><strong>什么是负载均衡？</strong></p><blockquote><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共通分担请求压力的目的。</p></blockquote><p><strong>负载均衡有哪些类型？</strong></p><blockquote><p>负载均衡分为软负载和硬负载两种，软负载就是在一台或多台服务器上安装负载均衡软件，如LVS、Nginx等；硬负载就是通过硬件设备来实现负载均衡，例如F5服务器等。</p></blockquote><p><strong>有哪些常见的负载均衡算法？</strong> 常见的负载均衡算法包括：</p><ul><li>基于权重的随机算法</li><li>基于最小活跃用数算法</li><li>基于Hash一致性算法</li><li>基于加权轮询算法</li></ul><p>Dubbo默认采用基于权重的随机算法。</p><p>RPC中的负载均衡完全由RPC框架自身实现，RPC的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起RPC调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起RPC调用请求。</p><p>示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520104220344.png" alt="image-20240520104220344"></p><p>RPC的负载均衡策略一般包括随机权重、Hash、轮询等。</p><p><strong>如何设计一个自适应的负载均衡？</strong></p><p>所谓自适应的负载均衡，就是指负载均衡组件可以根据服务节点的可处理能力，动态调整服务节点的权重，将请求转发给合适的服务节点，从而保证整个系统的稳定性。</p><p>我们可以采用一种打分策略，服务调用者收集与之建立长连接的每个服务节点的指标数据，例如服务节点的负载指标、CPU核数、内存大小、请求处理的平均耗时、服务节点的健康状态等。我们可以为这些指标设置不同的权重，之后就可以计算每个服务节点动态分值。</p><p>在得到服务节点的动态分值后，我们把分值作为服务节点的权重，采用随机权重的负载均衡策略去分发请求，这样我们就可以完成一个自适应的负载均衡。</p><p>关键步骤如下：</p><ol><li>添加服务指标收集器，并将其作为插件，默认有运行时状态指标收集器、请求耗时指标收集器。</li><li>运行时状态指标收集器收集服务节点CPU核数、CPU负载以及内存等指标，在服务调用者与服务提供者的心跳数据中获取。</li><li>请求耗时指标收集器收集请求耗时数据，如平均耗时、TP99、TP999等。</li><li>可以配置开启哪些指标收集器，并设置这些参考指标的指标权重，再根据指标数据和指标权重来综合打分。</li><li>通过服务节点的综合打分与节点的权重，最终计算出节点的最终权重，之后服务调用者会根据随机权重的策略，来选择服务节点。</li></ol><h3 id="12-异常重试：在约定的时间内安全可靠地重试">12 | 异常重试：在约定的时间内安全可靠地重试</h3><p><strong>什么是RPC框架的重试机制？</strong></p><blockquote><p>当调用端发起的请求失败时，RPC框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。 调用端发起RPC请求时，会经过负载均衡，选择一个节点，之后它会向这个节点发送请求信息。当消息发送失败或收到异常消息时，我们就可以捕获异常，根据异常触发重试，重新通过负载均衡选择一个节点发送请求信息，并且记录请求的重试次数，当重试次数达到用户配置的重试次数时，就返回给调用端动态代理一个失败异常。</p></blockquote><p><strong>如何在约定的时间内安全可靠的重试？</strong></p><p>首先，服务的业务逻辑需要是幂等的，这是我们可以重试的前提。</p><p>其次，在每次重试后，都需要重置一下请求的超时时间，因为连续的异常重试可能会导致请求处理时间过长造成超时。</p><p>再次，当我们发起服务重试时，负载均衡选择节点时，需要去掉重试之前出现过问题的节点，这样可以提高重试的成功率。</p><p>最后，我们可以在RPC框架中配置业务异常相关的白名单，这样当白名单中的业务异常类型被触发时，也可以进行服务重试。</p><h3 id="13-优雅关闭：如何避免服务停机带来的业务损失？">13 | 优雅关闭：如何避免服务停机带来的业务损失？</h3><p>我们在RPC架构下，需要考虑当服务重启时，如何做到让调用方系统不出问题。</p><p>当服务提供方要上线时，一般是通过部署系统完成实例重启，在这个过程汇总，服务提供方不会事先告诉调用方哪些实例会被重启，从而让调用方切换流量。而对调用方来说，它也无法预测服务提供方哪些实例会重启，因此负载均衡还是有可能降正在重启的实例挑选出来，这样导致请求被分发到正在重启的服务实例中，造成调用方无法拿到正确的响应结果。</p><p>在服务重启的时候，对于调用方来说，有以下2种情况：</p><ol><li>调用方发请求前，目标服务已经下线。对于调用方来说，跟目标节点的连接会断开，这时调用可以立刻感知到，并在其健康列表中将该实例删除，这样就不会被负载均衡选中。</li><li>调用方发请求时，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接没有断开，所以这个节点还会存在健康列表里面，有可能会被负载均衡选中。</li></ol><p><strong>我们可以通过服务发现来实时通知服务调用方关于服务提供方是否可用吗？</strong></p><p>不可以。这样做的话，整个过程会依赖两次RPC调用：一次是服务提供方通知注册中心下线操作，一次是注册中心通知服务调用方下线节点操作。注册中心通知服务调用方都是异步的，服务发现只保证最终一致性，并不保证实时性，所以当注册中心收到服务提供方下线的时候，并不能保证把这次要下线的节点推送给所有调用方，这样，调用方还是有可能将请求发送给错误的服务提供方节点。</p><p><strong>如何做到优雅关闭服务？</strong></p><p>我们可以尝试让服务提供方来通知调用方，RPC里面调用方和提供方之间是长连接，我们可以在提供方应用内存中维护一份调用方连接集合，当服务关闭时，挨个通知调用方去下线相关实例，这样整个调用链路就变短了，对于每个调用方来说只一次RPC，可以确保调用的成功率很高。</p><p>但是上述方法不能彻底解决问题，因为有时出问题请求的时间点和收到提供方关闭通知的时间点很接近，再加上网络延迟，还是有可能在服务提供方关闭服务后再接收到新的请求。</p><p>解决办法是我们在关闭的时候，在服务提供方设置一个请求“挡板”，它的作用是告诉调用方，我已经进入关闭流程，不能再处理新的请求了。</p><p>当服务提供方正在关闭，如果在之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（ShutdownException），这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，没有处理这个请求”，然后调用方收到这个异常响应后，RPC框架就把这个节点从健康列表中挪出，并把请求自动重试到其他节点，因为这个请求没有被服务提供方处理过，所以可以安全的重试到其他节点，这样可以实现对业务无损。</p><p>我们还可以加上主动通知流程，让服务提供方给相关调用方发送关闭通知，这样既可以保证实时性，也可以避免通知失败的情况。</p><p>在Java语言中，我们可以使用Runtime.addShudownHook方法，来注册关闭的钩子，在RPC启动的时候，我们提前去注册关闭钩子，并在里面添加连个处理程序：一个复杂开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时我们需要再调用链里面加上挡板处理器，当新的请求进来时，会判断关闭标识，如果正在关闭，就抛出特定异常。</p><p>对于关闭过程中还在处理的请求，我们可以根据引用计数器，等待正在处理的请求全部结束后再真正关闭服务，同时还可以设置一个超时控制，当超过指定时间，请求还没有处理完，就强制退出应用。</p><p>总结一下，关于如何优雅关闭服务，包括以下步骤：</p><ol><li>开启关闭挡板，拒绝新的请求</li><li>利用引用计数器确保正在执行的请求处理完</li><li>设置超时时间，保证服务可以正常关闭</li><li>执行关闭时，服务提供方通知服务调用方下线相关节点</li></ol><p>服务优雅关闭的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520105158413.png" alt="image-20240520105158413"></p><p>“优雅关闭”的概念除了在RPC里面，在其他很多框架中也很常见，例如Tomcat在关闭的时候，也是先从外层到里层逐层进行关闭，先保证不接收新的请求，然后再处理关闭前收到的请求。</p><h3 id="14-优雅启动：如何避免流量达到没有启动完成的节点？">14 | 优雅启动：如何避免流量达到没有启动完成的节点？</h3><p><strong>为什么Java程序运行一段时间会执行速度会变快？</strong></p><blockquote><p>这是因为在Java里面，在运行过程中，JVM虚拟机会把高频的代码编译成机器码，被加载过的类也会被缓存到JVM缓存中，再次使用的时候就不会触发临时加载，这样就使得 “热点”代码的执行不用每次都通过解释，从而提升执行速度。</p></blockquote><p><strong>什么是启动预热？</strong></p><blockquote><p>启动预热就是让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。</p></blockquote><p>服务调用方应用通过服务发现能够取得服务提供方的IP地址，然后每次发送请求前，都需要通过负载均衡算法从连接池中选择一个可用连接，我们可以让负载均衡在选择连接的时候，区分一下是不是刚启动的应用，如果是刚启动的应用，我们可以调低它的权重值，这样它被选中的概率会很低，随着时间推移，我们逐渐增大它的权重值，从而实现一个动态增加流量的效果。</p><p>我们如何获取服务提供方应用的启动时间？有两种方法：</p><ol><li>服务提供方在启动的时候，把自己启动的时间告诉注册中心。</li><li>注册中心收到的服务提供方请求注册的时间。</li></ol><p>启动越热更多是从调用方的角度出发，去解决服务提供方应用冷启动的问题，让调用方的请求量通过一个时间窗口过渡，慢慢达到一个正常的水平，从而实现平滑上线。</p><p>从服务提供方的角度来说，有什么优化方案吗？服务提供方可以使用<strong>延迟暴露</strong>的方法来优化热启动过程。</p><p><strong>问题</strong>：服务提供方应用在没有完成启动的时候，调用方的请求就过来了，而调用方请求过来的原因，在于服务提供方应用启动过程中把解析到的RPC服务注册到了注册中心，这就导致了后续加载没有完成的情况下，服务提供方地址就被服务调用方感知到了。</p><p><strong>解决办法</strong>：我们在应用启动加载、解析Bean的时候，如果遇到了RPC服务的Bean，只先把这个Bean注册到Spring-BeanFactory里面，而不把这个Bean对应的接口注册到注册中心，只有等应用启动完成后，才被接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。</p><p>我们还可以利用服务启动完成到注册到注册中心的那段时间，预留一个Hook，让用户可以扩展Hook逻辑，在Hook里面模拟业务调用逻辑，从而使得JVM指令能够预热起来，同时还可以在Hook中预先加载一些资源，只有等所有缓存和资源都加载完成后，才把接口注册到注册中心，这样也就完成了热启动整个流程。</p><p><strong>如果我们有大批量的服务都需要重启，如何避免同时重启造成请求被分发到新启动的应用实例而造成超时错误？</strong></p><p>我们可以采取一些措施：</p><ol><li>分时分批启动，就像灰度发布一样。</li><li>根据重启比例来设置重启服务的权重。</li><li>在请求低峰重启应用。</li><li>在重启过程中，如有必要，对服务进行限流处理。</li></ol><p>启动预热通常是指在应用启动时预先加载一些数据或执行一些操作，以提高后续使用时的性能。在很多系统或应用中，启动预热是一个常见的优化手段。</p><p>具体来说，启动预热可能包括以下一些操作：</p><ol><li>预加载数据：应用在启动时从数据库或其他数据源加载一些常用数据到内存中。这样，当这些数据被使用时，应用可以直接从内存中读取，而不需要进行磁盘I/O或网络请求，提高了性能。</li><li>预建立连接：例如，数据库连接、网络连接等。这样，当需要使用这些连接时，就不需要等待连接建立的时间。</li><li>预编译代码：例如，一些解释型语言的虚拟机会在启动时预先编译一些经常使用的代码，以提高运行速度。</li><li>预热缓存：例如，将一些经常访问的数据预先加载到缓存中，以提高后续访问的速度。</li></ol><p>需要注意的是，启动预热虽然可以提高后续使用的性能，但是也会使得应用的启动时间变长。因此，需要在启动时间和运行性能之间做好平衡。</p><h3 id="15-熔断限流：业务如何实现自我保护？">15 | 熔断限流：业务如何实现自我保护？</h3><p><strong>为什么我们的服务需要自我保护？</strong></p><blockquote><p>RPC是解决分布式系统通信问题的一大利器，它会面临高并发的场景，这意味着我们提供服务的每个服务节点都有可能由于访问量过大而引起一系列的问题，例如业务处理耗时过长、CPU利用率过高、频繁Full GC以及服务进程直接宕机等，在生产环境中，我们要保证服务的稳定性和高可用性，这就需要业务进行自我保护，从而在高访问量、高并发的场景下，应用系统依然稳定，服务依然高可用。</p></blockquote><p><strong>使用RPC时，业务如何实现自我保护？</strong></p><p>可以在服务提供方做<strong>限流</strong>操作，在服务调用方做<strong>熔断</strong>操作。</p><p>熔断是调用方为了避免在调用过程中，服务提供方出现问题的时候，自身资源被耗尽的一种保护行为，而限流则是服务提供方为防止自己被突发流量打垮的一种保护行为。</p><p><strong>熔断和限流有什么区别？</strong></p><p>熔断主要在服务调用方进行设置，限流主要在服务提供方进行设置。</p><p><strong>服务端如何实现限流逻辑？</strong></p><blockquote><p>方式有很多，包括计数器、滑动窗口、漏斗算法和令牌桶算法等，其中令牌桶算法最常用。</p></blockquote><p>我们发布服务后，提供给多个应用的调用方去调用，这时有一个应用的调用方发送过来的请求流量要比其他的应用大很多，这时我们就应该对这个应用下的调用端发送过来的请求流量进行限流。所以我们在限流时，需要考虑应用级别的维度，甚至是IP级别的维度，这样做不仅可以让我们对一个应用下的调用端发送过来的请求流量做限流，还可以对一个IP发送过来的请求流量做限流。</p><p><strong>在服务端实现限流，配置的限流阈值是作用在每个服务节点上的。</strong></p><p>我们还可以提供一个专门的限流服务，让每个节点都依赖一个限流服务，当请求流量打过来时，服务节点触发限流逻辑，调用这个限流服务来判断是否到达了限流阈值。我们甚至可以将限流逻辑放在调用端，调用端在发出请求时先触发限流逻辑，调用限流服务，如果请求量已经到达了限流阈值，请求都不需要发出去，直接返回给动态代理一个限流异常即可。</p><p>在一个服务作为调用端去调用另外一个服务时，为了防止被调用的服务出现问题而影响到座位调用端的这个服务，那么服务调用端也需要进行自我保护，而最有效的自我保护方式就是<strong>熔断</strong>。</p><p><strong>熔断器的工作原理是怎样的？</strong></p><p>熔断器的工作机制主要是关闭、打开和半打开这三个状态之间的切换。在正常情况下，熔断器是关闭的，当调用端调用下游服务出现异常时，熔断器会收集异常指标信息进行计算，当达到熔断条件时熔断器打开，这时调用端再发起请求是会直接被熔断器拦截，并快速地执行失败逻辑，当熔断器打开一段时间后，会转为半打开状态，这时熔断器允许调用端发送一个请求给服务端，如果这次请求能够正常地得到服务端的响应，则将状态置为关闭状态，否则设置为打开。</p><p><strong>熔断器放在哪里比较合适？</strong></p><blockquote><p>建议放在调用方的动态代理模块，因为这时RPC调用的第一个关口，在发出请求时先经过熔断器，如果状态是闭合则正常发出请求，如果状态是打开则执行熔断器的失败策略。</p></blockquote><h3 id="16-业务分组：如何隔离流量？">16 | 业务分组：如何隔离流量？</h3><p>关于为什么要对请求流量进行分组，作者举了一个非常合适的例子：</p><blockquote><p>在没有汽车的年代，我们的道路很简单，就一条，行人、洋车都在上边走。随着汽车的普及以及猛增，我们的道路越来越宽，慢慢地有了高速、辅路、人行道等。很显然，交通网的建设和完善不仅提高了我们的出行效率，而且还更好的保障了我们行人的安全。</p></blockquote><p>对服务进行分组，并没有一个明确的可衡量的标准，但是一般建议非核心应用不要跟核心应用分在同一个组，核心应用之间应该做好隔离，一个重要的原则就是保障核心应用不受影响。</p><p>通过分组的方式隔离调用方的流量，从而避免因为一个调用方出现流量激增而影响其他调用方的可用率。</p><p>服务分组隔离后，单个调用方在发RPC请求时可以选择的服务节点数相比之前是减少了，那么对于单个调用方来说，出错的概率就增加了。</p><p>要解决这个问题，我们还需要把配置的分组区分主次分组，只有在主分组上的节点都不可用的情况下才去选择次分组节点，只要主分组里面的节点恢复正常，我们就必须把流量都切换到主节点上。整个切换过程对于应用层完全透明，从而在一定程度上保证了服务调用方应用高可用。</p><p>我们不仅可以通过分组把服务提供方划分成不同规模的小集群，我们还可以利用分组完成一个接口多种实现的功能。正常情况下，为了方便我们自己管理服务，一般会建议每个接口完成的功能尽量保证唯一。但在有些特殊场景下，两个接口也会完全一样，只是具体实现上有所差别，那么我们就可以在服务提供方应用里面同时暴露两个相同接口，但是接口分组不一样。</p><p><strong>在实际工作中，测试人员和开发人员的工作一般都是并行的，这就导致一个问题经常出现：开发人员在开发过程中可能需要启动自身的应用，而测试人员为了能验证功能，会在测试环境中部署同样的应用。如果开发人员和测试人员用的接口分组名刚好一样，在这种情况下，就可能会干扰其它正在联调的调用方进行功能验证，进而影响整体的工作效率。有什么解决办法？</strong></p><p>解决这个问题，有几种思路：</p><ol><li>不同团队使用不同的服务注册中心来管理服务节点。</li><li>可以采取类似于K8S中的命名空间的方法来隔离服务节点。</li><li>可以尝试流量染色，具体可以参考<a href="http://link.zhihu.com/?target=https%3A//juejin.cn/post/7087078047538479141">有关于流量染色的一些实践</a>。</li></ol><h3 id="17-异步RPC：压榨单机吞吐量">17 | 异步RPC：压榨单机吞吐量</h3><blockquote><p><strong>为什么异步可以提升吞吐量</strong></p></blockquote><p>吞吐量是一个衡量系统处理能力的重要指标，通常用于描述在单位时间内，一个系统能处理的任务数量或数据量。</p><p>异步编程是一种编程模式，它可以提高系统的吞吐量和效率。在同步编程模式中，操作是按照顺序一个接一个执行的，每个操作必须完成后，才能开始下一个操作。如果一个操作需要等待外部资源（如网络请求、文件I/O等），则整个系统需要等待这个操作完成，这样就浪费了宝贵的计算资源。</p><p>相比之下，异步编程允许操作在等待外部资源时，释放计算资源给其他的操作使用。例如，当发起一个网络请求后，系统不需要等待网络请求的回应，而可以立即开始执行其他的操作。当网络请求回应到来时，系统再回来处理这个回应。这样就使得计算资源得到了充分利用，从而提高了系统的吞吐量。</p><p>此外，异步编程还可以提高系统的响应性。在同步系统中，如果一个操作需要花费很长时间，那么用户可能需要等待这个操作完成后，才能看到响应。但是在异步系统中，这个长时间的操作可以在后台进行，而系统可以立即给用户一个响应，告诉用户操作正在进行。这样就提高了系统的响应性，提升了用户体验。</p><p>所以，异步编程可以提高系统的吞吐量和响应性，但是它也带来了更复杂的编程模型，需要更多的处理错误和状态管理的代码。因此，是否使用异步编程，应根据具体的应用场景和需求来决定。</p><hr><p>在我们知道RPC框架基础知识后，我们需要从RPC框架整体性能去考虑问题，例如怎么提升RPC框架的性能、稳定性、安全性、吞吐量，以及如何在分布式的场景下快速定位问题等。</p><p><strong>影响RPC调用吞吐量的根本原因是什么？</strong></p><p>处理RPC请求比较耗时，并且CPU大部分时间都在等待而非去计算，从而导致CPU利用率不高。RPC请求的耗时大部分是业务耗时，比如业务逻辑中有访问数据库执行慢SQL的操作，所以我们要看怎么能提升业务逻辑处理。</p><p>要提升吞吐量，关键就两个字：<strong>异步</strong>。</p><p><strong>服务调用端怎么异步？</strong> 对于调用端来说，向服务端发送请求消息与接受服务端发送过来的响应消息，这两个处理过程是两个完全独立的过程，这两个过程甚至在大多数情况下都不在一个线程中进行，也就是说，对于RPC框架，无论是同步调用还是异步调用，调用端的内部实现都是异步的。</p><p>调用端发送的每条信息都有一个唯一的消息标识，实际上调用端想服务端发送请求消息之前会创建一个Future，并会存储这个消息标识与这个Future的映射，动态代理所获得的返回值最终就是从这个Future中获取的，当收到服务端响应的消息时，调用端会根据响应消息的唯一标识，通过之前存储的映射找到对应的Future，将结果注入给那个Future，再进行一系列的处理逻辑，最后动态代理从Future中得到正确的返回值。</p><p>所谓同步调用，是指RPC框架在调用端的处理逻辑中主动执行了Future.get()方法，让动态代理等待返回值，而异步调用则是RPC框架没有主动执行这个方法，用户可以从请求上下文中得到这个Future，自己决定什么时候执行Future.get()方法。</p><p>Future模式的示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520111315955.png" alt="image-20240520111315955"></p><p>RPC调用在调用方和提供方之间完全异步。</p><p>CompletableFuture是Java 8原生支持的。如果RPC框架能够支持CompletableFuture，那发布一个RPC服务，服务接口定义的返回值是CompletableFuture对象，整个调用过程会分为以下几步：</p><ol><li>服务调用方发起RPC请求，直接拿到返回值CompletableFuture对象，之后就不需要任何额外的与RPC框架相关的操作了，直接就可以进行异步处理。</li><li>在服务提供方业务逻辑中创建一个返回值CompletableFuture对象，之后服务端真正的业务逻辑完全可以在一个线程池中异步处理，业务逻辑完成之后再调用这个CompletableFuture对象的complete方法，完成异步通知。</li><li>服务调用方在收到服务提供方发送过来的响应之后，RPC框架再自动地调用服务调用方拿到的那个 返回值CompletableFuture对象的complete方法，这样一次异步调用就完成了。</li></ol><p>RPC远程方法调用，有以下几种方式：</p><ol><li>sync，默认方式，这是在“方法”内部同步，但RPC框架还是异步处理的。</li><li>future，RPC消费者得到future，自行决定何时获取返回结果。</li><li>callback，RPC调用端不需要同步处理响应结果，可以直接返回，最后返回结果将会在回调线程中异步处理。</li><li>oneway，调用端发起请求后不需要接收响应。</li></ol><h3 id="18-安全体系：如何建立可靠的安全体系？">18 | 安全体系：如何建立可靠的安全体系？</h3><p>RPC一般用于解决内部应用之间的通信，这里的“内部”是指应用都部署在同一个大局域网中，这样在RPC中，我们很少考虑像数据包篡改、请求伪造等恶意行为。</p><p>我们主要关注两种类型的安全场景：</p><ol><li>调用方之间的安全保证。</li><li>服务发现中的安全保证。</li></ol><p>我们可以引入一个授权平台，来对调用方的身份进行验证，调用方可以在授权平台上申请自己应用里面需要调用的接口，而服务方可以在授权平台上进行审批，只有服务提供方审批后，调用方才能够调用。</p><p>上面的设计方案，授权平台承担了公司内所有RPC请求的次数总和，当RPC请求量达到一定水平，授权平台会成为一个瓶颈点。</p><p>为了解决这个问题，我们可以将授权平台所做的事情转移到服务提供方。我们使用一种不可逆加密算法，例如HMAC算法。服务提供方应用里面放一个用于HMAC签名的私钥，在授权平台上用这个私钥为申请调用的调用方应用进行签名，这个签名生成的串就变成了调用方唯一的身份。服务提供方在收到调用方的授权请求之后，我们只需要验证这个签名更调用方应用信息是否对应的上就可以了。</p><p>服务提供方可以提供的安全校验方式：</p><ol><li>md5摘要校验</li><li>非对称加密算法</li><li>OAuth2授权</li></ol><p>为了避免同一个接口有多个应用做发布提供者，我们需要把接口跟应用绑定上，一个接口只允许有一个应用发布提供者，避免其他应用也能发布这个接口。</p><p>当注册中心收到服务提供方注册申请时，可以验证下请求过来的应用是否跟接口绑定的应用一样，只有相同才允许注册，否则就返回错误信息给启动的应用，从而避免假冒的服务提供者对外提供错误服务。</p><h3 id="19-分布式环境下如何快速定位问题？">19 | 分布式环境下如何快速定位问题？</h3><p><strong>分布式环境下定位问题有什么难点？</strong></p><blockquote><p>分布式环境下定位问题的难点在于，各子应用、子服务之间有复杂的依赖关系，我们有时很难确定是哪个服务的哪个环节出现的问题。如果要通过日志来排查问题，就需要对每个子应用、子服务逐一进行排查，很难一步到位。</p></blockquote><p><strong>在分布式环境下如何快速定位问题？</strong> 有两种方式：</p><ol><li>借助合理封装的异常信息</li><li>借助分布式链路跟踪</li></ol><p>RPC框架打印的异常信息中，需要包含定位问题所需要的异常信息的，比如哪些异常引起的问题（如序列化问题或网络超时问题），是调用端还是服务端出现的异常，调用端与服务端的IP是多少，以及服务接口与服务分组是什么等等。</p><p>异常的示意图如下所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520113224912.png" alt="image-20240520113224912"></p><p>一款优秀的RPC框架要对异常进行详细地封装，还要对各类异常进行分类，每类异常都要有明确的异常标识码，并整理成一份简明的文档。适用房可以快速地通过异常标识码在文档中查阅，从而快速定位问题，找到原因，并且异常信息中药包含排查问题时所需要的重要信息，比如服务接口名、服务分组、调用端和服务端的IP，以及产生异常的原因。总之，要让适用房在复杂的分布式应用系统重，根据异常信息快速地定位到问题。</p><p>分布式链路跟踪可以让我们快速的知道整个服务调用的链路信息以及被调用的各个服务是否存在问题。例如服务A调用下游服务B，服务B又调用了B依赖的下游服务，如果服务A可以清楚的知道整个调用链路，并且能准确的直到调用链路中个服务的状态，那么就可以快速的定位问题。</p><p>分布式链路跟踪有Trace和Span两个关键概念：</p><ul><li><strong>Trace</strong>：代表整个链路，每次分布式都会产生一个Trace，每个Trace都有它的唯一标识，即TraceId，在分布式链路跟踪系统重，就是通过TraceId来区分每个Trace的。</li><li><strong>Span</strong>：代表了整个链路的一段链路，也就说Trace是由多个Span组成的。在一个Trace下，每个Span也有唯一的标识SpanId，而Span之间是存在父子关系的。</li></ul><p>Trace和Span的关系如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240520113243384.png" alt="image-20240520113243384"></p><p>RPC在整合分布式链路跟踪所需要做的核心事情有2件：</p><ol><li><strong>埋点</strong>：分布式链路跟踪系统要想获得一次分布式调用的完整链路信息，就必须对这次分布式调用进行数据采集，而采集这些数据的方法就是通过RPC框架对分布式链路跟踪进行埋点。RPC调用端在访问服务端时，在发送请求消息前会触发分布式跟踪埋点，在接收到服务端响应时，也会触发分布式跟踪埋点，并且在服务端也会有类似的埋点。这些埋点最终可以记录一个完整的Span，而这个链路的源头会记录一个完整的Trace，最终Trace信息也会上报给分布式链路跟踪系统。</li><li><strong>传递</strong>：上游调用端将Trace信息与父Span信息传递给下游服务的服务端，由下游触发埋点，对这些信息进行处理，在分布式链路跟踪系统重，每个子Span都存有父Span的相关信息以及Trace的相关信息。</li></ol><h3 id="20-详解时钟轮在RPC中的应用">20 | 详解时钟轮在RPC中的应用</h3><p><strong>RPC中的定时任务应该如何处理？</strong></p><ol><li>针对有定时需求的请求，建立额外的线程，使用Thread.sleep方法来处理。</li><li>建立一个单独的线程，来持续扫描有定时需求的请求，判断是否到时间了。</li><li>使用时钟轮方法</li></ol><p>在时钟轮机制中，有时间槽和时钟轮的概念，时间槽相当于时钟的刻度，时钟轮箱单与秒针与分针等跳动的一个周期，我们会将每个人物放到相应的时间槽位上。</p><p>时钟轮的运行机制和生活中的时钟是一样的，每隔固定的单位时间，就会从一个时间槽位调到下一个时间槽位，这就相当于我们的秒针跳动了一次；时钟轮可以分为多层，下一层时钟轮中每个槽位的单位时间是当前时间轮整个周期的时间，这就相当于1分钟等于60秒钟；当时钟轮将一个周期的所有槽位都跳动完后，就会从下一层时钟轮中取出一个槽位的任务，重新分不到当前的时钟轮中，当前时钟轮则从第0槽位开始重新跳动，这就相当于下一分钟的第1秒。</p><p><strong>在RPC框架中哪些功能会用到时钟轮？</strong></p><ol><li><strong>调用端请求超时处理</strong>，我们每发一次请求，都创建一个处理请求超时的定时任务放到时钟轮里，在高并发、高访问量的情况下，时钟轮每次只轮询一个时间槽位中的任务，这样会节省大量的CPU。</li><li><strong>心跳检测</strong>，对于这种需要重复执行的定时任务，我们可以在定时任务执行逻辑的最后，重设这个任务的执行时间，把它重新丢回到时钟轮里面。</li></ol><p>在使用时间轮时，我们需要注意两件事情：</p><ol><li>时间槽位的单位时间越短，时间轮触发任务的时间就越精确。</li><li>时间轮的槽位越多，那么一个任务呗重复扫描的概率就越小，因为只有在多层时钟轮中的任务才会被重复扫描。</li></ol><h3 id="21-流量回放：保障业务技术升级的神器">21 | 流量回放：保障业务技术升级的神器</h3><p><strong>什么是流量回放？</strong></p><blockquote><p>流量就是指在某个时间段内的所有请求，我们通过某种手段把发送到A应用的所有请求录制下来，然后把这些请求统一转发到B应用，让B应用接收到的请求参数和A应用保持一致，从而实现A接收到的请求在B应用里面重新请求了一遍，这个过程，我们称为“流量回放”。</p></blockquote><p>当我们对应用逻辑有改动，但在做了单元测试和回归测试之后，因为线上环境更加复杂，为了降低出错的概率，可以尝试使用流量回放。</p><p>传统QA测试不能满足要求的根本原因就是在于改造后的应用在上线后出现跟应用上线前不一致的行为。我们测试的目的就是为了保证改造后的应用跟改造前应用的行为一致，我们测试Case也应该尽力去模拟应用在线上的行为，这时最好的方式就是用线上流量来验证，但是又不能把新的应用直接上线，所以我们可以考虑流量回放。也就是说我们可以把线上一段时间内的请求参数和响应结果保存下来，然后把这些请求参数在新改造的应用里面重新请求一遍，对比一下改造前后的响应结果是否一致，这样就间接达到了使用线上流量进行测试的效果。</p><p>我们常用的流量回放方案包括TcpCopy、Nginx等。</p><p>在RPC框架中，因为所有的请求都经过RPC，我们可以在RPC中拿到这些请求参数，将这些参数旁录下来，并将旁录结果用异步的方式发送到一个固定的地方保存起来，这样就完成了流量录制功能。</p><p>在完成录制功能后，我们需要模拟一个应用调用方，将录制好的请求参数重新发送一遍到要回归测试的应用里面，然后对比录制拿到的请求结果和新请求的结果，这样就完成了请求回放的过程。</p><p>流量回放不是RPC框架的核心功能，但是有了这个功能以后，用户可以更放心的升级自己的应用了。</p><p>使用流量回放，对请求有一些限制：</p><ol><li>请求是否依赖底层数据，如果依赖，那么需要保证底层数据是一致的。</li><li>请求是否与当前系统状态或者系统时间有关系，如果相关，那么相关依赖也需要保持一致。</li><li>请求所执行的方法是否幂等，如果不幂等，很可能会影响验证结果。</li></ol><p>实现流量回放的设计思路：</p><ol><li>使用动态代理，切面拦截对应的方法，获取出入参。</li><li>把拦截信息异步转存到线上验证系统。</li><li>通过线上验证系统调用待验证的防范。</li><li>收集结果对比信息，设置报警功能。</li></ol><p>服务分组：为了避免非核心业务因调用量突增而影响整个系统的可用性，我们可以把服务按照调用方的不同划分为不同的小组或集群，这样可以实现调用流量的隔离，保证不同的业务之间不会相互影响。并且，通过将非核心业务应用和核心业务应用分开，可以进一步保护核心业务的稳定性。</p><p>分组机器配置：通过压力测试来评估每台服务器能承受的请求量（QPS），然后根据每个分组的总调用量计算出所需要的机器数量。为了应对可能的流量增长，我们通常会在计算出的机器数量基础上增加一定比例的额外机器作为缓冲。</p><p>动态分组：当某个分组的流量突然增加，而预留的机器无法满足需求时，我们可以检查其他分组是否有多余的处理能力来帮助处理请求。这就涉及到动态分组的概念，即通过修改注册中心的数据，动态调整服务分组，以适应不同的调用需求。</p><h3 id="22-动态分组：超高效实现秒级扩缩容">22 | 动态分组：超高效实现秒级扩缩容</h3><p>我们之前学习过服务分组，在调用方复杂的情况下，如果让所有调用方都调用同一个集群，那么很可能会因为非核心业务调用量的突增，造成整个集群都不可用了，为了避免这种情况，我们需要把整个打击群根据不同的调用方划分出不同的小集群，从而实现调用方流量隔离的效果，保证不同业务之间不会相互影响。</p><p>在给集群分组的时候，我们一般会选择性的合并一些调用方到同一个分组里，至于如何合并，并没有统一标准，一般来说，我们可以按照应用的重要级别来划分，让非核心业务应用和核心业务应用不要共用一个分组，并且非核心应用之间也最好别用一个分组。</p><p>那么我们如何为每个分组配置合适的机器数量呢？一般会通过压测来评估服务提供方单台机器所能承受的QPS，然后再计算出每个分组里面的所有调用方的调用总量，考虑到可能的不确定性因素，我们可以在现有调用总量的基础上，添加一个百分比作为buffer，这个百分比一般来自经验总结。</p><p>我们计算每个分组所需要的机器数量时，会额外增加一些机器，这样让每个小集群可以有一定的抗压能力，而抗压能力取决于预留机器的数量，这就需要在成本和可用性之间做权衡。</p><p>当某个分组的调用方流量突增，而分组所预留的空间不能满足当前流量要求时，我们可以看一下其他分组的服务提供方是否有富余能力来帮忙处理请求，这也就是动态分组的含义。</p><p>因为服务提供方的分组信息以及机器节点都保存在注册中心里面，我们可以在注册中心里面将部分实例的别名改成我们想要的别名，然后通过服务发现进而影响到不同调用方能够调用的服务提供方实例集合，换句话说，我们可以通过控制注册中心，来管理服务调用方可以触达的服务提供方以及分组节点的信息。</p><p>通过直接修改注册中心数据，我们可以让任何一个分组瞬间拥有不同规模的集群能力。我们不仅可以实现把某个实例的分组名改成另一个分组名，还可以让某个实例分组名变成多个分组名，这就是我们在动态分组里面最常见的两种动作：追加和替换。</p><p>我们还可以利用动态分组解决分组后的每个分组预留机器冗余的问题，我们没有必要把所有冗余的机器都分配到分组里面，我们可以把这些机器做成一个共享的池子，从而减少整理预留的实例数量。</p><h3 id="23-如何在没有接口的情况下进行RPC调用？">23 | 如何在没有接口的情况下进行RPC调用？</h3><p><strong>我们什么情况下需要在没有接口时进行RPC调用？</strong> 列举2个典型场景：</p><ol><li>我们搭建一个测试平台，允许各个业务方在测试凭条上通过输入接口、分组名、方法名以及参数值，在线测试自己发布的RPC服务。</li><li>我们要搭建一个轻量级的服务网关，可以让各个业务方用HTTP的方式，通过服务网关调用其他服务。</li></ol><p>所谓RPC调用，本质上就是调用端向服务端发送一条请求消息，服务端接收并处理，之后向调用端发送一条响应消息，调用端处理完响应消息后，一次RPC调用就完成了。</p><p>如果调用端可以将服务端需要知道的消息，例如接口名、业务分组名、方法名以及参数信息封装成请求消息发送给服务器，服务端就能够解析并处理这条请求信息，这样问题就解决了。</p><p>我们可以使用泛化接口的方式，来让RPC框架通过动态代理的方式，在没有接口的情况下，进行RPC调用，也称为泛化调用。</p><h3 id="24-如何在线上环境里兼容多种RPC协议？">24 | 如何在线上环境里兼容多种RPC协议？</h3><p>不同的RPC框架随着互联网技术的发展而慢慢涌现，这些框架会在不同时期被引入到不同的项目中去解决应用之间的通信问题，这样就导致了我们在线上的环境中会存在各种各样的RPC框架。</p><p>我们可以尝试通过自下而上的滚动升级方式，最终让所有的应用都切换到统一的RPC框架上，这种方法有2个局限：</p><ol><li>这要求我们能够清楚的梳理出各个应用之间的调用关系，只有这样，我们才能按部就班地把所有应用都升级到新的RPC框架上。</li><li>这要求应用之间的关系不能存在互相调用的情况，最好是应用之间的调用关系就像一棵树，有一定的层次关系。但实际上，应用之间的调用关系往往会变成一张网。</li></ol><p>这里的关键在于，我们要让新的RPC能同时支持多种RPC调用，当一个调用方切换到新的RPC之后，调用方和服务提供方之间就可以用新的协议完成调用，当调用方用老的RPC进行调用时，调用方和服务提供方之间就继续沿用老的协议完成调用。</p><p>RPC协议的作用是用来分割二进制数据流，不同的协议约定的数据包格式是不一样的，而且每种协议开头都有一个协议编码， 一般叫做magic number。</p><p>当RPC收到数据包之后，我们可以先解析出magic number，之后就可以找到对应协议的数据格式，然后使用相应的数据格式去解析收到的二进制数据包。</p><p>协议解析过程就是把一连串的二进制数据变成一个RPC内部对象，我们可以把和协议相关的对象转换成一个和协议无关的对象。</p><p>当完成真正的方法调用以后，RPC返回的也是一个和协议无关的通用对象，当我们向调用方回写数据时，我们还需要把通用对象转换成和协议相关的对象。</p>]]></content>
    
    
    <summary type="html">《RPC实战与核心原理》</summary>
    
    
    
    <category term="分布式" scheme="https://penge666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://penge666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Webbench</title>
    <link href="https://penge666.github.io/posts/689fc9d.html"/>
    <id>https://penge666.github.io/posts/689fc9d.html</id>
    <published>2024-05-19T14:07:33.000Z</published>
    <updated>2024-05-21T14:09:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Webbench是一款非常简单的网站压力测试工具，它是由Lionbridge公司开发的。由于它的简单性和轻量级，Webbench在互联网公司中广泛使用，特别是在进行网站压力测试时。</p><p>Webbench的主要功能是模拟大量的并发连接，以测试网站在高并发环境下的性能。它可以模拟多达3万个并发连接，这对于大多数网站来说已经足够了。</p><p>Webbench的使用也非常简单，你只需要在命令行中输入相应的命令，就可以开始测试。例如，以下命令会模拟1000个并发连接，持续60秒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbench -c 1000 -t 60 http://yourwebsite.com</span><br></pre></td></tr></table></figure><p>测试结束后，Webbench会在命令行中显示测试结果，包括每秒钟处理的请求数（Requests per second）、每秒钟传输的数据量（Transfer rate）等。</p><p>总的来说，Webbench是一款简单、轻量级的网站压力测试工具，它可以帮助你评估你的网站在高并发环境下的性能。</p><p>官网：<a href="http://home.tiscali.cz/~cz210552/webbench.html">http://home.tiscali.cz/~cz210552/webbench.html</a></p><h2 id="核心原理">核心原理</h2><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240521215503291.png" alt="image-20240521215503291"></p><h2 id="源码分析">源码分析</h2><p><strong>socket.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $Id: socket.c 1.1 1995/01/01 07:11:14 cthuang Exp $</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module has been modified by Radim Kolar for OS/2 emx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">  module:       socket.c</span></span><br><span class="line"><span class="comment">  program:      popclient</span></span><br><span class="line"><span class="comment">  SCCS ID:      @(#)socket.c    1.5  4/1/94</span></span><br><span class="line"><span class="comment">  programmer:   Virginia Tech Computing Center</span></span><br><span class="line"><span class="comment">  compiler:     DEC RISC C compiler (Ultrix 4.1)</span></span><br><span class="line"><span class="comment">  environment:  DEC Ultrix 4.3 </span></span><br><span class="line"><span class="comment">  description:  UNIX sockets code.</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">功能：通过地址和端口建立网络连接</span></span><br><span class="line"><span class="comment">host：网络地址</span></span><br><span class="line"><span class="comment">clientPort:端口</span></span><br><span class="line"><span class="comment">返回值：建立的socket连接</span></span><br><span class="line"><span class="comment">如果返回 -1,表示建立连接失联</span></span><br><span class="line"><span class="comment">***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以host和clientPort构成一对TCP的套接字（host支持域名）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Socket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">int</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> inaddr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ad;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *hp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;ad, <span class="number">0</span>, <span class="built_in">sizeof</span>(ad));</span><br><span class="line">    ad.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    inaddr = <span class="built_in">inet_addr</span>(host);<span class="comment">//将点分的十进制的IP转为无符号长整型</span></span><br><span class="line">    <span class="keyword">if</span> (inaddr != INADDR_NONE)</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="built_in">sizeof</span>(inaddr));</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果host是域名</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = <span class="built_in">gethostbyname</span>(host); <span class="comment">//用域名获取IP</span></span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//端口</span></span><br><span class="line">    ad.sin_port = <span class="built_in">htons</span>(clientPort); <span class="comment">//将一个无符号短整型(s)的主机数值(h)转换为网络字节顺序(n)</span></span><br><span class="line">    <span class="comment">//创建通信端点：套接字</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sock;</span><br><span class="line">    <span class="comment">//连接到相应的主机</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;ad, <span class="built_in">sizeof</span>(ad)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webbench.c</strong></p><p>在webbench.c文件中，包含了下面几个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="type">int</span> signal)</span><span class="comment">//信号处理函数，时钟结束时进行调用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//是在使用出错时提示怎么使用本程序。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span><span class="comment">//是用来创建http连接请求的。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bench</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//中创建管道和子进程，调用测试http函数。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span> *req)</span><span class="comment">//对http请求进行测试。</span></span></span><br></pre></td></tr></table></figure><p>wenbench.c源代码及注释 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* (C) Radim Kolar 1997-2004</span></span><br><span class="line"><span class="comment">* This is free software, see GNU Public License version 2 for</span></span><br><span class="line"><span class="comment">* details.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Simple forking WWW Server benchmark:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Usage:</span></span><br><span class="line"><span class="comment">*   webbench --help</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Return codes:</span></span><br><span class="line"><span class="comment">*    0 - sucess</span></span><br><span class="line"><span class="comment">*    1 - benchmark failed (server is not on-line)</span></span><br><span class="line"><span class="comment">*    2 - bad param</span></span><br><span class="line"><span class="comment">*    3 - internal error, fork failed</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;socket.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rpc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* values */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> timerexpired=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> speed=<span class="number">0</span>;<span class="comment">//子进程成功得到服务器响应的总数</span></span><br><span class="line"><span class="type">int</span> failed=<span class="number">0</span>;<span class="comment">//子进程请求失败总数</span></span><br><span class="line"><span class="type">int</span> bytes=<span class="number">0</span>;<span class="comment">//读取的字节总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* globals */</span></span><br><span class="line"><span class="type">int</span> http10=<span class="number">1</span>; <span class="comment">/* 0 - http/0.9, 1 - http/1.0, 2 - http/1.1 */</span></span><br><span class="line"><span class="comment">/* Allow: GET, HEAD, OPTIONS, TRACE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_GET 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_HEAD 1  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_OPTIONS 2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_TRACE 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRAM_VERSION <span class="string">&quot;1.5&quot;</span></span></span><br><span class="line"><span class="type">int</span> method=METHOD_GET;  <span class="comment">//HTTP请求方法，默认GET 方式</span></span><br><span class="line"><span class="type">int</span> clients=<span class="number">1</span>;  <span class="comment">//只模拟一个客户端,并发数</span></span><br><span class="line"><span class="type">int</span> force=<span class="number">0</span>;  <span class="comment">//是否等待服务器应答。默认为不等待</span></span><br><span class="line"><span class="type">int</span> force_reload=<span class="number">0</span>; <span class="comment">//失败时</span></span><br><span class="line"><span class="type">int</span> proxyport=<span class="number">80</span>; <span class="comment">//代理服务器应答，访问端口为80</span></span><br><span class="line"><span class="type">char</span> *proxyhost=<span class="literal">NULL</span>; <span class="comment">//代理服务器的地址</span></span><br><span class="line"><span class="type">int</span> benchtime=<span class="number">30</span>; <span class="comment">//模拟请求时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal */</span></span><br><span class="line"><span class="type">int</span> mypipe[<span class="number">2</span>]; <span class="comment">//管道，用于父子进程间通信</span></span><br><span class="line"><span class="type">char</span> host[MAXHOSTNAMELEN]; <span class="comment">//网络地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_SIZE 2048</span></span><br><span class="line"><span class="type">char</span> request[REQUEST_SIZE]; <span class="comment">//HTTP请求信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">option</span> long_options[]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;force&quot;</span>,no_argument,&amp;force,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;reload&quot;</span>,no_argument,&amp;force_reload,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;time&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;?&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http09&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;9&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http10&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http11&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;2&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>,no_argument,&amp;method,METHOD_GET&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;head&quot;</span>,no_argument,&amp;method,METHOD_HEAD&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;options&quot;</span>,no_argument,&amp;method,METHOD_OPTIONS&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;trace&quot;</span>,no_argument,&amp;method,METHOD_TRACE&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;version&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;V&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;proxy&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;clients&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prototypes */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host,<span class="type">const</span> <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *request)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bench</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timerexpired=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//帮助信息</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">            <span class="string">&quot;webbench [option]... URL\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -f|--force               Don&#x27;t wait for reply from server.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -r|--reload              Send reload request - Pragma: no-cache.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -9|--http09              Use HTTP/0.9 style requests.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -1|--http10              Use HTTP/1.0 protocol.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -2|--http11              Use HTTP/1.1 protocol.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --get                    Use GET request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --head                   Use HEAD request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --options                Use OPTIONS request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  --trace                  Use TRACE request method.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -?|-h|--help             This information.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -V|--version             Display program version.\n&quot;</span></span><br><span class="line">           );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> opt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> options_index=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *tmp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带参数时直接输出帮助信息</span></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usage</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//getopt_log 为命令行解析的库函数</span></span><br><span class="line">    <span class="keyword">while</span>((opt=<span class="built_in">getopt_long</span>(argc,argv,<span class="string">&quot;912Vfrt:p:c:?h&quot;</span>,long_options,&amp;options_index))!=EOF )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果有返回对应的命令行参数</span></span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="number">0</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: force=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: force_reload=<span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>: http10=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: http10=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: http10=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="built_in">printf</span>(PROGRAM_VERSION<span class="string">&quot;\n&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//输入版本号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: benchtime=<span class="built_in">atoi</span>(optarg);<span class="keyword">break</span>;     </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: </span><br><span class="line">            <span class="comment">/* proxy server parsing server:port */</span></span><br><span class="line">            tmp=<span class="built_in">strrchr</span>(optarg,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            proxyhost=optarg;</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Error in option --proxy %s: Missing hostname.\n&quot;</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg+<span class="built_in">strlen</span>(optarg)<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Error in option --proxy %s Port number is missing.\n&quot;</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *tmp=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            proxyport=<span class="built_in">atoi</span>(tmp+<span class="number">1</span>);<span class="keyword">break</span>;<span class="comment">//重设端口号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>: <span class="built_in">usage</span>();<span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: clients=<span class="built_in">atoi</span>(optarg);<span class="keyword">break</span>;<span class="comment">//并发数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optind 被 getopt_long设置为命令行参数中未读取的下一个元素下标值</span></span><br><span class="line">    <span class="keyword">if</span>(optind==argc) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;webbench: Missing URL!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">usage</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能指定客户端数和请求时间为 0</span></span><br><span class="line">    <span class="keyword">if</span>(clients==<span class="number">0</span>) clients=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(benchtime==<span class="number">0</span>) benchtime=<span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Copyright */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Webbench - Simple Web Benchmark &quot;</span>PROGRAM_VERSION<span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n&quot;</span></span><br><span class="line">            );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造HTTP请求到request数组</span></span><br><span class="line">    <span class="built_in">build_request</span>(argv[optind]);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print request info ,do it in function build_request</span></span><br><span class="line">    <span class="comment">/*printf(&quot;Benchmarking: &quot;);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    switch(method)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        case METHOD_GET:</span></span><br><span class="line"><span class="comment">        default:</span></span><br><span class="line"><span class="comment">        printf(&quot;GET&quot;);break;</span></span><br><span class="line"><span class="comment">        case METHOD_OPTIONS:</span></span><br><span class="line"><span class="comment">        printf(&quot;OPTIONS&quot;);break;</span></span><br><span class="line"><span class="comment">        case METHOD_HEAD:</span></span><br><span class="line"><span class="comment">        printf(&quot;HEAD&quot;);break;</span></span><br><span class="line"><span class="comment">        case METHOD_TRACE:</span></span><br><span class="line"><span class="comment">        printf(&quot;TRACE&quot;);break;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    printf(&quot; %s&quot;,argv[optind]);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    switch(http10)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        case 0: printf(&quot; (using HTTP/0.9)&quot;);break;</span></span><br><span class="line"><span class="comment">        case 2: printf(&quot; (using HTTP/1.1)&quot;);break;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Runing info: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clients==<span class="number">1</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 client&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d clients&quot;</span>,clients);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, running %d sec&quot;</span>, benchtime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(force) <span class="built_in">printf</span>(<span class="string">&quot;, early socket close&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost!=<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;, via proxy server %s:%d&quot;</span>,proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(force_reload) <span class="built_in">printf</span>(<span class="string">&quot;, forcing reload&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始压力测试，返回bench函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bench</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">功能：创建URL请求连接</span></span><br><span class="line"><span class="comment">url:url地址</span></span><br><span class="line"><span class="comment">返回值:无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">********************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求地址和请求连接清零</span></span><br><span class="line">    <span class="comment">//bzero(host,MAXHOSTNAMELEN);</span></span><br><span class="line">    <span class="comment">//bzero(request,REQUEST_SIZE);</span></span><br><span class="line">    <span class="built_in">memset</span>(host,<span class="number">0</span>,MAXHOSTNAMELEN);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(request,<span class="number">0</span>,REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断应该使用的HTTP协议,协议适配</span></span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span> &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填写method方式</span></span><br><span class="line">    <span class="keyword">switch</span>(method)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> METHOD_GET: <span class="built_in">strcpy</span>(request,<span class="string">&quot;GET&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_HEAD: <span class="built_in">strcpy</span>(request,<span class="string">&quot;HEAD&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_OPTIONS: <span class="built_in">strcpy</span>(request,<span class="string">&quot;OPTIONS&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_TRACE: <span class="built_in">strcpy</span>(request,<span class="string">&quot;TRACE&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">//URL 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==<span class="built_in">strstr</span>(url,<span class="string">&quot;://&quot;</span>)) <span class="comment">//找：//”在URL中的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n%s: is not a valid URL.\n&quot;</span>,url);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(url)&gt;<span class="number">1500</span>) <span class="comment">//url是否太长</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;URL is too long.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>!=<span class="built_in">strncasecmp</span>(<span class="string">&quot;http://&quot;</span>,url,<span class="number">7</span>)) <span class="comment">//比较前7个字符串</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//只支持HTTP地址</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nOnly HTTP protocol is directly supported, set --proxy for others.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到主机名开始的地方</span></span><br><span class="line">    <span class="comment">/* protocol/host delimiter */</span></span><br><span class="line">    i=<span class="built_in">strstr</span>(url,<span class="string">&quot;://&quot;</span>)-url+<span class="number">3</span>; <span class="comment">//i指向http://后第一个位置</span></span><br><span class="line">    <span class="comment">//必须以/结束</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;/&#x27;</span>)==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nInvalid URL syntax - hostname don&#x27;t ends with &#x27;/&#x27;.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get port from hostname */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)!=<span class="literal">NULL</span> &amp;&amp; <span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)&lt;<span class="built_in">index</span>(url+i,<span class="string">&#x27;/&#x27;</span>)) <span class="comment">//判断url中是否指定了端口号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;:&#x27;</span>)-url-i);  <span class="comment">//取出主机地址</span></span><br><span class="line">            <span class="comment">//bzero(tmp,10);</span></span><br><span class="line">            <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">10</span>);<span class="comment">//端口</span></span><br><span class="line">            <span class="built_in">strncpy</span>(tmp,<span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)+<span class="number">1</span>,<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;/&#x27;</span>)-<span class="built_in">index</span>(url+i,<span class="string">&#x27;:&#x27;</span>)<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;tmp=%s\n&quot;,tmp); */</span></span><br><span class="line">            proxyport=<span class="built_in">atoi</span>(tmp); <span class="comment">//设置端口</span></span><br><span class="line">            <span class="keyword">if</span>(proxyport==<span class="number">0</span>) proxyport=<span class="number">80</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strcspn</span>(url+i,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;Host=%s\n&quot;,host);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request+<span class="built_in">strlen</span>(request),url+i+<span class="built_in">strcspn</span>(url+i,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;ProxyHost=%s\nProxyPort=%d\n&quot;,proxyhost,proxyport);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request,url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(http10==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot; HTTP/1.0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (http10==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot; HTTP/1.1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;User-Agent: WebBench &quot;</span>PROGRAM_VERSION<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span> &amp;&amp; http10&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;Host: &quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(request,host);</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;Pragma: no-cache\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* add empty line at end */</span></span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>) <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRequest:\n%s\n&quot;</span>,request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment">功能：创建管道和子进程，对http请求进行测试</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* vraci system rc error kod */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bench</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为测试地址是否合法</span></span><br><span class="line">    <span class="comment">/* check avaibility of target server */</span></span><br><span class="line">    i=<span class="built_in">Socket</span>(proxyhost==<span class="literal">NULL</span>?host:proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nConnect to server failed. Aborting benchmark.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建管道</span></span><br><span class="line">    <span class="comment">/* create pipe */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(mypipe))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not needed, since we have alarm() in childrens */</span></span><br><span class="line">    <span class="comment">/* wait 4 next system clock tick */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cas=time(NULL);</span></span><br><span class="line"><span class="comment">    while(time(NULL)==cas)</span></span><br><span class="line"><span class="comment">    sched_yield();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//派生子进程</span></span><br><span class="line">    <span class="comment">/* fork childs */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;clients;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= (<span class="type">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* child process or error*/</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">/* make childs faster */</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//子进程立刻跳出循环，要不就子进程继续fork </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid &lt; (<span class="type">pid_t</span>) <span class="number">0</span>)<span class="comment">//fork出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;problems forking worker no. %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == (<span class="type">pid_t</span>) <span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程发出实际请求</span></span><br><span class="line">        <span class="comment">/* I am a child */</span></span><br><span class="line">        <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">benchcore</span>(host,proxyport,request);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">benchcore</span>(proxyhost,proxyport,request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开管道写</span></span><br><span class="line">        <span class="comment">/* write results to pipe */</span></span><br><span class="line">        f=<span class="built_in">fdopen</span>(mypipe[<span class="number">1</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;open pipe for writing failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* fprintf(stderr,&quot;Child - %d %d\n&quot;,speed,failed); */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(f,<span class="string">&quot;%d %d %d\n&quot;</span>,speed,failed,bytes);</span><br><span class="line">        <span class="built_in">fclose</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程打开管道读</span></span><br><span class="line">        f=<span class="built_in">fdopen</span>(mypipe[<span class="number">0</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;open pipe for reading failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">setvbuf</span>(f,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        speed=<span class="number">0</span>;<span class="comment">//传输速度</span></span><br><span class="line">        failed=<span class="number">0</span>;<span class="comment">//失败请求数</span></span><br><span class="line">        bytes=<span class="number">0</span>;<span class="comment">//传输字节数</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  <span class="comment">//从管道中读取每个子进程的任务执行情况，并计数</span></span><br><span class="line">        &#123;</span><br><span class="line">            pid=<span class="built_in">fscanf</span>(f,<span class="string">&quot;%d %d %d&quot;</span>,&amp;i,&amp;j,&amp;k);</span><br><span class="line">            <span class="keyword">if</span>(pid&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Some of our childrens died.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            speed+=i;</span><br><span class="line">            failed+=j;</span><br><span class="line">            bytes+=k;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//子进程是否读取完</span></span><br><span class="line">            <span class="comment">/* fprintf(stderr,&quot;*Knock* %d %d read=%d\n&quot;,speed,failed,pid); */</span></span><br><span class="line">            <span class="keyword">if</span>(--clients==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">fclose</span>(f);</span><br><span class="line">        <span class="comment">//输出测试结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n&quot;</span>,</span><br><span class="line">            (<span class="type">int</span>)((speed+failed)/(benchtime/<span class="number">60.0f</span>)),</span><br><span class="line">            (<span class="type">int</span>)(bytes/(<span class="type">float</span>)benchtime),</span><br><span class="line">            speed,</span><br><span class="line">            failed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment">功能：测试HTTP</span></span><br><span class="line"><span class="comment">host：地址</span></span><br><span class="line"><span class="comment">port：端口</span></span><br><span class="line"><span class="comment">req:http格式方法</span></span><br><span class="line"><span class="comment">**************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rlen;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="type">int</span> s,i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装信号</span></span><br><span class="line">    <span class="comment">/* setup alarm signal handler */</span></span><br><span class="line">    sa.sa_handler=alarm_handler;<span class="comment">//定时器方法</span></span><br><span class="line">    sa.sa_flags=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sigaction</span>(SIGALRM,&amp;sa,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置闹钟函数</span></span><br><span class="line">    <span class="built_in">alarm</span>(benchtime); <span class="comment">// after benchtime,then exit</span></span><br><span class="line"></span><br><span class="line">    rlen=<span class="built_in">strlen</span>(req);</span><br><span class="line">    <span class="comment">//无限执行请求，直到接收到SIGALRM信号将timerexpired设置为1时</span></span><br><span class="line">    nexttry:<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timerexpired)<span class="comment">//定时器到时后，也就是收到信号则后，会设定timerexpired=1，函数就会返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(failed&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* fprintf(stderr,&quot;Correcting failed by signal\n&quot;); */</span></span><br><span class="line">                failed--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接远程服务器 ，进行HTTP请求</span></span><br><span class="line">        s=<span class="built_in">Socket</span>(host,port); <span class="comment">//创建连接                         </span></span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">0</span>) &#123; failed++;<span class="keyword">continue</span>;&#125; <span class="comment">//连接失败，failed加1</span></span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        <span class="keyword">if</span>(rlen!=<span class="built_in">write</span>(s,req,rlen)) &#123;failed++;<span class="built_in">close</span>(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是http/0.9则关闭socket的写操作</span></span><br><span class="line">        <span class="keyword">if</span>(http10==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">shutdown</span>(s,<span class="number">1</span>)) &#123; failed++;<span class="built_in">close</span>(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果等到响应数据返回，则读取响应数据，计算传输的字节数</span></span><br><span class="line">        <span class="keyword">if</span>(force==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* read all available data from socket */</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(timerexpired) <span class="keyword">break</span>; </span><br><span class="line">                i=<span class="built_in">read</span>(s,buf,<span class="number">1500</span>);</span><br><span class="line">                <span class="comment">/* fprintf(stderr,&quot;%d\n&quot;,i); */</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) </span><br><span class="line">                &#123; </span><br><span class="line">                    failed++;</span><br><span class="line">                    <span class="built_in">close</span>(s);</span><br><span class="line">                    <span class="keyword">goto</span> nexttry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                bytes+=i; <span class="comment">//读取字节数增加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">close</span>(s)) &#123;failed++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//成功完成一次请求，并计数，继续下一次相同的请求，直到超时为止</span></span><br><span class="line">        speed++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ ./webbench -<span class="built_in">help</span></span><br><span class="line">webbench [option]... URL</span><br><span class="line">  -f|--force               Don<span class="string">&#x27;t wait for reply from server.</span></span><br><span class="line"><span class="string">  -r|--reload              Send reload request - Pragma: no-cache.</span></span><br><span class="line"><span class="string">  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.</span></span><br><span class="line"><span class="string">  -p|--proxy &lt;server:port&gt; Use proxy server for request.</span></span><br><span class="line"><span class="string">  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.</span></span><br><span class="line"><span class="string">  -9|--http09              Use HTTP/0.9 style requests.</span></span><br><span class="line"><span class="string">  -1|--http10              Use HTTP/1.0 protocol.</span></span><br><span class="line"><span class="string">  -2|--http11              Use HTTP/1.1 protocol.</span></span><br><span class="line"><span class="string">  --get                    Use GET request method.</span></span><br><span class="line"><span class="string">  --head                   Use HEAD request method.</span></span><br><span class="line"><span class="string">  --options                Use OPTIONS request method.</span></span><br><span class="line"><span class="string">  --trace                  Use TRACE request method.</span></span><br><span class="line"><span class="string">  -?|-h|--help             This information.</span></span><br><span class="line"><span class="string">  -V|--version             Display program version.</span></span><br></pre></td></tr></table></figure><p>简单测试下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv/pengeHome/webbench-c$ ./webbench  http://www.baidu.com/</span><br><span class="line">Webbench - Simple Web Benchmark 1.5</span><br><span class="line">Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http://www.baidu.com/</span><br><span class="line">1 client, running 30 sec.</span><br><span class="line"></span><br><span class="line">Speed=356 pages/min, 2416135 bytes/sec.</span><br><span class="line">Requests: 178 susceed, 0 failed.</span><br></pre></td></tr></table></figure><p>-t表示测试的时间，-c表示并发访问网站的客户数。上述QPS=178/30</p><p>返回的结果中有两个指标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.pages/min:每分输出的页面数；</span><br><span class="line">2.bytes/sec:每秒传输的比特数；</span><br><span class="line">3.succeed和failed表示请求的成功数目和失败数目；</span><br></pre></td></tr></table></figure><p><strong>补充</strong></p><p>Apache Bench 是 Apache 服务器自带的一个web压力测试=工具，简称 ab 。</p><p>ab的原理：ab命令会创建 <strong>多个并发</strong> 访问线程，模拟 <strong>多个访问者</strong> 同时对某一 <strong>URL地址</strong> 进行访问。</p><p>它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、<a href="https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3DIIS%26spm%3D1001.2101.3001.7020">IIS</a>等其它Web服务器的压力。</p><p>参考自：</p><ul><li><p><a href="https://blog.csdn.net/chen1415886044/article/details/103939937">web性能压力测试工具：Webbench 源码分析</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/106323837">web压力测试工具webbench</a></p></li></ul>]]></content>
    
    
    <summary type="html">Web性能压力测试工具:Webbench</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="https://penge666.github.io/posts/f12cbde5.html"/>
    <id>https://penge666.github.io/posts/f12cbde5.html</id>
    <published>2024-05-18T13:13:33.000Z</published>
    <updated>2024-05-20T11:30:55.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-开篇词"><strong>01 开篇词</strong></h2><h3 id="3-提升-MySQL-水平的方式">3 提升 MySQL 水平的方式</h3><p>如果你没有 MySQL 的基础，建议可以看下面两本书籍，看完之后，可以简单处理一些优化：</p><ul><li>《MySQL 必知必会》：主要讲 SQL 的写法；</li><li>《深入浅出 MySQL》：比较全面的讲解了 MySQL 的基础知识，也涉及了一些优化。</li></ul><p>如果已经对 MySQL 比较熟悉了，可以看下面的书籍，你会对索引和锁以及事务等有全新的看法：</p><ul><li>《高性能 MySQL》：里面讲了很多 MySQL 优化技巧；</li><li>《MySQL 技术内幕》：讲解了很多 MySQL 原理，强力推荐给想深入学习 MySQL 的同学；</li><li>《MySQL 内核：InnoDB 存储引擎》：想深入研究 MySQL 内核及原理的可以看看；</li><li>《MySQL 运维内参》：对 MySQL 源码感兴趣，可以入手；</li><li>《MySQL Internals Manual》<a href="https://dev.mysql.com/doc/internals/en/">https://dev.mysql.com/doc/internals/en/</a> ；</li><li>《MySQL 5.7 Reference Manual》<a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a> 。</li></ul><h3 id="4-学习本专栏前的提醒">4 学习本专栏前的提醒</h3><p><strong>本专栏默认使用的 MySQL 版本为 5.7.21，事务隔离级别为 RR，表的存储引擎为 InnoDB。</strong></p><h2 id="02-快速学会分析SQL执行效率（上）"><strong>02 快速学会分析SQL执行效率（上）</strong></h2><h3 id="1-定位慢-SQL">1 定位慢 SQL</h3><h4 id="1-1-通过慢查询日志">1.1 通过慢查询日志</h4><p>MySQL 的慢查询日志用来记录在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句。</p><blockquote><p>默认情况下，<strong>慢查询日志中不会记录管理语句</strong>，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。</p><p>默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。</p></blockquote><p>使用慢查询日志，一般分为三步：</p><ol><li><p>开启慢查询日</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log <span class="operator">=</span> <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置慢查询阀值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>确定慢查询日志路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;datadir&quot;; <span class="comment">/* 慢查询日志的目录 */</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;slow_query_log_file&quot;;  <span class="comment">/* 慢查询日志的文件名 */</span></span><br></pre></td></tr></table></figure></li></ol><p><code>SHOW GLOBAL VARIABLES LIKE</code>这句命令的含义就是查询MySQL数据库的全局变量。</p><h4 id="1-2-通过-show-processlist">1.2 通过 show processlist</h4><p>有时慢查询正在执行，已经导致数据库负载偏高了，而由于慢查询还没执行完，因此慢查询日志还看不到任何语句。此时可以使用 <code>show processlist</code> 命令判断正在执行的慢查询。 <strong><code>show processlist</code> 显示哪些线程正在运行</strong>。如果有 PROCESS 权限，则可以看到所有线程。否则，只能看到当前会话的线程。</p><blockquote><p>如果不使用 FULL 关键字，在 info 字段中只显示每个语句的前 100 个字符，如果想看语句的全部内容可以使用 full 修饰（<code>show full processlist</code>）。</p></blockquote><h3 id="2-使用-explain-分析慢查询">2 使用 explain 分析慢查询</h3><p>为了便于理解，先创建两张测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE muke;           <span class="comment">/* 创建测试使用的database，名为muke */</span></span><br><span class="line">use muke;                       <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;        <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (             <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">    `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`),</span><br><span class="line">    KEY `idx_b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                    <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do                  <span class="comment">/* 对满足i&lt;=1000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i, i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                      <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;                 <span class="comment">/* 创建批量写入1000条数据到表t1的存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t1();           <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t2;    <span class="comment">/* 如果表t2存在则删除表t2 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;    <span class="comment">/* 创建表t2，表结构与t1一致 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;   <span class="comment">/* 将表t1的数据导入到t2 */</span></span><br></pre></td></tr></table></figure><p>下面尝试使用 explain 分析一条 SQL，例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">=</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>Explain 的结果各字段解释如下（加粗的列为需要重点关注的项）：</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">id</td><td style="text-align:left">查询编号</td></tr><tr><td style="text-align:left"><strong>select_type</strong></td><td style="text-align:left">查询类型：显示本行是简单还是复杂查询</td></tr><tr><td style="text-align:left">table</td><td style="text-align:left">涉及到的表</td></tr><tr><td style="text-align:left">partitions</td><td style="text-align:left">匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td style="text-align:left"><strong>type</strong></td><td style="text-align:left">本次查询的表连接类型</td></tr><tr><td style="text-align:left">possible_keys</td><td style="text-align:left">可能选择的索引</td></tr><tr><td style="text-align:left"><strong>key</strong></td><td style="text-align:left">实际选择的索引</td></tr><tr><td style="text-align:left">key_len</td><td style="text-align:left">被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">与索引比较的列</td></tr><tr><td style="text-align:left"><strong>rows</strong></td><td style="text-align:left">预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td style="text-align:left">filtered</td><td style="text-align:left">按条件筛选的行的百分比</td></tr><tr><td style="text-align:left"><strong>Extra</strong></td><td style="text-align:left">附加信息</td></tr></tbody></table><p>这里介绍几个比较重要列常包含的值：</p><h4 id="2-1-select-type">2.1 select_type</h4><table><thead><tr><th style="text-align:left">select_type 的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">SIMPLE</td><td style="text-align:left">简单查询(不使用关联查询或子查询)</td></tr><tr><td style="text-align:left">PRIMARY</td><td style="text-align:left">如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td></tr><tr><td style="text-align:left">UNION</td><td style="text-align:left">联合查询中第二个及后面的查询</td></tr><tr><td style="text-align:left">DEPENDENT UNION</td><td style="text-align:left">满足依赖外部的关联查询中第二个及以后的查询</td></tr><tr><td style="text-align:left">UNION RESULT</td><td style="text-align:left">联合查询的结果</td></tr><tr><td style="text-align:left">SUBQUERY</td><td style="text-align:left">子查询中的第一个查询</td></tr><tr><td style="text-align:left">DEPENDENT SUBQUERY</td><td style="text-align:left">子查询中的第一个查询，并且依赖外部查询</td></tr><tr><td style="text-align:left">DERIVED</td><td style="text-align:left">用到派生表的查询</td></tr><tr><td style="text-align:left">MATERIALIZED</td><td style="text-align:left">被物化的子查询</td></tr><tr><td style="text-align:left">UNCACHEABLE SUBQUERY</td><td style="text-align:left">一个子查询的结果不能被缓存，必须重新评估外层查询的每一行</td></tr><tr><td style="text-align:left">UNCACHEABLE UNION</td><td style="text-align:left">关联查询第二个或后面的语句属于不可缓存的子查询</td></tr></tbody></table><h4 id="2-2-type">2.2 type</h4><table><thead><tr><th style="text-align:left">type的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">system</td><td style="text-align:left">查询对象表只有一行数据,且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td style="text-align:left">const</td><td style="text-align:left">基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td style="text-align:left">eq_ref</td><td style="text-align:left">表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td style="text-align:left">fulltext</td><td style="text-align:left">全文检索</td></tr><tr><td style="text-align:left">ref_or_null</td><td style="text-align:left">表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td style="text-align:left">index_merge</td><td style="text-align:left">利用多个索引</td></tr><tr><td style="text-align:left">unique_subquery</td><td style="text-align:left">子查询中使用唯一索引</td></tr><tr><td style="text-align:left">index_subquery</td><td style="text-align:left">子查询中使用普通索引</td></tr><tr><td style="text-align:left">range</td><td style="text-align:left">利用索引进行范围查询</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">全索引扫描</td></tr><tr><td style="text-align:left">ALL</td><td style="text-align:left">全表扫描</td></tr></tbody></table><blockquote><p><strong>上表的这些情况，查询性能从上到下依次是最好到最差。</strong></p></blockquote><h4 id="2-3-Extra">2.3 Extra</h4><table><thead><tr><th style="text-align:left">Extra 常见的值</th><th style="text-align:left">解释</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">Using filesort</td><td style="text-align:left">将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td style="text-align:left">explain select * from t1 order by create_time;</td></tr><tr><td style="text-align:left">Using temporary</td><td style="text-align:left">需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td style="text-align:left">explain select * from t1 group by create_time;</td></tr><tr><td style="text-align:left">Using index</td><td style="text-align:left">使用覆盖索引</td><td style="text-align:left">explain select a from t1 where a=111;</td></tr><tr><td style="text-align:left">Using where</td><td style="text-align:left">使用 where 语句来处理结果</td><td style="text-align:left">explain select * from t1 where create_time=’2019-06-18 14:38:24’;</td></tr><tr><td style="text-align:left">Impossible WHERE</td><td style="text-align:left">对 where 子句判断的结果总是 false 而不能选择任何数据</td><td style="text-align:left">explain select * from t1 where 1&lt;0;</td></tr><tr><td style="text-align:left">Using join buffer (Block Nested Loop)</td><td style="text-align:left">关联查询中，被驱动表的关联字段没索引</td><td style="text-align:left">explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td style="text-align:left">Using index condition</td><td style="text-align:left">先条件过滤索引，再查数据</td><td style="text-align:left">explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td style="text-align:left">Select tables optimized away</td><td style="text-align:left">使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td style="text-align:left">explain select max(a) from t1;</td></tr></tbody></table><h2 id="03-快速学会分析SQL执行效率（下）"><strong>03 快速学会分析SQL执行效率（下）</strong></h2><h3 id="1-show-profile-分析慢查询">1 show profile 分析慢查询</h3><p>有时需要确定 SQL 到底慢在哪个环节，此时 explain 可能不好确定。在 MySQL 数据库中，通过 profile，能够更清楚地了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节。</p><blockquote><p>可以通过配置参数 profiling = 1 来启用 SQL 分析。该参数可以在全局和 session 级别来设置。</p></blockquote><p>使用 profile 分析慢查询的大致步骤如下：</p><h4 id="1-1-确定是否支持-profile">1.1 确定是否支持 profile</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure><h4 id="1-2-查看-profiling-是否关闭的">1.2 查看 profiling 是否关闭的</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-通过-set-开启-profile">1.3 通过 set 开启 profile</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="1-4-执行-SQL-语句">1.4 执行 SQL 语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h4 id="1-5-确定-SQL-的-query-id">1.5 确定 SQL 的 query id</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                         |</span><br><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">|        1 | 0.00982500 | select * from t1 where b=1000 |</span><br><span class="line">+----------+------------+-------------------------------+</span><br></pre></td></tr></table></figure><h4 id="1-6-查询-SQL-执行详情">1.6 查询 SQL 执行详情</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------+----------+</span><br><span class="line">| Status                         | Duration |</span><br><span class="line">+--------------------------------+----------+</span><br><span class="line">| starting                       | 0.001746 |</span><br><span class="line">| Executing hook on transaction  | 0.000089 |</span><br><span class="line">| starting                       | 0.000107 |</span><br><span class="line">| checking permissions           | 0.000120 |</span><br><span class="line">| Opening tables                 | 0.001553 |</span><br><span class="line">| init                           | 0.000254 |</span><br><span class="line">| System lock                    | 0.000276 |</span><br><span class="line">| optimizing                     | 0.000291 |</span><br><span class="line">| statistics                     | 0.002640 |</span><br><span class="line">| preparing                      | 0.000235 |</span><br><span class="line">| executing                      | 0.001847 |</span><br><span class="line">| end                            | 0.000133 |</span><br><span class="line">| query end                      | 0.000031 |</span><br><span class="line">| waiting for handler commit     | 0.000090 |</span><br><span class="line">| closing tables                 | 0.000110 |</span><br><span class="line">| freeing items                  | 0.000242 |</span><br><span class="line">| cleaning up                    | 0.000062 |</span><br><span class="line">+--------------------------------+----------+</span><br></pre></td></tr></table></figure><h3 id="2-trace-分析-SQL-优化器">2 trace 分析 SQL 优化器</h3><p>从前面学到了 explain 可以查看 SQL 执行计划，但是无法知道它为什么做这个决策，如果想确定多种索引方案之间是如何选择的或者排序时选择的是哪种排序模式，可以使用 trace 查看优化器如何选择执行计划。</p><p>如果需要使用，先开启 trace，设置格式为 JSON，再执行需要分析的 SQL，最后查看 trace 分析结果（在 information_schema.OPTIMIZER_TRACE 中）。</p><p>开启该功能，会对 MySQL 性能有所影响，因此只建议分析问题时临时开启。</p><p>下面一起来看下 trace 的使用方法。使用讲解 explain 时创建的表t1做实验。</p><p>首先构造如下 SQL (表示取出表 t1 中 a 的值大于 900 并且 b 的值大于 910 的数据，然后按照 a 字段排序)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">and</span> b <span class="operator">&gt;</span> <span class="number">910</span> <span class="keyword">order</span>  <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p>我们首先用 explain 分析下执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">and</span> b <span class="operator">&gt;</span> <span class="number">910</span> <span class="keyword">order</span>  <span class="keyword">by</span> a;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_a,idx_b   <span class="operator">|</span> idx_b <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">90</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>通过上面执行计划中 key 这个字段可以看出，该语句使用的是 b 字段的索引 idx_b。实际表 t1 中，a、b 两个字段都有索引，为什么条件中有这两个索引字段却偏偏选了 b 字段的索引呢？这时就可以使用 trace 进行分析。大致步骤如下：</p><ol><li><p>开启 trace</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* optimizer_trace=&quot;enabled=on&quot; 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */</span></span><br><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行需要分析的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">and</span> b <span class="operator">&gt;</span> <span class="number">910</span> <span class="keyword">order</span>  <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure></li><li><p>查看 trace 分析结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">QUERY: select * from t1 where a &gt;900 and b &gt; 910 order  by a    --SQL语句</span><br><span class="line">TRACE: &#123;</span><br><span class="line">    &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">           &quot;join_preparation&quot;: &#123;    --SQL准备阶段</span><br><span class="line">               &quot;select#&quot;: 1,</span><br><span class="line">               &quot;steps&quot;: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       &quot;expanded_query&quot;: &quot;/* select#1 */ select `t1`.`id` AS `id`,`t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`create_time` AS `create_time`,`t1`.`update_time` AS `update_time` from `t1` where ((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910)) order by `t1`.`a`&quot;</span><br><span class="line">                   &#125;</span><br><span class="line">               ] /* steps */</span><br><span class="line">           &#125; /* join_preparation */</span><br><span class="line">       &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;join_optimization&quot;: &#123;   --SQL优化阶段</span><br><span class="line">                &quot;select#&quot;: 1,</span><br><span class="line">                &quot;steps&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;condition_processing&quot;: &#123;    --条件处理</span><br><span class="line">                            &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">                            &quot;original_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;,        --原始条件</span><br><span class="line">                            &quot;steps&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                                    &quot;resulting_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;   --等值传递转换</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                                    &quot;resulting_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;       --常量传递转换</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                                    &quot;resulting_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;        --去除没有的条件后的结构</span><br><span class="line">                                &#125;</span><br><span class="line">                            ] /* steps */</span><br><span class="line">                        &#125; /* condition_processing */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">                        &#125; /* substitute_generated_columns */   --替换虚拟生成列</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;table_dependencies&quot;: [  --表依赖详情</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                                &quot;map_bit&quot;: 0,</span><br><span class="line">                                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                                ] /* depends_on_map_bits */</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* table_dependencies */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">                        ] /* ref_optimizer_key_uses */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;rows_estimation&quot;: [ --预估表的访问成本</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                                    &quot;table_scan&quot;: &#123;</span><br><span class="line">                                        &quot;rows&quot;: 1000,       --扫描行数</span><br><span class="line">                                        &quot;cost&quot;: 207.1       --成本</span><br><span class="line">                                    &#125; /* table_scan */,</span><br><span class="line">                                    &quot;potential_range_indexes&quot;: [    --分析可能使用的索引</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                                            &quot;usable&quot;: false,       --为false，说明主键索引不可用</span><br><span class="line">                                            &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;index&quot;: &quot;idx_a&quot;,      --可能使用索引idx_a</span><br><span class="line">                                            &quot;usable&quot;: true,</span><br><span class="line">                                            &quot;key_parts&quot;: [</span><br><span class="line">                                                &quot;a&quot;,</span><br><span class="line">                                                &quot;id&quot;</span><br><span class="line">                                            ] /* key_parts */</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;index&quot;: &quot;idx_b&quot;,      --可能使用索引idx_b</span><br><span class="line">                                            &quot;usable&quot;: true,</span><br><span class="line">                                            &quot;key_parts&quot;: [</span><br><span class="line">                                                &quot;b&quot;,</span><br><span class="line">                                                &quot;id&quot;</span><br><span class="line">                                            ] /* key_parts */</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ] /* potential_range_indexes */,</span><br><span class="line">                                    &quot;setup_range_conditions&quot;: [</span><br><span class="line">                                    ] /* setup_range_conditions */,</span><br><span class="line">                                    &quot;group_index_range&quot;: &#123;</span><br><span class="line">                                        &quot;chosen&quot;: false,</span><br><span class="line">                                        &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                                    &#125; /* group_index_range */,</span><br><span class="line">                                    &quot;analyzing_range_alternatives&quot;: &#123; --分析各索引的成本</span><br><span class="line">                                        &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                &quot;index&quot;: &quot;idx_a&quot;, --使用索引idx_a的成本</span><br><span class="line">                                                &quot;ranges&quot;: [</span><br><span class="line">                                                    &quot;900 &lt; a&quot;   --使用索引idx_a的范围</span><br><span class="line">                                                ] /* ranges */,</span><br><span class="line">                                                &quot;index_dives_for_eq_ranges&quot;: true, --是否使用index dive（详细描述请看下方的知识扩展）</span><br><span class="line">                                                &quot;rowid_ordered&quot;: false, --使用该索引获取的记录是否按照主键排序</span><br><span class="line">                                                &quot;using_mrr&quot;: false,   --是否使用mrr</span><br><span class="line">                                                &quot;index_only&quot;: false,    --是否使用覆盖索引</span><br><span class="line">                                                &quot;rows&quot;: 100,            --使用该索引获取的记录数</span><br><span class="line">                                                &quot;cost&quot;: 121.01,         --使用该索引的成本</span><br><span class="line">                                                &quot;chosen&quot;: true          --可能选择该索引</span><br><span class="line">                                            &#125;,</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                &quot;index&quot;: &quot;idx_b&quot;,       --使用索引idx_b的成本</span><br><span class="line">                                                &quot;ranges&quot;: [</span><br><span class="line">                                                    &quot;910 &lt; b&quot;</span><br><span class="line">                                                ] /* ranges */,</span><br><span class="line">                                                &quot;index_dives_for_eq_ranges&quot;: true,</span><br><span class="line">                                                &quot;rowid_ordered&quot;: false,</span><br><span class="line">                                                &quot;using_mrr&quot;: false,</span><br><span class="line">                                                &quot;index_only&quot;: false,</span><br><span class="line">                                                &quot;rows&quot;: 90,</span><br><span class="line">                                                &quot;cost&quot;: 109.01,</span><br><span class="line">                                                &quot;chosen&quot;: true             --也可能选择该索引</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        ] /* range_scan_alternatives */,</span><br><span class="line">                                        &quot;analyzing_roworder_intersect&quot;: &#123; --分析使用索引合并的成本</span><br><span class="line">                                            &quot;usable&quot;: false,</span><br><span class="line">                                            &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                                        &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                                    &#125; /* analyzing_range_alternatives */,</span><br><span class="line">                                    &quot;chosen_range_access_summary&quot;: &#123;  --确认最优方法</span><br><span class="line">                                        &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                                            &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                                            &quot;index&quot;: &quot;idx_b&quot;,</span><br><span class="line">                                            &quot;rows&quot;: 90,</span><br><span class="line">                                            &quot;ranges&quot;: [</span><br><span class="line">                                                &quot;910 &lt; b&quot;</span><br><span class="line">                                            ] /* ranges */</span><br><span class="line">                                        &#125; /* range_access_plan */,</span><br><span class="line">                                        &quot;rows_for_plan&quot;: 90,</span><br><span class="line">                                        &quot;cost_for_plan&quot;: 109.01,</span><br><span class="line">                                        &quot;chosen&quot;: true</span><br><span class="line">                                    &#125; /* chosen_range_access_summary */</span><br><span class="line">                                &#125; /* range_analysis */</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* rows_estimation */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;considered_execution_plans&quot;: [  --考虑的执行计划</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;plan_prefix&quot;: [</span><br><span class="line">                                ] /* plan_prefix */,</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;best_access_path&quot;: &#123;          --最优的访问路径</span><br><span class="line">                                    &quot;considered_access_paths&quot;: [ --决定的访问路径</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;rows_to_scan&quot;: 90,      --扫描的行数</span><br><span class="line">                                            &quot;access_type&quot;: &quot;range&quot;,  --访问类型：为range</span><br><span class="line">                                            &quot;range_details&quot;: &#123;</span><br><span class="line">                                                &quot;used_index&quot;: &quot;idx_b&quot;  --使用的索引为：idx_b</span><br><span class="line">                                            &#125; /* range_details */,</span><br><span class="line">                                            &quot;resulting_rows&quot;: 90,    --结果行数</span><br><span class="line">                                            &quot;cost&quot;: 127.01,          --成本</span><br><span class="line">                                            &quot;chosen&quot;: true,     --确定选择</span><br><span class="line">                                            &quot;use_tmp_table&quot;: true</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ] /* considered_access_paths */</span><br><span class="line">                                &#125; /* best_access_path */,</span><br><span class="line">                                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                                &quot;rows_for_plan&quot;: 90,</span><br><span class="line">                                &quot;cost_for_plan&quot;: 127.01,</span><br><span class="line">                                &quot;sort_cost&quot;: 90,</span><br><span class="line">                                &quot;new_cost_for_plan&quot;: 217.01,</span><br><span class="line">                                &quot;chosen&quot;: true</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* considered_execution_plans */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;attaching_conditions_to_tables&quot;: &#123;  --尝试添加一些其他的查询条件</span><br><span class="line">                            &quot;original_condition&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;,</span><br><span class="line">                            &quot;attached_conditions_computation&quot;: [</span><br><span class="line">                            ] /* attached_conditions_computation */,</span><br><span class="line">                            &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                    &quot;attached&quot;: &quot;((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ] /* attached_conditions_summary */</span><br><span class="line">                        &#125; /* attaching_conditions_to_tables */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;clause_processing&quot;: &#123;</span><br><span class="line">                            &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">                            &quot;original_clause&quot;: &quot;`t1`.`a`&quot;,</span><br><span class="line">                            &quot;items&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;item&quot;: &quot;`t1`.`a`&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ] /* items */,</span><br><span class="line">                            &quot;resulting_clause_is_simple&quot;: true,</span><br><span class="line">                            &quot;resulting_clause&quot;: &quot;`t1`.`a`&quot;</span><br><span class="line">                        &#125; /* clause_processing */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;</span><br><span class="line">                            &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">                            &quot;index_order_summary&quot;: &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;index_provides_order&quot;: false,</span><br><span class="line">                                &quot;order_direction&quot;: &quot;undefined&quot;,</span><br><span class="line">                                &quot;index&quot;: &quot;idx_b&quot;,</span><br><span class="line">                                &quot;plan_changed&quot;: false</span><br><span class="line">                            &#125; /* index_order_summary */</span><br><span class="line">                        &#125; /* reconsidering_access_paths_for_index_ordering */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;refine_plan&quot;: [          --改进的执行计划</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;pushed_index_condition&quot;: &quot;(`t1`.`b` &gt; 910)&quot;,</span><br><span class="line">                                &quot;table_condition_attached&quot;: &quot;(`t1`.`a` &gt; 900)&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* refine_plan */</span><br><span class="line">                    &#125;</span><br><span class="line">                ] /* steps */</span><br><span class="line">            &#125; /* join_optimization */</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;join_execution&quot;: &#123;             --SQL执行阶段</span><br><span class="line">                &quot;select#&quot;: 1,</span><br><span class="line">                &quot;steps&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;filesort_information&quot;: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;direction&quot;: &quot;asc&quot;,</span><br><span class="line">                                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                                &quot;field&quot;: &quot;a&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ] /* filesort_information */,</span><br><span class="line">                        &quot;filesort_priority_queue_optimization&quot;: &#123;</span><br><span class="line">                            &quot;usable&quot;: false,             --未使用优先队列优化排序</span><br><span class="line">                            &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot;     --未使用优先队列排序的原因是没有limit</span><br><span class="line">                        &#125; /* filesort_priority_queue_optimization */,</span><br><span class="line">                        &quot;filesort_execution&quot;: [</span><br><span class="line">                        ] /* filesort_execution */,</span><br><span class="line">                        &quot;filesort_summary&quot;: &#123;           --排序详情</span><br><span class="line">                            &quot;rows&quot;: 90,                   --预计扫描的行数</span><br><span class="line">                            &quot;examined_rows&quot;: 90,          --参与排序的行数</span><br><span class="line">                            &quot;number_of_tmp_files&quot;: 0,     --排序过程中使用的临时文件数</span><br><span class="line">                            &quot;sort_buffer_size&quot;: 115056,   --sort_buffer 的大小</span><br><span class="line">                            &quot;sort_mode&quot;: &quot;&lt;sort_key, additional_fields&gt;&quot;   --排序模式（详解请看下方知识扩展）</span><br><span class="line">                        &#125; /* filesort_summary */</span><br><span class="line">                    &#125;</span><br><span class="line">                ] /* steps */</span><br><span class="line">            &#125; /* join_execution */</span><br><span class="line">        &#125;</span><br><span class="line">    ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 --该字段表示分析过程丢弃的文本字节大小，本例为0，说明没丢弃任何文本</span><br><span class="line">                    INSUFFICIENT_PRIVILEGES: 0    --查看trace的权限是否不足，0表示有权限查看trace详情</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">------------------------------------------------</span><br></pre></td></tr></table></figure></li><li><p>关闭trace</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure><p>TRACE 字段中整个文本大致分为三个过程。</p></li></ol><ul><li>准备阶段：对应文本中的 join_preparation</li><li>优化阶段：对应文本中的 join_optimization</li><li>执行阶段：对应文本中的 join_execution</li></ul><p>使用时，重点关注优化阶段和执行阶段。</p><p>由此例可以看出：</p><ul><li>在 trace 结果的 analyzing_range_alternatives 这一项可以看到：使用索引 idx_a 的成本为 121.01，使用索引 idx_b 的成本为 109.01，显然使用索引 idx_b 的成本要低些，因此优化器选择了 idx_b 索引；</li><li>在 trace 结果的 filesort_summary 这一项可以看到：排序模式为 <code>&lt;sort_key, additional_fields&gt;</code> ，表示使用的是单路排序，即一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序。</li></ul><blockquote><p>知识扩展：</p><p><strong>知识点一：MySQL 常见排序模式：</strong></p><ul><li><code>&lt; sort_key, rowid &gt;</code>双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li><code>&lt; sort_key, additional_fields &gt;</code>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li><code>&lt; sort_key, packed_additional_fields &gt;</code>打包数据排序模式：将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>三种排序模式比较：</p><p>第二种模式相对第一种模式，避免了二次回表，可以理解为用空间换时间。由于 sort buffer 有限，如果需要查询的数据比较大的话，会增加磁盘排序时间，效率可能比第一种方式更低。</p><p>MySQL 提供了一个参数：max_length_for_sort_data，当”排序的键值对大小” &gt; max_length_for_sort_data 时，MySQL 认为磁盘外部排序的 IO 效率不如回表的效率，会选择第一种排序模式；否则，会选择第二种模式。</p><p>第三种模式主要解决变长字符数据存储空间浪费的问题。</p><p><strong>知识点二：优化器在估计符合条件的行数时有两个选择：</strong></p><ul><li>index diver：dive 到 index 中利用索引完成元组数的估算；特点是速度慢，但可以得到精确的值；</li><li>index statistics：使用索引的统计数值，进行估算；特点是速度快，但是值不一定准确。</li></ul></blockquote><h3 id="3-总结">3 总结</h3><p>对比一下三种分析 SQL 方法的特点：</p><ul><li>explain：获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等；</li><li>profile：可以清楚了解到SQL到底慢在哪个环节；</li><li>trace：查看优化器如何选择执行计划，获取每个可能的索引选择的代价。</li></ul><h2 id="04-条件字段有索引，为什么查询也这么慢"><strong>04 条件字段有索引，为什么查询也这么慢?</strong></h2><p>下面会讲解几种有索引但是查询不走索引导致查询慢的场景。</p><h3 id="1-函数操作">1 函数操作</h3><h4 id="1-1-验证对条件字段做函数操作是否能走索引">1.1 验证对条件字段做函数操作是否能走索引</h4><p>首先创建测试表，建表及数据写入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">use muke;                       <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;        <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (             <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `a` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">    KEY `idx_b` (`b`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">    KEY `idx_c` (`c`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                    <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do                 <span class="comment">/* 对满足i&lt;=10000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i,i);  <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                        <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_t1();                    <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> c <span class="operator">=</span> <span class="string">&#x27;2019-05-22 00:00:00&#x27;</span>;  <span class="comment">/* 更新表t1的c字段，值都为&#x27;2019-05-22 00:00:00&#x27; */</span></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> c <span class="operator">=</span> <span class="string">&#x27;2019-05-21 00:00:00&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10000</span>;  <span class="comment">/* 将id为10000的行的c字段改为与其它行都不一样的数据，以便后面实验使用 */</span></span><br></pre></td></tr></table></figure><p>对于上面创建的测试表，比如要查询测试表 t1 单独某一天的所有数据，SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="type">date</span>(c) <span class="operator">=</span><span class="string">&#x27;2019-05-21&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以使用第 2 节学习的 explain 来分析这条SQL的执行计划，分析结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>查看图中的执行计划，type 为 ALL，key 字段结果为 NULL，因此知道该 SQL 是没走索引的全表扫描。</p><p>原因：对条件字段做函数操作走不了索引。</p><h4 id="1-2-对条件字段做函数操作不走索引的原因">1.2 对条件字段做函数操作不走索引的原因</h4><p>该例中 c 字段普通索引的 B+ 索引树如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518215240866.png" alt="image-20240518215240866"></p><p>根据上面结构可以看到，索引树中存储的是列的实际值和主键值。如果拿 ‘2019-05-21’ 去匹配，将无法定位到索引树中的值。因此放弃走索引，而选择全表扫描。</p><h4 id="1-3-函数操作的-SQL-优化">1.3 函数操作的 SQL 优化</h4><p>因此如果需要优化的话，改成 c 字段实际值相匹配的形式。因为 SQL 的目的是查询 2019-05-21 当天所有的记录，因此可以改成范围查询，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> c<span class="operator">&gt;=</span><span class="string">&#x27;2019-05-21 00:00:00&#x27;</span> <span class="keyword">and</span> c<span class="operator">&lt;=</span><span class="string">&#x27;2019-05-21 23:59:59&#x27;</span>;</span><br></pre></td></tr></table></figure><p>再用 explain 分析下执行计划的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_c         | idx_c | 5       | NULL |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><h3 id="2-隐式转换"><strong>2 隐式转换</strong></h3><blockquote><p>什么时隐式转换？</p><p>当操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。某些转换是隐式的。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html">关于隐式转换详情请参考MySQL官方手册</a></p></blockquote><p>隐式转换估计是很多 MySQL 使用者踩过的坑，比如联系方式字段。由于有时电话号码带加、减等特殊字符，有时需要以 0 开头，因此一般设计表时会使用 varchar 类型存储，并且会经常做为条件来查询数据，所以会添加索引。</p><p>而有时遇到需要按照手机号码条件（比如 11111111111）去查询数据时，因为查询者看到条件是一串数字，而忽视表中对应手机号字段是 varchar 类型，因此写出了如下不合理的SQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,tele_phone from user_info <span class="built_in">where</span> tele_phone =11111111111; /* SQL 1 */</span><br></pre></td></tr></table></figure><h4 id="2-2-验证隐式转换是否能走索引">2.2 验证隐式转换是否能走索引</h4><p>实验过程分为：先创建测试表并写入数据；测试隐式转换的查询并查看执行计划；测试正常查询，再查看执行计划。</p><p>比如我们要查询 a 字段等于 1000 的值，SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>看下 explain 结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_a         | NULL | NULL    | NULL | 10302 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>通过 type 这列可以看到是最差的情况 ALL（全表扫描）， 通过 key 这列可以看到没走 a 字段的索引，通过 rows 这列可以看到进行了全表扫描。</p><h4 id="2-3-不走索引的原因">2.3 不走索引的原因</h4><p>a 字段类型是 varchar(20)，而语句中 a 字段条件值没加单引号，导致 MySQL 内部会先把a转换成int型，再去做判断，相当于实际执行的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="built_in">cast</span>(a <span class="keyword">as</span> signed <span class="type">int</span>) <span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>因此又回到上面说的：<strong>对索引字段做函数操作时，优化器会放弃使用索引</strong>。</p><h4 id="2-4-隐式转换的-SQL-优化">2.4 隐式转换的 SQL 优化</h4><p>索引字符串列条件添加单引号，查看执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;1000&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 83      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>通过 type 这列，可以看到是 ref（基于普通索引的等值查询，比 ALL 性能好很多），通过key这列，可以看到已经走了 a 字段的索引，通过rows这列可以看到通过索引查询后就扫描了一行。</p><h3 id="3-模糊查询"><strong>3 模糊查询</strong></h3><h4 id="3-1-分析模糊查询">3.1 分析模糊查询</h4><p>很多时候我们想根据某个字段的某几个关键字查询数据，比如会有如下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;%1111%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>实际这种情况无法走索引，看下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |    11.11 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>重点留意type、key、rows、Extra，发现是全表扫描。</p><h4 id="3-2-模糊查询优化建议">3.2 模糊查询优化建议</h4><p>修改业务，让模糊查询必须包含条件字段前面的值，然后落到数据库的查询为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;1111%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种写法是可以用到索引的，explain分析如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_a         | idx_a | 83      | NULL |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><blockquote><p>如果条件只知道中间的值，需要模糊查询去查，那就建议使用<strong>ElasticSearch</strong>或其它搜索服务器。</p></blockquote><h3 id="4-范围查询"><strong>4 范围查询</strong></h3><h4 id="4-1-构造不能使用索引的范围查询">4.1 构造不能使用索引的范围查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span><span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>看下这条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_b         | NULL | NULL    | NULL | 10302 |    97.07 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>发现并不能走b字段的索引。</p><p>原因：优化器会根据检索比例、表大小、I/O块大小等进行评估是否使用索引。比如单次查询的数据量过大，优化器将不走索引。</p><h4 id="4-2-优化范围查询">4.2 优化范围查询</h4><p>降低单次查询范围，分多次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span><span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1001</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看执行计划（就只看第一条的，第二条同理）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_b         | idx_b | 5       | NULL | 1000 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><p>因此，降低查询范围后，能正常使用索引。</p><blockquote><p>经验分享：</p><p>实际这种范围查询而导致使用不了索引的场景经常出现，比如按照时间段抽取全量数据，每条SQL抽取一个月的；或者某张业务表历史数据的删除。遇到此类操作时，<strong>应该在执行之前对SQL做explain分析，确定能走索引，再进行操作</strong>，否则不但可能导致操作缓慢，在做更新或者删除时，甚至会导致表所有记录锁住，十分危险。</p></blockquote><h3 id="5-计算操作">5 计算操作</h3><h4 id="5-1-查询条件进行计算操作的-SQL-执行效率">5.1 查询条件进行计算操作的 SQL 执行效率</h4><p>有时我们与有对条件字段做计算操作的需求，在使用 SQL 查询时，就应该小心了。先看下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b<span class="number">-1</span> <span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>查看执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><blockquote><p>原因：对索引字段做运算将使用不了索引。</p></blockquote><h4 id="5-2-计算操作的-SQL-优化">5.2 计算操作的 SQL 优化</h4><p>将计算操作放在等号后面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> b <span class="operator">=</span><span class="number">1000</span> <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查看执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>发现将计算操作放在等号后，能正常使用索引。</p><blockquote><p>经验分享：</p><p><strong>一般需要对条件字段做计算时，建议通过程序代码实现，而不是通过MySQL实现。如果在MySQL中计算的情况避免不了，那必须把计算放在等号后面。</strong></p></blockquote><h3 id="6-总结">6 总结</h3><p>在写 SQL 时应该注意这些点：</p><ul><li>应该避免隐式转换</li><li>like查询不能以%开头</li><li>范围查询时，包含的数据比例不能太大</li><li>不建议对条件字段做运算及函数操作</li></ul><p>本节涉及到的一些SQL优化如下图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518215925762.png" alt="image-20240518215925762"></p><h2 id="05-如何优化数据导入？"><strong>05 如何优化数据导入？</strong></h2><h3 id="1-一次插入多行的值">1 一次插入多行的值</h3><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li>连接：30%</li><li>向服务器发送查询：20%</li><li>解析查询：20%</li><li>插入行：10% * 行的大小</li><li>插入索引：10% * 索引数</li><li>结束：10%</li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。</p><h3 id="2-关闭自动提交">2 关闭自动提交</h3><p>Autocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。</p><h3 id="3-参数调整">3 参数调整</h3><p>影响MySQL写入速度的主要两个参数：innodb_flush_log_at_trx_commit、sync_binlog。</p><h4 id="3-1-参数解释">3.1 参数解释</h4><p>innodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略，有0 、1和2三种值。</p><ul><li>0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。</li></ul><p>sync_binlog：控制binlog的刷盘时机，可配置0、1或者大于1的数字。</p><ul><li>0：二进制日志从不同步到磁盘，依赖OS刷盘机制；</li><li>1：二进制日志每次提交都会刷盘；</li><li>n(n&gt;1) : 每n次提交落盘一次。</li></ul><h2 id="06-让order-by、group-by查询更快"><strong>06 让order by、group by查询更快</strong></h2><h3 id="1-order-by-原理">1 order by 原理</h3><p>在优化 order by 语句之前，需要先了解 MySQL 中排序的相关知识点和原理，为了方便讲解过程举例说明，首先创建一张测试表，建表及数据写入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">use muke;                 <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;  <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (       <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `d` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a_b` (`a`,`b`),</span><br><span class="line">    KEY `idx_c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8mb4 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                  <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                        <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do         <span class="comment">/* 对满足i&lt;=10000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b,c) <span class="keyword">values</span>(i,i,i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                       <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_t1();               <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">where</span> id <span class="operator">&gt;</span><span class="number">9000</span>;    <span class="comment">/* 将id大于9000的行的a字段更新为1000 */</span></span><br></pre></td></tr></table></figure><h4 id="1-1-MySQL-的排序方式">1.1 MySQL 的排序方式</h4><p>按照排序原理分，MySQL 排序方式分两种：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行的排序</li></ul><blockquote><p><strong>怎么确定某条排序的 SQL 所使用的排序方式？</strong></p><p>使用 explain 来查看该排序 SQL 的执行计划，重点关注 Extra 字段：</p><p>如果该字段里显示是 Using index，则表示是通过有序索引直接返回有序数据。</p><p>如果该字段里显示是 Using filesort，则表示该 SQL 是通过 Filesort 进行的排序。</p></blockquote><h4 id="1-2-Filesort-是在内存中还是在磁盘中完成排序的？">1.2 Filesort 是在内存中还是在磁盘中完成排序的？</h4><p>MySQL 中的 Filesort 并不一定是在磁盘文件中进行排序的，也有可能在内存中排序，内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小。</p><ul><li>如果 “排序的数据大小” &lt; sort_buffer_size: 内存排序</li><li>如果 “排序的数据大小” &gt; sort_buffer_size: 磁盘排序</li></ul><blockquote><p><strong>怎么确定使用 Filesort 排序的 SQL 是在内存还是在磁盘中进行的排序操作？</strong></p><p>此时就可以使用 trace 进行分析，重点关注 number_of_tmp_files，如果等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序；如果大于0，则表示排序过程中使用了临时文件。</p></blockquote><h4 id="1-3-Filesort-下的排序模式">1.3 Filesort 下的排序模式</h4><p>Filesort 下的排序模式有三种，具体介绍如下：（参考<a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html">《MySQL 5.7 Reference Manual》8.2.1.14 ORDER BY Optimization</a>）</p><ul><li><code>&lt; sort_key, rowid &gt;</code>双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li><code>&lt; sort_key, additional_fields &gt;</code>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li><code>&lt; sort_key, packed_additional_fields &gt;</code>打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>因为打包数据排序模式是单路排序的一种升级模式，因此重点探讨双路排序和单路排序的区别。MySQL 通过比较系统变量 max_length_for_sort_data 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p><ul><li>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 <code>&lt; sort_key, additional_fields &gt;</code>排序模式；</li><li>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 <code>&lt;sort_key, rowid&gt;</code> 排序模式。</li></ul><p>为什么要添加 max_length_for_sort_data 这个参数让排序使用不同的排序模式呢？</p><p>接下来，我们一起分析下 max_length_for_sort_data 的重要性。比如下面这条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,c,d <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>我们先看<strong>单路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 条件的主键 id</li><li>根据主键 id 取出整行，<strong>取出 a、c、d 三个字段的值，存入 sort_buffer 中</strong></li><li>从索引 a 找到下一个满足 a = 1000 条件的主键 id</li><li>重复步骤 2、3 直到不满足 a = 1000</li><li>对 sort_buffer 中的数据按照字段 d 进行排序</li><li>返回结果给客户端</li></ol><p>我们再看下<strong>双路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 的主键 id</li><li>根据主键 id 取出整行，<strong>把排序字段 d 和主键 id 这两个字段放到 sort buffer 中</strong></li><li>从索引 a 取下一个满足 a = 1000 记录的主键 id</li><li>重复 3、4 直到不满足 a = 1000</li><li>对 sort_buffer 中的字段 d 和主键 id 按照字段 d 进行排序</li><li>遍历排序好的 id 和字段 d，按照 id 的值回到原表中取出 a、c、d 三个字段的值返回给客户端</li></ol><p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p><h3 id="2-order-by-优化">2 order by 优化</h3><h4 id="2-1-添加合适索引">2.1 添加合适索引</h4><h5 id="2-1-1-排序字段添加索引">2.1.1 排序字段添加索引</h5><p>首先我们看下对 d 字段（没有索引）进行排序的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> d,id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br></pre></td></tr></table></figure><p>发现使用的是 filesort（关注 Extra 字段）。</p><p>再看些对 c 字段（有索引）进行排序的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> c,id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> c;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_c | 5       | NULL | 10236 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>可以看到，根据有索引的字段排序，在 Extra 中显示的就为 Using index，表示使用的是索引排序。</p><p><strong>因此可以在排序字段上添加索引来优化排序语句。</strong></p><h5 id="2-1-2-多个字段排序优化">2.1.2 多个字段排序优化</h5><p>有时面对的需求是要对多个字段进行排序，而这种情况应该怎么优化或者设计索引呢？首先看下面例子：</p><p>对 a、c 两个字段进行排序的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,c <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,c;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br></pre></td></tr></table></figure><p>观察 Extra 字段，发现使用的是 filesort。</p><p>再看对 a、b（a、b 两个字段有联合索引）两个字段进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,b;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>发现使用的是索引排序。</p><p>多个字段排序的情况，如果要通过添加索引优化，得注意排序字段的顺序与联合索引中列的顺序要一致。</p><p>因此，<strong>如果多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句。</strong></p><h5 id="2-1-3-先等值查询再排序的优化">2.1.3 先等值查询再排序的优化</h5><p>我们更多的情况是会先根据某个字段条件查出一部分数据，然后再排序，而这类 SQL 应该如果优化呢？看下面的实验：</p><p>表 t1中，根据 a=1000 过滤数据再根据 d 字段排序的执行计划如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,d <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+</span><br></pre></td></tr></table></figure><p>可以在 Extra 字段中看到 “Using filesort”，说明使用的是 filesort 排序。</p><p>再看下根据 a=1000 过滤数据在根据 b 字段排序的执行计划（a、b 两个字段有联合索引）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>可以在 Extra 字段中看到”Using index”，说明使用的是索引排序。</p><p>因此，对于先等值查询再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化此类排序语句。</p><h4 id="2-2-去掉不必要的返回字段">2.2 去掉不必要的返回字段</h4><p>有时，我们其实并不需要查询出所有字段，但是可能因为习惯问题，就写成查所有字段的数据了。我们看下下面两条 SQL 的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,b;           <span class="comment">/* 根据a和b字段排序查出所有字段的值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a,b;      <span class="comment">/* 根据a和b字段排序查出id,a,b字段的值 */</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 order by a,b;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id,a,b from t1 order by a,b;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>这个例子中，查询所有字段不走索引的原因是：扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><h4 id="2-3-修改参数">2.3 修改参数</h4><p>在本节一开始讲 order by 原理的时候，接触到两个跟排序有关的参数：max_length_for_sort_data、sort_buffer_size。</p><ul><li>max_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值，让优化器优先选择全字段排序。当然不能设置过大，可能会导致 CPU 利用率过低或者磁盘 I/O 过高；</li><li>sort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。但不能设置过大，可能导致数据库服务器 SWAP。</li></ul><h4 id="2-4-几种无法利用索引排序的情况">2.4 几种无法利用索引排序的情况</h4><h5 id="2-4-1-使用范围查询再排序">2.4.1 使用范围查询再排序</h5><p>在本节 2.1.3 中介绍过，对于先等值过滤再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化；但是如果联合索引中前面的字段使用了范围查询，对后面的字段排序是否能用到索引排序呢？下面我们通过实验验证一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">9000</span> <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_a_b       | idx_a_b | 5       | NULL |    1 |   100.00 | Using where; Using index; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br></pre></td></tr></table></figure><p>这里对上面执行计划做下解释：首先条件 a&gt;9000 使用了索引（关注 key 字段对应的值为 idx_a_b）；在 Extra 中，看到了”Using filesort”，表示使用了 filesort 排序，并没有使用索引排序。所以联合索引中前面的字段使用了范围查询，对后面的字段排序使用不了索引排序。</p><p>原因是：a、b 两个字段的联合索引，对于单个 a 的值，b 是有序的。而对于 a 字段的范围查询，也就是 a 字段会有多个值，取到 a，b 的值 b 就不一定有序了，因此要额外进行排序。联合索引结果如下图（为了便于理解，该图的值与上面所创建的表 t1 数据不一样）：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518221159176.png" alt="image-20240518221159176"></p><p><strong>使用范围查询再排序</strong></p><p>如上图所示，对于有 a、b 两个字段联合索引的表，如果对 a 字段范围查询，b 字段整体来看是无序的（如上图 b 的值为：1，2，3，1，2，3······）。</p><h5 id="2-4-2-ASC-和-DESC-混合使用将无法使用索引">2.4.2 ASC 和 DESC 混合使用将无法使用索引</h5><p>对联合索引多个字段同时排序时，如果一个是顺序，一个是倒序，则使用不了索引，如下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,a,b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">asc</span>,b <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra                       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+</span><br></pre></td></tr></table></figure><h3 id="3-group-by-优化">3 group by 优化</h3><p>默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。</p><h3 id="4-总结">4 总结</h3><p>首先说到 MySQL 的两种排序方式：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行排序</li></ul><p>建议优先考虑索引排序。</p><p>而Filesort又分为两种：</p><ul><li>内存排序</li><li>磁盘文件排序</li></ul><p>优先考虑内存排序。</p><p>Filesort 有三种排序模式：</p><ul><li><code>&lt; sort_key, rowid &gt;</code></li><li><code>&lt; sort_key, additional_fields &gt;</code></li><li><code>&lt; sort_key, packed_additional_fields &gt;</code></li></ul><p><strong>order by 语句的优化，这个是本节的重点：</strong></p><ul><li>通过添加合适索引</li><li>去掉不必要的返回字段</li><li>调整参数：主要是 max_length_for_sort_data 和 sort_buffer_size</li><li>避免几种无法利用索引排序的情况</li></ul><p>最后说到 group by 语句的优化，如果只要分组，没有排序需求的话，可以加 order by null 禁止排序。</p><h2 id="07-换种思路写分页查询"><strong>07 换种思路写分页查询</strong></h2><p>很多时候，业务上会有分页操作的需求，对应的 SQL 类似下面这条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> t1 limit <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>表示从表 t1 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。本节内容就一起研究下，是否有办法去优化分页查询。</p><p>为了方便验证，首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use muke;                       <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;        <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (             <span class="comment">/* 创建表t1 */</span></span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">    `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`),</span><br><span class="line">    KEY `idx_b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;                    <span class="comment">/* 声明变量i */</span></span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do                  <span class="comment">/* 对满足i&lt;=100000的值进行while循环 */</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i, i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                      <span class="comment">/* 将i加1 */</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;                 <span class="comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t1();           <span class="comment">/* 运行存储过程insert_t1 */</span></span><br></pre></td></tr></table></figure><h3 id="1-根据自增且连续主键排序的分页查询">1 根据自增且连续主键排序的分页查询</h3><p>首先来看一个根据自增且连续主键排序的分页查询的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 limit <span class="number">9000</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>该 SQL 表示查询从第 9001 开始的两行数据，没添加单独 order by，表示通过主键排序。我们再看表 t1，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 9001开始的两行数据，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">&gt;</span><span class="number">9000</span> limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>查询的结果是一致的。我们再对比一下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 limit 9000,2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t1 where id &gt;9000 limit 2;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1000 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>原 SQL 中 key 字段为 NULL，表示未走索引，rows 显示 9963，表示扫描的行数 9963行；</p><p>改写后的 SQL key 字段为 PRIMARY，表示走了主键索引，扫描了1000行。</p><p>显然改写后的 SQL 执行效率更高。</p><p>另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：</p><ul><li>主键自增且连续</li><li>结果是按照主键排序的</li></ul><h3 id="2-查询根据非主键字段排序的分页查询">2 查询根据非主键字段排序的分页查询</h3><p>再看一个根据非主键字段排序的分页查询，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">9000</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>看下这条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure><p>发现并没有使用 a 字段的索引（key 字段对应的值为 null），具体原因：<strong>扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p><p>知道不走索引的原因，那么怎么优化呢？</p><p>其实关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL 改写如下（这里参考了《深入浅出 MySQL》18.4.7 优化分页查询）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 f <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">9000</span>,<span class="number">2</span>)g <span class="keyword">on</span> f.id <span class="operator">=</span> g.id;</span><br></pre></td></tr></table></figure><p>看下这条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 9002 |   100.00 | NULL        |</span><br><span class="line">|  1 | PRIMARY     | f          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | g.id |    1 |   100.00 | NULL        |</span><br><span class="line">|  2 | DERIVED     | t1         | NULL       | index  | NULL          | idx_a   | 5       | NULL | 9002 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p><h2 id="08-Join语句可以这样优化"><strong>08 Join语句可以这样优化</strong></h2><p>这个部分可以看《MySQL实战45讲》</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE muke; <span class="comment">/* 创建测试使用的database，名为muke */</span></span><br><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1; <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` ( <span class="comment">/* 创建表t1 */</span></span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; <span class="comment">/* 如果存在存储过程insert_t1，则删除 */</span></span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1() <span class="comment">/* 创建存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do <span class="comment">/* 对满足i&lt;=10000的值进行while循环 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i, i); <span class="comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t1(); <span class="comment">/* 运行存储过程insert_t1 */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t2; <span class="comment">/* 如果表t2存在则删除表t2 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1; <span class="comment">/* 创建表t2，表结构与t1一致 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 limit <span class="number">100</span>; <span class="comment">/* 将表t1的前100行数据导入到t2 */</span></span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518222859201.png" alt="image-20240518222859201"></p><h3 id="1-关联查询的算法">1 关联查询的算法</h3><p>MySQL 使用以下两种嵌套循环算法或它们的变体在表之间执行连接（参考 《<a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html">MySQL 5.7 Reference Manual》8.2.1.6 Nested-Loop Join Algorithms</a>）：</p><ul><li>Nested-Loop Join 算法</li><li>Block Nested-Loop Join 算法</li></ul><p>另外还有一种算法 Batched Key Access，其实算对 Nested-Loop Join 算法的一种优化。</p><h4 id="1-1-Nested-Loop-Join-算法">1.1 Nested-Loop Join 算法</h4><p>一个简单的 Nested-Loop Join(NLJ) 算法一次一行循环地从第一张表（称为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行，然后取出两张表的结果合集。</p><p>我们试想一下，如果在被驱动表中这个关联字段没有索引，那么每次取出驱动表的关联字段在被驱动表查找对应的数据时，都会对被驱动表做一次全表扫描，成本是非常高的（比如驱动表数据量是 m，被驱动表数据量是 n，则扫描行数为 m * n ）。</p><p>好在 MySQL 在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join，等下会细说这个算法。我们先来看下在有索引情况的情况下，使用 Nested-Loop Join 的场景（称为：Index Nested-Loop Join）。</p><p>因为 MySQL 在关联字段有索引时，才会使用 NLJ，因此本节后面的内容所用到的 NLJ 都表示 Index Nested-Loop Join。</p><p>如下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.a;       <span class="comment">/* sql1 */</span></span><br></pre></td></tr></table></figure><blockquote><p>表 t1 和表 t2 中的 a 字段都有索引。</p></blockquote><p>怎么确定这条 SQL 使用的是 NLJ 算法？</p><p>我们先来看下 sql1 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | NULL        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>从执行计划中可以看到这些信息：</p><ul><li>驱动表是 t2，被驱动表是 t1。原因是：explain 分析 join 语句时，在第一行的就是驱动表；选择 t2 做驱动表的原因：如果没固定连接方式（比如没加 straight_join）优化器会优先选择小表做驱动表。<strong>所以使用 inner join 时，前面的表并不一定就是驱动表。</strong></li><li>使用了 NLJ。原因是：一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer （***）；则表示使用的 join 算法是 NLJ。</li></ul><p>在这个过程中会读取 t2 表的所有数据，因此这里扫描了 100 行，然后遍历这 100 行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行，这里也扫描了 100 行。因此整个过程扫描了 200 行。</p><p>在前面，我们有说到：如果被驱动表的关联字段没索引，就会使用 Block Nested-Loop Join(简称：BNL)，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join呢？下面就一起分析下：</p><h4 id="1-2-Block-Nested-Loop-Join-算法">1.2 Block Nested-Loop Join 算法</h4><p>Block Nested-Loop Join(BNL) 算法的思想是：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。</p><p>我们一起看看下面这条 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b <span class="operator">=</span> t2.b;       <span class="comment">/* sql2 */</span></span><br></pre></td></tr></table></figure><blockquote><p>表 t1 和表 t2 中的 b 字段都没有索引</p></blockquote><p>看下执行计划</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br></pre></td></tr></table></figure><p>在 Extra 发现 Using join buffer (Block Nested Loop)，这个就说明该关联查询使用的是 BNL 算法。</p><p>我们再看下 sql2 的执行流程：</p><ol><li>把 t2 的所有数据放入到 join_buffer 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li><li>返回满足 join 条件的数据</li></ol><p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</p><p>下面我们来回答上面提出的一个问题：</p><p>如果被驱动表的关联字段没索引，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join 呢？</p><p>在被驱动表的关联字段没索引的情况下，比如 sql2：</p><p>如果使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。</p><p>如果使用 BNL，那么磁盘扫描是 100 + 10000=10100 次，在内存中判断 100 * 10000 = 100万次。</p><p>显然后者磁盘扫描的次数少很多，因此是更优的选择。因此对于 MySQL 的关联查询，如果被驱动表的关联字段没索引，会使用 BNL 算法。</p><h4 id="1-3-Batched-Key-Access-算法">1.3 Batched Key Access 算法</h4><p>NLJ 的关键思想是：被驱动表的关联字段有索引。</p><p>BNL 的关键思想是：把驱动表的数据批量提交一部分放到 join_buffer 中。</p><p>从 MySQL 5.6 开始，确实出现了这种集 NLJ 和 BNL 两种算法优点于一体的新算法：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html">Batched Key Access(BKA)</a>。</p><p>其原理是：</p><ol><li>将驱动表中相关列放入 join_buffer 中</li><li>批量将关联字段的值发送到 Multi-Range Read(MRR) 接口</li><li>MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作</li><li>返回结果给客户端</li></ol><blockquote><p><strong>这里补充下 MRR 相关知识：</strong></p><p>当表很大并且没有存储在缓存中时，使用辅助索引上的范围扫描读取行可能导致对表有很多随机访问。</p><p>而 Multi-Range Read 优化的设计思路是：查询辅助索引时，对查询结果先按照主键进行排序，并按照主键排序后的顺序，进行顺序查找，从而减少随机访问磁盘的次数。</p><p>使用 MRR 时，explain 输出的 Extra 列显示的是 Using MRR。</p><p>optimizer_switch 中 mrr_cost_based 参数的值会影响 MRR。</p><p>如果 mrr_cost_based=on，表示优化器尝试在使用和不使用 MRR 之间进行基于成本的选择。</p><p>如果 mrr_cost_based=off，表示一直使用 MRR。</p><p>更多 MRR 信息请参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html%E3%80%82">https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html。</a></p></blockquote><p>下面尝试开启 BKA ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里对上面几个参数做下解释：</p><ul><li>mrr=on 开启 mrr</li><li>mrr_cost_based=off 不需要优化器基于成本考虑使用还是不使用 MRR，也就是一直使用 MRR</li><li>batched_key_access=on 开启 BKA</li></ul><p>然后再看 sql1 的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.a;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra                                  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where                            |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+</span><br></pre></td></tr></table></figure><p>在 Extra 字段中发现有 Using join buffer (Batched Key Access)，表示确实变成了 BKA 算法。</p><h3 id="2-优化关联查询">2 优化关联查询</h3><p>通过上面的知识点，我们知道了关联查询的一些算法，下面一起来讨论下关联查询的优化：</p><h4 id="2-1-关联字段添加索引">2.1 关联字段添加索引</h4><p>通过上面的内容，我们知道了 BNL、NLJ 和 BKA 的原理，<strong>因此建议在被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。</strong></p><h4 id="2-2-小表做驱动表">2.2 小表做驱动表</h4><p>前面说到，Index Nested-Loop Join 算法会读取驱动表的所有数据，首先扫描的行数是驱动表的总行数（假设为 n），然后遍历这 n 行数据中关联字段的值，根据驱动表中关联字段的值索引扫描被驱动表中的对应行，这里又会扫描 n 行，因此整个过程扫描了 2n 行。当使用 Index Nested-Loop Join 算法时，扫描行数跟驱动表的数据量成正比。所以<strong>在写 SQL 时，如果确定被关联字段有索引的情况下，建议用小表做驱动表。</strong></p><p>我们来看下以 t2 为驱动表的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> t2.a <span class="operator">=</span> t1.a;</span><br></pre></td></tr></table></figure><p>这里使用 straight_join 可以固定连接方式，让前面的表为驱动表。</p><h4 id="2-3-临时表">2.3 临时表</h4><p>多数情况我们可以通过在被驱动表的关联字段上加索引来让 join 使用 NLJ 或者 BKA，但有时因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源，那么有什么办法优化呢？</p><p>这里提供一种创建临时表的方法。比如下面这条关联查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b<span class="operator">=</span> t2.b;</span><br></pre></td></tr></table></figure><p>看下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span><br></pre></td></tr></table></figure><p>由于表 t1 和表 t2 的字段 b都没索引，因此使用的是效率比较低的 BNL 算法。</p><p>现在用临时表的方法对这条 SQL 进行优化：</p><p>首先创建临时表 t1_tmp，表结构与表 t1 一致，只是在关联字段 b 上添加了索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> `t1_tmp` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录创建时间&#x27;</span>,</span><br><span class="line">    `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;记录更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_a` (`a`),</span><br><span class="line">    KEY `idx_b` (b)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB ;</span><br></pre></td></tr></table></figure><p>把 t1 表中的数据写入临时表 t1_tmp 中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1_tmp <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><p>执行 join 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1_tmp <span class="keyword">join</span> t2 <span class="keyword">on</span> t1_tmp.b<span class="operator">=</span> t2.b;</span><br></pre></td></tr></table></figure><p>我们再看下执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t2     | NULL       | ALL  | NULL          | NULL  | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1_tmp | NULL       | ref  | idx_b         | idx_b | 5       | muke.t2.b |    1 |   100.00 | NULL        |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>Extra 没出现 “Block Nested Loop”，说明使用的是 Index Nested-Loop Join，并且扫描行数也大大降低了。</p><p><strong>所以当遇到 BNL 的 join 语句，如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询</strong></p><h2 id="09-为何count-这么慢"><strong>09 为何count(*)这么慢?</strong></h2><h3 id="1-重新认识-count">1 重新认识 count()</h3><h4 id="1-1-count-a-和-count-的区别">1.1 count(a) 和 count(*) 的区别</h4><p>当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。</p><p>而 <code>count(*)</code> 无论是否包含空值，都会统计。</p><h4 id="1-2-MyISAM-引擎和-InnoDB-引擎-count-的区别">1.2 MyISAM 引擎和 InnoDB 引擎 count(*) 的区别</h4><p>对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 <code>count(*)</code> 将会非常快。因为 MyISAM 引擎会把表的总行数存在磁盘上。</p><p>首先我们看下对 t2 表（存储引擎为 MyISAM）不带 where 子句做 <code>count(*)</code> 的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t2;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br></pre></td></tr></table></figure><p>在 Extra 字段发现 “Select tables optimized away” 关键字，表示是从 MyISAM 引擎维护的准确行数上获取到的统计值。</p><p>而 InnoDB 并不会保留表中的行数，<strong>因为并发事务可能同时读取到不同的行数</strong>。所以执行 <code>count(*)</code> 时都是临时去计算的，会比 MyISAM 引擎慢很多。</p><p>我们看下对 t1 表（存储引擎为 InnoDB）执行 <code>count(*)</code> 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select count(*) from t1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>发现使用的是 b 字段的索引 idx_b，并且扫描行数是10109，表示会遍历 b 字段的索引树去计算表的总量。</p><p>对比 MyISAM 引擎和 InnoDB 引擎 <code>count(*)</code> 的区别，可以知道：</p><ul><li>MyISAM 会维护表的总行数，放在磁盘中，如果有 <code>count(*)</code> 的需求，直接返回这个数据</li><li>但是 InnoDB 就会去遍历普通索引树，计算表数据总量</li></ul><p>在上面这个例子，InnoDB 表 t1 在执行 <code>count(*)</code> 时，为什么会走 b 字段的索引而不是走主键索引呢？下面我们分析下：</p><h4 id="1-3-MySQL-5-7-18-前后-count-的区别">1.3 MySQL 5.7.18 前后 count(*) 的区别</h4><p>在 MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 <code>count(*)</code> 语句。</p><p>从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句。如果不存在二级索引，则扫描聚簇索引。但是，如果索引记录不完全在缓存池中的话，处理 <code>count(*)</code> 也是比较久的。</p><p>新版本为什么会使用二级索引来处理 <code>count(*)</code> 语句呢？</p><p>原因是 InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 <code>count (*)</code> 快。</p><h4 id="1-4-count-1-比-count-快吗？">1.4 count(1) 比 count(*) 快吗？</h4><p>在前面我们知道 <code>count(*)</code> 无论是否包含空值，所有结果都会统计。</p><p>而 count(1)中的 1 是恒真表达式，因此也会统计所有结果。</p><p>所以 count(1) 和 <code>count(*)</code> 统计结果没差别。</p><p>我们来对比 count(1) 和 count(* ) 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select count(1) from t1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from t1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+</span><br></pre></td></tr></table></figure><p>执行计划一样，所以 count(1) 并不比 count(*) 快。</p><h3 id="2-哪些方法可以加快-count">2 哪些方法可以加快 count()</h3><h4 id="2-1-show-table-status">2.1 show table status</h4><p>有时，我们只需要知道某张表的大概数据量，这种情况就可以使用 show table status，具体用法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;t1&#x27;</span>\G</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Rows: 10147</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Rows 这列就表示这张表的行数。这种方式获取 InnoDB 表的行数非常快。</p><p><strong>但是，这个值是个估算值，可能与实际值相差 40% 到 50%</strong>。（对于 Rows 这个字段更详细的解释，可以参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html%EF%BC%89">https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html）</a></p><h2 id="10-为什么添加索引能提高查询速度"><strong>10 为什么添加索引能提高查询速度?</strong></h2><p>为了便于理解 MySQL 的索引，我们先了解一些与索引相关的算法。</p><h3 id="1-跟索引相关的一些算法">1 跟索引相关的一些算法</h3><p>对于 MySQL 而言，使用最频繁的就是 B+ 树索引，所以我们必须要知道 B+ 树的结构，而 B+ 树是借鉴了二分查找法、二叉查找树、平衡二叉树、B 树的一些思想构建的。因此我们首先通过了解这些算法，来一层一层拨开 B+ 树的神秘面纱。</p><h4 id="1-1-二分查找法">1.1 二分查找法</h4><p>二分查找法的查找过程是：将记录按顺序排列，查找时先以有序列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将查询范围缩小为左半部分；如果要找的元素值大于该中点元素，则将查询范围缩小为右半部分。以此类推，直到查到需要的值。</p><h4 id="1-2-二叉查找树">1.2 二叉查找树</h4><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，并且每个节点最多只有两颗子树。</p><h4 id="1-3-平衡二叉树">1.3 平衡二叉树</h4><p>平衡二叉树的定义：满足二叉查找树的定义，另外必须满足任何节点的两个子树的高度差最大为 1。</p><h4 id="1-4-B-树">1.4 B 树</h4><p>B 树可以理解为一个节点可以拥有多于 2 个子节点的平衡多叉查找树。</p><p>B 树中同一键值不会出现多次，要么在叶子节点，要么在内节点上。</p><p>比如用 1、2、3、5、6、7、9 这些数字构建一个 B 树结构，其图形如下：</p><p>与平衡二叉树相比，B 树利用多个分支（平衡二叉树只有两个分支）节点，减少获取记录时所经历的节点数。</p><p>B 树也是有缺点的，因为每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，同样会有：”要经历多层节点才能查询在叶子节点的数据”的问题。这时，B+ 树站了出来。</p><h4 id="1-5-B-树">1.5 B+ 树</h4><p>B+ 树是 B 树的变体，定义基本与 B 树一致，与 B 树的不同点：</p><ul><li>所有叶子节点中包含了全部关键字的信息</li><li>各叶子节点用指针进行连接</li><li>非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。</li><li>B 树是纵向扩展，最终变成一个”瘦高个”，而 B+ 树是横向扩展的，最终会变成一个”矮胖子”（这里参考了《MySQL 运维内参》第 8 节 B+ 树及 B 树的区别中的比喻）。</li></ul><p>在 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上。B+ 树中的 B 不是代表二叉(binary) 而是代表（balance），B+ 树并不是一个二叉树。</p><p>还是根据前面提到的这组数字（1、2、3、5、6、7、9）举例，它的结构如下</p><p>与 1.4 中 B 树的结构最大的区别就是：</p><p>它的键一定会出现在叶子节点上，同时也有可能在非叶子节点中重复出现。而 B 树中同一键值不会出现多次</p><h3 id="2-B-树索引">2 B+ 树索引</h3><p>B+ 树索引就是基于本节前面介绍的 B+ 树发展而来的。在数据库中，B+ 树的高度一般都在 2 ~ 4 层，所以<strong>查找某一行数据最多只需要 2 到 4 次 IO。而没索引的情况，需要逐行扫描，明显效率低很多，这也就是为什么添加索引能提高查询速度。</strong></p><p>B+ 树索引并不能找到一个给定键值的具体行，B+ 树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到缓冲池（buffer pool）中，在内存中通过二分查找法进行查找，得到需要的数据。</p><p>InnoDB 中 B+ 树索引分为聚集索引和辅助索引，我们再继续了解这两种索引的特点。</p><p>为了方便理解，我们先创建一张测试表并写入数据：</p><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t8; <span class="comment">/* 如果表t1存在则删除表t1 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t8` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t8(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;e&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;f&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;g&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="2-1-聚集索引">2.1 聚集索引</h4><p>InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</p><p>InnoDB 的主键一定是聚集索引。如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，也有可能是 row id。</p><p>由于实际的数据页只能按照一颗 B+ 树进行排序，因此每张表只能有一个聚集索引（TokuDB 引擎除外）。查询优化器倾向于采用聚集索引，因为聚集索引能够在 B+ 树索引的叶子节点上直接找到数据。</p><p>聚集索引对于主键的排序查找和范围查找速度非常快。</p><p>对于刚刚创建好的测试表 t8的聚集索引的大致结构如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518224149464.png" alt="image-20240518224149464"></p><p>两点关键信息：</p><ul><li>根据主键值创建了 B+ 树结构</li><li>每个叶子节点包含了整行数据</li></ul><h4 id="2-2-辅助索引">2.2 辅助索引</h4><p>我们现在知道了聚集索引的叶子节点存放了整行数据，而 InnoDB 存储引擎辅助索引的叶子节点并不会放整行数据，而存放的是键值和主键 ID。</p><p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引来找到对应的行数据。</p><p>比如一颗高度为 3 的辅助索引树中查找数据，那需要对这颗辅助索引树遍历 3 次找到指定主键，如果聚集索引树的高度也为 3，那么还需要对聚集索引树进行 3 次查找，最终找到一个完整的行数据所在的页，因此获取数据一共需要6次逻辑 IO 访问。</p><p>我们继续拿表 t8 分析，它的辅助索引 idx_a 结构如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518224208146.png" alt="image-20240518224208146"></p><p>上图中两点关键点需要注意：</p><ul><li>根据 a 字段的值创建了 B+ 树结构</li><li>每个叶子节点保存的是 a 字段自己的键值和主键 ID</li></ul><p>对于表 t8，比如有下面这条查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t8 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>它先通过 a 字段上的索引树，得到主键 id 为 3，再到 id 的聚集索引树上找到对应的行数据。</p><p>而下面这条 SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t8 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>查询到的结果是一样的，而执行过程则只需要搜索 id 的聚集索引树。我们能看出辅助索引的查询比主键查询多扫描一颗索引树，所以，我们应该<strong>尽量使用主键做为条件进行查询</strong>。</p><h2 id="11-哪些情况需要添加索引？"><strong>11 哪些情况需要添加索引？</strong></h2><p>首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t9_1; <span class="comment">/* 如果表t9_1存在则删除表t9_1 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t9_1` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a` (`a`),</span><br><span class="line">KEY `idx_b_c` (`b`,`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t9_1; <span class="comment">/* 如果存在存储过程insert_t9_1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t9_1() <span class="comment">/* 创建存储过程insert_t9_1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do <span class="comment">/* 对满足i&lt;=100000的值进行while循环 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t9_1中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入100000条数据到表t9_1的存储过程insert_t9_1 */</span></span><br><span class="line"><span class="keyword">call</span> insert_t9_1(); <span class="comment">/* 运行存储过程insert_t9_1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t9_1(a,b,c,d) <span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> t9_1;</span><br><span class="line"><span class="comment">/*  把t9_1的数据量扩大到160万 */</span></span><br></pre></td></tr></table></figure><p>目前比较常见需要创建索引的场景有：数据检索时在条件字段添加索引、聚合函数对聚合字段添加索引、对排序字段添加索引、为了防止回表添加索引、关联查询在关联字段添加索引等。我们就一一分析这些需要创建索引的场景：</p><h3 id="1-数据检索">1 数据检索</h3><p>用上面的表 t9_1 做测试，首先把没有索引的字段 d 作为条件进行查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t9_1 <span class="keyword">where</span> d <span class="operator">=</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>发现查询时间需要0.44 秒</p><p>再把有索引的字段 a 作为条件进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t9_1 <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>发现查询时间为 0.00 sec，表示执行时间不超过 10 毫秒，非常快。</p><p>我们再对比两条 SQL 的执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t9_1 where d = 90000;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t9_1  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 3192096 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t9_1 where a = 90000;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t9_1  | NULL       | ref  | idx_a         | idx_a | 5       | const |   32 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>前者 type 字段为 ALL，后者 type 字段为 ref，显然后者性能更好</p><p>rows 这个字段前者是 3192096，而后者是 32，有索引的情况扫描行数大大降低。</p><p>因此建议数据检索时，在条件字段添加索引。</p><h3 id="2-聚合函数">2 聚合函数</h3><p>在测试表 t9_1 中，如果要求出无索引字段 d 的最大值，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(d) <span class="keyword">from</span> t9_1;</span><br></pre></td></tr></table></figure><p>执行时间为 0.33 秒。</p><p>再看下求有索引的字段 a 的最大值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(a) <span class="keyword">from</span> t9_1;</span><br></pre></td></tr></table></figure><p>执行时间为 0.00 秒，表示执行时间不超过 10 毫秒。</p><p>相比对没有索引的字段 d 求最大值（花费330毫秒），<strong>显然索引能提升 max() 函数的效率，同理也能提升 min() 函数的效率</strong>。</p><p>在第 7 节中的 1.3 小节中有介绍 MySQL 5.7.18 之后版本的 <code>count(*)</code> 特点：从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句，如果不存在二级索引，则扫描聚簇索引。原因是：InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。</p><p><strong>因此索引对聚合函数 count(*) 也有优化作用。</strong></p><h3 id="3-排序">3 排序</h3><p>在第 4 节 2.1 小节，我们列出了几种通过添加合适索引优化 order by 的方法，这里再做一次总结（如果对下面的总结不是很理解，可以复习第 4 节的内容，有对每种情况举例说明）：</p><ul><li>如果对单个字段排序，则可以在这个排序字段上添加索引来优化排序语句；</li><li>如果是多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句；</li><li>如果是先等值查询再排序，可以通过在条件字段和排序字段添加联合索引来优化排序语句。</li></ul><h3 id="4-避免回表">4 避免回表</h3><p>比如下面这条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,d <span class="keyword">from</span> t9_1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>可以走 a 字段的索引，但是在学了第 8 节后，我们知道了辅助索引的结构，如果通过辅助索引来寻找数据，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引回表去找对应的行数据。</p><p>但是，如果条件字段和需要查询的字段有联合索引的话，其实回表这一步就省了，因为联合索引中包含了这两个字段的值。像这种索引就已经覆盖了我们的查询需求的场景，我们称为：覆盖索引。比如下面这条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b,c <span class="keyword">from</span> t9_1 <span class="keyword">where</span> b<span class="operator">=</span><span class="number">90000</span>;</span><br></pre></td></tr></table></figure><p>可直接通过联合索引 idx_b_c 找到 b、c 的值（联合索引详细讲解将放在第 11 节）。</p><p><strong>所以可以通过添加覆盖索引让 SQL 不需要回表，从而减少树的搜索次数，让查询更快地返回结果。</strong></p><h3 id="5-关联查询">5 关联查询</h3><p>在第 6 节中，我们讲到了关联查询的一些优化技巧，其中一个优化方式就是：通过在关联字段添加索引，让 BNL变成 NLJ 或者 BKA。</p><h3 id="6-总结-2">6 总结</h3><p>本节讲解了常见需要添加索引的场景：</p><ul><li>数据检索时在条件字段添加索引</li><li>聚合函数对聚合字段添加索引</li><li>对排序字段添加索引</li><li>为了防止回表添加索引</li><li>关联查询在关联字段添加索引</li></ul><h2 id="12-普通索引和唯一索引有哪些区别？"><strong>12 普通索引和唯一索引有哪些区别？</strong></h2><p>对于普通索引和唯一索引的区别，也许你已经知道：有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。其实对于 MySQL 来说，不止这一种区别。今天我们就再深入探究一下普通索引和唯一索引的区别。</p><p>在讨论两者的区别前，我们首先学习一下 Insert Buffer 和 Change Buffer。</p><h3 id="1-Insert-Buffer">1 Insert Buffer</h3><p>对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入；如果不在，则先放入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。这时通常能将多个插入合并到一个操作中（因为在一个索引页中），就大大提高了非聚集索引的插入性能。</p><blockquote><p>增加 Insert Buffer 有两个好处：</p><ul><li>减少磁盘的离散读取</li><li>将多次插入合并为一次操作</li></ul></blockquote><p>但是得注意的是，使用 Insert Buffer 得满足两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><h3 id="2-Change-Buffer">2 Change Buffer</h3><p>InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。</p><p>影响参数有两个：</p><ul><li>innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、changes、purges、all。默认为 all，表示启用所有。</li><li>innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示最多可以使用 buffer pool 的 25%，最大值50。</li></ul><p>跟 Insert Buffer 一样，Change Buffer 也得满足这两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><p>为什么唯一索引的更新不使用 Change Buffer ?</p><p>原因：唯一索引<strong>必须要将数据页读入内存才能判断是否违反唯一性约束</strong>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。</p><h3 id="3-普通索引和唯一索引的区别">3 普通索引和唯一索引的区别</h3><p>通过上面对 Insert Buffer 和 Change Buffer 的了解，也许你已经知道了普通索引和唯一索引的另外一种区别：<strong>如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。</strong></p><p>在上面讲解 Change Buffer 时，也提到了修改唯一索引必须判断是否违反唯一性约束，其实在 RR 隔离级别（事务隔离级别将在第 4 章重点讲解）下，可能会出现一个比较严重的问题：死锁。</p><p>那么查询过程两者的区别呢？</p><p>对于普通索引，查找到满足条件的第一个记录，还需要查找下一个记录，直到不满足条件。</p><p>对于唯一索引来说，查找到第一个记录返回结果就结束了。</p><p>但是 InnoDB 是按页从磁盘读取的，所以很大可能根据该普通索引查询的数据都在一个数据页里，因此如果通过普通索引查找到第一条满足条件所在的数据页，再查找后面的记录很大概率都在之前的数据页里，也就是多了几次内存扫描，实际这种消耗可以忽略不计。</p><p>这里总结一下普通索引和唯一索引的隐藏区别：</p><ul><li>数据修改时，普通索引可以用 Change Buffer，而唯一索引不行。</li><li>数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。</li><li>查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。</li></ul><h3 id="4-普通索引和唯一索引如何选择">4 普通索引和唯一索引如何选择</h3><p>上面说了普通索引和唯一索引的区别，那么两者应该如何选择呢？</p><p>如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引，让这个字段唯一，该字段新增重复数据时，将报类似如下的错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;f1&#x27;</span><br></pre></td></tr></table></figure><p>如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。 因为普通索引可以使用 Change Buffer，并且出现死锁的概率比唯一索引低。</p><h3 id="5-总结">5 总结</h3><p>普通索引和唯一索引的区别：</p><ul><li>有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。</li><li>数据修改时，普通索引优于唯一索引，因为普通索引可以用 Change Buffer，并且 RR 隔离级别下，出现死锁的概率比唯一索引低。</li><li>查询数据时，两者性能差别不大。</li></ul><h2 id="13-联合索引有哪些讲究"><strong>13 联合索引有哪些讲究?</strong></h2><h3 id="1-认识联合索引">1 认识联合索引</h3><p>联合索引：是指对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。</p><p>我们拿讲解 order by 时使用的联合索引 B+ 树图进行理解，如下图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240518224509953.png" alt="image-20240518224509953"></p><p>联合索引的键值数量大于 1（比如上图中有 a 和 b 两个键值），与单个键值的 B+ 树一样，也是按照键值排序的。<strong>对于 a、b 两个字段都做为条件时，查询是可以走索引的；对于单独 a 字段查询也是可以走索引的。但是对于 b 字段单独查询就走不了索引了。</strong></p><p>联合索引的建议：</p><ul><li>where 条件中，经常同时出现的列放在联合索引中。</li><li>把选择性最大的列放在联合索引的最左边。</li></ul><p>老规矩，创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t11; <span class="comment">/* 如果表t11存在则删除表t11 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t11` ( <span class="comment">/* 创建表t11 */</span></span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`b` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`d` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_a_b_c` (`a`,`b`,`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8mb4 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t11(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>); <span class="comment">/* 写入一些数据 */</span></span><br></pre></td></tr></table></figure><h3 id="2-联合索引使用分析">2 联合索引使用分析</h3><h4 id="2-1-可以完整用到联合索引的情况">2 .1 可以完整用到联合索引的情况</h4><p>下面我们列出几种可以完整用到联合索引的情况，并查看其执行计划，然后进行简短的分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* sql1 */</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>explain 中的 key_len 列用于表示这次查询中，所选择的索引长度有多少字节，常用于判断联合索引有多少列被选择了。下表总结了常用字段类型的 key_len：</p><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">KEY_LEN</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:left">key_len = 4+1</td><td style="text-align:left">int 为 4 bytes，允许为 NULL，加 1 byte</td></tr><tr><td style="text-align:left">int not null</td><td style="text-align:left">key_len = 4</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">bigint</td><td style="text-align:left">key_len=8+1</td><td style="text-align:left">bigint 为 8 bytes，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">bigint not null</td><td style="text-align:left">key_len=8</td><td style="text-align:left">bigint 为 8 bytes</td></tr><tr><td style="text-align:left">char(30) utf8</td><td style="text-align:left">key_len=30*3+1</td><td style="text-align:left">char(n)为：n * 3 ，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">char(30) not null utf8</td><td style="text-align:left">key_len=30*3</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">varchar(30) not null utf8</td><td style="text-align:left">key_len=30*3+2</td><td style="text-align:left">utf8 每个字符为 3 bytes，变长数据类型,加 2 bytes</td></tr><tr><td style="text-align:left">varchar(30) utf8</td><td style="text-align:left">key_len=30*3+2+1</td><td style="text-align:left">utf8 每个字符为 3 bytes，允许为 NULL,加 1 byte,变长数据类型，加 2 bytes</td></tr><tr><td style="text-align:left">datetime</td><td style="text-align:left">key_len=8+1 (MySQL 5.6.4之前的版本)；key_len=5+1(MySQL 5.6.4及之后的版本)</td><td style="text-align:left">允许为 NULL，加 1 byte</td></tr></tbody></table><p>因为 a、b、c 三个字段都是可以为 NULL 的 int 型。可以知道三个字段的 key_len 都是 5，所以如果完整使用索引 idx_a_b_c，则 key_len 对应的值为 15。再回到上面 sql1 的执行计划中：key_len 显示是 15，而 key 列对应的是 idx_a_b_c，所以 sql1 完整用到了联合索引 idx_a_b_c。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> c<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> a<span class="operator">=</span><span class="number">1</span>;  <span class="comment">/* sql2 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>跟 sql1 的执行计划一样，因此联合索引各字段都做为条件时，各字段的位置不会影响联合索引的使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> b <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">and</span> c<span class="operator">=</span><span class="number">2</span>;  <span class="comment">/* sql3 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 15      | NULL |    2 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><p>当联合索引前面的字段使用了范围查询，后面的字段做为条件时仍然可以使用完整的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> c;  <span class="comment">/* sql4 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    4 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>联合索引前面的字段做为条件时，对后面的字段做排序可以使用完整的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b,c;  <span class="comment">/* sql5 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>与 sql4 相似，对联合索引第一个字段做条件筛选时，对后面两个字段做排序可以使用完整的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> a,b,c <span class="keyword">from</span> t11 <span class="keyword">order</span> <span class="keyword">by</span> a,b,c;  <span class="comment">/* sql6 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | index | NULL          | idx_a_b_c | 15      | NULL |   15 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>对联合索引的字段同时做排序时（但是排序的三个字段顺序要跟联合索引中三个字段的顺序一致），可以完整用到联合索引。</p><h4 id="2-2-只能使用部分联合索引的情况">2.2 只能使用部分联合索引的情况</h4><p>有些场景只能用到部分联合索引，这里就列出几种情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* sql11 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>当条件只包含联合索引的前面部分字段时，可以用到部分联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">1</span>; <span class="comment">/* sql12 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |    10.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure><p>对于联合索引 idx_a_b_c（a,b,c） ，如果条件中只包含 a 和 c，则只能用到联合索引中 a 的索引。c 这里是用不了索引的。<strong>联合索引 idx_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c) 三种索引，称为联合索引的最左原则。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t11 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">2</span>  <span class="keyword">and</span> b <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">order</span> <span class="keyword">by</span> c; <span class="comment">/* sql13 */</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 10      | NULL |    2 |   100.00 | Using index condition; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+</span><br></pre></td></tr></table></figure><p>这里可以复习第 4 节 2.4，<strong>当联合索引前面的字段使用了范围查询，对后面的字段排序使用不了索引排序</strong>，也就是只能用到联合索引前面两个字段 a 和 b 的索引。</p><p>​</p>]]></content>
    
    
    <summary type="html">《一线数据库工程师带你深入理解MySQL》</summary>
    
    
    
    <category term="MySQL" scheme="https://penge666.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://penge666.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>并发练手</title>
    <link href="https://penge666.github.io/posts/624cfcb.html"/>
    <id>https://penge666.github.io/posts/624cfcb.html</id>
    <published>2024-05-16T14:42:12.000Z</published>
    <updated>2024-05-17T10:05:09.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经典并发案例~</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="thread传参"><a href="#thread传参" class="headerlink" title="thread传参"></a>thread传参</h3><p>推荐博客</p><ul><li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/129642800?spm=1001.2014.3001.5501">C++ thread线程函数传参原理剖析</a></li></ul><p>thread函数都会把参数转成右值!</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>信号量的类型：<code>sem_t</code></li><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><ul><li>功能：初始化信号量</li><li>参数<ul><li><code>sem</code>：信号量变量的地址</li><li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li><li><code>value</code>：信号量中的值，代表容器大小</li></ul></li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p><ul><li>功能：释放资源</li></ul></li><li><code>int sem_wait(sem_t *sem);</code>【wait先判断再-】<ul><li>如果信号量的值大于0，<code>sem_wait</code>会立即返回，并将信号量的值减少1。</li><li>如果信号量的值为0，<code>sem_wait</code>会阻塞，直到信号量的值变得大于0。这通常发生在另一个线程或进程增加了信号量的值，表示它已经释放了它先前持有的资源。</li></ul></li><li><code>int sem_trywait(sem_t *sem);</code></li><li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li><li><p><code>int sem_post(sem_t *sem);</code></p><ul><li>功能：对信号量解锁，调用一次对信号量的值+1</li></ul></li><li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li></ul><h3 id="future-promise和async"><a href="#future-promise和async" class="headerlink" title="future, promise和async"></a>future, promise和async</h3><p>学习自：<a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2VWIJgH3zKEww0BpLnYQX0NMpQ9">C++ 并发三剑客future, promise和async</a></p><p><strong>async</strong></p><p><code>std::async</code> 是一个用于异步执行函数的模板函数，它返回一个 <code>std::future</code> 对象，该对象用于获取函数的返回值。</p><p>启动策略：</p><ol><li><code>std::launch::deferred</code>：这种策略意味着任务将在调用<code>std::future::get()</code>或<code>std::future::wait()</code>函数时延迟执行。换句话说，任务将在需要结果时同步执行。</li><li><code>std::launch::async</code> 函数异步执行</li><li><code>std::launch::async | std::launch::deferred</code>：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res = <span class="built_in">async</span>(std::launch::deferred, fun, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;go here&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> cur = res.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>future</strong></p><ul><li><code>std::future::get()</code> 用于获取并返回任务的结果，而 <code>std::future::wait()</code> 只是等待任务完成。</li><li><code>get()</code> 只能调用一次，而 <code>wait()</code> 可以被多次调用。</li><li>如果任务还没有完成，<code>get()</code> 和 <code>wait()</code> 都会阻塞当前线程，但 <code>get()</code> 会一直阻塞直到任务完成并返回结果，而 <code>wait()</code> 只是在等待任务完成。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_package</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离，以便主线程可以等待任务完成</span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_package</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(fun)</span></span>;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">1</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promise和future结合【<code>std::promise</code>用于在某一线程中设置某个值或异常，而<code>std::future</code>则用于在另一线程中获取这个值或异常】</p><p>在C++中，<code>std::promise</code> 和 <code>std::future</code> 是一对配套的类，用于在不同线程之间传递值.【经典例子】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(fun, std::move(prom))</span></span>;</span><br><span class="line">    cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="按序打印"><a href="#按序打印" class="headerlink" title="按序打印"></a>按序打印</h3><p><a href="https://leetcode.cn/problems/print-in-order/">1114. 按序打印</a></p><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span>()</span> &#123; print(<span class="string">&quot;first&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span>()</span> &#123; print(<span class="string">&quot;second&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span>()</span> &#123; print(<span class="string">&quot;third&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个不同的线程 A、B、C 将会共用一个 <code>Foo</code> 实例。</p><ul><li>线程 A 将会调用 <code>first()</code> 方法</li><li>线程 B 将会调用 <code>second()</code> 方法</li><li>线程 C 将会调用 <code>third()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p><p><strong>提示：</strong></p><ul><li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li><li>你看到的输入格式主要是为了确保测试的全面性。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1,2,3]</span></span><br><span class="line">输出：<span class="string">&quot;firstsecondthird&quot;</span></span><br><span class="line">解释：</span><br><span class="line">有三个线程会被异步启动。输入 <span class="selector-attr">[1,2,3]</span> 表示线程 A 将会调用 <span class="built_in">first</span>() 方法，线程 B 将会调用 <span class="built_in">second</span>() 方法，线程 C 将会调用 <span class="built_in">third</span>() 方法。正确的输出是 <span class="string">&quot;firstsecondthird&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1,3,2]</span></span><br><span class="line">输出：<span class="string">&quot;firstsecondthird&quot;</span></span><br><span class="line">解释：</span><br><span class="line">输入 <span class="selector-attr">[1,3,2]</span> 表示线程 A 将会调用 <span class="built_in">first</span>() 方法，线程 B 将会调用 <span class="built_in">third</span>() 方法，线程 C 将会调用 <span class="built_in">second</span>() 方法。正确的输出是 <span class="string">&quot;firstsecondthird&quot;</span>。</span><br></pre></td></tr></table></figure><p>（1）信号量</p><p>信号量是用来实现对共享资源的同步访问的机制，通过主动等待和主动唤醒来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> firstJobDone;</span><br><span class="line">    <span class="type">sem_t</span> secondJobDone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;firstJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;secondJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;firstJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;firstJobDone);</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;secondJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;secondJobDone);</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）互斥锁</p><p>互斥锁是用来防止多个线程同时访问共享资源对象的机制，在同一时间只有一个线程可以拥有一个特定的锁对象，其他线程如果尝试获取锁会阻塞直到锁资源被释放或直接返回失败。</p><p>针对这道题我们可以用两个互斥锁来阻塞 second 和 third 函数，分别在 first 和 second 执行结束后解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mx1, mx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mx1.<span class="built_in">lock</span>();</span><br><span class="line">        mx2.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        mx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        mx1.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        mx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        mx2.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）条件变量</p><p>条件变量一般和互斥锁搭配使用，互斥锁用于上锁，条件变量用于在多线程环境中等待特定事件发生。这里一把锁和2把锁都是OK的！</p><ul><li><a href="https://zhuanlan.zhihu.com/p/340348726">C++11多线程编程(三)——lock_guard和unique_lock</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                &#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);</span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        k = <span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                &#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）异步操作</p><p>异步操作是一种，在不需要等待被调用方返回结果之前，就让操作继续进行下去的方法。针对这道题可以使用基于 future/promise 的异步编程模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; num1, num2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        num1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = num1.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        num2.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="type">int</span> num = num2.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）原子操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">while</span> (!b)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printFirst</span>();</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">printSecond</span>();</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">while</span> (!b)</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printThird</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;Foo::first, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;Foo::second, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;Foo::third, &amp;foo, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交替打印-FooBar"><a href="#交替打印-FooBar" class="headerlink" title="交替打印 FooBar"></a>交替打印 FooBar</h3><p><a href="https://leetcode.cn/problems/print-foobar-alternately/">交替打印 FooBar</a></p><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同的线程将会共用一个 <code>FooBar</code> 实例：</p><ul><li>线程 A 将会调用 <code>foo()</code> 方法，而</li><li>线程 B 将会调用 <code>bar()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>&quot;foobar&quot;</code> 被输出 <code>n</code> 次。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;foobar&quot;</span></span><br><span class="line">解释：这里有两个线程被异步启动。其中一个调用 <span class="built_in">foo</span>() 方法, 另一个调用 <span class="built_in">bar</span>() 方法，<span class="string">&quot;foobar&quot;</span> 将被输出一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;foobarfoobar&quot;</span></span><br><span class="line">解释：<span class="string">&quot;foobar&quot;</span> 将被输出两次。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>（1）信号量</p><p>将其中一个信号量设置成1就可以啦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> sem1, sem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;sem2);</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;sem1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;sem1);</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;sem2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FooBar <span class="title">fooBar</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;FooBar::foo, &amp;fooBar, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;FooBar::bar, &amp;fooBar, [&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;bar&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int num1 = 0;</span></span><br><span class="line">    <span class="comment">// sem_getvalue(&amp;foo.firstJobDone, &amp;num1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 互斥锁</p><p>和上一题类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    mutex mxt1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        mxt1.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            mtx2.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            mxt1.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            mxt1.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(3)条件变量</p><p>和上一道的条件变量类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            k = <span class="number">2</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（4）异步编程</p><p><strong>Note</strong>：在你的代码中，你使用了 <code>std::promise</code> 和 <code>std::future</code> 来同步 <code>foo</code> 和 <code>bar</code> 方法。然而，你在每个循环迭代中都调用了 <code>get()</code> 方法，这导致了问题。<code>std::future::get()</code> 方法只能被调用一次，因为它会移动（而不是复制）值。如果你尝试第二次调用 <code>get()</code>，会抛出一个 <code>std::future_error</code> 异常。</p><p>解决这个问题的一种方法是在每次迭代中重新创建 <code>std::promise</code> 和 <code>std::future</code> 对象。你可以在循环的每一次迭代后用新的 <code>std::promise</code> 对象替换旧的对象，然后从新的 <code>std::promise</code> 对象获取新的 <code>std::future</code> 对象。</p><p>不过我这里用投机的方式创建一个新的对象即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        p1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            p1.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            p1 = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            p2.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            p2.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            p2 = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">            p1.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用promise和future结合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; aa, bb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        aa = a.<span class="built_in">get_future</span>();</span><br><span class="line">        bb = b.<span class="built_in">get_future</span>();</span><br><span class="line">        b.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="type">int</span> tmp = bb.<span class="built_in">get</span>();</span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            promise&lt;<span class="type">int</span>&gt; tmp_b;</span><br><span class="line">            future&lt;<span class="type">int</span>&gt; tmp_bb;</span><br><span class="line">            b = <span class="built_in">move</span>(tmp_b);</span><br><span class="line">            bb = <span class="built_in">move</span>(tmp_bb);</span><br><span class="line">            bb = b.<span class="built_in">get_future</span>();</span><br><span class="line">            a.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="type">int</span> tmp = aa.<span class="built_in">get</span>();</span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            promise&lt;<span class="type">int</span>&gt; tmp_a;</span><br><span class="line">            future&lt;<span class="type">int</span>&gt; tmp_aa;</span><br><span class="line">            a = <span class="built_in">move</span>(tmp_a);</span><br><span class="line">            aa = <span class="built_in">move</span>(tmp_aa);</span><br><span class="line">            aa = a.<span class="built_in">get_future</span>();</span><br><span class="line">            b.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（5）原子操作</p><p>貌似用不用atomic都可以~可能这才是最纯粹的控制并发的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> a&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span> (a)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            a = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span> (!a)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            a = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="打印零与奇偶数"><a href="#打印零与奇偶数" class="headerlink" title="打印零与奇偶数"></a>打印零与奇偶数</h3><p><a href="https://leetcode.cn/problems/print-zero-even-odd/">打印零与奇偶数</a></p><p>现有函数 <code>printNumber</code> 可以用一个整数参数调用，并输出该整数到控制台。</p><ul><li>例如，调用 <code>printNumber(7)</code> 将会输出 <code>7</code> 到控制台。</li></ul><p>给你类 <code>ZeroEvenOdd</code> 的一个实例，该类中有三个函数：<code>zero</code>、<code>even</code> 和 <code>odd</code> 。<code>ZeroEvenOdd</code> 的相同实例将会传递给三个不同线程：</p><ul><li><strong>线程 A：</strong>调用 <code>zero()</code> ，只输出 <code>0</code></li><li><strong>线程 B：</strong>调用 <code>even()</code> ，只输出偶数</li><li><strong>线程 C：</strong>调用 <code>odd()</code> ，只输出奇数</li></ul><p>修改给出的类，以输出序列 <code>&quot;010203040506...&quot;</code> ，其中序列的长度必须为 <code>2n</code> 。</p><p>实现 <code>ZeroEvenOdd</code> 类：</p><ul><li><code>ZeroEvenOdd(int n)</code> 用数字 <code>n</code> 初始化对象，表示需要输出的数。</li><li><code>void zero(printNumber)</code> 调用 <code>printNumber</code> 以输出一个 0 。</li><li><code>void even(printNumber)</code> 调用<code>printNumber</code> 以输出偶数。</li><li><code>void odd(printNumber)</code> 调用 <code>printNumber</code> 以输出奇数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;0102&quot;</span></span><br><span class="line">解释：三条线程异步执行，其中一个调用 zero()，另一个线程调用 <span class="built_in">even</span>()，最后一个线程调用<span class="built_in">odd</span>()。正确的输出为 <span class="string">&quot;0102&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="string">&quot;0102030405&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>（1）原子变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">cnt</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zeroEvenOdd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;ZeroEvenOdd::zero, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;ZeroEvenOdd::even, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;ZeroEvenOdd::odd, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）信号量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> zero1, even1, odd1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;zero1, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;even1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;odd1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;zero1);</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sem_post</span>(&amp;odd1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sem_post</span>(&amp;even1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;even1);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;zero1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;odd1);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;zero1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zeroEvenOdd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;ZeroEvenOdd::zero, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;ZeroEvenOdd::even, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;ZeroEvenOdd::odd, &amp;zeroEvenOdd, [&amp;](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)条件变量+互斥锁</p><p>记得要写notify_all()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx, mtx1, mtx2;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">flag</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">0</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">2</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123; <span class="keyword">return</span> flag == <span class="number">1</span>; &#125;);</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(4)互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroEvenOdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx, mtx1, mtx2;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroEvenOdd</span>(<span class="type">int</span> n) : <span class="built_in">flag</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx2.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx1.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">printNumber</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="H2O生成"><a href="#H2O生成" class="headerlink" title="H2O生成"></a>H2O生成</h3><p><a href="https://leetcode.cn/problems/building-h2o/">1117. H2O 生成</a></p><p>现在有两种线程，氧 <code>oxygen</code> 和氢 <code>hydrogen</code>，你的目标是组织这两种线程来产生水分子。</p><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 <code>releaseHydrogen</code> 和 <code>releaseOxygen</code> 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><ul><li>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</li><li>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</li></ul><p>书写满足这些限制条件的氢、氧线程同步代码。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">water</span> = <span class="string">&quot;HOH&quot;</span></span><br><span class="line">输出: <span class="string">&quot;HHO&quot;</span></span><br><span class="line">解释: <span class="string">&quot;HOH&quot;</span> 和 <span class="string">&quot;OHH&quot;</span> 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">water</span> = <span class="string">&quot;OOHHHH&quot;</span></span><br><span class="line">输出: <span class="string">&quot;HHOHHO&quot;</span></span><br><span class="line">解释: <span class="string">&quot;HOHHHO&quot;</span>, <span class="string">&quot;OHHHHO&quot;</span>, <span class="string">&quot;HHOHOH&quot;</span>, <span class="string">&quot;HOHHOH&quot;</span>, <span class="string">&quot;OHHHOH&quot;</span>, <span class="string">&quot;HHOOHH&quot;</span>, <span class="string">&quot;HOHOHH&quot;</span> 和 <span class="string">&quot;OHHOHH&quot;</span> 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 * n == water.length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>water[i] == &#39;O&#39; or &#39;H&#39;</code></li><li>输入字符串 <code>water</code> 中的 ‘H’ 总数将会是 <code>2 * n</code> 。</li><li>输入字符串 <code>water</code> 中的 ‘O’ 总数将会是 <code>n</code> 。</li></ul><p>思路：</p><p>一道典型的阅读理解题。</p><p>题目的意思是，要一个水分子，一个水分子的生成。一个水分子是两个H一个O，也就是要运行两次hydrogen和一次oxygen。要想保证水分子正常生成，那么当有了2个H时，就不能再，执行hydrogen了，它就要等。同理，当有了1个O时，就不能再执行oxygen，就要等。</p><p>同时，当任何时候凑够了2个H，1个O时，也即能生成水分子时，就要把计数重置，以生成下一个水分子。</p><p>一个水分子内部，是不用管顺序的，也即HHO，OHH，HOH都是合法的。</p><p>互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H2O</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx1,mtx2;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">H2O</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hydrogen</span><span class="params">(function&lt;<span class="type">void</span>()&gt; releaseHydrogen)</span> </span>&#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">releaseHydrogen</span>();</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>) mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oxygen</span><span class="params">(function&lt;<span class="type">void</span>()&gt; releaseOxygen)</span> </span>&#123;</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.</span></span><br><span class="line">        <span class="built_in">releaseOxygen</span>();</span><br><span class="line">        cnt+=<span class="number">2</span>;</span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交替打印字符串"><a href="#交替打印字符串" class="headerlink" title="交替打印字符串"></a>交替打印字符串</h3><p><a href="https://leetcode.cn/problems/fizz-buzz-multithreaded/"> 交替打印字符串</a></p><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><ul><li>如果这个数字可以被 3 整除，输出 “fizz”。</li><li>如果这个数字可以被 5 整除，输出 “buzz”。</li><li>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。</li></ul><p>例如，当 <code>n = 15</code>，输出： <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>。</p><p>假设有这么一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">FizzBuzz</span>(int n) &#123; ... &#125;               <span class="comment">// constructor</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fizz</span>(<span class="params">printFizz</span>) &#123; ... &#125;          <span class="comment">// only output &quot;fizz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">buzz</span>(<span class="params">printBuzz</span>) &#123; ... &#125;          <span class="comment">// only output &quot;buzz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fizzbuzz</span>(<span class="params">printFizzBuzz</span>) &#123; ... &#125;  <span class="comment">// only output &quot;fizzbuzz&quot;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">number</span>(<span class="params">printNumber</span>) &#123; ... &#125;      <span class="comment">// only output the numbers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请你实现一个有四个线程的多线程版 <code>FizzBuzz</code>， 同一个 <code>FizzBuzz</code> 实例会被如下四个线程使用：</p><ol><li>线程A将调用 <code>fizz()</code> 来判断是否能被 3 整除，如果可以，则输出 <code>fizz</code>。</li><li>线程B将调用 <code>buzz()</code> 来判断是否能被 5 整除，如果可以，则输出 <code>buzz</code>。</li><li>线程C将调用 <code>fizzbuzz()</code> 来判断是否同时能被 3 和 5 整除，如果可以，则输出 <code>fizzbuzz</code>。</li><li>线程D将调用 <code>number()</code> 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li></ol><p><strong>提示：</strong></p><ul><li>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分。</li></ul><p>1.互斥锁+条件变量</p><p>一波暴力出奇迹~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FizzBuzz</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz() outputs &quot;fizz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;cnt%<span class="number">5</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printFizz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz() outputs &quot;buzz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buzz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBuzz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">3</span>!=<span class="number">0</span>&amp;&amp;cnt%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printBuzz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz() outputs &quot;fizzbuzz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizzbuzz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizzBuzz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">5</span>==<span class="number">0</span>&amp;&amp;cnt%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printFizzBuzz</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">number</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; printNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">                    &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">5</span>==<span class="number">0</span>||cnt%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            <span class="built_in">printNumber</span>(cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FizzBuzz <span class="title">tmp</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;FizzBuzz::fizz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;fizz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;FizzBuzz::buzz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;buzz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;FizzBuzz::fizzbuzz, &amp;tmp, []()</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; <span class="string">&quot;fizzbuzz&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(&amp;FizzBuzz::number, &amp;tmp, [](<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123; cout &lt;&lt; num &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><p><a href="https://leetcode.cn/problems/the-dining-philosophers/">哲学家进餐</a></p><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p><p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p><p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240517094400802.png" alt="image-20240517094400802"></p><p>哲学家从 <strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数 <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</p><ul><li><code>philosopher</code> 哲学家的编号。</li><li><code>pickLeftFork</code> 和 <code>pickRightFork</code> 表示拿起左边或右边的叉子。</li><li><code>eat</code> 表示吃面。</li><li><code>putLeftFork</code> 和 <code>putRightFork</code> 表示放下左边或右边的叉子。</li><li>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</li></ul><p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。 </p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]</span><br><span class="line">解释:</span><br><span class="line">n 表示每个哲学家需要进餐的次数。</span><br><span class="line">输出数组描述了叉子的控制和进餐的调用，它的格式如下：</span><br><span class="line">output[i] = [a, b, c] (3个整数)</span><br><span class="line">- a 哲学家编号。</span><br><span class="line">- b 指定叉子：&#123;1 : 左边, 2 : 右边&#125;.</span><br><span class="line">- c 指定行为：&#123;1 : 拿起, 2 : 放下, 3 : 吃面&#125;。</span><br><span class="line">如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 60</code></li></ul><p>学过操作系统的童鞋们都比较好懂。</p><p>开始这个问题之前，想个最暴力的做法，就是每次只能让一个人吃。一把大锁即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Yun_Ge/article/details/89177918">PV操作经典例题——哲学家进餐问题</a></p><p><strong>分析</strong>：放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用，为了实现对筷子的互斥访问，可以用一个信号量表示筷子，由这五个信号量构成信号量数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*当哲学家饥饿时，总是先拿左边的筷子，再拿右边的筷子*/</span></span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃饭</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*当哲学家进餐完成后，总是先放下左边的筷子，再放下右边的筷子*/</span></span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述的代码可以保证不会有两个相邻的哲学家同时进餐，但却可能引起死锁的情况。假如五位哲学家同时饥饿而都拿起的左边的筷子，就会使五个信号量chopstick都为0，当他们试图去拿右手边的筷子时，都将无筷子而陷入无限期的等待。</li></ul><p><strong>为避免死锁，可以使用以下三种策略</strong>：</p><p><strong>策略一</strong>：<strong>至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐</strong>，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。</p><p>错误代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DiningPhilosophers diningPhilosophers;</span><br><span class="line">    <span class="type">int</span> nPhilosophers = <span class="number">5</span>;</span><br><span class="line">    <span class="function">vector&lt;thread&gt; <span class="title">philosophers</span><span class="params">(nPhilosophers)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i] = <span class="built_in">thread</span>(&amp;DiningPhilosophers::wantsToEat, &amp;diningPhilosophers, i, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up right fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; eats\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down right fork\n&quot;</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：本代码使用了一个信号量来限制同时吃饭的哲学家的数量。这是一个常见的解决方案，可以避免死锁。但是，没有考虑到叉子的使用情况。所有的哲学家都试图先拿起左边的叉子，然后拿起右边的叉子。这可能会导致一个问题：如果所有的哲学家都拿起了他们左边的叉子，那么他们的右边的叉子就都被他们右边的哲学家拿走了，因此每个哲学家都无法吃饭，导致所有哲学家都在等待，从而产生死锁。</p><p>简单来说，我们需要考虑哲学家人数问题，也要考虑到叉子的资源使用。</p><p>正确代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    mutex mtx[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">        <span class="type">int</span> l = philosopher;</span><br><span class="line">        <span class="type">int</span> r = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>策略二</strong>：<strong>仅当哲学家的左右两支筷子都可用时，才允许他拿起筷子进餐</strong>。可以利用AND 型信号量机制实现，也可以利用信号量的保护机制实现。利用信号量的保护机制实现的思想是通过记录型信号量mutex对取左侧和右侧筷子的操作进行保护，使之成为一个<a href="https://so.csdn.net/so/search?q=原子操作&amp;spm=1001.2101.3001.7020">原子操作</a>，这样可以防止死锁的出现。描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    mutex mtx[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">        <span class="type">int</span> l = philosopher;</span><br><span class="line">        <span class="type">int</span> r = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">        <span class="built_in">pickLeftFork</span>();</span><br><span class="line">        <span class="built_in">pickRightFork</span>();</span><br><span class="line">        <span class="built_in">eat</span>();</span><br><span class="line">        <span class="built_in">putLeftFork</span>();</span><br><span class="line">        <span class="built_in">putRightFork</span>();</span><br><span class="line">        mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">        mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>策略三</strong>：规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则先拿起他右边的筷子，然后再去拿他左边的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mutex mtx[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">DiningPhilosophers</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="type">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                    function&lt;<span class="type">void</span>()&gt; putRightFork)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = philosopher;</span><br><span class="line">        <span class="type">int</span> r = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (philosopher % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">            mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">pickLeftFork</span>();</span><br><span class="line">            <span class="built_in">pickRightFork</span>();</span><br><span class="line">            <span class="built_in">eat</span>();</span><br><span class="line">            <span class="built_in">putLeftFork</span>();</span><br><span class="line">            <span class="built_in">putRightFork</span>();</span><br><span class="line">            mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">            mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtx[r].<span class="built_in">lock</span>();</span><br><span class="line">            mtx[l].<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">pickLeftFork</span>();</span><br><span class="line">            <span class="built_in">pickRightFork</span>();</span><br><span class="line">            <span class="built_in">eat</span>();</span><br><span class="line">            <span class="built_in">putLeftFork</span>();</span><br><span class="line">            <span class="built_in">putRightFork</span>();</span><br><span class="line">            mtx[l].<span class="built_in">unlock</span>();</span><br><span class="line">            mtx[r].<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DiningPhilosophers diningPhilosophers;</span><br><span class="line">    <span class="type">int</span> nPhilosophers = <span class="number">5</span>;</span><br><span class="line">    <span class="function">vector&lt;thread&gt; <span class="title">philosophers</span><span class="params">(nPhilosophers)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i] = <span class="built_in">thread</span>(&amp;DiningPhilosophers::wantsToEat, &amp;diningPhilosophers, i, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; picks up right fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; eats\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down left fork\n&quot;</span>; &#125;, [i]()</span><br><span class="line">                                 &#123; cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; puts down right fork\n&quot;</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nPhilosophers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        philosophers[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在写并发程序的时候很容易写着写着就有bug了。这时候，如何定位bug就显得尤为关键。</p><p>问题代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>           <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>             <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// std::condition_variable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁资源1</span></span><br><span class="line">std::mutex mtx1;</span><br><span class="line"><span class="comment">// 锁资源2</span></span><br><span class="line">std::mutex mtx2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 保证线程A先获取锁1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockA</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程A获取锁1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A睡眠2s再获取锁2，保证锁2先被线程B获取，模拟死锁问题的发生</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A先获取锁2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockB</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程A获取锁2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程A释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程B先睡眠1s保证线程A先获取锁1</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockB</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程B获取锁2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 线程B尝试获取锁1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockA</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程B获取锁1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程B释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(taskA)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(taskB)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main主线程等待所有子线程执行完</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行可执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ✘ ⚙ penge@penge-virtual-machine  ~/Desktop/MordenCpp  ./main</span><br><span class="line">线程A获取锁1</span><br><span class="line">线程B获取锁2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看进程号<code>ps -aux | grep main</code></p><p>通过top命令再查看一下进程内每个线程具体的运行情况：top -Hp pid</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">80342</span> penge     <span class="number">20</span>   <span class="number">0</span>   <span class="number">88564</span>   <span class="number">1676</span>   <span class="number">1508</span> S   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> main                                                                                  </span><br><span class="line"> <span class="attribute">80343</span> penge     <span class="number">20</span>   <span class="number">0</span>   <span class="number">88564</span>   <span class="number">1676</span>   <span class="number">1508</span> S   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> main                                                         </span><br><span class="line"> <span class="attribute">80344</span> penge     <span class="number">20</span>   <span class="number">0</span>   <span class="number">88564</span>   <span class="number">1676</span>   <span class="number">1508</span> t   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> main</span><br></pre></td></tr></table></figure><p>查看状态为S【<a href="https://blog.csdn.net/sdkdlwk/article/details/65938204">Linux进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)</a>】</p><p>接着使用 <strong>gdb attach pid</strong>调试一个已经在运行的进程.</p><p>查看所有线程的调用堆栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7f0846b3c700 (LWP 1407291)):</span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x5574527f2160 &lt;mtx1&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line"><span class="comment">#1  0x00007f084768f0a3 in __GI___pthread_mutex_lock (mutex=0x5574527f2160 &lt;mtx1&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x00005574527ed74f in __gthread_mutex_lock (__mutex=0x5574527f2160 &lt;mtx1&gt;) at /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:749</span></span><br><span class="line"><span class="comment">#3  0x00005574527ed8a4 in std::mutex::lock (this=0x5574527f2160 &lt;mtx1&gt;) at /usr/include/c++/9/bits/std_mutex.h:100</span></span><br><span class="line"><span class="comment">#4  0x00005574527ed940 in std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7f0846b3bdf0, __m=...) at /usr/include/c++/9/bits/std_mutex.h:159</span></span><br><span class="line"><span class="comment">#5  0x00005574527ed541 in taskB () at main.cpp:36</span></span><br><span class="line"><span class="comment">#6  0x00005574527ee526 in std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x557453d97008: 0x5574527ed4b1 &lt;taskB()&gt;) at /usr/include/c++/9/bits/invoke.h:60</span></span><br><span class="line"><span class="comment">#7  0x00005574527ee4be in std::__invoke&lt;void (*)()&gt; (__fn=@0x557453d97008: 0x5574527ed4b1 &lt;taskB()&gt;) at /usr/include/c++/9/bits/invoke.h:95</span></span><br><span class="line"><span class="comment">#8  0x00005574527ee450 in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x557453d97008) at /usr/include/c++/9/thread:244</span></span><br><span class="line"><span class="comment">#9  0x00005574527ee40d in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x557453d97008) at /usr/include/c++/9/thread:251</span></span><br><span class="line"><span class="comment">#10 0x00005574527ee3de in std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x557453d97000) at /usr/include/c++/9/thread:195</span></span><br><span class="line"><span class="comment">#11 0x00007f0847798df4 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#12 0x00007f084768c609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span></span><br><span class="line"><span class="comment">#13 0x00007f08475b1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7f084733d700 (LWP 1407290)):</span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x5574527f21a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line"><span class="comment">#1  0x00007f084768f0a3 in __GI___pthread_mutex_lock (mutex=0x5574527f21a0 &lt;mtx2&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x00005574527ed74f in __gthread_mutex_lock (__mutex=0x5574527f21a0 &lt;mtx2&gt;) at /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:749</span></span><br><span class="line"><span class="comment">#3  0x00005574527ed8a4 in std::mutex::lock (this=0x5574527f21a0 &lt;mtx2&gt;) at /usr/include/c++/9/bits/std_mutex.h:100</span></span><br><span class="line"><span class="comment">#4  0x00005574527ed940 in std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7f084733cdf0, __m=...) at /usr/include/c++/9/bits/std_mutex.h:159</span></span><br><span class="line"><span class="comment">#5  0x00005574527ed3f8 in taskA () at main.cpp:23</span></span><br><span class="line"><span class="comment">#6  0x00005574527ee526 in std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x557453d96eb8: 0x5574527ed368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:60</span></span><br><span class="line"><span class="comment">#7  0x00005574527ee4be in std::__invoke&lt;void (*)()&gt; (__fn=@0x557453d96eb8: 0x5574527ed368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:95</span></span><br><span class="line"><span class="comment">#8  0x00005574527ee450 in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x557453d96eb8) at /usr/include/c++/9/thread:244</span></span><br><span class="line"><span class="comment">#9  0x00005574527ee40d in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x557453d96eb8) at /usr/include/c++/9/thread:251</span></span><br><span class="line"><span class="comment">#10 0x00005574527ee3de in std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x557453d96eb0) at /usr/include/c++/9/thread:195</span></span><br><span class="line"><span class="comment">#11 0x00007f0847798df4 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#12 0x00007f084768c609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span></span><br><span class="line"><span class="comment">#13 0x00007f08475b1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line"></span><br><span class="line">Thread 1 (Thread 0x7f084733e740 (LWP 1407289)):</span><br><span class="line"><span class="comment">#0  __pthread_clockjoin_ex (threadid=139673531045632, thread_return=0x0, clockid=&lt;optimized out&gt;, abstime=&lt;optimized out&gt;, block=&lt;optimized out&gt;) at pthread_join_common.c:145</span></span><br><span class="line"><span class="comment">#1  0x00007f0847799057 in std::thread::join() () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#2  0x00005574527ed648 in main () at main.cpp:47</span></span><br></pre></td></tr></table></figure><p>定位到taskA和taskB线程阻塞的原因，都是因为锁获取不到，然后再结合源码进行分析定位，最终发现taskA之所以获取不到mtx2，是因为mtx2早被taskB线程获取了；同样taskB之所以获取不到mtx1，是因为mtx1早被taskA线程获取了，导致所有线程进入阻塞状态，等待锁资源的获取，但是又因为没有线程释放锁，最终导致死锁问题。</p><p>知道是死锁问题，那么如何定位具体哪一行呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">(base) sv@sv-NF5280M5:/home/sv$ sudo gdb attach 1406920</span><br><span class="line">[sudo] sv 的密码：</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">attach: 没有那个文件或目录.</span><br><span class="line">Attaching to process 1406920</span><br><span class="line">[New LWP 1406921]</span><br><span class="line">[New LWP 1406922]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">__pthread_clockjoin_ex (threadid=139933978740480, thread_return=0x0, clockid=&lt;optimized out&gt;, abstime=&lt;optimized out&gt;, block=&lt;optimized out&gt;)</span><br><span class="line">    at pthread_join_common.c:145</span><br><span class="line">145     pthread_join_common.c: 没有那个文件或目录.</span><br><span class="line">(gdb) info threads </span><br><span class="line">  Id   Target Id                                  Frame</span><br><span class="line">* 1    Thread 0x7f44eb185740 (LWP 1406920) <span class="string">&quot;main&quot;</span> __pthread_clockjoin_ex (threadid=139933978740480, thread_return=0x0, clockid=&lt;optimized out&gt;,</span><br><span class="line">    abstime=&lt;optimized out&gt;, block=&lt;optimized out&gt;) at pthread_join_common.c:145</span><br><span class="line">  2    Thread 0x7f44eb184700 (LWP 1406921) <span class="string">&quot;main&quot;</span> __lll_lock_wait (futex=futex@entry=0x55d52319e1a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span><br><span class="line">  3    Thread 0x7f44ea983700 (LWP 1406922) <span class="string">&quot;main&quot;</span> __lll_lock_wait (futex=futex@entry=0x55d52319e160 &lt;mtx1&gt;, private=0) at lowlevellock.c:52</span><br><span class="line">(gdb) thread 2</span><br><span class="line">[Switching to thread 2 (Thread 0x7f44eb184700 (LWP 1406921))]</span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x55d52319e1a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line">52      lowlevellock.c: 没有那个文件或目录.</span><br><span class="line">(gdb) bt <span class="comment"># 函数调用栈</span></span><br><span class="line"><span class="comment">#0  __lll_lock_wait (futex=futex@entry=0x55d52319e1a0 &lt;mtx2&gt;, private=0) at lowlevellock.c:52</span></span><br><span class="line"><span class="comment">#1  0x00007f44eb4d60a3 in __GI___pthread_mutex_lock (mutex=0x55d52319e1a0 &lt;mtx2&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x000055d52319974f in __gthread_mutex_lock (__mutex=0x55d52319e1a0 &lt;mtx2&gt;) at /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:749</span></span><br><span class="line"><span class="comment">#3  0x000055d5231998a4 in std::mutex::lock (this=0x55d52319e1a0 &lt;mtx2&gt;) at /usr/include/c++/9/bits/std_mutex.h:100</span></span><br><span class="line"><span class="comment">#4  0x000055d523199940 in std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7f44eb183df0, __m=...) at /usr/include/c++/9/bits/std_mutex.h:159</span></span><br><span class="line"><span class="comment">#5  0x000055d5231993f8 in taskA () at main.cpp:23</span></span><br><span class="line"><span class="comment">#6  0x000055d52319a526 in std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x55d523aeeeb8: 0x55d523199368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:60</span></span><br><span class="line"><span class="comment">#7  0x000055d52319a4be in std::__invoke&lt;void (*)()&gt; (__fn=@0x55d523aeeeb8: 0x55d523199368 &lt;taskA()&gt;) at /usr/include/c++/9/bits/invoke.h:95</span></span><br><span class="line"><span class="comment">#8  0x000055d52319a450 in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x55d523aeeeb8) at /usr/include/c++/9/thread:244</span></span><br><span class="line"><span class="comment">#9  0x000055d52319a40d in std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x55d523aeeeb8) at /usr/include/c++/9/thread:251</span></span><br><span class="line"><span class="comment">#10 0x000055d52319a3de in std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x55d523aeeeb0)</span></span><br><span class="line">    at /usr/include/c++/9/thread:195</span><br><span class="line"><span class="comment">#11 0x00007f44eb5dfdf4 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="comment">#12 0x00007f44eb4d3609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span></span><br><span class="line"><span class="comment">#13 0x00007f44eb3f8353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line">(gdb) f 5 <span class="comment"># 线程2的第5帧信息</span></span><br><span class="line"><span class="comment">#5  0x000055d5231993f8 in taskA () at main.cpp:23</span></span><br><span class="line">23          std::lock_guard&lt;std::mutex&gt; lockB(mtx2)</span><br></pre></td></tr></table></figure><p>main.cpp:23即可知道问题行所在定位。</p><ul><li><a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/08/19/cpluscplus-gdbusage_part2">GDB调试多线程及多进程</a></li></ul>]]></content>
    
    
    <summary type="html">经典并发案例</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
</feed>
