<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penge666</title>
  
  
  <link href="https://penge666.github.io/atom.xml" rel="self"/>
  
  <link href="https://penge666.github.io/"/>
  <updated>2024-05-03T05:24:27.871Z</updated>
  <id>https://penge666.github.io/</id>
  
  <author>
    <name>Penge666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>muduo网络库</title>
    <link href="https://penge666.github.io/posts/d0543761.html"/>
    <id>https://penge666.github.io/posts/d0543761.html</id>
    <published>2024-05-03T05:14:14.000Z</published>
    <updated>2024-05-03T05:24:27.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络编程是一个比较难码的模块，也是相对其他编程进阶的模块，特别是各种回调函数的理解调用以及其中会遇到各式各样难以解决的Bug。</p><p>借着学习陈硕大神muduo库的机会阅读了这本经典的网络编程教材《Linux多线程服务端编程》，这本也是这学期一直想学习的一本书，PS：就像研一下一直想学习Mit6.824一样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502214205866.png" alt="image-20240502214205866"></p><p>开始整体部分！</p><p>muduo网络库是Multi-Reactor架构，具体可以分为3个部分：</p><ul><li>网络相关模块：如Socket、InetAddress、TcpConnection、Acceptor、TcpServer等</li><li>事件循环相关模块：如EventLoop、Channel、Poller、EPollPoller等</li><li>线程相关模块：如Thread、EventLoopThread、EventLoopThreadPool等</li><li>基础模块：如用户态缓冲区Buffer、时间戳Timestamp、日志类Logger等</li></ul><p>本文参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/495016351">万字长文梳理Muduo库核心代码及优秀编程细节思想剖析</a></li><li><a href="https://www.cnblogs.com/S1mpleBug/p/16712003.html#231-%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88pollerchannel%E5%92%8Ceventloop%E5%9C%A8%E6%95%B4%E4%B8%AAmulti-reactor%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2">长文梳理muduo网络库核心代码、剖析优秀编程细节</a></li><li><a href="https://www.cnblogs.com/fortunely/p/15998209.html">muduo笔记</a></li></ul><h2 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h2><h3 id="Multi-Reactor"><a href="#Multi-Reactor" class="headerlink" title="Multi-Reactor"></a>Multi-Reactor</h3><p>Muduo库是基于Reactor模式实现的TCP网络编程库。</p><p>Multi-Reactor模型如下所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502220126199.png" alt="image-20240502220126199"></p><h3 id="事件循环模块"><a href="#事件循环模块" class="headerlink" title="事件循环模块"></a>事件循环模块</h3><p>muduo库基于三个关键组件来实现一个reactor，这个reactor可以持续地监听一组文件描述符（fd），并根据每个fd上发生的事件来调用相应的处理函数。这三个核心组件包括Channel类、Poller/EpollPoller类以及EventLoop类。</p><p>可以先看下整体的架构，先有个整体的了解。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502224744115.png" alt="image-20240502224744115"></p><h4 id="Channel类"><a href="#Channel类" class="headerlink" title="Channel类"></a>Channel类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>在TCP网络编程中，要想使用IO多路复用来监听某个文件描述符（fd），需要通过epoll_ctl将这个fd及其关心的事件注册到IO多路复用模块（也可以称之为事件监听器）上。当事件监听器检测到该fd发生了某个事件时，它会返回一个包含发生事件的fd集合，以及每个fd都发生了什么事件。</p><p>Channel类就是这样一个封装，它包含了一个文件描述符（fd），这个fd关心的事件，以及事件监听器实际检测到的事件。除此之外，Channel类还提供了一些方法，允许你设置这个fd的关心的事件，将这个fd及其关心的事件注册到事件监听器中或者从事件监听器中移除，以及保存这个fd的每种事件所对应的处理函数。</p><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li>int fd_：Channel对象关心的文件描述符。</li><li>int events_：fd感兴趣的事件类型集合。</li><li>int revents_：代表事件监听器实际监听到该fd发生的事件类型集合。当事件监听器监听到一个fd发生了什么事件，通过Channel::set_revents()函数来设置revents值。</li><li>EventLoop* loop：表示当前的Channel是在哪个loop中。</li><li>read<em>callback</em> 、write<em>callback</em>、close<em>callback</em>、error<em>callback</em>：这些是std::function类型，代表着这个Channel为这个文件描述符保存的各事件类型发生时的处理函数。比如这个fd发生了可读事件，需要执行可读事件处理函数，Channel类都替你保管好了这些可调用函数。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><p>成员函数的设计是根据成员变量和这个类的功能设计，在设计之前我们自己也可以先想想作者为什么这么设计。</p><ul><li><p>向Channel对象注册各类事件的处理函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123;read_callback_ = std::<span class="built_in">move</span>(cb);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(Eventcallback cb)</span> </span>&#123;write_callback_ = std::<span class="built_in">move</span>(cb);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span> </span>&#123;close_callback_ = std::<span class="built_in">move</span>(cb);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span> </span>&#123;error_callback_ = std::<span class="built_in">move</span>(cb);&#125; </span><br></pre></td></tr></table></figure><p>简单来说，就是事件监听器监听到描述符发生的事件的时候，相应的处理函数来处理。处理函数保存在Channel类中，这样调用也比较方便。第二点所示。</p></li><li><p>根据poller通知的channel发生的具体事件， 由channel负责调用具体的回调操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>, revents_);</span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用epoll_wait()后，可以得知事件监听器上哪些Channel（文件描述符）发生了哪些事件，事件发生后自然就要调用这些Channel对应的处理函数。</p></li><li><p>将这个文件描述符实际发生的事件封装进这个Channel中</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span> </span>&#123;revents_ = revt;&#125;</span><br></pre></td></tr></table></figure><p>  这个函数是在EPollPoller::fillActiveChannels调用，即获取活跃的连接的时候设置给Channel。</p></li><li><p>将Channel中的文件描述符及其感兴趣事件注册事件监听器上或从事件监听器上移除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成后会跟新epoll中的fd为当前需要监听[设置]的事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;events_ |= kReadEvent; <span class="built_in">upadte</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123;events_ &amp;= ~kReadEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;events_ |= kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;events_ &amp;= ~kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;events_ |= kNonEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void Channel::update()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // 通过channel所属的EventLoop，调用poller的相应方法，注册fd的events事件</span></span><br><span class="line"><span class="comment">    loop_-&gt;updateChannel(this);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个update的调用过程是Channel=&gt;EventLoop=&gt;Poller。update本质上就是调用了epoll_ctl()。</p></li></ul><h4 id="EpollPoller类"><a href="#EpollPoller类" class="headerlink" title="EpollPoller类"></a>EpollPoller类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>负责监听文件描述符事件是否触发以及返回发生事件的文件描述符以及具体事件的模块就是Poller。一个Poller对象对应一个事件监听器。其中，1个reactor中有1个Poller，也就是说有多少reactor就有多少Poller。</p><p>目前，项目中muduo库只支持epoll。</p><p>Poller是个抽象虚类，由EpollPoller和PollPoller继承实现，与监听文件描述符和返回监听结果的具体方法也基本上是在这两个派生类中实现。EpollPoller就是封装了用epoll方法实现的与事件监听有关的各种方法，PollPoller就是封装了poll方法实现的与事件监听有关的各种方法。</p><blockquote><p><strong>成员变量</strong></p></blockquote><p>这里将Poller/EpollPoller成员变量放在一起。</p><ul><li>epollfd_：用epoll_create方法返回的epoll句柄。</li><li>channels_：这个变量是std::unordered_map<int, Channel*>类型，负责记录 文件描述符 —-&gt; Channel的映射，也帮忙保管所有注册在这个Poller上的Channel。</li><li>ownerLoop_：表示当前epollfd在哪个loop。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li><p>获取监听发生事件的描述符的Channel集合</p><p>核心是以下2个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeStamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span></span></span><br></pre></td></tr></table></figure><p>具体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timestamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// events_每次传入都是初始化过的，也就说里面没有数据，等待epoll_wait获取数据。</span></span><br><span class="line">    <span class="type">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_, &amp;*events_.<span class="built_in">begin</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">    <span class="built_in">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填写活跃的连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Channel *channel = <span class="built_in">static_cast</span>&lt;Channel *&gt;(events_[i].data.ptr);</span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);</span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel); <span class="comment">// EventLoop就拿到了它的poller给它返回的所有发生事件的channel列表了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个问题：fillActiveChannels中遍历numEvents为什么就能得到channel对象？</p><p>这是因为在将EPollPoller::update中（也就是在将文件描述符交给epoll监听的时候，将channel对象也放进去便于传递方便后期使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure></li><li><p>更新文件描述符监听的事件</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关系：channel update remove =&gt; EventLoop updateChannel removeChannel =&gt; Poller updateChannel removeChannel</span></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == kNew || index == kDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == kNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">            channels_[fd] = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// channel已经在poller上注册过了</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新channel通道 epoll_ctl add/mod/del</span></span><br><span class="line"><span class="type">void</span> EPollPoller::<span class="built_in">update</span>(<span class="type">int</span> operation, Channel *channel)</span><br><span class="line">&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述的代码比较清楚了，调用updateChannel其中再调用update。本质还是调用epoll_ctl，只不过层层封装适合框架。</p></li></ul><h4 id="EventLoop类"><a href="#EventLoop类" class="headerlink" title="EventLoop类"></a>EventLoop类</h4><p>EventLoop类就是将Channel类和EpollPoller类进行统一管理。</p><p>EventLoop就是负责实现<strong>“循环”</strong>，负责驱动<strong>“循环”</strong>的重要模块。</p><p>这里循环也就是while循环不断检测是否存在监听事件的发生，然后使用传入的回调函数处理对应的事件。</p><p>可以看下下面这张图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502224744115.png" alt="image-20240502224744115"></p><ul><li><p>开启事件循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 监听两类fd   一种是client的fd，一种wakeupfd</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainLoop accept fd《=channel subloop</span></span><br><span class="line"><span class="comment">         * mainLoop 事先注册一个回调cb（需要subloop来执行）    wakeup subloop后，执行下面的方法，执行之前mainloop注册的cb操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------执行回调----------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> <span class="comment">// 执行回调</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Functor &amp;functor : functors)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">functor</span>(); <span class="comment">// 执行当前loop需要执行的回调操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，刚开始的时候对应为什么还会执行doPendingFunctors有点迷惑？这里给出我的理解：用于loop之间通信使用，比如：mainloop要将客户端交给一个loop处理请求。</p></li><li><p>子loop唤醒</p><p>接着上面的问题，当主loop要将连接的客户端交给一个subloop子loop监听处理，但是子loop怎么唤醒呢？</p><p>这里muduo库是先创建一个wakeup描述符，专门用于唤醒描述符，加入到epoll中监听。那么对于唤醒子loop的方法只用往wakeup写入即可，当epoll监听到写事件的时候，就会调用wakeup之前设置的事件发生处理函数进行处理（也就将写事件写入的读出来）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来唤醒loop所在的线程的  向wakeupfd_写一个数据，wakeupChannel就发生读事件，当前loop线程就会被唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当多线程的情况如何正确调用函数呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quit_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果是在其它线程中，调用的quit   在一个subloop(woker)中，调用了mainLoop(IO)的quit</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>()) <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>简单来说，1.loop在自己的线程中调用quit  2.在非loop的线程中，调用loop的quit。</p><ul><li><p>小注意点·</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>()) <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒相应的，需要执行上面回调操作的loop的线程了</span></span><br><span class="line">    <span class="comment">// || callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(); <span class="comment">// 唤醒loop所在线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前的线程直接执行回调函数，但是如果不在的就需要唤醒下。</p><p>这里2个注意点：</p><p>1.怎么判断线程是否是当前线程？</p><p>isInLoopThread() const { return threadId_ ==  CurrentThread::tid(); }</p><p>muduo库设计中使用了这条语句判断。我们只要使用这个函数进行判断。【这个深入的话有点抽象】</p><p>2.(!isInLoopThread() || callingPendingFunctors_)</p><p>如果不在当前线程，唤醒比较好理解。还有一种情况需要唤醒是正在执行回调函数，如果不唤醒，那么这个回调函数就不知道要什么时候才能执行，也可能不执行。因此需要唤醒一下。</p></li><li><p>其他</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventLoop的方法 =》 Poller的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个点在Channel调用过程中已经说明。</p></li></ul><h3 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h3><p>这部分体现了One loop one thread的思想，也是muduo的核心！</p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>Thread类主要是创建线程，然后执行相应的回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(ThreadFunc, <span class="type">const</span> std::string &amp;name = std::string())</span></span>;</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">tid</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tid_; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numCreated_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDefaultName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    <span class="type">bool</span> joined_;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; thread_;</span><br><span class="line">    <span class="type">pid_t</span> tid_;</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">static</span> std::atomic_int numCreated_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="EventLoopThread类"><a href="#EventLoopThread类" class="headerlink" title="EventLoopThread类"></a>EventLoopThread类</h4><p>这个类体现了One loop one thread的思想，就是一个线程负责一个loop循环。</p><p>这个类主要的工作是将eventloop和thread封装，正好一个loop一个线程。</p><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li>EventLoop *loop_：对应的loop。</li><li><em> bool exiting</em>：是否退出。</li><li>Thread thread_：线程类。</li><li>std::mutex mutex_：互斥锁。</li><li><em>std::condition_variable cond</em>：条件变量。</li><li>ThreadInitCallback callback_：线程初始化回调函数。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li>开启loop</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_.<span class="built_in">start</span>(); <span class="comment">// 启动底层的新线程</span></span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (loop_ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个方法，实在单独的新线程里面运行的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 创建一个独立的eventloop，和上面的线程是一一对应的，one loop per thread</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// EventLoop loop  =&gt; Poller.poll</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是创建loop，然后线程中不断的loop循环。</p><h4 id="EventLoopPoolThread类"><a href="#EventLoopPoolThread类" class="headerlink" title="EventLoopPoolThread类"></a>EventLoopPoolThread类</h4><p>eventloop池，从最开始的架构图就可以知道，muduo有主Loop和若干个子loop。这些loop就是这个类产生的。</p><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li>EventLoop *baseLoop_：这是主EventLoop，通常在主线程中运行。</li><li><em>std::string name</em>： EventLoopThreadPool的名称。</li><li>bool started _ ：表示EventLoopThreadPool是否已经启动。</li><li>int numThreads _ ： 线程池中线程的数量。</li><li>int next _ ： 下一个要被处理的线程的索引。</li><li>std::vector&lt; std::unique<em>ptr&lt; EventLoopThread&gt; &gt; threads</em>： 存储线程池中所有线程的容器，使用unique_ptr管理每个线程的生命周期。</li><li>_std::vector<EventLoop *> loops： 存储所有EventLoop的指针的容器，用于分发任务。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li><p>启动线程池，并且在每个线程中创建并启动一个EventLoop。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[name_.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s%d&quot;</span>, name_.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        EventLoopThread *t = <span class="keyword">new</span> <span class="built_in">EventLoopThread</span>(cb, buf);</span><br><span class="line">        threads_.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>()); <span class="comment">// 底层创建线程，绑定一个新的EventLoop，并返回该loop的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个服务端只有一个线程，运行着baseloop</span></span><br><span class="line">    <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主Loop_默认以轮询的方式分配channel给子loop，通过轮询挑选出一个子loop</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop *loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loops_.<span class="built_in">empty</span>()) <span class="comment">// 通过轮询获取下一个处理事件的loop</span></span><br><span class="line">    &#123;</span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span> (next_ &gt;= loops_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            next_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h3><h4 id="Acceptor类"><a href="#Acceptor类" class="headerlink" title="Acceptor类"></a>Acceptor类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>Accetpor封装了服务器专门用于监听是否有客户端连接的套接字fd以及相关处理方法。主要是对其他类的方法调用进行封装。</p><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li>acceptSocket_：这个是服务器监听套接字的文件描述符。</li><li>acceptChannel<em>：这是个Channel类，把acceptSocket </em> 及其感兴趣事件和事件对应的处理函数都封装进去。</li><li>EventLoop *loop：监听套接字的fd由哪个EventLoop负责循环监听以及处理相应事件，其实这个EventLoop就是main EventLoop。</li><li>newConnectionCallback_: TcpServer构造函数中将TcpServer::newConnection( )函数注册给了这个成员变量。这个TcpServer::newConnection函数的功能是公平的选择一个subEventLoop，并把已经接受的连接分发给这个subEventLoop。</li></ul><blockquote><p><strong>成员函数</strong></p></blockquote><ul><li><p>开启链接监听</p><p>listen( )：该函数底层调用了linux的函数listen( )，开启对acceptSocket <em> 的监听同时将acceptChannel及其感兴趣事件（可读事件）注册到main EventLoop 的事件监听器上。换言之就是让main EventLoop事件监听器去监听acceptSocket</em>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>(); <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理新用户连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop)</span><br><span class="line">    , <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">    , <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>())</span><br><span class="line">    , <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// bind</span></span><br><span class="line">    <span class="comment">// TcpServer::start() Acceptor.listen  有新用户的连接，要执行一个回调（connfd=》channel=》subloop）</span></span><br><span class="line">    <span class="comment">// baseLoop =&gt; acceptChannel_(listenfd) =&gt; </span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleRead( )：这是一个私有成员方法，这个方法是要注册到acceptChannel<em> 上的，在构造accept对象的时候设置给acceptchannel对象， 同时handleRead( )方法内部还调用了成员变量newConnectionCallback</em>保存的函数。当main EventLoop监听到acceptChannel _ 上发生了可读事件时（新用户连接事件），就是调用这个handleRead( )方法。</p></li></ul><h4 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h4><blockquote><p><strong>概述</strong></p></blockquote><p>Buffer类其实是封装了一个用户缓冲区，以及向这个缓冲区写数据读数据等一系列控制方法。</p><blockquote><p><strong>算法</strong></p></blockquote><p>这张图已经可以很好的说明这个类的具体功能。</p><p>可以和CS144 TCP协议中的buffer进行比对下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240502231632156.png" alt="image-20240502231632156"></p><blockquote><p><strong>成员方法</strong></p></blockquote><ul><li>ssize_t Buffer::readFd(int fd, int* saveErrno);：客户端发来数据，readFd从该TCP接收缓冲区中将数据读出来并放到Buffer中。</li><li>ssize_t Buffer::writeFd(int fd, int* saveErrno);：服务端要向这条TCP连接发送数据，通过该方法将Buffer中的数据拷贝到TCP发送缓冲区中。</li></ul><p>巧妙的设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从fd上读取数据  Poller工作在LT模式</span></span><br><span class="line"><span class="comment"> * Buffer缓冲区是有大小的！ 但是从fd上读数据的时候，却不知道tcp数据最终的大小</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); <span class="comment">// 这是Buffer底层缓冲区剩余的可写空间大小</span></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// extrabuf里面也写入了数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：可以让用户一次性把所有TCP接收缓冲区的所有数据全部都读出来并放到用户自定义的缓冲区Buffer中。用户自定义缓冲区Buffer是有大小限制的，我们一开始不知道TCP接收缓冲区中的数据量有多少，如果一次性读出来会不会导致Buffer装不下而溢出。所以在readFd( )函数中会在栈上创建一个临时空间extrabuf，然后使用readv的分散读特性，将TCP缓冲区中的数据先拷贝到Buffer中，如果Buffer容量不够，就把剩余的数据都拷贝到extrabuf中，然后再调整Buffer的容量(动态扩容)，再把extrabuf的数据拷贝到Buffer中。当这个函数结束后，extrabuf也会被释放。另外extrabuf是在栈上开辟的空间，速度比在堆上开辟还要快。</p><h4 id="TcpConnection-TcpServer类"><a href="#TcpConnection-TcpServer类" class="headerlink" title="TcpConnection/TcpServer类"></a>TcpConnection/TcpServer类</h4><p>这个类是集大成的类，需要清楚的知道具体的回调函数的调用。</p><p>TCP网络编程的本质是处理下面这几个事件：</p><ul><li>连接的建立。</li><li>连接的断开。（包括主动断开和被动断开）</li><li>消息到达，客户端连接文件描述符可读。</li><li>消息发送，向客户端连接文件描述符写数据。</li></ul><p>先来看看整体的图示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503110725342.png" alt=""></p><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/Logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">            <span class="type">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        server_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接建立或者断开的回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                Timestamp time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 写端   EPOLLHUP =》 closeCallback_</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpServer server_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;EchoServer-01&quot;</span>)</span></span>; <span class="comment">// Acceptor non-blocking listenfd  create bind </span></span><br><span class="line">    server.<span class="built_in">start</span>(); <span class="comment">// listen  loopthread  listenfd =&gt; acceptChannel =&gt; mainLoop =&gt;</span></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// 启动mainLoop的底层Poller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：using TcpConnectionPtr = std::shared_ptr&lt; TcpConnection &gt; ;</p><h5 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h5><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503105422549.png" alt="image-20240503105422549"></p><p>大体的整个流程如上图所示：</p><ul><li><p>TcpServer::TcpServer()<br>当我们创建一个TcpServer对象，即执行代码TcpServer server(&amp;loop, listenAddr);调用了TcpServer的构造函数，TcpServer构造函数最主要的就是类的内部实例化了一个Acceptor对象，并往这个Acceptor对象注册了一个回调函数TcpServer::newConnection()。</p></li><li><p>Acceptor::Acceptor()<br>当我们在TcpServer构造函数实例化Acceptor对象时，Acceptor的构造函数中实例化了一个Channel对象，即acceptChannel <em> ，该Channel对象封装了服务器监听套接字文件描述符（尚未注册到main EventLoop的事件监听器上）。接着Acceptor构造函数将Acceptor::handleRead()方法注册进acceptChannel</em> 中，这也意味着，日后如果事件监听器监听到acceptChannel_发生可读事件，将会调用Acceptor::handleRead()函数。</p><p>至此，TcpServer对象创建完毕，用户调用TcpServer::start()方法，开启TcpServer。主要就是调用Acceptor::listen()函数（底层是调用了linux的函数listen()）监听服务器套接字，以及将acceptChannel_注册到main EventLoop的事件监听器上监听它的可读事件（新用户连接事件）接着用户调用loop.loop()，即调用了EventLoop::loop()函数，该函数就会循环的获取事件监听器的监听结果，并且根据监听结果调用注册在事件监听器上的Channel对象的事件处理函数。</p></li><li><p>Acceptor::handleRead()<br>当程序如果执行到了这个函数里面，说明acceptChannel<em> 发生可读事件，程序处理新客户连接请求。该函数首先调用了Linux的函数accept()接受新客户连接。接着调用了TcpServer::newConnection()函数，这个函数是在步骤1中注册给Acceptor并由成员变量newConnectionCallback</em>保存。</p></li><li><p>TcpServer::newConnection()<br>该函数的主要功能就是将建立好的连接进行封装（封装成TcpConnection对象），并使用选择算法公平的选择一个sub EventLoop，并调用TcpConnection::connectEstablished()将TcpConnection::channel_注册到刚刚选择的sub EventLoop上。</p></li></ul><h5 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h5><p>SubEventLoop中的EventLoop::loop()函数内部会<strong>循环的执行</strong>上图中的步骤1和步骤2。步骤1就是调用Poller::poll()方法获取事件监听结果，这个事件监听结果是一个Channel集合，每一个Channel封装着 [一个fd] 及 [fd感兴趣的事件] 和 [事件监听器监听到该fd实际发生的事件]。步骤2就是调用每一个Channel的Channel::HandlerEvent方法。该方法会根据每一个Channel的感兴趣事件以及实际发生的事件调用提前注册在Channel内的对应的事件处理函数（readCallback<em>、writeCallback</em>、closeCallback<em>、errorCallback </em>  )。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503105957775.png" alt="image-20240503105957775"></p><blockquote><p><strong>消息读取</strong></p></blockquote><p>readCallback_保存的函数其实是TcpConnection::handleRead( )，<strong>消息读取的处理逻辑也就是由这个函数提供的</strong>，我们稍微剖析一下这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>; </span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="comment">//从fd读到了数据，并且放在了inputBuffer_上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TcpConnection::handleRead( )函数首先调用Buffer<em>.readFd(channel</em>-&gt;fd(), &amp;saveErrno)，该函数底层调用Linux的函数readv( )，将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中（inputBuffer_）。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在savedErrno中。</p><ul><li>当readFd( )返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用messageCallback_中保存的用户自定义的读取消息后的处理函数。</li><li>readFd( )返回值等于0，说明客户端连接关闭，这时候应该调用TcpConnection::handleClose( )来处理连接关闭事件</li><li>readFd( )返回值等于-1，说明发生了错误，调用TcpConnection::handleError( )来处理savedErrno的错误事件。Moduo库只支持LT模式，所以读事件不会出现EAGAIN的错误，所以一旦出现错误，说明肯定是比较不好的非正常错误了。而EAGAIN错误只不过是非阻塞IO调用时的一种常见错误而已。</li></ul><blockquote><p> <strong>消息发送</strong></p></blockquote><p>当用户调用了TcpConnetion::send(buf)函数时，相当于要求muduo库把数据buf发送给该Tcp连接的客户端。此时该TcpConnection注册在事件监听器上的感兴趣事件中是没有可写事件的。TcpConnection::send(buf)函数内部其实是调用了Linux的函数write( )</p><p>如果TCP发送缓冲区内不能一次性容纳buf：</p><ul><li>这时候write( )函数buf数据尽可能地拷贝到TCP发送缓冲区中，并且将errno设置为EWOULDBLOCK。</li><li>剩余未拷贝到TCP发送缓冲区中的buf数据会被存放在TcpConnection::outputBuffer<em>中。并且向事件监听器上注册该TcpConnection::channel</em>的可写事件。</li><li>事件监听器监听到该Tcp连接可写事件，就会调用TcpConnection::handleWrite( )函数把TcpConnection::outputBuffer<em>中剩余的数据发送出去。</em><ul><li>在TcpConnection::handleWrite( )函数中，通过调用Buffer::writeFd()函数将outputBuffer_的数据写入到Tcp发送缓冲区，如果Tcp发送缓冲区能容纳全部剩余的未发送数据，那最好不过了。如果Tcp发送缓冲区依旧没法容纳剩余的未发送数据，那就尽可能地将数据拷贝到Tcp发送缓冲区中，继续保持可写事件的监听。</li></ul></li><li>当数据全部拷贝到Tcp发送缓冲区之后，就会调用用户自定义的【写完后的事件处理函数】，并且移除该TcpConnection在事件监听器上的可写事件。（移除可写事件是为了提高效率，不会让epoll_wait() 毫无意义的频繁触发可写事件。因为大多数时候是没有数据需要发送的，频繁触发可写事件但又没有数据可写。）</li></ul><p><strong>TcpConnection::send和TcpConnection::handleWrite的区别：</strong></p><ul><li>sendInLoop 的目的是尝试立即将数据写入内核空间。如果一次就能写完，那么就没问题。但如果写入操作被阻塞，或者只写入了部分数据，那么剩下的数据就会被放到 outputBuffer_ 中，然后通过注册写事件 enableWriting()，在有空间可写的时候，再继续写入剩下的数据。这个函数的调用通常是在应用程序想要发送数据的时候。</li><li>handleWrite 则是在内核通知应用程序可以写入数据的时候调用的，即当套接字的发送缓冲区有足够的空间可以接收更多数据时。这个函数的目的是尽可能地将 outputBuffer<em> 中的数据写入到内核空间，直到写入全部数据或者内核空间无法接收更多数据为止。然后，如果 outputBuffer</em> 中的数据全部写入完成，那么就取消对写事件的关注 disableWriting()，因为此时不需要再写数据了。</li><li>总的来说，sendInLoop 是应用程序主动发送数据，handleWrite 是在收到内核的可写通知后尝试写入数据。这两个函数共同实现了数据的异步写入：sendInLoop 负责将应用程序的数据放入 outputBuffer<em> ，并尝试写入内核；handleWrite 负责在内核准备好接收数据时，将 outputBuffer</em> 中的数据写入内核。</li></ul><p>在阅读源码的时候，有个疑问？也就是之前在学习buffer设计的时候，buffer既支持写也支持读，而且缓冲区的设计就有readerIndex<em> 和writerIndex</em>，那为什么之后TcpConnnection中又放2个缓冲区buffer呢？</p><p>GPT回答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在muduo网络库中，接收数据的缓冲区inputBuffer_和发送数据的缓冲区outputBuffer_ 都是独立的，这是因为在网络编程中，接收和发送数据的操作通常是异步的，也就是说，它们可以在不同的时间、以不同的速度发生，因此，它们需要各自的缓冲区来维护它们的状态。</span><br><span class="line"></span><br><span class="line">具体来说，inputBuffer_被用来存储从网络中接收到的数据，直到应用程序准备好处理这些数据为止。同样，outputBuffer_ 被用来存储应用程序准备发送到网络中的数据，直到这些数据被实际发送为止。</span><br><span class="line"></span><br><span class="line">虽然你提到的一个缓冲区可以处理读写操作，但这只适用于单一的读写操作。在网络编程中，接收和发送数据的操作是分离的，并且经常需要在不同的时间进行。因此，使用两个独立的缓冲区可以使得接收和发送数据的操作更加灵活和高效。</span><br></pre></td></tr></table></figure><h5 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h5><blockquote><p><strong>连接被动断开</strong></p></blockquote><p>服务端TcpConnection::handleRead()中感知到客户端把连接断开了。<br>TcpConnection::handleRead( )函数内部调用了Linux的函数readv( )，当readv( )返回0的时候，服务端就知道客户端断开连接了。然后就接着调用TcpConnection::handleClose( )。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503111746345.png" alt="image-20240503111746345"></p><ol><li>在执行TcpConnection::handle<em>Close()的时候，该函数还是在SubEventLoop线程中运行的，接着调用closeCallback</em>(connPtr)回调函数，该函数保存的其实是TcpServer::removeConnection( )函数</li><li>TcpServer::removeConnection( )函数调用了remvoveConnectionInLoop( )函数，该函数的运行是在MainEventLoop线程中执行的，这里涉及到线程切换技术。</li><li>removeConnectionInLoop( )函数：TcpServer对象中有一个connections<em> 成员变量，这是一个unordered_map，负责保存【string —&gt; TcpConnection】的映射，其实就是保存着Tcp连接的名字到TcpConnection对象的映射。因为这个Tcp连接要关闭了，所以也要把这个TcpConnection对象从connections</em>中删掉。然后再调用TcpConnection::connectDestroyed函数。<br>另外为什么removeConnectionInLoop()要在MainEventLoop中运行，因为该函数主要是从TcpServer对象中删除某条数据。而TcpServer对象是属于MainEventLoop的。这也是贯彻了One Loop Per Thread的理念。</li><li>TcpConnection::connectDestroyed( )函数的执行是又跳回到了subEventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外SubEventLoop中的Poller类对象还保存着这条Tcp连接的channel<em>，所以调用channel</em>.remove( )将这个Tcp连接的channel对象从Poller内的数据结构中删除。</li></ol><blockquote><p> <strong>连接主动断开</strong></p></blockquote><p>服务器主动关闭导致连接断开。当服务器主动关闭时，调用TcpServer::~TcpServer()析构函数。</p><p>这里在提示一下EventLoop::runInLoop()函数的意义，假如你有一个EventLoop对象 loop<em>，当你调用了loop</em>-&gt;runInLoop(function)函数时，这个function函数的执行会在这个loop_绑定的线程上运行！<br>所以我们画了下面这幅图，在创建TcpConnection对象时，Acceptor都要将这个对象分发给一个SubEventLoop来管理。这个TcpConnection对象的一切函数执行都要在其管理的SubEventLoop线程中运行。再一次贯彻One Loop Per Thread的设计模式。比如要想彻底删除一个TcpConnection对象，就必须要调用这个对象的connecDestroyed()方法，这个方法执行完后才能释放这个对象的堆内存。每个TcpConnection对象的connectDestroyed()方法都必须在这个TcpConnection对象所属的SubEventLoop绑定的线程中执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503110725342.png" alt=""></p><p>所有上面的TcpServer::~TcpServer()函数就是干这事儿的，不断循环的让这个TcpConnection对象所属的SubEventLoop线程执行TcpConnection::connectDestroyed()函数，同时在MainEventLoop的TcpServer::~TcpServer()函数中调用item.second.reset()释放保管TcpConnection对象的共享智能指针，以达到释放TcpConnection对象的堆内存空间的目的。<br>但是这里面其实有一个问题需要解决，TcpConnection::connectDestroyed()函数的执行以及这个TcpConnection对象的堆内存释放操作不在同一个线程中运行，所以要考虑怎么保证一个TcpConnectino对象的堆内存释放操作是在TcpConnection::connectDestroyed()调用完后。<br>这个析构函数巧妙利用了共享智能指针的特点，当没有共享智能指针指向这个TcpConnection对象时（引用计数为0），这个TcpConnection对象就会被析构删除（堆内存释放）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//connections类型为std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : connections_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.<span class="built_in">reset</span>(); </span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先TcpServer::connections_是一个unordered_map<string, TcpConnectionPtr>，其中TcpConnectionPtr的含义是指向TcpConnection的shared_ptr。</li><li>在一开始，每一个TcpConnection对象都被一个共享智能指针TcpConnetionPtr持有，当执行了TcpConnectionPtr conn(item.second)时，这个TcpConnetion对象就被conn和这个item.second共同持有，但是这个conn的生存周期很短，只要离开了当前的这一次for循环，conn就会被释放。</li><li>紧接着调用item.second.reset()释放掉TcpServer中保存的该TcpConnectino对象的智能指针。此时在当前情况下，只剩下conn还持有这个TcpConnection对象，因此当前TcpConnection对象还不会被析构。</li><li>接着调用了conn-&gt;getLoop()-&gt;runInLoop(bind(&amp;TcpConnection::connectDestroyed, conn));<br>这句话的含义是让SubEventLoop线程去执行TcpConnection::connectDestroyed()函数。当你把这个conn的成员函数传进去的时候，conn所指向的资源的引用计数会加1。因为传给runInLoop的不只有函数，还有这个函数所属的对象conn。</li><li>SubEventLoop线程开始运行TcpConnection::connectDestroyed()</li><li>MainEventLoop线程当前这一轮for循环跑完，共享智能指针conn离开代码块，因此被析构，但是TcpConnection对象还不会被释放，因为还有一个共享智能指针指向这个TcpConnection对象，而且这个智能指针在TcpConnection::connectDestroyed()中，只不过这个智能指针你看不到，它在这个函数中是一个隐式的this的存在。当这个函数执行完后，智能指针就真的被释放了。到此，就没有任何智能指针指向这个TcpConnection对象了。TcpConnection对象就彻底被析构删除了。</li></ul>]]></content>
    
    
    <summary type="html">深入剖析muduo</summary>
    
    
    
    <category term="网络编程" scheme="https://penge666.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="网络编程" scheme="https://penge666.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>时间函数</title>
    <link href="https://penge666.github.io/posts/83c8f10.html"/>
    <id>https://penge666.github.io/posts/83c8f10.html</id>
    <published>2024-04-30T09:05:22.000Z</published>
    <updated>2024-04-30T11:17:17.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C++日志系统中，打印时间是必不可少的一个操作。</p><p>在 Linux C 语言编程中，有两种时间表示方式：</p><ul><li><p>一种是日历时间（calendar time），用于表示自纪元（Epoch）以来的秒数，他可以转换成我们日常看到的时间。</p></li><li><p>一种是处理器时间（processor time），用于表示程序在 CPU 上执行的时间。本文主要关注日历时间的处理。</p></li></ul><blockquote><p><strong>时间戳的概念</strong></p></blockquote><p>时间戳是一种用数字表示时间的方式。它是一个简单的计数器，记录了某个特定事件发生时的时间和日期。</p><p>你可以把时间戳看作一个独一无二的数字标记，表示了某个时刻的时间。这个数字通常是从某个参考点（通常是纪元）开始不断增加的。</p><p>时间戳可以精确到秒、毫秒甚至更小的单位，取决于使用的系统和编程语言。使用时间戳，我们可以轻松地对事件按照时间顺序进行排序和比较，而不用担心日期格式、时区等复杂的问题。</p><p>时间戳在计算机科学和软件开发中非常有用。它可以用来记录事件发生的顺序、计算时间差、创建时间戳序列、做数据分析等等。许多操作系统和编程语言都提供了用于获取和处理时间戳的函数和工具，使我们可以方便地使用它们。</p><p>简而言之，<strong>时间戳就是用数字来表示特定时刻的时间和日期，方便我们在计算机中处理和比较时间</strong>。</p><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><h3 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h3><p>time()函数是 C 和 C++ 中最基本的时间函数，它返回自 1970 年 1 月 1 日起的秒数。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span></span>;</span><br></pre></td></tr></table></figure><p>参数的作用：</p><ul><li>当参数为NULL时：time_t这个整型值通过返回值返回。</li><li>当参数不为NULL时：time_t我们需要的这个整型值通过参数指针得到。</li></ul><p>time_t类型</p><ul><li><strong>time_t</strong>是一个用于表示时间的数据类型，它在 C 语言中广泛使用。可以把它看作是一个整数类型，<strong>用于存储时间戳</strong>。</li></ul><p>使用示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time;</span><br><span class="line">    <span class="built_in">time</span>(&amp;current_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)current_time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面也是可以的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time;</span><br><span class="line">    current_time=<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)current_time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gettimeofday"><a href="#gettimeofday" class="headerlink" title="gettimeofday()"></a>gettimeofday()</h3><p>gettimeofday() 这个函数在 Unix 和 Linux 系统中常用，它可以获取到微秒级别的时间，更加精确。</p><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_sec: %d\n&quot;</span>, tv.tv_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_usec: %d\n&quot;</span>, tv.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="localtime"><a href="#localtime" class="headerlink" title="localtime()"></a>localtime()</h3><p>localtime() 函数的功能是将 time_t 类型的时间转换为一个 tm 结构体类型的时间。</p><p>localtime() 函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* <span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span>* timer);</span><br></pre></td></tr></table></figure><ul><li>参数</li></ul><p>timer：要转换的时间。</p><ul><li>返回值</li></ul><p>返回一个指向 tm 结构体变量的指针，该变量存储了当前时间的各个组成部分。</p><p>tm结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">/* Seconds (0-60) */</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">/* Minutes (0-59) */</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">/* Hours (0-23) */</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">/* Day of the month (1-31) */</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">/* Month (0-11) */</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">/* Year - 1900 */</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">/* Day of the week (0-6, Sunday = 0) */</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">/* Day in the year (0-365, 1 Jan = 0) */</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">/* Daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">time_t</span> current_time;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span>* local_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前时间</span></span><br><span class="line">  current_time = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换为本地时间结构体</span></span><br><span class="line">  local_time = <span class="built_in">localtime</span>(&amp;current_time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否转换成功</span></span><br><span class="line">  <span class="keyword">if</span> (local_time != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">             local_time-&gt;tm_year + <span class="number">1900</span>, <span class="comment">// 年份</span></span><br><span class="line">             local_time-&gt;tm_mon + <span class="number">1</span>,     <span class="comment">// 月份</span></span><br><span class="line">             local_time-&gt;tm_mday,        <span class="comment">// 日</span></span><br><span class="line">             local_time-&gt;tm_hour,        <span class="comment">// 小时</span></span><br><span class="line">             local_time-&gt;tm_min,         <span class="comment">// 分钟</span></span><br><span class="line">             local_time-&gt;tm_sec          <span class="comment">// 秒</span></span><br><span class="line">      );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;时间转换失败\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-04-30 18:54:30</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>localtime函数不是线程安全的。在多线程应用里面，应该用localtime_r函数替代localtime函数，因为localtime_r是线程安全的。</p><h3 id="gmtime"><a href="#gmtime" class="headerlink" title="gmtime()"></a>gmtime()</h3><p>类似 localtime()，但返回的是格林尼治标准时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间</span></span><br><span class="line">    std::<span class="type">time_t</span> current_time = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 gmtime 转换为格林尼治标准时间</span></span><br><span class="line">    std::tm* gm_time = std::<span class="built_in">gmtime</span>(&amp;current_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UTC time: &quot;</span> &lt;&lt; gm_time-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">              &lt;&lt; gm_time-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">              &lt;&lt; gm_time-&gt;tm_sec &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime()"></a>strftime()</h3><p>strftime() 函数的作用是按照指定的格式将时间结构体转换为字符串表示。</p><p>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure><p>strftime参数解析：</p><ul><li><p>s：一个指向字符数组的指针，用于存储格式化后的时间字符串。这个字符数组必须具有足够的空间来存储生成的字符串。</p></li><li><p>maxsize：表示存储时间字符串的字符数组的最大长度。这是为了避免溢出。</p></li><li><p>format：一个指向格式化字符串的指针，用于定义时间字符串的输出格式。格式字符串包含特定的格式占位符，如 %Y 表示年份，%m 表示月份等。</p></li><li><p>timeptr：一个指向 struct tm 结构体的指针，其中包含了要格式化的时间信息。这个结构体存储了年、月、日、时、分、秒等时间字段的值。</p></li></ul><p>strftime返回值解析</p><ul><li>函数 strftime() 的返回值是一个 size_t 类型的整数，表示成功写入目标字符串 s 的字符数（不包括末尾的空字符）。</li></ul><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time;</span><br><span class="line">    <span class="built_in">time</span>(&amp;current_time);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="type">local_t</span> = <span class="built_in">localtime</span>(&amp;current_time);</span><br><span class="line">    <span class="type">char</span> time_str[<span class="number">64</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">strftime</span>(time_str, <span class="built_in">sizeof</span>(time_str), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, <span class="type">local_t</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %s\n&quot;</span>, time_str);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时间为: 2024-04-30 19:05:43</span><br></pre></td></tr></table></figure><h3 id="chrono库"><a href="#chrono库" class="headerlink" title="chrono库"></a>chrono库</h3><p>这是 C++11 中引入的新的时间库，可以方便地获取高精度时间，并进行时间的算术运算。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/679451085">C++ std::chrono库使用指南 (实现C++ 获取日期,时间戳,计时等功能)</a></li><li><a href="https://zhuanlan.zhihu.com/p/662738124">再也不被时间束缚：C++ stdchrono时间库全面解析</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://developer.aliyun.com/article/1350147">Linux C语言之时间函数精讲</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/679451085">C++ std::chrono库使用指南 (实现C++ 获取日期,时间戳,计时等功能)</a></p></li></ul>]]></content>
    
    
    <summary type="html">走进时间函数的世界</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux惊群效应</title>
    <link href="https://penge666.github.io/posts/e5c92e8d.html"/>
    <id>https://penge666.github.io/posts/e5c92e8d.html</id>
    <published>2024-04-30T02:36:29.000Z</published>
    <updated>2024-04-30T03:08:41.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客主要介绍什么是惊群，惊群在线程和进程中的具体表现，惊群的系统消耗和惊群的处理方法。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>惊群效应也有人叫做雷鸣群体效应，不过叫什么，简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。</p><p>这里打个有趣的比方，就像在学校的湖里面用面包🍞喂天鹅，当你往一群天鹅中间扔一撮面包🍞，所有的天鹅各自都被惊动前来抢夺这可口的食物，但是最终注定只有一个天鹅抢到食物，没有抢到的天鹅只好回去继续等待。</p><blockquote><p><strong>惊群效应存在的问题</strong></p></blockquote><p>（1）系统对用户进程/线程频繁地做无效的调度，上下文切换系统性能大打折扣。</p><p>（2）为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。</p><h2 id="惊群效应示例"><a href="#惊群效应示例" class="headerlink" title="惊群效应示例"></a>惊群效应示例</h2><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>场景：主进程创建了socket、bind、listen之后，fork()出来多个进程，每个子进程都开始循环处理（accept）这个listen_fd。每个进程都阻塞在accept上，当一个新的连接到来时候，所有的进程都会被唤醒，但是其中只有一个进程会接受成功，其余皆失败，重新休眠。</p><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 10</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="built_in">listen</span>(fd, <span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PROCESS_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (connfd == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">snprintf</span>(sendbuff, <span class="built_in">sizeof</span>(sendbuff), <span class="string">&quot;接收到accept事件的进程PID = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">send</span>(connfd, sendbuff, <span class="built_in">strlen</span>(sendbuff) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d accept success\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d accept a connection failed: %s\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int status;</span></span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/test  g++ main.cpp -o main -pthread</span><br><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/test  strace -f ./main</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/180053751">Linux神器strace的使用方法及实践</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[pid 171338] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171338] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171338] accept(3, NULL, NULLstrace: Process 171339 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171339</span><br><span class="line">[pid 171339] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171339] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171339] accept(3, NULL, NULLstrace: Process 171340 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171340</span><br><span class="line">[pid 171340] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171340] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171340] accept(3, NULL, NULLstrace: Process 171341 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171341</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171341] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">strace: Process 171342 attached</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171342</span><br><span class="line">[pid 171341] accept(3, NULL, NULL &lt;unfinished ...&gt;</span><br><span class="line">[pid 171342] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171342] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171342] accept(3, NULL, NULLstrace: Process 171343 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171343</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171343] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">[pid 171343] accept(3, NULL, NULLstrace: Process 171344 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171344</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171344] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">[pid 171344] accept(3, NULL, NULLstrace: Process 171345 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171345</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171345] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">strace: Process 171346 attached</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171346</span><br><span class="line">[pid 171345] accept(3, NULL, NULL &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;</span><br><span class="line">[pid 171346] set_robust_list(0x7fc56358fa20, 24) = 0</span><br><span class="line">[pid 171346] accept(3, NULL, NULLstrace: Process 171347 attached</span><br><span class="line"> &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] &lt;... <span class="built_in">clone</span> resumed&gt;, child_tidptr=0x7fc56358fa10) = 171347</span><br><span class="line">[pid 171347] set_robust_list(0x7fc56358fa20, 24 &lt;unfinished ...&gt;</span><br><span class="line">[pid 171337] wait4(-1,  &lt;unfinished ...&gt;</span><br><span class="line">[pid 171347] &lt;... set_robust_list resumed&gt;) = 0</span><br><span class="line">[pid 171347] accept(3, NULL, NULL &lt;unfinished ...&gt;</span><br></pre></td></tr></table></figure><p>之后，在启用一个终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 1234</span><br></pre></td></tr></table></figure><p>看看发生了什么变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[pid 172089] fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x9), ...&#125;) = 0</span><br><span class="line">[pid 172089] brk(NULL)                  = 0x55f621f04000</span><br><span class="line">[pid 172089] brk(0x55f621f25000)        = 0x55f621f25000</span><br><span class="line">[pid 172089] write(1, <span class="string">&quot;process 172089 accept a connecti&quot;</span>..., 51process 172089 accept a connection failed: Success</span><br><span class="line">) = 51</span><br><span class="line">[pid 172089] close(4)                   = 0</span><br><span class="line">[pid 172089] accept(3, NULL, NULL^C &lt;unfinished ...&gt;</span><br><span class="line">[pid 172098] &lt;... accept resumed&gt;)      = ? ERESTARTSYS (To be restarted <span class="keyword">if</span> SA_RESTART is <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><p>很明显当telnet连接的时候只有一个进程accept成功，也就说明了这里并没有发生惊群。</p><p>其实在linux2.6版本以后，linux内核已经解决了accept（）函数的“惊群”现象，大概的处理方式就是，当内核接收到一个客户连接后，只会唤醒等待队列上的第一个进程（线程）,所以如果服务器采用accept阻塞调用方式，在最新的linux系统中已经没有“惊群效应”了</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>场景：如果多个进程/线程阻塞在监听同一个监听socket fd的epoll_wait上，当有一个新的连接到来时，所有的进程都会被唤醒。</p><p>主进程创建socket，bind，listen后，将该socket加入到epoll中，然后fork出多个子进程，每个进程都阻塞在epoll_wait上，如果有事件到来，则判断该事件是否是该socket上的事件如果是，说明有新的连接到来了，则进行接受操作。为了简化处理，忽略后续的读写以及对接受返回的新的套接字的处理，直接断开连接。<br>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"><span class="comment">// socket创建和绑定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sock_creat_bind</span><span class="params">(<span class="type">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(port));</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">return</span> sock_fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用fcntl设置文件或者函数调用的状态标志</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_nonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    val |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl set&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd, epoll_fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: [port] %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = <span class="built_in">sock_creat_bind</span>(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket and bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">make_nonblocking</span>(sock_fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;make non blocking&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sock_fd, SOMAXCONN) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((epoll_fd = <span class="built_in">epoll_create</span>(MAXEVENTS)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    event.data.fd = sock_fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock_fd, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*buffer where events are returned*/</span></span><br><span class="line">    events = <span class="built_in">static_cast</span>&lt;epoll_event *&gt;(<span class="built_in">calloc</span>(MAXEVENTS, <span class="built_in">sizeof</span>(event)));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PROCESS_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> num, j;</span><br><span class="line">                num = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process %d returnt from epoll_wait\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp; EPOLLIN)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sock_fd == events[i].data.fd)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 收到关于监听套接字的通知，意味着一盒或者多个传入连接</span></span><br><span class="line">                        <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                        <span class="type">socklen_t</span> in_len = <span class="built_in">sizeof</span>(in_addr);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">accept</span>(sock_fd, &amp;in_addr, &amp;in_len) &lt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;process %d accept failed!\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;process %d accept successful!\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> ✘ penge@penge-virtual-machine  ~/Desktop/MordenCpp/test  ./main 1234  </span><br><span class="line">process 173413 returnt from epoll_wait</span><br><span class="line">process 173412 returnt from epoll_wait</span><br><span class="line">process 173411 returnt from epoll_wait</span><br><span class="line">process 173410 returnt from epoll_wait</span><br><span class="line">process 173409 returnt from epoll_wait</span><br><span class="line">process 173408 returnt from epoll_wait</span><br><span class="line">process 173407 returnt from epoll_wait</span><br><span class="line">process 173406 returnt from epoll_wait</span><br><span class="line">process 173405 returnt from epoll_wait</span><br><span class="line">process 173404 returnt from epoll_wait</span><br><span class="line">process 173407 accept successful!</span><br><span class="line">process 173409 accept failed!</span><br><span class="line">process 173410 accept failed!</span><br><span class="line">process 173411 accept failed!</span><br><span class="line">process 173412 accept failed!</span><br><span class="line">process 173406 accept failed!</span><br><span class="line">process 173404 accept failed!</span><br><span class="line">process 173413 accept failed!</span><br><span class="line">process 173405 accept failed!</span><br><span class="line">process 173408 accept failed!</span><br></pre></td></tr></table></figure><p>显然，发生了惊群效应。</p><blockquote><p>怎么判断发生了惊群呢？</p></blockquote><p>我们根据strace的返回信息可以确定:</p><p>(1) 系统只会让一个进程真正的接受这个连接，而剩余的进程会获得一个EAGAIN信号。</p><p>(2）通过返回结果和进程执行的系统调用判断。</p><blockquote><p>为什么内核处理了accept的惊群，却不处理epoll_wait的惊群呢？</p></blockquote><p>accept确实应该只能被一个进程调用成功，内核很清楚这一点。但epoll不一样，他监听的文件描述符，除了可能后续被accept调用外，还有可能是其他网络IO事件的，而其他IO事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以，对epoll的惊群，内核则不予处理。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方式一共有三种</p><ol><li>accept_mutex（应用层的解决方案）</li><li>EPOLLEXCLUSIVE（内核层的解决方案）</li><li>SO_REUSEPORT（内核层的解决方案）</li></ol><h3 id="accept-mutex"><a href="#accept-mutex" class="headerlink" title="accept_mutex"></a>accept_mutex</h3><p>看到 mutex 可能你就知道了，锁嘛！这也是对于高并发处理的 ”基操“ 遇事不决加锁，没错，加锁肯定能解决问题。</p><p>感兴趣的可以看看这部分的<a href="https://github.com/nginx/nginx/blob/b489ba83e9be446923facfe1a2fe392be3095d1f/src/event/ngx_event_accept.c#L328">代码实现</a>。</p><h3 id="EPOLLEXCLUSIVE"><a href="#EPOLLEXCLUSIVE" class="headerlink" title="EPOLLEXCLUSIVE"></a>EPOLLEXCLUSIVE</h3><p>EPOLLEXCLUSIVE 是 2016 年 4.5+ 内核新添加的一个 epoll 的标识。它降低了多个进程/线程通过 epoll_ctl 添加共享 fd 引发的惊群概率，使得一个事件发生时，只唤醒一个正在 epoll_wait 阻塞等待唤醒的进程（而不是全部唤醒）。</p><p>关键是：每次内核只唤醒一个睡眠的进程处理资源。</p><h3 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h3><p>Linux内核的3.9版本带来了SO_REUSEPORT特性，该特性支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，允许多个套接字bind()以及listen()同一个TCP或UDP端口，并且在内核层面实现负载均衡。</p><ul><li>在未开启SO_REUSEPORT的时候，由一个监听socket将新接收的连接请求交给各个工作者处理，看图示：<ul><li><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240430110045200.png" alt="image-20240430110045200"></li></ul></li><li>在使用SO_REUSEPORT后，多个进程可以同时监听同一个IP：端口，然后由内核决定将新链接发送给哪个进程，显然会降低每个工人接收新链接时锁竞争。<ul><li><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240430110103466.png" alt="image-20240430110103466"></li></ul></li></ul><blockquote><p> <strong>SO_REUSEPORT解决了什么问题</strong></p></blockquote><p>（1）允许多个套接字bind()/listen()同一个tcp/udp端口。每一个线程拥有自己的服务器套接字，在服务器套接字上没有锁的竞争。</p><p>（2）内核层面实现负载均衡</p><p>（3）安全层面，监听同一个端口的套接字只能位于同一个用户下面。</p><p>（4）处理新建连接时，查找listener的时候，能够支持在监听相同IP和端口的多个sock之间均衡选择。</p><blockquote><p><strong>当一个连接到来的时候，系统到底是怎么决定那个套接字来处理它？</strong></p></blockquote><p>对于不同内核，存在两种模式，这两种模式并不共存，一种叫做热备份模式，另一种叫做负载均衡模式，3.9内核以后，全部改为负载均衡模式。</p><ul><li>热备份模式：一般而言，会将所有的reuseport同一个IP地址/端口的套接字挂在一个链表上，取第一个即可，工作的只有一个，其他的作为备份存在，如果该套接字挂了，它会被从链表删除，然后第二个便会成为第一个。</li><li>负载均衡模式：和热备份模式一样，所有reuseport同一个IP地址/端口的套接字会挂在一个链表上，你也可以认为是一个数组，这样会更加方便，当有连接到来时，用数据包的源IP/源端口作为一个HASH函数的输入，将结果对reuseport套接字数量取模，得到一个索引，该索引指示的数组位置对应的套接字便是工作套接字。这样就可以达到负载均衡的目的，从而降低某个服务的压力。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/666017070">Nginx 是如何解决惊群效应的？</a></li><li><a href="https://blog.csdn.net/lyztyycode/article/details/78648798">Linux惊群效应详解</a></li></ul>]]></content>
    
    
    <summary type="html">一篇让我想起在学校喂天鹅的故事</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://penge666.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习笔记</title>
    <link href="https://penge666.github.io/posts/f5ef6bcf.html"/>
    <id>https://penge666.github.io/posts/f5ef6bcf.html</id>
    <published>2024-04-29T14:56:09.000Z</published>
    <updated>2024-04-30T03:06:38.483Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://penge666.github.io/posts/51aeee82.html"/>
    <id>https://penge666.github.io/posts/51aeee82.html</id>
    <published>2024-04-27T08:57:46.000Z</published>
    <updated>2024-04-27T13:16:30.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>计算机网络基础，是一名计算机学生必须牢牢掌握的基本功。</p><p>这里安利下斯坦福大学开设的CS144课程，给想进一步了解TCP协议具体实现的小伙伴。</p><p>课程🔗：<a href="https://cs144.github.io/">https://cs144.github.io/</a></p><p>这门课将带你从0到1实现一个属于自己的能在网络上通信的 TCP/IP 协议栈。</p><p>好了，开始基本的知识点梳理~</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><strong>UDP头部</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173840722.png" alt="image-20240427173840722"></p><p>字段含义</p><ul><li><p>端口：长度16位，指定发送方所使用的端口号，若不需要对方回发消息，则可全置为0。</p></li><li><p>目的端口：长度16位，指定接收方所使用的端口号。</p></li><li><p>UDP总长度：长度16位，指定了UDP数据报的总长度。</p></li><li><p>校验和：长度16位，用于UDP的差错检测，防止UDP报文出错，同时伪首部参与计算，避免UDP用户数据报传送到错误的目的地。UDP的首部，数据部分，伪首部都会参与检验和的计算，各字段是按照16比特为单位进行计算的，因此数据部分是要保证是16比特的倍数，不够用0填充。</p></li></ul><p><strong>TCP头部</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173903612.png" alt="image-20240427173903612"></p><p>字段含义</p><ul><li><p>16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序。</p></li><li><p>32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</p></li><li><p>32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</p></li><li><p>4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</p></li><li><p>6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）。</p></li><li><p>16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p></li><li><p>16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</p></li><li><p>16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</p></li></ul><p><strong>区别</strong></p><ul><li>TCP<strong>面向连接</strong>；UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供<strong>可靠的服务</strong>；UDP不保证可靠交付。</li><li>TCP<strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP是面向报文的。</li><li>TCP有<strong>拥塞控制</strong>；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li><li><p>每一条TCP连接只能是<strong>点到点</strong>的；UDP支持一对一、一对多、多对一和多对多的通信方式。</p></li><li><p>TCP首部开销20字节；UDP的首部开销小，只有8个字节。</p></li></ul><p><strong>常见的应用协议</strong></p><p>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</p><ul><li><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口80</li><li><strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)</li><li><strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25</li><li><strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口23</li><li><strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22</li></ul><p>基于UDP的应用层协议：DNS、TFTP、SNMP</p><ul><li><strong>DNS</strong> : Domain Name Service (域名服务),默认端口 53</li><li><strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69</li><li><strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。</li></ul><blockquote><p><strong>TCP是如何确保可靠性的呢？</strong></p></blockquote><ul><li>首先，TCP的连接是基于<strong>三次握手</strong>，而断开则是基于<strong>四次挥手</strong>。确保连接和断开的可靠性。</li><li>其次，TCP的可靠性，还体现在<strong>有状态</strong>;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li><li>再次，TCP的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK应答、<strong>超时重传(发送方)</strong>、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</li></ul><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p>假设发送端为客户端，接收端为服务端。</p><p>开始时客户端和服务端的状态都是<code>CLOSED</code></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427171700576.png" alt="image-20240427171700576"></p><ul><li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位<code>SYN=1</code>，序列号<code>seq=x</code>。第一次握手前客户端的状态为<code>CLOSE</code>，第一次握手后客户端的状态为<code>SYN-SENT</code>。此时服务端的状态为<code>LISTEN</code>。</li><li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位<code>SYN=1</code>，<code>ACK=1</code>，序列号<code>seq=y</code>，确认号<code>ack=x+1</code>。第二次握手前服务端的状态为<code>LISTEN</code>，第二次握手后服务端的状态为<code>SYN-RCVD</code>，此时客户端的状态为<code>SYN-SENT</code>。（其中<code>SYN=1</code>表示要和客户端建立一个连接，<code>ACK=1</code>表示确认序号有效）。</li><li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位<code>ACK=1</code>，序列号<code>seq=x+1</code>，确认号<code>ack=y+1</code>。第三次握手前客户端的状态为<code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为<code>ESTABLISHED</code>。<strong>此时连接建立完成。</strong></li></ul><blockquote><p><strong>两次握手可以吗？</strong></p></blockquote><p>防止重复连接</p><ul><li>三次握手的主要原因是为了防止旧的重复连接引起连接混乱问题。</li><li>比如在网络状况比较复杂或者网络状况比较差的情况下，发送方可能会连续发送多次建立连接的请求。</li><li>如果 TCP 握手的次数只有两次，那么接收方只能选择接受请求或者拒绝接受请求，但它并不清楚这次的请求是正常的请求，还是由于网络环境问题而导致的过期请求，如果是过期请求的话就会造成错误的连接。</li><li>所以如果 TCP 是三次握手的话，那么客户端在接收到服务器端 SEQ+1 的消息之后，就可以判断当前的连接是否为历史连接，如果判断为历史连接的话就会发送终止报文（RST）给服务器端终止连接；如果判断当前连接不是历史连接的话就会发送指令给服务器端来建立连接。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427172057128.png" alt="image-20240427172057128"></p><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>客户端A发完数据，要关闭连接。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427172134551.png" alt="image-20240427172134551"></p><ol><li>A的应用进程先向其TCP发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭TCP连接，进入<code>FIN-WAIT-1</code>（终止等待1）状态，等待B的确认。</li><li>B收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B进入<code>CLOSE-WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li><li>A收到B的确认后，进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待B发出的连接释放报文段。</li><li>B发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B进入<code>LAST-ACK</code>（最后确认）状态，等待A的确认。</li><li>A收到B的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A进入<code>TIME-WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>（最大报文段生存时间）后，A才进入<code>CLOSED</code>状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。</li></ol><blockquote><p><strong>什么TIME_WAIT状态？</strong></p></blockquote><p>TIME-WAIT状态指的是第四次挥手后，主动中断连接方所处的状态，这个状态下，主动方尚未完全关闭TCP连接，端口不可复用。</p><blockquote><p><strong>为什么TIME-WAIT状态需要等待2MSL?</strong></p></blockquote><ul><li><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个<code>ACK</code>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在<code>2MSL</code>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到<code>CLOSED</code>状态，若A在<code>TIME-WAIT</code>状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到<code>CLOSED</code>状态。</li><li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个<code>ACK</code>报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li></ul><h2 id="TCP的状态转换图"><a href="#TCP的状态转换图" class="headerlink" title="TCP的状态转换图"></a>TCP的状态转换图</h2><p>状态转换图几乎出现在每一本有关TCP的教材中，可谓是经典中的经典。</p><p>TCP通信过程包括三个步骤：建立TCP连接通道（三次握手）、数据传输、断开TCP连接通道（四次挥手）</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427171057056.png" alt="image-20240427171057056"></p><p>而整个过程可以表示成<strong>TCP状态状态转换图</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427171502114.png" alt="image-20240427171502114"></p><p>详细学习这篇内容：<a href="https://www.coonote.com/tcpip/tcpip-tutorial.html">TCP/IP 教程</a></p><h2 id="TCP的滑动窗口机制"><a href="#TCP的滑动窗口机制" class="headerlink" title="TCP的滑动窗口机制"></a>TCP的滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。</p><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427172810673.png" alt="image-20240427172810673"></p><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173017396.png" alt="image-20240427173017396"></p><p><strong>慢开始</strong></p><p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p><p>当 cwnd &lt; ssthresh 时，使用慢开始算法。</p><p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p><p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p><strong>拥塞避免</strong></p><p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p><strong>快重传</strong></p><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p><p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>粘包指TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p><strong>Note</strong>:只有UDP协议不存在粘包。这是由于UDP有消息保护边界，不会发生粘包拆包问题。</p><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><ul><li><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p></li><li><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p></li></ul><p>粘包和拆包示意图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427173217720.png" alt="image-20240427173217720"></p><p>上图中演示了以下几种情况：</p><ul><li>正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；</li><li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；</li><li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；</li><li>拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。</li></ul><p><strong>解决办法</strong>：</p><ul><li>发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li><li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li><li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>通过自定义协议进行粘包和拆包的处理。</li></ul><h3 id="SYN-flood攻击"><a href="#SYN-flood攻击" class="headerlink" title="SYN-flood攻击"></a>SYN-flood攻击</h3><p>SYN 洪泛攻击 (SYN flood attack)</p><p>原理</p><ul><li>利用三次握手的过程漏洞</li><li>大量发送第一次握手（假IP)的报文</li><li>攻击方忽略第二次握手的报文</li><li>被攻击方多个TCP连接处于(SYNC-RCVD)阶段，耗费大量资源</li><li>最终因为资源耗尽，拒绝服务(DoS)</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://joytsing.cn/posts/42952/#toc-heading-2">TCP协议中三次握手和四次挥手</a></li><li><a href="https://www.coonote.com/tcpip/tcpip-tutorial.html">TCP/IP 教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/356225028">面试题：聊聊TCP的粘包、拆包以及解决方案</a></li></ul>]]></content>
    
    
    <summary type="html">通俗易懂理解TCP协议</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP队头阻塞</title>
    <link href="https://penge666.github.io/posts/9b06a28b.html"/>
    <id>https://penge666.github.io/posts/9b06a28b.html</id>
    <published>2024-04-27T05:20:46.000Z</published>
    <updated>2024-04-27T13:17:14.272Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自：<a href="https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/">Head-of-Line Blocking in QUIC and HTTP/3: The Details</a></p><p>您可能已经听说，经过4年的工作，新的 HTTP/3 和 QUIC 协议终于接近正式标准化。预览版现在可以在服务器和浏览器中进行测试。</p><p>与 HTTP/2 相比，HTTP/3 有很大的性能改进，这主要是因为它将底层传输协议从 TCP 改为基于 UDP 的 QUIC。在这篇文章中，我们将深入了解其中的一项改进，即<strong>消除队头阻塞</strong>（Head-of-Line blocking, 简写：HOL blocking）问题。这很有用，因为我读过很多关于这实际上意味着什么以及它在现实中有多大帮助的误解。解决队头阻塞也是 HTTP/3 和 QUIC 以及 HTTP/2 背后的主要动机之一，因此它也为协议演进的原因提供了一个极好的视角。</p><p>我将首先介绍队头阻塞问题，然后在整个 HTTP 历史中跟踪它的不同形式。我们还将研究它如何与其他系统交互，如优先级和拥塞控制。我们的目标是帮助人们对 HTTP/3 的性能改进做出正确的判断，而这（剧透）可能不像营销材料中所说的那样令人惊讶。</p><p><strong>目录：</strong></p><ol><li>什么是队头阻塞？</li><li>HTTP/1.1 的队头阻塞</li><li>HTTP/2（基于 TCP）的队头阻塞</li><li>HTTP/3（基于 QUIC）的队头阻塞</li><li>总结与结论</li></ol><p><strong>彩蛋内容：</strong></p><ul><li>彩蛋：HTTP/1.1 管道</li><li>彩蛋：TLS 队头阻塞</li><li>彩蛋：传输拥堵控制</li><li>彩蛋：多路复用是否重要？</li></ul><h2 id="什么是队头阻塞（Head-of-Line-blocking）？"><a href="#什么是队头阻塞（Head-of-Line-blocking）？" class="headerlink" title="什么是队头阻塞（Head-of-Line blocking）？"></a>什么是队头阻塞（<strong>Head-of-Line blocking</strong>）？</h2><p>很难给你一个单一的队头阻塞（HOL blocking）的技术定义，因为这篇博客文章单独描述了它的四个不同变体。然而，一个简单的定义是：</p><blockquote><p>当单个（慢）对象阻止其他/后续的对象前进时</p></blockquote><p>现实生活中一个很好的比喻就是只有一个收银台的杂货店。一个顾客买了很多东西，最后会耽误排在他后面的人，因为顾客是以先进先出（First In, First Out）的方式服务的。另一个例子是只有单行道的高速公路。在这条路上发生一起车祸，可能会使整个通道堵塞很长一段时间。因此，即使是在“头部（head）”一个单一的问题可以“阻塞（block）”整条“线（line）”。</p><p>这个概念一直是最难解决的 Web 性能问题之一。为了理解这一点，让我们从 HTTP/1.1 开始讲起。</p><h2 id="HTTP-1-1-的队头阻塞"><a href="#HTTP-1-1-的队头阻塞" class="headerlink" title="HTTP/1.1 的队头阻塞"></a>HTTP/1.1 的队头阻塞</h2><p>HTTP/1.1是一种更简单的协议。一个协议仍然可以基于文本并在网络上可读的时代。如下图1所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132357401.png" alt="image-20240427132357401"></p><center>图1：服务器 HTTP/1.1 响应 script.js</center><p>在本例中，浏览器基于 HTTP/1.1上 请求简单的<code>script.js</code>文件（绿色），图1显示了服务器对该请求的响应。我们可以看到 HTTP 方面本身很简单：它只是在明文文件内容或“有效荷载”（payload）前面直接添加一些文本“headers”（红色）。然后，头（Headers）+ 有效荷载（payload）被传递到底层 TCP（橙色），以便真实传输到客户端。对于这个例子，假设我们不能将整个文件放入一个 TCP 包中，并且必须将它分成两部分。</p><p><em>注意：实际上，当使用 HTTPS 时，HTTP 和 TCP 之间有另一个安全层，通常使用 TLS 协议。不过，为了清晰起见，我们在这里省略了这一点。我在结尾加入了一个额外的彩蛋部分，详细说明了 TLS 特定的队头阻塞变体以及 QUIC 如何避免它。阅读完正文后，请随意阅读它（以及其他的彩蛋部分）。</em></p><p>现在让我们看看当浏览器也请求<code>style.css</code>时发生了什么，如图2：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132410754.png" alt="image-20240427132410754"></p><center>图2：服务器 HTTP/1.1 响应 script.js 和 sytle.css</center><p>在本例中，当<code>script.js</code>的响应传输之后，我们发送<code>style.css</code>（紫色）。<code>style.css</code>的头部（headers）和内容只是附加在 JavaScript（JS）文件之后。接收者使用<strong>Content-Length</strong> header 来知道每个响应的结束位置和另一个响应的开始位置（在我们的简化示例中，<code>script.js</code>是1000字节，而<code>style.css</code>只有600字节）。</p><p>在这个包含两个小文件的简单示例中，所有这些似乎都很合理。但是，假设 JS 文件比 CSS 大得多（比如说 1MB 而不是 1KB）。这种情况下，在下载整个JS文件之前，CSS 必须等待，尽管它要小得多，其实可以更早地解析/使用。更直接地将其可视化，使用数字 1 表示<code>large_script.js</code>和 2 表示<code>style.css</code>，我们会得到这样的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111111111111122</span><br></pre></td></tr></table></figure><p>你可以看到这是一个队头阻塞问题的例子！现在你可能会想：这很容易解决！只需让浏览器在JS文件之前请求CSS文件！然而，至关重要的是，浏览器无法预先知道这两个文件中的哪一个在请求时会成为更大的文件。这是因为没有办法在HTML中指明文件有多大（类似这样的东西很不错，HTML工作组：<code>&lt;img src=&quot;thisisfine.jpg&quot; size=&quot;15000&quot; /&gt;</code>）。</p><p>这个问题的“真正”解决方案是采用<strong>多路复用（multiplexing）</strong>。如果我们可以将每个文件的有效荷载（header）分成更小的片（pieces）或“块”（chunks），我们就可以在网络上混合或“交错”（interleave）这些块：为 JS 发送一个块，为 CSS 发送一个块，然后再发送另一个用于 JS，等等，直到文件被下载为止。使用这种方法，较小的CSS文件将更早地下载（并且可用），同时只将较大的JS文件延迟一点。用数字形象化我们会得到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12121111111111111111111111111111111111111</span><br></pre></td></tr></table></figure><p>然而不幸的是，由于协议存在一些基础的限制，这种多路复用在 HTTP/1.1 中是不可能的。为了理解这一点，我们甚至不需要继续查看大资源对小资源（large-vs-small）场景，因为它已经在我们的示例中显示了两个较小的文件。如图3，我们只为两个资源交错4个块：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427211652242.png" alt="image-20240427211652242"></p><center>图3：服务器 HTTP/1.1 多路复用 script.js 和 style.css</center><p>这里的主要问题是 HTTP/1.1 是一个纯文本协议，它只在有效荷载（payload）的前面附加头（headers）。它不会进一步区分单个（大块）资源与其他资源。让我们用一个例子来说明这一点，如果我们尝试了它会发生什么。在图3中，浏览器开始分析<code>script.js</code>并期望后面有1000个字节（Content-Length）的有效荷载。但是，它只接收450个 JS 字节（第一个块），然后开始读取<code>sytle.css</code>的头部。它最终将 CSS 头部和第一个 CSS 块解释为JS的一部分，因为这两个文件的有效荷载和头都是纯文本。更糟糕的是，它在读取1000个字节后停止，直到第二个<code>script.js</code>块的一半。此时，它看不到有效的新报头，必须删除 TCP 数据包3（packet 3）的其余部分。然后浏览器传递它认为的内容<code>script.js</code>到JS解析器，它失败了因为不是有效的 JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">600</span></span><br><span class="line"></span><br><span class="line">.<span class="property">h1</span> &#123; font-<span class="attr">size</span>: 4em; &#125;</span><br><span class="line">func</span><br></pre></td></tr></table></figure><p>同样，您可以说有一个简单的解决方案：让浏览器查找<code>HTTP/1.1 &#123;statusCode&#125; &#123;statusString&#125;\n</code>模式来查看新的头块何时开始。这可能适用于 TCP 数据包2（packet 2），但在数据包3（packet 3）中会失败：浏览器如何知道绿色的<code>script.js</code>块在哪里结束和紫色<code>style.css</code>块从哪里开始？</p><p>这是 HTTP/1.1 协议设计方式的一个基础限制。如果您只有一个 HTTP/1.1 连接，那么在您切换到发送新资源之前，必须<strong>完整地</strong>传输资源响应。如果前面的资源创建缓慢（例如，从数据库查询动态生成的<code>index.html</code>）或者，如上所述，如果前面的资源很大。这些问题可能会引起队头阻塞问题。</p><p>这就是为什么浏览器开始为 HTTP/1.1 上的每个页面加载<a href="https://link.zhihu.com/?target=http%3A//www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">打开多个并行 TCP 连接</a>（通常为6个）。这样，请求可以分布在这些单独的连接上，并且不再有队头阻塞。也就是说，除非每页有超过6个资源…这当然是很常见的。这就是在多个域名上“分片”（sharding）资源的实践(<a href="https://link.zhihu.com/?target=http%3A//img.mysite.com/">img.mysite.com</a>, static.mysite.com, 等）和 CDN 的由来。由于每个单独的域名有6个连接，浏览器将为每个页面加载总共打开 30-ish 个 TCP 连接。这是可行的，但有相当大的开销：建立一个新的 TCP 连接可能是昂贵的（例如在服务器上的状态和内存方面，以及设置 TLS 加密的计算），并且需要消耗一些时间（特别是对于 HTTPS 连接，因为 TLS 需要自己的握手）。</p><p>由于这个问题不能用 HTTP/1.1 解决，而且并行 TCP 连接的补丁解决方案也不能随着时间的推移扩展得太好，很明显需要一种全新的方法，这就是后来的 HTTP/2。</p><p><em>注意：阅读本文的老哥可能会表示想知道 HTTP/1.1 管道（pipelining）。我决定不在这里讨论这一点，以保持整个故事的流畅性，但对更深入的技术感兴趣的人可以阅读结尾的彩蛋部分。</em></p><h2 id="HTTP-2（基于-TCP）的队头阻塞"><a href="#HTTP-2（基于-TCP）的队头阻塞" class="headerlink" title="HTTP/2（基于 TCP）的队头阻塞"></a><strong>HTTP/2（基于 TCP）的队头阻塞</strong></h2><p>那么，让我们回顾一下。HTTP/1.1 有一个队头阻塞问题，一个大的或慢的响应会延迟后面的其他响应。这主要是因为协议本质上是纯文本的，在资源块（resource chunks）之间不使用分隔符。作为一种解决办法，浏览器打开许多并行TCP连接，这既不高效，也不可扩展。</p><p>因此，HTTP/2 的目标非常明确：<strong>我们能够回到单个 TCP 连接，解决队头阻塞问题</strong>。换一种说法：我们希望能够正确地复用资源块（resource chunks）。这在 HTTP/1.1 中是不可能的，因为没有办法分辨一个块属于哪个资源，或者它在哪里结束，另一个块从哪里开始。HTTP/2 非常优雅地解决了这一问题，它在资源块之前添加了<strong>帧（frames）</strong>。如图4所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132443159.png" alt="image-20240427132443159"></p><center>图4：HTTP/1.1 vs HTTP/2 响应 script.js</center><p>HTTP/2 在每个块前面放置一个所谓的数据帧（DATA frame）。这些数据帧主要包含两个关键的元数据。首先：下面的块属于哪个资源。每个资源的“字节流（bytestream）”都被分配了一个唯一的数字，即<strong>流id（stream id）</strong>。第二：块的大小是多少。协议还有许多其他帧类型，图5也显示了头部帧（HEADERS frame）。这再次使用流id（stream id）来指出这些头（headers）属于哪个响应，这样甚至可以将头（headers）从它们的实际响应数据中分离出来。</p><p>使用这些帧，HTTP/2 确实允许在一个连接上正确地复用多个资源，参见图5：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132510915.png" alt="image-20240427132510915"></p><center>图5：HTTP/2 多路复用响应 script.js 和 style.css</center><p>与图3中的示例不同，浏览器现在可以完美地处理这种情况。它首先处理<code>script.js</code>的头部帧（HEADERS frame），然后是第一个JS块的数据帧（DATA frame）。从数据帧（DATA frame）中包含的块长度来看，浏览器知道它只延伸到 TCP 数据包1的末尾，并且需要从 TCP 数据包2开始寻找一个全新的帧。在那里它确实找到了<code>style.css</code>的头（HEADERS）， 下一个数据帧（DATA frame）含有与第一个数据帧（1）不同的流 id（2），因此浏览器知道这属于不同的资源。同样的情况也适用于 TCP 数据包3，其中数据帧（DATA frame）流 id 用于将响应块“解复用”（de-multiplex）到正确的资源“流”（streams）。</p><p>因此，通过“framing”单个消息，HTTP/2 比 HTTP/1.1 更加灵活。它允许在单个 TCP 连接上通过交错排列块来多路传输多个资源。它还解决了第一个资源缓慢时的队头阻塞问题：而不必等待查询数据库生成的<code>index.html</code>，服务器可以在等待<code>index.html</code>时开始发送其他资源。</p><p>HTTP/2 的方式一个重要结果是，我们突然需要一种方法让浏览器与服务器通信，单个连接的带宽如何跨资源分布（distributed）。换一种说法：资源块应该如何“调度（scheduled）”或交错（interleaved）。如果我们再次用 1 和 2 来表示，我们会发现对于 HTTP/1.1，唯一的选项是11112222（我们称之为顺序的（sequential））。然而， HTTP/2 有更多的自由：</p><ul><li>公平多路复用（例如两个渐进的 JPEGs）：12121212</li><li>加权多路复用（2是1的两倍）：22122122121</li><li>反向顺序调度（例如2是密钥服务器推送的资源）：22221111</li><li>部分调度（流1被中止且未完整发送）：112222</li></ul><p>使用哪种方法是由 HTTP/2 中所谓的“优先级（prioritization）”系统驱动的，所选择的方法对Web 性能有很大的影响。然而，这本身就是一个非常复杂的话题，你不需要在接下来的博客文章中理解它，所以我不把它放在这里讲了。</p><p>我想您会同意，通过 HTTP/2 的帧（frames）及其优先级设置，它确实解决了 HTTP/1.1 的队头阻塞问题。这意味着我在这里的工作完成了，我们都可以回家了。对吗？好吧，没那么简单。我们已经解决了 HTTP/1.1 的队头阻塞，是的，但是 TCP 的队头阻塞呢？</p><h2 id="TCP-队头阻塞"><a href="#TCP-队头阻塞" class="headerlink" title="TCP 队头阻塞"></a>TCP 队头阻塞</h2><p>事实证明，HTTP/2 只解决了 HTTP 级别的队头阻塞，我们可以称之为“应用层”队头阻塞。然而，在典型的网络模型中，还需要考虑下面的其他层。您可以在图6中清楚地看到这一点：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132530740.png" alt="image-20240427132530740"></p><center>图6：典型网络模型中的几个协议层</center><p>HTTP 位于顶层，但首先由安全层的 TLS 支持（请参阅“彩蛋 TLS”部分），然后接着再由传输层的 TCP 传输。这些协议中的每一层都用一些元数据包装来自其上一层的数据。例如，在我们的 HTTP(S) 数据中预先加上 TCP 包头（packet header），然后将其放入 IP 包等，这样就可以在协议之间实现相对简洁的分离。这反过来又有利于它们的可重用性：像 TCP 这样的传输层协议不必关心它正在传输什么类型的数据（可以是 HTTP，也可以是 FTP，也可以是 SSH，谁知道呢），而且 IP 对于 TCP 和 UDP 都能很好地工作。</p><p>然而，如果我们想将多个 HTTP/2 资源多路传输到一个 TCP 连接上，这确实会产生重要的后果。如图7：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132541483.png" alt="image-20240427132541483"></p><center>图7：HTTP/2 和 TCP 在透视图上的差异</center><p>虽然我们和浏览器都知道我们正在获取 JavaScript 和 CSS 文件，但 HTTP/2 不需要知道这一点。它只知道它在使用来自不同资源流 id （stream id）的块。然而，<strong>TCP 甚至不知道它在传输 HTTP！</strong>TCP 所知道的就是它被赋予了一系列字节，它必须从一台计算机传输另一台计算机。为此，它使用特定最大大小（maximum size）的数据包，通常大约为1450字节。每个数据包只跟踪它携带的数据的那一部分（字节范围），这样原始数据就可以按照正确的顺序重建。</p><p>换言之，这两个层之间的透视图是不匹配的：HTTP/2 可以看到多个独立的资源字节流（bytestream），而 TCP 只看到一个不透明的字节流（bytestreams）。图7的TCP数据包3就是一个例子：TCP 只知道它正在传输的任何内容的字节 750 到字节1 599。另一方面，HTTP/2 知道数据包3中实际上有两个独立资源的两个块。<em>（注意：实际上，每个 HTTP/2 帧（如 DATA 和 HEADERS）的大小也有几个字节。为了简单起见，我没有计算额外的开销或这里的 HEADERS 帧，以使数字更直观。）</em></p><p>所有这些看起来都是不必要的细节，直到你意识到互联网是一个根本不可靠的网络。在从一个端点到另一个端点的传输过程中，数据包会丢失和延迟。TCP 的可靠性正是其最受欢迎的原因之一。它只需重<strong>新传输丢失数据包的副本</strong>就可以做到这一点。</p><p>我们现在可以理解传输层是如何导致队头阻塞的。再次思考下图7并问自己：如果 TCP 数据包2在网络中丢失，但数据包1和数据包3已经到达，会发生什么情况？请记住，TCP并不知道它正在承载 HTTP/2，只知道它需要按顺序传递数据。因此，它知道数据包1的内容可以安全使用，并将这些内容传递给浏览器。然而，它发现数据包1中的字节和数据包3中的字节（放数据包2 的地方）之间存在间隙，因此还不能将数据包3传递给浏览器。TCP 将数据包3保存在其接收缓冲区（receive buffer）中，直到它接收到数据包2的重传副本（这至少需要往返服务器一次），之后它可以按照正确的顺序将这两个数据包都传递给浏览器。换个说法：<strong>丢失的数据包2 队头阻塞（HOL blocking）数据包3！</strong></p><p>您可能不清楚为什么这是个问题，所以让我们更深入地研究图7中 HTTP 层的 TCP 包中的实际内容。我们可以看到，TCP 数据包2只携带流id 2（CSS文件）的数据，数据包3同时携带流1（JS文件）和流2的数据。在 HTTP 级别，我们知道这两个流是独立的，并且由数据帧（DATA frame）清楚地描述出来。因此，理论上我们可以完美地将数据包3传递给浏览器，而不必等待数据包2到达。浏览器将看到流id为1的数据帧，并且能够直接使用它。只有流2必须被挂起，等待数据包2的重新传输。这将比我们从 TCP 的方式中得到的效率更高，TCP 的方式最终会阻塞流1和流2。</p><p>另一个例子是数据包1丢失，但是接收到2和3的情况。TCP将再次阻止数据包2和3，等待1。但是，我们可以看到，在HTTP/2级别，流2的数据（CSS文件）完全存在于数据包2和3中，不必等待数据包1的重新传输。浏览器本可以完美地解析/处理/使用 CSS 文件，但却被困在等待 JS 文件的重新传输。</p><p>总之，TCP 不知道 HTTP/2 的独立流（streams）这一事实意味着 <strong>TCP 层队头阻塞（由于丢失或延迟的数据包）也最终导致 HTTP 队头阻塞！</strong></p><p>现在，您可能会问自己：那重点是什么？如果我们仍然有 TCP 队头阻塞，为什么还要使用HTTP/2 呢？好吧，主要原因是虽然数据包丢失确实发生在网络上，但还是比较少见的。特别是在有线网络中，包丢失率只有 0.01%。即使是在最差的蜂窝网络上，在现实中，您也很少看到丢包率高于2%。这与数据包丢失和抖动（网络中的延迟变化）通常是<strong>突发性</strong>的这一事实结合在一起的。包丢失率为2%并不意味着每100个包中总是有2个包丢失（例如数据包 42 和 96）。实际上，可能更像是在总共500个包中丢失10个<strong>连续的</strong>包（例如数据包255到265）。这是因为数据包丢失通常是由网络路径中的路由器内存缓冲区暂时溢出引起的，这些缓冲区开始丢弃无法存储的数据包。不过，细节在这里并不重要。重要的是：是的，TCP 队头阻塞是真实存在的，但是它对 Web 性能的影响要比HTTP/1.1 队头阻塞小得多，HTTP/1.1 队头阻塞几乎可以保证每次都会遇到它，而且它也会受到 TCP 队头阻塞的影响！</p><p>然而，当比较单个连接上的 HTTP/2 和单个连接上的 HTTP/1.1 时，这个基本上是真的。正如我们之前所看到的，实际上它并不是这样工作的，因为 HTTP/1.1 通常会打开多个连接。这使得 HTTP/1.1 不仅在一定程度上减轻了 HTTP 级别，而且减轻了 TCP 级别的队头阻塞。因此，在某些情况下，单个连接上的 HTTP/2 很难比6个连接上的 HTTP/1.1 快，甚至与 HTTP/1.1 一样快。这主要是由于 TCP 的<strong>“拥塞控制”（congestion control）</strong>机制。然而，这是另一个非常深入的话题，并不是我们讨论队头阻塞（HOL blocking）的核心，所以我把它移到了末尾的另一个彩蛋部分。</p><p>总之，事实上，我们看到（也许出乎意料），<strong>HTTP/2 目前部署在浏览器和服务器中，在大多数情况下通常与 HTTP/1.1 一样快或略快</strong>。在我看来，这部分是因为网站在优化 HTTP/2 方面做得更好，部分原因是浏览器仍然经常打开多个并行 HTTP/2 连接，从而使两者兼得。</p><p>然而，也有一些情况（特别是在数据包丢失率较高的低速网络上），6个连接的 HTTP/1.1 仍然比一个连接的 HTTP/2 更为出色，这通常是由于 TCP 级别的队头阻塞问题造成的。正是这个事实极大地推动了新的 QUIC 传输协议的开发，以取代 TCP。</p><h2 id="HTTP-3（基于-QUIC）的队头阻塞"><a href="#HTTP-3（基于-QUIC）的队头阻塞" class="headerlink" title="HTTP/3（基于 QUIC）的队头阻塞"></a>HTTP/3（基于 QUIC）的队头阻塞</h2><p>在那之后，我们终于可以开始谈论新的东西了！但首先，让我们总结一下我们目前所学到的：</p><ul><li>HTTP/1.1 有队头阻塞，因为它需要完整地发送响应，并且不能多路复用它们</li><li>HTTP/2 通过引入“帧”（frames）标识每个资源块属于哪个“流”（stream）来解决这个问题</li><li>然而，TCP 不知道这些单独的“流”（streams），只是把所有的东西看作一个大流（1 big stream）</li><li>如果一个 TCP 包丢失，所有后续的包都需要等待它的重传，即使它们包含来自不同流的无关联数据。TCP 具有传输层队头阻塞。</li></ul><p>我敢肯定你现在可以预测我们如何解决 TCP 的问题，对吧？毕竟，解决方案很简单：我们“只是”需要<strong>让传输层知道不同的、独立的流</strong>！这样，如果一个流的数据丢失，传输层本身就知道它不需要阻塞其他流。</p><p>尽管这个解决方案概念简单，但在现实中却很难实现。由于各种原因，不可能改变 TCP 本身使其具有流意识（stream-aware）。选择的替代方法是以 QUIC 的形式实现一个全新的传输层协议。为了使 QUIC 现实中可以部署在因特网上，它运行在不可靠的 UDP 协议之上。然而，非常重要的是，这并不意味着 QUIC 本身也是不可靠的！在许多方面，QUIC 应该被看作是一个 TCP 2.0。它包括 TCP 的所有特性（可靠性、拥塞控制、流量控制、排序等）的最佳版本，以及更多其他特性。QUIC还完全集成了TLS（参见图6），并且不允许未加密的连接。因为 QUIC 与 TCP 如此不同，这也意味着我们不能仅仅在其上运行 HTTP/2，这就是为什么创建了 HTTP/3（稍后我们将详细讨论这个问题）。这篇博文已经足够长了，不需要更详细地讨论QUIC，因此我将只关注我们需要了解当前队头阻塞讨论的几个部分。如图8所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132618174.png" alt="image-20240427132618174"></p><center>图8：HTTP/1.1 vs HTTP/2 vs HTTP/3 响应 script.js</center><p>我们观察到，让 QUIC 知道不同的流（streams）是非常简单的。QUIC 受到 HTTP/2 帧方式（framing-approach）的启发，还添加了自己的帧（frames）；在本例中是流帧（STREAM frame）。流id（stream id）以前在 HTTP/2 的数据帧（DATA frame）中，现在被<strong>下移到传输层的 QUIC 流帧（STREAM frame）中</strong>。这也说明了如果我们想使用 QUIC，我们需要一个新版本的 HTTP 的原因之一：如果我们只在 QUIC 之上运行 HTTP/2，那么我们将有两个（可能冲突的）“流层”（stream layers）。相反，HTTP/3 从 HTTP 层删除了流的概念（它的数据帧（DATA frames）没有流id），而是重新使用底层的 QUIC 流。</p><p><em>注意：这并不意味着 QUIC 突然知道 JS 或 CSS 文件，甚至知道它正在传输 HTTP；和 TCP 一样，QUIC 应该是一个通用的、可重用的协议。它只知道有独立的流（streams），它可以单独处理，而不必知道它们到底是什么。</em></p><p>现在我们了解了QUIC的流帧（STREAM frames），也很容易看出它们如何帮助解决图9中的传输层队头阻塞：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132627615.png" alt="image-20240427132627615"></p><center>图9：TCP 和 QUIC 在透视图上的差异</center><p>与 HTTP/2 的数据帧（DATA frames）非常相似，<strong>QUIC 的流帧（STREAM frames）分别跟踪每个流的字节范围</strong>。这与 TCP 不同，TCP 只是将所有流数据附加到一个大 blob 中。像以前一样，让我们考虑一下如果 QUIC 数据包2丢失，而 1 和 3 到达会发生什么。与 TCP 类似，数据包1中流1（stream 1）的数据可以直接传递到浏览器。然而，对于数据包3，QUIC 可以比 TCP 更聪明。它查看流1的字节范围，发现这个流帧（STREAM frame）完全遵循流id 1的第一个流帧 STREAM frame（字节 450 跟在字节 449 之后，因此数据中没有字节间隙）。它可以立即将这些数据提供给浏览器进行处理。然而，对于流id 2，QUIC确实看到了一个缺口（它还没有接收到字节0-299，这些字节在丢失的 QUIC 数据包2中）。它将保存该流帧（STREAM frame），直到 QUIC 数据包2的重传（retransmission）到达。再次将其与 TCP 进行对比，后者也将数据流1的数据保留在数据包3中！</p><p>类似的情况发生在另一种情形下，数据包1丢失，但2和3到达。QUIC 知道它已经接收到流2（stream 2）的所有预期数据，并将其传递给浏览器，只保留流1（stream 1）。我们可以看到，对于这个例子，QUIC 确实解决了 TCP 的队头阻塞！</p><p>不过，这种方式有几个重要的后果。最有影响的是 <strong>QUIC 数据可能不再以与发送时完全相同的顺序发送到浏览器</strong>。对于 TCP，如果您发送数据包1、2和3，它们的内容将以完全相同的顺序发送到浏览器（这就是导致队头阻塞的第一个原因）。然而，对于 QUIC，在上面的第二个示例中，在数据包1丢失的情况下，浏览器首先看到数据包2的内容，然后是数据包3的最后一部分，然后是数据包1的（重传），然后是数据包3的第一部分。换言之：<strong>QUIC 在单个资源流中保留了顺序，但不再跨单个流（individual streams）进行排序</strong>。</p><p>这是需要 HTTP/3 的第二个也是最重要的原因，因为事实证明，HTTP/2 中的几个系统非常严重地依赖于 TCP 跨流（across streams）的完全确定性排序。例如，HTTP/2 的优先级系统通过传输更改树数据结构（tree data structure ）布局的操作（例如，将资源5添加为资源6的子级）工作的。如果这些操作应用的顺序与发送顺序不同（现在通过 QUIC 是可能出现的），客户端和服务端的优先级状态可能不同。HTTP/2 的头压缩系统 HPACK 也会发生类似的情况。理解这里的细节并不重要，只需要得出结论：要让这些 HTTP/2 系统直接应用 QUIC 是非常困难的。因此，<strong>对于 HTTP/3，有些系统使用完全不同的方法</strong>。例如，QPACK 是 HTTP/3 的 HPACK 版本，它允许在潜在的队头阻塞和压缩性能之间进行自我选择的权衡。HTTP/2 的优先级系统甚至被完全删除，很可能会被 HTTP/3 的简化版本所取代。所有这些都是因为，与 TCP 不同，QUIC 不能完全保证首先发送的数据也会首先被接收。</p><p>所以，所有 QUIC 和重新设想 HTTP 版本的这些工作都是为了消除传输层队头阻塞。我当然希望这是值得的…</p><h2 id="QUIC-和-HTTP-3-真的完全消除了队头阻塞？"><a href="#QUIC-和-HTTP-3-真的完全消除了队头阻塞？" class="headerlink" title="QUIC 和 HTTP/3 真的完全消除了队头阻塞？"></a>QUIC 和 HTTP/3 真的完全消除了队头阻塞？</h2><p>如果你允许我说一点不好的话，我想引用自己几个段落前的话：</p><blockquote><p>QUIC在单个资源流中保留排序</p></blockquote><p>你想想，这很符合逻辑。它基本上是这样说的：如果你有一个 JavaScript 文件，该文件需要重新组装（re-assembled），就像它是由开发人员创建的一样（或者，老实说，通过 webpack），否则代码将无法工作。任何类型的文件都是一样的：把图片随机地放在一起意味着你阿姨寄来的一些奇怪的电子圣诞卡（甚至更奇怪的）。这意味着，<strong>即使在QUIC中，我们仍然有一种队头阻塞的形式</strong>：如果在单个流中有一个字节间隙，那么流的后面部分仍然会被阻塞，直到这个间隙被填满。</p><p>这有一个关键的含义：QUIC 的队头阻塞移除只有在<strong>多个资源流同时活动时</strong>才有效。这样，如果其中一个流上有包丢失，其他流仍然可以继续。这就是我们在上面图9的例子中看到的。然而，如果在某一时刻只有一个流在活动，任何丢包都会影响到这条孤独的流，我们仍然会被阻塞，即使在 QUIC。所以，真正的问题是：<strong>我们会经常有多个并发流（simultaneous streams）吗？</strong></p><p>正如对 HTTP/2 所解释的，这是可以通过使用适当的资源调度器/多路复用方法来配置的。流1和流2可以被发送 1122、2121、1221 等，并且浏览器可以使用优先级系统指定它希望服务器遵循的方案（对于 HTTP/3 仍然如此）。所以浏览器可以说：嘿！我注意到这个连接有严重的数据包丢失。我将让服务器以 121212 模式而不是 111222 向我发送资源。这样，如果1的一个数据包丢失，2仍然可以继续工作。然而，这种模式的问题是，<strong>121212 模式（或者类似的）对资源加载性能通常不是最优的。</strong></p><p>这是另一个复杂的话题，我现在不想太深入。但是，通过我们的 JS 和 CSS 文件的简单示例，基本概念很容易理解。正如您可能知道的那样，浏览器需要接收整个 JS 或 CSS 文件，然后才能实际执行/应用它（虽然有些浏览器已经可以开始编译/解析部分下载的文件，但它们仍然需要等待它们完整后才能实际使用它们）。但是，大量多路复用这些文件的资源块最终会延迟它们：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用多路复用（较慢）：</span><br><span class="line">---------------------------</span><br><span class="line">                              流1（Stream 1）只有到这里才能使用</span><br><span class="line">                              ▼</span><br><span class="line">12121212121212121212121212121212</span><br><span class="line">                               ▲</span><br><span class="line">                               流2（Stream 2）在这里下载完毕</span><br><span class="line"></span><br><span class="line">未使用多路复用/顺序（流1（Stream 1）更快）：</span><br><span class="line">------------------------------------------------------</span><br><span class="line">                 流1（Stream 1）在这里下载完毕，可以更早地使用</span><br><span class="line">                 ▼   </span><br><span class="line">11111111111111111122222222222222</span><br><span class="line">                               ▲</span><br><span class="line">                               流2（Stream 2）还是在这里下载完毕</span><br></pre></td></tr></table></figure><p>现在，这个话题有很多细微差别，当然也存在多路复用方法更快的情况（例如，如果其中一个文件比另一个文件小得多，正如本文前面讨论的那样）。然而，一般来说，对于大多数页面和大多数资源类型，我们可以说顺序方法最有效。</p><p>现在，这是什么意思？对于最佳性能，我们有<strong>两个相互冲突的性能优化建议</strong>：</p><ol><li>从 QUIC 的队头阻塞移除中获利：多路复用发送资源（12121212）</li><li>为了确保浏览器能够尽快处理核心资源：按顺序发送资源（11112222）</li></ol><p>那么，哪一个是正确的？或者至少：哪一个应该优先于另一个？可悲的是，目前我还不能给你一个明确的答案，因为这是我正在研究的一个主题。这之所以困难，主要是因为<strong>数据包丢失模式很难预测</strong>。</p><p>正如我们在上面讨论过的，包丢失通常是突发性的和分组的。这意味着我们上面 12121212 的例子已经过于简化了。图10给出了一个更真实的概述。在这里，我们假设在下载2个流（绿色和紫色）时，我们有一个8个丢失包的突发事件：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132717355.png" alt="image-20240427132717355"></p><center>图10：HTTP/3 over QUIC 流多路复用对防止队头阻塞的影响。每个矩形是一个单独的QUIC包，为一个流传输数据。红叉表示丢失的包。</center><p>在图10的顶部第一行中，我们可以看到（通常）对资源加载性能更好的顺序情况。在这里，我们看到 QUIC 对消除队头阻塞确实没有那么大的帮助：在丢包之后收到的绿包不能被浏览器处理，因为它们属于经历丢包的同一个流。第二个（紫色）流的数据尚未收到，因此无法处理。</p><p>这与中间一行不同，中间一行（偶然！）丢失的8个数据包都来自绿色流。这意味着浏览器可以处理最后收到的紫色数据包。然而，正如前面所讨论的，如果浏览器是 JS 或 CSS 文件，如果有更多的紫色数据出现，浏览器可能不会从中受益太多。因此，在这里，我们从 QUIC 的队头阻塞移除中获得了一些好处（因为紫色没有被绿色阻止），但是可能会牺牲整体资源加载性能（因为多路复用会导致文件稍后完成）。</p><p>最下面一行几乎是最糟糕的情况。8个丢失的数据包分布在两个流中。这意味着这两个流现在都被队头阻塞了：不是因为它们像TCP那样在等待对方，而是因为每个流仍然需要自己排序。</p><p><em>注意：这也是为什么大多数 QUIC 实现很少同时创建包含来自多个流（streams）的数据包（packets）的原因。如果其中一个数据包丢失，则会立即导致单个数据包中所有流的队头阻塞！</em></p><p>因此，我们看到可能存在某种最佳位置（中间一行），在这里，<strong>队头阻塞预防和资源加载性能之间的权衡可能是值得的</strong>。然而，正如我们所说，丢包模式很难预测。不会总是8个数据包。它们不会总是一样的8个数据包。如果我们搞错了，丢失的数据包只向左移动了一个，我们突然也少了一个紫色的包，这基本上使我们降级到与最下面一行相似的位置…</p><p>我想你会同意我的观点，那听起来很复杂，甚至可能太复杂了。即便如此，问题是这会有多大帮助。如前所述，包丢失在许多网络类型中通常比较少见，可能（也许？）太罕见了，看不到 QUIC 移除队头阻塞的影响。另一方面，已经有很好的文档证明无论您使用的是 HTTP/2 还是 HTTP/3，每个资源的数据包（图10的最后一行）对资源加载性能都是相当不利的。</p><p>因此，有人可能会说，虽然 QUIC 和 HTTP/3 不再受到应用层或传输层队头阻塞的影响，但这在现实中可能并不重要。我不能确定这一点，因为我们还没有完全完成 QUIC 和 HTTP/3 的实现，所以我也没有最后的度量（measurements）。然而，我个人的直觉（这是由我的几个早期实验的结果支持的）说，<strong>QUIC 消除队头阻塞可能实际上对 Web 性能没有太大帮助</strong>，因为理想情况下，您不希望为了资源加载性能而对许多流进行多路复用。而且，如果你真的想让它工作得很好，你就必须非常巧妙地调整你的多路复用方式来适应连接类型，因为你绝对不想在包丢失非常低的快速网络上进行大量的多路复用（因为它们无论如何都不会遭受太多的队头阻塞）。就我个人而言，我不认为会发生这种事。</p><p><em>注意：在这里，在结尾，你可能已经注意到我的故事有点不一致。一开始，我说 HTTP/1.1 的问题是它不允许多路复用。最后，我说多路复用在现实中并不那么重要。为了帮助解决这个明显的矛盾，我添加了另一个额外的彩蛋部分</em></p><h2 id="总结与结论"><a href="#总结与结论" class="headerlink" title="总结与结论"></a>总结与结论</h2><p>在这篇（很长，我知道）的文章中，我们一直在追踪队头阻塞。我们首先讨论了为什么 HTTP/1.1 会受到应用层队头阻塞的影响。这主要是因为 HTTP/1.1 没有识别单个资源块的方法。HTTP/2 使用帧来标记这些块并启用多路复用。这解决了 HTTP/1.1 的问题，但遗憾的是HTTP/2 仍然受到底层 TCP 的限制。由于 TCP 将 HTTP/2 数据抽象为一个单一的、有序的、但不透明的流，因此如果数据包在网络上丢失或严重延迟，它将遭受队头阻塞。QUIC 通过将 HTTP/2 的一些概念引入传输层来解决这个问题。这反过来会产生严重的影响，因为跨流的数据不再是完全有序的。这最终导致需要一个全新的版本 HTTP/3，它只运行在 QUIC 之上（而 HTTP/2 只运行在 TCP 之上，请参见图6）。</p><p>我们需要所有这些上下文来批判性地思考 QUIC（以及 HTTP/3）中的队头阻塞移除在现实中对 Web 性能的实际帮助有多大。我们看到它可能只会对有大量数据包丢失的网络产生很大的影响。我们还讨论了为什么即使这样，您仍然需要多路复用资源，并看运气丢包对多路复用的影响怎么样。我们看到了为什么这样做实际上弊大于利，因为资源多路复用通常不是 Web 性能的最佳方案。我们得出的结论是，虽然现在确定这一点还为时过早，<strong>但在大多数情况下，QUIC 和 HTTP/3 的队头阻塞移除可能不会对 Web 性能起到多大作用</strong>。</p><p>那么…这又给我们留下什么样的 Web 性能评价呢？忽略 QUIC 和 HTTP/3，坚持 HTTP/2 + TCP？我当然不希望！<strong>我仍然相信 HTTP/3 总体上将比 HTTP/2 快</strong>，因为 QUIC 还包括其他性能改进。例如，它比 TCP 在网络上的开销更小，在拥塞控制方面更加灵活，而且最重要的是，它具有 0-RTT 连接建立特性。我觉得<strong>特别是 0-RTT 将提供最多的Web性能好处</strong>，尽管也有很多挑战。以后我会写另一篇关于 0-RTT 的博客文章，但是如果你迫不及待想知道更多关于放大攻击预防、重放攻击、初始拥塞窗口大小等的信息，请看我的另一篇 YouTube 讲座或阅读我最近的论文。</p><p>如果你喜欢所有这些，并希望在未来有更多的交流，请关注我的 twitter <a href="https://link.zhihu.com/?target=https%3A//twitter.com/programmingart">@programmingart</a>。</p><p>这篇文章的“在线文档”版本可以在  github 上找到。如果您有关于如何改进它的建议，请让我知道！</p><p>感谢您的阅读！</p><h2 id="彩蛋：HTTP-1-1-管道（pipelining）"><a href="#彩蛋：HTTP-1-1-管道（pipelining）" class="headerlink" title="彩蛋：HTTP/1.1 管道（pipelining）"></a>彩蛋：HTTP/1.1 管道（<strong>pipelining</strong>）</h2><p>HTTP/1.1 包含了一个名为“管道“（pipelining）的特性，在我看来这是经常被误解的。我看过很多文章，甚至书籍中都有人声称 HTTP/1.1 管道解决了队头阻塞问题。我甚至见过一些人说管道和正确的多路复用是一样的。两种说法都是错误的。</p><p>我发现用类似彩蛋图1中的插图来解释 HTTP/1.1 管道是最简单的：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240427132814642.png" alt="image-20240427132814642"></p><center>彩蛋图1：HTTP/1.1 管道</center><p>如果没有管道（pipelining）（彩蛋图1的左侧），浏览器必须等待发送第二个资源请求，直到第一个请求的响应被完全接收（同样使用 Content-Length）。这会为每个请求增加一个往返时间（RTT）延迟，这对Web性能不利。</p><p>有了管道（彩蛋图1的中间部分），浏览器不必等待任何响应数据，现在可以背靠背地发送请求。这样，我们在连接过程中节省了一些 RTTs，使得加载过程更快。<em>另请注意，请回顾图2：您会看到实际上也在使用管道，因为服务器在 TCP 数据包2中打包 <code>script.js</code> 以及 <code>style.css</code> 的响应数据。当然，只有在服务器同时接收到这两个请求时，这才是可能的。</em></p><p>然而，最重要的是，这种管道只适用于来自浏览器的请求。正如HTTP/1.1 规范所说：</p><blockquote><p>服务器必须按照接收请求的顺序发送对这些[管道化]请求的响应。</p></blockquote><p>因此，我们看到，实际的响应块（response chunks）多路复用（如彩蛋图1右侧所示）在 HTTP/1.1 管道中仍然是不可能的。换一种说法：<strong>管道解决了请求的队头阻塞，而不是响应的队头阻塞</strong>。可悲的是，响应队头阻塞是导致 Web 性能问题最多的原因。</p><p>更糟糕的是，大多数浏览器实际上并没有在现实中使用 HTTP/1.1 管道，因为这会使队头阻塞在多个并行 TCP 连接的设置中变得更加不可预测。为了理解这一点，让我们设想一个设置，其中通过两个 TCP 连接从服务器请求三个文件 A（大）、B（小）和 C（小）。A 和 B 在不同的连接上被请求。现在，浏览器应该在哪个连接上传输对 C 的请求？正如我们之前所说，它不知道 A 还是 B 将成为最大/最慢的资源。</p><p>如果它猜对了（B），它就可以在传输 A 所需的时间内同时下载 B 和 C，从而获得了很好的加速效果。但是，如果猜测是错误的（A），B 的连接将长时间处于空闲状态，而 C 则在 A 后面被阻塞。这是因为 HTTP/1.1 也没有提供一种在请求被发送后“中止”的方法（HTTP/2 和 HTTP/3 允许这样做）。因此，浏览器不能简单地通过 B 的连接请求 C，因为它最终会请求两次 C。</p><p>为了解决所有这些问题，现代浏览器不使用管道，甚至会主动延迟对某些已发现资源（例如图像）的请求一段时间，以查看是否找到更重要的文件（例如 JS 和 CSS），以确保高优先级资源不会被阻塞。</p><p>很明显，HTTP/1.1 管道的失败是 HTTP/2 使用截然不同方法的另一个动机。然而，由于 HTTP/2 的优先级系统指导多路复用在现实中常常无法执行，一些浏览器甚至采取了延迟 HTTP/2 资源请求的方式来获得最佳性能。</p><h2 id="彩蛋：TLS-队头阻塞"><a href="#彩蛋：TLS-队头阻塞" class="headerlink" title="彩蛋：TLS 队头阻塞"></a>彩蛋：TLS 队头阻塞</h2><p>如上所述，TLS 协议为应用层协议（如 HTTP）提供加密（和其他功能）。它通过将从 HTTP 获取的数据包装到 TLS 记录中，TLS 记录在概念上类似于 HTTP/2 帧（frames）或 TCP 数据包（packets）。例如，它们在开始时包含一些元数据，以标识记录的长度。然后，对该记录及其 HTTP 内容进行加密并传递给 TCP 进行传输。</p><p>就 CPU 使用率而言，加密可能是一项昂贵的操作，因此一次加密一个好数据块通常是一个好主意，因为这通常更有效。实际上，TLS 可以以高达 16KB 的块加密资源，这足以填充大约 11 个典型的 TCP 包（give 或 take）。</p><p>然而，至关重要的是，TLS 只能对整个记录进行解密，这就是为什么会出现 TLS 队头阻塞的情况。假设 TLS 记录分散在 11 个 TCP 包上，最后一个 TCP 包丢失。由于 TLS 记录是不完整的，它不能被解密，因此被卡在等待最后一个 TCP 包的重传。注意，在这个特定的情况下，没有 TCP 队头阻塞：在编号11之后没有数据包被卡住等待重新传输。换言之，如果我们在本例中使用纯 HTTP 而不是 HTTPS，那么前10个包中的 HTTP 数据可能已经被移动到浏览器中进行处理。然而，因为我们需要整个11包的 TLS 记录才能解密它，所以我们有了一种新形式的队头阻塞。</p><p>虽然这是一个非常具体的情况，在现实中可能不会经常发生，但在设计 QUIC 协议时，它仍然被考虑在内。因为那里的目标是彻底消除所有形式的队头阻塞（或至少尽可能多地消除），甚至这种边缘情况也必须被移除。这就是为什么 QUIC 集成了 TLS，它总是以每个包为基础加密数据，并且不直接使用 TLS 记录。正如我们所看到的，与使用更大的块相比，这效率更低，需要更多的 CPU，这也是为什么 QUIC 在当前实现中仍然比 TCP 慢的主要原因之一。</p><h2 id="彩蛋：传输拥塞控制"><a href="#彩蛋：传输拥塞控制" class="headerlink" title="彩蛋：传输拥塞控制"></a>彩蛋：传输拥塞控制</h2><p>传输层协议如 TCP 和 QUIC 包括一种称为拥塞控制（Congestion Control）的机制。拥塞控制器的主要工作是确保网络不会同时被过多的数据过载。如果没有缓冲区的话，数据包就会溢出。所以，它通常只发送一点数据（通常是 14KB），看看是否能通过。如果数据到达，接收方将确认发送回发送方。只要所有发送的数据都得到确认，发送方就在每次 RTT 时将其发送速率加倍，直到观察到丢包事件（这意味着网络过载（1 位），它需要后退（1 位））。这就是 TCP 连接如何“探测”其可用带宽。</p><p><em>注：以上描述只是拥塞控制的一种方法。目前，其他方法也越来越流行，其中主要是</em> <a href="https://link.zhihu.com/?target=https%3A//research.google/pubs/pub45646/">BBR 算法</a><em>。BBR 并没有直接观察数据包丢失，而是大量考虑 RTT 波动来确定网络是否过载，这意味着它通常通过探测带宽来减少数据包丢失。</em></p><p>关键是：<strong>拥塞控制机制对每个 TCP（和 QUIC）连接都是独立的</strong>！这反过来也会影响到 HTTP层 的 Web 性能。首先，这意味着 HTTP/2 的单个连接最初只发送 14KB。然而，HTTP/1.1 的6个连接在它们的第一次传输中发送 14KB，大约是 84KB！随着时间的推移，这将变得复杂，因为每个 HTTP/1.1 连接使用每个 RTT 将其数据加倍。第二，只有在数据包丢失的情况下，连接才会降低其发送速率。对于 HTTP/2 的单个连接，即使是一个包丢失也意味着它将减慢速度（除了导致 TCP 队头阻塞之外！）。然而，对于 HTTP/1.1，只有一个连接上的一个包丢失只会减慢这一个连接的速度：其他5个连接可以保持正常的发送和增长。</p><p>这一切使一件事变得非常清楚：<strong>HTTP/2 的多路复用与 HTTP/1.1 的同时下载资源是不一样的</strong>（我还看到一些人声称这一点）。单个 HTTP/2 连接的可用带宽只是在不同文件之间分布/共享，但是块仍然是按顺序发送的。这与 HTTP/1.1 不同，后者以真正的并行方式发送内容。</p><p>现在，您可能会想知道：那么，<strong>HTTP/2 怎么可能比 HTTP/1.1 快呢</strong>？这是一个很好的问题，也是我断断续续问自己很久的问题。一个明显的答案是，如果你有超过6个文件。这就是 HTTP/2 在当时的市场营销方式：将一个图像分割成小正方形，然后通过 HTTP/1.1 vs HTTP/2 加载它们。这主要展示了 HTTP/2 的队头阻塞移除。然而，对于普通/真实的网站来说，事情很快就会变得更加微妙。这取决于资源的数量、大小、使用的优先级/多路复用方案、到服务器的 RTT、实际有多少丢包以及何时发生、同时链路上有多少其他流量、使用的拥塞控制器逻辑，等等。HTTP/1.1 可能会丢失的一个例子是在可用带宽有限的网络上：6个 HTTP/1.1 连接各自增加其发送速率，导致它们很快使网络过载，之后它们都必须后退，必须通过反复试验找到它们共存的带宽限制（在 HTTP/2 之前，人们认为 HTTP/1.1 的并行连接可能是因特网上数据包丢失的主要原因）。单个 HTTP/2 连接增长较慢，但在包丢失事件后恢复速度更快，并且更快地找到最佳带宽。另一个带有注释的拥塞窗口的更详细的，HTTP/2 更快的示例可以看[这张图片（不适用于胆小的人）。</p><p>QUIC 和 HTTP/3 将面临类似的挑战，就像 HTTP/2 一样，HTTP/3 将使用单一的底层 QUIC 连接。然后，您可能会说 QUIC 连接在概念上有点像多个 TCP 连接，因为每个 QUIC 流都可以看作一个TCP连接，因为丢失检测是在每个流的基础上完成的。然而，关键的是，QUIC 的拥塞控制仍然是在连接级别完成的，而不是针对每个流。这意味着，即使流在概念上是独立的，它们仍然会影响 QUIC 的单连接拥塞控制器，如果流中有任何一个丢失，就会导致速度减慢。换句话说：单个 HTTP/3+QUIC 连接仍然不会像 6 个 HTTP/1.1 连接那样快速增长，类似于一个连接上的 HTTP/2+TCP 增长速度并不快。</p><h2 id="彩蛋：多路复用是否重要？"><a href="#彩蛋：多路复用是否重要？" class="headerlink" title="彩蛋：多路复用是否重要？"></a>彩蛋：多路复用是否重要？</h2><p>如上所述，并在本演示文稿中进行了深入解释，通常建议以顺序方式而不是多路传输方式发送大多数网页资源。换一种说法，如果你有两个文件，你通常最好发送 11112222 而不是 12121212。对于需要在应用之前完全接收的资源，如 JS、CSS 和字体，尤其如此。</p><p>如果是这样的话，我们可能会想为什么我们需要多路复用？通过扩展：HTTP/2 甚至 HTTP/3，因为多路复用是 HTTP/1.1 没有的主要特性之一。首先，一些可以增量处理/呈现的文件确实从多路复用中获益。例如，渐进式图像就是这样。第二，如上所述，如果其中一个文件比其他文件小得多，那么它可能会很有用，因为它将更早地下载，而不会对其他文件造成太多的延迟。第三，<strong>多路复用允许改变响应的顺序，并为高优先级的响应中断低优先级的响应</strong>。</p><p>现实中出现的一个很好的例子是在源服务器前面使用 CDN 缓存。假设浏览器从 CDN 请求两个文件。第一个（1）没有被缓存，需要从源文件中获取，这需要一段时间。第二个资源（2）缓存在 CDN 中，因此可以直接传输回浏览器。</p><p>在一个连接上使用 HTTP/1.1，由于队头阻塞，我们必须等待队头完全发送（1），然后才能开始发送（2）。这将给我们带来 11112222，但需要很长的前期等待时间。然而，使用HTTP/2，我们可以立即开始发送（2），利用 CDN 和源节点之间的“思考时间”，并“预热”连接的拥塞控制器。重要的是，如果（1）在（2）完成之前开始到达，我们现在可以简单地开始将（1）的数据注入到响应流中。这样我们就可以得到 22111122，等待的时间要短得多。甚至可以在连接开始时使用服务器推送（Server Push）或103早期提示（103 early hints）等功能。</p><p>因此，虽然像 12121212 这样的完全“轮询”多路复用很少是您想要的 Web 性能，但是多路复用在总体上绝对是一个有用的特性。</p>]]></content>
    
    
    <summary type="html">Head-of-Line Blocking</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝-高效的传输文件</title>
    <link href="https://penge666.github.io/posts/80c635db.html"/>
    <id>https://penge666.github.io/posts/80c635db.html</id>
    <published>2024-04-26T09:31:30.000Z</published>
    <updated>2024-04-26T09:59:51.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>零拷贝</strong>是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种<code>I/O</code>操作优化技术。</p><h2 id="传统-IO-的执行流程"><a href="#传统-IO-的执行流程" class="headerlink" title="传统 IO 的执行流程"></a>传统 IO 的执行流程</h2><p>做服务端开发的小伙伴，文件下载功能应该实现过不少了吧。如果你实现的是一个<strong>web程序</strong>，前端请求过来，服务端的任务就是：将服务端主机磁盘中的文件从已连接的socket发出去。关键实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((n = <span class="built_in">read</span>(diskfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">write</span>(sockfd, buf , n);</span><br></pre></td></tr></table></figure><p>传统的IO流程，包括read和write的过程。</p><ul><li><code>read</code>：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li><li><code>write</code>：先把数据写入到socket缓冲区，最后写入网卡设备。</li></ul><p><strong>流程图如下：</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426174926090.png" alt="image-20240426174926090"></p><ul><li>用户应用进程调用read函数，向操作系统发起IO调用，<strong>上下文从用户态转为内核态（切换1）</strong></li><li>DMA控制器把数据从磁盘中，读取到内核缓冲区。</li><li>CPU把内核缓冲区数据，拷贝到用户应用缓冲区，<strong>上下文从内核态转为用户态（切换2）</strong>，read函数返回</li><li>用户应用进程通过write函数，发起IO调用，<strong>上下文从用户态转为内核态（切换3）</strong></li><li>CPU将用户缓冲区中的数据，拷贝到socket缓冲区</li><li>DMA控制器把数据从socket缓冲区，拷贝到网卡设备，<strong>上下文从内核态切换回用户态（切换4）</strong>，write函数返回</li></ul><p>从流程图可以看出，<strong>传统IO的读写流程</strong>，包括了4次上下文切换（4次用户态和内核态的切换），4次数据拷贝（<strong>两次CPU拷贝以及两次的DMA拷贝</strong>)，什么是DMA拷贝呢？我们一起来回顾下，零拷贝涉及的<strong>操作系统知识点</strong>哈。</p><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>DMA，英文全称是<strong>Direct Memory Access</strong>，即直接内存访问。<strong>DMA</strong>本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程<strong>不需要CPU的参与</strong>。</p><p>我们一起来看下IO流程，DMA帮忙做了什么事情。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426175033350.png" alt="image-20240426175033350"></p><ul><li>用户应用进程调用read函数，向操作系统发起IO调用，进入阻塞状态，等待数据返回。</li><li>CPU收到指令后，对DMA控制器发起指令调度。</li><li>DMA收到IO请求后，将请求发送给磁盘；</li><li>磁盘将数据放入磁盘控制缓冲区，并通知DMA</li><li>DMA将数据从磁盘控制器缓冲区拷贝到内核缓冲区。</li><li>DMA向CPU发出数据读完的信号，把工作交换给CPU，由CPU负责将数据从内核缓冲区拷贝到用户缓冲区。</li><li>用户应用进程由内核态切换回用户态，解除阻塞状态</li></ul><p>DMA的工作就是<strong>帮忙CPU转发一下IO请求，以及拷贝数据</strong>。</p><blockquote><p>主要就是效率，它帮忙CPU做事情，这时候，CPU就可以闲下来去做别的事情，提高了CPU的利用效率。大白话解释就是，CPU老哥太忙太累啦，所以他找了个小弟（名叫DMA） ，替他完成一部分的拷贝工作，这样CPU老哥就能着手去做其他事情。</p></blockquote><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数。</p><p>零拷贝实现有多种方式，分别是</p><ul><li>mmap+write</li><li>sendfile</li><li>sendfile+DMA收集</li><li>splice</li></ul><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap+write"></a>mmap+write</h3><p>mmap 的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr：指定映射的虚拟内存地址</li><li>length：映射的长度</li><li>prot：映射内存的保护模式</li><li>flags：指定映射的类型</li><li>fd:进行映射的文件句柄</li><li>offset:文件偏移量</li></ul><p>mmap用了虚拟内存中可以把内核空间和用户空间的虚拟地址映射到同一个物理地址这个特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，所有的IO都在内核中完成。</p><p><code>mmap+write</code><br>实现的零拷贝流程如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426175310052.png" alt="image-20240426175310052"></p><ul><li>用户进程通过<code>mmap方法</code>向操作系统内核发起IO调用，<strong>上下文从用户态切换为内核态</strong>。</li><li>CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li><strong>上下文从内核态切换回用户态</strong>，mmap方法返回。</li><li>用户进程通过<code>write</code><br>方法向操作系统内核发起IO调用，<strong>上下文从用户态切换为内核态</strong>。</li><li>CPU将内核缓冲区的数据拷贝到的socket缓冲区。</li><li>CPU利用DMA控制器，把数据从socket缓冲区拷贝到网卡，<strong>上下文从内核态切换回用户态</strong>，write调用返回。</li></ul><p>可以发现，<code>mmap+write</code>实现的零拷贝，I/O发生了<strong>4</strong>次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中，包括了<strong>2次DMA拷贝和1次CPU拷贝</strong>。</p><p><code>mmap</code>是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，所以节省了一次CPU拷贝‘’并且用户进程内存是<strong>虚拟的</strong>，只是<strong>映射</strong>到内核的读缓冲区，可以节省一半的内存空间。</p><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p><code>sendfile</code>是Linux2.1内核版本后引入的一个系统调用函数，API如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>out_fd:为待写入内容的文件描述符，一个socket描述符。，</li><li>in_fd:为待读出内容的文件描述符，必须是真实的文件，不能是socket和管道。</li><li>offset：指定从读入文件的哪个位置开始读，如果为NULL，表示文件的默认起始位置。</li><li>count：指定在fdout和fdin之间传输的字节数。</li></ul><p>sendfile表示在两个文件描述符之间传输数据，它是在<strong>操作系统内核</strong>中操作的，<strong>避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作</strong>，因此可以使用它来实现零拷贝。</p><p>sendfile实现的零拷贝流程如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426175356744.png" alt="image-20240426175356744"></p><ol><li>用户进程发起sendfile系统调用，<strong>上下文（切换1）从用户态转向内核态</strong></li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU将读缓冲区中数据拷贝到socket缓冲区</li><li>DMA控制器，异步把数据从socket缓冲区拷贝到网卡，</li><li><strong>上下文（切换2）从内核态切换回用户态</strong>，sendfile调用返回。</li></ol><p>可以发现，<code>sendfile</code>实现的零拷贝，I/O发生了<strong>2</strong>次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中，包括了<strong>2次DMA拷贝和1次CPU拷贝</strong>。那能不能把CPU拷贝的次数减少到0次呢？有的，即带有DMA收集拷贝功能的sendfile！</p><h3 id="sendfile-DMA-scatter-gather"><a href="#sendfile-DMA-scatter-gather" class="headerlink" title="sendfile+DMA scatter/gather"></a>sendfile+DMA scatter/gather</h3><p>linux 2.4版本之后，对<code>sendfile</code>做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了<code>scatter/gather</code>操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去<strong>一次CPU拷贝</strong>。</p><p>sendfile+DMA scatter/gather实现的零拷贝流程如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426175456788.png" alt="image-20240426175456788"></p><ol><li>用户进程发起sendfile系统调用，<strong>上下文（切换1）从用户态转向内核态</strong></li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU把内核缓冲区中的<strong>文件描述符信息</strong>（包括内核缓冲区的内存地址和偏移量）发送到socket缓冲区</li><li>DMA控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡</li><li><strong>上下文（切换2）从内核态切换回用户态</strong>，sendfile调用返回。</li></ol><p>可以发现，<code>sendfile+DMA scatter/gather</code>实现的零拷贝，I/O发生了<strong>2</strong>次用户空间与内核空间的上下文切换，以及2次数据拷贝。其中2次数据拷贝都是包<strong>DMA拷贝</strong>。这就是真正的 <strong>零拷贝（Zero-copy)</strong> 技术，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的。</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>基于 splice 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p><ol><li>用户进程通过 splice() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），splice 系统调用执行返回。</li></ol><p>splice 拷贝方式也同样存在用户程序不能对数据进行修改的问题。除此之外，它使用了 Linux 的管道缓冲机制，可以用于任意两个文件描述符中传输数据，但是它的两个文件描述符参数中有一个必须是管道设备。</p><p><strong>总结</strong></p><p>无论是传统 I/O 拷贝方式还是引入零拷贝的方式，2 次 DMA Copy 是都少不了的，因为两次 DMA 都是依赖硬件完成的。下面从 CPU 拷贝次数、DMA 拷贝次数以及系统调用几个方面总结一下上述几种 I/O 拷贝方式的差别。</p><div class="table-container"><table><thead><tr><th>拷贝方式</th><th>CPU拷贝</th><th>DMA拷贝</th><th>系统调用</th><th>上下文切换</th></tr></thead><tbody><tr><td>传统方式（read + write）</td><td>2</td><td>2</td><td>read / write</td><td>4</td></tr><tr><td>内存映射（mmap + write）</td><td>1</td><td>2</td><td>mmap / write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile + DMA gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>splice</td><td>0</td><td>2</td><td>splice</td><td>2</td></tr></tbody></table></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/user/3104676567320286/posts">零壹技术栈</a></li><li><a href="https://juejin.cn/user/4406498336190638/posts">潜行前行</a></li><li><a href="https://www.modb.pro/db/218517">看一遍就理解：零拷贝详解</a></li></ul>]]></content>
    
    
    <summary type="html">零拷贝</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>页中断</title>
    <link href="https://penge666.github.io/posts/54462149.html"/>
    <id>https://penge666.github.io/posts/54462149.html</id>
    <published>2024-04-26T08:29:19.000Z</published>
    <updated>2024-04-26T08:58:28.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote><p><strong>Linux虚拟内存系统</strong></p></blockquote><p>Linux将虚拟内存组织成一些区域(也叫做段)的集合。一个区域(area)就是已经存在着的(已分配的)虚拟内存的连续片(chunk)，这些页是以某种方式相关联的。例如，代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域的概念很重要，因为它允许虚拟地址空间有间隙。内核不用记录那些不存在的虚拟页，而这样的页也不占用内存、磁盘或者内核本身中的任何额外资源。</p><p>Linux将虚拟内存组织成一些区域(也叫做段)的集合。一个区域(area)就是已经存在着的(已分配的)虚拟内存的连续片(chunk)，这些页是以某种方式相关联的。如下图所示</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426163611028.png" alt="image-20240426163611028"></p><p>下图强调了记录一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的任务结构(源代码中的task_struct)。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行目标文件的名字，以及程序计数器)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426163509993.png" alt="image-20240426163509993"></p><p>任务结构中的一个条目指向mm_struct，它描述了虚拟内存的当前状态。我们感兴趣的两个字段是 pgd和mmap，其中 pgd指向第一级页表(页全局目录)的基址，而mmap指向一个vm area_structs(区域结构)的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pgd存放在CR3控制寄存器中。</p><p>一个具体的区域结构包含以下字段：</p><ul><li>vm_start:指向这个区域的起始处。</li><li>vm_end:指向这个区域的结束处。</li><li>vm_prot:描述这个区域内包含的所有页的读写许可权限。</li><li>vm_flags:描述这个区域内的页面是与其他进程共享的，还是这个进程私有的(还描述了其他一些信息)。</li><li>vm_next:指向链表中下一个区域结构。</li></ul><blockquote><p><strong>页中断异常处理</strong></p></blockquote><p>假设 MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤:</p><ol><li>虚拟地址A是合法的吗?换句话说，A在某个区域结构定义的区域内吗?为了回答这个问题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而婆止这个进程。这个情况在图9-28中标识为“1”。<br>因为一个进程可以创建任意数量的新虚拟内存区域(使用在下一节中描述的mmap函数)，所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行查找。</li><li>试图进行的内存访问是否合法?换句话说，进程是否有读、写或者执行这个区域内页面的权限?例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的?这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的?如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这种情况在图9-28中标识为“2”。</li><li>此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的:选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到 MMU。这次，MMU就能正常地翻译A，而不会再产生缺页中断了。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426165657036.png" alt="image-20240426165657036"></p><h2 id="fork原理"><a href="#fork原理" class="headerlink" title="fork原理"></a>fork原理</h2><p><strong>fork原理：写保护中断与写时复制</strong></p><p>父进程和子进程不仅可以访问共有的变量，还可以各自修改这个变量，并且这个修改对方都看不见。这其实是 fork 的一种写时复制机制，而里面起关键作用的就是写保护中断。</p><p>实际上，操作系统为每个进程提供了一个进程管理的结构，在偏理论的书籍里一般会称它为进程控制块（Process Control Block，PCB)。具体到 Linux 系统上，PCB 就是 task_struct 这个结构体。它里面记录了进程的页表基址，打开文件列表、信号、时间片、调度参数和线性空间已经分配的内存区域等等数据。</p><p>其中，<strong>描述线性空间已分配的内存区域的结构对于内存管理至关重要</strong>。在 Linux 源码中，负责这个功能的结构是 vm_area_struct，后面简称 vma【也是前置知识中提到的】。内核将每一段具有相同属性的内存区域当作一个单独的内存对象进行管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> &#123; </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_start;      <span class="comment">// 区间首地址</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_end;        <span class="comment">// 区间尾地址</span></span><br><span class="line">  <span class="type">pgprot_t</span>      vm_page_prot;  <span class="comment">// 访问控制权限</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_flags;      <span class="comment">// 标志位</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> * vm_file;       <span class="comment">// 被映射的文件</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;      <span class="comment">// 文件中的偏移量</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在操作系统内核里，fork 的第一个动作是把 PCB 复制一份，但类似于物理页等进程资源不会被复制</strong>。这样的话，父进程与子进程的代码段、数据段、堆和栈都是相同的，这是因为它们拥有相同的页表，自然也有相同的虚拟空间布局和对物理内存的映射。如果父进程在 fork 子进程之前创建了一个变量，打开了一个文件，那么父子进程都能看到这个变量和文件。</p><p><strong>fork 的第二个动作是复制页表和 PCB 中的 vma 数组，并把所有当前正常状态的数据段、堆和栈空间的虚拟内存页，设置为不可写，然后把已经映射的物理页面的引用计数加 1</strong>。这一步只需要复制页表和修改 PTE 中的写权限位可以了，并不会真的为子进程的所有内存空间分配物理页面，修改映射，所以它的效率是非常高的。这时，父子进程的页表的情况如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426164350719.png" alt="image-20240426164350719"></p><p>在上图中，物理页括号中的数字代表该页被多少个进程所引用。Linux 中用于管理物理页面，和维护物理页的引用计数的结构是 mem_map 和 page struct。</p><p>接下来，就是写保护中断要发挥作用的地方了。不管是父进程还是子进程，它们接下来都有可能发生写操作，但我们知道在 fork 的第二步操作中，已经将所有原来可写的地方都变成不可写了，所以这时必然会发生写保护中断。</p><p>我们刚才说，Linux 系统的页中断的入口地址是 do_page_fault，在这个函数里，它会继续判断中断的类型。由于发生中断的虚拟地址在 vma 中是可写的，在 PTE 中却是只读的，可以断定这是一次写保护中断。这时候，内核就会转而调用 do_wp_page 来处理这次中断，wp 是 write protection 的缩写。</p><p>在 do_wp_page 中，系统会首先判断发生中断的虚拟地址所对应的物理地址的引用计数，如果大于 1，就说明现在存在多个进程共享这一块物理页面，那么它就需要为发生中断的进程再分配一个物理页面，把老的页面内容拷贝进这个新的物理页，最后把发生中断的虚拟地址映射到新的物理页。这就完成了一次写时复制 (Copy On Write， COW）。具体过程如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426164426565.png" alt="image-20240426164426565"></p><p>在上图中，当子进程发生写保护中断后，系统就会为它分配新的物理页，然后复制页面，再修改页表映射。这时老的物理页的引用计数就变为 1，同时子进程中的 PTE 的权限也从只读变为读写。</p><p>当父进程再访问到这个地址时，也会触发一次写保护中断，这时系统发现物理页的引用计数为 1，那就只要把父进程 PTE 中的权限，简单地从只读变为读写就可以了。</p><p>总结：</p><p>fork 在执行时，子进程只会复制父进程的 PCB 和页表，并且把所有页表项都设为只读，这个过程并不会复制真正的物理页。只有当父子进程其中一个对页进行写操作的时候，才会复制一个副本出来。这种机制被称为写时复制。</p><h2 id="execve原理"><a href="#execve原理" class="headerlink" title="execve原理"></a>execve原理</h2><p><strong>execve原理：缺页中断</strong></p><p>execve 的作用是使当前进程执行一个新的可执行程序，它的原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* argv[],<span class="type">const</span> <span class="type">char</span>* envp[])</span></span><br></pre></td></tr></table></figure><p>其中 execve 的第一个参数是可执行程序的文件名，第二个参数用来传递命令行参数，第三个参数用来传递环境变量。</p><p>execve 的执行步骤如下所示：</p><ol><li>清空页表，这样整个进程中的页都变成不存在了，一旦访问这些页，就会发生页中断；</li><li>打开待加载执行的文件，在内核中创建代表这个文件的 struct file 结构；</li><li>加载和解析文件头，文件头里描述了这个可执行文件一共有多少 section；</li><li>创建相应的 vma 来描述代码段，数据段，并且将文件的各个 section 与这些内存区域建立映射关系；</li><li>如果当前加载的文件还依赖其他共享库文件，则找到这个共享库文件，并跳转到第 2 步继续处理这个共享库文件；</li><li>最后跳转到可执行程序的入口处执行。</li></ol><p><strong>execve 的实现并不负责将文件内容加载到物理页中，它只建立了这种文件 section，与内存区域的映射关系就结束了</strong>。真正负责加载文件内容的是缺页中断。</p><p>因为由于第 1 步把页表都清空了，这就导致 CPU 在加载指令时会发现代码段是缺失的，此时就会产生缺页中断。</p><p>Linux 内核用于处理缺页中断的函数是 do_no_page，如果内核检查，当前出现缺页中断的虚拟地址所在的内存区域 vma（虚拟地址落在该内存区域的 vm_start 和 vm_end 之间）存在文件映射 (vm_file 不为空），那就可以通过虚拟内存地址计算文件中的偏移，这就定位到了内存所缺的页对应到文件的哪一段。然后内核就启动磁盘 IO，将对应的页从磁盘加载进内存。一次缺页中断就这样被解决了。</p><h2 id="mmap原理"><a href="#mmap原理" class="headerlink" title="mmap原理"></a>mmap原理</h2><blockquote><p><strong>mmap内存映射过程</strong></p></blockquote><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p><p><strong>(一)进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p><ol><li><p>进程在用户空间调用库函数mmap，原型：void <em>mmap(void </em>start, size_t length, int prot, int flags, int fd, off_t offset);</p></li><li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址。</p></li><li><p>为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化。</p></li><li><p>将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中。</p></li></ol><p><strong>(二)调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p><ol><li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p></li><li><p>通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file <em>filp, struct vm_area_struct </em>vma)，不同于用户空间库函数。</p></li><li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p></li><li><p>通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p></li></ol><p><strong>(三)进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</strong></p><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><ol><li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p></li><li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p></li><li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p></li><li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p></li></ol><p><strong>注意：</strong>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p><blockquote><p><strong>mmap 和常规文件操作的区别</strong></p></blockquote><p>使用系统调用，函数的调用过程：</p><ol><li><p>进程发起读文件请求。</p></li><li><p>内核通过查找进程文件描述符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</p></li><li><p>inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p></li><li><p>如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p></li></ol><p>【重点】总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同、数据不通的繁琐过程。因此mmap效率更高。</p><p><strong>Note</strong>：使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://joytsing.cn/posts/30090/">mmap,比想象的更重要一点</a></li><li>极客时间</li><li>《深入理解计算机系统》</li></ul>]]></content>
    
    
    <summary type="html">强大的页中断</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>EXT文件系统</title>
    <link href="https://penge666.github.io/posts/93870e50.html"/>
    <id>https://penge666.github.io/posts/93870e50.html</id>
    <published>2024-04-26T06:26:10.000Z</published>
    <updated>2024-04-26T06:29:51.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EXT文件系统"><a href="#EXT文件系统" class="headerlink" title="EXT文件系统"></a>EXT文件系统</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>强烈推荐看完这篇Blog，自己动手亲自实现一个min的文件系统，成就感满满~</p><p>课程信息：CSE.30341.FA17: Project 06：Simple File System</p><p>链接：<a href="https://www3.nd.edu/~pbui/teaching/cse.30341.fa17/project06.html">https://www3.nd.edu/~pbui/teaching/cse.30341.fa17/project06.html</a></p><p>由于实验要求，这里不放仓库链接🔗。有需要参考的小伙伴可私我。</p><h3 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h3><p>在学习知识前，最好要有个整体的认知，再去学习细节。要不然容易陷入细节迷失方向。</p><p>先来个整体的认知</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133829332.png" alt="image-20240426133829332"></p><ul><li><a href="https://www.bilibili.com/video/BV1ce4y1R7et/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d6efee335659a376be8deb6c0654e9f7">一文彻底搞懂文件系统。文件系统，跪下！23计算机考研操作系统复盘之文件系统</a></li></ul><p>文件系统的类型有很多种</p><ul><li>CentOS 5和CentOS 6上默认使用的ext2/ext3/ext4</li><li>CentOS 7上默认使用的xfs</li><li>windows上的NTFS</li><li>光盘类的文件系统ISO9660</li><li>MAC上的混合文件系统HFS</li><li>网络文件系统NFS</li><li>Oracle研发的btrfs</li><li>还有老式的FAT/FAT32等。</li></ul><h3 id="1-文件系统的组成部分"><a href="#1-文件系统的组成部分" class="headerlink" title="1.文件系统的组成部分"></a>1.文件系统的组成部分</h3><h4 id="1-1-block的出现"><a href="#1-1-block的出现" class="headerlink" title="1.1 block的出现"></a>1.1 block的出现</h4><p>硬盘最底层的读写IO一次是一个扇区512字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为LBA【(Logical Block Addressing)逻辑块寻址模式】。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。</p><p>到了Linux操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为1024bytes(1K)或2048bytes(2K)或4096bytes(4K)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的IO管理器知道如何将它的数据块翻译成磁盘维护的数据块地址LBA。</p><p>对于使用文件系统的IO操作来说，比如读写文件，这些IO的基本单元是文件系统上的数据块，一次读写一个文件系统数据块。比如需要读一个或多个块时，<strong>文件系统的IO管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去</strong>。</p><p>正如标题所示，本文重点是在文件系统而不是在磁盘，所以<strong>后文出现的block均表示的是文件系统的数据块</strong>而不是磁盘维护的逻辑块。</p><p>文件系统block的出现使得在文件系统层面上读写性能大大提高，也大量减少了碎片。但是它的副作用是可能造成空间浪费。由于文件系统以block为读写单元，即使存储的文件只有1K大小也将占用一个block，剩余的空间完全是浪费的。</p><h4 id="1-2-inode的出现"><a href="#1-2-inode的出现" class="headerlink" title="1.2 inode的出现"></a>1.2 inode的出现</h4><p>问题1：如果一个文件系统占用大量的block读取时会如何？</p><p>假如block大小为1KB，仅仅存储一个10M的文件就需要10240个block，而且这些blocks很可能在位置上是不连续在一起的(不相邻)，读取该文件时难道要从前向后扫描整个文件系统的块，然后找出属于该文件的块吗?显然是不应该这么做的，因为太慢太傻瓜式了。</p><p>问题2：如果一个文件系统占用少量的block读取时会如何？</p><p>假设读取一个只占用1个block的文件，难道只读取一个block就结束了吗?并不是，仍然是扫描整个文件系统的所有block，因为它不知道什么时候扫描到，扫描到了它也不知道这个文件是不是已经完整而不需要再扫描其他的block。</p><p>问题3：文件名的元数据存储在哪里呢？</p><p>……</p><p>对于类似问题，我们是使用索引，因为通过扫描索引找到对应的数据，而且索引可以存储部分数据。</p><p>在文件系统上索引技术具体化为索引节点(index node)，在索引节点上存储的部分数据即为文件的属性元数据及其他少量信息。一般来说索引占用的空间相比其索引的文件数据而言占用的空间就小得多，扫描它比扫描整个数据要快得多，否则索引就没有存在的意义。这样一来就解决了前面所有的问题。</p><p>在文件系统上的术语中，索引节点称为inode。在inode中存储了inode号、文件类型、权限、文件所有者、大小、时间戳等元数据信息，最重要的是还存储了指向属于该文件block的指针，这样<strong>读取inode就可以找到属于该文件的block</strong>，进而读取这些block并获得该文件的数据。为了方便称呼和区分，暂且将这个inode记录中指向文件data block的指针称之为block指针。</p><p>以下是ext2文件系统中inode包含的信息示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Inode: 12 Type: regular Mode: 0644 Flags: 0x0 </span><br><span class="line">Generation: 1454951771 Version: 0x00000000:00000001 </span><br><span class="line">User: 0 Group: 0 Size: 5 </span><br><span class="line">File ACL: 0 Directory ACL: 0 </span><br><span class="line">Links: 1 Blockcount: 8 </span><br><span class="line">Fragment: Address: 0 Number: 0 Size: 0 </span><br><span class="line"> ctime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line"> atime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line"> mtime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line">crtime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018 </span><br><span class="line">Size of extra inode fields: 28 </span><br><span class="line">BLOCKS: </span><br><span class="line">(0):1024 </span><br><span class="line">TOTAL: 1 </span><br></pre></td></tr></table></figure><p>一般inode大小为128字节或256字节，相比那些MB或GB计算的文件数据而言小得多的多，但也要知道可能一个文件大小小于inode大小，例如只占用1个字节的文件。</p><h4 id="1-3-bmap出现"><a href="#1-3-bmap出现" class="headerlink" title="1.3 bmap出现"></a>1.3 bmap出现</h4><p>在向硬盘存储数据时，文件系统需要知道哪些块是空闲的，哪些块是已经占用了的。最笨的方法当然是从前向后扫描，遇到空闲块就存储一部分，继续扫描直到存储完所有数据。</p><blockquote><p>解释：空闲的含义</p></blockquote><p>在文件系统中，”空闲块” 指的是尚未被任何文件或数据占用的磁盘块。文件系统需要维护一个列表或者位图来记录哪些磁盘块是空闲的，以及哪些磁盘块已经被文件或者数据占用了。这样的信息可以帮助文件系统有效地管理磁盘空间，确保数据的存储和检索操作能够正常进行。</p><p>当文件系统需要为新文件或者数据分配存储空间时，它会查找空闲块列表或者位图，找到一个或者多个空闲的磁盘块，并将它们标记为已经被占用。相反，当文件或者数据被删除时，文件系统会将对应的磁盘块标记为空闲，以便后续被重用。</p><p>通过维护空闲块列表或者位图，文件系统可以实现对磁盘空间的动态管理，确保磁盘空间的高效利用。</p><hr><p>优化的方法当然也可以考虑使用索引，但是仅仅1G的文件系统就有1KB的block共1024*1024=1048576个【1G/1K】，这仅仅只是1G，如果是100G、500G甚至更大呢，仅仅使用索引索引的数量和空间占用也将极大，这时就出现更高一级的优化方法：使用块位图(bitmap简称bmap)。</p><p>位图只使用0和1标识对应block是空闲还是被占用，0和1在位图中的位置和block的位置一一对应，第一位标识第一个块，第二个位标识第二个块，依次下去直到标记完所有的block。</p><p>思考：为什么块位图更优化？</p><p>在位图中1个字节8个位，可以标识8个block。对于一个block大小为1KB、容量为1G的文件系统而言，block数量有1024 <em> 1024个，所以在位图中使用1024 </em> 1024个位共1024 * 1024/8=131072字节=128K，即1G的文件只需要128个block做位图就能完成一一对应。通过扫描这100多个block就能知道哪些block是空闲的，速度提高了非常多。</p><p>但是要注意，<strong>bmap的优化针对的是写优化</strong>，因为只有写才需要找到空闲block并分配空闲block。对于读而言，只要通过inode找到了block的位置，cpu就能迅速计算出block在物理磁盘上的地址，cpu的计算速度是极快的，计算block地址的时间几乎可以忽略，那么读速度基本认为是受硬盘本身性能的影响而与文件系统无关。大多数稍大一点的文件可能都会存储在不连续的block上，而且使用了一段时间的文件系统可能会有不少碎片，这时硬盘的随机读取性能直接决定读数据的速度，这也是机械硬盘速度相比固态硬盘慢的多的多的原因之一，而且固态硬盘的随机读和连续读取速度几乎是一致的，对它来说，文件系统碎片的多少并不会影响读取速度。</p><p>虽然bmap已经极大的优化了扫描，但是仍有其瓶颈：如果文件系统是100G呢?</p><p>100G的文件系统要使用128*100=12800个1KB大小的block，这就占用了12.5M的空间了。试想完全扫描12800个很可能不连续的block这也是需要占用一些时间的，虽然快但是扛不住每次存储文件都要扫描带来的巨大开销。</p><p>所以需要再次优化，如何优化?简而言之就是将文件系统划分开形成块组，至于块组的介绍放在后文。</p><h4 id="1-4-inode表的出现"><a href="#1-4-inode表的出现" class="headerlink" title="1.4 inode表的出现"></a>1.4 inode表的出现</h4><p>回顾下inode相关信息：inode存储了inode号、文件属性元数据、指向文件占用的block的指针;<strong>每一个inode占用128字节或256字节。</strong></p><p>现在又出现问题了，一个文件系统中可以说有无数多个文件，每一个文件都对应一个inode，难道每一个仅128字节的inode都要单独占用一个block进行存储吗?这太浪费空间了。</p><p>所以更优的方法是将多个inode合并存储在block中，对于128字节的inode，一个block存储8【1K/128B】个inode，对于256字节的inode，一个block存储4个inode。这就使得每个存储inode的块都不浪费。</p><p>在ext文件系统上，将这些物理上存储inode的block组合起来，在逻辑上形成一张inode表(inode table)来记录所有的inode。</p><p>举个例子，每一个家庭都要向派出所登记户口信息，通过户口本可以知道家庭住址，而每个镇或街道的派出所将本镇或本街道的所有户口整合在一起，要查找某一户地址时，在派出所就能快速查找到。inode table就是这里的派出所。它的内容如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425201144640.png" alt=""></p><p>实际上，在文件系统创建完成后所有的inode号都已经分配好并记录到inode table中了，只不过被使用的inode号所在的行还有文件属性的元数据信息和block位置信息，而未被使用的inode号只有一个inode号而已而没有其他信息而已。</p><p>再细细一思考，就能发现一个大的文件系统仍将占用大量的块来存储inode，想要找到其中的一个inode记录也需要不小的开销，尽管它们已经形成了一张逻辑上的表，但扛不住表太大记录太多。那么如何快速找到inode，这同样是需要优化的，优化的方法是将文件系统的block进行分组划分，每个组中都存有本组inode table范围、bmap等。</p><h4 id="1-5-imap的出现"><a href="#1-5-imap的出现" class="headerlink" title="1.5 imap的出现"></a>1.5 imap的出现</h4><p>前面说bmap是块位图，用于标识文件系统中哪些block是空闲哪些block是占用的。</p><p>对于inode也一样，在存储文件(Linux中一切皆文件)时需要为其分配一个inode号。但是在格式化创建文件系统后所有的inode号都是被事先设定好存放在inode table中的，因此产生了问题：要为文件分配哪一个inode号呢?又如何知道某一个inode号是否已经被分配了呢?</p><p>既然是”是否被占用”的问题，使用位图是最佳方案，像bmap记录block的占用情况一样。标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。</p><p>imap存在着和bmap和inode table一样需要解决的问题：如果文件系统比较大，imap本身就会很大，每次存储文件都要进行扫描，会导致效率不够高。同样，优化的方式是将文件系统占用的block划分成块组，每个块组有自己的imap范围。</p><h4 id="1-6-块组的出现"><a href="#1-6-块组的出现" class="headerlink" title="1.6 块组的出现"></a>1.6 块组的出现</h4><p>前面一直提到的优化方法是将文件系统占用的block划分成块组(block group)，解决bmap、inode table和imap太大的问题。</p><p>在物理层面上的划分是将磁盘按柱面划分为多个分区，即多个文件系统。在逻辑层面上的划分是将文件系统划分成块组。<strong>每个文件系统包含多个块组，每个块组包含多个元数据区和数据区</strong>【看下节的图】：</p><ul><li>元数据区就是存储bmap、inode table、imap等的数据;</li><li>数据区就是存储文件数据的区域。</li></ul><p>注意块组是逻辑层面的概念，所以并不会真的在磁盘上按柱面、按扇区、按磁道等概念进行划分。</p><h4 id="1-7-块组的划分"><a href="#1-7-块组的划分" class="headerlink" title="1.7 块组的划分"></a>1.7 块组的划分</h4><p>块组在文件系统创建完成后就已经划分完成了，也就是说元数据区bmap、inode table和imap等信息占用的block以及数据区占用的block都已经划分好了。那么文件系统如何知道一个块组元数据区包含多少个block，数据区又包含多少block呢?</p><p>它只需确定一个数据——每个block的大小，再根据bmap至多只能占用一个完整的block的标准就能计算出块组如何划分。如果文件系统非常小，所有的bmap总共都不能占用完一个block，那么也只能空闲bmap的block了。</p><p>每个block的大小在创建文件系统时可以人为指定，不指定也有默认值。</p><p>假如现在block的大小是1KB，一个bmap完整占用一个block能标识1024*8= 8192个block(当然这8192个block是数据区和元数据区共8192个，因为元数据区分配的block也需要通过bmap来标识)。每个block是1K，每个块组是8192K即8M，创建1G的文件系统需要划分1024/8=128个块组，如果是1.1G的文件系统呢?128+12.8=128+13=141个块组。【给出block的大小，就可以从文件大小计算出快组的个数】</p><p>每个组的block数目是划分好了，但是每个组设定多少个inode号呢?inode table占用多少block呢?这需要由系统决定了，因为描述”每多少个数据区的block就为其分配一个inode号”的指标默认是我们不知道的，当然创建文件系统时也可以人为指定这个指标或者百分比例。见后文”inode深入”。</p><p>使用dumpe2fs可以将ext类的文件系统信息全部显示出来，当然bmap是每个块组固定一个block的不用显示，imap比bmap更小所以也只占用1个block不用显示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215539679.png" alt="image-20240425215539679"></p><p>从这张表中能计算出文件系统的大小，该文件系统共4667136个blocks，每个block大小为4K，所以文件系统大小为4667136*4/1024/1024=17.8GB。</p><p>也能计算出分了多少个块组，因为每一个块组的block数量为32768，所以块组的数量为4667136/32768=142.4即143个块组。由于块组从0开始编号，所以最后一个块组编号为Group 142。如下图所示是最后一个块组的信息。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215816389.png" alt="image-20240425215816389"></p><h3 id="2-文件系统的完整结构"><a href="#2-文件系统的完整结构" class="headerlink" title="2. 文件系统的完整结构"></a>2. 文件系统的完整结构</h3><p>将上文描述的bmap、inode table、imap、数据区的blocks和块组的概念组合起来就形成了一个文件系统，当然这还不是完整的文件系统。完整的文件系统如下图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215902069.png" alt="image-20240425215902069"></p><p>首先，该图中多了Boot Block、Super Block、GDT、Reserver GDT这几个概念。下面会分别介绍它们。</p><p>然后，图中指明了块组中每个部分占用的block数量，除了superblock、bmap、imap能确定占用1个block，其他的部分都不能确定占用几个block。</p><p>最后，图中指明了Superblock、GDT和Reserved GDT是同时出现且不一定存在于每一个块组中的，也指明了bmap、imap、inode table和data blocks是每个块组都有的。</p><h4 id="2-1-引导块"><a href="#2-1-引导块" class="headerlink" title="2.1 引导块"></a>2.1 引导块</h4><p>即上图中的Boot Block部分，也称为boot sector。它位于分区上的第一个块，占用1024字节，并非所有分区都有这个boot sector，只有装了操作系统的主分区和装了操作系统的逻辑分区才有。里面存放的也是boot loader，这段boot loader称为VBR(主分区装操作系统时)或EBR(扩展分区装操作系统时)，这里的Boot loader和mbr上的boot loader是存在交错关系的。开机启动的时候，首先加载mbr中的bootloader，然后定位到操作系统所在分区的boot serctor上加载此处的boot loader。如果是多系统，加载mbr中的bootloader后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的boot sector上。它们之间的关系如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425220833137.png" alt="image-20240425220833137"></p><p>但是，这种方式的操作系统菜单早已经弃之不用了，而是使用grub来管理启动菜单。尽管如此，在安装操作系统时，仍然有一步是选择boot loader安装位置的步骤。</p><h4 id="2-2-超级块-superblock"><a href="#2-2-超级块-superblock" class="headerlink" title="2.2 超级块(superblock)"></a>2.2 超级块(superblock)</h4><p>既然一个文件系统会分多个块组，<strong>那么文件系统怎么知道分了多少个块组呢?每个块组又有多少block多少inode号等等信息呢?还有，文件系统本身的属性信息如各种时间戳、block总数量和空闲数量、inode总数量和空闲数量、当前文件系统是否正常、什么时候需要自检等等，它们又存储在哪里呢?</strong></p><p>毫无疑问，这些信息必须要存储在block中。存储这些信息占用1024字节，所以也要一个block，<strong>这个block称为超级块(superblock)</strong>，它的block号可能为0也可能为1。如果block大小为1K，则引导块正好占用一个block，这个block号为0，所以superblock的号为1;如果block大小大于1K，则引导块和超级块同置在一个block中，这个block号为0。总之superblock的起止位置是第二个1024(1024-2047)字节。</p><p>使用df命令读取的就是每个文件系统的superblock，所以它的统计速度非常快。相反，用du命令查看一个较大目录的已用空间就非常慢，因为不可避免地要遍历整个目录的所有文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT </span><br><span class="line">Filesystem     Type      Size  Used Avail Use% Mounted on</span><br><span class="line">udev           devtmpfs  1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs          tmpfs     388M  2.0M  386M   1% /run</span><br><span class="line">/dev/sda5      ext4       59G   43G   14G  77% /</span><br><span class="line">tmpfs          tmpfs     1.9G     0  1.9G   0% /dev/shm</span><br><span class="line">tmpfs          tmpfs     5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs          tmpfs     1.9G     0  1.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0     squashfs  128K  128K     0 100% /snap/bare/5</span><br><span class="line">/dev/loop2     squashfs   75M   75M     0 100% /snap/core22/1122</span><br><span class="line">/dev/loop1     squashfs   64M   64M     0 100% /snap/core20/2264</span><br></pre></td></tr></table></figure><p>superblock对于文件系统而言是至关重要的，超级块丢失或损坏必将导致文件系统的损坏。所以旧式的文件系统将超级块备份到每一个块组中，但是这又有所空间浪费，所以ext2文件系统只在块组0、1和3、5、7幂次方的块组中保存超级块的信息，如Group9、Group25等。尽管保存了这么多的superblock，但是文件系统只使用第一个块组即Group0中超级块信息来获取文件系统属性，只有当Group0上的superblock损坏或丢失才会找下一个备份超级块复制到Group0中来恢复文件系统。</p><p>下图是一个ext4文件系统的superblock的信息，ext家族的文件系统都能使用dumpe2fs -h获取。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425221706736.png" alt="image-20240425221706736"></p><h4 id="2-3-块组描述符表-GDT"><a href="#2-3-块组描述符表-GDT" class="headerlink" title="2.3 块组描述符表(GDT)"></a>2.3 块组描述符表(GDT)</h4><p>既然文件系统划分了块组，那么每个块组的信息和属性元数据又保存在哪里呢?</p><p><strong>ext文件系统每一个块组信息使用32字节描述，这32个字节称为块组描述符</strong>，所有块组的块组描述符组成块组描述符表GDT(group descriptor table)。</p><p>虽然每个块组都需要块组描述符来记录块组的信息和属性元数据，但是不是每个块组中都存放了块组描述符。<strong>ext文件系统的存储方式是：将它们组成一个GDT，并将该GDT存放于某些块组中，存放GDT的块组和存放superblock和备份superblock的块相同，也就是说它们是同时出现在某一个块组中的。读取时也总是读取Group0中的块组描述符表信息。</strong></p><p>假如block大小为4KB的文件系统划分了143个块组，每个块组描述符32字节，那么GDT就需要143*32=4576字节即两个block来存放。这两个GDT block中记录了所有块组的块组信息，且存放GDT的块组中的GDT都是完全相同的。</p><p>下图是一个块组描述符的信息(通过dumpe2fs获取)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425222725852.png" alt="image-20240425222725852"></p><h4 id="2-4-Reserved-GDT"><a href="#2-4-Reserved-GDT" class="headerlink" title="2.4 Reserved GDT"></a>2.4 Reserved GDT</h4><p>保留GDT：Reserved GDT</p><p>保留GDT用于以后扩容文件系统使用，防止扩容后块组太多，使得块组描述符超出当前存储GDT的blocks。保留GDT和GDT总是同时出现，当然也就和superblock同时出现了。</p><p>例如前面143个块组使用了2个block来存放GDT，但是此时第二个block还空余很多空间，当扩容到一定程度时2个block已经无法再记录块组描述符了，这时就需要分配一个或多个Reserved GDT的block来存放超出的块组描述符。</p><p>由于新增加了GDT block，所以应该让每一个保存GDT的块组都同时增加这一个GDT block，所以将保留GDT和GDT存放在同一个块组中可以直接将保留GDT变换为GDT而无需使用低效的复制手段备份到每个存放GDT的块组。</p><p>同理，新增加了GDT需要修改每个块组中superblock中的文件系统属性，所以将superblock和Reserved GDT/GDT放在一起又能提升效率。</p><h3 id="3-Data-Block"><a href="#3-Data-Block" class="headerlink" title="3.Data Block"></a>3.Data Block</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425215902069.png" alt=""></p><p>如上图，除了Data Blocks其他的部分都解释过了。data block是直接存储数据的block，但事实上并非如此简单。</p><p>数据所占用的block由文件对应inode记录中的block指针找到，不同的文件类型，数据block中存储的内容是不一样的。以下是Linux中不同类型文件的存储方式。</p><ul><li>对于常规文件，文件的数据正常存储在数据块中。</li><li>对于目录，该目录下的所有文件和一级子目录的目录名存储在数据块中。</li><li>文件名不是存储在其自身的inode中，而是存储在其所在目录的data block中。</li><li>对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。</li><li>设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。</li></ul><h4 id="3-1-目录文件的data-block"><a href="#3-1-目录文件的data-block" class="headerlink" title="3.1 目录文件的data block"></a>3.1 目录文件的data block</h4><p>对于目录文件，其inode记录中存储的是目录的inode号、目录的属性元数据和目录文件的block指针，这里面没有存储目录自身文件名的信息。</p><p>而其data block的存储方式则如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425223235705.png" alt="image-20240425223235705"></p><p>由图可知，在目录文件的数据块中存储了其下的文件名、目录名、目录本身的相对名称”.”和上级目录的相对名称”..”，还存储了指向inode table中这些文件名对应的inode号的指针(并非直接存储inode号码)、目录项长度rec_len、文件名长度name_len和文件类型file_type。注意到除了文件本身的inode记录了文件类型，其所在的目录的数据块也记录了文件类型。由于rec_len只能是4的倍数，所以需要使用”\0”来填充name_len不够凑满4倍数的部分。至于rec_len具体是什么，只需知道它是一种偏移即可。</p><p>目录的data block中并没有直接存储目录中文件的inode号，它存储的是指向inode table中对应文件inode号的指针，暂且称之为inode指针(至此，已经知道了两种指针：一种是inode table中每个inode记录指向其对应data block的block指针，一个此处的inode指针。题外话：实际上inode指针应该称之为存储在目录data blcok中的链接link，这个link和inode num一一映射，所以删除文件的函数称为unlink()，表示在目录的data block中删除这个链接)。一个很有说服力的例子，在目录只有读而没有执行权限的时候，使用”ls -l”是无法获取到其内文件inode号的，这就表明没有直接存储inode号。实际上，因为在创建文件系统的时候，inode号就已经全部划分好并在每个块组的inode table中存放好，inode table在块组中是有具体位置的，如果使用dumpe2fs查看文件系统，会发现每个块组的inode table占用的block数量是完全相同的，如下图是某分区上其中两个块组的信息，它们都占用249个block。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425223747136.png" alt="image-20240425223747136"></p><p>除了inode指针，目录的data block中还使用数字格式记录了文件类型，数字格式和文件类型的对应关系如下图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425223811142.png" alt="image-20240425223811142"></p><p>注意到目录的data block中前两行存储的是目录本身的相对名称”.”和上级目录的相对名称”..”，它们实际上是目录本身的硬链接和上级目录的硬链接。硬链接的本质后面说明。</p><p>由此也就容易理解目录权限的特殊之处了。目录文件的读权限(r)和写权限(w)，都是针对目录文件的数据块本身。由于目录文件内只有文件名、文件类型和inode指针，所以如果只有读权限，只能获取文件名和文件类型信息，无法获取其他信息，尽管目录的data block中也记录着文件的inode指针，但定位指针是需要x权限的，因为其它信息都储存在文件自身对应的inode中，而要读取文件inode信息需要有目录文件的执行权限通过inode指针定位到文件对应的inode记录上。以下是没有目录x权限时的查询状态，可以看到除了文件名和文件类型，其余的全是”?”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lisi4@xuexi tmp]$ ll -i d </span><br><span class="line"><span class="built_in">ls</span>: cannot access d/hehe: Permission denied </span><br><span class="line"><span class="built_in">ls</span>: cannot access d/haha: Permission denied </span><br><span class="line">total 0 </span><br><span class="line">? d????????? ? ? ? ? ? haha </span><br><span class="line">? -????????? ? ? ? ? ? hehe </span><br></pre></td></tr></table></figure><p>注意，xfs文件系统和ext文件系统不一样，它连文件类型都无法获取。</p><h4 id="3-2-符号链接存储方式"><a href="#3-2-符号链接存储方式" class="headerlink" title="3.2 符号链接存储方式"></a>3.2 符号链接存储方式</h4><p>符号链接即为软链接，类似于Windows操作系统中的快捷方式，它的作用是指向原文件或目录。</p><p>软链接之所以也被称为特殊文件的原因是：它一般情况下不占用data block，仅仅通过它对应的inode记录就能将其信息描述完成;符号链接的大小是其指向目标路径占用的字符个数，例如某个符号链接的指向方式为”rmt —&gt; ../sbin/rmt”，则其文件大小为11字节;只有当符号链接指向的目标的路径名较长(60个字节)时文件系统才会划分一个data block给它;它的权限如何也不重要，因它只是一个指向原文件的”工具”，最终决定是否能读写执行的权限由原文件决定，所以很可能ls -l查看到的符号链接权限为777。</p><p>注意，软链接的block指针存储的是目标文件名。也就是说，链接文件的一切都依赖于其目标文件名。这就解释了为什么/mnt的软链接/tmp/mnt在/mnt挂载文件系统后，通过软链接就能进入/mnt所挂载的文件系统。究其原因，还是因为其目标文件名”/mnt”并没有改变。</p><p>例如以下筛选出了/etc/下的符号链接，注意观察它们的权限和它们占用的空间大小。</p><h4 id="3-3-设备文件、FIFO、套接字文件"><a href="#3-3-设备文件、FIFO、套接字文件" class="headerlink" title="3.3 设备文件、FIFO、套接字文件"></a>3.3 设备文件、FIFO、套接字文件</h4><p>关于这3种文件类型的文件只需要通过inode就能完全保存它们的信息，它们不占用任何数据块，所以它们是特殊文件。</p><p>设备文件的主设备号和次设备号也保存在inode中。以下是/dev/下的部分设备信息。注意到它们的第5列和第6列信息，它们分别是主设备号和次设备号，主设备号标识每一种设备的类型，次设备号标识同种设备类型的不同编号;也注意到这些信息中没有大小的信息，因为设备文件不占用数据块所以没有大小的概念。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># ll /dev | tail </span></span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 129 Oct 7 21:26 vcsa1 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 130 Oct 7 21:27 vcsa2 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 131 Oct 7 21:27 vcsa3 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 132 Oct 7 21:27 vcsa4 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 133 Oct 7 21:27 vcsa5 </span><br><span class="line">crw-rw---- 1 vcsa <span class="built_in">tty</span> 7, 134 Oct 7 21:27 vcsa6 </span><br><span class="line">crw-rw---- 1 root root 10, 63 Oct 7 21:26 vga_arbiter </span><br><span class="line">crw------- 1 root root 10, 57 Oct 7 21:26 vmci </span><br><span class="line">crw-rw-rw- 1 root root 10, 56 Oct 7 21:27 vsock </span><br><span class="line">crw-rw-rw- 1 root root 1, 5 Oct 7 21:26 zero </span><br></pre></td></tr></table></figure><h3 id="4-inode基础知识"><a href="#4-inode基础知识" class="headerlink" title="4.inode基础知识"></a>4.inode基础知识</h3><p>每个文件都有一个inode，在将inode关联到文件后系统将通过inode号来识别文件，而不是文件名。并且访问文件时将先找到inode，通过inode中记录的block位置找到该文件。</p><p>Q：为什么要要链接？</p><p>A：为了方便用户访问文件，可以将一个文件或目录与另一个文件或目录建立关联，从而实现多个路径指向同一个文件或目录的效果。</p><p>Q：为什么需要硬和软两种链接呢？</p><p>A：</p><ul><li><strong>硬链接</strong>是指在<strong>同一个文件系统中</strong>，将一个文件名关联到一个已经存在的文件上，使得该文件名也可以访问该文件。</li><li><strong>软链接</strong>（也称符号链接）是指在<strong>不同的文件系统之间</strong>，将一个文件名关联到另一个文件上，使得该文件名也可以访问该文件。</li></ul><h4 id="4-1-硬链接"><a href="#4-1-硬链接" class="headerlink" title="4.1 硬链接"></a>4.1 硬链接</h4><p><strong>本质：硬链接就是多个文件名指向同一个文件的数据块。</strong></p><p>虽然每个文件都有一个inode，但是存在一种可能：多个文件的inode相同，也就即inode号、元数据、block位置都相同，这是一种什么样的情况呢?</p><p>能够想象这些inode相同的文件使用的都是同一条inode记录，所以代表的都是同一个文件，这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。这种inode相同的文件在Linux中被称为”硬链接”。</p><p>硬链接文件的inode都相同，每个文件都有一个”硬链接数”的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  <span class="built_in">ls</span> -l</span><br><span class="line">total 40</span><br><span class="line">-rwxrwxr-x 1 penge penge 18264 4月  17 13:32 a.out</span><br><span class="line">-rw-rw-r-- 1 penge penge   196 4月  25 17:11 example.c</span><br><span class="line">-rw-rw-r-- 1 penge penge  4240 4月  17 13:31 example.o</span><br><span class="line">-rw-rw-r-- 1 penge penge    56 4月  17 13:31 external.c</span><br><span class="line">-rw-rw-r-- 1 penge penge  2952 4月  17 13:32 external.o</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">ls</span> -i file1</span><br><span class="line">1055165 file1</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">ls</span> -i file2</span><br><span class="line">1055165 file2</span><br></pre></td></tr></table></figure><p>例如下图描述的是dir1目录中的文件name1及其硬链接dir2/name2，右边分别是它们的inode和datablock。这里也看出了硬链接文件之间唯一不同的就是其所在目录中的记录不同。注意下图中有一列Link Count就是标记硬链接数的属性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426105519520.png" alt="image-20240426105519520"></p><p>每创建一个文件的硬链接，实质上是多一个指向该inode记录的inode指针，并且硬链接数加1。</p><p>删除文件的实质是删除该文件所在目录data block中的对应的inode指针，所以也是减少硬链接次数，由于block指针是存储在inode中的，所以不是真的删除数据，如果仍有其他指针指向该inode，那么该文件的block指针仍然是可用的。当硬链接次数为1时再删除文件就是真的删除文件了，此时inode记录中block指针也将被删除。</p><p>不能跨分区创建硬链接，因为不同文件系统的inode号可能会相同，如果允许创建硬链接，复制到另一个分区时inode可能会和此分区已使用的inode号冲突。</p><p>硬链接只能对文件创建，无法对目录创建硬链接。【这里我的理解是可能会导致循环引用的情况】之所以无法对目录创建硬链接，是因为文件系统已经把每个目录的硬链接创建好了，它们就是相对路径中的”.”和”..”，分别标识当前目录的硬链接和上级目录的硬链接。每一个目录中都会包含这两个硬链接，它包含了两个信息：</p><p>(1) 一个没有子目录的目录文件的硬链接数是2，其一是目录本身，即该目录datablock中的”.”，其二是其父目录datablock中该目录的记录，这两者都指向同一个inode号;</p><p>(2) 一个包含子目录的目录文件，其硬链接数是2+子目录数，因为每个子目录都关联一个父目录的硬链接”..”。很多人在计算目录的硬链接数时认为由于包含了”.”和”..”，所以空目录的硬链接数是2，这是错误的，因为”..”不是本目录的硬链接。另外，还有一个特殊的目录应该纳入考虑，即”/“目录，它自身是一个文件系统的入口，是自引用(下文中会解释自引用)的，所以”/“目录下的”.”和”..”的inode号相同，它自身不占用硬链接，因为其datablock中只记录inode号相同的”.”和”..”，不再像其他目录一样还记录一个名为”/“的目录，所以”/“的硬链接数也是2+子目录数，但这个2是”.”和”..”的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># ln /tmp /mydata </span></span><br><span class="line"><span class="built_in">ln</span>: `/tmp<span class="string">&#x27;: hard link not allowed for directory </span></span><br></pre></td></tr></table></figure><p>为什么文件系统自己创建好了目录的硬链接就不允许人为创建呢?从”.”和”..”的用法上考虑，如果当前目录为/usr，我们可以使用”./local”来表示/usr/local，但是如果我们人为创建了/usr目录的硬链接/tmp/husr，难道我们也要使用”/tmp/husr/local”来表示/usr/local吗?这其实已经是软链接的作用了。若要将其认为是硬链接的功能，这必将导致硬链接维护的混乱。【这个解释也很好】</p><p>不过，通过mount工具的”—bind”选项，可以将一个目录挂载到另一个目录下，实现伪”硬链接”，它们的内容和inode号是完全相同的。</p><p>硬链接的创建方法： ln file_target link_name 。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426140728344.png" alt="image-20240426140728344"></p><h4 id="4-2-软链接"><a href="#4-2-软链接" class="headerlink" title="4.2 软链接"></a>4.2 软链接</h4><p><strong>软链接的本质是一个包含目标文件或目录路径的小文件，而不是像硬链接一样直接指向数据块。当你访问软链接时，文件系统会根据该链接中包含的路径找到目标文件或目录，并将操作重定向到目标。</strong></p><p>软链接就是字符链接，<strong>链接文件默认指的就是字符链接文件(注意不是字符设备)，使用”l”表示其类型。</strong></p><p>硬链接不能跨文件系统创建，否则inode号可能会冲突。于是实现了软链接以便跨文件系统建立链接。既然是跨文件系统，那么软链接必须得有自己的inode号。</p><p>软链接在功能上等价与Windows系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。可以认为软链接inode记录中的指针内容是目标路径的字符串。</p><p>创建方式： ln –s source_file softlink_name ，记住是source_file&lt;—link_name的指向关系(反箭头)，以前我老搞错位置。</p><p>查看软链接的值： readlink softlink_name</p><p>在设置软链接的时候，<strong>source_file虽然不要求是绝对路径，但建议给绝对路径</strong>。是否还记得软链接文件的大小?它是根据软链接所指向路径的字符数计算的，例如某个符号链接的指向方式为”rmt —&gt; ../sbin/rmt”，它的文件大小为11字节，也就是说只要建立了软链接后，软链接的指向路径是不会改变的，仍然是”../sbin/rmt”。如果此时移动软链接文件本身，它的指向是不会改变的，仍然是11个字符的”../sbin/rmt”，但此时该软链接父目录下可能根本就不存在/sbin/rmt，也就是说此时该软链接是一个被破坏的软链接。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426140716839.png" alt="image-20240426140716839"></p><h4 id="4-3-实操"><a href="#4-3-实操" class="headerlink" title="4.3 实操"></a>4.3 实操</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/641716217">【Linux】硬链接 和 软链接</a></li></ul><blockquote><p><strong>硬链接</strong></p></blockquote><p>如果A文件和B文件的关系是硬连接的关系。当用户修改了A文件的内容，那么B文件的内容也会发生更改。如果修改的B文件，那么A文件的内容也会发生更改。</p><p>特点:<br>1、硬连接不限于两个文件之间，可以在多个文件之间进行。ls -l命令中显示了文件的硬连接数</p><p>2、不能对目录做硬件连接</p><p>3、不能在不同的文件系统之间做硬链接〔Linux的文件系统: ext4。xfs等等)</p><p>4、所有的硬连接，具备相同的iNode节点号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">touch</span> file1</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">ln</span> file1 file2</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  ll            </span><br><span class="line">total 88K</span><br><span class="line">-rwxrwxr-x 1 penge penge  38K 3月  10 15:14 a.out</span><br><span class="line">-rw-rw-r-- 2 penge penge    0 4月  26 14:00 file1</span><br><span class="line">-rw-rw-r-- 2 penge penge    0 4月  26 14:00 file2</span><br><span class="line">-rw-rw-r-- 1 penge penge 1.6K 3月  10 15:14 http_conn.cpp</span><br><span class="line">-rw-rw-r-- 1 penge penge  779 3月  13 11:18 http_conn.h</span><br><span class="line">-rw-rw-r-- 1 penge penge 2.7K 3月  10 10:52 locker.h</span><br><span class="line">-rwxrwxr-x 1 penge penge  21K 4月  12 10:39 main</span><br><span class="line">-rw-rw-r-- 1 penge penge    0 4月  17 13:30 main.cpp</span><br><span class="line">-rw-rw-r-- 1 penge penge 3.6K 3月  10 10:52 threadpool.h</span><br><span class="line">drwxrwxr-x 2 penge penge 4.0K 4月  16 14:25 tmp</span><br><span class="line">drwxrwxr-x 2 penge penge 4.0K 4月  25 16:05 tmp1</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">echo</span> <span class="string">&#x27;aaa&#x27;</span>&gt;file1                                                  </span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file1                                                         </span><br><span class="line">aaa</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file2</span><br><span class="line">aaa</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">echo</span> <span class="string">&#x27;bbb&#x27;</span>&gt;file2</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file2       </span><br><span class="line">bbb</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file2       </span><br><span class="line">bbb</span><br><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp  <span class="built_in">cat</span> file1</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure><blockquote><p><strong>软链接</strong></p></blockquote><p>类似Windows中的快捷方式。为一个源文件创建一个快捷方式。</p><p>1、如果源文件被删除了，也没有办法使用该快捷方式。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据</p><p>2、在ls-l中，软链接作为一种特殊的文件类型显示出来，其第一个字母是l。</p><p>3、软链接的大小是其链接文件的路径名中的字符数。</p><p>pwd -P显示文件的实际路径,而不是软连接的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  /bin  <span class="built_in">pwd</span> -P</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure><h3 id="5-inode深入"><a href="#5-inode深入" class="headerlink" title="5.inode深入"></a>5.inode深入</h3><h4 id="5-1-inode大小和划分"><a href="#5-1-inode大小和划分" class="headerlink" title="5.1 inode大小和划分"></a>5.1 inode大小和划分</h4><p>inode大小为128字节的倍数，最小为128字节。它有默认值大小，它的默认值由/etc/mke2fs.conf文件中指定。不同的文件系统默认值可能不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># cat /etc/mke2fs.conf </span></span><br><span class="line">[defaults] </span><br><span class="line"> base_features = sparse_super,filetype,resize_inode,dir_index,ext_attr </span><br><span class="line"> enable_periodic_fsck = 1 </span><br><span class="line"> blocksize = 4096 </span><br><span class="line"> inode_size = 256 </span><br><span class="line"> inode_ratio = 16384 </span><br><span class="line">[fs_types] </span><br><span class="line"> ext3 = &#123; </span><br><span class="line"> features = has_journal </span><br><span class="line"> &#125; </span><br><span class="line"> ext4 = &#123; </span><br><span class="line"> features = has_journal,extent,huge_file,flex_bg,uninit_bg,dir_nlink,extra_isize </span><br><span class="line"> inode_size = 256 </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>同样观察到这个文件中还记录了blocksize的默认值和inode分配比率inode_ratio。inode_ratio=16384表示每16384个字节即16KB就分配一个inode号，由于默认blocksize=4KB，所以每4个block就分配一个inode号。当然分配的这些inode号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个inode号。但是分配的inode自身会占用block，而且其自身大小256字节还不算小，所以inode号的浪费代表着空间的浪费。</p><p>既然知道了inode分配比率，就能计算出每个块组分配多少个inode号，也就能计算出inode table占用多少个block。</p><p>如果文件系统中大量存储电影等大文件，inode号就浪费很多，inode占用的空间也浪费很多。但是没办法，文件系统又不知道你这个文件系统是用来存什么样的数据，多大的数据，多少数据。</p><p>当然inodesize、inode分配比例、blocksize都可以在创建文件系统的时候人为指定。</p><h4 id="5-2-ext文件系统预留的inode号"><a href="#5-2-ext文件系统预留的inode号" class="headerlink" title="5.2 ext文件系统预留的inode号"></a>5.2 ext文件系统预留的inode号</h4><p>Ext预留了一些inode做特殊特性使用，如下：某些可能并非总是准确，具体的inode号对应什么文件可以使用”find / -inum NUM”查看。</p><ul><li>Ext4的特殊inode</li><li>Inode号 用途</li><li>0 不存在0号inode</li><li>1 虚拟文件系统，如/proc和/sys</li><li>2 根目录</li><li>3 ACL索引</li><li>4 ACL数据</li><li>5 Boot loader</li><li>6 未删除的目录</li><li>7 预留的块组描述符inode</li><li>8 日志inode</li><li>11 第一个非预留的inode，通常是lost+found目录</li></ul><p>所以在ext4文件系统的dumpe2fs信息中，能观察到fisrt inode号可能为11也可能为12。</p><p>并且注意到”/“的inode号为2，这个特性在文件访问时会用上。</p><p>需要注意的是，每个文件系统都会分配自己的inode号，不同文件系统之间是可能会出现使用相同inode号文件的。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># find / -ignore_readdir_race -inum 2 -ls </span></span><br><span class="line"> 2 4 dr-xr-xr-x 22 root root 4096 Jun 9 09:56 / </span><br><span class="line"> 2 2 dr-xr-xr-x 5 root root 1024 Feb 25 11:53 /boot </span><br><span class="line"> 2 0 c--------- 1 root root Jun 7 02:13 /dev/pts/ptmx </span><br><span class="line"> 2 0 -rw-r--r-- 1 root root 0 Jun 6 18:13 /proc/sys/fs/binfmt_misc/status </span><br><span class="line"> 2 0 drwxr-xr-x 3 root root 0 Jun 6 18:13 /sys/fs </span><br></pre></td></tr></table></figure><p>从结果中可见，除了根的Inode号为2，还有几个文件的inode号也是 2，它们都属于独立的文件系统，有些是虚拟文件系统，如/proc和/sys。</p><h4 id="5-3-ext2-3的inode直接、间接寻址"><a href="#5-3-ext2-3的inode直接、间接寻址" class="headerlink" title="5.3 ext2/3的inode直接、间接寻址"></a>5.3 ext2/3的inode直接、间接寻址</h4><p>前文说过，inode中保存了blocks指针，但是一条inode记录中能保存的指针数量是有限的，否则就会超出inode大小(128字节或256字节)。</p><p>在ext2和ext3文件系统中，一个inode中最多只能有15个指针，每个指针使用i_block[n]表示。</p><p>前12个指针i_block[0]到i_block[11]是直接寻址指针，每个指针指向一个数据区的block。如下图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426112610456.png" alt="image-20240426112610456"></p><p>第13个指针i_block[12]是一级间接寻址指针，它指向一个仍然存储了指针的block即i_block[12] —&gt; Pointerblock —&gt; datablock。</p><p>第14个指针i_block[13]是二级间接寻址指针，它指向一个仍然存储了指针的block，但是这个block中的指针还继续指向其他存储指针的block，即i_block[13] —&gt; Pointerblock1 —&gt; PointerBlock2 —&gt; datablock。</p><p>第15个指针i_block[14]是三级间接寻址指针，它指向一个任然存储了指针的block，这个指针block下还有两次指针指向。即i_block[13] —&gt; Pointerblock1 —&gt; PointerBlock2 —&gt; PointerBlock3 —&gt; datablock。</p><p>其中由于每个指针大小为4字节，所以每个指针block能存放的指针数量为BlockSize/4byte。例如blocksize为4KB，那么一个Block可以存放4096/4=1024个指针。</p><p>如下图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426112704312.png" alt="image-20240426112704312"></p><p>为什么要分间接和直接指针呢?如果一个inode中15个指针全是直接指针，假如每个block的大小为1KB，那么15个指针只能指向15个block即15KB的大小，由于每个文件对应一个inode号，所以就限制了每个文件最大为15*1=15KB，这显然是不合理的。</p><p>如果存储大于15KB的文件而又不太大的时候，就占用一级间接指针i_block[12]，这时可以存放指针数量为1024/4+12=268，所以能存放268KB的文件。</p><p>如果存储大于268K 的文件而又不太大的时候，就继续占用二级指针i_block[13]，这时可以存放指针数量为[1024/4]^2+1024/4+12=65804，所以能存放65804KB=64M左右的文件。</p><p>如果存放的文件大于64M，那么就继续使用三级间接指针i_block[14]，存放的指针数量为[1024/4]^3+[1024/4]^2+[1024/4]+12=16843020个指针，所以能存放16843020KB=16GB左右的文件。</p><p>如果blocksize=4KB呢?那么最大能存放的文件大小为([4096/4]^3+[4096/4]^2+[4096/4]+12)*4/1024/1024/1024=4T左右。</p><p>当然这样计算出来的不一定就是最大能存放的文件大小，它还受到另一个条件的限制。这里的计算只是表明一个大文件是如何寻址和分配的。</p><p>其实看到这里的计算数值，就知道ext2和ext3对超大文件的存取效率是低下的，它要核对太多的指针，特别是4KB大小的blocksize时。而ext4针对这一点就进行了优化，ext4使用extent的管理方式取代ext2和ext3的块映射，大大提高了效率也降低了碎片。</p><h3 id="6-单文件系统中文件操作的原理"><a href="#6-单文件系统中文件操作的原理" class="headerlink" title="6.单文件系统中文件操作的原理"></a>6.单文件系统中文件操作的原理</h3><p>在Linux上执行删除、复制、重命名、移动等操作时，它们是怎么进行的呢?还有访问文件时是如何找到它的呢?其实只要理解了前文中介绍的几个术语以及它们的作用就很容易知道文件操作的原理了。</p><p>注：在这一小节所解释的都是在单个文件系统下的行为，在多个文件系统中如何请看下一个小节：多文件系统关联。</p><h4 id="6-1-读取文件"><a href="#6-1-读取文件" class="headerlink" title="6.1 读取文件"></a><strong>6.1 读取文件</strong></h4><p>当执行”<strong>cat /var/log/messages</strong>“命令在系统内部进行了什么样的步骤呢?该命令能被成功执行涉及了cat命令的寻找、权限判断以及messages文件的寻找和权限判断等等复杂的过程。这里只解释和本节内容相关的如何寻找到被cat的/var/log/messages文件。</p><ul><li>找到根文件系统的块组描述符表所在的blocks，读取GDT(已在内存中)找到inode table的block号。</li></ul><p>因为GDT总是和superblock在同一个块组，而superblock总是在分区的第1024-2047个字节，所以很容易就知道第一个GDT所在的块组以及GDT在这个块组中占用了哪些block。</p><p>其实GDT早已经在内存中了，在系统开机的时候会挂载根文件系统，挂载的时候就已经将所有的GDT放进内存中。</p><ul><li>在inode table的block中定位到根”/“的inode，找出”/“指向的data block。</li></ul><p>前文说过，ext文件系统预留了一些inode号，其中”/“的inode号为2，所以可以根据inode号直接定位根目录文件的data block。</p><ul><li>在”/“的datablock中记录了var目录名和指向var目录文件inode的指针，并找到该inode记录，inode记录中存储了指向var的block指针，所以也就找到了var目录文件的data block。</li></ul><p>通过var目录的inode指针，可以寻找到var目录的inode记录，但是指针定位的过程中，还需要知道该inode记录所在的块组以及所在的inode table，所以需要读取GDT，同样，GDT已经缓存到了内存中。</p><ul><li>在var的data block中记录了log目录名和其inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到log的data block。</li><li>在log目录文件的data block中记录了messages文件名和对应的inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到messages的data block。</li><li>最后读取messages对应的datablock。</li></ul><p>将上述步骤中GDT部分的步骤简化后比较容易理解。如下:<strong>找到GDT—&gt;找到”/“的inode—&gt;找到/的数据块读取var的inode—&gt;找到var的数据块读取log的inode—&gt;找到log的数据块读取messages的inode—&gt;找到messages的数据块并读取它们。</strong> </p><h4 id="6-2-删除、重命名和移动文件"><a href="#6-2-删除、重命名和移动文件" class="headerlink" title="6.2 删除、重命名和移动文件"></a>6.2 删除、重命名和移动文件</h4><p>注意这里是不跨越文件系统的操作行为。</p><ul><li><strong>删除文件分为普通文件和目录文件</strong>，知道了这两种类型的文件的删除原理，就知道了其他类型特殊文件的删除方法。</li></ul><p>对于删除普通文件：</p><p>(1) 找到文件的inode和data block(根据前一个小节中的方法寻找);</p><p>(2) 将inode table中该inode记录中的data block指针删除;</p><p>(3) 在imap中将该文件的inode号标记为未使用;</p><p>(4) 在其所在目录的data block中将该文件名所在的记录行删除，删除了记录就丢失了指向inode的指针;</p><p>(5) 将bmap中data block对应的block号标记为未使用。</p><p>对于删除目录文件：找到目录和目录下所有文件、子目录、子文件的inode和data block;在imap中将这些inode号标记为未使用;将bmap中将这些文件占用的 block号标记为未使用;在该目录的父目录的data block中将该目录名所在的记录行删除。需要注意的是，删除父目录data block中的记录是最后一步，如果该步骤提前，将报目录非空的错误，因为在该目录中还有文件占用。</p><p>关于上面的(2)-(5)：当(2)中删除data block指针后，将无法再找到这个文件的数据;当(3)标记inode号未使用，表示该inode号可以被后续的文件重用;当(4)删除目录data block中关于该文件的记录，真正的删除文件，外界再也定位也无法看到这个文件了;当(5)标记data block为未使用后，表示开始释放空间，这些data block可以被其他文件重用。</p><p>注意，在第(5)步之前，由于data block还未被标记为未使用，在superblock中仍然认为这些data block是正在使用中的。这表示尽管文件已经被删除了，但空间却还没有释放，df也会将其统计到已用空间中(df是读取superblock中的数据块数量，并计算转换为空间大小)。</p><p>什么时候会发生这种情况呢?当一个进程正在引用文件时将该文件删除，就会出现文件已删除但空间未释放的情况。这时步骤已经进行到(4)，外界无法再找到该文件，但由于进程在加载该文件时已经获取到了该文件所有的data block指针，该进程可以获取到该文件的所有数据，但却暂时不会释放该文件空间。直到该进程结束，文件系统才将未执行的步骤(5)继续完成。这也是为什么有时候du的统计结果比df小的原因，关于du和df统计结果的差别，详细内容见：详细分析du和df的统计结果为什么不一样。</p><ul><li>重命名文件分为同目录内重命名和非同目录内重命名。非同目录内重命名实际上是移动文件的过程，见下文。</li></ul><p>同目录内重命名文件的动作仅仅只是修改所在目录data block中该文件记录的文件名部分，不是删除再重建的过程。</p><p>如果重命名时有文件名冲突(该目录内已经存在该文件名)，则提示是否覆盖。覆盖的过程是覆盖目录data block中冲突文件的记录。例如/tmp/下有a.txt和a.log，若将a.txt重命名为a.log，则提示覆盖，若选择覆盖，则/tmp的data block中关于a.log的记录被覆盖，此时它的指针是指向a.txt的inode。</p><ul><li>移动文件</li></ul><p>同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针，如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除(如果多个硬链接数，则另当别论)。</p><p>所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p><p>对于不同文件系统内的移动，相当于先复制再删除的动作。见后文。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426113825639.png" alt="image-20240426113825639"></p><p>关于文件移动，在Linux环境下有一个非常经典网上却又没任何解释的问题：/tmp/a/a能覆盖为/tmp/a吗?答案是不能，但windows能。为什么不能?见mv的一个经典问题(mv的本质)。</p><h4 id="6-3-存储和复制文件"><a href="#6-3-存储和复制文件" class="headerlink" title="6.3 存储和复制文件"></a>6.3 存储和复制文件</h4><ul><li>对于文件存储</li><li>(1).读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号;</li><li>(2).在inode table中完善该inode号所在行的记录;</li><li>(3).在目录的data block中添加一条该文件的相关记录;</li><li>(4).将数据填充到data block中。</li><li>注意，填充到data block中的时候会调用block分配器：一次分配4KB大小的block数量，当填充完4KB的data block后会继续调用block分配器分配4KB的block，然后循环直到填充完所有数据。也就是说，如果存储一个100M的文件需要调用block分配器100*1024/4=25600次。</li><li>另一方面，在block分配器分配block时，block分配器并不知道真正有多少block要分配，只是每次需要分配时就分配，在每存储一个data block前，就去bmap中标记一次该block已使用，它无法实现一次标记多个bmap位。这一点在ext4中进行了优化。</li><li>(5)填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针。</li><li>对于复制，完全就是另一种方式的存储文件。步骤和存储文件的步骤一样。</li></ul><h3 id="7-多文件系统关联"><a href="#7-多文件系统关联" class="headerlink" title="7.多文件系统关联"></a>7.多文件系统关联</h3><p>在单个文件系统中的文件操作和多文件系统中的操作有所不同。本文将对此做出非常详细的说明。</p><h4 id="7-1-根文件系统的特殊性"><a href="#7-1-根文件系统的特殊性" class="headerlink" title="7.1 根文件系统的特殊性"></a>7.1 根文件系统的特殊性</h4><p>这里要明确的是，任何一个文件系统要在Linux上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如/dev/cdrom挂载在/mnt上，/mnt目录本身是在”/“文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有”/“是自引用的。这里要说明挂载点的级别和自引用的概念。</p><p>假如/dev/sdb1挂载在/mydata上，/dev/cdrom挂载在/mydata/cdrom上，那么/mydata就是一级挂载点，此时/mydata已经是文件系统/dev/sdb1的入口了，而/dev/cdrom所挂载的目录/mydata/cdrom是文件系统/dev/sdb1中的某个目录，那么/mydata/cdrom就是二级挂载点。一级挂载点必须在根文件系统下，所以可简述为：文件系统2挂载在文件系统1中的某个目录下，而文件系统1又挂载在根文件系统中的某个目录下。</p><p>再解释自引用。首先要说的是，自引用的只能是文件系统，而文件系统表现形式是一个目录，所以自引用是指该目录的data block中，”.”和”..”的记录中的inode指针都指向inode table中同一个inode记录，所以它们inode号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi /]<span class="comment"># ll -ai / </span></span><br><span class="line">total 102 </span><br><span class="line"> 2 dr-xr-xr-x. 22 root root 4096 Jun 6 18:13 . </span><br><span class="line"> 2 dr-xr-xr-x. 22 root root 4096 Jun 6 18:13 ..  </span><br></pre></td></tr></table></figure><p>由此也能解释cd /.和cd /..的结果都还是在根下，这是自引用最直接的表现形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]<span class="comment"># cd /. </span></span><br><span class="line">[root@xuexi /]<span class="comment"># </span></span><br><span class="line">[root@xuexi tmp]<span class="comment"># cd /.. </span></span><br><span class="line">[root@xuexi /]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>注意，根目录下的”.”和”..”都是”/“目录的硬链接，且其datablock中不记录名为”/“的条目，因此除去根目录下子目录数后的硬链接数为2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># a=$(ls -ld / | awk &#x27;&#123;print $2&#125;&#x27;) </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># b=$(ls -l / | grep &quot;^d&quot; |wc -l) </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># echo $((a - b)) </span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="7-2-挂载文件系统的细节"><a href="#7-2-挂载文件系统的细节" class="headerlink" title="7.2 挂载文件系统的细节"></a>7.2 挂载文件系统的细节</h4><p>挂载文件系统到某个目录下，例如”mount /dev/cdrom /mnt”，挂载成功后/mnt目录中的文件全都暂时不可见了，且挂载后权限和所有者(如果指定允许普通用户挂载)等的都改变了，知道为什么吗?</p><p>下面就以通过”mount /dev/cdrom /mnt”为例，详细说明挂载过程中涉及的细节。</p><p>在将文件系统/dev/cdrom(此处暂且认为它是文件系统)挂载到挂载点/mnt之前，挂载点/mnt是根文件系统中的一个目录，”/“的data block中记录了/mnt的一些信息，其中包括inode指针inode_n，而在inode table中，/mnt对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426131810028.png" alt="image-20240426131810028"></p><p>当文件系统/dev/cdrom挂载到/mnt上后，/mnt此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。但是如何连接呢？如下图。【好图】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426131959318.png" alt="image-20240426131959318"></p><p>在根文件系统的inode table中，为/mnt重新分配一个inode记录m，该记录的block指针block_m指向文件系统/dev/cdrom中的data block。既然为/mnt分配了新的inode记录m，那么在”/“目录的data block中，也需要修改其inode指针为inode_m以指向m记录。同时，原来inode table中的inode记录n就被标记为暂时不可用。</p><p>block_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。</p><p>挂载完成后，将在/proc/self/{mounts,mountstats,mountinfo}这三个文件中写入挂载记录和相关的挂载信息，并会将/proc/self/mounts中的信息同步到/etc/mtab文件中，当然，如果挂载时加了-n参数，将不会同步到/etc/mtab。</p><p>而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。由于卸载只是移除inode记录，所以使用挂载点和文件系统都可以实现卸载，因为它们是联系在一起的。</p><p>下面是分析或结论</p><p>(1).挂载点挂载时的inode记录是新分配的。</p><p># 挂载前挂载点/mnt的inode号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># ll -id /mnt </span></span><br><span class="line">100663447 drwxr-xr-x. 2 root root 6 Aug 12 2015 /mnt </span><br><span class="line">[root@server2 tmp]<span class="comment"># mount /dev/cdrom /mnt </span></span><br><span class="line"><span class="comment"># 挂载后挂载点的inode号 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll -id /mnt  </span></span><br><span class="line">1856 dr-xr-xr-x 8 root root 2048 Dec 10 2015 mnt </span><br></pre></td></tr></table></figure><p>由此可以验证，inode号确实是重新分配的。</p><p>(2).挂载后，挂载点的内容将暂时不可见、不可用，卸载后文件又再次可见、可用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在挂载前，向挂载点中创建几个文件 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># touch /mnt/a.txt </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># mkdir /mnt/abcdir </span></span><br><span class="line"><span class="comment"># 挂载 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># mount /dev/cdrom /mnt </span></span><br><span class="line"><span class="comment"># 挂载后，挂载点中将找不到刚创建的文件 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll /mnt </span></span><br><span class="line">total 636 </span><br><span class="line">-r--r--r-- 1 root root 14 Dec 10 2015 CentOS_BuildTag </span><br><span class="line">dr-xr-xr-x 3 root root 2048 Dec 10 2015 EFI </span><br><span class="line">-r--r--r-- 1 root root 215 Dec 10 2015 EULA </span><br><span class="line">-r--r--r-- 1 root root 18009 Dec 10 2015 GPL </span><br><span class="line">dr-xr-xr-x 3 root root 2048 Dec 10 2015 images </span><br><span class="line">dr-xr-xr-x 2 root root 2048 Dec 10 2015 isolinux </span><br><span class="line">dr-xr-xr-x 2 root root 2048 Dec 10 2015 LiveOS </span><br><span class="line">dr-xr-xr-x 2 root root 612352 Dec 10 2015 Packages </span><br><span class="line">dr-xr-xr-x 2 root root 4096 Dec 10 2015 repodata </span><br><span class="line">-r--r--r-- 1 root root 1690 Dec 10 2015 RPM-GPG-KEY-CentOS-7 </span><br><span class="line">-r--r--r-- 1 root root 1690 Dec 10 2015 RPM-GPG-KEY-CentOS-Testing-7 </span><br><span class="line">-r--r--r-- 1 root root 2883 Dec 10 2015 TRANS.TBL </span><br><span class="line"><span class="comment"># 卸载后，挂载点/mnt中的文件将再次可见 </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># umount /mnt </span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll /mnt </span></span><br><span class="line">total 0 </span><br><span class="line">drwxr-xr-x 2 root root 6 Jun 9 08:18 abcdir </span><br><span class="line">-rw-r--r-- 1 root root 0 Jun 9 08:18 a.txt </span><br></pre></td></tr></table></figure><p>之所以会这样，是因为挂载文件系统后，挂载点原来的inode记录暂时被标记为不可用，关键是没有指向该inode记录的inode指针了。在卸载文件系统后，又重新启用挂载点原来的inode记录，”/“目录下的mnt的inode指针又重新指向该inode记录。</p><p>(3).挂载后，挂载点的元数据和data block是分别存放在不同文件系统上的。</p><p>(4).挂载点即使在挂载后，也还是属于源文件系统的文件。</p><h4 id="7-3-多文件系统操作关联"><a href="#7-3-多文件系统操作关联" class="headerlink" title="7.3 多文件系统操作关联"></a>7.3 多文件系统操作关联</h4><p>假如下图中的圆代表一块硬盘，其中划分了3个区即3个文件系统。其中根是根文件系统，/mnt是另一个文件系统A的入口，A文件系统挂载在/mnt上，/mnt/cdrom也是一个文件系统B的入口，B文件系统挂载在/mnt/cdrom上。每个文件系统都维护了一些inode table，这里假设图中的inode table是每个文件系统所有块组中的inode table的集合表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426132902871.png" alt="image-20240426132902871"></p><p>如何读取/var/log/messages呢?这是和”/“在同一个文件系统的文件读取，在前面单文件系统中已经详细说明了。</p><p>但如何读取A文件系统中的/mnt/a.log呢?首先，从根文件系统找到/mnt的inode记录，这是单文件系统内的查找;然后根据此inode记录的block指针，定位到/mnt的data block中，这些block是A文件系统的data block;然后从/mnt的data block中读取a.log记录，并根据a.log的inode指针定位到A文件系统的inode table中对应a.log的inode记录;最后从此inode记录的block指针找到a.log的data block。至此，就能读取到/mnt/a.log文件的内容。</p><p>下图能更完整的描述上述过程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133033004.png" alt="image-20240426133033004"></p><p>那么又如何读取/mnt/cdrom中的/mnt/cdrom/a.rpm呢?这里cdrom代表的文件系统B挂载点位于/mnt下，所以又多了一个步骤。先找到”/“，再找到根中的mnt，进入到mnt文件系统中，找到cdrom的data block，再进入到cdrom找到a.rpm。也就是说，mnt目录文件存放位置是根，cdrom目录文件存放位置是mnt，最后a.rpm存放的位置才是cdrom。</p><p>继续完善上图。如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133050365.png" alt="image-20240426133050365"></p><h3 id="8-ext3文件系统的日志功能"><a href="#8-ext3文件系统的日志功能" class="headerlink" title="8.ext3文件系统的日志功能"></a>8.ext3文件系统的日志功能</h3><p>相比ext2文件系统，ext3多了一个日志功能。</p><p>在ext2文件系统中，只有两个区：数据区和元数据区。如果正在向data block中填充数据时突然断电，那么下一次启动时就会检查文件系统中数据和状态的一致性，这段检查和修复可能会消耗大量时间，甚至检查后无法修复。之所以会这样是因为文件系统在突然断电后，它不知道上次正在存储的文件的block从哪里开始、哪里结束，所以它会扫描整个文件系统进行排除(也许是这样检查的吧)。</p><p>而在创建ext3文件系统时会划分三个区：数据区、日志区和元数据区。每次存储数据时，先在日志区中进行ext2中元数据区的活动，直到文件存储完成后标记上commit才将日志区中的数据转存到元数据区。当存储文件时突然断电，下一次检查修复文件系统时，只需要检查日志区的记录，将bmap对应的data block标记为未使用，并把inode号标记未使用，这样就不需要扫描整个文件系统而耗费大量时间。</p><p>虽说ext3相比ext2多了一个日志区转写元数据区的动作而导致ext3相比ext2性能要差一点，特别是写众多小文件时。但是由于ext3其他方面的优化使得ext3和ext2性能几乎没有差距。</p><h3 id="9-ext4文件系统"><a href="#9-ext4文件系统" class="headerlink" title="9.ext4文件系统"></a>9.ext4文件系统</h3><p>回顾前面关于ext2和ext3文件系统的存储格式，它使用block为存储单元，每个block使用bmap中的位来标记是否空闲，尽管使用划分块组的方法优化提高了效率，但是一个块组内部仍然使用bmap来标记该块组内的block。对于一个巨大的文件，扫描整个bmap都将是一件浩大的工程。另外在inode寻址方面，ext2/3使用直接和间接的寻址方式，对于三级间接指针，可能要遍历的指针数量是非常非常巨大的。</p><p>ext4文件系统的最大特点是在ext3的基础上使用区(extent，或称为段)的概念来管理。一个extent尽可能的包含物理上连续的一堆block。inode寻址方面也一样使用区段树的方式进行了改进。</p><p>默认情况下，EXT4不再使用EXT3的block mapping分配方式 ，而改为Extent方式分配。</p><p>以下是ext4文件系统中一个文件的inode属性示例，注意最后两行的EXTENTS。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Inode: 12 Type: regular Mode: 0644 Flags: 0x80000 </span><br><span class="line">Generation: 476513974 Version: 0x00000000:00000001 </span><br><span class="line">User: 0 Group: 0 Size: 11 </span><br><span class="line">File ACL: 0 Directory ACL: 0 </span><br><span class="line">Links: 1 Blockcount: 8 </span><br><span class="line">Fragment: Address: 0 Number: 0 Size: 0 </span><br><span class="line"> ctime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line"> atime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line"> mtime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line">crtime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018 </span><br><span class="line">Size of extra inode fields: 28 </span><br><span class="line">EXTENTS: </span><br><span class="line">(0):33409 </span><br></pre></td></tr></table></figure><p>(1). 关于EXT4的结构特征</p><p>EXT4在总体结构上与EXT3相似，大的分配方向都是基于相同大小的块组，每个块组内分配固定数量的inode、可能的superblock(或备份)及GDT。</p><p>EXT4的inode 结构做了重大改变，为增加新的信息，大小由EXT3的128字节增加到默认的256字节，同时inode寻址索引不再使用EXT3的”12个直接寻址块+1个一级间接寻址块+1个二级间接寻址块+1个三级间接寻址块”的索引模式，而改为4个Extent片断流，每个片断流设定片断的起始block号及连续的block数量(有可能直接指向数据区，也有可能指向索引块区)。</p><p>片段流即下图中索引节点(inde node block)部分的绿色区域，每个15字节，共60字节。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133212168.png" alt="image-20240426133212168"></p><p>(2). EXT4删除数据的结构更改。</p><p>EXT4删除数据后，会依次释放文件系统bitmap空间位、更新目录结构、释放inode空间位。</p><p>(3). ext4使用多block分配方式。</p><p>在存储数据时，ext3中的block分配器一次只能分配4KB大小的Block数量，而且每存储一个block前就标记一次bmap。假如存储1G的文件，blocksize是4KB，那么每存储完一个Block就将调用一次block分配器，即调用的次数为1024 <em> 1024 / 4KB=262144次，标记bmap的次数也为1024 </em> 1024/4=262144次。</p><p>而在ext4中根据区段来分配，可以实现调用一次block分配器就分配一堆连续的block，并在存储这一堆block前一次性标记对应的bmap。这对于大文件来说极大的提升了存储效率。</p><h3 id="10-ext类的文件系统的缺点"><a href="#10-ext类的文件系统的缺点" class="headerlink" title="10.ext类的文件系统的缺点"></a>10.ext类的文件系统的缺点</h3><p>最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢极慢的。例如将一个几十T的磁盘阵列格式化为ext4文件系统，可能你会因此而失去一切耐心。</p><p>除了格式化速度超慢以外，ext4文件系统还是非常可取的。当然，不同公司开发的文件系统都各有特色，最主要的还是根据需求选择合适的文件系统类型。</p><h3 id="11-虚拟文件系统VFS"><a href="#11-虚拟文件系统VFS" class="headerlink" title="11.虚拟文件系统VFS"></a>11.虚拟文件系统VFS</h3><p>每一个分区格式化后都可以建立一个文件系统，Linux上可以识别很多种文件系统，那么它是如何识别的呢?另外，在我们操作分区中的文件时，并没有指定过它是哪个文件系统的，各种不同的文件系统如何被我们用户以无差别的方式操作呢?这就是虚拟文件系统的作用。</p><p>虚拟文件系统为用户操作各种文件系统提供了通用接口，使得用户执行程序时不需要考虑文件是在哪种类型的文件系统上，应该使用什么样的系统调用来操作该文件。有了虚拟文件系统，只要将所有需要执行的程序调用VFS的系统调用就可以了，剩下的动作由VFS来帮忙完成。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240426133132195.png" alt="image-20240426133132195"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文章摘自：</p><ul><li><a href="https://www.51cto.com/article/603104.html">EXT文件系统机制原理详解</a></li><li><a href="https://www.yuque.com/yukun-srnyg/gxz6gg/hovdfg">操作系统-哈工大李治军老师</a></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    <summary type="html">动手实现文件系统</summary>
    
    
    
    <category term="操作系统" scheme="https://penge666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>malloc原理实现</title>
    <link href="https://penge666.github.io/posts/3e3da89f.html"/>
    <id>https://penge666.github.io/posts/3e3da89f.html</id>
    <published>2024-04-25T09:04:14.000Z</published>
    <updated>2024-04-25T09:38:47.409Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://mp.weixin.qq.com/s/xCqPaYqM5It97KDwCjrYIQ">内存分配函数 malloc 原理及实现</a></p><h2 id="1-什么是malloc"><a href="#1-什么是malloc" class="headerlink" title="1.什么是malloc"></a><strong>1.什么是malloc</strong></h2><p>根据<strong>标准C库函数</strong>的定义，malloc具有如下原型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* malloc(size_t size);</span><br></pre></td></tr></table></figure><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><ul><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li><li>malloc应该尽快完成内存分配并返回</li><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li></ul><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man malloc</span><br></pre></td></tr></table></figure><p><strong>malloc如何分配内存？</strong></p><p>第一种：通过brk()系统调用从堆分配内存</p><p>第二种：通过 mmap()系统调用在文件映射区域分配内存;</p><p>两种方式应该如何区分?</p><ol><li><p>如果用户分配的内存小于128 KB，则通过brk()申请内存</p></li><li><p>如果用户分配的内存大于128 KB，则通过mmap()申请内存</p></li><li>不同的glibc当中定义的阈值是不一样的【glibc 是 C 语言的运行时库，C语义中常见的函数printf等实现都在 glibc.so 中】</li></ol><h2 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2.预备知识"></a><strong>2.预备知识</strong></h2><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><h3 id="2-1-Linux内存管理"><a href="#2-1-Linux内存管理" class="headerlink" title="2.1 Linux内存管理"></a>2.1 Linux内存管理</h3><h4 id="2-1-1-虚拟内存地址与物理内存地址"><a href="#2-1-1-虚拟内存地址与物理内存地址" class="headerlink" title="2.1.1 虚拟内存地址与物理内存地址"></a>2.1.1 虚拟内存地址与物理内存地址</h4><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片2N字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为264Byte。</p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<strong>MMU</strong>[2]（Memory Management Unit）的硬件完成。</p><h4 id="2-1-2-页与地址构成"><a href="#2-1-2-页与地址构成" class="headerlink" title="2.1.2 页与地址构成"></a>2.1.2 页与地址构成</h4><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171539476.png" alt="image-20240425171539476"></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<strong>页表</strong>[3]来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<strong>TLB</strong>[4]等机制。</p><p>下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况是一致的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171620475.png" alt="image-20240425171620475"></p><h4 id="2-1-3-内存页与磁盘页"><a href="#2-1-3-内存页与磁盘页" class="headerlink" title="2.1.3 内存页与磁盘页"></a>2.1.3 内存页与磁盘页</h4><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<strong>图片来源页</strong>[5]）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171626448.png" alt="image-20240425171626448"></p><h3 id="2-2-Linux进程级内存管理"><a href="#2-2-Linux进程级内存管理" class="headerlink" title="2.2 Linux进程级内存管理"></a>2.2 Linux进程级内存管理</h3><h4 id="2-2-1-内存排布"><a href="#2-2-1-内存排布" class="headerlink" title="2.2.1 内存排布"></a>2.2.1 内存排布</h4><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>根据<strong>Linux内核相关文档</strong>[6]描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171633158.png" alt="image-20240425171633158"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h4 id="2-2-2-Heap内存模型"><a href="#2-2-2-Heap内存模型" class="headerlink" title="2.2.2 Heap内存模型"></a>2.2.2 Heap内存模型</h4><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171639162.png" alt="image-20240425171639162"></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h4 id="2-2-3-brk与sbrk"><a href="#2-2-3-brk与sbrk" class="headerlink" title="2.2.3 brk与sbrk"></a>2.2.3 brk与sbrk</h4><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个<strong>系统调用</strong>的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">brk</span><span class="params">(<span class="type">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><h4 id="2-2-4-资源限制与rlimit"><a href="#2-2-4-资源限制与rlimit" class="headerlink" title="2.2.4 资源限制与rlimit"></a>2.2.4 资源限制与rlimit</h4><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。</p><p>这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> *limit = (<span class="keyword">struct</span> rlimit *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> rlimit));</span><br><span class="line">    <span class="built_in">getrlimit</span>(RLIMIT_AS, limit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;soft limit: %ld, hard limit: %ld\n&quot;</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中rlimit是一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span> &#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h2 id="3-实现malloc"><a href="#3-实现malloc" class="headerlink" title="3.实现malloc"></a><strong>3.实现malloc</strong></h2><p>下面主要是空闲链表实现的。</p><h3 id="3-1-玩具实现"><a href="#3-1-玩具实现" class="headerlink" title="3.1 玩具实现"></a>3.1 玩具实现</h3><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个玩具malloc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    p = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sbrk</span>(size) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h3 id="3-2-正式实现"><a href="#3-2-正式实现" class="headerlink" title="3.2 正式实现"></a>3.2 正式实现</h3><p>下面严肃点讨论malloc的实现方案。</p><h4 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="3.2.1 数据结构"></a>3.2.1 数据结构</h4><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p>可以用如下结构体定义一个block：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_block</span> *t_block;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s_block</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">/* 数据区大小 */</span></span><br><span class="line">  t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">  <span class="type">int</span> free; <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">  <span class="type">int</span> padding; <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">  <span class="type">char</span> data[<span class="number">1</span>] <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171646744.png" alt="image-20240425171646744"></p><blockquote><p><strong>补充</strong>：柔性数组</p></blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/385501987">听说有人不了解柔性数组？</a></li></ul><h4 id="3-2-2-寻找合适的block"><a href="#3-2-2-寻找合适的block" class="headerlink" title="3.2.2 寻找合适的block"></a>3.2.2 寻找合适的block</h4><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First fit */</span></span><br><span class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  t_block b = first_block;</span><br><span class="line">  <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">     *last = b;</span><br><span class="line">     b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。</p><p>这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><h4 id="3-2-3-开辟新的block"><a href="#3-2-3-开辟新的block" class="headerlink" title="3.2.3 开辟新的block"></a>3.2.3 开辟新的block</h4><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 24 <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></span><br><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="type">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sbrk</span>(BLOCK_SIZE + s) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    b-&gt;free = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-分裂block"><a href="#3-2-4-分裂block" class="headerlink" title="3.2.4 分裂block"></a>3.2.4 分裂block</h4><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425171653204.png" alt="image-20240425171653204"></p><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="type">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + s;</span><br><span class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;free = <span class="number">1</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-malloc的实现"><a href="#3-2-5-malloc的实现" class="headerlink" title="3.2.5 malloc的实现"></a>3.2.5 malloc的实现</h4><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。【因为BLOCK_SIZE保存的4个INT的内存大小】</p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">align8</span><span class="params">(<span class="type">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 24</span></span><br><span class="line"><span class="type">void</span> *first_block=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* other functions... */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="type">size_t</span> s;</span><br><span class="line">    <span class="comment">/* 对齐地址 */</span></span><br><span class="line">    s = <span class="built_in">align8</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">    / *查找合适的block */</span><br><span class="line">        last = first_block;</span><br><span class="line">        b = <span class="built_in">find_block</span>(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">    <span class="comment">/* 如果可以，则分裂*/</span></span><br><span class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                <span class="built_in">split_block</span>(b, s);</span><br><span class="line">            b-&gt;free = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    / *没有合适的block，开辟一个新的 */</span><br><span class="line">        b = <span class="built_in">extend_heap</span>(last, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b = <span class="built_in">extend_heap</span>(<span class="literal">NULL</span>, s);</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-6-calloc的实现"><a href="#3-2-6-calloc的实现" class="headerlink" title="3.2.6 calloc的实现"></a>3.2.6 calloc的实现</h4><p>有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> number, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">size_t</span> s8, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</span><br><span class="line">        s8 = <span class="built_in">align8</span>(number * size) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-7-free的实现"><a href="#3-2-7-free的实现" class="headerlink" title="3.2.7 free的实现"></a>3.2.7 free的实现</h4><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。</p><p>这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_block</span> *t_block;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s_block</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="type">int</span> free;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="type">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="type">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们定义检查地址合法性的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *tmp;  </span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">valid_addr</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; <span class="built_in">sbrk</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == (<span class="built_in">get_block</span>(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>一个简单的解决方式是当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。</p><p>修改后的block结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_block</span> *t_block;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s_block</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="type">int</span> free;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="type">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="type">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>合并方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) &#123;</span><br><span class="line">  b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">  b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">  b-&gt;next-&gt;prev = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。</p><p>如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">valid_addr</span>(p)) &#123;</span><br><span class="line">        b = <span class="built_in">get_block</span>(p);</span><br><span class="line">        b-&gt;free = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free)</span><br><span class="line">            b = <span class="built_in">fusion</span>(b-&gt;prev);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            <span class="built_in">fusion</span>(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;prev)</span><br><span class="line">                b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                first_block = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">brk</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-8-realloc的实现"><a href="#3-2-8-realloc的实现" class="headerlink" title="3.2.8 realloc的实现"></a>3.2.8 realloc的实现</h4><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *sdata, *ddata;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</span><br><span class="line">        ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做得更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>下面是realloc的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> s;</span><br><span class="line">    t_block b, <span class="keyword">new</span>;</span><br><span class="line">    <span class="type">void</span> *newp;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">valid_addr</span>(p)) &#123;</span><br><span class="line">        s = <span class="built_in">align8</span>(size);</span><br><span class="line">        b = <span class="built_in">get_block</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                <span class="built_in">split_block</span>(b,s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 看是否可进行合并 */</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;free</span><br><span class="line">                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">                <span class="built_in">fusion</span>(b);</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                    <span class="built_in">split_block</span>(b, s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 新malloc */</span></span><br><span class="line">                newp = <span class="built_in">malloc</span> (s);</span><br><span class="line">                <span class="keyword">if</span> (!newp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">new</span> = <span class="built_in">get_block</span>(newp);</span><br><span class="line">                <span class="built_in">copy_block</span>(b, <span class="keyword">new</span>);</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">return</span>(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">malloc的幕后机制</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="操作系统" scheme="https://penge666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="https://penge666.github.io/posts/51d1b1e7.html"/>
    <id>https://penge666.github.io/posts/51d1b1e7.html</id>
    <published>2024-04-24T01:47:49.000Z</published>
    <updated>2024-04-25T06:59:11.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><p>学技术最快速的方式就是根据官方文档学习：<a href="https://redis.com.cn/documentation.html">redis技术文档</a></p><p>redis的重点是在如何用好先，在谈设计，就像朱哥说的。</p><h2 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h2><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串)，而是自己构建了一种名为简单动态字符串（ simple dynamic string，SDS)的抽象类型，并将SDS用作 Redis 的默认字符串表示。</p><h3 id="2-1-SDS的定义"><a href="#2-1-SDS的定义" class="headerlink" title="2.1 SDS的定义"></a>2.1 SDS的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sdshdr</span> &#123;</span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> free;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串，会自动在数组末尾添加一个字节，用于保存&#x27;\0&#x27;，不计入 len 值中</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424095542031.png" alt="image-20240424095542031"></p><h3 id="2-2-SDS与C字符串的区别"><a href="#2-2-SDS与C字符串的区别" class="headerlink" title="2.2 SDS与C字符串的区别"></a>2.2 SDS与C字符串的区别</h3><p><strong>1.常数复杂度获取字符串长度</strong></p><p>通过使用SDS而不是C字符串，Redis 将获取字符串长度所需的复杂度从O(N)降低到了O(1)，这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</p><p><strong>2.杜绝缓冲区溢出</strong></p><p>除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出 ( buffer overflow)。</p><p>SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS-API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p><p><strong>3.减少修改字符串时带来的内存重分配次数</strong></p><p>3.1 预分配空间</p><p>空间预分配用于优化SDS字符串增长操作。在扩展SDS空间前，SDS API会先检查未使用空间够不够，如果不够，则进行空间预分配。此时，程序不仅会为SDS分配修改所必须要的空间，还为其分配额外未使用的空间。</p><ul><li>修改后的SDS&lt;1MB，程序分配和len属性同样大小的未使用空间，此时SDS的len与free大小相等。比如修改后实际存储字符串的空间变为13字节，那么len=13，free=13，buf数组整体的长度=13+13+1（额外1字节保存空字符）。</li><li>修改后SDS&gt;=1MB。程序会分配1MB的未使用空间。比如修改后实际存储字符串的空间变为2MB，那么len=2M，free=1MB，buf数组整体的长度=2MB+1MB+1byte。</li></ul><p>通过空间的预分配，将连续增长N次字符串需要的内存分配次数从一定需要N次变为最多N次。因而可以减少连续执行字符串增长操作所需的内存重分配的次数。</p><p>3.2 惰性空间释放</p><p>惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p><p><strong>4.二进制安全</strong></p><p>为了确保 Redis 可以适用于各种不同的适用场景，SDS 的 API 都是二进制安全的，因此使得 Redis 不仅可以保存文本数据，还可以保存任意格式的二进制数据，因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束。简单来说，就是得益于SDS结构体存储的数据信息。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424100127306.png" alt="image-20240424100127306"></p><p><strong>5.兼容部分C字符串函数</strong></p><p>通过遵循C字符串以空字符结尾的惯例，SDS 可以在有需要时重用 <code>&lt;string.h&gt;</code> 函数库，从而避免了不必要的代码重复。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424100136783.png" alt="image-20240424100136783"></p><h2 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h2><p>链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><p>Redis 的链表是由一个 <code>list</code> 结构和 n 个 <code>listNode</code> 结构组成，list 里面可以存储该链表的头指针、尾指针、以及长度计数器和用于实现多态链表所需的类型特定函数，Redis 的链表是 <strong>双端</strong>、<strong>无环</strong> 的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个链表节点使用一个 adlist.h/listNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> * prev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> * next;</span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"><span class="comment">// 虽然仅仅使用多个listNode结构就可以构成链表，</span></span><br><span class="line"><span class="comment">// 但使用adlist.h/list来持有链表的话，操作起来会更方便</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="built_in">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure><h2 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h2><p>字典，又称为符号表( symbol table)、关联数组( associative array)或映射( map)，是一种用于保存键值对( key-value pair)的抽象数据结构。<br>在字典中，一个键( key)可以和一个值( value)进行关联（或者说将键映射为值)，这些关联的键和值就称为键值对。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。可以想象成类似这种结构 Map<String,Map<String,T> &gt; MP;</p><h3 id="4-1-哈希表"><a href="#4-1-哈希表" class="headerlink" title="4.1 哈希表"></a>4.1 哈希表</h3><ul><li>Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dicht</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424100659824.png" alt="image-20240424100659824"></p><h3 id="4-2-哈希表节点"><a href="#4-2-哈希表节点" class="headerlink" title="4.2 哈希表节点"></a>4.2 哈希表节点</h3><p>哈希表节点使用dictEntry实现，每个dictEntry都存储着一个键值对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span>&#123;</span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>键值对的值可以是一个指针，或一个uint64<em>t整数，或一个int64</em>整数。next是指向另一个哈希节点的指针，可将多个哈希值相同的键值对连接在一起，以此来解决冲突。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424100809559.png" alt="image-20240424100809559"></p><h3 id="4-3-字典"><a href="#4-3-字典" class="headerlink" title="4.3 字典"></a>4.3 字典</h3><p>Redis中的字典由<code>dict.h/dict</code>实现，由这个数据结构将字典组织在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type和privdata属性是针对不同类型的键值对，为丰富键值对的使用场景而设置的。</p><ul><li>type属性是一个指向dictType的结构指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为用途不同的字典设置不同类型特定函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictType</span>&#123;</span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li><li>ht属性是包含两个项的数组，每项都是一个哈希表，ht[0]平时使用，而ht[1]仅在rehash时使用。</li><li>rehashidx记录了rehash的进度，初始为-1。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424100919619.png" alt="image-20240424100919619"></p><h3 id="4-4-哈希算法"><a href="#4-4-哈希算法" class="headerlink" title="4.4 哈希算法"></a>4.4 哈希算法</h3><p>Redis计算哈希值方法： hash=dict-&gt;type-&gt;hashFunction(key);<br>计算索引值的方法：index=hash &amp; dict-&gt;ht[x].sizemask;</p><p>当字典被用作数据库的底层实现或哈希键的底层实现时，Redis使用<strong>MurmurHash2算法</strong>来计算键的哈希值。优点在于即使输入的键是有规律的，算法仍然能给出<strong>很好的随机分布性</strong>，并且计算<strong>速度飞快</strong>。</p><h3 id="4-5-解决键冲突"><a href="#4-5-解决键冲突" class="headerlink" title="4.5 解决键冲突"></a>4.5 解决键冲突</h3><p>当有两个或以上的键被分配到哈希表的同个索引，那么就发生了冲突。Redis使用链地址法来解决冲突，被分配到索引的多个节点使用链表连接。为了提高速度，每次都是将新节点添加到链表的表头位置。</p><h3 id="4-6-rehash"><a href="#4-6-rehash" class="headerlink" title="4.6 rehash"></a>4.6 rehash</h3><blockquote><p><strong>执行扩展或收缩操作的条件</strong></p></blockquote><p><strong>Dict的扩容</strong></p><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次新增键值对时都会检查负载因子（LoadFactor） ，满足以下两种情况时会触发哈希表扩容。</p><ul><li>服务目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1 。</li><li>服务器目前正在执行BGSAVE命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ 负载因子 = 哈希表已保存的节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size;</span><br></pre></td></tr></table></figure><p><strong>Dict的收缩</strong></p><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩。</p><blockquote><p><strong>rehash</strong></p></blockquote><p><strong>Dict的rehash</strong></p><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<br>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n<br>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li></ul><p>rehash前</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424102112213.png" alt="image-20240424102112213"></p><p>rehash后</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424102044457.png" alt="image-20240424102044457"></p><h3 id="4-7-渐进式rehash"><a href="#4-7-渐进式rehash" class="headerlink" title="4.7 渐进式rehash"></a>4.7 渐进式rehash</h3><p>Dict的rehash并不是一次性完成的。试想一下，如果Dict中包含数百万的entry，要在一次rehash完成，极有可能导致主线程阻塞。因此Dict的rehash是分多次、渐进式的完成，因此称为<strong>渐进式rehash</strong>。流程如下：</p><ul><li>计算新hash表的size，值取决于当前要做的是扩容还是收缩：<br>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n<br>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li><li>按照新的size申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li><del>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</del></li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束<br>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><p><strong>总结</strong>：</p><p>Q：为什么哈希表操作变慢了？</p><p>A：哈希表的冲突问题和 rehash 可能带来的操作阻塞。因此提出渐进式rehash</p><p><strong>渐进式 rehash介绍</strong></p><p>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425135541925.png" alt="image-20240425135541925"></p><h2 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均 O(logN) 、最坏 O(N) 度的节点查找，还可以通过顺序性操作来批量处理节点。Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424102514122.png" alt="image-20240424102514122"></p><p>之前实现过跳表的原理，欢迎start:<a href="https://github.com/Penge666/SkipList">基于跳表实现的K-V存储引擎</a></p><p>总结：</p><p><strong>跳表</strong></p><p>跳表在链表的基础上，<strong>增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425135851173.png" alt="image-20240425135851173"></p><p>第一次：如果我们要在链表中查找 33 这个元素，只能从头开始遍历链表，查找 6 次，直到找到 33 为止。O(N)</p><p>第二次：增加一级索引，从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就能定位到元素 33 了。</p><p>第三次：增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。</p><p>时间复杂度：O（lgN）</p><h2 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h2><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p><h3 id="6-1-整数集合的实现"><a href="#6-1-整数集合的实现" class="headerlink" title="6.1 整数集合的实现"></a>6.1 整数集合的实现</h3><p>整数集合(intset)是 Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、 int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">intset</span> &#123;</span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合中包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是 contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序的排列，并且数组中不包含任何重复项。</p><h3 id="6-2-升级"><a href="#6-2-升级" class="headerlink" title="6.2 升级"></a>6.2 升级</h3><p>当我们要将一个新元素添加至集合时，并且新元素的类型比现有集合类型都长时，整数集合就要升级。</p><p>步骤：</p><ol><li>根据新元素类型，扩展数组空间，为新元素分配空间。</li><li>将底层数组现有所有元素都转为新元素相同类型，并将类型转换后的元素放到正确位置。</li><li>将新元素添加到底层数组。</li></ol><p>由于每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有元素进行类型转换，所以添加的时间复杂度为O(N)。</p><h3 id="6-3-升级的好处"><a href="#6-3-升级的好处" class="headerlink" title="6.3 升级的好处"></a>6.3 升级的好处</h3><ul><li><p>整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能的节约内存。</p><p>Note：整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p></li></ul><h2 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 压缩列表"></a>第七章 压缩列表</h2><p> ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424103109865.png" alt="image-20240424103109865"></p><div class="table-container"><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table></div><p><strong>ZipListEntry</strong></p><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424103141314.png" alt="image-20240424103141314"></p><ul><li>previous_entry_length：前一节点的长度，占1个或5个字节。<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li><li>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</li><li>contents：负责保存节点的数据，可以是字符串或整数</li></ul><p><strong>ZipList的连锁更新问题</strong></p><ul><li>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul><p>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424103344907.png" alt="image-20240424103344907"></p><p><strong>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新</strong>（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><h2 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 对象"></a>第八章 对象</h2><p>Redis<strong>没有直接使用</strong>前文的数据结构来实现键值对数据库，而是基于这些数据结构构建了一个对象系统，通过对象组织数据结构，包括字<strong>符串对象，列表对象，哈希对象，集合对象</strong>和<strong>有序集合对象这</strong>5种对象。</p><p>使用对象的一个好处是可以针对不同的使用场景，为对象<strong>设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率。</p><h3 id="8-1-对象的类型与编码"><a href="#8-1-对象的类型与编码" class="headerlink" title="8.1 对象的类型与编码"></a>8.1 对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis 的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象)，另一个对象用作键值对的值（值对象)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424103518790.png" alt="image-20240424103518790"></p><p><strong>8.1.1 类型</strong></p><p>对象的 type属性记录了对象的类型，其值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</p><p>对于 Redis 数据库保存的键值对来说，键总是一个字符串对象，而值则可以是其他类型对象中的一种，因此：</p><ul><li>当我们称呼一个数据库键为 “字符串键” 时，我们指的是 “这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为 “列表键” 时，我们指的是 “这个数据库键所对应的值为列表对象” 。</li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424103820248.png" alt=""></p><p><strong>7.1.2 编码和底层实现</strong></p><p>对象的 ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的 encoding 属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。</p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424104027791.png" alt="image-20240424104027791"></p><h3 id="8-2-字符串对象"><a href="#8-2-字符串对象" class="headerlink" title="8.2 字符串对象"></a>8.2 字符串对象</h3><p>字符串对象的编码可以是 int 、raw 、或者 embstr 。</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long），并将字符串对象的编码设置为 int。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 raw。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用 embstr编码的方式来保存这个字符串值 。</li></ul><p>raw编码的字符串对象</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424104214996.png" alt="image-20240424104214996"></p><p>embstr编码的字符串对象</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424104231320.png" alt="image-20240424104231320"></p><p><strong>raw 与 embstr 的区别</strong>是：raw编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构，而 embstr编码则通过一次内存分配函数来分配一块连续的空间，空间中依次包含 redisObject和 sdshdr 两个结构 。</p><p><strong>编码转换</strong></p><p>对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。</p><p>另外，因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序)，所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。</p><h3 id="8-3-列表对象"><a href="#8-3-列表对象" class="headerlink" title="8.3 列表对象"></a>8.3 列表对象</h3><p>列表对象的编码可以是 ziplist或者 linkedlist 。</p><ul><li>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</li><li>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素</li></ul><p><strong>编码转换</strong></p><p>当列表对象可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li><li>列表对象保存的元素数量小于 512 个；</li></ul><p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。注意这两个条件的上限值是可以修改的。</p><h3 id="8-4-哈希对象"><a href="#8-4-哈希对象" class="headerlink" title="8.4 哈希对象"></a>8.4 哈希对象</h3><p>哈希对象的编码可以是 ziplist或者 hashtable 。</p><p>使用 ziplist编码的哈希对象有以下特点：</p><ol><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后。</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424104719359.png" alt="image-20240424104719359"></p><p>使用 hashtable编码的哈希对象有以下特点：</p><ol><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值；</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424104728270.png" alt="image-20240424104728270"></p><p><strong>编码转换</strong></p><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用 ziplist 编码：</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li><li>哈希对象保存的键值对数量小于 512 个；</li></ol><p>这两个条件的上限值也是可以修改的，不满足条件的哈希对象需要使用 hashtable 编码。</p><h3 id="8-5-集合对象"><a href="#8-5-集合对象" class="headerlink" title="8.5 集合对象"></a>8.5 集合对象</h3><p>集合对象的编码可以是 intset或者 hashtable 。</p><ul><li>intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</li><li>hashtable 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 null 。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424104835719.png" alt="image-20240424104835719"></p><p><strong>编码转换</strong></p><p>当集合对象可以同时满足以下两个条件时，对象使用 intset编码：</p><ol><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 512 个；</li></ol><p>第二个条件的上限值是可以修改的，不满足这两个条件的集合对象需要使用 hashtable编码。</p><h3 id="8-6-有序集合对象"><a href="#8-6-有序集合对象" class="headerlink" title="8.6 有序集合对象"></a>8.6 有序集合对象</h3><p>有序集合的编码可以是 ziplist 或者 skiplist 。</p><p>ziplist 编码的压缩对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score），压缩列表内的集合元素按分值从小到大进行排序。</p><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据key找value</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424105059158.png" alt="image-20240424105059158"></p><p><strong>编码转换</strong></p><p>当有序集合对象可以同时满足以下两个条件时，对象使用 ziplist编码：</p><ol><li>有序集合保存的元素数量小于 128 个；</li><li>有序集合保存的所有元素成员长度都小于 64 字节；</li></ol><p>以上两个上限值都是可以修改的，不能满足这两个条件的有序集合对象将使用 skiplist编码 </p><h3 id="8-7-类型检查的实现"><a href="#8-7-类型检查的实现" class="headerlink" title="8.7 类型检查的实现"></a>8.7 类型检查的实现</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424105213455.png" alt="image-20240424105213455"></p><h3 id="8-8-内存回收"><a href="#8-8-内存回收" class="headerlink" title="8.8 内存回收"></a>8.8 内存回收</h3><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（ reference counting)技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><h3 id="8-9-对象共享"><a href="#8-9-对象共享" class="headerlink" title="8.9 对象共享"></a>8.9 对象共享</h3><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p><h3 id="8-10-对象的空转时长"><a href="#8-10-对象的空转时长" class="headerlink" title="8.10 对象的空转时长"></a>8.10 对象的空转时长</h3><p>除了之前介绍了 type、encoding 、ptr 和 refcount 四个属性之外，redisObject 结构包含的最后一个属性为 lru 属性，该属性记录了对象最后一次被命令程序访问的时间。</p><p>使用命令OBJECT IDLETIME 给定键 可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的。</p><p>总结：</p><p>对象：String,List,Hash,Set,Sorted Set</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425134220304.png" alt="image-20240425134220304"></p><p>特点：<strong>一个键对应了一个集合的数据</strong></p><h2 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 数据库"></a>第九章 数据库</h2><h3 id="9-1-服务器中的数据库"><a href="#9-1-服务器中的数据库" class="headerlink" title="9.1 服务器中的数据库"></a>9.1 服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisserver结构的db数组中，db 数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">redisServer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 初始化服务器时，程序会根据服务器状态的 dbnum 属性</span></span><br><span class="line">    <span class="comment">// 来决定应该创建多少个数据库，默认是 16</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dbnum：来决定应该创建多少个数据库，默认是 16</p><h3 id="9-2-切换数据库"><a href="#9-2-切换数据库" class="headerlink" title="9.2 切换数据库"></a>9.2 切换数据库</h3><p>可以通过命令SELECT n来切换到 n 号数据库。</p><h3 id="9-3-数据库键空间"><a href="#9-3-数据库键空间" class="headerlink" title="9.3 数据库键空间"></a>9.3 数据库键空间</h3><p>redisDb结构的 dict 字典保存了数据库中所有键值对，我们将这个字典称为键空间（key space）。</p><p>键空间和用户所见的数据库是直接对应的</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种 Redis 对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424105713099.png" alt="image-20240424105713099"></p><h3 id="9-4-键的生存时间或过期时间"><a href="#9-4-键的生存时间或过期时间" class="headerlink" title="9.4 键的生存时间或过期时间"></a>9.4 键的生存时间或过期时间</h3><p><strong>保存过期时间</strong></p><p>redisDb 结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个 long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间–一个毫秒精度的 UNIX 时间戳。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424110005819.png" alt="image-20240424110005819"></p><h3 id="9-5-过期键的删除策略"><a href="#9-5-过期键的删除策略" class="headerlink" title="9.5 过期键的删除策略"></a>9.5 过期键的删除策略</h3><p>有三种不同的删除策略：</p><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键；如果没有，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ol><p>为了更好更合理的在 CPU 时间以及避免浪费内存空间之间取得平衡，Redis 服务器使用 <strong>惰性删除</strong> 和 <strong>定期删除</strong> 两种策略。</p><h3 id="9-6-Redis的过期键删除策略"><a href="#9-6-Redis的过期键删除策略" class="headerlink" title="9.6 Redis的过期键删除策略"></a>9.6 Redis的过期键删除策略</h3><h3 id="9-7-AOF、RDB-和复制功能对过期键的处理"><a href="#9-7-AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="9.7 AOF、RDB 和复制功能对过期键的处理"></a>9.7 AOF、RDB 和复制功能对过期键的处理</h3><p><strong>生成RDB文件</strong></p><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><p><strong>载入 RDB 文件</strong></p><p>在启动服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入 RDB 文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul><p><strong>AOF 文件写入</strong></p><p>当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序回向 AOF 文件追加（append）一条 DEL 命令，来显式地记录该键已经被删除。</p><p><strong>AOF 重写</strong></p><p>和生成 RDB 文件时类似，在执行 AOF 重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p><p><strong>复制</strong></p><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式的向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的 DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><p>下面用2张图简单了解下这个过程</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424110408994.png" alt="image-20240424110408994"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424110436186.png" alt="image-20240424110436186"></p><p><strong>数据库通知</strong></p><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>这一类关注“某个键执行了什么命令”的通知称为键空间通知（ key-space notification ),除此之外，还有另一类称为键事件通知( key-event notification )的通知，它们关注的是“某个命令被什么键执行了””。</p><h2 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 RDB持久化"></a>第十章 RDB持久化</h2><p>因为 Redis是内存数据库,它将自己的数据库状态储存在内存里面,所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p><p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态,如图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424110626725.png" alt="image-20240424110626725"></p><h3 id="10-1-RDB文件的创建与载入"><a href="#10-1-RDB文件的创建与载入" class="headerlink" title="10.1 RDB文件的创建与载入"></a>10.1 RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><ul><li><p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</p></li><li><p>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p></li></ul><p>RDB 文件的载入工作是在服务器启动时自动执行的，所以 Redis 并没有专门用于载入 RDB 文件的命令，只要 Redis 服务器在启动时检测到 RDB 文件存在，它就会自动载入 RDB 文件。</p><p>另外，因为 AOF 文件的更新频率通常比 RDB 文件的更新频率高，所以：</p><ul><li>如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。</li><li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</li></ul><p>服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h3 id="10-2-自动间隔性保存"><a href="#10-2-自动间隔性保存" class="headerlink" title="10.2 自动间隔性保存"></a>10.2 自动间隔性保存</h3><p>因为 BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以 Redis 允许用户通过设置服务器配置的 save 选项，让服务器每个一段时间自动执行一次 BGSAVE命令。</p><p>用户可以通过 save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE命令。</p><p>Redis 的服务器周期性操作函数 serverCron默认每个 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查 save选项所设置的保存条件是否已经满足，如果满足的话，就执行 BGSAVE 命令。</p><h3 id="10-3-RDB文件结构"><a href="#10-3-RDB文件结构" class="headerlink" title="10.3 RDB文件结构"></a>10.3 RDB文件结构</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424110918715.png" alt="image-20240424110918715"></p><h2 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 AOF持久化"></a>第十一章 AOF持久化</h2><p>与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF（Append Only File）持久化时通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424111013241.png" alt="image-20240424111013241"></p><p><strong>补充</strong>：</p><p>Q：AOF日志写入时机？</p><p>A：AOF日志是写后日志。</p><p>解释：我们常常写日志都是WAL技术，就是先记录，再写日志。但是AOF写日志是反的。</p><p>原因：</p><ol><li>不会阻塞当前命令执行</li><li>如果当前命令成功执行，也就说明这个命令没有问题，那么写入日志很ok。</li></ol><h3 id="11-1-AOF持久化的实现"><a href="#11-1-AOF持久化的实现" class="headerlink" title="11.1 AOF持久化的实现"></a>11.1 AOF持久化的实现</h3><p>AOF持久化功能的实现可以分为命令追加（ append)、文件写入、文件同步( sync)三个步骤。</p><p><strong>命令追加</strong></p><p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf缓冲区的末尾。</p><p><strong>AOF文件的写入与同步</strong></p><p>为了提高文件的写入效率，在现代操作系统中，当用户调用 write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正的将缓冲区中的数据写入到磁盘里面。<br>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>因此，Redis 服务器配置 appendfsync 选项的值直接决定 AOF 持久化功能的效率和安全性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424111144986.png" alt="image-20240424111144986"></p><p> AOF 配置项 appendfsync 的三个可选值。</p><ul><li><p><strong>Always</strong>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p></li><li><p><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p></li><li><p><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p></li></ul><p>三种策略的写回时机:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425142848519.png" alt="image-20240425142848519"></p><p>简单一句话：要高性能，选择 No 策略；要高可靠性，选择 Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。</p><h3 id="11-2-AOF-文件的载入与数据还原"><a href="#11-2-AOF-文件的载入与数据还原" class="headerlink" title="11.2 AOF 文件的载入与数据还原"></a>11.2 AOF 文件的载入与数据还原</h3><p>因为 AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端（fake client）</li><li>从 AOF 文件中分析并读取一条写命令</li><li>使用伪客户端执行被读出的写命令</li><li>重复执行步骤 2 与 步骤 3 ，直到 AOF 中的所有写命令都被处理完毕为止。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424111221484.png" alt="image-20240424111221484"></p><h3 id="11-3-AOF重写"><a href="#11-3-AOF重写" class="headerlink" title="11.3 AOF重写"></a>11.3 AOF重写</h3><p>为什么要重写？</p><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF 文件的体积越大，使用AOF 文件来进行数据还原所需的时间就越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（ rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF 文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF 文件的体积要小得多。</p><p><strong>AOF文件重写实现</strong></p><p>虽然 Redis将生成新AOF文件替换旧AOF 文件的功能命名为“AOF文件重写”，<strong>但实际上，AOF 文件重写并不需要对现有的AOF 文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</strong></p><p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，<strong>这就是AOF重写功能的实现原理</strong>。</p><p><strong>AOF后台重写</strong></p><p>上面介绍的AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的任务，但是，因为这个函数会进行大量的写人操作，所以调用这个函数的线程将被长时间阻塞,所以 Redis 决定将AOF重写程序放到子进程里执行。</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p><p>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区，如图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424112203933.png" alt="image-20240424112203933"></p><p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的 AOF 文件进行改名，原子地（atomic）覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。</p><p>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其它时候，AOF 后台重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。</p><p><strong>总结</strong>：</p><p>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作后，服务器就会重写缓冲区中的所有内容追加到新的AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p><p>这里，对AOF和做个总结</p><div class="table-container"><table><thead><tr><th></th><th><strong>RDB</strong></th><th><strong>AOF</strong></th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table></div><blockquote><p><strong>极客时间中重写总结</strong></p></blockquote><p>重写的过程总结为<strong>一个拷贝，两处日志</strong>。</p><p>重写过程是由后台线程 bgrewriteaof 来完成的。</p><ol><li>“一个拷贝”是指什么？</li></ol><ul><li>每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</li></ul><ol><li>“两处日志”又是什么呢？</li></ol><ul><li><p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p></li><li><p>而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240425143725321.png" alt="image-20240425143725321"></p><h2 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 事件"></a>第十二章 事件</h2><p>Redis 服务器是一个事件驱动器，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis 服务器通过套接字与客户端（或者其它 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其它服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis 服务器中的一些操作（比如 serverCron 函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h3 id="12-1-文件事件"><a href="#12-1-文件事件" class="headerlink" title="12.1 文件事件"></a>12.1 文件事件</h3><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用 I / O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其它同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p><p>文件事件分为 AE_READABLE事件（读事件）和 AE_WRITEABLE 事件（写事件）两类。</p><h3 id="12-2-时间事件"><a href="#12-2-时间事件" class="headerlink" title="12.2 时间事件"></a>12.2 时间事件</h3><p>Redis 的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序 X 在当前时间的 30 毫秒之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序 X 每隔 30 毫秒就执行一次。</li></ul><p>服务器在一般情况下只执行 serverCron 函数一个时间事件，并且这个事件是周期性事件。</p><p>时间事件的实际处理时间通常会比设定的到达时间晚一些。</p><blockquote><p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</p></blockquote><h2 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 客户端"></a>第十三章 客户端</h2><h2 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 服务器"></a>第十四章 服务器</h2><p>Q：为什么单线程Redis能那么快？</p><p>A：</p><p>首先，先理清下概念：Redis 是单线程，主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程</strong>。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><p>快呢，有4点原因：</p><ol><li><p>内存DB </p></li><li><p>单线程，没有线程切换开销</p></li><li>IO多路复用</li><li>底层数据结构</li></ol><h2 id="第十五章-复制"><a href="#第十五章-复制" class="headerlink" title="第十五章 复制"></a>第十五章 复制</h2><p>在 Redis 中，用户可以通过执行 SLAVEOF命令或者设置 slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器被称为从服务器（slave）。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424112727043.png" alt="image-20240424112727043"></p><blockquote><p>Redis中可以通过 SLAVEOF 命令来设置一个服务器为从服务器，从而复制指定的主服务器的数据。</p></blockquote><h3 id="15-1-旧版复制功能的实现"><a href="#15-1-旧版复制功能的实现" class="headerlink" title="15.1 旧版复制功能的实现"></a>15.1 旧版复制功能的实现</h3><p>旧版复制功能包括 同步(sync) 和 命令传播 两个操作。</p><p><strong>同步</strong></p><p>从服务器对主服务器的同步操作需要发送 SYNC命令来实现，该命令的执行步骤包括：</p><ol><li>从服务器向主服务器发送SYNC命令；</li><li>主服务器接收到命令后，执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区来记录从当前开始的写命令；</li><li>当主服务器的 BGSAVE命令执行完成后就将 RDB 文件发送给从服务器，从服务器开始接受并且载入这个RDB 文件；</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器执行，从服务器来将自己的数据库状态更新为主服务器的状态。</li></ol><p><strong>命令传播</strong> </p><p>在同步操作完成后，主服务器一旦有一些新命令的执行导致数据库发生改变就需要将改变立刻同步到从服务器，因此对于会导致数据库更改的命令，主服务器会同样发送到从服务器。</p><h3 id="15-2-旧版复制功能的缺陷"><a href="#15-2-旧版复制功能的缺陷" class="headerlink" title="15.2 旧版复制功能的缺陷"></a>15.2 旧版复制功能的缺陷</h3><p>在Redis中的复制可以分为初次复制和断线后的重复制。旧版复制对于初次复制没有问题，但是断线后的重复制效率比较低。<br>因为当复制过程中出现断线后，当从服务器再次连接上时由于没有记录上次的复制位置，所以需要重新从头开始复制，执行SYNC 命令(初次复制)。<br>但是主从服务器断开的时间比较短，导致主服务器在断线期间执行的写命令较少，而每次断线时为了这点命令选择执行 SYNC命令，效率非常低效。</p><p><strong>SYNC 命令是一种非常耗时的操作</strong></p><ul><li>主服务器要执行 BGSAVE 指令来生成 RDB 文件，这个操作会消耗主服务器大量的 CPU、内存和磁盘 I/O 资源。</li><li>主服务器将 RDB 文件发送到从服务器会消耗网络资源。</li><li>从服务器接受 RDB 文件后会载入，这个期间从服务器会阻塞没有办法处理命令请求。</li></ul><h3 id="15-3-新版复制功能的实现"><a href="#15-3-新版复制功能的实现" class="headerlink" title="15.3 新版复制功能的实现"></a>15.3 新版复制功能的实现</h3><p>新版复制采用 PSYNC 命令代替旧版的 SYNC 命令。</p><p>这不就是增量复制麻Qwq</p><p>该命令包含两个部分：</p><ul><li>完整重同步：和旧版复制的初次复制操作一样。</li><li>部分重同步：用于断线后的处理，采用 复制偏移量、复制积压缓冲区、服务器运行ID来实现搞笑的重连接复制操作。</li></ul><p><strong>部分重同步</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424150947810.png" alt="image-20240424150947810"></p><p>主服务器和从服务器各保存一份复制偏移量，每次主服务器发送数据和从服务器成功接受数据就增加相应的偏移量。通过复制偏移量能够确保主从服务器的数据状态是否一致。</p><p><strong>复制积压缓冲区</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424151008569.png" alt="image-20240424151008569"></p><p>复制积压缓冲区的特点：</p><ul><li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度</strong>的先进先出队列，默认大小为 1MB。</li><li>每当主服务器进行命令传播时，它不仅会将数据发送给从服务器，还要将数据写入到复制积压缓冲区中，复制积压缓冲区同时还会为队列中的每个字节记录相应的复制偏移量。</li><li>那么当从服务器断线重连后，它会将自己的复制偏移量发送给主服务器，主服务器就会检查该偏移量之后的数据是否全部存在于复制积压缓冲区中，如果全部存在就执行部分重同步操作；否则必须执行完整重同步操作。</li></ul><p>复制积压缓冲区大小可以动态调整：</p><ul><li>默认大小是 1MB，但是如果断线时间过长，断线时写入的数据较多，就会由于缓冲区大小太小而不得不进行完整重同步操作。</li><li>缓冲区大小的计算公式：second * write_size_per_second来估算，second表示从服务器断线后重新连接上主服务器所需的时间；write_size_per_second 表示主服务器每秒钟写入的命令数据量。</li><li>可以通过修改配置文件中的 repl-backlog-size 选项调整缓冲区大小；通过repl-backlog-ttl调整缓冲区的存活时间，超过会被销毁。</li></ul><p><strong>服务器ID</strong></p><p>每个服务器启动时都会分配一个服务器ID，当从服务器对主服务器进行初次同步操作时，主服务器会将自己的服务器ID发送给从服务器，从服务器会保存起来。<br>如果从服务器断开后重连到一个主服务器，它会发送之前保存的主服务器ID，如果ID和当前主服务器ID相同就执行部分重同步操作，否则执行完整重同步操作。</p><p>从服务器发送指令：</p><ul><li>如果从服务器初次同步主服务器，它会发送 PSYNC ? -1命令，请求完整重同步操作；</li><li>如果从服务器已经复制过某个主服务器后，当它开始一次新复制时会发送 PSYNC &lt; runid &gt; &lt; offset &gt; 命令，runid 是上次主服务器的ID， offset 是自己当前的复制偏移量。</li></ul><p>主服务器回复指令：</p><ul><li>+FULLRESYNC &lt; runid &gt; &lt; offset &gt;：主服务器与从服务器执行完整的重同步操作；</li><li>+CONTINUE：执行部分重同步操作，等待主服务器发送数据；</li><li>-ERR：识别不了命令，出现问题。</li></ul><p>明了概念</p><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul><h3 id="15-7-心跳检测"><a href="#15-7-心跳检测" class="headerlink" title="15.7 心跳检测"></a>15.7 心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令 REPLCONF ACK <replication_offset> ，其中 replication_offset 是从服务器当前的复制偏移量。</p><p>发送 REPLCONF ACK命令对于从服务器有三个作用：</p><ul><li>检测主从服务器的网络连接状态。</li><li>辅助实现 min-slaves选项。</li><li>检测命令是否丢失。</li></ul><h2 id="第十六章-Sentinel"><a href="#第十六章-Sentinel" class="headerlink" title="第十六章 Sentinel"></a>第十六章 Sentinel</h2><p>这个大致思路和raft协议很像。</p><p>Sentinel（哨岗、哨兵）是 Redis 的高可用性解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><p>哨兵的作用</p><ul><li>监控：Sentinel 会不断检查您的master和slave是否按预期工作</li><li>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424113707465.png" alt="image-20240424113707465"></p><p><strong>主观下线</strong></p><p>在默认情况下，Sentinel 会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其它 Sentinel 在内）发送 PING 命令，并通过实例返回的 PING命令回复来判断实例是否在线。</p><p>如果在默认配置的间隔时间内，有一服务器并没有进行有效回复，那此 Sentinel 就会将此服务器标记为主观下线。</p><p><strong>客观下线</strong></p><p>当 Sentinel 将一个服务器判断为主观下线之后，为了确定此服务器是否是真的下线了，它会去询问其它 Sentinel 此服务器是否已下线，当得到足够数量的确定回复之后，Sentinel 就会将此服务器标记为客观下线状态，如果此服务器是主服务器，就执行故障转移操作。</p><p><strong>选举领头 Sentinel</strong></p><p>当一个主服务器被判定为客观下线之后，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作。</p><p><strong>故障转移</strong></p><p>在选举产生领头 Sentinel 之后，领头 Sentinel 将对已下线的主服务器执行故障转移操作，包含以下三个步骤：</p><ol><li>在已下线主服务器的所有从服务器中，选择一个从服务器将其转换为新的主服务器。</li><li>让已下线主服务器的所有从服务器改为复制新的从服务器。</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，他就会成为新的主服务器的从服务器</li></ol><p><strong>总结</strong></p><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点，执行slaveof 新master</li></ul><h2 id="第十七章-集群"><a href="#第十七章-集群" class="headerlink" title="第十七章 集群"></a>第十七章 集群</h2><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><p>一个 Redis 集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接各个节点的工作可以使用这个命令来完成</span></span><br><span class="line">CLUSTER MEET  </span><br></pre></td></tr></table></figure><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424114229008.png" alt="image-20240424114229008"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li><p>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</p></li><li><p>key中不包含“{}”，整个key都是有效部分</p></li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424114234608.png" alt="image-20240424114234608"></p><p>Redis如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h2 id="第十八章-发布与订阅"><a href="#第十八章-发布与订阅" class="headerlink" title="第十八章 发布与订阅"></a>第十八章 发布与订阅</h2><p>Redis 的发布与订阅功能由 PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成</p><ul><li>SUBSCRIBE是频道订阅，客户端可以订阅一个或多个频道，成为这些频道的订阅者（subscriber），每当有其它客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息</li><li>PSUBSCRIBE是基于模式的订阅，除了订阅频道之外，客户端还可以通过执行 PSUBSCRIBE 命令订阅一个或多个模式，从而成为这些模式的订阅者，每当有其它客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会发送给所有与这个频道相匹配的模式的订阅者。</li></ul><p>客户端可以通过 PUBSUB命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者等等。</p><p>当一个 Redis 客户端执行 PUBLISH  &lt; channel &gt; &lt; message &gt; 命令将消息 message 发送给频道 channel 的时候，服务器需要执行以下两个动作：</p><ol><li>将消息 message 发送给 channel 频道的所有订阅者。</li><li>如果有一个或多个模式的 pattern 与频道 channel 相匹配，那么将消息 message 发送给 pattern 模式的订阅者。</li></ol><h2 id="第十九章-事务"><a href="#第十九章-事务" class="headerlink" title="第十九章 事务"></a>第十九章 事务</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务( transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><h3 id="19-1-事务的实现"><a href="#19-1-事务的实现" class="headerlink" title="19.1 事务的实现"></a>19.1 事务的实现</h3><p>一个事务从开始到结束通常会经历以下三个阶段:</p><p>1）事务开始</p><p>2）命令入队</p><p>3）事务执行</p><p>本节接下来的内容将对这三个阶段进行介绍，说明一个事务从开始到结束的整个过程。</p><p><strong>事务开始</strong></p><ol><li>MULTI 命令的执行代表事务的开始，MULTI通过将客户端状态的 flags 属性中的 REDIS_MULTI标识打开来将执行该命令的客户端切换至事务状态。</li><li>每个客户端都有自己的事务状态，它保存在客户端状态的 mstate 属性里面，mstate 里面包含一个事务队列，以及一个已入队命令的计数器，事务队列是一个 multiCmd类型的数组，每个 multiCmd 结构都保存着一个已入队命令的相关信息，事务队列以先进先出（FIFO）的方式保存入队命令。</li><li>当一个处于事务状态的客户端向服务器发送 EXEC命令时，这个 EXEC命令会立即被执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424142426360.png" alt="image-20240424142426360"></p><h3 id="19-2-WATCH命令的实现"><a href="#19-2-WATCH命令的实现" class="headerlink" title="19.2 WATCH命令的实现"></a>19.2 WATCH命令的实现</h3><p>WATCH命令是一个乐观锁（ optimistic locking )，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p><p>接下来，我将详细介绍下watch命令的实现原理。</p><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端:</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424142552387.png" alt="image-20240424142552387"></p><p>下图展示的watched_keys字典将被更新的状态。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424142606928.png" alt="image-20240424142606928"></p><p><strong>监视机制的触发</strong></p><p>所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchwatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAs标识打开，表示该客户端的事务安全性已经被破坏。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240424142724988.png" alt="image-20240424142724988"></p><h3 id="19-3-事务的ACID性质"><a href="#19-3-事务的ACID性质" class="headerlink" title="19.3 事务的ACID性质"></a>19.3 事务的ACID性质</h3><p>在 Redis 中，事务总是具有原子性(Atomicity )、一致性( Consistency)和隔离性( Isolation )，并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性( Durability )。</p><h2 id="第二十章-Lua脚本"><a href="#第二十章-Lua脚本" class="headerlink" title="第二十章 Lua脚本"></a>第二十章 Lua脚本</h2><h2 id="第二十一章-二进制位数组"><a href="#第二十一章-二进制位数组" class="headerlink" title="第二十一章 二进制位数组"></a>第二十一章 二进制位数组</h2><p>Redis 提供了 SETBIT、GETBIT、BITCOUNT、BITOP 四个命令用于处理二进制位数组，又称 “位数组”</p><ul><li>SETBIT命令用于为位数组指定偏移量上的二进制位设置值，可以是 0 或者 1</li><li>GETBIT 用于获取指定偏移量上的二进制位的值</li><li>BITCOUNT 用于统计位数组里面，值为 1 的二进制位的数量</li><li>BITOP可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）、取反（not）运算</li></ul><p>Redis 使用 SDS 来保存位数组。</p><h2 id="第二十二章-慢查询日志"><a href="#第二十二章-慢查询日志" class="headerlink" title="第二十二章 慢查询日志"></a>第二十二章 慢查询日志</h2><ul><li>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</li></ul><h2 id="第二十三章-监视器"><a href="#第二十三章-监视器" class="headerlink" title="第二十三章 监视器"></a>第二十三章 监视器</h2><ul><li>客户端可以通过执行 MONITOR 命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息</li><li>当一个客户端从普通客户端变为监视器时，该客户端的 REDIS_MONITOR标识会被打开</li><li>服务器将所有监视器都记录在 monitors 链表中</li><li>每次处理命令时，服务器都会遍历 monitors 链表，将相关信息发送给监视器</li></ul>]]></content>
    
    
    <summary type="html">《Redis设计与实现》</summary>
    
    
    
    <category term="Redis" scheme="https://penge666.github.io/categories/Redis/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/categories/Redis/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://penge666.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="https://penge666.github.io/posts/a5a0c60f.html"/>
    <id>https://penge666.github.io/posts/a5a0c60f.html</id>
    <published>2024-04-23T09:58:36.000Z</published>
    <updated>2024-04-24T09:01:56.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>来个问题先=-=</p><p>Q：为什么加缓存？</p><p>A：因为CPU和主存的速度差异。</p><p>Q：缓存的设计是根据程序局部性原理</p><p>A：程序局部性包括时间局部性和空间局部性。</p><ol><li>时间局部性是指被访问过一次的内存位置很可能在不远的将来会被再次访问。</li><li>空间局部性是指如果一个内存位置被引用过，那么它邻近的位置在不远的将来也有很大概率会被访问。</li></ol><p>开始正题^-^</p><p>缓存是由 SRAM（静态随机存储）组成的，它的本质是一种时序逻辑电路，具体的每个单元（比特）由一个个锁存器构成，锁存器的功能就是让电路具有记忆功能。</p><p>缓存集成到芯片的方式有多种，在多核芯片上，缓存集成的方式主要有以下三种：</p><ul><li><p><strong>集中式缓存</strong>：一个缓存和所有处理器直接相连，多个核共享这一个缓存</p></li><li><p><strong>分布式缓存</strong>：一个处理器仅和一个缓存相连，一个处理器对应一个缓存</p></li><li><p><strong>混合式缓存</strong>：在 L3 采用集中式缓存，在 L1 和 L2 采用分布式缓存</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423160952647.png" alt="image-20240423160952647"></p><p>越靠近 CPU 核心的缓存其访问速度越快，CPU 访问 L1 Cache 只需要 2~4个时钟周期，访问 L2 Cache 大约 10~20 个时钟周期，访问 L3 Cache 大约 20~60 个时钟周期，而访问内存速度大概在 200~300 个时钟周期之间。如下表格：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423161038790.png" alt="image-20240423161038790"></p><h3 id="缓存的工作原理"><a href="#缓存的工作原理" class="headerlink" title="缓存的工作原理"></a>缓存的工作原理</h3><p><strong>介绍</strong></p><p>先来学习下cache line（缓存行/缓存块），cache line 是缓存进行管理的一个最小存储单元，也叫缓存块。从内存向缓存加载数据也是按缓存块进行加载的，一个缓存块和一个内存中相同容量的数据块（下称内存块）对应。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423161303297.png" alt=""></p><p>上图中的小方框就代表一个缓存块。</p><p>整个缓存由组（set）构成，每个组由路（way）构成。所以整个缓存容量等于组数、路数和缓存块大小的乘积：</p><p>计算公式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整个缓存容量=组数×路数×缓存块大小</span><br></pre></td></tr></table></figure><p><strong>简单认识</strong></p><p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为 <strong>Cache Line（缓存块）</strong>。</p><p>我们可以根据以下命令查看linux L1 Cache的缓存大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ✘ penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  <span class="built_in">cat</span>  /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size </span><br><span class="line">64</span><br></pre></td></tr></table></figure><p> L1 Cache 一次载入数据的大小是 64 字节。</p><p>比如，有一个 int array[100]的数组，当载入 array[0]时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会<strong>顺序加载</strong>数组元素到 array[15]，意味着 array[0]~array[15] 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。</p><p><strong>读取流程</strong></p><p>先来个问题：CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？</p><p>为了简化寻址方式，内存地址确定的数据块总是会被放在一个固定的组，但可以放在组内的任意路上，也就是说，对于一个特定地址数据的访问，它如果要载入缓存，那么它放在上图中的行数是固定的，但是具体放到哪一列是不固定的。</p><p>根据缓存中组数和路数的不同，缓存的映射方式分为三类：</p><ul><li><p><strong>直接相连映射</strong>：缓存只有一个路，一个内存块只能放置在特定的组上</p><ul><li>问题：对于直接相连映射，当多个内存块映射到同一组时，会产生冲突，因为只有一列，会导致缓存块被频繁替换。</li></ul></li><li><p><strong>全相连映射</strong>：缓存只有一个组，所有的内存块都放在这一个组的不同路上</p><ul><li>问题：当要查询某个缓存块时，需要逐个遍历每个路。</li></ul></li><li><p><strong>组组相连映射</strong>：缓存同时由多个组和多个路。</p></li></ul><p>下面以直接相连映射举例：</p><p>对于直接映射 Cache 采用的策略，就是把内存块的地址始终「映射」在一个 CPU Line（缓存块） 的地址，至于映射关系实现方式，则是使用「取模运算」，取模运算的结果就是内存块地址对应的 CPU Line（缓存块） 的地址。</p><p>补充：我们提到 CPU 访问内存数据时，是一小块一小块数据读取的，具体这一小块数据的大小，取决于 coherency_line_size的值，一般 64 字节。在内存中，这一块的数据我们称为<strong>内存块（Bock）</strong>，读取的时候我们要拿到数据所在内存块的地址。</p><p>举个例子，内存共被划分为 32 个内存块，CPU Cache 共有 8 个 CPU Line，假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Line 中的话，则是一定映射在 7 号 CPU Line 中，因为 15 % 8的值是 7。</p><p>机智的你肯定发现了，使用取模方式映射的话，就会出现多个内存块对应同一个 CPU Line，比如上面的例子，除了 15 号内存块是映射在 7 号 CPU Line 中，还有 7 号、23 号、31 号内存块都是映射到 7 号 CPU Line 中。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423162615794.png" alt="image-20240423162615794"></p><p>因此，为了区别不同的内存块，在对应的 CPU Line 中我们还会存储一个<strong>组标记（Tag）</strong>。这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。</p><p>除了组标记信息外，CPU Line 还有两个信息：</p><ul><li>一个是，从内存加载过来的实际存放<strong>数据（Data）</strong>。</li><li>另一个是，<strong>有效位（Valid bit）</strong>，它是用来标记对应的 CPU Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。</li></ul><p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<strong>字（Word）</strong>。那怎么在对应的 CPU Line 中数据块中找到所需的字呢？答案是，需要一个<strong>偏移量（Offset）</strong>。</p><p>因此，一个内存的访问地址，包括<strong>组标记、CPU Line 索引、偏移量</strong>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423162643672.png" alt="image-20240423162643672"></p><p>如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：</p><ol><li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址；</li><li>找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li><li>对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是不是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li><li>根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。</li></ol><p><strong>程序优化</strong></p><p>如果下次访问内存时，数据已经在缓存中了，这就是缓存命中，它获取目标数据的速度非常快。如果数据没在缓存中，这就是缓存缺失，此时要启动内存数据传输，而内存的访问速度相比缓存差很多。</p><p>下面，将举出一些和缓存相关的例子，加深在程序上面的应用。</p><blockquote><p>例子</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="comment">// pro1:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">a[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pro2:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">a[j][i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，pro1的执行时间更短，也就是我们常常说的程序局部一致性原理。</p><p>为什么pr2的性能不够好呢？</p><p>原因：主要原因是当按行访问时地址是连续的，下次访问的元素和当前大概率在同一个 cache line（一个元素 8 字节，而一个 cache line 可以容纳 8 个元素），但是当按列访问时，由于地址跨度大，下次访问的元素基本不可能还在同一个 cache line，因此就会增加 cache line 被替换的次数，所以性能劣化。</p><blockquote><p>例子2</p></blockquote><p>伪共享（false-sharing）的意思是说，<strong>当两个线程同时各自修改两个相邻的变量，由于缓存是按缓存块来组织的，当一个线程对一个缓存块执行写操作时，必须使其他线程含有对应数据的缓存块无效。这样两个线程都会同时使对方的缓存块无效，导致性能下降</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> b;</span><br><span class="line">&#125; s;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread1</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000000</span>; i++)&#123;</span><br><span class="line">        s.a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread2</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000000</span>; i++)&#123;</span><br><span class="line">        s.b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    s.a = <span class="number">0</span>;</span><br><span class="line">    s.b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %lld, b = %lld\n&quot;</span>, s.a, s.b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，main 函数中创建了两个线程，分别修改结构体 S 中的 a 、b 变量。a 、b 均为 long long 类型，都占 8 字节，所以 a 、b 在同一个 cache line 中，因此会发生为伪共享的情况。</p><p>根据上述知识，知道解决伪共享的办法是，将 a 、b 不要放在同一个 cache line，这样两个线程分别操作不同的 cache line 不会相互影响。</p><p>将结构体修改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_0;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_1;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_2;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_3;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_4;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_5;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_6;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> nop_7;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> b;</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure><p>因为在 a、b 中间插入了 8 个 long long 类型的变量，中间隔了 64 字节，所以 a、b 会被映射到不同的缓存块。</p><p>分别运行上述的程序，具体运行时间如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  ./main                        </span><br><span class="line">a = 100000000, b = 100000000</span><br><span class="line">520934.0000000000%</span><br><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  g++ example.c -o main -pthread</span><br><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  ./main                        </span><br><span class="line">a = 100000000, b = 100000000</span><br><span class="line">342973.0000000000%   </span><br></pre></td></tr></table></figure><h2 id="缓存一致性协议MESI"><a href="#缓存一致性协议MESI" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议MESI</h2><blockquote><p>基本术语</p></blockquote><p><strong>缓存和内存的更新策略</strong></p><ul><li><p>写回 （ Write Back）：对缓存的修改不会立刻传播到主存，只有当缓存块被替换时，这些被修改的缓存块，才会写回并覆盖内存中过时的数据</p></li><li><p>写直达 （Write Through）：缓存中任何一个字节的修改，都会立刻传播到内存</p></li></ul><p><strong>写缓存时 CPU 之间的更新策略</strong></p><ul><li>写更新（Write Update）：如果 CPU 采取写更新策略，每次它的缓存写入新的值，该 CPU 都必须发起一次总线请求，通知其他 CPU 将它们的缓存值更新为刚写入的值，所以写更新会很占用总线带宽。</li><li>写无效（Write Invalidate）：如果在一个 CPU 修改缓存时，将其他 CPU 中的缓存全部设置为无效</li></ul><p><strong>从写缓存时数据是否被加载</strong></p><ul><li>写分配（Write Allocate）：在写入数据前将数据读入缓存</li><li>写不分配（Not Write Allocate）：在写入数据时，直接将要写入的数据传播内存，而并不将数据块读入缓存</li></ul><p>开始正题：</p><p>Q：为什么要设计这个协议呢？</p><p>A：因为当多核CPU对缓存数据进行读写操作的时候，导致不一致性。因此引入这个协议保证不让系统数据混乱。</p><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><blockquote><p>缓存行（Cache line）:缓存存储数据的单元。</p></blockquote><div class="table-container"><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td>M 修改 (Modified)</td><td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td></tr><tr><td>E 独享、互斥 (Exclusive)</td><td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td></tr><tr><td>S 共享 (Shared)</td><td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td><td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td>I 无效 (Invalid)</td><td>该Cache line无效。</td><td>无</td></tr></tbody></table></div><p><strong>MESI状态转换</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423155851866.png" alt="image-20240423155851866"></p><p>触发事件：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423155500901.png" alt=""></p><p>各个状态转移情况</p><ul><li>M状态</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423160109457.png" alt="image-20240423160109457"></p><ul><li>E状态</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423160152951.png" alt="image-20240423160152951"></p><ul><li>S状态</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423160251531.png" alt="image-20240423160251531"></p><ul><li>I状态</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423160319450.png" alt="image-20240423160319450"></p><p><strong>总结</strong></p><p>MESI协议：当CPU写数据(M)时，如果发现操作的变量是共享变量(s) ，会发出信号通知其他CPU将该变量的缓存行置为无效状态(1) ，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取，确保一致性。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>在上面的章节我们学习到，在 Share 状态下，如果一个核想独占缓存进行修改，就需要先给所有 Share 状态的同伴发出 Invalid 消息，等所有同伴确认并回复它“Invalid acknowledgement”以后，它才能把这块缓存的状态更改为 Modified，这是保持多核信息同步的必然要求。但是这个过程是很耗费时间的。【简单来说，一个CPU每次的修改都要等待另外的CPU的确认信息，这是比较耗费时间的】</p><p>那就继续优化！！！</p><h3 id="写缓冲与写屏障"><a href="#写缓冲与写屏障" class="headerlink" title="写缓冲与写屏障"></a>写缓冲与写屏障</h3><p>CPU 的设计者为每个核都添加了一个名为 <strong>store buffer</strong> 的结构，store buffer 是硬件实现的缓冲区，它的读写速度比缓存的速度更快，所有面向缓存的写操作都会先经过 store buffer。</p><p>增加了 store buffer 以后的 CPU 缓存结构</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423164905953.png" alt=""></p><p>这里，如果 CPU 的某个核再要对一个变量进行赋值，它就不必等到所有的同伴都确认完，而是直接把新的值放入 store buffer，然后再由 store buffer 慢慢地去做核间同步，并且将新的值刷入到 cache 中去就好了。而且，每个核的 store buffer 都是私有的，其他核不可见。</p><p>但是有个Bug：就是<strong>它并不能保证变量写入缓存和主存的顺序</strong>。</p><p>来个看经典的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CPU1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423170726938.png" alt="image-20240423170726938"></p><p>在这个代码块中，CPU0 执行 foo 函数，CPU1 执行 bar 函数。但在对变量 a 和 b 进行赋值的时候，有两种情况会导致它们的赋值顺序被打乱。</p><p><strong>第一种情况是 CPU 的乱序执行</strong>。可能会b先执行，然后再执行a。这是因为CPU 为了提升运行效率和提高缓存命中率，采用了乱序执行。</p><p><strong>第二种情况是 store buffer 在写入时，有可能 b 所对应的缓存行会先于 a 所对应的缓存行进入独占状态，也就是说 b 会先写入缓存。</strong>【store buffer将变量放进缓存的顺序不一致】</p><p>简单来说就是因为Store Buffer的存在，最后结果不确定。</p><ol><li>a的值可能因为是Share（共享）先被写入了Store Buffer，并发送通知其他cpu置为Invalid(失效)。</li><li>b的值，可能因为在cache中已经存在并且是Exclusive（独占）直接被写进cache中。</li><li>读取的时候因为先读b的值，b被刷进主存供读取。</li><li>后面要读a，因为还没收到失效通知，从cache中直接拿到a，断言失败。</li></ol><p>为此，CPU 设计者就引入了<strong>内存屏障，屏障的作用是前边的读写操作未完成的情况下，后面的读写操作不能发生</strong>。</p><p>来看看加了内存屏障的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">smp_mb</span>();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CPU1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>smp_mb 就代表了多核体系结构上的内存屏障。由于在不同的体系结构上，指令各不相同，我们使用一个函数对它进行封装。加上这一道屏障以后，CPU 会保证 a 和 b 的赋值指令不会乱序执行，同时写入 cache 的顺序也与程序代码保持一致。</p><p><strong>所以说，内存屏障保证了，其他 CPU 能观察到 CPU0 按照我们期望的顺序更新变量</strong>。</p><p>总的来说，store buffer 的存在是为提升写性能，放弃了缓存的顺序一致性，我们把这种现象称为<strong>弱缓存一致性</strong>。</p><h3 id="失效队列与读屏障"><a href="#失效队列与读屏障" class="headerlink" title="失效队列与读屏障"></a>失效队列与读屏障</h3><p>上述过程中还存在问题，当一个 CPU 向同伴发出 Invalid 消息的时候，它的同伴要先把自己的缓存置为 Invalid，然后再发出 acknowledgement。这个从“把缓存置为 Invalid”到“发出 acknowledgement”的过程所需要的时间也是比较长的。由于 store buffer 的存在提升了写入速度，那么 invalid 消息确认速度相比起来就慢了，这就带来了速度的不匹配。很容易导致 store buffer 的内容还没有及时更新到 cache 里，自己的容量就被撑爆了，从而失去了加速的作用。</p><p>为此，引入了失效队列（invalid queue）。</p><p>失效队列工作流程：收到 Invalid 消息的 CPU，比如我们称它为 CPU1，在收到 Invalid 消息时立即向 CPU0 发回确认消息，但这个时候 CPU1 并没有把自己的 cache 由 Share 置为 Invalid，而是把这个失效的消息放到一个队列中，等到空闲的时候再去处理失效消息，这个队列就是 invalid queue。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240423172524418.png" alt="image-20240423172524418"></p><p>运行上面增加内存屏障的代码，第 11 行的断言又可能失败了。</p><p>核心0 中 a 所对应的缓存行是 <strong>S</strong> 状态，b 所对应的缓存行是 <strong>E</strong> 状态；核心1中 a 所对应的缓存行是 <strong>S</strong> 状态，b 所对应的缓存行是 <strong>I</strong> 状态；</p><ul><li>因为有内存屏障在，a 和 b的写入缓存的顺序不会乱。</li><li>a 先向其他核心发送 Invalid 消息，并且等待 Invalid 确认消息；</li><li>Invalid 消息先入 核心1 对应的 Invalid Queue 并立刻返回确认消息，等待 核心1 处理；</li><li>核心0 收到确认消息后把 a 写入缓存，继续处理 b 的写入，由于 b 是 <strong>E</strong> 状态，直接写入缓存；</li><li>核心1 发送 BusRd 消息，读取到新的 b 值，然后获取 a（<strong>S</strong> 状态）值是0，因为使其无效的消息还在 Invalid Queue 中，第 11 行断言失败。</li></ul><p>引入 Invalid Queue 后，对核心1 来说看到的 a 和 b 的写入又出现乱序了。</p><p>解决办法是继续加内存屏障，核心1 想越过屏障必须清空 Invalid Queue，及时处理了对 a 的无效，然后读取到新的 a 值，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// CPU0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">smp_mb</span>();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CPU1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">smp_mb</span>(); <span class="comment">//继续加内存屏障</span></span><br><span class="line">    <span class="built_in">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的内存屏障是<strong>全屏障</strong>，包括读写屏障，过于严格了，会导致性能下降，所以有了细粒度的<strong>读屏障</strong>和<strong>写屏障</strong>。</p><h3 id="读写屏障分离"><a href="#读写屏障分离" class="headerlink" title="读写屏障分离"></a>读写屏障分离</h3><p>完全遵守MESI协议CPU性能下降，但是增加了这两个队列就无法保证一致性。</p><p>分离的写屏障和读屏障的出现，是为了更加精细地控制 Store Buffer 和 Invalid Queue 的顺序。</p><p>也就是说</p><ul><li>写屏障之前的写操作一定会比之后的写操作先写到缓存中。</li><li>屏障前后的读操作都不能翻过屏障。</li></ul><p>【store buffer写进缓存顺序写，失效队列消费完成了再读】</p><p>优化前面的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// CPU0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">smp_wmb</span>(); <span class="comment">//写屏障</span></span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CPU1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">smp_rmb</span>(); <span class="comment">//读屏障</span></span><br><span class="line">    <span class="built_in">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这种修改只有在区分读写屏障的体系结构里才会有作用，比如 alpha 结构。而在 X86 和 Arm 中是没有作用的，这是因为 X86 采用的 TSO 模型不存在缓存一致性的问题，而 Arm 则是采用了另一种称为单向屏障的分类方式。</p><h3 id="单向屏障"><a href="#单向屏障" class="headerlink" title="单向屏障"></a>单向屏障</h3><p>单向屏障 (<strong>half-way barrier</strong>) 也是一种内存屏障，但它不是以读写来区分的，而是像单行道一样，只允许单向通行，例如 ARM 中的 stlr 和 ldar 指令就是这样。</p><ul><li><strong>stlr</strong> 的全称是 store release register，包括 StoreStore barrier 和 LoadStore barrier（场景少），通常使用 release 语义将寄存器的值写入内存；</li><li><strong>ldar</strong> 的全称是 load acquire register，包括 LoadLoad barrier 和 LoadStore barrier（对，你没看错，我没写错），通常使用 acquire 语义从内存中将值加载入寄存器；</li><li><strong>release</strong> 语义的内存屏障只不允许其前面的读写向后越过屏障，<strong>挡前不挡后</strong>；</li><li><strong>acquire</strong> 语义的内存屏障只不允许其后面的读写向前越过屏障，<strong>挡后不挡前;</strong></li><li>StoreLoad barrier 就只能使用 <strong>dmb</strong>（全屏障） 代替了。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/rong_toa/article/details/109274448">CPU Cache Line：CPU缓存行/缓存块</a></li><li><a href="https://www.bilibili.com/video/BV1fK4y1E7NC/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d6efee335659a376be8deb6c0654e9f7">缓存一致性协议MESI</a></li><li><a href="https://zhuanlan.zhihu.com/p/467782159">全知乎最详细的并发研究之CPU缓存一致性协议(MESI)有这一篇就够了！</a></li><li><a href="[金阶之路：内存屏障（Memory Barriers） - 知乎 (zhihu.com">金阶之路：内存屏障（Memory Barriers）</a>](<a href="https://zhuanlan.zhihu.com/p/606658179">https://zhuanlan.zhihu.com/p/606658179</a>))</li><li>《极客时间》</li></ul>]]></content>
    
    
    <summary type="html">Memory Barriers</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战45讲</title>
    <link href="https://penge666.github.io/posts/cc27ac8a.html"/>
    <id>https://penge666.github.io/posts/cc27ac8a.html</id>
    <published>2024-04-21T10:50:21.000Z</published>
    <updated>2024-04-24T07:35:45.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>极客时间《MySQL实战45讲》学习笔记</p><h2 id="01-基础架构：-一条SQL查询语句是如何执行的"><a href="#01-基础架构：-一条SQL查询语句是如何执行的" class="headerlink" title="01 | 基础架构： 一条SQL查询语句是如何执行的 ?"></a><strong>01 | 基础架构：</strong> <strong>一条SQL查询语句是如何执行的 ?</strong></h2><p>MySQL基本架构示意图：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421185512876.png" alt="image-20240421185512876"></p><p>MySQL可以分为Server层和存储引擎层两部分。</p><ul><li><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p></li><li><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p></li></ul><p><strong>连接器</strong></p><p>第一步，会先连接到这个数据库上， 这时候接待你的就是连接器。 连接器负责跟客户端建立连接、 获取权限、 维持和管理连接。</p><blockquote><p><strong>长连接</strong></p></blockquote><p>数据库中<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>问题：MySQL在执行过程中临时使用的内存是管理在连接对象里面的，可能导致MySQL占用内存涨得特别快。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>解决方法：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>MySQL 5.7及以上，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><p><strong>查询缓存</strong></p><p>MySQL拿到一个查询请求后， 会先到查询缓存看看， 之前是不是执行过这条语句。 之前执行过的语句及其结果可能会以key-value对的形式， 被直接缓存在内存中。 key是查询的语句， value是查询的结果。 如果你的查询能够直接在这个缓存中找到key， 那么这个value就会被直接返回给客户端。</p><p>查询缓存往往弊大于利 ，大多数时候建议不要使用。</p><p>原因：查询缓存的失效频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p><strong>分析器</strong></p><p>如果没有命中查询缓存， 就要开始真正执行语句了。 分析器先会做“词法分析”。 你输入的是由多个字符串和空格组成的一条SQL语句， MySQL需要识别出里面的字符串分别是什么， 代表什么 。做完了这些识别以后， 就要做“语法分析”。 根据词法分析的结果， 语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p><strong>优化器</strong></p><p>在开始执行之前， 还要先经过优化器的处理。优化器是在表里面有多个索引的时候， 决定使用哪个索引； 或者在一个语句有多表关联（join）的时候， 决定各个表的连接顺序。</p><p><strong>执行器</strong></p><p>开始执行的时候， 要先判断一下你对这个表T有没有执行查询的权限 。如果有权限， 就打开表继续执行。 打开表的时候， 执行器就会根据表的引擎定义， 去使用这个引擎提供的接口。</p><h2 id="02-日志系统：-一条SQL更新语句是如何执行的？"><a href="#02-日志系统：-一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志系统： 一条SQL更新语句是如何执行的？"></a><strong>02 | 日志系统：</strong> <strong>一条SQL更新语句是如何执行的？</strong></h2><p>与查询流程不一样的是， 更新流程还涉及两个重要的日志模块： redo log（重做日志） 和 binlog（归档日志）。 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log里面， 并更新内存， 这个时候更新就算完成了。然后Server层更新binlog,刷到磁盘。 同时， InnoDB引擎会在适当的时候， 将这个操作记录更新到磁盘里面。</p><p><strong>Redo log</strong></p><p>文中举了《孔乙己》粉板和账本配合的故事，即对应MySQL中的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>这里来介绍下redo log：</p><p>InnoDB的redo log是固定大小的， 比如可以配置为一组4个文件， 每个文件的大小是1GB， 那么这块“粉板”总共就可以记录4GB的操作。 从头开始写， 写到末尾就又回到开头循环写， 如下面这个图所示。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421190252047.png" alt="image-20240421190252047"></p><p>write pos是当前记录的位置， 一边写一边后移， 写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置， 也是往后推移并且循环的， 擦除记录前要把记录更新到数据文件。write pos和checkpoint之间的是“粉板”上还空着的部分， 可以用来记录新的操作。 如果write pos追上checkpoint， 表示“粉板”满了， 这时候不能再执行新的更新， 得停下来先擦掉一些记录， 把checkpoint推进一下。</p><blockquote><p><strong>补充</strong></p></blockquote><p>redo log其实是由两部分组成的，一部分是重做日志缓冲（redo log buffer），这部分是确实存在于内存中的；而另一部分则是重做日志文件（redo log file），这部分是存储在磁盘中的。当事务提交后，所有修改的信息会先存到内存中的重做日志缓冲，然后再被写入到磁盘的重做日志文件中。所以，我们不能简单地说redo log是在内存还是在磁盘，它其实是同时在内存和磁盘中都有存在的部分</p><p><strong>Binlog</strong></p><p>另外一个日志就是Binlog啦，先看看和redo log有啥差异。</p><p><strong>思考</strong>：为啥要有这个binlog日志呢，我认为是用于备份用的，即主从备份，分布式raft那一套。而redo log是用于优化效率用的。</p><p>有以下三点不同</p><ol><li><p>redo log是InnoDB引擎特有的； binlog是MySQL的Server层实现的， 所有引擎都可以使用。</p></li><li><p>redo log是物理日志， 记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志， 记录的是这个语句的原始逻辑， 比如“给ID=2这一行的c字段加1 ”。</p></li><li><p>redo log是循环写的， 空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件写到一定大小后会切换到下一个， 并不会覆盖以前的日志。</p></li></ol><p>接下来，看看下面这条update SQL的执行流程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>执行流程图</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421191135808.png" alt="image-20240421191135808"></p><p>解释：</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p><strong>两阶段提交</strong></p><p>这个两阶段提交在分布式也极为常见的概念，2阶段提交的<strong>2阶段</strong>分别是<strong>提交请求阶段</strong>和<strong>提交执行阶段</strong>。</p><p><strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><ul><li>首先，找到最近的一次全量备份，从这个备份恢复到临时库。</li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到误删表之前的那个时刻。</li></ul><p><strong>为什么需要2阶段提交呢？</strong></p><p>这里通过反证明法说明。</p><p>由于redo log和binlog是两个独立的逻辑， 如果不用两阶段提交， 要么就是先写完redo log再写binlog， 或者采用反过来的顺序。仍然用前面的update语句来做例子。 假设当前ID=2的行， 字段c的值是0， 再假设执行update语句过程中在写完第一个日志后， 第二个日志还没有写完期间发生了crash， 会出现什么情况呢？</p><p><strong>先写redo log后写binlog。</strong> 假设在redo log写完， binlog还没有写完的时候， MySQL进程异常重启。 由redo log写完之后， 系统即使崩溃， 仍然能够把数据恢复回来， 所以恢复后这一行c的值是1。但是由于binlog没写完就crash了， 这时候binlog里面就没有记录这个语句。 因此， 之后备份日志的时候， 存起来的binlog里面就没有这条语句。如果需要用这个binlog来恢复临时库的话，恢复出来的这一行c的值就是0， 与原库的值不同。</p><p><strong>先写binlog后写redo log。</strong> 如果在binlog写完之后crash， 由于redo log还没写， 崩溃恢复以后这个事务无效， 所以这一行c的值是0。 但是binlog里面已经记录了“把c从0改成1”这个日志。 所以， 在之后用binlog来恢复的时候就多了一个事务出来， 恢复出来的这一行c的值就是1， 与原库的值不同。</p><p>简单说， redo log和binlog都可以用于表示事务的提交状态， 而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="03-事务隔离：-为什么你改了我还看不见？"><a href="#03-事务隔离：-为什么你改了我还看不见？" class="headerlink" title="03 | 事务隔离： 为什么你改了我还看不见？"></a><strong>03 | 事务隔离：</strong> <strong>为什么你改了我还看不见？</strong></h2><p>简单来说， 事务就是要保证一组数据库操作， 要么全部成功， 要么全部失败。 在MySQL中， <strong>事务支持是在引擎层实现的</strong>。 你现在知道， MySQL是一个支持多引擎的系统， 但并不是所有的引擎都支持事务。 比如MySQL原生的MyISAM引擎就不支持事务， 这也是MyISAM被InnoDB取代的重要原因之一。</p><p><strong>隔离性与隔离级别</strong></p><p>提到事务，脑海里肯定有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。这里重点说隔离性。</p><p>当数据库上有多个事务同时执行的时候， 就可能出现脏读（dirtyread） 、 不可重复读（non repeatable read） 、 幻读（ phantom read） 的问题， 为了解决这些问题， 就有了“隔离级别”的概念。SQL标准的事务隔离级别包括： 读未提交（ read uncommitted） 、读提交（read committed） 、 可重复读（ repeatable read） 和串行化（ serializable ） 。</p><ul><li>读未提交是指， 一个事务还没提交时， 它做的变更就能被别的事务看到。</li><li>读提交是指， 一个事务提交之后， 它做的变更才会被其他事务看到。<br>可重复读是指， 一个事务执行过程中看到的数据， 总是跟这个事务在启动时看到的数据是一致的。 当然在可重复读隔离级别下， 未提交变更对其他事务也是不可见的。</li><li>串行化， 顾名思义是对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。 当出现读写锁冲突的时候， 后访问的事务必须等前一个事务执行完成， 才能继续执行。</li></ul><p>假设数据表T中只有一列， 其中一行的值为1， 下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421191725626.png" alt="image-20240421191725626"></p><ul><li>若隔离级别是“读未提交”， 则V1的值就是2。 这时候事务B虽然还没有提交， 但是结果已经被A看到了。 因此， V2、 V3也都是2。</li><li>若隔离级别是“读提交”， 则V1是1， V2的值是2。 事务B的更新在提交后才能被A看到。 所以，V3的值也是2。</li><li>若隔离级别是“可重复读”， 则V1、 V2是1， V3是2。 之所以V2还是1， 遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”， 则在事务B执行“将1改成2”的时候， 会被锁住。 直到事务A提交后，事务B才可以继续执行。 所以从A的角度看， V1、 V2值是1， V3的值是2。</li></ul><p>在实现上， 数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。 </p><ul><li>在“可重复读”隔离级别下， 这个视图是在事务启动时创建的， 整个事务存在期间都用这个视图。 </li><li>在“读提交”隔离级别下， 这个视图是在每个SQL语句开始执行的时候创建的。 这里需要注意的是， </li><li>“读未提交”隔离级别下直接返回记录上的最新值， 没有视图概念。</li><li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ul><p>Note：Oracle数据库的默认隔离级别是“读提交”，MySQL数据库的默认隔离级别是可重复读。因此，从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要将MySQL的隔离级别设置为“读提交”。</p><p><strong>事务隔离的实现</strong></p><p>可重复读 ：在MySQL中， 实际上每条记录在更新的时候都会同时记录一条回滚操作。 记录上的最新值， 通过回滚操作， 都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、 3、 4， 在回滚日志里面就会有类似下面的记录。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192045780.png" alt="image-20240421192045780"></p><p><strong>为什么建议你尽量不要使用长事务</strong></p><ul><li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li><li>长事务还占用锁资源，也可能拖垮整个库。</li></ul><p><strong>事务的启动方式</strong></p><ol><li><p>显式启动事务语句， begin 或 start transaction。 配套的提交语句是commit， 回滚语句是rollback。</p></li><li><p>set autocommit=0， 这个命令会将这个线程的自动提交关掉。 意味着如果你只执行一个select语句， 这个事务就启动了， 而且并不会自动提交。 这个事务持续存在直到你主动执行commit 或 rollback 语句， 或者断开连接。因此，建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p></li></ol><h2 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 | 深入浅出索引（上）"></a><strong>04 | 深入浅出索引（上）</strong></h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjg4OTcyNA==&amp;mid=2247484419&amp;idx=1&amp;sn=534c25b454a48d182849c551e4e063d0&amp;chksm=e8d1b710dfa63e06a7d807c873ee6ce432e2c1b48b82560ccd14ea2ab3e22a2eb26df73ca410&amp;cur_album_id=2138177096085471232&amp;scene=189#wechat_redirect">MySQL索引经典15问！</a></li></ul><p>索引的出现其实就是为了提高数据查询的效率， 就像书的目录一样。</p><p><strong>索引的常见模型</strong></p><p>哈希表、 有序数组和搜索树。</p><p><strong>哈希表</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192109123.png" alt="image-20240421192109123"></p><p>哈希表这种结构适用于只有等值查询的场景。</p><p><strong>有序数组</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192116542.png" alt="image-20240421192116542"></p><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。但是有序数组索引只适用于静态存储引擎。</p><p><strong>搜索树</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192123739.png" alt="image-20240421192123739"></p><p><strong>InnoDB的索引模型</strong></p><p>InnoDB中， 表都是根据主键顺序以索引的形式存放的， 这种存储方式的表称为索引组织表。又因为前面我们提到的， InnoDB使用了B+树索引模型， 所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。<br>假设， 我们有一个主键列为ID的表， 表中有字段k， 并且在k上有索引。<br>这个表的建表语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k))engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、 (200,2)、 (300,3)、 (500,5)和(600,6)， 两棵树的示例示意图如下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192319244.png" alt="image-20240421192319244"></p><p>从图中不难看出， 根据叶子节点的内容， 索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。 在InnoDB里， 主键索引也被称为聚簇索引（clustered index） 。非主键索引的叶子节点内容是主键的值。 在InnoDB里， 非主键索引也被称为二级索引（secondaryindex）。</p><p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p><p>如果语句是select * from Twhere ID=500， 即主键查询方式， 则只需要搜索ID这棵B+树；</p><p>如果语句是select * from Twhere k=5， 即普通索引查询方式， 则需要先搜索k索引树， 得到ID的值为500， 再到ID索引树搜索一次。 这个过程称为回表。</p><p><strong>索引维护</strong></p><p>主要是由于页分裂和合并。</p><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>自增主键的插入数据模式，符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。</p><p><strong>如何避免长事务对业务的影响</strong> <strong>？</strong></p><p>首先， 从应用开发端来看：</p><ol><li>确认是否使用了set autocommit=0。 这个确认工作可以在测试环境中开展， 把MySQL的general_log开起来， 然后随便跑一个业务逻辑， 通过general_log的日志来确认。 一般框架如果会设置这个值， 也就会提供参数来控制行为， 你的目标就是把它改成1。</li><li>确认是否有不必要的只读事务。 有些框架会习惯不管什么语句先用begin/commit框起来。 我见过有些是业务并没有这个需要， 但是也把好几个select语句放到了事务中。 这种只读事务可以去掉。</li><li>业务连接数据库的时候， 根据业务本身的预估， 通过SETMAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间， 避免单个语句意外执行太长时间。 （为什么会意外？ 在后续的文章中会提到这类案例）</li></ol><p><strong>其次，</strong> <strong>从数据库端来看</strong></p><ol><li>监控 information_schema.Innodb_trx表， 设置长事务阈值， 超过就报警/或者kill；</li><li>Percona的pt-kill这个工具不错， 推荐使用；</li><li>在业务功能测试阶段要求输出所有的general_log， 分析日志行为提前发现问题；</li><li>如果使用的是MySQL 5.6或者更新版本， 把innodb_undo_tablespaces设置成2（或更大的值） 。 如果真的出现大事务导致回滚段过大， 这样设置后清理起来更方便。</li></ol><h2 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 | 深入浅出索引（下）"></a><strong>05 | 深入浅出索引（下）</strong></h2><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Twhere k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>需要执行几次树的搜索操作，会扫描多少行？</p><p>表的初始化语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192628068.png" alt="image-20240421192628068"></p><p>我们一起来看看这条SQL查询语句的执行流程：</p><ol><li>在k索引树上找到k=3的记录，取得 ID = 300；</li><li>再到ID索引树查到ID=300对应的R3；</li><li>在k索引树取下一个值k=5，取得ID=500；</li><li>再回到ID索引树查到ID=500对应的R4；</li><li>在k索引树取下一个值k=6，不满足条件，循环结束。</li></ol><p>回到主键索引树搜索的过程， 我们称为回表。</p><p><strong>覆盖索引</strong></p><p>由于覆盖索引可以减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段。</p><p><strong>最左前缀原则</strong></p><p>如果为每一种查询都设计一个索引， 索引是不是太多了。B+树这种索引结构， 可以利用索引的“最左前缀”， 来定位记录。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192809647.png" alt="image-20240421192809647"></p><p>可以看到， 索引项是按照索引定义里面出现的字段顺序排序的。</p><p><strong>索引下推</strong></p><p>什么是索引下推？拿到索引之后根据where条件看看能不能再进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在MySQL 5.6之前， 只能从ID3开始一个个回表。 到主键索引上找出数据行， 再对比字段值。<br>而MySQL 5.6 引入的索引下推优化（indexcondition pushdown)， 可以在索引遍历过程中， 对索引中包含的字段先做判断， 直接过滤掉不满足条件的记录， 减少回表次数。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192816713.png" alt="image-20240421192816713"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192822945.png" alt="image-20240421192822945"></p><p>区别是， InnoDB在(name,age)索引内部就判断了age是否等于10， 对于不等于10的记录， 直接判断并跳过。 在我们的这个例子中， 只需要对ID4、 ID5这两条记录回表取数据判断， 就只需要回表2次。</p><h2 id="06-全局锁和表锁-：-给表加个字段怎么有这么多阻碍？"><a href="#06-全局锁和表锁-：-给表加个字段怎么有这么多阻碍？" class="headerlink" title="06 | 全局锁和表锁 ： 给表加个字段怎么有这么多阻碍？"></a><strong>06 | 全局锁和表锁</strong> <strong>：</strong> <strong>给表加个字段怎么有这么多阻碍？</strong></h2><p>数据库锁设计的初衷是处理并发问题。</p><p>根据加锁的范围， MySQL里面的锁大致可以分成全局锁、 表级锁和行锁三类。</p><p><strong>全局锁</strong></p><p>当你需要让整个库处于只读状态的时候， 可以使用这个命令， 之后其他线程的以下语句会被阻塞： 数据更新语句（数据的增删改） 、 数据定义语句（包括建表、 修改表结构等） 和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是， 做全库逻辑备份。</strong></p><p>但是让整库都只读， 听上去就很危险：<br>如果你在主库上备份， 那么在备份期间都不能执行更新， 业务基本上就得停摆；<br>如果你在从库上备份， 那么备份期间从库不能执行主库同步过来的binlog， 会导致主从延迟 。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421192903605.png" alt="image-20240421192903605"></p><p>这个备份结果里， 用户A的数据状态是“账户余额没扣， 但是用户课程表里面已经多了一门课”。 如果后面用这个备份来恢复数据的话， 用户A就发现， 自己赚了。但是，如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果【狗头】。</p><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p><strong>表级锁</strong></p><p>MySQL里面表级别的锁有两种： 一种是表锁， 一种是元数据锁（meta data lock， MDL) 。</p><p>表锁的语法是 lock tables …read/write。举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句， 则其他线程写t1、 读写t2的语句都会被阻塞。 同时， 线程A在执行unlock tables之前， 也只能执行读t1、 读写t2的操作。 连写t1都不允许， 自然也不能访问其他表。</p><p>另一类表级的锁是MDL（ metadata lock)。 MDL不需要显式使用， 在访问一个表的时候会被自动加上。 MDL的作用是， 保证读写的正确性。 你可以想象一下， 如果一个查询正在遍历一个表中的数据， 而执行期间另一个线程对这个表结构做变更， 删了一列， 那么查询线程拿到的结果跟表结构对不上， 肯定是不行的。</p><p>MDL读锁之间不互斥， 因此你可以有多个线程同时对一张表增删改查。</p><p>读写锁之间、 写锁之间是互斥的， 用来保证变更表结构操作的安全性。</p><p>因此， 如果有两个线程要同时给一个表加字段， 其中一个要等另一个执行完才能开始执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421193106335.png" alt="image-20240421193106335"></p><ol><li>session A先启动，对表t加一个MDL读锁。</li><li>由于session B需要的也是MDL读锁。</li><li>session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</li><li>问题来了，之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。等于这个表现在完全不可读写了。</li></ol><p>上面的例子如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p><p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</strong></p><p><strong>pro1:如何安全地给小表加字段？</strong></p><p><strong>solution1:</strong>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><p><strong>pro2:你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p><p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><h2 id="07-行锁功过：-怎么减少行锁对性能的影响？"><a href="#07-行锁功过：-怎么减少行锁对性能的影响？" class="headerlink" title="07 | 行锁功过： 怎么减少行锁对性能的影响？"></a><strong>07 | 行锁功过：</strong> <strong>怎么减少行锁对性能的影响？</strong></h2><p>MySQL的行锁是在引擎层由各个引擎自己实现的。 但并不是所有的引擎都支持行锁。 InnoDB是支持行锁的。MyISAM引擎就不支持行锁。</p><p><strong>从两阶段锁说起</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194317901.png" alt="image-20240421194317901"></p><p>实际上事务B的update语句会被阻塞， 直到事务A执行commit之后， 事务B才能继续执行。 在InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放。 这个就是两阶段锁协议。</p><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p><strong>结论</strong>：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p><strong>死锁和死锁检测</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194324791.png" alt="image-20240421194324791"></p><p>这时候， 事务A在等待事务B释放id=2的行锁， 而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放， 就是进入了死锁状态。</p><p> 当出现死锁以后， 有两种策略：</p><ul><li>一种策略是， 直接进入等待， 直到超时。 这个超时时间可以通过参数innodb_lock_wait_timeout来设置。<ul><li>在InnoDB中，innodb_lock_wait_timeout的默认值是50s。意味着当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。如果我们把这个时间设置成一个很小的值，比如1s，会伤害到普通的锁等待。</li></ul></li><li>另一种策略是， 发起死锁检测， 发现死锁后， 主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 将参数innodb_deadlock_detect设置为on， 表示开启这个逻辑。</li></ul><p>背景：</p><p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？</p><p>问题：</p><p>问题的关键在于死锁检测要耗费大量的CPU资源。</p><p>解决方法：</p><ol><li>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</li><li>控制并发度。比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。</li></ol><h2 id="08-事务到底是隔离的还是不隔离的？"><a href="#08-事务到底是隔离的还是不隔离的？" class="headerlink" title="08 | 事务到底是隔离的还是不隔离的？"></a><strong>08 | 事务到底是隔离的还是不隔离的？</strong></h2><p>这部分主要是MVCC原理，可以到B站上学习下。</p><p>网上看到不错的作图，贴在这里啦~</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194150016.png" alt="image-20240421194150016"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194201861.png" alt="image-20240421194201861"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194212043.png" alt="image-20240421194212043"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194233781.png" alt="image-20240421194233781"></p><p><a href="https://www.processon.com/view/link/65eaae60eaba490be1941ae3">https://www.processon.com/view/link/65eaae60eaba490be1941ae3</a></p><p>好文推荐</p><ul><li><a href="https://mp.weixin.qq.com/s/yyMI3uPvovEr1EgndGro5g">看一遍就懂：MVCC原理详解</a></li></ul><p>如果是可重复读隔离级别， 事务T启动的时候会创建一个视图read-view， 之后事务T执行期间， 即使有其他事务修改了数据， 事务T看到的仍然跟在启动时看到的一样。</p><p>begin/start transaction 命令并不是一个事务的起点， 在执行到它们之后的第一个操作InnoDB表的语句， 事务才真正启动。 如果你想要马上启动一个事务， 可以使用start transaction withconsistent snapshot 这个命令。</p><p>在MySQL里， 有两个“视图”的概念：一个是view。 它是一个用查询语句定义的虚拟表， 在调用的时候执行查询语句并生成结果。创建视图的语法是create view …， 而它的查询方法与表一样。另一个是InnoDB在实现MVCC时用到的一致性读视图， 即consistent read view， 用于支持RC（Read Committed， 读提交） 和RR（ Repeatable Read， 可重复读） 隔离级别的实现。</p><p><strong>“快照”在MVCC里是怎么工作的？</strong></p><p>InnoDB里面每个事务有一个唯一的事务ID， 叫作transaction id。 它是在事务开始的时候向InnoDB的事务系统申请的， 是按申请顺序严格递增的。而每行数据也都是有多个版本的。 每次事务更新数据的时候， 都会生成一个新的数据版本， 并且把transaction id赋值给这个数据版本的事务ID， 记为row trx_id。 同时， 旧的数据版本要保留，并且在新的数据版本中， 能够有信息可以直接拿到它。也就是说， 数据表中的一行记录， 其实可能有多个版本(row)， 每个版本有自己的row trx_id。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194335011.png" alt="image-20240421194335011"></p><p>实际上， 图2中的三个虚线箭头， 就是undo log； 而V1、 V2、 V3并不是物理上真实存在的， 而是每次需要的时候根据当前版本和undo log计算出来的。 比如， 需要V2的时候， 就是通过V4依次执行U3、 U2算出来。</p><p>InnoDB为每个事务构造了一个数组， 用来保存这个事务启动瞬间， 当前正在“活跃”的所有事务ID。 “活跃”指的就是， 启动了但还没提交。</p><p>更新数据都是先读后写的， 而这个读， 只能读当前的值， 称为“当前读”（ current read） 。</p><p>InnoDB的行数据有多个版本， 每个数据版本有自己的row trx_id， 每个事务或者语句有自己的一致性视图。 普通查询语句是一致性读， 一致性读会根据row trx_id和一致性视图确定数据版本的可见性。</p><p>￮ 对于可重复读， 查询只承认在事务启动前就已经提交完成的数据；</p><p>￮ 对于读提交， 查询只承认在语句启动前就已经提交完成的数据；</p><p>￮ 而当前读， 总是读取已经提交完成的最新版本。</p><h2 id="09-普通索引和唯一索引，-应该怎么选择？"><a href="#09-普通索引和唯一索引，-应该怎么选择？" class="headerlink" title="09 | 普通索引和唯一索引， 应该怎么选择？"></a><strong>09 | 普通索引和唯一索引，</strong> <strong>应该怎么选择？</strong></h2><p>从性能的角度考虑， 你选择唯一索引还是普通索引呢？ 选择的依据是什么呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421194340923.png" alt="image-20240421194340923"></p><p><strong>查询过程</strong></p><p>假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p><p>InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p><p>因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p><strong>更新过程</strong></p><p>先介绍一下change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p><p><strong>pro</strong>:什么条件下可以使用change buffer呢？</p><p><strong>ans</strong>：唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p><p>介绍完change buffer,来说说更新过程，分为2个case。</p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p><strong>change buffer使用场景</strong></p><p>先来一个问题：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p><p>心中有个最初的原则：change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。</p><p>有好的场景当然也有不好的场景。</p><p>不好的场景就是假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><p><strong>索引选择和实践</strong></p><p>普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议你尽量选择普通索引</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p><strong>change buffer 和 redo log</strong></p><p>接下来其实主要就是区分redo log和change buffer。</p><p>现在，我们要在表上执行这个插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t(id,k) <span class="keyword">values</span>(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421195152846.png" alt="image-20240421195152846"></p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p>现在要执行 select * from t where k in (k1, k2)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421195257043.png" alt="image-20240421195257043"></p><ol><li>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p><p><strong>来个问题：</strong>如果某次写入使用了change buffer机制，之后主机异常重启，是否会丢失change buffer和数据。</p><p>这个问题的答案是不会丢失。虽然是只更新内存，但是在事务提交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。</p><h2 id="10-MySQL为什么有时候会选错索引？"><a href="#10-MySQL为什么有时候会选错索引？" class="headerlink" title="10 | MySQL为什么有时候会选错索引？"></a><strong>10 | MySQL为什么有时候会选错索引？</strong></h2><p>【优化器工作原理】</p><p>一种方法是， 像我们第一个例子一样， 采用force index强行选择一个索引。</p><p>第二种方法就是， 我们可以考虑修改 语句， 引导MySQL使用我们期望的索引。 比如， 在这个例子里， 显然把“order byb limit 1” 改成 “order byb,a limit 1” ， 语义的逻辑是相同的。</p><p>第三种方法是， 在有些场景下， 我们可以新建一个更合适的索引， 来提供给优化器做选择， 或删掉误用的索引。</p><h2 id="11-怎么给字符串字段加索引？"><a href="#11-怎么给字符串字段加索引？" class="headerlink" title="11 | 怎么给字符串字段加索引？"></a><strong>11 | 怎么给字符串字段加索引？</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>第一个语句创建的index1索引里面， 包含了每个记录的整个字符串； 而第二个语句创建的index2索引里面， 对于每个记录都是只取前6个字节。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421195513438.png" alt="image-20240421195513438"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421195518185.png" alt="image-20240421195518185"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p><ol><li>从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值；</li><li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li><li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’zhangssxyz@xxx.com’的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p><ol><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li><li>到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃；</li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li></ol><p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</p><p>通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p><p><strong>结论：使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p>来个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p><p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>常用方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p><strong>前缀索引对覆盖索引的影响</strong></p><p>先来看看这个SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>与前面例子中的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p><p>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p><strong>使用前缀索引就用不上覆盖索引对查询性能的优化</strong>了， 这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><p><strong>其他方式</strong></p><p>第一种方式是使用倒序存储。</p><p>第二种方式是使用hash字段。</p><p>首先， 它们的相同点是， 都不支持范围查询。 倒序存储的字段上创建的索引是按照倒序字符串的方式排序的， 已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。 同样地， hash字段的方式也只能支持等值查询。</p><p>它们的区别， 主要体现在以下三个方面：</p><ol><li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li><li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</li><li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol><p><strong>总结</strong></p><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li><li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol><h2 id="12-为什么我的MySQL会“抖”一下？"><a href="#12-为什么我的MySQL会“抖”一下？" class="headerlink" title="12 | 为什么我的MySQL会“抖”一下？"></a><strong>12 | 为什么我的MySQL会“抖”一下？</strong></h2><p>【数据库代码】</p><p>当内存数据页跟磁盘数据页内容不一致的时候， 我们称这个内存页为“脏页”。 内存数据写入到磁盘后， 内存和磁盘上的数据页的内容就一致了， 称为“干净页”。</p><p>什么时候flush？</p><p>1：是InnoDB的redo log写满了。 这时候系统会停止所有更新操作， 把:checkpoint往前推进， redo log留出空间可以继续写。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421195941651.png" alt="image-20240421195941651"></p><p>checkpoint可不是随便往前修改一下位置就可以的。 比如图中， 把checkpoint位置从CP推进到CP’， 就需要将两个点之间的日志（浅绿色部分） ， 对应的所有脏页都flush到磁盘上。 之后， 图中从write pos到CP’之间就是可以再写入的redo log的区域。</p><p>2：系统内存不足。 当需要新的内存页， 而内存不够用的时候， 就要淘汰一些数据页， 空出内存给别的数据页使用。 如果淘汰的是“脏页”， 就要先将脏页写到磁盘。</p><p>3：MySQL认为系统“空闲”的时候。</p><p>4：MySQL正常关闭的情况。 这时候， MySQL会把内存的脏页都flush到磁盘上， 这样下次MySQL启动的时候， 就可以直接从磁盘上读数据， 启动速度会很快。</p><p>第一种是“redo log写满了， 要flush脏页”， 这种情况是InnoDB要尽量避免的。 因为出现这种情况的时候， 整个系统就不能再接受更新了， 所有的更新都必须堵住。</p><p>第二种是“内存不够用了， 要先将脏页写到磁盘”， 这种情况其实是常态。InnoDB用缓冲池（ buffer pool） 管理内存， 缓冲池中的内存页有三种状态：第一种是， 还没有使用的；第二种是， 使用了并且是干净页；第三种是， 使用了并且是脏页。</p><p>InnoDB的刷盘速度就是要参考这两个因素： 一个是脏页比例， 一个是redo log写盘速度。 InnoDB会根据这两个因素先单独算出两个数字。</p><p>InnoDB每次写入的日志都有一个序号， 当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。 InnoDB会根据这个N算出一个范围在0到100之间的数字， 这个计算公式可以记为F2(N)。 F2(N)算法比较复杂， 你只要知道N越大， 算出来的值越大就好了。然后， 根据上述算得的F1(M)和F2(N)两个值， 取其中较大的值记为R， 之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421195954851.png" alt="image-20240421195954851"></p><p>现在你知道了， InnoDB会在后台刷脏页， 而刷脏页的过程是要将内存页写入磁盘。 所以， 无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页， 还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句</p><p>而MySQL中的一个机制， 可能让你的查询会更慢： 在准备刷一个脏页的时候， 如果这个数据页旁边的数据页刚好是脏页， 就会把这个“邻居”也带着一起刷掉； 而且这个把“邻居”拖下水的逻辑还可以继续蔓延， 也就是对于每个邻居数据页， 如果跟它相邻的数据页也还是脏页的话， 也会被放到一起刷</p><h2 id="13-为什么表数据删掉一半，-表文件大小不变？"><a href="#13-为什么表数据删掉一半，-表文件大小不变？" class="headerlink" title="13 | 为什么表数据删掉一半， 表文件大小不变？"></a><strong>13 | 为什么表数据删掉一半，</strong> <strong>表文件大小不变？</strong></h2><p>【B+树代码】</p><p>InnoDB引擎只会把R4这个记录标记为删除。 如果之后要再插入一个ID在300和600之间的记录时， 可能会复用这个位置。 但是， 磁盘文件的大小并不会缩小。</p><p>delete命令其实只是把记录的位置， 或者数据页标记为了“可复用”， 但磁盘文件的大小是不会变的。 也就是说， 通过delete命令是不能回收表空间的。 这些可以复用， 而没有被使用的空间， 看起来就像是“空洞”。</p><p>不止是删除数据会造成空洞， 插入数据也会。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200036775.png" alt="image-20240421200036775"></p><p>page A满了， 再插入一个ID是550的数据时， 就不得不再申请一个新的页面page B来保存数据了。 页分裂完成后， page A的末尾就留下了空洞（注意： 实际上， 可能不止1个记录的位置是空洞） 。</p><p><strong>重建表</strong></p><p>你可以新建一个与表A结构相同的表B， 然后按照主键ID递增的顺序， 把数据一行一行地从表A里读出来再插入到表B中。由于表B是新建的表， 所以表A主键索引上的空洞， 在表B中就都不存在了。 显然地， 表B的主键索引更紧凑， 数据页的利用率也更高。 如果我们把表B作为临时表， 数据从表A导入表B的操作完成后， 用表B替换A，从效果上看， 就起到了收缩表A空间的作用。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200044232.png" alt="image-20240421200044232"></p><p>引入了Online DDL之后， 重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200108974.png" alt="image-20240421200108974"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200122892.png" alt="image-20240421200122892"></p><h2 id="14-count-这么慢，-我该怎么办？"><a href="#14-count-这么慢，-我该怎么办？" class="headerlink" title="14 | count(*)这么慢， 我该怎么办？"></a><strong>14 | count(*)这么慢，</strong> <strong>我该怎么办？</strong></h2><p>【不同引擎工作以及常见count】</p><p><strong>count(*)的实现方式</strong></p><p>在不同的MySQL引擎中， count( * )有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上， 因此执行count( * )的时候会直接返回这个数，效率很高</li><li>InnoDB引擎就麻烦了， 它执行count(*)的时候， 需要把数据一行一行地从引擎里面读出来， 然后累积计数</li></ul><p>那为什么InnoDB不跟MyISAM一样， 也把数字存起来呢？ <strong>这是因为即使是在同一个时刻的多个查询， 由于多版本并发控制（MVCC） 的原因</strong>， InnoDB表“应该返回多少行”也是不确定的。 这里， 我用一个算count(*)的例子来为你解释一下。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200223518.png" alt="image-20240421200223518"></p><p>这和InnoDB的事务设计有关系， 可重复读是它默认的隔离级别， 在代码上就是通过多版本并发控制， 也就是MVCC来实现的。 每一行记录都要判断自己是否对这个会话可见， 因此对于count(*)请求来说， InnoDB只好把数据一行一行地读出依次判断， 可见的行才能够用于计算“基于这个查询”的表的总行数。</p><p><strong>不同的count用法</strong></p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p><p><strong>结论是</strong>：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(<em>)，所以我建议你，尽量使用count(</em>)。</p><h2 id="15-答疑文章（一）-：-日志和索引相关问题"><a href="#15-答疑文章（一）-：-日志和索引相关问题" class="headerlink" title="15 | 答疑文章（一） ： 日志和索引相关问题"></a><strong>15 | 答疑文章（一）</strong> <strong>：</strong> <strong>日志和索引相关问题</strong></h2><p>这个部分好好看看平台文章。</p><p><strong>日志相关问题</strong></p><p><strong>在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200445846.png" alt="image-20240421200445846"></p><p>崩溃恢复时的判断规则。</p><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><p><strong>MySQL怎么知道binlog是完整的?</strong></p><p>回答：一个事务的binlog是有完整格式的：</p><ul><li>statement格式的binlog，最后会有COMMIT；</li><li>row格式的binlog，最后会有一个XID event。</li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><p><strong>redo log 和 binlog是怎么关联起来的?</strong></p><p>回答： 它们有一个共同的数据字段， 叫XID。 崩溃恢复的时候， 会按顺序扫描redo log：<br>如果碰到既有prepare、 又有commit的redo log， 就直接提交；<br>如果碰到只有parepare、 而没有commit的redo log， 就拿着XID去binlog找对应的事务。</p><p><strong>redo log一般设置多大？</strong></p><p>redo log太小的话， 会导致很快就被写满， 然后不得不强行刷redo log， 这样WAL机制的能力就发挥不出来了。所以， 如果是现在常见的几个TB的磁盘的话， 就不要太小气了， 直接将redo log设置为4个文件、 每个文件1GB吧。</p><p><strong>redo log buffer是什么？是先修改内存，还是先写redo log文件？</strong></p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><h2 id="16-“order-by”是怎么工作的？"><a href="#16-“order-by”是怎么工作的？" class="headerlink" title="16 | “order by”是怎么工作的？"></a><strong>16 | “order by”是怎么工作的？</strong></h2><p>【流程及其优化】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure><p><strong>全字段排序</strong></p><p>为避免全表扫描， 我们需要在city字段加上索引。在city字段上创建索引之后， 我们用explain命令来看看这个语句的执行情况。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200729385.png" alt="image-20240421200729385"></p><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200739061.png" alt="image-20240421200739061"></p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421200817067.png" alt="image-20240421200817067"></p><p><strong>这里，我们要熟悉OPTIMIZER_TRACE命，explain以及慢查询查看结果。</strong></p><p><strong>rowid排序</strong></p><p>新的算法放入sort_buffer的字段， 只有要排序的列（ 即name字段） 和主键id。但这时， 排序的结果就因为少了city和age字段的值， 不能直接返回了， 整个执行流程就变成如<br>下所示的样子：</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city=’杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201012251.png" alt="image-20240421201012251"></p><p><strong>全字段排序 VS rowid排序</strong></p><p>使用索引优化从而优化排序。</p><h2 id="17-如何正确地显示随机消息？"><a href="#17-如何正确地显示随机消息？" class="headerlink" title="17 | 如何正确地显示随机消息？"></a><strong>17 | 如何正确地显示随机消息？</strong></h2><p>【学习SQL执行过程】</p><p><strong>背景</strong></p><p>这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。</p><p><strong>内存临时表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个语句的意思很直白，随机排序取前3个。使用explain命令来看看这个语句的执行情况。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201253209.png" alt="image-20240421201253209"></p><p>对于内存表， 回表过程只是简单地根据数据行的位置， 直接访问内存得到数据， 根本不会导致多访问磁盘。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: <span class="number">0.900376</span>  Lock_time: <span class="number">0.000347</span> Rows_sent: <span class="number">3</span> Rows_examined: <span class="number">20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201352186.png" alt="image-20240421201352186"></p><p><strong>总结：order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><p>MySQL的表是用什么方法来定位“一行数据”的。 如果你创建的表没有主键， 或者把一个表的主键删掉了， 那么InnoDB会自己生成一个长度为6字节的rowid来作为主键</p><h2 id="18-为什么这些SQL语句逻辑相同，-性能却差异巨大？"><a href="#18-为什么这些SQL语句逻辑相同，-性能却差异巨大？" class="headerlink" title="18 | 为什么这些SQL语句逻辑相同， 性能却差异巨大？"></a><strong>18 | 为什么这些SQL语句逻辑相同，</strong> <strong>性能却差异巨大？</strong></h2><p>【索引失效】</p><p>案例一： 条件字段函数操作</p><p>对索引字段做函数操作， 可能会破坏索引值的有序性， 因此优化器就决定放弃走树搜索功能。</p><p>案例二： 隐式类型转换</p><p>数据类型转换的规则是什么？<br>为什么有数据类型转换， 就需要走全索引扫描？</p><p>在MySQL中， 字符串和数字做比较的话， 是将字符串转换成数字</p><p>案例三： 隐式字符编码转换</p><p>其实是在说同一件事儿， 即： 对索引字段做函数操作， 可能会破坏索引值的有序性， 因此优化器就决定放弃走树搜索功能。</p><h2 id="19-为什么我只查一行的语句，-也执行这么慢？"><a href="#19-为什么我只查一行的语句，-也执行这么慢？" class="headerlink" title="19 | 为什么我只查一行的语句， 也执行这么慢？"></a><strong>19 | 为什么我只查一行的语句，</strong> <strong>也执行这么慢？</strong></h2><p>【锁住了or长事务】</p><p>套路：分析问题，验证问题，解决问题。</p><p>有些情况下， “查一行”， 也会执行得特别慢。</p><p><strong>第一类：</strong> <strong>查询长时间不返回</strong></p><p>如图1所示， 在表t执行下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询结果长时间不返回。一般碰到这种情况的话， 大概率是表t被锁住了。</p><p>接下来分析原因的时候， 一般都是首先执行一下show processlist命令， 看看当前语句处于什么状态。然后我们再针对每种状态， 去分析它们产生的原因、 如何复现， 以及如何处理。</p><p><strong>等MDL锁</strong></p><p>使用show processlist命令查看Waiting for table metadata lock。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201745437.png" alt="image-20240421201745437"></p><p>出现这个状态表示的是， 现在有一个线程正在表t上请求或者持有MDL写锁， 把select语句堵住了。</p><p>解决方法：就是找到谁持有MDL写锁，然后把它kill掉。</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201712264.png" alt="image-20240421201712264"></p><p><strong>等flush</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201753947.png" alt="image-20240421201753947"></p><p>使用show processlist排查。</p><p><strong>等行锁</strong></p><p>现在， 经过了表级锁的考验， 我们的select 语句终于来到引擎里了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201839042.png" alt="image-20240421201839042"></p><p>解决方法：</p><p>通过sys.innodb_lock_waits 表查出是谁占着这个写锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>`<span class="string">&#x27;test&#x27;</span>.<span class="string">&#x27;t&#x27;</span>`\G</span><br></pre></td></tr></table></figure><p>然后直接断开这个连接。</p><p><strong>第二类：</strong> <strong>查询慢</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>虽然扫描行数是1， 但执行时间却长达800毫秒。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202203454.png" alt="image-20240421202203454"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode</span><br></pre></td></tr></table></figure><p> 执行时扫描行数也是1行， 执行时间是0.2毫秒。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202228245.png" alt="image-20240421202228245"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202237859.png" alt="image-20240421202237859"></p><p>先猜测下，再往下看。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202245363.png" alt="image-20240421202245363"></p><p>session A先用start transaction with consistent snapshot命令启动了一个事务， 之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后， id=1这一行处于什么状态呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202312908.png" alt="image-20240421202312908"></p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><h2 id="20-幻读是什么，-幻读有什么问题？"><a href="#20-幻读是什么，-幻读有什么问题？" class="headerlink" title="20 | 幻读是什么， 幻读有什么问题？"></a><strong>20 | 幻读是什么，</strong> <strong>幻读有什么问题？</strong></h2><p>【是什么？会出现什么问题？数据库又是怎么解决的？】</p><p>前提：可重复读隔离级别下的，间隙锁才会发生。</p><p><strong>幻读是什么？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p><p>现在，我们就来分析一下，如果只在id=5这一行加锁，而其他行的不加锁的话，会怎么样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202441948.png" alt="image-20240421202441948"></p><p>可以看到， session A里执行了三次查询， 分别是Q1、 Q2和Q3。 它们的SQL语句相同， 都是select * from t where d=5 for update。 查所有d=5的行， 而且使用的是当前读， 并且加上写锁。</p><ol><li>Q1只返回id=5这一行；</li><li>在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行；</li><li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行。</li></ol><p>其中， Q3读到id=1这一行的现象， 被称为“幻读”。 </p><p><strong>幻读指的是一个事务在前后两次查询同一个范围的时候， 后一次查询看到了前一次查询没有看到的行。</strong></p><p><strong>说明</strong></p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li><li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。<strong>幻读仅专指“新插入的行”。</strong></li></ol><p><strong>幻读有什么问题？</strong></p><p>会导致数据不一致问题。</p><p>下面这个例子非常好。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202546044.png" alt="image-20240421202546044"></p><p>分析一下上图</p><ol><li>经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li><li>经过T2时刻，id=0这一行变成(0,5,5);</li><li>经过T4时刻，表里面多了一行(1,5,5);</li><li>其他行跟这个执行序列无关，保持不变。</li></ol><p>这些数据也没啥问题，但是我们来看看binlog里面的内容。</p><ol><li>T2时刻，session B事务提交，写入了两条语句；</li><li>T4时刻，session C事务提交，写入了两条语句；</li><li>T6时刻，session A事务提交，写入了update t set d=100 where d=5 这条语句。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure><p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。</p><p>也就是说，id=0和id=1这两行，发生了数据不一致。这个问题很严重，是不行的。</p><p><strong>如何解决幻读？</strong></p><p>行锁只能锁住行， 但是新插入记录这个动作， 要更新的是记录之间的“间隙”。 因此， 为了解决幻读问题， InnoDB只好引入新的锁， 也就是间隙锁(Gap Lock)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202915584.png" alt="image-20240421202915584"></p><p>解决办法：执行 select * from t where d=5 for update的时候， 就不止是给数据库中已有的6个记录加上了行锁， 还同时加了7个间隙锁。 这样就确保了无法再插入新的记录。也就是说这时候， 在一行行扫描的过程中， 不仅将给行加上了行锁， 还给行两边的空隙， 也加上了间隙锁。</p><p><strong>跟间隙锁存在冲突关系的， 是“往这个间隙中插入一个记录”这个操作。 间隙锁之间都不存在冲突关系</strong>。</p><p>间隙锁和行锁合称next-keylock， 每个next-keylock是前开后闭区间。 也就是说， 我们的表t初始化以后， 如果用select * from t for update要把整个表所有记录锁起来， 就形成了7个next-key lock， 分别是 (-∞,0]、 (0,5]、 (5,10]、 (10,15]、 (15,20]、 (20, 25]、 (25, +supremum]。</p><p>但是可能会有死锁的情况发生。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203059813.png" alt="image-20240421203059813"></p><p>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p><ol><li>session A 执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);</li><li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li><li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li></ol><p>至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p><p>最后，这节分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这也是现在不少公司使用的配置组合。</p><h2 id="21-为什么我只改一行的语句，-锁这么多？"><a href="#21-为什么我只改一行的语句，-锁这么多？" class="headerlink" title="21 | 为什么我只改一行的语句， 锁这么多？"></a><strong>21 | 为什么我只改一行的语句，</strong> <strong>锁这么多？</strong></h2><p>【重点】</p><p><strong>以下默认是可重复读隔离级别。</strong></p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>该节有许多经典案例，回到平台文章细看，就不再这里一一列举。</p><h2 id="22-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#22-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22 | MySQL有哪些“饮鸩止渴”提高性能的方法？"></a><strong>22 | MySQL有哪些“饮鸩止渴”提高性能的方法？</strong></h2><p>第一种方法： 先处理掉那些占着连接但是不工作的线程。</p><p>第二种方法： 减少连接过程的消耗。</p><p><strong>慢查询性能问题</strong></p><p>导致慢查询的第一种可能是， 索引没有设计好。</p><p>导致慢查询的第二种可能是， 语句没写好。</p><p><strong>QPS突增问题</strong></p><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li></ol><h2 id="23-MySQL是怎么保证数据不丢的？"><a href="#23-MySQL是怎么保证数据不丢的？" class="headerlink" title="23 | MySQL是怎么保证数据不丢的？"></a><strong>23 | MySQL是怎么保证数据不丢的？</strong></h2><p>【日志】</p><p>只要redo log和binlog保证持久化到磁盘， 就能确保MySQL异常重启后， 数据可以恢复。</p><p><strong>binlog的写入机制</strong></p><p>事务执行过程中， 先把日志写到binlog cache， 事务提交的时候， 再把binlog cache写到binlog文件中。 </p><p>一个事务的binlog是不能被拆开的， 因此不论这个事务多大， 也要确保一次性写入。</p><p>系统给binlog cache分配了一片内存， 每个线程一个， 参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。 如果超过了这个参数规定的大小， 就要暂存到磁盘。事务提交的时候， 执行器把binlog cache里的完整事务写入到binlog中， 并清空binlog cache。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203459314.png" alt="image-20240421203459314"></p><p><strong>每个线程有自己binlog cache， 但是共用同一份binlog文件。</strong></p><p>图中的write， 指的就是指把日志写入到文件系统的page cache， 并没有把数据持久化到磁盘， 所以速度比较快。</p><p>图中的fsync， 才是将数据持久化到磁盘的操作。 一般情况下， 我们认为fsync才占磁盘的IOPS。</p><p><strong>redo log的写入机制</strong></p><p>事务在执行过程中， 生成的redolog是要先写到redo log buffer的。 redo log buffer里面的内容， 是不是每次生成后都要直接持久化到磁盘呢？答案是， 不需要。如果事务执行期间MySQL发生异常重启， 那这部分日志就丢了。 由于事务并没有提交， 所以这时日志丢了也不会有损失。事务还没提交的时候， redo log buffer中的部分日志有没有可能被持久化到磁盘呢？答案是， 确实会有。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203632190.png" alt="image-20240421203632190"></p><p>这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的， wirte到page cache也差不多， 但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ul><li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong></li><li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong></li></ul><p>如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p><p><strong>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</strong></p><p>其实到这里，我的理解是本质就是2次刷盘磁盘，但是加了buffer进行优化，提高效率。</p><p><strong>组提交</strong></p><p>三个并发事务(trx1, trx2, trx3)在prepare 阶段， 都写完redo log buffer， 持久化到磁盘的过程， 对应的LSN分别是50、 120 和160。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203939757.png" alt="image-20240421203939757"></p><p>从图中可以看到，</p><ol><li>trx1是第一个到达的，会被选为这组的 leader；</li><li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</li><li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。</p><p>WAL机制主要得益于两个方面：</p><ol><li>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</li><li>组提交机制，可以大幅度降低磁盘的IOPS消耗。【磁盘IOPS：磁盘IOPS是指一秒内磁盘进行多少次I/O读写；】</li></ol><p><strong>如果你的MySQL现在出现了性能瓶颈，</strong> <strong>而且瓶颈在IO上，</strong> <strong>可以通过哪些方法来提升性能呢？</strong></p><ol><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。</li></ol><h2 id="24-MySQL是怎么保证主备一致的？"><a href="#24-MySQL是怎么保证主备一致的？" class="headerlink" title="24 | MySQL是怎么保证主备一致的？"></a><strong>24 | MySQL是怎么保证主备一致的？</strong></h2><p>【日志】</p><p>binlog对主备一致贡献非常的大。</p><p><strong>MySQL主备的基本原理</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204119341.png" alt="image-20240421204119341"></p><p>节点A到B这条线的内部流程是什么样的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204125172.png" alt="image-20240421204125172"></p><p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。</p><p>备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li><li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li><li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li></ol><p><strong>binlog的三种格式</strong></p><p>当binlog_format=statement时， binlog里面记录的就是SQL语句的原文。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204210641.png" alt="image-20240421204210641"></p><p>把binlog的格式改为binlog_format=‘row’</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204223526.png" alt="image-20240421204223526"></p><p>row格式的binlog里没有了SQL语句的原文， 而是替换成了两个event： Table_map和Delete_rows</p><p><strong>为什么会有mixed这种binlog格式的存在场景？</strong></p><ul><li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。</li><li>但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li><li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。<strong>mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</strong></li></ul><p><strong>循环复制问题</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204300198.png" alt="image-20240421204300198"></p><p>双M结构和M-S结构， 其实区别只是多了一条线， 即： 节点A和B之间总是互为主备关系。 这样在切换的时候就不用再修改主备关系。</p><p>业务逻辑在节点A上更新了一条语句， 然后再把生成的binlog 发给节点B， 节点B执行完这条更新语句后也会生成binlog。如果节点A同时是节点B的备库， 相当于又把节点B新生成的binlog拿过来执行了一次， 然后节点A和B间， 会不断地循环执行这个更新语句， 也就是循环复制了。 这个要怎么解决呢？</p><p>MySQL在binlog中记录了这个命令第一次执行时所在实例的serverid。 因此， 我们可以用下面的逻辑， 来解决两个节点间的循环复制的问题：</p><ol><li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li><li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol><h2 id="25-MySQL是怎么保证高可用的？"><a href="#25-MySQL是怎么保证高可用的？" class="headerlink" title="25 | MySQL是怎么保证高可用的？"></a><strong>25 | MySQL是怎么保证高可用的？</strong></h2><p>【就是主备低延时】</p><p>正常情况下， 只要主库执行更新生成的所有binlog， 都可以传到备库并被正确地执行， 备库就能达到跟主库一致的状态， 这就是最终一致性。</p><p><strong>主备延迟</strong></p><p>主备切换可能是一个主动运维动作， 比如软件升级、 主库所在机器按计划下线等， 也可能是被动操作， 比如主库所在机器掉电。</p><p>与数据同步有关的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟， 就是同一个事务， 在备库执行完成的时间和主库执行完成的时间之间的差值， 也就是T3-T1。</p><p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><p><strong>seconds_behind_master</strong>的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p><p><strong>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。</strong></p><p>下面来说说常见的例子。</p><p><strong>主备延迟的来源</strong></p><ol><li><p>备库所在机器的性能要比主库所在的机器性能差。</p></li><li><p>备库的压力大：备库上的查询耗费了大量的CPU资源， 影响了同步速度， 造成主备延迟</p></li></ol><ul><li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ul><ol><li>大事务</li></ol><p><strong>可靠性优先策略</strong></p><p>双M结构下， 从状态1到状态2切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程， 一般是由专门的HA系统来完成的， 我们暂时称之为可靠性优先流程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204637780.png" alt="image-20240421204637780"></p><p><strong>可用性优先策略</strong></p><p>强行把步骤4、 5调整到最开始执行， 也就是说不等主备数据同步， 直接把连接切到备库B， 并且让备库B可以读写， 那么系统几乎就没有不可用时间了。我们把这个切换流程， 暂时称作<strong>可用性优先</strong>流程。 这个切换流程的代价， 就是可能出现数据不一致的情况。</p><p><strong>可用性优先策略，且binlog_format=mixed</strong>时的切换流程和数据结果。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204731138.png" alt="image-20240421204731138"></p><p>现在，我们一起分析下这个切换流程：</p><ol><li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li><li>步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</li><li>步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li><li>步骤5中，备库B执行“插入c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c=5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li></ol><p>最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p><p><strong>可用性优先策略，但设置binlog_format=row</strong>时的切换流程和数据结果。</p><p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204815379.png" alt="image-20240421204815379"></p><p>结论：</p><ol><li>使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li><li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li></ol><p>MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p><h2 id="26-备库为什么会延迟好几个小时？"><a href="#26-备库为什么会延迟好几个小时？" class="headerlink" title="26 | 备库为什么会延迟好几个小时？"></a><strong>26 | 备库为什么会延迟好几个小时？</strong></h2><p>【中转日志消费不够快】</p><p>如果备库执行日志的速度持续低于主库生成日志的速度， 那这个延迟就有可能成了小时级别。 而且对于一个压力持续比较高的主库来说， 备库很可能永远都追不上主库的节奏。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205013154.png" alt="image-20240421205013154"></p><p>coordinator在分发的时候， 需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。 这就要求更新同一行的两个事务， 必须被分发到同一个worker中。</li><li>同一个事务不能被拆开， 必须放到同一个worker中。</li></ol><p><strong>MySQL 5.5版本的并行复制策略</strong></p><p><strong>按表分发策略</strong></p><p>按表分发事务的基本思路是， 如果两个事务更新不同的表， 它们就可以并行。 因为数据是存储在表里的， 所以按表分发， 可以保证两个worker不会更新同一行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205026348.png" alt="image-20240421205026348"></p><p><strong>按行分发策略</strong></p><p>要解决热点表的并行复制问题， 就需要一个按行并行复制的方案。 按行复制的核心思路是： 如果两个事务没有更新相同的行， 它们在备库上可以并行执行。 显然， 这个模式要求binlog格式必须是row。</p><p>相比于按表并行分发策略， 按行并行策略在决定线程分发的时候， 需要消耗更多的计算资源。</p><p><strong>MySQL 5.6版本的并行复制策略</strong></p><p>官方MySQL5.6版本， 支持了并行复制， 只是支持的粒度是按库并行。这个策略的并行效果， 取决于压力模型。 如果在主库上有多个DB， 并且各个DB的压力均衡， 使用这个策略的效果会很好。</p><p><strong>MySQL 5.7的并行复制策略</strong></p><p>MySQL 5.7并行复制策略的思想是：</p><ol><li>同时处于prepare状态的事务， 在备库执行时是可以并行的；</li><li>处于prepare状态的事务， 与处于commit状态的事务之间， 在备库执行时也是可以并行的。</li></ol><p>为什么要有多线程复制呢？ 这是因为单线程复制的能力全面低于多线程复制， 对于更新压力较大的主库， 备库是可能一直追不上主库的。 从现象上看就是， 备库上seconds_behind_master的值越来越大。</p><h2 id="27-主库出问题了，-从库怎么办？"><a href="#27-主库出问题了，-从库怎么办？" class="headerlink" title="27 | 主库出问题了， 从库怎么办？"></a><strong>27 | 主库出问题了，</strong> <strong>从库怎么办？</strong></h2><p>【主备切换，日志从哪开始同步问题】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205036452.png" alt="image-20240421205036452"></p><p>图中， 虚线箭头表示的是主备关系， 也就是A和A’互为主备， 从库B、 C、 D指向的是主库A。一主多从的设置， 一般用于读写分离， 主库负责所有的写入和一部分读， 其他的读请求则由从库分担。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205046203.png" alt="image-20240421205046203"></p><p>相比于一主一备的切换流程， 一主多从结构在切换完成后， A’会成为新的主库， 从库B、 C、 D也要改接到A’。 正是由于多了从库B、 C、 D重新指向的这个过程， 所以主备切换的复杂性也相应增加了。</p><p><strong>基于位点的主备切换</strong></p><p>之所以需要这个，是因为从库要换连接的主库，我认为这个位点是之后备库A‘和从库开始同步的位置。</p><p>一种取同步位点的方法是这样的：</p><ol><li>等待新主库A’把中转日志（relay log）全部同步完成；</li><li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li><li>取原主库A故障的时刻T；</li><li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File --stop-datetime=T --start-datetime=T</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205402957.png" alt="image-20240421205402957"></p><p>当然这个值并不精确。为什么呢？</p><p>你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p><p>那么，这时候系统的状态是这样的：</p><ol><li>在从库B上，由于同步了binlog， R这一行已经存在；</li><li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li><li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li></ol><p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p><p>因此，<strong>我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</strong></p><p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global <span class="attribute">sql_slave_skip_counter</span>=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p><p><strong>另外一种方式是，</strong>通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p><p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p><ul><li>1062错误是插入数据时唯一键冲突；</li><li>1032错误是删除数据时找不到行。</li></ul><p>因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p><p><strong>GTID</strong></p><p>知道GTID的概念这部分就非常好理解了。</p><p><a href="https://www.bilibili.com/video/BV1rr4y1Q7uy?p=11&amp;vd_source=d6efee335659a376be8deb6c0654e9f7">MySQL5.7 集群管理（主从复制、MHA、GTID、PXC）</a></p><ol><li><p>全局事务标识∶ global transaction identifiers。</p></li><li><p>GTID与事务——对应，并且全局唯一ID。</p></li><li><p>一个GTID在一个服务器上只执行一次。</p></li><li><p>MySQL-5.6.5开始支持GTID。</p></li></ol><p>组成：GTID = server_uuid : transaction_id</p><p>binlog和GTID的关系</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205708126.png" alt="image-20240421205708126"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205835872.png" alt="image-20240421205835872"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205853616.png" alt="image-20240421205853616"></p><h2 id="28-读写分离有哪些坑？"><a href="#28-读写分离有哪些坑？" class="headerlink" title="28 | 读写分离有哪些坑？"></a><strong>28 | 读写分离有哪些坑？</strong></h2><p>【从库没有同步到位】</p><p>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。我们称这种读为过期读。</p><p><strong>强制走主库方案</strong></p><p>我们可以将查询请求分为这么两类：</p><ol><li><p>对于必须要拿到最新结果的请求， 强制将其发到主库上。 比如， 在一个交易平台上， 卖家发布商品以后， 马上要返回主页面， 看商品是否发布成功。 那么， 这个请求需要拿到最新的结果， 就必须走主库。</p></li><li><p>对于可以读到旧数据的请求， 才将其发到从库上。 在这个交易平台上， 买家来逛商铺页面，就算晚几秒看到最新发布的商品， 也是可以接受的。 那么， 这类请求就可以走从库。</p></li></ol><p><strong>Sleep 方案</strong></p><p>主库更新后， 读从库之前先sleep一下。</p><p><strong>判断主备无延迟方案</strong></p><p>第一种确保主备无延迟的方法是， 每次从库执行查询请求前， 先判断seconds_behind_master是否已经等于0。 如果还不等于0 ， 那就必须等到这个参数变为0才能执行查询请求 。</p><p>第二种方法， 对比位点确保主备无延迟 。</p><p>第三种方法， 对比GTID集合确保主备无延迟 。</p><p><strong>等主库位点方案</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑如下：</p><ol><li>它是在从库执行的；</li><li>参数file和pos指的是主库上的文件名和位置；</li><li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li></ol><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>使用逻辑：</p><ol><li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行select master_pos_wait(File, Position, 1)；</li><li>如果返回值是&gt;=0的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421210118844.png" alt="image-20240421210118844"></p><p><strong>GTID方案</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">wait_for_executed_gtid_set</span>(<span class="params">gtid_set, <span class="number">1</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>这条命令的逻辑是：</p><ol><li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li><li>超时返回1。</li></ol><p>等GTID的执行流程就变成了：</p><ol><li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421210204444.png" alt="image-20240421210204444"></p><h2 id="29-如何判断一个数据库是不是出问题了？"><a href="#29-如何判断一个数据库是不是出问题了？" class="headerlink" title="29 | 如何判断一个数据库是不是出问题了？"></a><strong>29 | 如何判断一个数据库是不是出问题了？</strong></h2><p>主备切换有两种场景， 一种是主动切换， 一种是被动切换。 而其中被动切换， 往往是因为主库出问题了， 由HA系统发起的。</p><p><strong>select 1判断</strong></p><p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p><p><strong>查表判断</strong></p><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况， 我们需要找一个访问InnoDB的场景。 一般的做法是， 在系统库（mysql库） 里创建一个表， 比如命名为health_check， 里面只放一行数据， 然后定期执行： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check;</span><br></pre></td></tr></table></figure><p>可能出现读没有问题，但是写存在问题，还是排查不够彻底。</p><p><strong>更新判断</strong></p><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure><p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p><p>但是这都是外部提供，我们可以通过使用数据库告诉我们内部的真实情况。</p><p><strong>内部统计</strong></p><p>MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p><h2 id="30-答疑文章（二）-：-用动态的观点看加锁"><a href="#30-答疑文章（二）-：-用动态的观点看加锁" class="headerlink" title="30 | 答疑文章（二） ： 用动态的观点看加锁"></a><strong>30 | 答疑文章（二）</strong> <strong>：</strong> <strong>用动态的观点看加锁</strong></h2><p>原则1： 加锁的基本单位是next-keylock。 希望你还记得， next-keylock是前开后闭区间。<br>原则2： 查找过程中访问到的对象才会加锁。<br>优化1： 索引上的等值查询， 给唯一索引加锁的时候， next-keylock退化为行锁。<br>优化2： 索引上的等值查询， 向右遍历时且最后一个值不满足等值条件的时候， next-keylock退化为间隙锁。<br>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><h2 id="31-误删数据后除了跑路，-还能怎么办？"><a href="#31-误删数据后除了跑路，-还能怎么办？" class="headerlink" title="31 | 误删数据后除了跑路， 还能怎么办？"></a><strong>31 | 误删数据后除了跑路，</strong> <strong>还能怎么办？</strong></h2><p>先对和MySQL相关的误删数据， 做下分类：</p><ol><li>使用delete语句误删数据行；</li><li>使用drop table或者truncate table语句误删数据表；</li><li>使用drop database语句误删数据库；</li><li>使用rm命令误删整个MySQL实例。</li></ol><p>其实主要就是靠数据库记录的日志恢复。</p><p><strong>误删行</strong></p><p>具体恢复数据时， 对单个事务做如下处理：</p><ol><li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li><li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li><li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ol><p><strong>误删库/表</strong></p><p>这种情况下， 要想恢复数据， 就需要使用全量备份， 加增量日志的方式了。 这个方案要求线上有定期的全量备份， 并且实时备份binlog。在这两个条件都具备的情况下， 假如有人中午12点误删了一个库， 恢复数据的流程如下：</p><ol><li><p>取最近一次全量备份， 假设这个库是一天一备， 上次备份是当天0点；</p></li><li><p>用备份恢复出一个临时库；</p></li><li><p>从日志备份里面， 取出凌晨0点之后的日志；</p></li><li><p>把这些日志， 除了误删除数据的语句外， 全部应用到临时库。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211155332.png" alt="image-20240421211155332"></p><p><strong>延迟复制备库</strong></p><p>我们可以考虑<strong>搭建延迟复制的备库。</strong>这个功能是MySQL 5.6版本引入的。</p><p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p><p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p><p><strong>预防误删库/表的方法</strong></p><p>第一条建议是，账号分离。第二条建议是，制定操作规范。</p><p><strong>rm删除数据</strong></p><p>只要不是恶意地把整个集群删除， 而只是删掉了其中某一个节点的数据的话， HA系统就会开始工作， 选出一个新的主库， 从而保证整个集群的正常工作。这时， 你要做的就是在这个节点上把数据恢复回来， 再接入整个集群</p><h2 id="32-为什么还有kill不掉的语句？"><a href="#32-为什么还有kill不掉的语句？" class="headerlink" title="32 | 为什么还有kill不掉的语句？"></a><strong>32 | 为什么还有kill不掉的语句？</strong></h2><p>在MySQL中有两个kill命令： 一个是kill query+线程id， 表示终止这个线程中正在执行的语句； 一个是kill connection +线程id， 这里connection可缺省， 表示断开这个线程的连接， 当然如果这个线程有语句正在执行， 也是要先停止正在执行的语句的。不知道你在使用MySQL的时候， 有没有遇到过这样的现象： 使用了kill命令， 却没能断开这个连接。 再执行show processlist命令， 看到这条语句的Command列显示的是Killed。</p><p>kill并不是马上停止的意思， 而是告诉执行线程说， 这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p><p>MySQL客户端发送请求后， 接收服务端返回结果的方式有两种：</p><ol><li><p>一种是本地缓存， 也就是在本地开一片内存， 先把结果存起来。 如果你用API开发， 对应的就是mysql_store_result 方法。</p></li><li><p>另一种是不缓存， 读一个处理一个。 如果你用API开发， 对应的就是mysql_use_result方法。</p></li></ol><h2 id="33-我查这么多数据，-会不会把数据库内存打爆？"><a href="#33-我查这么多数据，-会不会把数据库内存打爆？" class="headerlink" title="33 | 我查这么多数据， 会不会把数据库内存打爆？"></a><strong>33 | 我查这么多数据，</strong> <strong>会不会把数据库内存打爆？</strong></h2><p>其实这篇文章主要说的是MySQL是边读边发的，但是我认为和DBMS的buffer pool也有关系。</p><p><strong>全表扫描对server层的影响</strong></p><p>InnoDB的数据是保存在主键索引上的， 所以全表扫描实际上是直接扫描表t的主键索引。 这条查询语句由于没有其他的判断条件， 所以查到的每一行都可以直接放到结果集里面， 然后返回给客户端</p><p>实际上， 服务端并不需要保存一个完整的结果集。 取数据和发数据的流程是这样的：</p><ol><li><p>获取一行， 写到net_buffer中。 这块内存的大小是由参数net_buffer_length定义的， 默认是16k。</p></li><li><p>重复获取行， 直到net_buffer写满， 调用网络接口发出去。</p></li><li><p>如果发送成功， 就清空net_buffer， 然后继续取下一行， 并写入net_buffer。</p></li><li><p>如果发送函数返回EAGAIN或WSAEWOULDBLOCK， 就表示本地网络栈（socket send buffer） 写满了， 进入等待。 直到网络栈重新可写， 再继续发送。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211458092.png" alt="image-20240421211458092"></p><p><strong>MySQL是“边读边发的”</strong>，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><p>在show processlist命令中的State列的值一直处于<strong>“Sending to client”</strong>，就表示服务器端的网络栈写满了。</p><p><strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p><strong>Sending data</strong>：它的意思只是“正在执行”。</p><p><strong>全表扫描对InnoDB的影响</strong></p><p>InnoDB内存管理用的是最近最少使用 (Least RecentlyUsed, LRU)算法， 这个算法的核心就是淘汰最久未使用的数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211510369.png" alt="image-20240421211510369"></p><p>InnoDB不能直接使用这个LRU算法。 实际上， InnoDB对LRU算法做了改进。在InnoDB实现上， 按照5:3的比例把整个LRU链表分成了young区域和old区域。 图中LRU_old指向的就是old区域的第一个位置， 是整个链表的5/8处。 也就是说， 靠近链表头部的5/8是young区域， 靠近链表尾部的3/8是old区域。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211516058.png" alt="image-20240421211516058"></p><p>改进后的LRU算法执行流程变成了下面这样。</p><ol><li><p>图7中状态1， 要访问数据页P3， 由于P3在young区域， 因此和优化前的LRU算法一样， 将其移到链表头部， 变成状态2。</p></li><li><p>之后要访问一个新的不存在于当前链表的数据页， 这时候依然是淘汰掉数据页Pm， 但是新插入的数据页Px， 是放在LRU_old处。</p></li><li><p>处于old区域的数据页， 每次被访问的时候都要做下面这个判断：若这个数据页在LRU链表中存在的时间超过了1秒， 就把它移动到链表头部；如果这个数据页在LRU链表中存在的时间短于1秒， 位置保持不变。 1秒这个时间， 是由参数innodb_old_blocks_time控制的。 其默认值是1000， 单位毫秒。</p></li></ol><p>我们看看改进后的LRU算法的操作逻辑：</p><ol><li><p>扫描过程中， 需要新插入的数据页， 都被放到old区域;</p></li><li><p>一个数据页里面有多条记录， 这个数据页会被多次访问到， 但由于是顺序扫描， 这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒， 因此还是会被保留在old区域；</p></li><li><p>再继续扫描后续的数据， 之前的这个数据页之后也不会再被访问到， 于是始终没有机会移到链表头部（也就是young区域） ， 很快就会被淘汰出去。</p></li></ol><h2 id="34-到底可不可以使用join？"><a href="#34-到底可不可以使用join？" class="headerlink" title="34 | 到底可不可以使用join？"></a><strong>34 | 到底可不可以使用join？</strong></h2><p>在实际生产中， 关于join语句使用的问题， 一般会集中在以下两类：</p><ol><li><p>我们DBA不让使用join， 使用join有什么问题呢？</p></li><li><p>如果有两个大小不同的表做join， 应该用哪个表做驱动表呢？</p></li></ol><p><strong>Index Nested-Loop Join</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br></pre></td></tr></table></figure><p>如果直接使用join语句， MySQL优化器可能会选择表t1或t2作为驱动表， 这样会影响我们分析SQL语句的执行过程。 所以， 为了便于分析执行过程中的性能问题， 我改用straight_join让MySQL使用固定的连接方式执行查询， 这样优化器只会按照我们指定的方式去join。 在这个语句里， t1 是驱动表， t2是被驱动表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421212736792.png" alt="image-20240421212736792"></p><p>可以看到， 在这条语句里， 被驱动表t2的字段a上有索引， join过程用上了这个索引， 因此这个语句的执行流程是这样的：</p><ol><li><p>从表t1中读入一行数据 R；</p></li><li><p>从数据行R中， 取出a字段到表t2里去查找；</p></li><li><p>取出表t2中满足条件的行， 跟R组成一行， 作为结果集的一部分；</p></li><li><p>重复执行步骤1到3， 直到表t1的末尾循环结束。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421212800908.png" alt="image-20240421212800908"></p><p>对比用单表查询怎么实现。</p><ol><li>执行select * from t1，查出表t1的所有数据，这里有100行；</li><li>循环遍历这100行数据：<ul><li>从每一行R取出字段a的值$R.a；</li><li>执行select * from t2 where a=$R.a；</li><li>把返回的结果和R构成结果集的一行。</li></ul></li></ol><p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p><p>结论：</p><ol><li><p>使用join语句， 性能比强行拆成多个单表执行SQL语句的性能要好；</p></li><li><p>如果使用join语句的话， 需要让小表做驱动表。</p></li></ol><p><strong>Simple Nested-Loop Join</strong></p><p>由于表的字段b上没有索引， 因此再用图的执行流程时， 每次到t2去匹配的时候， 就要做一次全表扫描 。</p><p><strong>Block Nested-Loop Join</strong></p><p>这时候， 被驱动表上没有可用的索引， 算法的流程是这样的：</p><ol><li><p>把表t1的数据读入线程内存join_buffer中， 由于我们这个语句中写的是select *， 因此是把整个表t1放入了内存；</p></li><li><p>扫描表t2， 把表t2中的每一行取出来， 跟join_buffer中的数据做对比， 满足join条件的， 作为结果集的一部分返回。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421212952835.png" alt="image-20240421212952835"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213046975.png" alt="image-20240421213046975"></p><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万次。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol><p>可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p><p>分段放：join_buffer的大小是由参数join_buffer_size设定的， 默认值是256k。 <strong>如果放不下表t1的所有数据话， 策略很简单， 就是分段放</strong>。 我把join_buffer_size改成1200， 再执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></table></figure><p>执行过程就变成了：</p><ol><li><p>扫描表t1， 顺序读取数据行放入join_buffer中， 放完第88行join_buffer满了， 继续第2步；</p></li><li><p>扫描表t2， 把t2中的每一行取出来， 跟join_buffer中的数据做对比， 满足join条件的， 作为结果集的一部分返回；</p></li><li><p>清空join_buffer；</p></li><li><p>继续扫描表t1， 顺序读取最后的12行数据放入join_buffer中， 继续执行第2步。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213008023.png" alt="image-20240421213008023"></p><p>我们再来看下， 在这种情况下驱动表的选择问题。</p><p>假设， 驱动表的数据行数是N， 需要分K段才能完成算法流程， 被驱动表的数据行数是M。注意， 这里的K不是常数， N越大K就会越大， 因此把K表示为λ * N， 显然λ的取值范围是(0,1)。所以， 在这个算法的执行过程中：</p><ol><li><p>扫描行数是 N+λ <em> N </em> M；</p></li><li><p>内存判断 N * M次。</p><p>显然， 内存判断次数是不受选择哪个表作为驱动表影响的。 而考虑到扫描行数， 在M和N大小确定的情况下， N小一些， 整个算式的结果会更小。所以结论是， 应该让小表当驱动表。当然， 你会发现， 在N+λ<em>N</em>M这个式子里， λ才是影响扫描行数的关键因素， 这个值越小越好。</p></li></ol><p><strong>回答文章开头的两个问题</strong>。</p><p>第一个问题：能不能使用join语句？</p><ol><li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li></ol><p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。</p><p>第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p><ol><li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li><li>如果是Block Nested-Loop Join算法：<ul><li>在join_buffer_size足够大的时候，是一样的；</li><li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p>所以，这个问题的结论就是，总是应该使用小表做驱动表。</p><p>在决定哪个表做驱动表的时候， 应该是两个表按照各自的条件过滤， 过滤完成之后， 计算参与join的各个字段的总数据量， 数据量小的那个表， 就是“小表”， 应该作为驱动表。</p><p><strong>总结</strong></p><p>通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到了文章开头两个问题的答案：</p><ol><li>如果可以使用被驱动表的索引，join语句还是有其优势的；</li><li>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用；</li><li>在使用join的时候，应该让小表做驱动表。</li></ol><h2 id="35-join语句怎么优化？"><a href="#35-join语句怎么优化？" class="headerlink" title="35 | join语句怎么优化？"></a><strong>35 | join语句怎么优化？</strong></h2><p><strong>Multi-Range Read优化</strong></p><p>【主要是根据局部一致性原理进行优化的】</p><p>Multi-Range Read优化 (MRR)。 这个优化的主要目的是尽量使用顺序读盘。</p><p>主键索引是一棵B+树， 在这棵树上， 每次只能根据一个主键id查到一行数据。 因此， 回表肯定是一行行搜索主键索引的</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213400293.png" alt="image-20240421213400293"></p><p>如果随着a的值递增顺序查询的话， id的值就变成随机的， 那么就会出现随机访问， 性能相对较差。 虽然“按行查”这个机制不能改， 但是调整查询的顺序， 还是能够加速的。因为大多数的数据都是按照主键递增顺序插入得到的， 所以我们可以认为， 如果按照主键的递增顺序查询的话， 对磁盘的读比较接近顺序读， 能够提升读性能。</p><p>这就是MRR优化的设计思路。 此时， 语句的执行流程变成了这样：</p><ol><li><p>根据索引a， 定位到满足条件的记录， 将id值放入read_rnd_buffer中;</p></li><li><p>将read_rnd_buffer中的id进行递增排序；</p></li><li><p>排序后的id数组， 依次到主键id索引中查记录， 并作为结果返回。</p></li></ol><p><strong>Batched Key Access</strong></p><p>NLJ算法执行的逻辑是： 从驱动表t1， 一行行地取出a的值， 再到被驱动表t2去做join。 也就是说， 对于表t2来说， 每次都是匹配一个值。 这时， MRR的优势就用不上了。</p><p><strong>BNL算法的性能问题</strong></p><p>大表join操作虽然对IO有影响， 但是在语句执行结束后， 对IO的影响也就结束了。 但是，对Buffer Pool的影响就是持续性的， 需要依靠后续的查询请求慢慢恢复内存命中率。</p><p>也就是说， BNL算法对系统的影响主要包括三个方面：</p><ol><li><p>可能会多次扫描被驱动表， 占用磁盘IO资源；</p></li><li><p>判断join条件需要执行M*N次对比（M、 N分别是两张表的行数） ， 如果是大表就会占用非常多的CPU资源；</p></li><li><p>可能会导致Buffer Pool的热数据被淘汰， 影响内存命中率。</p></li></ol><h2 id="36-为什么临时表可以重名？"><a href="#36-为什么临时表可以重名？" class="headerlink" title="36 | 为什么临时表可以重名？"></a><strong>36 | 为什么临时表可以重名？</strong></h2><p><strong>内存表和临时表的概念</strong></p><ul><li><p>内存表， 指的是使用Memory引擎的表， 建表语法是create table engine=memory。 这种表的数据都保存在内存里， 系统重启的时候会被清空， 但是表结构还在。 除了这两个特性看上去比较“奇怪”外， 从其他的特征上看， 它就是一个正常的表。</p></li><li><p>临时表， 可以使用各种引擎类型 。 如果是使用InnoDB引擎或者MyISAM引擎的临时表， 写数据的时候是写到磁盘上的。 当然， 临时表也可以使用Memory引擎。</p></li></ul><p><strong>临时表的特性</strong></p><p>临时表在使用上有以下几个特点：</p><ol><li><p>建表语法是create temporary table …。</p></li><li><p>一个临时表只能被创建它的session访问， 对其他线程不可见。</p></li><li><p>临时表可以与普通表同名。</p></li><li><p>session A内有同名的临时表和普通表的时候， show create语句， 以及增删改查语句访问的是临时表。</p></li><li><p>show tables命令不显示临时表。</p></li></ol><p><strong>临时表的应用</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213557334.png" alt="image-20240421213557334"></p><p><strong>为什么临时表可以重名？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>MySQL要给这个InnoDB表创建一个frm文件保存表结构定义， 还要有地方保存表数据。这个frm文件放在临时文件目录下， 文件名的后缀是.frm， 前缀是“#sql{进程id}<em>{线程id}</em>序列号”。 你可以使用select @@tmpdir命令， 来显示实例的临时文件目录。</p><h2 id="37-什么时候会使用内部临时表？"><a href="#37-什么时候会使用内部临时表？" class="headerlink" title="37 | 什么时候会使用内部临时表？"></a><strong>37 | 什么时候会使用内部临时表？</strong></h2><p><strong>union 执行流程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> (<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213647330.png" alt="image-20240421213647330"></p><ol><li><p>创建一个内存临时表， 这个临时表只有一个整型字段f， 并且f是主键字段。</p></li><li><p>执行第一个子查询， 得到1000这个值， 并存入临时表中。</p></li><li><p>执行第二个子查询：</p><p>i. 拿到第一行id=1000， 试图插入临时表中。 但由于1000这个值已经存在于临时表了， 违反了唯一性约束， 所以插入失败， 然后继续执行；</p><p>Sii. 取到第二行id=999， 插入临时表成功。</p></li><li><p>从临时表中按行取出数据， 返回结果， 并删除临时表， 结果中包含两行数据分别是1000和999。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213702537.png" alt="image-20240421213702537"></p><p>可以看到， 这里的内存临时表起到了暂存数据的作用， 而且计算过程还用上了临时表主键id的唯一性约束， 实现了union的语义。</p><p><strong>group by 执行流程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213717901.png" alt="image-20240421213717901"></p><p>在Extra字段里面， 我们可以看到三个信息：</p><ul><li><p>Using index， 表示这个语句使用了覆盖索引， 选择了索引a， 不需要回表；</p></li><li><p>Using temporary， 表示使用了临时表；</p></li><li>Using filesort， 表示需要排序。</li></ul><p>这个语句的执行流程是这样的：</p><ol><li><p>创建内存临时表， 表里有两个字段m和c， 主键是m；</p></li><li><p>扫描表t1的索引a， 依次取出叶子节点上的id值， 计算id%10的结果， 记为x；</p></li></ol><ul><li><p>如果临时表中没有主键为x的行， 就插入一个记录(x,1);</p></li><li><p>如果表中有主键为x的行， 就将x这一行的c值加1；</p></li></ul><ol><li>遍历完成后， 再根据字段m做排序， 得到结果集返回给客户端。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213743352.png" alt="image-20240421213743352"></p><p><strong>指导原则</strong></p><ol><li><p>如果对group by语句的结果没有排序要求， 要在语句后面加 order bynull；</p></li><li><p>尽量让group by过程用上表的索引， 确认方法是explain结果里没有Using temporary和 Using filesort；</p></li><li><p>如果group by需要统计的数据量不大， 尽量只使用内存临时表； 也可以通过适当调大tmp_table_size参数， 来避免用到磁盘临时表；</p></li><li><p>如果数据量实在太大， 使用SQL_BIG_RESULT这个提示， 来告诉优化器直接使用排序算法得到group by的结果。</p></li></ol><p><strong>数据库中已经设置buffer，为什么还要有临时表这个东西，除了存储在磁盘上还有其他的好处吗</strong>?</p><ol><li><strong>缓冲区（Buffer）</strong>：缓冲区是用来存储数据页的内存区域，它的主要作用是提高数据库的性能。当数据库需要读取或写入数据时，首先将数据页加载到内存的缓冲区中，这样数据库可以直接在内存中进行操作，而不必每次都访问磁盘。这样做的好处是减少了磁盘I/O操作的次数，加快了数据的访问速度，提高了数据库的性能。</li><li><strong>临时表（Temporary Table）</strong>：临时表是一种特殊类型的表，它在数据库中的生命周期通常比普通表短暂，它的数据通常不会持久保存，而是在会话结束或者事务提交后被删除。临时表通常用于临时存储数据、中间计算结果等，它们可以帮助简化复杂的查询或者操作，提高查询的可读性和性能。</li></ol><h2 id="38-都说InnoDB好，-那还要不要使用Memory引擎？"><a href="#38-都说InnoDB好，-那还要不要使用Memory引擎？" class="headerlink" title="38 | 都说InnoDB好， 那还要不要使用Memory引擎？"></a><strong>38 | 都说InnoDB好，</strong> <strong>那还要不要使用Memory引擎？</strong></h2><p><strong>内存表的数据组织结构</strong></p><p>假设有以下的两张表t1 和 t2， 其中表t1使用Memory引擎， 表t2使用InnoDB引擎。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214154359.png" alt="image-20240421214154359"></p><p>可以看到， 内存表t1的返回结果里面0在最后一行， 而InnoDB表t2的返回结果里0在第一行。表t2用的是InnoDB引擎， 它的主键索引id的组织方式， 你已经很熟悉了： InnoDB表的数据就放在主键索引树上， 主键索引是B+树。 所以表t2的数据组织方式如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214201995.png" alt="image-20240421214201995"></p><p>与InnoDB引擎不同， Memory引擎的数据和索引是分开的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214207021.png" alt="image-20240421214207021"></p><p>可见， InnoDB和Memory引擎的数据组织方式是不同的：</p><ul><li>InnoDB引擎把数据放在主键索引上， 其他索引上保存的是主键id。 这种方式， 我们称之为索引组织表（IndexOrganizied Table） </li><li>而Memory引擎采用的是把数据单独存放， 索引上保存数据位置的数据组织形式， 我们称之为堆组织表（Heap Organizied Table） </li></ul><p>从中我们可以看出， 这两个引擎的一些典型不同</p><ol><li><p>InnoDB表的数据总是有序存放的， 而内存表的数据就是按照写入顺序存放的；</p></li><li><p>当数据文件有空洞的时候， InnoDB表在插入新数据的时候， 为了保证数据有序性， 只能在固定的位置写入新值， 而内存表找到空位就可以插入新值；</p></li><li><p>数据位置发生变化的时候， InnoDB表只需要修改主键索引， 而内存表需要修改所有索引；</p></li><li><p>InnoDB表用主键索引查询时需要走一次索引查找， 用普通索引查询的时候， 需要走两次索引查找。 而内存表没有这个区别， 所有索引的“地位”都是相同的。</p></li><li><p>InnoDB支持变长数据类型， 不同记录的长度可能不同； 内存表不支持Blob 和 Text字段， 并且即使定义了varchar(N)， 实际也当作char(N)， 也就是固定长度字符串来存储， 因此内存表的每行数据长度相同。</p></li></ol><p><strong>hash索引和B-Tree索引</strong></p><p>存表也是支B-Tree索引的。 在id列上创建一个B-Tree索引， SQL语句可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> index a_btree_index <span class="keyword">using</span> btree (id);</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214257739.png" alt="image-20240421214257739"></p><p><strong>内存表的锁</strong></p><p>内存表不支持行锁， 只支持表锁。 因此， 一张表只要有更新， 就会堵住其他所有在这个表上的读写操作。</p><p><strong>数据持久性问题</strong></p><p>数据放在内存中， 是内存表的优势， 但也是一个劣势。 因为， 数据库重启的时候， 所有的内存表都会被清空。内存表并不适合在生产环境上作为普通数据表使用 。</p><ol><li><p>如果你的表更新量大， 那么并发度是一个很重要的参考指标， InnoDB支持行锁， 并发度比内存表好；</p></li><li><p>能放到内存表的数据量都不大。 如果你考虑的是读的性能， 一个读QPS很高并且数据量不大的表， 即使是使用InnoDB， 数据也是都会缓存在InnoDB Buffer Pool里的。 因此， 使用InnoDB表的读性能也不会差。</p></li></ol><p>建议你把普通内存表都用InnoDB表来代替</p><p>内存临时表刚好可以无视内存表的两个不足， 主要是下面的三个原因：</p><ol><li><p>临时表不会被其他线程访问， 没有并发性的问题；</p></li><li><p>临时表重启后也是需要删除的， 清空数据这个问题不存在；</p></li><li><p>备库的临时表也不会影响主库的用户线程。</p></li></ol><h2 id="39-自增主键为什么不是连续的？"><a href="#39-自增主键为什么不是连续的？" class="headerlink" title="39 | 自增主键为什么不是连续的？"></a><strong>39 | 自增主键为什么不是连续的？</strong></h2><p><strong>自增值保存在哪儿？</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214411507.png" alt="image-20240421214411507"></p><p>可以看到， 表定义里面出现了一个AUTO_INCREMENT=2， 表示下一次插入数据时， 如果需要自动生成自增值， 会生成id=2。其实， 这个输出结果容易引起这样的误解： 自增值是保存在表结构定义里的。 实际上， 表的结构定义存放在后缀名为.frm的文件中， 但是并不会保存自增值。</p><p>不同的引擎对于自增值的保存策<strong>略不同。MyISAM引擎的自增值保存在数据文件中。InnoDB引擎的自增值， 其实是保存在了内存里， 并且到了MySQL 8.0版本后， 才有了“自增值持久化”的能力， 也就是才实现了“如果发生重启， 表的自增值可以恢复为MySQL重启前的值”</strong>。</p><p><strong>自增值修改机制</strong></p><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p><strong>自增值的修改时机</strong></p><p><strong>唯一键冲突导致自增主键id不连续</strong></p><p>假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>这个语句的执行流程就是：</p><ol><li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li><li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li><li>将传入的行的值改成(2,1,1);</li><li>将表的自增值改成3；</li><li>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214727022.png" alt="image-20240421214727022"></p><p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再改回去。</p><p><strong>事务回滚导致自增主键id不连续</strong></p><p>同样道理。</p><p>思考：为什么<strong>自增值为什么不能回退？</strong></p><p>【简单来说，在多事务执行下回退会出现重复】</p><p>下面举例子说明。</p><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol><li>假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。</li><li>事务B正确提交了，但事务A出现了唯一键冲突。</li><li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id=3的行，而当前的自增id值是2。</li><li>接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入语句报错“主键冲突”。</li></ol><p>而为了解决这个主键冲突，有两种方法：</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>可见，这两个方法都会导致性能问题。</p><p><strong>MySQL内部机制</strong></p><p>对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol><li>语句执行过程中，第一次申请自增id，会分配1个；</li><li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li><li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li><li>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</li></ol><p>举个例子，我们一起看看下面的这个语句序列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3， 第三次被分配到id=4到id=7。</p><p>由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p><h2 id="40-insert语句的锁为什么这么多？"><a href="#40-insert语句的锁为什么这么多？" class="headerlink" title="40 | insert语句的锁为什么这么多？"></a><strong>40 | insert语句的锁为什么这么多？</strong></h2><p>insert …select 是很常见的在两个表之间拷贝数据的方法。 你需要注意， 在可重复读隔离级别下， 这个语句会给select的表里扫描到的记录和间隙加读锁。</p><p>而如果insert和select的对象是同一个表， 则有可能会造成循环写入。 这种情况下， 我们需要引入用户临时表来做优化。<br>insert 语句如果出现唯一键冲突， 会在冲突的唯一值上加共享的next-keylock(S锁)。 因此， 碰到由于唯一键约束导致报错后， 要尽快提交或回滚事务， 避免加锁时间过长。</p><h2 id="41-怎么最快地复制一张表？"><a href="#41-怎么最快地复制一张表？" class="headerlink" title="41 | 怎么最快地复制一张表？"></a><strong>41 | 怎么最快地复制一张表？</strong></h2><p><strong>mysqldump方法</strong></p><p>SQL mysqldump -h$host -P$port -u$user —add-locks=0 —no-create-info —single-transaction —set-gtid-purged=OFF db1</p><p>这条命令中， 主要参数含义如下：</p><ol><li><p>–single-transaction的作用是， 在导出数据的时候不需要对表db1.t加表锁， 而是使用STARTTRANSACTION WITH CONSISTENTSNAPSHOT的方法；</p></li><li><p>–add-locks设置为0， 表示在输出的文件结果里， 不增加” LOCKTABLES t WRITE;”；</p></li><li><p>–no-create-info的意思是， 不需要导出表结构；</p></li><li><p>–set-gtid-purged=off表示的是， 不输出跟GTID相关的信息；</p></li><li><p>–result-file指定了输出文件的路径， 其中client表示生成的文件是在客户端机器上的。<br>通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。</p></li></ol><p><strong>导出CSV文件</strong></p><p>另一种方法是直接将结果导出成.csv文件。 MySQL提供了下面的语法， 用来将查询结果导出到服务端本地目录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.t <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/server_tmp/t.csv&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>物理拷贝</strong></p><h2 id="42-grant之后要跟着flush-privileges吗？"><a href="#42-grant之后要跟着flush-privileges吗？" class="headerlink" title="42 | grant之后要跟着flush privileges吗？"></a><strong>42 | grant之后要跟着flush privileges吗？</strong></h2><p>grant之后真的需要执行flush privileges吗？</p><p>如果没有执行这个flush命令的话， 赋权语句真的不能生效吗？grant语句会同时修改数据表和内存， 判断权限的时候使用的是内存数据。 因此， 规范地使用grant和revoke语句， 是不需要随后加上flush privileges语句的。flush privileges语句本身会用数据表的数据重建一份内存权限数据， 所以在权限数据可能存在不一致的情况下再使用。 而这种不一致往往是由于直接用DML语句操作系统权限表导致的， 所以我们尽量不要使用这类语句。</p><h2 id="43-要不要使用分区表？"><a href="#43-要不要使用分区表？" class="headerlink" title="43 | 要不要使用分区表？"></a><strong>43 | 要不要使用分区表？</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在表t中初始化插入了两行记录， 按照定义的分区规则， 这两行记录分别落在p_2018和p_2019这两个分区上。可以看到， 这个表包含了一个.frm文件和4个.ibd文件， 每个分区对应一个.ibd文件。 也就是说：对于引擎层来说， 这是4个表；对于Server层来说， 这是1个表。</p><p><strong>分区策略</strong></p><ul><li><p>MyISAM分区表使用的分区策略， 我们称为通用分区策略（generic partitioning） ， 每次访问分区都由server层控制。 通用分区策略， 是MySQL一开始支持分区表的时候就存在的代码， 在文件管理、 表管理的实现上很粗糙， 因此有比较严重的性能问题。</p></li><li><p>从MySQL 5.7.9开始， InnoDB引擎引入了本地分区策略（native partitioning） 。 这个策略是在InnoDB内部自己管理打开分区的行为。</p></li><li><p>MySQL从5.7.17开始， 将MyISAM分区表标记为即将弃用(deprecated)， 意思是“从这个版本开始不建议这么使用， 请使用替代方案。 在将来的版本中会废弃这个功能”。</p></li><li><p>从MySQL 8.0版本开始， 就不允许创建MyISAM分区表了， 只允许创建已经实现了本地分区策略的引擎。 目前来看， 只有InnoDB和NDB这两个引擎支持了本地分区策略。</p></li></ul><p><strong>分区表的server层行为</strong></p><p>如果从server层看的话， 一个分区表就只是一个表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421215158558.png" alt="image-20240421215158558"></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421215203807.png" alt="image-20240421215203807"></p><p>可以看到， 虽然session B只需要操作p_2107这个分区， 但是由于session A持有整个表t的MDL锁， 就导致了session B的alter语句被堵住。</p><ol><li><p>MySQL在第一次打开分区表的时候， 需要访问所有的分区；</p></li><li><p>在server层， 认为这是同一张表， 因此所有分区共用同一个MDL锁；</p></li><li><p>在引擎层， 认为这是不同的表， 因此MDL锁之后的执行过程， 会根据分区表规则，只访问必要的分区。</p></li></ol><p>有两个问题需要注意：</p><ol><li>分区并不是越细越好。 实际上， 单表或者单分区的数据一千万行， 只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li><li>分区也不要提前预留太多， 在使用之前预先创建即可。 比如， 如果是按月分区， 每年年底时再把下一年度的12个新分区创建上即可。 对于没有数据的历史分区， 要及时的drop掉。</li></ol><p>至于分区表的其他问题， 比如查询需要跨多个分区取数据， 查询性能就会比较慢， 基本上就不是分区表本身的问题， 而是数据量的问题或者说是使用方式的问题了。</p><h2 id="44-答疑文章（三）-：-说一说这些好问题"><a href="#44-答疑文章（三）-：-说一说这些好问题" class="headerlink" title="44 | 答疑文章（三） ： 说一说这些好问题"></a><strong>44 | 答疑文章（三）</strong> <strong>：</strong> <strong>说一说这些好问题</strong></h2><h2 id="45-自增id用完怎么办？"><a href="#45-自增id用完怎么办？" class="headerlink" title="45 | 自增id用完怎么办？"></a><strong>45 | 自增id用完怎么办？</strong></h2><p>MySQL里面的几种自增id， 一起分析一下它们的值达到上限以后，会出现什么情况。2^32 -1（4294967295） 不是一个特别大的数， 对于一个频繁插入删除数据的表来说， 是可能会被用完的。 因此在建表的时候你需要考察你的表是否有可能达到这个上限， 如果有可能， 就应该创建成8个字节的bigint unsigned。</p><p><strong>InnoDB系统自增row_id</strong></p><p>如果你创建的InnoDB表没有指定主键， 那么InnoDB会给你创建一个不可见的， 长度为6个字节的row_id。 InnoDB维护了一个全局的dict_sys.row_id值， 所有无主键的InnoDB表， 每插入一行数据， 都将当前的dict_sys.row_id值作为要插入数据的row_id， 然后把dict_sys.row_id的值加1。</p><p>每种自增id有各自的应用场景， 在达到上限后的表现也不同：</p><ol><li><p>表的自增id达到上限后， 再申请时它的值就不会改变， 进而导致继续插入数据时报主键冲突的错误。</p></li><li><p>row_id达到上限后， 则会归0再重新递增， 如果出现相同的row_id， 后写的数据会覆盖之前的数据。</p></li><li><p>Xid只需要不在同一个binlog文件中出现重复值即可。 虽然理论上会出现重复值， 但是概率极小， 可以忽略不计。</p></li><li><p>InnoDB的max_trx_id 递增值每次MySQL重启都会被保存起来， 所以我们文章中提到的脏读的例子就是一个必现的bug， 好在留给我们的时间还很充裕。</p></li><li><p>thread_id是我们使用中最常见的， 而且也是处理得最好的一个自增id逻辑了。</p></li></ol><h2 id="面试高频知识"><a href="#面试高频知识" class="headerlink" title="面试高频知识"></a><strong>面试高频知识</strong></h2><p>搬运自知乎</p><p>1、一条 sql 语句是如何执行的？也就是说，从客户端执行了一条 sql 命令，服务端会进行哪些处理？（例如验证身份，是否启用缓存啥的）</p><p>2、索引相关：索引是如何实现的？多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）</p><p>3、事务相关：例如事务的隔离是如何实现的？事务是如何保证原子性？不同的事务看到的数据怎么就不一样了？难道每个事务都拷贝一份视图？MVCC 的实现原理（重要）等等。</p><p>4、各种锁相关：例如表锁，行锁，间隙锁，共享锁，排他锁。这些锁的出现主要是用来解决哪些问题？（重要）</p><p>5、日志相关：redolog，binlog，undolog，这些日志的实现原理，为了解决怎么问题？日志也是非常重要的吧，面试也问的挺多。</p><p>6、数据库的主从备份、如何保证数据不丢失、如何保证高可用等等。</p><p>7、一些故障排查的命令，例如慢查询，sql 的执行计划，索引统计的刷新等等。</p>]]></content>
    
    
    <summary type="html">MySQL实战45讲</summary>
    
    
    
    <category term="MySQL" scheme="https://penge666.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://penge666.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Cpp基础知识</title>
    <link href="https://penge666.github.io/posts/4772239d.html"/>
    <id>https://penge666.github.io/posts/4772239d.html</id>
    <published>2024-04-19T06:52:18.000Z</published>
    <updated>2024-05-04T03:38:47.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内功学习推荐</p><ul><li>CSAPP 第七章：链接</li><li>程序员的自我修养：第2，3，4，6章</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="形参带默认值"><a href="#形参带默认值" class="headerlink" title="形参带默认值"></a>形参带默认值</h3><p>形参带默认值的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum1</span><span class="params">(<span class="type">int</span> a=<span class="number">2</span>, <span class="type">int</span> b=<span class="number">4</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note1</strong></p></blockquote><p>若是传入实参，则使用的就是你的实参。没有传入就使用形参的默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bug</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span><span class="number">5</span>E<span class="operator">:</span>\CPP\<span class="number">996.</span>cpp[<span class="literal">Error</span>] <span class="keyword">default</span> argument missing <span class="keyword">for</span> parameter <span class="number">2</span> <span class="keyword">of</span> <span class="symbol">&#x27;int</span> <span class="keyword">fun</span>(<span class="type">int</span>, <span class="type">int</span>)&#x27;</span><br></pre></td></tr></table></figure><p>Note：形参给默认值的时候，只能从右向左给。因为压栈的时候是从右向左压的。</p><blockquote><p><strong>Note2</strong></p></blockquote><p>调用形参带默认值的函数，其效率与不带的比较？</p><ul><li>效率是增长了，毕竟少了mov指令</li></ul><p>汇编查看</p><ul><li>pre</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01112156  mov         eax,dword ptr [b]  【ebp-8】</span><br><span class="line">01112159  push        eax  </span><br><span class="line">0111215A  mov         ecx,dword ptr [a]  【ebp-4】</span><br><span class="line">0111215D  push        ecx  </span><br><span class="line">0111215E  call        sum (01111406h)  </span><br></pre></td></tr></table></figure><ul><li>now</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0111217A  push        14h  </span><br><span class="line">0111217C  push        0Ah  </span><br><span class="line">0111217E  call        sum (01111406h)  </span><br></pre></td></tr></table></figure><blockquote><p><strong>Note3</strong></p></blockquote><p>函数形参变量给默认值，定义处可以声明也可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">sum</span>(a);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">sum</span>();</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">sum</span>(a, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note4</strong></p></blockquote><p>函数声明可以很多次，定义只有一次。但是形参给默认值，不管是在定义处还是声明处给，形参默认值只能出现一次。</p><h3 id="内联inline"><a href="#内联inline" class="headerlink" title="内联inline"></a>内联inline</h3><p>内联函数和普通函数的区别：</p><ol><li>inline函数在编译过程中，没有函数调用的开销。在函数调用点（int ret = sum(a, b);）直接把函数的代码进行展开处理。</li><li>inline函数(内联成功)不会在符号表中生成相应的函数符号。</li><li>inline只是建议编译器把这个函数处理为内联函数，但是编译器最终决定是否处理为内联函数的。</li><li>可以通过命令查看：objdump -t main.o。就看在符号表里面有没有产生符号，若内联成功肯定没有符号。</li><li>在debug版本上，inline是不起作用的(也有普通函数的调用开销)，因为是debug版本需要调试的。</li></ol><p>Note：递归不会产生内联。</p><p>具体代码规范参考《Google Style C++》</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote><p> pro1：C++为什么支持函数重载，但是C语言不支持？</p></blockquote><p>编译器编译代码产生符号的规则不同。</p><ol><li>C++代码产生函数符号的时候，是由 <strong>函数名+参数列表类型</strong> 组成的。</li><li>C语言产生函数符号的时候，是只由函数名来决定的。（在C语言中，函数名相同，所以就会产生链接错误：找到多个函数的定义）</li></ol><blockquote><p>pro2：函数重载需要注意些什么？</p></blockquote><p>函数重载：一组函数，其函数名相同，参数列表的个数或者类型不同，那么这一组函数就可以称作为函数重载。一组函数要称得上重载，一定得先处于同一个作用域当中的。重载函数名字都一样，在编译器编译的过程中会根据函数调用的时候 传入的实参的类型来选择合适的函数重载版本。</p><p>注意点</p><ol><li>函数重载定义：<strong>一组函数，其函数名相同，参数列表的个数或者类型不同</strong>，那么这一组函数就可以称作为函数重载。</li><li>一组函数要称得上重载，<strong>一定得先处于同一个作用域当中的</strong>（从函数调用点来看，这组函数是处于同一个作用域 。注：在函数中不可以定义函数，可以声明函数，但是需要注意其中的作用域问题）</li><li>当给参数加上const或者volatile（标准的C/C++的关键字）的时候，是怎么影响形参类型的？(下面会进行详解)</li><li>一组函数，函数名相同，参数列表也相同，仅仅是返回值不同？<strong>这不是重载</strong> 。<ul><li><strong>返回值相不相同和函数重载没有任何关系</strong>，函数重载的主要原因就是：虽然看起来函数名相同但最终生成的符号是不同的。因为符号是函数名+形参列表。</li></ul></li></ol><p>程序1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_int_int&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_double_double&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_const char*_const char*&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.0</span>, <span class="number">20.0</span>);</span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compare_int_int</span><br><span class="line">compare_double_double</span><br><span class="line">compare_const char*_const char*</span><br></pre></td></tr></table></figure><p>程序2：不同作用域</p><p><strong>在C和C++里面，在函数里面再定义一个函数是不行的，但是声明一个函数是可以的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_int_int&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_double_double&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_const char*_const char*&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.0</span>, <span class="number">20.0</span>);</span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2420E:\CPP\996.cpp[Error] invalid conversion from <span class="string">&#x27;const char*&#x27;</span> to <span class="string">&#x27;int&#x27;</span> [-fpermissive]</span><br></pre></td></tr></table></figure><p>分析：在C语言和C++中，都是分作用域的。在函数里面也可以定义一个和全局变量同名的局部变量，作用域不同 是可以定义同名变量。<strong>在使用这个变量的时候，会优先使用在当前最近的作用域下找这个变量。</strong></p><p>程序3：当给参数加上const或者volatile</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65E:\CPP\996.cpp[Error] redefinition of <span class="string">&#x27;int func(int)&#x27;</span></span><br></pre></td></tr></table></figure><p>对于编译器而言，两个func的形参类型都是int。相当于函数重定义了</p><blockquote><p><strong>补充：</strong>C++和C语言代码之间如何相互调用？</p></blockquote><p>在说这个问题之前，需要先了解下两者之间的差异。</p><p>最大的差异是C++支持函数重载，而C语言不支持。为了使函数支持重载，C++在C语言的基础上，将函数名添加上返回值和参数的类型信息。例如，int add(int, int)这个函数，通过C++编译器编译后，可能呈现的函数名为int int_add_int_int(int, int)。因此调用过程在链接阶段可能会出现错误。</p><blockquote><p><strong>C调用C++</strong></p></blockquote><ol><li>将函数用extern “C”声明。</li><li>C代码中不要include C++的头文件, 而采用直接在C中增加函数声明的方式。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*C++ code*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*C code*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 不引入, 而只是直接声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cc</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(i);  <span class="comment">//调用</span></span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>C++调用C</strong></p></blockquote><p>cfun.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------cfun.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __C_FUN_20180228_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __C_FUN_20180228_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __cplusplus</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>#ifdef __cplusplus， 表示如果是C++来调用该接口，则该函数接口经编译后的函数符号生成规则按照C风格走, 否则没有extern “C” ， 这样提供的接口同时支持C和C++两者的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------cfun.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cfun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cfun.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cfun</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const修饰"><a href="#const修饰" class="headerlink" title="const修饰"></a>const修饰</h3><blockquote><p> <strong>const是什么？</strong></p></blockquote><p>const修饰的变量不能再作为左治，初始化完成，值不能修改！</p><blockquote><p><strong>const在C和C++中的区别？</strong></p></blockquote><ol><li><p>初始化</p><ul><li>C++中的const，必须初始化</li></ul></li><li><p>编译方式不一样：</p><ul><li>C中，const就是当作一个变量[常变量]来编译生成指令</li></ul></li></ol><ul><li>C++中，所有出现const常量名字的地方，都会常量的初始值代替</li></ul><h3 id="const和一级指针"><a href="#const和一级指针" class="headerlink" title="const和一级指针"></a>const和一级指针</h3><p>待填坑…</p><h3 id="const和二级指针"><a href="#const和二级指针" class="headerlink" title="const和二级指针"></a>const和二级指针</h3><p>待填坑…</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Q：OOP语言的四大特征是什么？</p><p>A：抽象 ，封装（隐藏）， 继承， 多态。</p><p>Q：封装（隐藏）体现在？</p><p>A：使用的访问限定符 （public private protected）</p><p>Q：对象的内存大小计算</p><p>A：对象的内存大小只依赖于 成员变量，与成员方法的多少无关。算成员变量的大小是和结构体变量的内存计算方式一样：先找占用内存最长的成员变量，以其为内存字节对齐的方式。然后计算出总的对象的大小。</p><p>Note：静态成员变量不占用对象大小。</p><p>类有无数个对象，每个对象都有自己的成员变量，但是共享一套成员方法【方法放在代码段】</p><p>Q：当用对象调用类里面的同一套方法时，这个方法是怎么知道处理哪个对象的信息呢？</p><p>A：this 指针：this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="built_in">init</span>();<span class="comment">// 编译器给加的：init(A *const this,...)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.<span class="built_in">init</span>();<span class="comment">// 编译器给加的： init(&amp;a,...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的成员方法经过编译，所有方法参数都会加上this指针，接受该方法的对象地址。</p><p>Q：对象的构造函数和析构函数的时机？</p><p>A：先构造的后析构，后构造的先析构</p><p>Q：动态和静态定义对象？</p><p>A：静态建立一个类对象， 是由编译器为对象在栈空间中分配内存， 通过直接移动栈顶指针挪出适当的空间， 然后在这片内存空间上调用构造函数形成一个栈对象。 动态建立类对象， 是使用new运算符将对象建立在堆空间中， 在栈中只保留了指向该对象的指针。 </p><p>Q：深拷贝和浅拷贝？</p><p>对象默认的拷贝构造是在做内存的数据拷贝。在new的时候会存在问题。</p><p>case1:默认拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a=b;(等于A <span class="built_in">a</span>(b))</span><br></pre></td></tr></table></figure><p>case2:默认赋值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure><p>Q：看看下面代码哪错了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;typeinfo&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;functional&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">a_=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> aa)&#123;</span><br><span class="line">tmp=<span class="built_in">A</span>(aa);</span><br><span class="line">&#125;</span><br><span class="line">A tmp; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>构造函数初始化列表的时候，tmp=A(aa)赋值语句本质是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A tmp</span><br><span class="line">tmp=<span class="built_in">A</span>(aa)</span><br></pre></td></tr></table></figure><p>由于A类中提供了有参构造，因此，不会生成默认的无参构造。所以A tmp报错。</p><p>如果修改正确？</p><p>方式1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;typeinfo&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;functional&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">a_=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> aa):<span class="built_in">tmp</span>(<span class="built_in">A</span>(aa))&#123;</span><br><span class="line">&#125;</span><br><span class="line">A tmp; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>方式2：</p><p>在A中添加无参构造。</p><p>Q：构造函数初始化顺序问题？</p><p>A：结论：谁先定义，谁先初始化。因为C++的·对象模型在内存中是连续的！</p><p>Q：类的成员方法有哪些？区别是什么？</p><p>A：</p><ul><li>普通方法要用对象调用=》编译会产生this指针</li><li>静态方法用类的作用域调用=》没有this指针</li></ul><h2 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板 ： 是不进行编译的，因为（形参a b）类型还不知道。（区分函数模板很简单，前面看有没有加template和模板参数列表）。</p><p>模板的实例化：是在函数调用点进行实例化（由用户指定的类型，或实参推演出的类型）。</p><p>模板函数： 在函数调用点，编译器用用户指定的类型，从原模板实例化一份函数代码出来。这是真真正正需要代码编译（编译器编译）的函数。</p><p>模板的实参推演 ：可以根据用户传入的实参的类型，来推导出模板类型参数的具体类型。</p><p>模板代码是不能在一个文件中定义，在另外一个文件中使用的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240503193134169.png" alt="image-20240503193134169"></p><p>针对某些类型来说，依赖编译器默认实例化的模板代码，代码处理逻辑是有错误的。</p><p>因此，使用模板的特例化的实例化。</p><p>下面来看个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//定义一个模板参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用T类型 定义具体的形参变量</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;template compare&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对compare函数模板，提供const char *类型的特例化版本</span></span><br><span class="line"><span class="comment">//不可省略：表示这个特例化也是从上面的模板来的，先有模板才有特例化。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">compare</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare&lt;const char*&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////非模板函数</span></span><br><span class="line"><span class="comment">//bool compare(const char* a, const char* b)&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;普通的compare&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return strcmp(a, b) &gt; 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">compare</span>(<span class="string">&quot;11&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>Note:模板的非类型参数，都是常量</strong></p><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板的使用实际上是类模板实例化成一个具体的类（而非模板类）。模板参数列表里面一般都是定义参数，用来初始化类型的。即都是定义模板类型参数。模板类型参数：&lt; &gt; 里面可以由typename/class定义 模板 类型参数T （可以定义多个，由，隔开）T用来接收 类型的。</p><p>直接来个例子练练手吧~</p><p>实现C++ STL向量容器vector。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">int</span>&gt;<span class="comment">//定义模板类型参数</span></span><br><span class="line"><span class="keyword">class</span> MyVector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="type">int</span> size = <span class="number">5</span>)<span class="comment">//底层开辟5个元素的空间</span></span><br><span class="line">&#123;</span><br><span class="line">_first = <span class="keyword">new</span> T[size];</span><br><span class="line">_last = _first;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MyVector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]_first;</span><br><span class="line">_first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="type">const</span> MyVector&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = src._end - src._first;<span class="comment">//总的空间 个数</span></span><br><span class="line">_first = <span class="keyword">new</span> T[size];</span><br><span class="line">_end = _first + size;</span><br><span class="line"><span class="type">int</span> len = src._last - src._first;<span class="comment">//有效长度</span></span><br><span class="line">_last = _first + len;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_first[i] = src._first[i];<span class="comment">//把值赋过来</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyVector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyVector&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[]_first;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = src._end - src._first;<span class="comment">// 总的空间 个数</span></span><br><span class="line">_first = <span class="keyword">new</span> T[size];</span><br><span class="line">_end = _first + size;</span><br><span class="line"><span class="type">int</span> len = src._last - src._first;<span class="comment">// 有效长度</span></span><br><span class="line">_last = _first + len;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_first[i] = src._first[i];<span class="comment">// 把值赋过来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; val)</span><span class="comment">// 向容器末尾添加元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">resize</span>();</span><br><span class="line">&#125;</span><br><span class="line">*_last++ = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span><span class="comment">// 向容器末尾删除元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">*_last--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">getValueBack</span><span class="params">()</span><span class="type">const</span><span class="comment">// 返回容器末尾的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span><span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last == _end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _first == _last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cursize</span><span class="params">()</span><span class="type">const</span><span class="comment">//元素的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last - _first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _first;<span class="comment">// 数组起始位置</span></span><br><span class="line">T* _last;<span class="comment">// 最后一个有效元素的 后继</span></span><br><span class="line">T* _end;<span class="comment">// 数组最后一个空间位置的  后继</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span><span class="comment">// 容器的2倍扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">cursize</span>() * <span class="number">2</span>;</span><br><span class="line">T* newfirst = <span class="keyword">new</span> T[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">cursize</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">newfirst[i] = _first[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]_first;</span><br><span class="line">_first = newfirst;</span><br><span class="line">_last = _first + size / <span class="number">2</span>;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyVector&lt;&gt;myvec;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前容器的容量是：&quot;</span> &lt;&lt; myvec.<span class="built_in">cursize</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">myvec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前容器的容量是：&quot;</span> &lt;&lt; myvec.<span class="built_in">cursize</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (!myvec.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; myvec.<span class="built_in">getValueBack</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">myvec.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前容器的容量是：&quot;</span> &lt;&lt; myvec.<span class="built_in">cursize</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解容器空间配置器allocator"><a href="#理解容器空间配置器allocator" class="headerlink" title="理解容器空间配置器allocator"></a>理解容器空间配置器allocator</h3><p>为什么要提出这个东东呢？</p><p>先来看个例子，PS：代码示例虽然长，但是比起文字更有力量！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;</span><br><span class="line">p=<span class="keyword">new</span> T[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line">T *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>()&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Test()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>()&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;~Test()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A&lt;Test&gt; a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Test()</span><br><span class="line">Test()</span><br><span class="line">Test()</span><br><span class="line">Test()</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br></pre></td></tr></table></figure><p>这一个空的容器，竟然给我构造了5个 Test对象。出了作用域，又析构了5个Test对象。我现在就只是实例化一个这个空的vector容器。</p><p>若是用户传入了个 10000，那么他只是想 定义一个容器对象。然后就给人家构造了10000个对象，这不是人家想要的。</p><p><strong>因此</strong>，现在的需求：需要把内存开辟 和 对象的构造分开处理。在定义容器对象的时候，需要做的只是 底层开辟空间（只是给容器这个数组开辟空间，而不去构造对象）。</p><p>废话少说，直接看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span></span><br><span class="line"><span class="comment">//默认的内存管理都是free malloc（也可以采用内存池的方式）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Allocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="comment">// 只负责内存开辟</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p)</span> <span class="comment">// 只负责内存释放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="type">const</span> T&amp; val)</span> <span class="comment">// 只负责对象构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//在我们指定的地址里面构造一个值为val的对象</span></span><br><span class="line"><span class="comment">//在一个已经存在 开辟好的内存上去构造一个值为val的对象</span></span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T</span>(val); <span class="comment">// 定位new    T类型的拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> <span class="comment">// 只负责对象析构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;~<span class="built_in">T</span>(); <span class="comment">// ~T()代表了T类型的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">容器底层内存开辟，内存释放，对象构造和析构，</span></span><br><span class="line"><span class="comment">都通过allocator空间配置器来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">int</span>,<span class="keyword">typename</span> Alloc=Allocator&lt;T&gt;&gt;<span class="comment">//定义模板类型参数</span></span><br><span class="line"><span class="keyword">class</span> MyVector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="type">int</span> size = <span class="number">5</span>)<span class="comment">//底层开辟5个元素的空间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需要把内存开辟和对象的构造分开处理</span></span><br><span class="line"><span class="comment">//_first = new T[size];</span></span><br><span class="line"></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">_last = _first;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MyVector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//析构容器里面有效的元素，再去释放_first指向的堆内存</span></span><br><span class="line"><span class="comment">//delete[]_first;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);<span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">_first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="type">const</span> MyVector&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = src._end - src._first;<span class="comment">//总的空间 个数</span></span><br><span class="line"><span class="comment">//_first = new T[size];</span></span><br><span class="line"></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">_end = _first + size;</span><br><span class="line"><span class="type">int</span> len = src._last - src._first;<span class="comment">//有效长度</span></span><br><span class="line">_last = _first + len;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//_first[i] = src._first[i];//把值赋过来</span></span><br><span class="line"></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_first + i, src._first[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyVector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyVector&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delete[]_first;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">_allocator.<span class="built_in">destory</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);<span class="comment">// 释放堆上的数组内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = src._end - src._first;<span class="comment">//总的空间 个数</span></span><br><span class="line"><span class="comment">//_first = new T[size];</span></span><br><span class="line"></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">_end = _first + size;</span><br><span class="line"><span class="type">int</span> len = src._last - src._first;<span class="comment">//有效长度</span></span><br><span class="line">_last = _first + len;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//_first[i] = src._first[i];//把值赋过来</span></span><br><span class="line"></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_first + i, src._first[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; val)</span><span class="comment">//向容器末尾添加元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">resize</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*_last= val;</span></span><br><span class="line"><span class="comment">//_last++;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_last指针指向的内存构造一个值为val的对象</span></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">_last++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span><span class="comment">//向容器末尾删除元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//_last--;// 不仅要把_last指针--，还需要析构删除的元素</span></span><br><span class="line">--_last;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">getValueBack</span><span class="params">()</span><span class="type">const</span><span class="comment">//返回容器末尾的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span><span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last == _end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _first == _last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cursize</span><span class="params">()</span><span class="type">const</span><span class="comment">//元素的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last - _first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _first;<span class="comment">//数组起始位置</span></span><br><span class="line">T* _last;<span class="comment">//最后一个有效元素的 后继</span></span><br><span class="line">T* _end;<span class="comment">//数组最后一个空间位置的  后继</span></span><br><span class="line">Alloc _allocator;<span class="comment">//定义的容器 空间配置器对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span><span class="comment">//容器的2倍扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">cursize</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="comment">//T* newfirst = new T[size];</span></span><br><span class="line"></span><br><span class="line">T* newfirst = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">cursize</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">construct</span>(newfirst + i, _first[i]);</span><br><span class="line"><span class="comment">//newfirst[i] = _first[i];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//delete[]_first;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);<span class="comment">// 释放堆上的数组内存</span></span><br><span class="line"></span><br><span class="line">_first = newfirst;</span><br><span class="line">_last = _first + size / <span class="number">2</span>;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">const</span> Test&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test t1, t2, t3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//MyVector&lt;&gt;myvec;//定义了一个容器，里面并没有添加元素</span></span><br><span class="line">MyVector&lt;Test&gt;myvec;<span class="comment">//用Test类型 实例化一下这个vector容器</span></span><br><span class="line">myvec.<span class="built_in">push_back</span>(t1);</span><br><span class="line">myvec.<span class="built_in">push_back</span>(t2);</span><br><span class="line">myvec.<span class="built_in">push_back</span>(t3);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line">myvec.<span class="built_in">pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过空间配置器的功能，就可以很好的解决上面的问题。</p><blockquote><p> <strong>补充：定位new运算符</strong></p></blockquote><p>定位new（placement new）是C++中的一种new操作符，它允许在已分配的内存中构造对象。这种构造方式不会为对象分配新的内存，而是在已经存在的内存中创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass constructed:&quot;</span>&lt;&lt;a&lt;&lt;std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>]; <span class="comment">// 分配一块内存</span></span><br><span class="line"></span><br><span class="line">    MyClass *p = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">10</span>); <span class="comment">// 在已分配的内存中构造对象</span></span><br><span class="line"></span><br><span class="line">    p-&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 手动调用析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><strong>Note1:</strong></p><p>++ —单目运算符<br>operator++() 前置++<br>operator++(int) 后置++</p><h3 id="String类的实现"><a href="#String类的实现" class="headerlink" title="String类的实现"></a>String类的实现</h3><p>实现String类，并支持以下功能：</p><ol><li>支持默认构造</li><li>说明string类 里面有string（const char*参数)的构造函数</li><li>里面有 加法运算符的重载函数</li><li>里面有类内实现的：支持对象+ const char*的</li><li>还要全局实现的：const char*+对象</li></ol><p>Note：strlen(p)表示字符串有效字符个数，但是字符后面存在\0,因此申请大小的时候要加1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str_, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *str_ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str_;</span><br><span class="line">        str_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(obj.str_) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str_, obj.str_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值运算,保证可以连续赋值</span></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] str_;</span><br><span class="line">        str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(obj.str_) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str_, obj.str_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str_, obj.str_) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str_, obj.str_) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str_, obj.str_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strlen</span>(str_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> str_[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在一个类中指明其他的类（或者）函数能够直接访问该类中的private和protected成员</span></span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String &amp;des, <span class="type">const</span> String src);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, String &amp;src);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> String &amp;src);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str_;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> String &amp;src)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; src.str_;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, String &amp;src)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; src.str_;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String &amp;des, <span class="type">const</span> String src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *newstr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(des.str_) + <span class="built_in">strlen</span>(src.str_) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(newstr, des.str_);</span><br><span class="line">    newstr = <span class="built_in">strcat</span>(newstr, src.str_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(newstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String c = a + b;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a&gt;b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a&lt;b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上示例，我们还要继续完善，如果给String类加迭代器呢？就好像使用的是原生的一样呢？</p><p>完善的代码。迭代器只要去嵌套个类即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str_, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *str_ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str_;</span><br><span class="line">        str_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(obj.str_) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str_, obj.str_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值运算,保证可以连续赋值</span></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] str_;</span><br><span class="line">        str_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(obj.str_) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str_, obj.str_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str_, obj.str_) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str_, obj.str_) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str_, obj.str_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strlen</span>(str_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> str_[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">iterator</span>(<span class="type">char</span> *p = <span class="literal">nullptr</span>) : <span class="built_in">p_</span>(p) &#123;&#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it.p_ != p_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            p_++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> &amp;<span class="keyword">operator</span>*()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *p_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> *p_;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(str_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(str_ + <span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在一个类中指明其他的类（或者）函数能够直接访问该类中的private和protected成员</span></span><br><span class="line">    <span class="keyword">friend</span> String</span><br><span class="line">    <span class="keyword">operator</span>+(<span class="type">const</span> String &amp;des, <span class="type">const</span> String src);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, String &amp;src);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> String &amp;src);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str_;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> String &amp;src)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; src.str_;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, String &amp;src)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; src.str_;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String &amp;des, <span class="type">const</span> String src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *newstr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(des.str_) + <span class="built_in">strlen</span>(src.str_) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(newstr, des.str_);</span><br><span class="line">    newstr = <span class="built_in">strcat</span>(newstr, src.str_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(newstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String c = a + b;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a&gt;b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a&lt;b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们讨论个常见的问题：<strong>容器的迭代器 iterator失效</strong></p><p>迭代器失效通常发生在对容器进行修改操作后。下面是一些常见的情况：</p><ol><li><strong>向容器中添加元素</strong>：如果容器的内部存储空间不足以容纳新的元素，容器可能需要分配新的内存空间，将所有元素移动到新的位置。在这种情况下，指向容器中元素的所有迭代器都会失效。</li><li><strong>从容器中删除元素</strong>：删除元素会导致容器中后面的元素向前移动，填补空出的位置。在这种情况下，指向被删除元素和它之后的元素的迭代器都会失效。</li><li><strong>对容器进行排序或重新排列</strong>：这些操作会改变元素的位置，导致指向容器中元素的迭代器失效。</li><li><strong>清空容器</strong>：清空容器后，指向容器中任何元素的迭代器都会失效。</li></ol><h3 id="Vector类的实现"><a href="#Vector类的实现" class="headerlink" title="Vector类的实现"></a>Vector类的实现</h3><p>【重点】在上述的vector代码继续完善insert erase的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocator</span>    <span class="comment">//自定义的空间配置器，负责内存管理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span><span class="comment">//负责开辟内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p)</span><span class="comment">//负责回收内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="type">const</span> T&amp; val)</span><span class="comment">//负责 对象构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span><span class="comment">//负责对象析构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;~<span class="built_in">T</span>();<span class="comment">//~T()代表了T类型的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">容器底层内存开辟，内存释放，对象构造和析构</span></span><br><span class="line"><span class="comment">都通过allocator空间配置器来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">int</span>,<span class="keyword">typename</span> Allo= MyAllocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyVector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="type">int</span> size = <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//需要把内存开辟 和 对象构造分开，不能用new</span></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">_last = _first;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MyVector</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//先析构容器里面的有效的元素</span></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后释放_first 指向的堆内存</span></span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">_first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="type">const</span> MyVector&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> size = src._last - src._first;<span class="comment">//有效元素的个数</span></span><br><span class="line"><span class="type">int</span> len = src._end - src._first;<span class="comment">//空间总长度</span></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(len);</span><br><span class="line">_last = _first + size;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">construct</span>(_first + i, src._first[i]);</span><br><span class="line">&#125;</span><br><span class="line">_end = _first + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyVector&lt;T&gt;<span class="keyword">operator</span>=(<span class="type">const</span> MyVector&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;= 运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先析构容器里面的有效的元素</span></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后释放_first 指向的堆内存</span></span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = src._last - src._first;<span class="comment">//有效元素的个数</span></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">_last = _first + size;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">construct</span>(_first + i, src._first[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = src._end - src._first;<span class="comment">//空间总长度</span></span><br><span class="line">_end = _first + len;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; val)</span><span class="comment">// 向容器末尾添加元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">resize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//_last指针指向的内存构造一个值为val的对象</span></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">_last++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">getBack</span><span class="params">()</span><span class="type">const</span><span class="comment">// 返回容器末尾的元素的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span><span class="comment">// 从容器末尾删除元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是从当前末尾元素进行删除的 需要把那个 失效一下</span></span><br><span class="line"><span class="built_in">checkIterator</span>(_last - <span class="number">1</span>, _last);</span><br><span class="line"><span class="comment">// 不仅要把_last指针--，还需要析构删除的元素</span></span><br><span class="line">_allocator.<span class="built_in">destroy</span>(--_last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last == _end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last == _first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _last - _first;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)<span class="comment">//myv[4]  下标运算符的重载</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;下标运算符的重载&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">getSize</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;index 不合法&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> _first[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器一般实现成容器类的嵌套类</span></span><br><span class="line"><span class="comment">// 给vector类型提供迭代器的实现</span></span><br><span class="line"><span class="comment">//作为vector的嵌套类，为了迭代向量的底层数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyVector</span>&lt;T, Allo&gt;;</span><br><span class="line"><span class="built_in">iterator</span>(MyVector&lt;T, Allo&gt;* ptrVec=<span class="literal">nullptr</span>,T*_p=<span class="literal">nullptr</span>)</span><br><span class="line"> :_p(_p),_ptrVec(ptrVec)</span><br><span class="line">&#123;</span><br><span class="line">Iterator_Base* newIter = </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _ptrVec-&gt;_head._next);</span><br><span class="line">_ptrVec-&gt;_head._next = newIter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个对于字符串的迭代器的不等于</span></span><br><span class="line"><span class="comment">// 迭代器的不等于就是底层指针的不等于</span></span><br><span class="line"><span class="comment">// 迭代器的指向 就是 vector数组底层指针的指向</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查迭代器的有效性</span></span><br><span class="line"><span class="keyword">if</span> (_ptrVec == <span class="literal">nullptr</span> || _ptrVec != it._ptrVec)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;iterator 不匹配!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _p != it._p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++ 不会产生临时量，就是修改当前对象的值 再返回</span></span><br><span class="line"><span class="comment">//后置++ 需要把原对象的值返回  再修改当前对象的值</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查迭代器的有效性</span></span><br><span class="line"><span class="keyword">if</span> (_ptrVec == <span class="literal">nullptr</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;iterator 无效的!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">++_p;<span class="comment">//给迭代器 成员变量++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常方法：普通对象 常对象都可以调用</span></span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>*()<span class="type">const</span><span class="comment">//只读 常方法</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 检查迭代器的有效性</span></span><br><span class="line"><span class="keyword">if</span> (_ptrVec == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;iterator 无效的!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *_p; </span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="comment">//可读可写</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查迭代器的有效性</span></span><br><span class="line"><span class="keyword">if</span> (_ptrVec == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;iterator 无效的!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *_p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _p;</span><br><span class="line"><span class="comment">//当前迭代器需要知道 它在迭代哪种容器对象</span></span><br><span class="line">MyVector&lt;T, Allo&gt;* _ptrVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要给容器提供begin end方法</span></span><br><span class="line"><span class="comment">// begin返回的是容器底层 首元素 的迭代器的表示</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用_first这个指向数组首元素地址的 指针</span></span><br><span class="line"><span class="comment">// 构造一个iterator</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>,_first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// end返回的是容器末尾(有效的)元素后继位置的迭代器的表示</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>,_last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkIterator</span><span class="params">(T* first, T* last)</span><span class="comment">// 检查迭代器失效</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Iterator_Base* preIter = &amp;<span class="keyword">this</span>-&gt;_head;<span class="comment">// 指向头结点</span></span><br><span class="line">Iterator_Base* curIter = <span class="keyword">this</span>-&gt;_head._next;<span class="comment">// 指向第一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (curIter != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;<span class="comment">//迭代的地址 在这个失效区间里面  则把这个迭代器失效一下</span></span><br><span class="line"><span class="keyword">if</span> (curIter-&gt;_curiterator-&gt;_p &gt; first &amp;&amp;</span><br><span class="line"> curIter-&gt;_curiterator-&gt;_p &lt;= last)</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 迭代器失效，把iterator持有的容器指针置nullptr</span></span><br><span class="line">curIter-&gt;_curiterator-&gt;_ptrVec = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 删除当前迭代器节点，继续判断后面的迭代器节点是否失效</span></span><br><span class="line">preIter-&gt;_next = curIter-&gt;_next;</span><br><span class="line"><span class="keyword">delete</span> curIter;</span><br><span class="line">curIter = preIter-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">preIter = curIter;</span><br><span class="line">curIter = curIter-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义实现vector容器的insert方法</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.不考虑扩容 verify(_first - 1, _last);</span></span><br><span class="line"><span class="comment">//2.不考虑it._ptr的指针合法性</span></span><br><span class="line"><span class="built_in">checkIterator</span>(it._p - <span class="number">1</span>, _last);</span><br><span class="line">T* p = _last;</span><br><span class="line"><span class="keyword">while</span> (p &gt; it._p)<span class="comment">//元素依次后移</span></span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">--p;</span><br><span class="line">&#125;</span><br><span class="line">_allocator.<span class="built_in">construct</span>(p, val); </span><br><span class="line">_last++;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//最后返回一个当前位置的新的迭代器</span></span><br><span class="line"><span class="comment">//把当前对象 this传进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义实现vector容器的erase方法</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.不考虑扩容 verify(_first - 1, _last);</span></span><br><span class="line"><span class="comment">// 2.不考虑it._ptr的指针合法性</span></span><br><span class="line"><span class="built_in">checkIterator</span>(it._p - <span class="number">1</span>, _last);</span><br><span class="line">T* p = it._p;</span><br><span class="line"><span class="keyword">while</span> ( p&lt;_last<span class="number">-1</span>)<span class="comment">//元素依次前移</span></span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">_allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">_last--;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._p);</span><br><span class="line"><span class="comment">// 最后返回一个当前位置的新的迭代器</span></span><br><span class="line"><span class="comment">// 把当前对象 this传进去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _first;<span class="comment">// 指向数组起始的位置</span></span><br><span class="line">T* _last;<span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">T* _end;<span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">Allo _allocator;<span class="comment">// 定义容器的空间配置器对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> size = _last - _first;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> newsize = size * <span class="number">2</span>;</span><br><span class="line">T* newfirst = _allocator.<span class="built_in">allocate</span>(newsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">construct</span>(newfirst + i, _first[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">_first = newfirst;</span><br><span class="line">_last = _first + size;</span><br><span class="line">_end = _first + newsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_Base</span> <span class="comment">// 容器迭代器失效增加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Iterator_Base</span>(iterator* curiterator=<span class="literal">nullptr</span>,</span><br><span class="line"> Iterator_Base* next=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_curiterator = curiterator;</span><br><span class="line">_next = next;</span><br><span class="line">&#125;</span><br><span class="line">iterator* _curiterator;</span><br><span class="line">Iterator_Base* _next;</span><br><span class="line">&#125;;</span><br><span class="line">Iterator_Base _head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyVector&lt;&gt; <span class="built_in">myv</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">myv.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//要使用iterator</span></span><br><span class="line">MyVector&lt;&gt;::iterator it = myv.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it != myv.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 使用 iterator 是通用做法，提供[]只适合内存连续 有意义的</span></span><br><span class="line"><span class="comment">// 使用[]运算符重载</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myv.<span class="built_in">getSize</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; myv[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用C++11 的foeach</span></span><br><span class="line"><span class="comment">//其底层原理就是通过iterator来实现容器遍历的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : myv)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!myv.<span class="built_in">empty</span>())<span class="comment">//进行打印 OK的</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; myv.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">myv.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : myv)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//在容器里面，在容器的奇数前面 都添加上一个小于1的偶数</span></span><br><span class="line">MyVector&lt;<span class="type">int</span>&gt;::iterator it1 = myv.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != myv.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*it1) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">it1 = myv.<span class="built_in">insert</span>(it1, (*it1) - <span class="number">1</span>);</span><br><span class="line">++it1;</span><br><span class="line">&#125;</span><br><span class="line">++it1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : myv)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//把容器中的奇数都删掉</span></span><br><span class="line">MyVector&lt;<span class="type">int</span>&gt;::iterator it2 = myv.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != myv.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*it2) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">it2 = myv.<span class="built_in">erase</span>(it2);</span><br><span class="line"><span class="keyword">else</span> ++it2;<span class="comment">//没有删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : myv)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><p>new delete两个运算符的调用，实质上也是两个运算符重载函数的调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> -&gt; <span class="keyword">operator</span> <span class="keyword">new</span></span><br><span class="line"><span class="keyword">delete</span> -&gt; <span class="keyword">operator</span> <span class="keyword">delete</span></span><br></pre></td></tr></table></figure><p>new和malloc的区别：</p><ol><li>malloc是按字节开辟内存的:malloc(sizeof(int)10);它不管内存上放什么数据的。开辟完内存之后返回的是void 需要人为的类型强转。而new开辟内存时需要指定类型，并直接给出开辟元素的个数。new int[10];实质上调用operator new（），返回的类型就是自动的就是你给定的类型指针。int* 。</li><li>malloc只负责开辟内存，而new不仅仅具有malloc的功能，还具有数据的初始化操作。</li><li>malloc开辟内存失败 返回nullptr；new的则是抛出bad_alloc类型的异常（不可以进行与nullptr的比较），需要把new开辟内存的代码放在 try catch里面。</li><li>malloc开辟单个元素和数组的内存都是一样的（给字节数就行）；new的 对于单个字符不需要加上[]的,对于数组需要加[]并指定个数就可以了。</li></ol><p>free与delete的区别：</p><ol><li>delete 需要先进行调用析构函数，再free内存。但是对于 delete (int*)p，和free（p）是一样的。因为int 类型没有什么析构函数，只剩下内存释放。</li></ol><h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的本质：</p><ol><li>代码复用</li><li>在基类中提供统一的虚函数接口，让派生类重写，然后就可以使用多态</li></ol><p>类和类之间的关系：</p><ol><li>组合: a part of … …一部分的关系</li><li>继承: a kind of … …一种的关系</li></ol><p><strong>访问限定符权限</strong></p><div class="table-container"><table><thead><tr><th>继承方式</th><th>基类的访问限定</th><th>派生类的访问限定</th><th>(main)外部的访问限定</th></tr></thead><tbody><tr><td>public (class B : public A)</td><td>public</td><td>public 派生类里面可以访问</td><td>外部可以访问</td></tr><tr><td></td><td>protected</td><td>protected 派生类里面可以访问</td><td>外部不可以访问</td></tr><tr><td></td><td>private</td><td>不可见 派生类里面不可以访问</td><td>外部不可以访问</td></tr><tr><td>protected(class B: protected A)</td><td>public</td><td>protected 相当于降级为 protected</td><td>外部不可以访问</td></tr><tr><td></td><td>protected</td><td>protected 派生类里面可以访问</td><td>外部不可以访问</td></tr><tr><td></td><td>private</td><td>不可见 派生类里面不可以访问</td><td>外部不可以访问</td></tr><tr><td>protected(class B: private A)</td><td>public</td><td>private 相当于降级为 private 派生类里面可以访问</td><td>外部不可以访问</td></tr><tr><td></td><td>protected</td><td>private 相当于降级为 private 派生类里面可以访问</td><td>外部不可以访问</td></tr><tr><td></td><td>private</td><td>不可见 派生类里面不可以访问</td><td>外部不可以访问</td></tr></tbody></table></div><p>总结：</p><ol><li>外部只能访问对象 public 成员， protected 和 private 的成员无法直接访问</li><li>在继承结构中， 派生类从基类可以继承过来 private 的成员， 但是派生类无法直接访问</li><li>protected 和 private 的区别？ 在基类中定义的成员， 想被派生类访问， 但是不想被外部访问， 那么在基类中， 把相关成员定义成 protected 保护的； 如果派生类和外部都不打算访问， 那么在基类中， 就把相关成员定义成 private 私有的。</li></ol><p>protected 主要用于继承。</p><p><strong>默认的继承方式是什么？</strong></p><p>要看 派生类是用 class 定义的， 还是 struct 定义的。</p><ul><li>class 定义派生类， 默认继承方式是 private 私有的。class 的成员默认是 private 权限。</li><li>struct 定义派生类， 默认继承方式是 public 公有的。 struct 默认是 public 权限。</li></ul><p><strong>派生类的构造过程</strong></p><p>派生类从基类可以继承来所有的成员（变量和方法），<strong>除构造函数和析构函数</strong></p><p>派生类怎么初始化从基类继承来的成员变量呢？通过调用<strong>基类相应的构造函数来初始化</strong>。</p><p>派生类的构造函数和析构函数，负责初始化和清理派生类部分</p><p>派生类从基类继承来的成员由基类的构造函数和析构函数负责。</p><p><strong>派生类对象构造和析构的过程</strong></p><ol><li>派生类调用基类的构造函数，初始化从基类继承来的成员</li><li>调用派生类自己的构造函数，初始化派生类自己特有的成员</li><li>… 派生类对象的作用域到期了</li><li>调用派生类的析构函数，释放派生类成员可能占用的外部资源（堆内存，文件）</li><li>调用基类的析构函数，释放派生类内存中，从基类继承来的成员可能占用的外部资源（堆内存，文件）</li></ol><p><strong>派生类和基类赋值问题</strong></p><ul><li>派生类对象可以赋值给基类对象， 派生类对象中含有基类部分【多可以到少】</li><li>基类对象不可以赋值给派生类对象， 因为基类中不含派生类部分【多可以到少】</li><li>基类指针 （ 引用） 可以指向派生类， 但是只能访问派生类的基类部分</li><li>派生类指针 （ 引用） 不可以指向基类， 因为派生类的指针会超出基类对象的范围， 不合法【类型强转】</li></ul><h3 id="重载、隐藏、覆盖"><a href="#重载、隐藏、覆盖" class="headerlink" title="重载、隐藏、覆盖"></a>重载、隐藏、覆盖</h3><p><strong>重载关系</strong></p><p>一组函数要重载，必须处在同一作用域中；而且函数名字相同，参数列表不同。</p><p><strong>隐藏关系</strong></p><p>在继承结构中，派生类的同名成员把基类的同名成员给隐藏了，也就是调用的时候调用的是派生类的成员函数。要调用基类那就加作用域，（比如 Base::show）</p><p>把继承结构也说成从上（基类）到下（派生类）的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Base</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">Derive</span>(<span class="number">20</span>);</span><br><span class="line">b = d; <span class="comment">// 基类对象b &lt;- 派生类对象d类型从下到上的转换允许</span></span><br><span class="line">d = b; <span class="comment">// 派生类对象d &lt;- 基类对象b类型从上到下的转换不允许</span></span><br><span class="line">Base *pb = &amp;d; <span class="comment">// 基类指针（引用） &lt;- 派生类对象  类型从下到上的转换允许</span></span><br><span class="line">Derive *pd = &amp;b; <span class="comment">// 派生类指针（引用） &lt;- 基类对象。   类型从上到下的转换       不允许</span></span><br><span class="line"><span class="comment">// 在继承结构中进行上下的类型转换，默认只支持从下到上的类型转换</span></span><br></pre></td></tr></table></figure><h3 id="虚函数、静态绑定和动态绑定"><a href="#虚函数、静态绑定和动态绑定" class="headerlink" title="虚函数、静态绑定和动态绑定"></a>虚函数、静态绑定和动态绑定</h3><p><strong>静态绑定和动态绑定的概念</strong></p><ul><li>静态绑定：静态–编译时期；绑定–函数的调用</li><li>动态绑定：动态–运行时期；绑定–函数的调用</li></ul><p><strong>虚函数 virtual</strong></p><ol><li><p>一个类里面定义了虚函数，那么编译阶段，编译器会给这个类类型产生一个唯一的 vftable 虚函数表，虚函数表中主要存储的内容就是 RTTI （run-time type information）指针和虚函数的地址。当程序运行时，每一张虚函数表都会加载到内存的 .rodata 区(read only data)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240504104928494.png" alt="image-20240504104928494"></p></li><li><p>一个类里面定义了虚函数，那么这个类定义的对象，其运行时，内存中开始部分，多存储一个 vfptr 虚函数指针，指向相应类型的虚函数表 vftable。一个类型定义的 n 个对象，它们的 vfptr 指向的都是同一张虚函数表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240504105018672.png" alt="image-20240504105018672"></p></li><li><p>一个类里面虚函数的个数，不影响对象内存大小(vfptr)，影响的是虚函数表的大小。</p></li><li><p>如果派生类中的方法，和基类继承来的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 virtual 虚函数，那么派生类的这个方法，自动处理成虚函数。</p></li><li><p>在派生类中的虚函数表， 如果重写了方法， 那么虚函数表中原本基类的虚函数地址， 被派生类的虚函数地址覆盖调用过程： 基类指针指向派生类对象， 调用函数， 先去基类查看函数的类型， 如果是普通函数， 那么就是静态绑定， 直接调用父类函数。 如果发现是虚函数， 那么进行动态绑定， 首先查看对象的前四个字节 （ 虚函数表） 找到虚函数中的虚函数地址。</p><p>​    重写《=》覆盖</p><p><strong>覆盖：虚函数表中虚函数地址的覆盖</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// virtual void show(),因为这个函数和基类同名，自动处理成虚函数</span></span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240504110035559.png" alt="image-20240504110035559"></p></li></ol><p>看个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Drive\n&quot;</span>; &#125; <span class="comment">// virtual void show(),因为这个函数和基类同名，自动处理成虚函数</span></span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Drive d;</span><br><span class="line">    Base *p = (Base *)&amp;d;</span><br><span class="line">    p-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是Base类，当p调用的，p.show先去Base类中查看show是不是virtual：</p><ul><li>不是，则静态绑定，直接调用Base中的show方法。</li><li>是，则运行时期从代码看，运行时期指向子类Drive类，Drive类中存在从父类继承的虚函数表，那么就从中调用。</li></ul><p>如果这样呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="built_in">show</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>也是动态绑定，调用子类的虚函数表中查找。</p><p>Q：哪些函数不能实现成虚函数？</p><p>虚函数依赖：</p><ol><li><p>虚函数能产生地址，存储在 vftable 当中</p></li><li><p>对象必须存在，(vfptr -&gt; vftable -&gt; 虚函数地址)</p></li></ol><p>构造函数：</p><ol><li>构造函数前面不能加 virtual</li><li>构造函数中（调用的任何函数都是静态绑定）调用虚函数，也不会进行动态绑定</li></ol><p>派生类对象构造过程 先调用基类的构造函数，然后才调用派生类的构造函数</p><ol><li>static 静态成员方法。对象都没有，也就不能 static 前面加 virtual</li></ol><p><strong>再谈动态绑定</strong></p><p>虚函数和动态绑定的问题：是不是虚函数的调用一定就是动态绑定？ 肯定不是的！</p><p>在类的构造函数中，调用虚函数，也是静态绑定（构造函数中调用其他函数（虚），不会发生动态绑定）</p><p>用对象本身调用虚函数，属于静态绑定</p><p>动态绑定，必须由指针调用虚函数（Base *pb1 = &b;），或者必须由引用变量调用虚函数（Base &amp;rb1 = b;）</p><p><strong>虚函数通过指针或者引用变量调用，才发生动态绑定</strong></p><p><strong>多态</strong></p><ul><li><p>静态（编译时期）的多态：函数重载、模板（函数模板和类模板）</p></li><li><p>动态（运行时期）多态：在继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名覆盖方法（虚函数）。基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为多态。多态底层是通过动态绑定来实现的。</p></li></ul><p><strong>抽象类</strong></p><p>抽象类：有纯虚函数的类【为什么要有抽象类？属实不知道这个类抽象成什么实体】</p><p>抽象类不能再实例化对象了，到那时可以定义指针和引用变量。</p><p><strong>菱形继承</strong></p><p>待填坑。</p><h2 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h2><ul><li><a href="https://mrbananazly.github.io/2023/03/22/cpp_STL_note/">初级STL笔记</a></li></ul><h2 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h2><p>对象使用过程中调用了哪些方法</p><p><strong>case1:</strong>C++编译器对于对象构造的优化。用临时对象生成新对象时，临时对象就不产生了。直接构造新对象即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test t4=<span class="built_in">Test</span>(<span class="number">20</span>) <span class="comment">// Test t4(20)；没有区别 《-拷贝构造</span></span><br></pre></td></tr></table></figure><p><strong>case2:</strong>3个效果引用，都是赋值运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>t4=<span class="built_in">Test</span>(<span class="number">20</span>)  <span class="comment">// </span></span><br><span class="line"><span class="number">2.</span>t4=(Test)<span class="number">20</span> <span class="comment">// 显式 【显式生成临时对象生命周期：所在语句】</span></span><br><span class="line"><span class="number">3.</span>t4=<span class="number">30</span>   <span class="comment">// 隐式</span></span><br></pre></td></tr></table></figure><p>case3:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test *p=&amp;<span class="built_in">Test</span>(<span class="number">40</span>) <span class="comment">// p指向的是一个已经析构的临时对象【之后就会有野指针了】</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Test &amp;p = <span class="built_in">Test</span>(<span class="number">40</span>) <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>Test *p = &amp;Test(40)这行代码有问题，是因为Test(40)创建了一个临时对象，这个对象在该行代码执行完后就会被销毁，所以p指向的内存区域是未定义的，这样是非法的。</p><p>而const Test &amp;p = Test(40)则是合法的，这是因为const引用延长了临时对象的生命周期。在这种情况下，临时对象会一直存在，直到对应的const引用p不再使用。所以，p引用的对象在其生命周期内始终是有效的。</p><p>总的来说，这两种情况的区别在于const引用对临时对象的生命周期进行了延长，而普通指针则没有这个特性。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240504112620253.png" alt="image-20240504112620253"></p><p><strong>总结：3条对象优化规则</strong></p><ul><li><p>函数参数传递过程中，对象优先按引用传递。【防止对象切片】</p></li><li><p>函数返回的时候，应优先返回一个临时对象，而不要返回一个定义的对象。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240504112419307.png" alt="image-20240504112419307"></p></li><li><p>接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按照赋值方式接受</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240504112507471.png" alt="image-20240504112507471"></p></li></ul><p><strong>【精华】用临时对象生成新对象，临时对象就不产生了。</strong></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>为什么要有智能指针这个东西？裸指针不好吗？</p><p>裸指针到底有什么不好，比如下面的原因：</p><ol><li>有写free或者delete，忘记释放资源，导致资源泄露（发生了内存泄漏）</li><li>同一资源释放多次，导致释放野指针，程序崩溃</li><li>明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间return掉了，导致释放资源的代码未被执行到。</li><li>代码运行过程中一旦发生异常，随着异常栈展开，导致释放资源的代码未被执行到。</li></ol><p>那有没有什么办法自动负责管理这些资源。答案就是智能指针。</p><p><strong>智能指针的特点</strong>：主要体现在用户可以不关注资源的释放，因为智能指针会自动完全管理资源的释放，它会保证无论程序逻辑如何进行，正常执行还是发生异常，资源在到期的情况下，一定会进行资源的自动释放。智能指针就是对普通指针（裸指针）的一层封装（面向对象的），在构造函数中初始化资源地址，在析构函数中负责释放资源。利用栈上的对象出作用域会自动析构这么一个特点，把资源释放的代码全部放在这个析构函数中执行。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySmartptr</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MySmartptr</span>(T *ptr = <span class="literal">nullptr</span>) : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MySmartptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MySmartptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    (*p1).<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个问题：智能指针可不可以定义到堆上？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; *p = <span class="keyword">new</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>但是最后不是得手动·delete，那和裸指针没有区别了。</p><h3 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h3><p>如果在最开始的示例中，改成如下语句，会发送什么事情？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MySmartptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">p1-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="function">MySmartptr&lt;Test&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure><p>pro：在智能指针对象析构的时候，同一份资源释放了两次。第二次 是在释放野指针。也就是，我们常说的，默认拷贝构造函数：<strong>发生浅拷贝</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySmartptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MySmartptr</span>(T *ptr = <span class="literal">nullptr</span>) : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line">    <span class="built_in">MySmartptr</span>(<span class="type">const</span> MySmartptr&lt;T&gt; &amp;obj)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = <span class="keyword">new</span> <span class="built_in">T</span>(obj.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，需要加上拷贝构造函数。</p><p>那智能指针这块是怎么解决这个浅拷贝问题呢？</p><p>不带引用计数的智能指针</p><ol><li>auto_ptr</li><li>scoped_ptr</li><li>unique_ptr</li></ol><blockquote><p><strong>auto_ptr</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">*p2=<span class="number">20</span>;</span><br><span class="line">cout&lt;&lt;*p1&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>程序运行崩溃！</p><p>查看源码就可以知道了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span></span><br><span class="line"><span class="function"><span class="title">auto_ptr</span><span class="params">(auto_ptr&lt;_Tp1&gt;&amp; __a)</span> <span class="title">throw</span><span class="params">()</span> : _M_ptr(__a.release()) &#123;</span> &#125;</span><br></pre></td></tr></table></figure><p>release方法：把ptr1的 <em> mptr值给ptr2的</em> mptr，意思就是ptr2的_  mptr指向了原来ptr1的堆内存。然后把ptr1的_mptr置为nullptr，意思是ptr1放弃了堆内存的指向。</p><p>总结：auto_ptr解决浅拷贝的方法如下：<br>首先其成员变量只有一个裸指针，没有引用计数。<strong>永远让最后一个智能指针对象去 管理资源。其余前面的智能指针对象的_mptr置为nullptr，意思是他们放弃了堆内存的指向。</strong></p><blockquote><p><strong>scoped_ptr</strong></p></blockquote><p>scoped_ptr：不能拷贝构造和赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scoped_ptr</span>(scoped_ptr <span class="type">const</span> &amp;)=<span class="keyword">delete</span>;</span><br><span class="line">scoped_ptr &amp; <span class="keyword">operator</span>=(scoped_ptr <span class="type">const</span> &amp;)=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>unique_ptr</strong></p></blockquote><p>底层提供了移动拷贝和移动赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr <span class="type">const</span> &amp;)=<span class="keyword">delete</span>;</span><br><span class="line">unique_ptr &amp; <span class="keyword">operator</span>=(unique_ptr <span class="type">const</span> &amp;)=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(move(p1))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h3><p><strong>引用计数的智能指针：多个智能指针可以管理同一份资源。</strong></p><p>什么是带引用计数的智能指针？当允许多个智能指针对象指向同一个资源的时候，每一个智能指针对象都会给资源的引用计数加1，当一个智能指针对象析构时，同样会使资源的引用计数减1，这样最后一个智能指针把资源的引用计数从1减到0时，就说明该资源可以释放了，由最后一个智能指针对象的析构函数来处理资源的释放问题，这就是很好的解决了 智能指针的浅拷贝问题。</p><p><strong>shared_ptr和weak_ptr都是线程安全。</strong></p><p>来看个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//对资源进行引用计数的类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResouseCount</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ResouseCount</span>(T* mReptr = <span class="literal">nullptr</span>) :_mReptr(mReptr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ResouseCount()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (_mReptr != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_mcount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> _mcount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">~<span class="built_in">ResouseCount</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~ResouseCount()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _mReptr;</span><br><span class="line">_mReptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addResouseCont</span><span class="params">()</span><span class="comment">//引用计数+1,增加资源的引用计数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_mcount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delResouseCont</span><span class="params">()</span><span class="comment">//引用计数-1,减少资源的引用计数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_mcount--;</span><br><span class="line"><span class="keyword">return</span> _mcount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _mReptr;<span class="comment">//记录资源的地址</span></span><br><span class="line"><span class="type">int</span> _mcount;<span class="comment">//资源的引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//智能指针 保证可以做到资源的自动释放</span></span><br><span class="line"><span class="comment">//利用栈上对象出作用域自动析构的特点，保证可以做到资源的自动释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySmartptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 在生成这个智能指针对象的时候，生成一个资源的引用计数对象</span></span><br><span class="line"><span class="built_in">MySmartptr</span>(T* mptr = <span class="literal">nullptr</span>) :_mptr(mptr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySmartptr()&quot;</span> &lt;&lt; endl;</span><br><span class="line">myRes = <span class="keyword">new</span> <span class="built_in">ResouseCount</span>&lt;T&gt;(_mptr);</span><br><span class="line"><span class="comment">//把_mptr传进去，即给这个资源建立了一个引用计数对象</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MySmartptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~MySmartptr()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (myRes-&gt;<span class="built_in">delResouseCont</span>() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _mptr;</span><br><span class="line">_mptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看似是在对 智能指针对象进行解引用，但是实际上是对底层的成员变量进行解引用</span></span><br><span class="line"><span class="comment">//返回值是引用，因为我们要改变指针指向的内存本身的值</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> *()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_mptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给指向符  提供运算符重载函数 其实是：</span></span><br><span class="line"><span class="comment">(ptr2.operator-&gt;())-&gt;show();</span></span><br><span class="line"><span class="comment">即：智能指针对象调用指向符运算符重载函数，然后返回的结</span></span><br><span class="line"><span class="comment">果（返回智能指针对象底层管理的指针）再去调用后面的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()<span class="comment">//指向 运算符重载函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _mptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数，当前的智能指针对象也要指向这个资源</span></span><br><span class="line"><span class="built_in">MySmartptr</span>(<span class="type">const</span> MySmartptr&lt;T&gt;&amp; src) </span><br><span class="line">:_mptr(src._mptr), <span class="built_in">myRes</span>(src.myRes)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySmartptr(const &amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//引用了一个有效的资源</span></span><br><span class="line"><span class="comment">//相当于 两个智能指针对象都指向了这块资源，需要增加资源的引用计数</span></span><br><span class="line"><span class="keyword">if</span> (_mptr != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">myRes-&gt;<span class="built_in">addResouseCont</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MySmartptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySmartptr&lt;T&gt;&amp; src)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySmartptr&lt;T&gt;&amp; operator=(const MySmartptr&lt;T&gt;&amp; src)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (myRes-&gt;<span class="built_in">delResouseCont</span>() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _mptr;</span><br><span class="line">&#125;</span><br><span class="line">_mptr = src._mptr;</span><br><span class="line">myRes = src.myRes;<span class="comment">//当前智能指针也指向了这块资源</span></span><br><span class="line"></span><br><span class="line">myRes-&gt;<span class="built_in">addResouseCont</span>();<span class="comment">//当前资源的引用计数+1</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拷贝构造函数 和 赋值运算符重载函数，并没有去开辟新的资源</span></span><br><span class="line"><span class="comment">而是给这个资源添加了引用计数。有效的避免了 多个智能指针引用同一块资源</span></span><br><span class="line"><span class="comment">然后对同一个资源进行多次的释放。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _mptr;<span class="comment">//指向资源的指针</span></span><br><span class="line">ResouseCount&lt;T&gt; * myRes;<span class="comment">//指向该资源引用计数对象的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MySmartptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">MySmartptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">MySmartptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">ptr3 = ptr2;</span><br><span class="line"></span><br><span class="line">*ptr1 = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*ptr2:&quot;</span> &lt;&lt; *ptr2 &lt;&lt; <span class="string">&quot;   *ptr3:&quot;</span> &lt;&lt; *ptr3 &lt;&lt; endl;<span class="comment">//20 20</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>myRes-&gt;delResouseCont()语句解释：</p><p>在这个函数中，myRes-&gt;delResouseCont()的作用是减少当前智能指针所指向资源的引用计数。这是因为在赋值操作中，我们假设当前的智能指针将不再指向原来的资源，因此需要减少原来资源的引用计数。接着，我们检查引用计数是否为0，如果是0，那么说明没有任何智能指针再指向这个资源了，因此我们可以安全地删除这个资源，这就是if (myRes-&gt;delResouseCont() == 0) { delete _mptr; }的作用。</p><h3 id="shared-ptr-的交叉引用问题"><a href="#shared-ptr-的交叉引用问题" class="headerlink" title="shared_ptr 的交叉引用问题"></a>shared_ptr 的交叉引用问题</h3><ul><li>shared_ptr：强智能指针，可以改变资源的引用计数</li><li>weak_ptr：弱智能指针，不会改变资源的引用计数</li></ul><p>weak_ptr来观察shared_ptr，而shared_ptr来观察资源。</p><p>看个资源泄露的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 构造函数是给成员变量做初始化的</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 析构函数是在对象内存释放之前，把对象占有的外部资源进行释放</span></span><br><span class="line">    shared_ptr&lt;B&gt; ptr_b; <span class="comment">// 指向B类型对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 构造函数是给成员变量做初始化的</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 析构函数是在对象内存释放之前，把对象占有的外部资源进行释放</span></span><br><span class="line">    shared_ptr&lt;A&gt; ptr_a; <span class="comment">// 指向A类型对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// A 类型实例化的智能指针pa 来管理A对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// B 类型实例化的智能指针pb 来管理B对象</span></span><br><span class="line"></span><br><span class="line">    pa-&gt;ptr_b = pb;</span><br><span class="line">    pb-&gt;ptr_a = pa;</span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印它所引用资源的引用计数</span></span><br><span class="line">    cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>new出来的对象，没有释放，资源泄漏了。</p><p>这个问题又该怎么解决呢？</p><p>方法：<strong>定义对象的时候，用强智能指针;引用对象的地方，使用弱智能指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 构造函数是给成员变量做初始化的</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 析构函数是在对象内存释放之前，把对象占有的外部资源进行释放</span></span><br><span class="line">    weak_ptr&lt;B&gt; ptr_b; <span class="comment">// 指向B类型对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 构造函数是给成员变量做初始化的</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 析构函数是在对象内存释放之前，把对象占有的外部资源进行释放</span></span><br><span class="line">    weak_ptr&lt;A&gt; ptr_a; <span class="comment">// 指向A类型对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// A 类型实例化的智能指针pa 来管理A对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// B 类型实例化的智能指针pb 来管理B对象</span></span><br><span class="line"></span><br><span class="line">    pa-&gt;ptr_b = pb;</span><br><span class="line">    pb-&gt;ptr_a = pa;</span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印它所引用资源的引用计数</span></span><br><span class="line">    cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-<span class="keyword">virtual</span>-machine  ~/Desktop/MordenCpp  ./<span class="function">main                       </span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">1</span></span><br><span class="line"><span class="function">1</span></span><br><span class="line"><span class="function">~<span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">~<span class="title">A</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>Note：弱智能指针只会观察资源，不可以去使用和访问资源。弱智能指针 这个类就没有提供 * 运算符重载 和 -&gt; 运算符重载 函数。因此需要将弱智能指针升级成强智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<span class="comment">//构造函数是给成员变量做初始化的</span></span><br><span class="line">~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">//析构函数是在对象内存释放之前，把对象占有的外部资源进行释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_A</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;类A的成员方法&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">//shared_ptr&lt;B&gt;ptr_b;//指向B类型对象的智能指针</span></span><br><span class="line">weak_ptr&lt;B&gt;ptr_b;<span class="comment">//指向B类型对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<span class="comment">//构造函数是给成员变量做初始化的</span></span><br><span class="line">~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">//析构函数是在对象内存释放之前，把对象占有的外部资源进行释放</span></span><br><span class="line"><span class="comment">//shared_ptr&lt;A&gt;ptr_a;//指向A类型对象的智能指针</span></span><br><span class="line">weak_ptr&lt;A&gt;ptr_a;<span class="comment">//指向A类型对象的智能指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ptr_a-&gt;fun_A();//不可以进行访问</span></span><br><span class="line">shared_ptr&lt;A&gt; strongPtr = ptr_a.<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">//把ptr_a提升成一个强智能指针</span></span><br><span class="line"><span class="keyword">if</span> (strongPtr != <span class="literal">nullptr</span>)<span class="comment">//提升成功</span></span><br><span class="line">strongPtr-&gt;<span class="built_in">fun_A</span>();<span class="comment">//这样就可以访问了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提升成功  strongPtr就是一个强智能指针了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">shared_ptr&lt;A&gt;<span class="built_in">pa</span>(<span class="keyword">new</span> <span class="built_in">A</span>());<span class="comment">//A 类型实例化的智能指针pa 来管理A对象</span></span><br><span class="line">shared_ptr&lt;B&gt;<span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>());<span class="comment">//B 类型实例化的智能指针pb 来管理B对象</span></span><br><span class="line"></span><br><span class="line">pa-&gt;ptr_b = pb;</span><br><span class="line">pb-&gt;ptr_a = pa;</span><br><span class="line"></span><br><span class="line">pb-&gt;<span class="built_in">fun</span>();</span><br><span class="line">cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//打印它所引用资源的引用计数</span></span><br><span class="line">cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程访问共享对象的线程安全问题"><a href="#多线程访问共享对象的线程安全问题" class="headerlink" title="多线程访问共享对象的线程安全问题"></a>多线程访问共享对象的线程安全问题</h3><p>例子1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类A的方法\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;B&gt; ptr_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(weak_ptr&lt;A&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    shared_ptr&lt;A&gt; check = q.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (check)</span><br><span class="line">    &#123;</span><br><span class="line">        check-&gt;<span class="built_in">fun_A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;object is delete\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">t1</span><span class="params">(handler, weak_ptr&lt;A&gt;(p))</span></span>;</span><br><span class="line">        t1.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-<span class="keyword">virtual</span>-machine  ~/Desktop/MordenCpp  ./main                       </span><br><span class="line">A</span><br><span class="line">~A</span><br><span class="line">object is <span class="keyword">delete</span></span><br></pre></td></tr></table></figure><p>将上述代码改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类A的方法\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;B&gt; ptr_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(weak_ptr&lt;A&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    shared_ptr&lt;A&gt; check = q.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (check)</span><br><span class="line">    &#123;</span><br><span class="line">        check-&gt;<span class="built_in">fun_A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;object is delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">t1</span><span class="params">(handler, weak_ptr&lt;A&gt;(p))</span></span>;</span><br><span class="line">        t1.<span class="built_in">detach</span>();</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-<span class="keyword">virtual</span>-machine  ~/Desktop/MordenCpp  ./main                       </span><br><span class="line">A</span><br><span class="line">类A的方法</span><br><span class="line">~A</span><br></pre></td></tr></table></figure><p>总结：解决多线程访问共享对象的线程安全问题，强弱智能指针shared_ptr和weak_ptr 可以在线程里面 通过资源计数来检测对象还活着吗</p><h3 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h3><p>C++11智能指针std::shared_ptr和std::unique_ptr都支持自定义删除器，本文将介绍自定义删除器的使用场景和使用方法。智能指针模板参数的第二个类型是删除器，一般是一个函数指针类型或者是一个函数对象类型。通常情况下，删除器的类型是std::default_delete&lt; T &gt;，它是一个函数对象类型，用于调用delete来释放所管理的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = std::default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = std::default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> shared_ptr;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><p>自定义删除器的作用是在智能指针释放所管理的对象时，执行一些特殊的操作，比如：</p><ul><li>内存释放时打印一些日志。</li><li>管理除内存以外的其它资源，例如文件句柄、数据库连接等。</li><li>与自定义分配器（Allocator）配合使用，将资源释放给自定义分配器。</li><li>在C++17之前，std::shared_ptr用于管理数组时需要自定义删除器来释放数组内存，因为默认使用delete来释放所管理的对象，而delete不能正确释放分配的数组，需要在自定义删除器delete[]释放数组。</li></ul><p>这部分可以参考Effective书籍。</p><h2 id="绑定器和function函数对象"><a href="#绑定器和function函数对象" class="headerlink" title="绑定器和function函数对象"></a>绑定器和function函数对象</h2><h3 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h3><p><strong>函数对象：</strong> 拥有operator()运算符重载函数的对象，且这个对象的使用 类似于函数调用。</p><p>STL中提供了的绑定器函数bind1st和bind2nd，它们将一个二元函数对象转化为一个一元函数对象。</p><ul><li>bind1st()是绑定第一个参数。</li><li>bind2nd()是绑定第二个参数。</li></ul><p>看个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[] = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span> cx;</span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are not less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="number">4</span> elements that are less than <span class="number">40.</span></span><br><span class="line">There are <span class="number">1</span> elements that are <span class="keyword">not</span> less than <span class="number">40.</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>bind1st将参数绑定到二元函数对象的第一个参数，例如bind1st(less&lt; int &gt;(), 40)将创建一个新的一元函数对象，这个函数对象将检查给定的参数是否大于40。</li><li>bind2nd将参数绑定到二元函数对象的第二个参数，例如bind2nd(less&lt; int &gt;(), 40)将创建一个新的一元函数对象，这个函数对象将检查给定的参数是否小于40。</li></ul><p>bind2nd(less&lt; int &gt;(), 40)用于计算数组中小于40的元素的数量，而bind1st(less&lt; int &gt;(), 40)用于计算数组中不小于40的元素的数量。因此，bind1st和bind2nd的区别在于它们将参数绑定到二元函数对象的不同位置。</p><p>通过上面的示例我们对于绑定器有了基本的了解。先记个结论：<strong>绑定器+二元函数对象 = 一元函数对象</strong>。</p><p>再来看个示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    <span class="comment">// for (auto it : v)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">typename</span> T::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// typename T::iterator it = v.begin();</span></span><br><span class="line">    <span class="keyword">for</span> (; it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">40</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="comment">// greater&lt;int&gt;()函数对象  二元函数对象：需要两个元素一一进行比较</span></span><br><span class="line">    <span class="comment">// 一次从容器里面拿出来2个元素</span></span><br><span class="line">    <span class="comment">// 其operator（） 有两个参数 比较的是 &gt;</span></span><br><span class="line">    <span class="comment">// 而库里面 与排序有关的默认 从小到大 &lt; less</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="comment">// 需求1：把14插入容器其中</span></span><br><span class="line">    <span class="comment">// 30 &lt; x</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">30</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(it, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="comment">// 需求2：把14插入容器其中</span></span><br><span class="line">    <span class="comment">// x &lt; 10</span></span><br><span class="line">    it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(it, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们学习下这个bind()以及find_if底层的实现。</p><blockquote><p><strong>find_if</strong></p></blockquote><p>find_if的底层实现：第三个参数需要的是一个 一元函数对象。</p><p>思路：遍历 iterator区间的元素，如果满足函数对象的运算 则返回当前iterator 。否则返回end 当然这里需要一个一元的函数对象 其operator（）只需要接收一个参数即可 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="comment">//Compare:函数对象</span></span><br><span class="line"><span class="function">Iterator <span class="title">myfind_if</span><span class="params">(Iterator st, Iterator ed, Compare compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; st != ed; st++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">compare</span>(*st))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bind1st 和 bind2nd</strong></p></blockquote><p>先来了解下这个函数对象是怎么调用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span>  a = <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">cout&lt;&lt;<span class="built_in">a</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// greater&lt;int&gt;()(1,3)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道这个，下面就非常容易了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板 bind1st的实现</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数 是一个二元函数对象</span></span><br><span class="line"><span class="comment">第二个参数 是一个 元素的类型 val(要绑定的值)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mybind1stClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mybind1stClass</span>(Compare compare, T val) : <span class="built_in">compare_</span>(compare), <span class="built_in">val_</span>(val) &#123;&#125;</span><br><span class="line">    <span class="comment">// 既然是函数对象 需要有operator（）的实现</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 底层还是二元函数对象的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare_</span>(val_, val); <span class="comment">// 第1个值被绑定了 所以传入第2个值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare compare_;</span><br><span class="line">    T val_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mybind1st</span><span class="params">(Compare compare, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// //构造一个 一元函数对象出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mybind1stClass</span>&lt;Compare, T&gt;(compare, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind1st 是一个函数模板，里面封装了一个 一元函数对象的产生。 bind1st 就是函数对象的应用。绑定器+二元函数对象 = 一元函数对象。</p><p>bind2nd也很容易了。</p><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    <span class="comment">// for (auto it : v)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">typename</span> T::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// typename T::iterator it = v.begin();</span></span><br><span class="line">    <span class="keyword">for</span> (; it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">Iterator <span class="title">myfind_if</span><span class="params">(Iterator st, Iterator ed, Compare compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; st != ed; st++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">compare</span>(*st))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mybind1stClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mybind1stClass</span>(Compare compare, T val) : <span class="built_in">compare_</span>(compare), <span class="built_in">val_</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare_</span>(val_, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare compare_;</span><br><span class="line">    T val_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mybind1st</span><span class="params">(Compare compare, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mybind1stClass</span>&lt;Compare, T&gt;(compare, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mybind2ndClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mybind2ndClass</span>(Compare compare, T val) : <span class="built_in">compare_</span>(compare), <span class="built_in">val_</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare_</span>(val, val_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare compare_;</span><br><span class="line">    T val_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mybind2nd</span><span class="params">(Compare compare, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mybind2ndClass</span>&lt;Compare, T&gt;(compare, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">40</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="comment">// greater&lt;int&gt;()函数对象  二元函数对象：需要两个元素一一进行比较</span></span><br><span class="line">    <span class="comment">// 一次从容器里面拿出来2个元素</span></span><br><span class="line">    <span class="comment">// 其operator（） 有两个参数 比较的是 &gt;</span></span><br><span class="line">    <span class="comment">// 而库里面 与排序有关的默认 从小到大 &lt; less</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="comment">// 需求1：把14插入容器其中</span></span><br><span class="line">    <span class="comment">// 30 &lt; x</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">myfind_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">30</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(it, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="comment">// 需求2：把14插入容器其中</span></span><br><span class="line">    <span class="comment">// x &lt; 10</span></span><br><span class="line">    it = <span class="built_in">myfind_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mybind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(it, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是比较随机的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-<span class="keyword">virtual</span>-machine  ~/Desktop/MordenCpp  g++ main.cpp -o main -pthread</span><br><span class="line"> penge@penge-<span class="keyword">virtual</span>-machine  ~/Desktop/MordenCpp  ./main                       </span><br><span class="line"><span class="number">24</span> <span class="number">7</span> <span class="number">18</span> <span class="number">36</span> <span class="number">34</span> <span class="number">16</span> <span class="number">27</span> <span class="number">13</span> <span class="number">10</span> <span class="number">22</span> <span class="number">3</span> <span class="number">28</span> <span class="number">11</span> <span class="number">20</span> <span class="number">4</span> <span class="number">7</span> <span class="number">21</span> <span class="number">27</span> <span class="number">13</span> <span class="number">17</span> </span><br><span class="line"><span class="number">36</span> <span class="number">34</span> <span class="number">28</span> <span class="number">27</span> <span class="number">27</span> <span class="number">24</span> <span class="number">22</span> <span class="number">21</span> <span class="number">20</span> <span class="number">18</span> <span class="number">17</span> <span class="number">16</span> <span class="number">13</span> <span class="number">13</span> <span class="number">11</span> <span class="number">10</span> <span class="number">7</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">30</span> <span class="number">36</span> <span class="number">34</span> <span class="number">28</span> <span class="number">27</span> <span class="number">27</span> <span class="number">24</span> <span class="number">22</span> <span class="number">21</span> <span class="number">20</span> <span class="number">18</span> <span class="number">17</span> <span class="number">16</span> <span class="number">13</span> <span class="number">13</span> <span class="number">11</span> <span class="number">10</span> <span class="number">7</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">30</span> <span class="number">36</span> <span class="number">34</span> <span class="number">28</span> <span class="number">27</span> <span class="number">27</span> <span class="number">24</span> <span class="number">22</span> <span class="number">21</span> <span class="number">20</span> <span class="number">18</span> <span class="number">17</span> <span class="number">16</span> <span class="number">13</span> <span class="number">13</span> <span class="number">11</span> <span class="number">10</span> <span class="number">10</span> <span class="number">7</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>现在，bind1st() 和 bind2nd()，在 C++11 里已经 deprecated 了.bind()可以替代他们，且用法更灵活更方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[] = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span> cx;</span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">40</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>, std::placeholders::_1));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are not less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="function函数对象"><a href="#function函数对象" class="headerlink" title="function函数对象"></a>function函数对象</h3><p>C++中的std::function是一个强大而灵活的工具，它允许我们将可调用对象（函数、函数指针、Lambda表达式等）包装成一个对象，使得我们可以像操作其他对象一样操作和传递可调用对象。</p><p><strong>基本概念</strong></p><p>std::function是C++11引入的标准库组件，位于&lt; functional &gt;头文件中。它的主要作用是将可调用对象封装为一个函数对象，提供一种统一的方式来处理各种类型的可调用对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;返回类型(参数类型1, 参数类型2, ...)&gt; func;</span><br></pre></td></tr></table></figure><p><strong>使用示例</strong></p><p>1.封装函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = greet;</span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 调用封装的函数指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.封装Lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda says hi!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 调用封装的Lambda表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.封装可调用对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Class Greeter says hello!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = <span class="built_in">Greeter</span>();</span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 调用封装的可调用对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.与bind结合使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> printHello = std::<span class="built_in">bind</span>(func,<span class="string">&quot;Hello&quot;</span>,std::placeholders::_1);</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; tmp=printHello;</span><br><span class="line"><span class="built_in">tmp</span>(<span class="number">666</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,介绍完应用，我们来看看具体的原理</p><p>如果我们想使用function封装下面的函数，如果实现呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(string str)</span><br></pre></td></tr></table></figure><p>使用模板和函数对象的知识实现代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//C++库的函数对象</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">//C++库的泛型算法</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//这两行相当于 提供模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunction</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A&gt;<span class="comment">// 返回值、形参类型 属于部分特例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunction</span>&lt;<span class="built_in">R</span>(A)&gt; <span class="comment">// //因为这是一个函数类型（1返回值 1参数）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pFun = <span class="built_in">R</span> (*)(A);<span class="comment">// 定义这个函数指针类型</span></span><br><span class="line">    <span class="built_in">MyFunction</span>(pFun pFun) &#123; pFun_ = pFun; &#125;</span><br><span class="line">    <span class="comment">/* operator（）重载函数</span></span><br><span class="line"><span class="comment">        封装的这个函数需要什么参数，</span></span><br><span class="line"><span class="comment">        operator（）就需要什么函数</span></span><br><span class="line"><span class="comment">        需要接收1个参数 类型为A </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pFun_</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pFun pFun_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyFunction&lt;<span class="title">void</span><span class="params">(string)</span>&gt; <span class="title">f</span><span class="params">(show)</span></span>;</span><br><span class="line">    <span class="comment">// MyFunction&lt;void(string)&gt; f=show;</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的参数不确定呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(string str)</span><br><span class="line"><span class="built_in">void</span>(string str,<span class="type">int</span> a)</span><br><span class="line"><span class="built_in">void</span>(string str,<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由C++11里面的 可变参（形参个数不定）的类型参数 完美解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//C++库的函数对象</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">//C++库的泛型算法</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunction</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... A&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunction</span>&lt;<span class="built_in">R</span>(A...)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pFun = <span class="built_in">R</span> (*)(A...);</span><br><span class="line">    <span class="built_in">MyFunction</span>(pFun pFun) &#123; pFun_ = pFun; &#125;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pFun_</span>(val...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pFun pFun_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(string a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyFunction&lt;<span class="title">void</span><span class="params">(string, <span class="type">int</span>)</span>&gt; <span class="title">f</span><span class="params">(show)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">111</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda ：函数对象的升级版，原理就是更高级的函数对象的实现。</p><p>函数对象的缺点：虽然在使用中不会单独使用函数对象，而且也都是使用在 泛型算法的参数传递 或者 带有比较 或者优先级队列等自定义类型的元素比较方式 或者 智能指针的删除器 之中（就可以传递一个函数对象进去）。但是 但是 但是 函数对象 是需要自己先去定义一个函数对象类型 出来啊！！！！ 而且这个类型定义出来以后，这个类型定义的对象只是使用在 （例如：优先级队列的定义处），之后这个函数对象类型 可能再也不用了。</p><p>老样子，看个例子先</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> myfun1 = []()-&gt;<span class="type">void</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lambda: I Love Libaibai&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">myfun1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myfun2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">myfun2</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> myfun3 = [&amp;a,&amp;b]()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">myfun3</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现代C++11对此有比较深入的介绍。</p><p>再来看个常见的例子，也就是优先队列对自定义对象排序。</p><p>优先队列中使用lambda表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> ma = <span class="number">10</span>, <span class="type">int</span> mb = <span class="number">10</span>) : _ma(ma), _mb(mb) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> _ma;</span><br><span class="line">    <span class="type">int</span> _mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Test, vector&lt;Test&gt;, function&lt;<span class="type">bool</span>(Test &amp;, Test &amp;)&gt;&gt;</span><br><span class="line">    <span class="built_in">myqueue</span>([](Test &amp;t1, Test &amp;t2) -&gt; <span class="type">bool</span></span><br><span class="line">            &#123; <span class="keyword">return</span> t1._ma &gt; t2._ma; &#125;);</span><br><span class="line">    myqueue.<span class="built_in">push</span>(<span class="built_in">Test</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    myqueue.<span class="built_in">push</span>(<span class="built_in">Test</span>(<span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line">    myqueue.<span class="built_in">push</span>(<span class="built_in">Test</span>(<span class="number">20</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">auto</span> cur = myqueue.<span class="built_in">top</span>();</span><br><span class="line">    myqueue.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; cur._ma;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    auto func = [](Test &amp;t1, Test &amp;t2) -&gt; bool</span></span><br><span class="line"><span class="comment">    &#123; return t1._ma &gt; t2._ma; &#125;;</span></span><br><span class="line"><span class="comment">    priority_queue&lt;Test, vector&lt;Test&gt;, function&lt;bool(Test &amp;, Test &amp;)&gt;&gt; myqueue(func);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：</p><ul><li><a href="https://suqingyu.com/2023/09/17/C++%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%80%BB%E7%BB%93/#%E5%89%8D%E8%A8%80">C++（基础）笔记与总结|</a></li></ul>]]></content>
    
    
    <summary type="html">C++11基础知识笔记</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>静态链接&amp;&amp;动态链接</title>
    <link href="https://penge666.github.io/posts/4551c130.html"/>
    <id>https://penge666.github.io/posts/4551c130.html</id>
    <published>2024-04-15T07:18:51.000Z</published>
    <updated>2024-04-22T01:39:52.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>程序猿在编程的代码无非是由函数和各种变量，以及对这些变量的读、写。不管是变量还是函数，它们最终都要存储在内存里。为每个变量和函数正确地分配内存空间，记录它们的地址，并把这个地址复写回调用或引用它们的地方。</p><p>而负责<strong>将这些符号转换成地址就是由链接器</strong>完成的 ~~~</p><p>通常分成3种情况：</p><p><strong>静态链接</strong>：</p><ul><li>生成二进制可执行文件的过程中。</li></ul><p><strong>动态链接</strong>：</p><ul><li>在二进制文件被加载进内存时。在二进制文件保留符号，在加载时再把符号解析成真实的内存地址</li><li>在运行期间解析符号。这种情况会把符号的解析延迟到最后不得不做时才去做符号的解析</li></ul><p>接下来，我将详细介绍这2种链接的具体工作原理。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这部分主要记录ELF文件格式，已经会的可以直接跳到链接部分。</p><p><strong>ELF：可执行和链接格式</strong></p><p>ELF格式文件不仅用于可执行文件，还可以存储可重定位目标文件、动态库文件等。也就是说，ELF文件既要承载编译的输出(可重定位目标文件)，又要承载链接的输出(可执行文件)，因此其文件格式需要同时满足这两个功能。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240416143913414.png" alt="image-20240416143913414"></p><h3 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="headerlink" title="可重定位目标文件格式"></a>可重定位目标文件格式</h3><p><strong>可重定位目标文件格式</strong></p><p>可重定位目标文件主要包含代码部分和数据部分，它可以与其他可重定位目标文件链接，从而创建可执行目标文件、共享库文件。</p><ul><li><p>可被链接（合并）生成可执行文件或共享目标文件；</p></li><li><p>静态链接库文件由若干个可重定位目标文件组成；</p></li><li><p>包含代码、数据（已初始化全局变量和局部静态变量.data和未初始化的全局变量和局部静态变量.bss）</p></li><li><p>包含重定位信息（指出哪些符号引用处需要重定位）</p></li><li><p>文件扩展名为.o（相当于Windows中的 .obj文件）</p><p>格式如下：由ELF头，节，节头表组成。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240415162724175.png" alt=""></p><p><strong>（1）ELF头</strong></p><p>readelf -h 命令对某个可重定位目标文件的 ELF 头进行解析</p><p>浅浅查看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp  readelf -h main.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          848 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br></pre></td></tr></table></figure><p><strong>ELF 头</strong>位于目标文件的起始位置，包含文件结构说明信息。分32位版本和64位版本。</p><p>32位系统对应的数据结构，共占 52（0x34） 字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">// 开始的四个字节是魔数，后面的16个字节包含一些标识信息，如字节序、32/64位、版本号等</span></span><br><span class="line">   Elf32_Half e_type;      <span class="comment">// 目标文件类型（可重定位文件、可执行文件、共享库文件还是其他类型文件）</span></span><br><span class="line">   Elf32_Half e_machine;   <span class="comment">// 机器结构类型（如 IA-32、AMD 64等）</span></span><br><span class="line">   Elf32_Word e_version;   <span class="comment">// 目标文件版本</span></span><br><span class="line">   Elf32_Addr e_entry;     <span class="comment">// 指定系统将控制权转移到的起始虚拟地址（程序入口点），如果没有关联入口点则为0，比如可重定位文件就是0</span></span><br><span class="line">   Elf32_Off e_phoff;</span><br><span class="line">   Elf32_Off e_shoff;      <span class="comment">// 节头表在文件中的偏移量（以字节为单位）</span></span><br><span class="line">   Elf32_Word e_flags;</span><br><span class="line">   Elf32_Half e_ehsize;    <span class="comment">// ELF 头的大小（以字节为单位）</span></span><br><span class="line">   Elf32_Half e_phentsize; </span><br><span class="line">   Elf32_Half e_phnum;</span><br><span class="line">   Elf32_Half e_shentsize; <span class="comment">// 节头表中一个表项的大小，所有表项大小相同</span></span><br><span class="line">   Elf32_Half e_shnum;     <span class="comment">// 节头表项的个数</span></span><br><span class="line">   Elf32_Half e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><ul><li>魔数：文件开头几个字节通常用来确定文件的类型或格式。<ul><li>a.out的魔数：01H 07H</li><li>PE格式魔数：4DH 5AH</li><li>加载或读取文件时，可用魔数确认文件类型是否正确</li></ul></li><li><p>仅 ELF 头在文件中具有固定位置，即总是在开头位置，其余部分的位置由 ELF 头和节头表指出。</p></li><li><p>因为是可重定位文件，<strong>所以字段 e_entry 为0，无程序头表</strong>（Size of program headers = 0）。</p></li></ul><p><strong>（2）节</strong></p><p>节是 ELF 文件中的主体信息，包含了链接过程所用的目标代码信息，包括指令、数据、符号表和重定位信息等。</p><div class="table-container"><table><thead><tr><th style="text-align:center">节名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">.text</td><td style="text-align:left">已编译程序的机器代码</td></tr><tr><td style="text-align:center">.rodata</td><td style="text-align:left">只读数据，如 printf 语句中的格式串、开关语句（switch-case）的跳转表等</td></tr><tr><td style="text-align:center">.data</td><td style="text-align:left">已初始化的全局变量</td></tr><tr><td style="text-align:center">.bss</td><td style="text-align:left">未初始化的全局和静态变量，以及所有被初始化为 0 的全局或静态变量。<strong>在目标文件中这个节不占据实际的空间</strong>，它仅仅是一个占位符，为了节省空间。在运行时，在内存中将这些变量初始化为 0。</td></tr><tr><td style="text-align:center">.symtab</td><td style="text-align:left">符号表（symbol table）,程序中定义的函数名和全局静态变量名都属于<strong>符号</strong>，与这些符号相关的信息保存在符号表中。每个可重定位目标文件都有一个 .symtab 节。和编译器中的符号表不同， .symtab 符号表不包含局部变量的条目。</td></tr><tr><td style="text-align:center">.rel.text</td><td style="text-align:left">.text 节相关的重定位信息。当链接器合并目标文件时，.text 中的代码合并后部分位置的数据需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改定位信息。另一方面，调用本地函数的指令则不需要修改。 TIP：可执行文件中并不需要重定位信息。</td></tr><tr><td style="text-align:center">.rel.data</td><td style="text-align:left">.data 节相关的可重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</td></tr><tr><td style="text-align:center">.debug</td><td style="text-align:left">调试用符号表。其条目是程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。</td></tr><tr><td style="text-align:center">.line</td><td style="text-align:left">C 源程序中的行号和 .text 节中机器指令之间的映射。</td></tr><tr><td style="text-align:center">.strtab</td><td style="text-align:left">字符串表。包括 .symtab 节和 .debug 节中的符号以及节头表中的节名。字符串表就是以 null 结尾的字符序列。</td></tr></tbody></table></div><p><strong>（3）节头表</strong></p><p>节头表（Section Header Table）由若干表项组成，每个表项描述相应的一个节的节名、在文件中的偏移、大小、访问属性、对齐方式等，目标文件中的每个节都有一个表项与之对应。</p><ul><li>除ELF头之外，节头表是ELF可重定位目标文件中最重要的部分内容。</li></ul><p>以下是 32 位系统对应的数据结构（每个表项占40B）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   Elf32_Word sh_name;  <span class="comment">// 节名字符串在.strtab中的偏移</span></span><br><span class="line">   Elf32_Word sh_type;  <span class="comment">// 节类型：无效/代码或数据/符号/字符串/…</span></span><br><span class="line">   Elf32_Word sh_flags; <span class="comment">// 节标志：该节在虚拟空间中的访问属性</span></span><br><span class="line">   Elf32_Addr sh_addr;  <span class="comment">// 虚拟地址：若可被加载，则对应虚拟地址</span></span><br><span class="line">   Elf32_Off sh_offset; <span class="comment">// 在文件中的偏移地址，对.bss节而言则无意义</span></span><br><span class="line">   Elf32_Word sh_size;  <span class="comment">// 节在文件中所占的长度</span></span><br><span class="line">   Elf32_Word sh_link;  <span class="comment">// sh_link和sh_info用于与链接相关的节（如.rel.text节、.rel.data节、.symtab节等）</span></span><br><span class="line">   Elf32_Word sh_info;</span><br><span class="line">   Elf32_Word sh_addralign;   <span class="comment">// 节的对齐要求</span></span><br><span class="line">   Elf32_Word sh_entsize;     <span class="comment">// 节中每个表项的长度，0表示无固定长度表项</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>比较特殊的一个地方：.bss 在文件中不占用空间，但节头表记录了 .bss 节的长度为 0x0c = 12，因此需要在主存中给 .bss 节分配 12 字节空间。</li></ul><p><strong>整体就是通过 ELF 头连接了节头表，再通过节头表把每一个节连接起来了。</strong></p><h3 id="可执行目标文件格式"><a href="#可执行目标文件格式" class="headerlink" title="可执行目标文件格式"></a>可执行目标文件格式</h3><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240415164614632.png" alt="image-20240415164614632"></p><p>与可重定文件稍有不同：</p><ul><li>ELF头中字段 e_entry 给出执行程序时第一条指令的地址，而在可重定位文件中，此字段为0；</li><li>多一个<strong>程序头表</strong>，也称段头表（segment header table），是一个结构数组，用来说明段信息；</li><li>多一个.init节，用于定义_init函数，该函数用来进行可执行目标文件开始执行时的初始化工作；</li><li>少两个.rel节（无需重定位）。</li></ul><p>在可执行文件中，ELF 头、程序头表、.init 节、.fini 节、.text 节和 .rodata 节合起来可构成一个<strong>只读代码段</strong>；.data 节和 .bss 节合起来可构成一个<strong>可读写数据段</strong>。显然，在可执行文件启动执行时，这两个段必须装入内存，因而称为<strong>可装入段</strong>。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><h3 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h3><p>先对链接器的的两步链接有个整体的认识：</p><p><strong>第一步是，链接器需要对编译器生成的多个目标（.o) 文件进行合并，采取的策略是相似段的合并，最终生成共享文件 (.so) 或者可执行文件</strong>。这个阶段中，链接器对输入的各个目标文件进行扫描，获取各个段的大小，并且同时会收集所有的符号定义以及引用信息，构建一个全局的符号表。当链接器构造好了最终的文件布局以及虚拟内存布局后，我们根据符号表，也就能确定了每个符号的虚拟地址了。</p><p><strong>第二步是，链接器会对整个文件再进行第二遍扫描，这一阶段，会利用第一遍扫描得到的符号表信息，依次对文件中每个符号引用的地方进行地址替换。也就是对符号的解析以及重定位过程</strong>。</p><p>简单来讲就是进行两遍扫描：第一遍扫描完成文件合并、虚拟内存布局的分配以及符号信息收集；第二遍扫描则是完成了符号的重定位过程。</p><p>接下来，我将分类讨论各种符号的处理方式。</p><p>在实操之前，先说<strong>总结</strong>：</p><ol><li>静态函数不需要重定位因为和执行单元代码都在.text段，相对位置在编译的时候就能确定了，因为链接器合并中间文件时相对位置不会变。</li><li>静态变量需要重定位，因为和编译单元代码段.text分属不同的section，在.data，链接器合并文件时会重新排布，所以需要重定位。</li><li>全局变量/函数，外部变量/函数都是需要被重定位的，大致方法就是：编译器先用0占位符号、链接重定位表找符号、定位符号地址、然后在当前代码段计算RIP相对偏移位置填上。</li></ol><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>开始实操</p><p>工具：readelf 查看 elf 文件 和 objdump 查看反汇编。</p><ul><li>objdump：对二进制文件进行反汇编</li><li>readelf ：解析二进制文件信息</li></ul><p>例子：</p><p>example.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> extern_var;</span><br><span class="line"><span class="type">int</span> global_var = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">extern_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">global_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var0 = extern_var;</span><br><span class="line">    <span class="type">int</span> var1 = global_var;</span><br><span class="line">    <span class="type">int</span> var2 = static_var;</span><br><span class="line">    <span class="type">int</span> var3 = <span class="built_in">extern_func</span>();</span><br><span class="line">    <span class="type">int</span> var4 = <span class="built_in">global_func</span>();</span><br><span class="line">    <span class="type">int</span> var5 = <span class="built_in">static_func</span>();</span><br><span class="line">    <span class="keyword">return</span> var0 + var1 + var2 + var3 + var4 + var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>external.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// external.c</span></span><br><span class="line"><span class="type">int</span> extern_var = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extern_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⚙ penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  gcc example.c -c -o example.o -fno-PIC -g</span><br><span class="line">⚙ penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  gcc external.c -c -o external.o -fno-PIC -g</span><br><span class="line">⚙ penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  gcc external.o example.o -o a.out -no-pie</span><br></pre></td></tr></table></figure><ul><li>-fno-PIC ：告诉编译器不要生成 PIC 的代码。</li></ul><p>我们将两个.o 文件链接生成可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc external.o example.o -o a.out -no-pie</span><br></pre></td></tr></table></figure><ul><li>-no-pie 表示关闭 pie 的模式。gcc 会默认打开 pie 模式，也就意味着系统 loader 对加载可执行文件时的起始地址，会随机加载。关闭 pie 之后，在 Linux 64 位的系统下，默认的加载起始地址是 0x400000。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  objdump -S example.o</span><br><span class="line"></span><br><span class="line">example.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;global_func&gt;:</span><br><span class="line">extern int extern_var;</span><br><span class="line">int global_var = 1;</span><br><span class="line">static int static_var = 2;</span><br><span class="line">extern int extern_func();</span><br><span class="line">int global_func()</span><br><span class="line">&#123;</span><br><span class="line">   0:f3 0f 1e fa          endbr64 </span><br><span class="line">   4:55                   push   %rbp</span><br><span class="line">   5:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    return 10;</span><br><span class="line">   8:b8 0a 00 00 00       mov    $0xa,%eax</span><br><span class="line">&#125;</span><br><span class="line">   d:5d                   pop    %rbp</span><br><span class="line">   e:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000000000f &lt;static_func&gt;:</span><br><span class="line">static int static_func()</span><br><span class="line">&#123;</span><br><span class="line">   f:f3 0f 1e fa          endbr64 </span><br><span class="line">  13:55                   push   %rbp</span><br><span class="line">  14:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    return 20;</span><br><span class="line">  17:b8 14 00 00 00       mov    $0x14,%eax</span><br><span class="line">&#125;</span><br><span class="line">  1c:5d                   pop    %rbp</span><br><span class="line">  1d:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000000001e &lt;main&gt;:</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  1e:f3 0f 1e fa          endbr64 </span><br><span class="line">  22:55                   push   %rbp</span><br><span class="line">  23:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  26:48 83 ec 20          sub    $0x20,%rsp</span><br><span class="line">    int var0 = extern_var;</span><br><span class="line">  2a:8b 05 00 00 00 00    mov    0x0(%rip),%eax        # 30 &lt;main+0x12&gt;</span><br><span class="line">  30:89 45 e8             mov    %eax,-0x18(%rbp)</span><br><span class="line">    int var1 = global_var;</span><br><span class="line">  33:8b 05 00 00 00 00    mov    0x0(%rip),%eax        # 39 &lt;main+0x1b&gt;</span><br><span class="line">  39:89 45 ec             mov    %eax,-0x14(%rbp)</span><br><span class="line">    int var2 = static_var;</span><br><span class="line">  3c:8b 05 00 00 00 00    mov    0x0(%rip),%eax        # 42 &lt;main+0x24&gt;</span><br><span class="line">  42:89 45 f0             mov    %eax,-0x10(%rbp)</span><br><span class="line">    int var3 = extern_func();</span><br><span class="line">  45:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  4a:e8 00 00 00 00       callq  4f &lt;main+0x31&gt;</span><br><span class="line">  4f:89 45 f4             mov    %eax,-0xc(%rbp)</span><br><span class="line">    int var4 = global_func();</span><br><span class="line">  52:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  57:e8 00 00 00 00       callq  5c &lt;main+0x3e&gt;</span><br><span class="line">  5c:89 45 f8             mov    %eax,-0x8(%rbp)</span><br><span class="line">    int var5 = static_func();</span><br><span class="line">  5f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  64:e8 a6 ff ff ff       callq  f &lt;static_func&gt;</span><br><span class="line">  69:89 45 fc             mov    %eax,-0x4(%rbp)</span><br><span class="line">    return var0 + var1 + var2 + var3 + var4 + var5;</span><br><span class="line">  6c:8b 55 e8             mov    -0x18(%rbp),%edx</span><br><span class="line">  6f:8b 45 ec             mov    -0x14(%rbp),%eax</span><br><span class="line">  72:01 c2                add    %eax,%edx</span><br><span class="line">  74:8b 45 f0             mov    -0x10(%rbp),%eax</span><br><span class="line">  77:01 c2                add    %eax,%edx</span><br><span class="line">  79:8b 45 f4             mov    -0xc(%rbp),%eax</span><br><span class="line">  7c:01 c2                add    %eax,%edx</span><br><span class="line">  7e:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">  81:01 c2                add    %eax,%edx</span><br><span class="line">  83:8b 45 fc             mov    -0x4(%rbp),%eax</span><br><span class="line">  86:01 d0                add    %edx,%eax</span><br><span class="line">&#125;</span><br><span class="line">  88:c9                   leaveq </span><br><span class="line">  89:c3                   retq</span><br></pre></td></tr></table></figure><p><strong>各种符号的处理方式</strong></p><p><strong>局部变量</strong></p><p>从反汇编的结果里，我们可以看到，局部变量在程序中的地址，都是基于 %rbp的偏移这种形式，rbp 寄存器存放的是当前函数栈帧的基地址。这些局部变量的内存分配与释放，都是在运行时通过 %rbp 的改变来进行的，因此，局部变量的内存地址不需要链接器来操心。</p><p><strong>静态函数</strong></p><p>它是唯一不需要重定位的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> int var5 = static_func();</span><br><span class="line">5f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">64:e8 a6 ff ff ff       callq  f &lt;static_func&gt;</span><br></pre></td></tr></table></figure><p>e8是callq指令的编码，后边 4个字节就对应被调函数的地址。</p><p>如果采用小端的字节序数值来表示0x ff ff ff a6也就是对应十进制的-90。</p><p>此时，当 CPU执行到 callq这条指令时，rip 寄存器的值指向的是下一条指令的内存地址，也就是 5d这条指令的内存地址，通过计算0x69 – 90可以得到 0xf。从反汇编中可以得到，0xf 刚好是 static_fun 的地址。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240419135448453.png" alt="image-20240419135448453"></p><p>同一个编译单元内部，static_func 与 main 函数的相对位置是固定不变的，即便链接的过程中会对不同.o 文件中的代码段进行合并，但是同一个.o 文件内部不同函数之间的位置也会保持不变，因此，我们在编译的时候，就能确定对静态函数调用的偏移。也就是说，静态函数的调用地址在编译阶段就可以确定下来。</p><p><strong>外部变量，全局变量以及静态变量</strong></p><p>从反汇编结果中看到，前三条语句对 extern_var、global_var 和 static_var 的访问，都生成了一条 mov 0x0(%rip)，%eax 的指令。这是因为在这个时候，编译器还无法确定这三个变量的地址，因此，先通过 0 来进行占位，以后链接器会将真正的地址回填在这里。</p><p><strong>extern_func 和 global_func 的调用</strong></p><p>call 指令同样是通过 0 来进行占位，和全局变量的处理方式一样。</p><p><strong>处理占位符【核心】</strong></p><p>由于在无法确定变量的真实地址时，编译器先通过 0 来进行占位。所以，我们这里继续观察链接器对 extern_var，static_var，global_var，global_func 以及 extern_func 的重定位过程。我们来查看占位符是如何处理的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  readelf -S example.o</span><br><span class="line"></span><br><span class="line">There are 21 section headers, starting at offset 0xb50:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000008a  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000760</span><br><span class="line">       0000000000000078  0000000000000018   I      18     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000cc</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000d4</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .debug_info       PROGBITS         0000000000000000  000000d4</span><br><span class="line">       0000000000000126  0000000000000000           0     0     1</span><br><span class="line">  [ 6] .rela.debug_info  RELA             0000000000000000  000007d8</span><br><span class="line">       0000000000000228  0000000000000018   I      18     5     8</span><br><span class="line">  [ 7] .debug_abbrev     PROGBITS         0000000000000000  000001fa</span><br><span class="line">       00000000000000a4  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .debug_aranges    PROGBITS         0000000000000000  0000029e</span><br><span class="line">       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [ 9] .rela.debug_arang RELA             0000000000000000  00000a00</span><br><span class="line">       0000000000000030  0000000000000018   I      18     8     8</span><br><span class="line">  [10] .debug_line       PROGBITS         0000000000000000  000002ce</span><br><span class="line">       0000000000000067  0000000000000000           0     0     1</span><br><span class="line">  [11] .rela.debug_line  RELA             0000000000000000  00000a30</span><br><span class="line">       0000000000000018  0000000000000018   I      18    10     8</span><br><span class="line">  [12] .debug_str        PROGBITS         0000000000000000  00000335</span><br><span class="line">       000000000000011f  0000000000000001  MS       0     0     1</span><br><span class="line">  [13] .comment          PROGBITS         0000000000000000  00000454</span><br><span class="line">       0000000000000024  0000000000000001  MS       0     0     1</span><br><span class="line">  [14] .note.GNU-stack   PROGBITS         0000000000000000  00000478</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [15] .note.gnu.propert NOTE             0000000000000000  00000478</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [16] .eh_frame         PROGBITS         0000000000000000  00000498</span><br><span class="line">       0000000000000078  0000000000000000   A       0     0     8</span><br><span class="line">  [17] .rela.eh_frame    RELA             0000000000000000  00000a48</span><br><span class="line">       0000000000000048  0000000000000018   I      18    16     8</span><br><span class="line">  [18] .symtab           SYMTAB           0000000000000000  00000510</span><br><span class="line">       00000000000001f8  0000000000000018          19    16     8</span><br><span class="line">  [19] .strtab           STRTAB           0000000000000000  00000708</span><br><span class="line">       0000000000000055  0000000000000000           0     0     1</span><br><span class="line">  [20] .shstrtab         STRTAB           0000000000000000  00000a90</span><br><span class="line">       00000000000000bb  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure><p>其中的 readelf -S选项是打印出二进制文件中所有 section-header的信息。我们可以看到 example.o里总共包含了 12 个 section，重点看.rela.text 段。</p><p>从 section-header的信息里可以看到，.rela.text 段的类型是 RELA 类型，也就是重定位表。</p><p>链接器在处理目标文件的时候，需要对目标文件里代码段和数据段引用到的符号进行重定位，而这些重定位的信息都记录在对应的重定位表里。</p><p>一般来说，重定位表的名字都是以 .rela 开头，比如 .rela.text 就是对 .text 段的重定位表，.rela.data 是对 .data 段的重定位表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> penge@penge-virtual-machine  ~/Desktop/MordenCpp/tmp1  readelf -r example.o </span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.text&#x27;</span> at offset 0x760 contains 5 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">00000000002c  001300000002 R_X86_64_PC32     0000000000000000 extern_var - 4</span><br><span class="line">000000000035  001000000002 R_X86_64_PC32     0000000000000000 global_var - 4</span><br><span class="line">00000000003e  000300000002 R_X86_64_PC32     0000000000000000 .data + 0</span><br><span class="line">00000000004b  001400000004 R_X86_64_PLT32    0000000000000000 extern_func - 4</span><br><span class="line">000000000058  001100000004 R_X86_64_PLT32    0000000000000000 global_func - 4</span><br></pre></td></tr></table></figure><p>.rela.text 的重定位表里存放了text段中需要进行重定位的每一处信息。所以，每个重定位项都会包含需要重定位的偏移、重定位类型和重定位符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr›   r_offset; <span class="comment">/* 重定位表项的偏移地址 */</span></span><br><span class="line">    Elf64_Xword›  r_info;   <span class="comment">/* 重定位的类型以及重定位符号的索引 */</span></span><br><span class="line">    Elf64_Sxword› r_addend; <span class="comment">/* 重定位过程中需要的辅助信息 */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>其中，r_info 的高 32bit 存放的是重定位符号在符号表的索引，r_info 的低 32bit 存放的是重定位的类型的索引。符号表就是.symtab 段，可以把它看成是一个字典，这个字典以整数为 key ，以符号名为 value。</p><p>查看重定位表中的四项，<strong>它们的类型都是 R_X86_64_PC32。这种类型的重定位计算方式为：S + A – P</strong>。</p><ul><li>S 表示完成链接后该符号的实际地址。在链接器将多个中间文件的段合并以后，每个符号就按先后顺序依次都会分配到一个地址，这就是它的最终地址 S。</li><li>A 表示 Addend 的值，它代表了占位符的长度。</li><li>P 表示要进行重定位位置的地址或偏移，可以通过 r_offset 的值获取到，这是引用符号的地方，也就是我们要回填地址的地方，简单说，它就是我们上文提到的用 0 填充的占位符的地址。</li></ul><p>这<strong>里 S 与 P 所表示的地址都是文件合并之后最终的虚拟地址</strong>。</p><p>以extern_var为例进制演算：【下面的例子的地址和上面程序无关】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000004004ad &lt;main&gt;:</span><br><span class="line">  4004ad:       55                      push   %rbp</span><br><span class="line">  4004ae:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4004b1:       48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  4004b5:       8b 05 75 0b 20 00       mov    0x200b75(%rip),%eax        # 601030 &lt;extern_var&gt;</span><br><span class="line">  4004bb:       89 45 e8                mov    %eax,-0x18(%rbp)</span><br></pre></td></tr></table></figure><ul><li><p>S 是其最终符号的真实地址，如上汇编里边的注释所示  也就是上面注释的 0x601030 这个地址；</p></li><li><p>A 是 Addend 的值，可以从重定位表里查到是 -4，对于 A 的具体含义我还会进一步解释；</p></li><li><p>P 是重定位 offset 的地址，这里是 0x4004b7。</p></li></ul><p>根据公式，我们算出重定位处需要填写的值应该是 0x601030 + (-4) – 0x4004b7 = 0x200b75，也就是最终可执行文件中这条 mov 指令里的值。</p><p>现在，我们从我们再从 CPU 的角度验证取值关系。从上面 main 函数的反编译的结果可以看到，我们最终对 extern_var 的访问生成的汇编是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    0x200b75(%rip), %eax</span><br></pre></td></tr></table></figure><p>这是一条 PC 相对偏移的寻址方式。当  CPU 执行到这条指令的时候，%rip 的值存放的是下一条指令的地址，也就是  0x4004bb。这时候可以算出 0x4004bb + 0x200b75 = 0x601030，刚好是 extern_var  的实际地址。</p><p>经过正面分析这个重定位的值的作用后，这里我们再来理解一下 S+A-P 这个公式的作用。链接器有了整体的虚拟内存布局后，知道的信息是：需要重定位符号的地址 S 的值是 (0x601030)，以及需要重定位的位置地址 P 的值是 (0x4004b7)。</p><p>其实，到这里不照本宣科的想一下更加比较容易的想·懂。</p><p><strong>静态变量</strong></p><p><strong>static_var 的最终地址就是本编译单元的.data 段的最终地址</strong>。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>回顾下静态链接的过程：源文件经过编译生成可重定位文件（.o文件），再经过静态链接生成可执行的ELF文件，最终运行时，通过页加载和页错误的方式，保证进程的正常运行。</p><p>假如像printf，scanf，strlen等基础函数，每个应用中都会使用到，那么不同的程序中一定会包含它们的指令部分。这就导致这些程序在磁盘保存时，都有这些基础函数的副本。运行时，也会将这些副本加载到对应进程的虚拟空间内存中去。这就导致了<strong>浪费磁盘和内存</strong>。</p><p>那么，接下来就要引出下面的主角了，<strong>动态链接</strong>。</p><p><strong>而动态链接的重定位的时机又可以分成：加载期间或者运行期间。</strong></p><h3 id="加载期间"><a href="#加载期间" class="headerlink" title="加载期间"></a>加载期间</h3><p>简单介绍下：我们希望将常用的公共的函数都放到一个文件中，在整个系统里只会被加载到内存中一次，无论有多少个进程使用它，这个文件在内存中只有一个副本，这种文件就是动态链接库文件。</p><p>动态链接库文件</p><ul><li>Linux：共享目标文件 (share object, so)</li><li>Window：动态链接库文件 (dynamic linking library, dll)</li></ul><p>我们先看个超级简单的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input i = %d\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfunc.so fun.c</span><br><span class="line">gcc main.c -o main -L./ -lfunc</span><br></pre></td></tr></table></figure><ul><li><p>-L： 指定了查找链接库的路径 (或者可以通过设置环境变量 LIBRARY_PATH 来追加路径)。 -L. 就是告诉链接器需要到当前目录下查找共享文件。</p></li><li><p>-l ：指定了具体链接库的名称，需要注意的是，gcc  在处理链接库名称时，会自动加上 lib的前缀和.so的后缀，所以，gcc 命令选项写的 -lfunc，就是告诉链接器查找libfunc.so这个共享目标文件。</p></li></ul><p>运行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=./</span><br><span class="line">./main</span><br><span class="line">input i = 5</span><br></pre></td></tr></table></figure><p>通过命令的指令我们浅浅的猜测一下，编译参数中 -lfunc存在的目的？</p><p>因为libfunc.so的符号表中有func,当链接器发现该符号存在于.so中，则将其作为动态符号处理。<strong>这也说明了，为什么静态链接阶段，我们还需要动态库的原因。静态链接阶段，动态库的作用就是用于区别符号的类型。</strong></p><p>在多进程共享动态库的时候，因为代码段是不可写的，所以进程间共享不存在问题，而数据段可写，系统必须保证一个进程写了共享库的数据段，另外一个进程看不到。因此，<strong>不同的库在不同的进程加载地址可能是不同的</strong>。</p><p>下面通过简单的实践查看一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c   -no-pie -o main</span><br></pre></td></tr></table></figure><ul><li>-no-pie 是禁止生成地址无关的可执行文件，方便查看进程的内存布局。</li></ul><p>分别在终端启动2个程序，通过下面的命令查看进程pid，具体实践如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ✘ penge@penge-virtual-machine  ~/Desktop/MordenCpp  ps aux | grep main</span><br><span class="line"></span><br><span class="line">penge      13319  0.1  2.4 962872 95600 ?        Sl   15:38   0:02 /home/penge/.vscode-server/cli/servers/Stable-e170252f762678dec6ca2cc69aba1570769a5d39/server/node /home/penge/.vscode-server/cli/servers/Stable-e170252f762678dec6ca2cc69aba1570769a5d39/server/out/server-main.js --connection-token=remotessh --accept-server-license-terms --start-server --enable-remote-auto-shutdown --socket-path=/tmp/code-5e7b9f0b-d52b-4755-9d41-32cabc4825ca</span><br><span class="line">penge      14196  0.0  0.0   2496   516 pts/2    S+   16:11   0:00 ./main</span><br><span class="line">penge      14241  0.0  0.0   2496   580 pts/4    S+   16:11   0:00 ./main</span><br><span class="line">penge      14405  0.0  0.0  12116  2728 pts/0    S+   16:13   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox mai</span><br></pre></td></tr></table></figure><p>查看进程内存：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">penge</span>@penge-virtual-machine  ~/Desktop/MordenCpp  cat /proc/<span class="number">14241</span>/maps</span><br><span class="line"><span class="attribute">00400000</span>-<span class="number">00401000</span> r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00401000</span>-<span class="number">00402000</span> r-xp <span class="number">00001000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00402000</span>-<span class="number">00403000</span> r--p <span class="number">00002000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00403000</span>-<span class="number">00404000</span> r--p <span class="number">00002000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00404000</span>-<span class="number">00405000</span> rw-p <span class="number">00003000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">01932000</span>-<span class="number">01953000</span> rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                 <span class="meta"> [heap]</span></span><br><span class="line"><span class="attribute">7f8c910fc000</span>-<span class="number">7</span>f8c9111e000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c9111e000</span>-<span class="number">7</span>f8c91296000 r-xp <span class="number">00022000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c91296000</span>-<span class="number">7</span>f8c912e4000 r--p <span class="number">0019</span>a000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c912e4000</span>-<span class="number">7</span>f8c912e8000 r--p <span class="number">001</span>e7000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c912e8000</span>-<span class="number">7</span>f8c912ea000 rw-p <span class="number">001</span>eb000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c912ea000</span>-<span class="number">7</span>f8c912f0000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="attribute">7f8c91308000</span>-<span class="number">7</span>f8c91309000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c91309000</span>-<span class="number">7</span>f8c9132c000 r-xp <span class="number">00001000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c9132c000</span>-<span class="number">7</span>f8c91334000 r--p <span class="number">00024000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c91335000</span>-<span class="number">7</span>f8c91336000 r--p <span class="number">0002</span>c000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c91336000</span>-<span class="number">7</span>f8c91337000 rw-p <span class="number">0002</span>d000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f8c91337000</span>-<span class="number">7</span>f8c91338000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="attribute">7ffd5dcfd000</span>-<span class="number">7</span>ffd5dd1e000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                         <span class="meta"> [stack]</span></span><br><span class="line"><span class="attribute">7ffd5ddd5000</span>-<span class="number">7</span>ffd5ddd9000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                         <span class="meta"> [vvar]</span></span><br><span class="line"><span class="attribute">7ffd5ddd9000</span>-<span class="number">7</span>ffd5dddb000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                         <span class="meta"> [vdso]</span></span><br><span class="line"><span class="attribute">ffffffffff600000</span>-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                 <span class="meta"> [vsyscall]</span></span><br><span class="line"> <span class="attribute">penge</span>@penge-virtual-machine  ~/Desktop/MordenCpp  cat /proc/<span class="number">14196</span>/maps</span><br><span class="line"><span class="attribute">00400000</span>-<span class="number">00401000</span> r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00401000</span>-<span class="number">00402000</span> r-xp <span class="number">00001000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00402000</span>-<span class="number">00403000</span> r--p <span class="number">00002000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00403000</span>-<span class="number">00404000</span> r--p <span class="number">00002000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">00404000</span>-<span class="number">00405000</span> rw-p <span class="number">00003000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">1090886</span>                            /home/penge/Desktop/MordenCpp/tmp1/main</span><br><span class="line"><span class="attribute">01584000</span>-<span class="number">015</span>a5000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                 <span class="meta"> [heap]</span></span><br><span class="line"><span class="attribute">7f9f9f286000</span>-<span class="number">7</span>f9f9f2a8000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f2a8000</span>-<span class="number">7</span>f9f9f420000 r-xp <span class="number">00022000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f420000</span>-<span class="number">7</span>f9f9f46e000 r--p <span class="number">0019</span>a000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f46e000</span>-<span class="number">7</span>f9f9f472000 r--p <span class="number">001</span>e7000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f472000</span>-<span class="number">7</span>f9f9f474000 rw-p <span class="number">001</span>eb000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232266</span>                    /usr/lib/x86_64-linux-gnu/libc-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f474000</span>-<span class="number">7</span>f9f9f47a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="attribute">7f9f9f492000</span>-<span class="number">7</span>f9f9f493000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f493000</span>-<span class="number">7</span>f9f9f4b6000 r-xp <span class="number">00001000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f4b6000</span>-<span class="number">7</span>f9f9f4be000 r--p <span class="number">00024000</span> <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f4bf000</span>-<span class="number">7</span>f9f9f4c0000 r--p <span class="number">0002</span>c000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f4c0000</span>-<span class="number">7</span>f9f9f4c1000 rw-p <span class="number">0002</span>d000 <span class="number">08</span>:<span class="number">05</span> <span class="number">2232260</span>                    /usr/lib/x86_64-linux-gnu/ld-<span class="number">2</span>.<span class="number">31</span>.so</span><br><span class="line"><span class="attribute">7f9f9f4c1000</span>-<span class="number">7</span>f9f9f4c2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="attribute">7ffd481b7000</span>-<span class="number">7</span>ffd481d8000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                         <span class="meta"> [stack]</span></span><br><span class="line"><span class="attribute">7ffd481f7000</span>-<span class="number">7</span>ffd481fb000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                         <span class="meta"> [vvar]</span></span><br><span class="line"><span class="attribute">7ffd481fb000</span>-<span class="number">7</span>ffd481fd000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                         <span class="meta"> [vdso]</span></span><br><span class="line"><span class="attribute">ffffffffff600000</span>-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                 <span class="meta"> [vsyscall]</span></span><br></pre></td></tr></table></figure><p>可以看出同样的/usr/lib/x86_64-linux-gnu/libc-2.31.so但是空间是不一样的。</p><p>因此这时候就有了<strong>地址无关代码</strong>。</p><h4 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h4><p>百度百科：在计算机领域中，地址无关代码 (position-independent code，PIC)，又称地址无关可执行文件 (position-independent executable，PIE) ，是指<strong>可在主存储器中任意位置正确地运行，而不受其绝对地址影响的一种机器码</strong>。</p><p>再介绍PIC之前，先说说之前<strong>不同的库在不同的进程加载地址可能是不同的</strong>导致的问题吧。</p><blockquote><p><strong>问题</strong></p></blockquote><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240419135438733.png" alt="image-20240419135438733"></p><p>如上图所示，如果两个进程共享了libc.so和libd.so两个动态库，而且 libc 中会调用 libd 中定义的 foo 方法。</p><p>进程 1 将 foo 方法映射到自己的虚拟地址 0x1000 处，而调用 foo 方法的指令被映射到 0x2000 处，那么 call 指令如果采用依赖 rip 寄存器的相对寻址的办法，这个偏移量应该填 -0x1000。进程 2 将 foo 方法映射到自己虚拟地址 0x2000 处，调用 foo 方法的指令被映射到 0x5000 处，那么 call 指令的参数就应该填 -0x3000。这就产生了冲突。</p><p>因此需要<strong>地址无关代码</strong>技术。</p><p>在计算机科学领域，<strong>有一句名言：“计算机领域的所有问题都可以使用新加一层抽象来解决”。</strong></p><p>那么有了这句话的引导，要实现代码段的地址无关代码，思路是通过添加一个中间层，使得对全局符号的访问由直接访问变成间接访问。</p><p>我们可以引入一个固定地址，让引用者与这个固定地址之间的相对偏移是固定的，然后这个地址处再填入 foo 函数真正的地址。当然，这个地方必然位于数据段中，是每个进程私有的，这样才能做到在不同的进程里，可以访问不同的虚拟地址。这个新引入的固定地址就是<strong>全局偏移表 (Global Offset Table, GOT)</strong>。</p><p>GOT 的工作原理如下</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240419135432310.png" alt="image-20240419135432310"></p><p>在上图中，call指令处被填入了 0x3000，这是因为进程 1 的 GOT 与 call 指令之间的偏移是 0x5000-0x2000=0x3000，同时进程 2 的 GOT 与 call指令之间的偏移是 0x8000-0x5000=0x3000。所以对于这一段共享代码，不管是进程 1 执行还是进程 2 执行，它们都能跳到自己的GOT 表里。</p><p>然后，进程 1 通过访问自己的 GOT 表，查到 foo 函数的地址是 0x1000，它就能真正地调用到 foo 函数了。进程 2 访问自己的 GOT 表，查到 foo 函数的地址是 0x2000，它也能顺利地调用 foo 函数。这样我们就通过引入了 GOT 这个间接层，解决了 call 指令和 foo 函数定义之间的偏移不固定的问题。</p><p>这种技术就是<strong>地址无关代码</strong> (Position Independent Code, PIC)。</p><p>这个验证也比较简单，可以尝试自己通过程序验证下。</p><p>因此，共享库的好处也呼之欲出了。</p><blockquote><p><strong>静态库 VS 动态库</strong></p></blockquote><ul><li>静态库是在编译阶段就和可执行文件打包链接在一起的，它可以看成是中间文件的简单集合，保留了符号，只有在静态链接的过程，才会真正地做地址分配和重定位。</li><li>动态库在编译阶段，它的代码并不会被合并进可执行文件中，在运行时才会被加载进内存，它被加载进内存的地址是不固定的，所以每次加载完成以后，才能为它的符号分配真实的内存地址，然后再把地址回填到引用它的GOT中。动态库的一个优点是可以在多个进程间共享，从而可以减少内存的重复。</li></ul><h3 id="运行期间"><a href="#运行期间" class="headerlink" title="运行期间"></a>运行期间</h3><p><strong>动态链接过程的基本原理</strong>：动态链接通过GOT 表加一层间接跳转的方式，解决了代码中 call 指令对绝对地址的依赖，从而实现了PIC的能力。</p><p>动态链接存在的问题：</p><ol><li>每次对全局符号的访问都要转换为对 GOT 表的访问，然后进行间接寻址，这必然要比直接的地址访问速度慢很多。</li><li>动态链接和静态链接的区别是将链接中重定位的过程推迟到程序加载时进行。因此在程序启动的时候，动态链接器需要对整个进程中依赖的 so 进行加载和链接，也就是对进程中所有 GOT 表中的符号进行解析重定位。</li></ol><h4 id="延迟绑定技术"><a href="#延迟绑定技术" class="headerlink" title="延迟绑定技术"></a>延迟绑定技术</h4><p>为了避免在加载时就把 GOT 表中的符号全部解析并重定位，那么就采取懒操作，把要做的事情推迟到必须做的时刻。<strong>简单来说，将函数地址的重定位工作一直推迟到第一次访问的时候再进行，这就是延迟绑定 (Lazy binding) 的技术</strong>。这样对于整个程序运行过程中没有访问到的全局函数，可以避免对这类符号的重定位工作，提高程序性能。</p><p>延迟绑定的实现使用了两个特殊的数据结构</p><ul><li>全局偏移表（Global Offset Table，GOT）</li><li>过程链接表（Procedure Linkage Table，PLT）</li></ul><p>大致的实现思路是我们把 GOT 中的待解析符号的地方都填成动态符号解析的函数，当 CPU 执行到这个函数的时候，就会跳转进去解析符号，然后把 GOT 表的这一项填成符号的真正的地址。</p><p>接下来，我们来看看下面的例子：</p><p>过程链接表（Procedure Linkage Table， PLT)，将动态解析符号的过程做成了三级跳。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240419135425681.png" alt="image-20240419135425681"></p><p>仔细查看，会发现上面的这张图多了.plt段。</p><p>在代码段里，main 函数对 B 函数的调用转成了对”B@plt”的调用，”B@plt”函数只有三条指令</p><ul><li>第一条指令 jmp *(GOT[3]) 是一个间接跳转，跳转的目标是 GOT 表偏移为 0x18 的位置，这个位置应该放的是 B 函数的真实地址，但是第一次访问时，里面肯定是为空的，因为在加载时，并没有进行重定位。因此现在填入的是指向了 B@plt + 0x6 的位置，这是为了传递参数给 _dl_runtime_resolve 函数。</li><li>B@plt+0x6 的位置其实就是 B@plt 函数的第二条指令，它的作用是将函数参数入栈。</li><li>接着执行第三条指令 jmp .plt 再准备第二个参数。</li></ul><p>3级跳分析：</p><ul><li><p>序号①箭头的位置，也就是第一级跳转，它的目的是把参数 0 入栈。由于 GOT 表的 0x0，0x8，0x10 的位置都被占用了，所以参数 0 代表的就是 0x18 位置，这就是 B 函数的真实地址应该存放的地方。</p></li><li><p>序号②箭头的位置，发生了第二级跳转，这一次是为了把动态库的 ID 号压栈传参。</p></li><li><p>序号③箭头的位置，继续进行第三级跳转，这一次跳转才真正地调用到了 _dl_runtime_resolve【动态解析符号的函数 _dl_runtime_resolve 依赖两个参数，一个是当前动态库的 ID，另一个是要解析的符号在 GOT 表中的序号】。调用完这个方法以后，B 函数的真实地址就会被填入 GOT 表中了。</p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240419135418296.png" alt="image-20240419135418296"></p><p>最后，总结一下 GOT 表中的各个表项的含义。</p><ul><li>GOT.PLT[0]位置被加载器保留，它里面存放的是.dynamic 段的地址，这里我们不用关心。</li><li>GOT.PLT[1]位置存放的是当前 so 的 ID，这个 ID 是加载器在加载当前动态库文件的时候分配的。</li><li>GOT.PLT[2]位置存放的是动态链接函数的入口地址，一般是动态链接器中的 _dl_runtime_resovle 函数。这个函数的作用是找到需要查找的符号地址，并最终回填到 GOT.PLT 表的对应位置。</li></ul><p>然后再回顾一下延迟绑定的整个过程。</p><ol><li>当 demo 函数想要调用 global_func 的时候，程序调用先进入 global_func@plt 中；</li><li>在 global_func@plt 中，会先执行 jmpq *GOT.PLT[3] ，此时 GOT.PLT[3] 里存放的是 global_func@plt 项中的第二条指令，因此控制流继续返回到 global_func@plt 中进行执行；</li><li>接下会把数值 0x0 进行压栈，这个数值代表了 global_func 的 ID。然后 jmp 到 PLT[0] 的表项中进行执行；</li><li>在 PLT[0] 中，继续将 GOT.PLT[1] 的值也就是库文件的 ID 进行压栈，然后通过 GOT.PLT[2] 跳转到 _dl_runtime_resolve 函数中；</li><li>dl_runtime_resolve 则根据存在栈上的函数 ID 和 so 的 ID 进行全局搜索，找到对应的函数地址之后就可以将其重新填充到 GOT.PLT[3] 中，这个时候延迟加载的整个过程就完成了；</li><li>当下一次调用 global_func 的时候，CPU 就可以通过 global_func@plt 中第一条指令 jmpq *GOT.PLT[3] 直接跳转到 global_func 的真实地址中。</li></ol><h2 id="Loader加载机制"><a href="#Loader加载机制" class="headerlink" title="Loader加载机制"></a>Loader加载机制</h2><p>一个完全静态链接的可执行文件则不需要动态链接器的辅助，所以内核加载完之后可以直接跳转到用户代码的入口中进行执行。而动态链接的可执行文件 a.out需要链接器。</p><p>Linux环境下：<strong>动态链接器名为ld.so，又因为它还负责加载动态库文件，所以我们有时也叫它 loader，或者加载器</strong>。</p><p>ld-linux.so完成4个工作：</p><ul><li>启动动态链接器</li><li>根据可执行文件的动态链接信息，寻找并加载可执行文件依赖的.so文件</li><li>对符号进行解析和重定位</li><li>依次执行各个 so 的 init 函数</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240419140052826.png" alt="image-20240419140052826"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>重定位的概念：编译器在把源代码翻译成汇编指令的过程中，由于不知道其他编译单元的符号的真实地址，在引用这些符号的时候只能使用占位符（通常是 0）来代替。这些占位符由链接器填充。当链接器把所有的符号的位置都确定好以后，再把真实地址回填到占位符里。</li><li>重定位的时机：编译期重定位，加载期和运行时重定位。</li><li>负责动态链接的是ld-linux.so，它被称为动态链接器，但因为它还负责加载文件工作，所以也被人称为加载器或者 loader。它的工作流程主要有启动，加载，重定位和 init 四个步骤。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《程序员的自我修养》</li><li>《CSAPP》</li><li>《LINUX GNU C 程序观察 (罗秋明) 》</li><li>《高级C/C++编译技术》</li><li>极客时间</li></ul>]]></content>
    
    
    <summary type="html">《静态链接和动态链接》</summary>
    
    
    
    <category term="计算机系统" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机系统" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络:I/O多路复用-[select/poll/epoll]</title>
    <link href="https://penge666.github.io/posts/b032cb51.html"/>
    <id>https://penge666.github.io/posts/b032cb51.html</id>
    <published>2024-04-12T03:15:36.000Z</published>
    <updated>2024-04-12T09:39:40.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很早之前写webserver项目学习到的知识点，在这里把核心知识点记载下 ~</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><strong>典型的一次I/O分为两个阶段</strong>：<strong>数据准备 和 数据读写</strong></p><p>解释：作为服务器，接收客户端的请求，得先监听客户端有没有数据过来，这是一个状态，还有就是数据过来了该怎么去读写，这又是一个状态。</p><p>实际上，阻塞，非阻塞，同步，异步，分别是这两种状态下的体系。</p><p><strong>网络I/O阶段1：数据准备</strong></p><p>数据准备：根据系统IO操作的就绪状态，分为</p><ol><li>阻塞 ： 让调用I/O的线程进入阻塞状态 ，数据准备好了就唤醒</li><li>非阻塞： 不会改变线程的状态，通过返回值判断</li></ol><p>1- <strong>阻塞</strong></p><p>sockfd相当于就是系统的文件描述符，代表1个I/O，创建的时候默认是阻塞，当我调用1个阻塞I/O的话，如果sockfd上没有数据可读，这个recv不会返回，<strong>造成当前线程阻塞</strong>，等待sockfd上有数据到来。如果返回了，就是有数据可读了，接下去就是数据读写了。返回的是最终读的数据的大小。一直等着。</p><p>2- <strong>非阻塞</strong></p><p>如果我们在创建sockfd的时候设置是非阻塞，recv的体现是：如果sockfd上没有数据到来的话，recv直接返回回来，<strong>不会造成当前线程阻塞</strong>。sockfd没有数据准备好的话，不断的空转CPU。</p><p>3 - <strong>阻塞和非阻塞的返回值</strong>（数据准备的返回值）</p><p>如果size==-1的话，表示错误：</p><ul><li><p>size==-1真的错误，是系统的内部错误，可能要close(sockfd)</p></li><li><p>如果size==-1&amp;&amp;errno==EAGAIN，表示正常的非阻塞返回，sockfd上没有网络事件发生</p></li></ul><p>如果size!= -1,有两种情况</p><ul><li>如果size= =0，表示网络对端关闭了连接，对端直接close(sockfd)</li><li>如果size&gt;0，就是表示有数据过来了。</li></ul><p><strong>网络I/O阶段2：数据读写</strong></p><p>数据读写：根据应用程序和内核的交互方式，分为两种</p><ol><li>同步</li><li>异步</li></ol><p><strong>2种同步和异步的区别</strong>：【I/O的同步和异步】和 【应用层并发的同步和异步】</p><p>1- <strong>IO同步</strong></p><p>在应用程序上调用recv函数，这个sockfd我不管它工作在阻塞模式还是非阻塞模式，真的有数据准备好了之后（TCP的接收缓冲区有数据了，就是数据可读了），我们要读这个数据，这个buf是用户层自己定义的，recv就可以开始接收了，是应用程序卡在这里recv()，从内核的TCP接收缓冲区搬数据到应用层上的buf，在搬的过程中，因为size&gt;0，这就表示从内核搬了多少字节的数据，我们就要访问buf了，没搬完之前，不会进入到下面的if语句。搬完了，recv才返回过来，看看size是多少，就是搬了多少数据，<strong>因此I/O同步是应用程序搬的数据。</strong></p><p>I/O同步的意思就是：<strong>当我调用网络I/O的接口，当I/O阶段1数据准备好之后，在数据读写的时候，应用层自己调用网络I/O接口自己去读写，都花在应用层上</strong>。</p><p>Note：recv和send是同步的I/O接口</p><p>2 - <strong>I/O异步</strong></p><p>当我请求内核的时候，关心sockfd上的数据，远端如果发过来数据，我需要读sockfd上的数据，我有一个buf，到时候如果有数据来了，内核能不能帮忙把数据放到buf里面，我再给内核注册一个sigio信号，也就是说，对一个操作系统级别的异步的I/O接口来说，我先塞给内核一个sockfd，表示对这个sockfd上的事件感兴趣，如果sockfd上有数据可读的话，<strong>麻烦操作系统内核把数据搬到buf里面。</strong></p><p>内核把内核缓冲区-sockfd对应的TCP接收缓冲区的数据搬到buf里面，搬完以后，通过信号sigio给应用程序通知一下。应用程序在这期间可以玩自己的了，做任何事清都可以。</p><p><strong>通知是异步最大的标识，是异步就有通知</strong></p><p>linux的aio_read，aio_write就是典型的linux给我们提供的异步I/O接口。</p><p>陈硕大佬的原话：<strong>在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步IO</strong>。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/5.png" alt=""></p><h1 id="Linux五种I-O模型"><a href="#Linux五种I-O模型" class="headerlink" title="Linux五种I/O模型"></a>Linux五种I/O模型</h1><ul><li><p>阻塞IO</p><ul><li>调用者调用了某个函数，等待这个函数返回，期间什么都不做，不停检查这个函数有没有返回，必须等该函数返回才能进行下一步动作。</li></ul></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/6.png" alt=""></p><ul><li><p>非阻塞IO</p><ul><li>每隔一段时间去检测IO时间是否就绪，没有就绪就可以进行其他操作。</li><li>非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若没发生则返回-1，此时根据errno区分两种情况，对于accept、recv和send，事件未发生时，errno被设置为EAGAIN。</li></ul></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/7.png" alt=""></p><ul><li><p>IO复用</p></li><li><p>select、poll、epoll函数实现，这些函数也会使进程阻塞，但是和阻塞IO不同的是，这些函数可以同时阻塞多个IO操作。</p><ul><li><p>可以同时对多个读操作、写操作的IO函数进行检测，直到有数据可读或可写时，才真正调用IO操作函数.</p></li><li><p><strong>IO多路复用的含义就是一个进程能处理多个socket</strong></p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/8.png" alt=""></p></li><li><p>信号驱动IO</p><ul><li>注册新号处理函数，进程继续运行并不阻塞，当IO事件就绪时，进程受到SIGIO新号，然后处理IO事件。</li><li><strong>内核在第一个阶段是异步，在第二个阶段是同步。</strong></li><li>与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/9.png" alt=""></p></li><li><p>异步IO</p><ul><li>LInux中，调用aio_read函数告诉内核描述字缓冲区指针和缓冲区大小 、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/10.png" alt=""></p><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><strong>简单理解：</strong></p><ul><li>委托内核进行操作</li><li>只会通知有几个任务可用，但不知道具体哪几个任务，还需遍历（与NIO模型略有不同）</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/11.png" alt=""></p><p><strong>主旨思想</strong></p><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中</li><li>调用一个系统函数(<code>select</code>)，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回<ul><li>这个函数是阻塞</li><li>函数对文件描述符的检测的操作是由内核完成的</li></ul></li><li>在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作</li></ol><p><strong>用法</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; </span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; </span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p><ul><li>通过<code>man select</code>查看帮助</li><li><p>参数</p><ul><li><code>nfds</code>：委托内核检测的最大文件描述符的值 + 1（+1是因为遍历是下标从0开始，for循环＜设定）</li><li><code>readfds</code>：要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性 <ul><li>一般检测读操作 </li><li>对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</li><li>是一个传入传出参数</li></ul></li><li><code>writefds</code>：要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性 <ul><li>委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</li></ul></li><li><code>exceptfds</code>：检测发生异常的文件描述符的集合，一般不用</li><li><code>timeout</code>：设置的超时时间，含义见<strong><code>select</code>参数列表说明</strong><ul><li><code>NULL</code>：永久阻塞，直到检测到了文件描述符有变化 </li><li><code>tv_sec = tv_usec = 0</code>， 不阻塞</li><li><code>tv_sec &gt; 0,tv_usec &gt; 0</code>：阻塞对应的时间 </li></ul></li></ul></li><li><p>返回值</p><ul><li>-1：失败</li><li>>0(n)：检测的集合中有n个文件描述符发生了变化  </li></ul></li></ul></li><li><p><code>select</code>参数列表说明</p><ul><li><p><code>fd_set</code>：是一块固定大小的缓冲区(结构体)，<code>sizeof(fd_set)=128</code>，即对应1024个比特位</p></li><li><p><code>timeval</code>：结构体类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123; </span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span> </span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>工作过程分析</strong></p><p>1.初始设定</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/12.png" alt=""></p><p>2.设置监听文件描述符，将<code>fd_set</code>集合相应位置为1</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/13.png" alt=""></p><p>3.调用<code>select</code>委托内核检测</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/14.png" alt=""></p><p>4.内核检测完毕后，返回给用户态结果</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/15.png" alt=""></p><blockquote><p> <strong>代码实现</strong></p></blockquote><p><strong>注意事项</strong></p><ul><li>select中需要的监听集合需要两个<ul><li>一个是用户态真正需要监听的集合<code>rSet</code></li><li>一个是内核态返回给用户态的修改集合<code>tmpSet</code></li></ul></li><li>需要先判断监听文件描述符是否发生改变<ul><li>如果改变了，说明有客户端连接，此时需要将<strong>新的连接文件描述符加入到<code>rSet</code></strong>，并更新最大文件描述符</li><li>如果没有改变，说明没有客户端连接</li></ul></li><li>由于<code>select</code>无法确切知道哪些文件描述符发生了改变，所以需要执行遍历操作，使用<code>FD_ISSET</code>判断是否发生了改变</li><li>如果客户端断开了连接，需要从<code>rSet</code>中清除需要监听的文件描述符</li><li>程序存在的问题：中间的一些断开连接后，最大文件描述符怎么更新？=&gt;<strong>估计不更新，每次都会遍历到之前的最大值处</strong>，解决方案见<a href="https://gitee.com/Pengge_666/linuxServer/blob/master/doc/04Linux网络编程.md###高并发优化思考">高并发优化思考</a></li></ul><p>服务器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERIP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 6789</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket（用于监听的套接字）</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    <span class="comment">// 点分十进制转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVERIP, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 服务端也可以绑定0.0.0.0即任意地址</span></span><br><span class="line">    <span class="comment">// server_addr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>); <span class="comment">// 同时最多能处理8个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建读检测集合</span></span><br><span class="line">    <span class="comment">// rSet用于记录正在的监听集合，tmpSet用于记录在轮训过程中由内核态返回到用户态的集合</span></span><br><span class="line">    fd_set rSet, tmpSet;</span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rSet);</span><br><span class="line">    <span class="comment">// 将监听文件描述符加入</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(listenfd, &amp;rSet);</span><br><span class="line">    <span class="comment">// 此时最大的文件描述符为监听描述符</span></span><br><span class="line">    <span class="type">int</span> maxfd = listenfd;</span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tmpSet = rSet;</span><br><span class="line">        <span class="comment">// 使用select，设置为永久阻塞，有文件描述符变化才返回</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;tmpSet, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前无文件描述符有变化，执行下一次遍历</span></span><br><span class="line">            <span class="comment">// 在本次设置中无效（因为select被设置为永久阻塞）</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首先判断监听文件描述符是否发生改变（即是否有客户端连接）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(listenfd, &amp;tmpSet)) &#123;</span><br><span class="line">                <span class="comment">// 4. 接收客户端连接</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in client_addr;</span><br><span class="line">                <span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">                <span class="comment">// 这行代码的作用是接受客户端的连接请求，并返回一个新的 socket 文件描述符 connfd，通过这个 connfd 可以进行和客户端的通信。</span></span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">                <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 输出客户端信息，IP组成至少16个字符（包含结束符）</span></span><br><span class="line">                <span class="type">char</span> client_ip[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr.s_addr, client_ip, <span class="built_in">sizeof</span>(client_ip));</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> client_port = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ip:%s, port:%d\n&quot;</span>, client_ip, client_port);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">FD_SET</span>(connfd, &amp;rSet);</span><br><span class="line">                <span class="comment">// 更新最大文件符</span></span><br><span class="line">                maxfd = maxfd &gt; connfd ? maxfd : connfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历集合判断是否有变动，如果有变动，那么通信</span></span><br><span class="line">            <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = listenfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;tmpSet)) &#123;</span><br><span class="line">                    ret = <span class="built_in">read</span>(i, recv_buf, <span class="built_in">sizeof</span>(recv_buf));</span><br><span class="line">                    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recv_buf);</span><br><span class="line">                        <span class="built_in">write</span>(i, recv_buf, <span class="built_in">strlen</span>(recv_buf));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rSet);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通俗来说，就是服务器先设置个文件描述符，专门用于监听是否有客户端进来，在其上绑定IP和端口号，交给给内核进行监听，当有客户端进来则这个专门用于监听的文件描述符就会发生变化。之后，当有客户端进来的时候，我们需要创建一个描述符用于与这个新进来的客户端进行通信。</p><p>【这里举个不是很恰当的例子，listened描述符就像酒店门口迎宾人员，当有客人来的时候，带进酒店的包间，之后由其他的服务人员来接管。之后这位迎宾人员又回到原来的工作岗位上】</p><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERIP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 6789</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket（用于通信的套接字）</span></span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 连接服务器端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVERIP, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(connfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> *send_buf = <span class="string">&quot;client message&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(connfd, send_buf, <span class="built_in">strlen</span>(send_buf));</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        ret = <span class="built_in">read</span>(connfd, recv_buf, <span class="built_in">sizeof</span>(recv_buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recv_buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠的目的是为了更好的观察，放在此处可以解决read: Connection reset by peer问题</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>存在问题</strong></p></blockquote><ul><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>select支持的文件描述符数量太小了，默认是1024</li><li>fds集合不能重用，每次都需要重置</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/16.png" alt=""></p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p><strong>主旨思想</strong></p><ul><li>用一个<strong>结构体记录文件</strong>描述符集合，并记录用户态状态和内核态状态</li></ul><p><strong>函数概述</strong></p><ul><li><p>概览</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123; </span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span> </span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span> </span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></p><ul><li><p>通过<code>man poll</code>查看帮助</p></li><li><p>参数</p><ul><li><code>fds</code>：是一个<code>struct pollfd</code> 结构体数组，这是一个需要检测的文件描述符的集合</li><li><code>nfds</code>：这个是第一个参数数组中最后一个有效元素的下标 + 1</li><li>timeout：阻塞时长<ul><li>0：不阻塞</li><li>-1：阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</li><li>>0：具体的阻塞时长(ms)</li></ul></li></ul></li><li><p>返回值</p><ul><li>-1：失败</li><li>>0(n)：检测的集合中有n个文件描述符发生了变化</li></ul></li></ul></li><li><p><code>events</code>及<code>revents</code>取值，如果有多个事件需要检测，用<code>|</code>即可，如同时检测读和写：<code>POLLIN | POLLOUT</code></p></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/17.png" alt=""></p><blockquote><p><strong>代码实现</strong></p></blockquote><p><strong>注意事项</strong></p><ul><li><code>nfds</code>表示的监听文件描述符的下标，所以在遍历时，需要使用<code>fds[i].fd</code>取得相应的文件描述符</li><li>如何优雅的更新nfds代码中使用连接的文件描述符作为替代更新</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERIP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 6789</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket（用于监听的套接字）</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    <span class="comment">// 点分十进制转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVERIP, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 服务端也可以绑定0.0.0.0即任意地址</span></span><br><span class="line">    <span class="comment">// server_addr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将监听文件描述符加入</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用poll，设置为永久阻塞，有文件描述符变化才返回</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前无文件描述符有变化，执行下一次遍历</span></span><br><span class="line">            <span class="comment">// 在本次设置中无效（因为select被设置为永久阻塞）</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首先判断监听文件描述符是否发生改变（即是否有客户端连接）</span></span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 4. 接收客户端连接</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in client_addr;</span><br><span class="line">                <span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">                <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 输出客户端信息，IP组成至少16个字符（包含结束符）</span></span><br><span class="line">                <span class="type">char</span> client_ip[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr.s_addr, client_ip, <span class="built_in">sizeof</span>(client_ip));</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> client_port = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ip:%s, port:%d\n&quot;</span>, client_ip, client_port);</span><br><span class="line">                <span class="comment">// 遍历集合, 将新的需要监听的文件描述符加入集合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = connfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新最大的监听文件描述符集合下标</span></span><br><span class="line">                <span class="comment">// 存在问题：使用文件描述符替代最大对应下标</span></span><br><span class="line">                nfds = nfds &gt; connfd ? nfds : connfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历集合判断是否有变动，如果有变动，那么通信</span></span><br><span class="line">            <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fds[i].fd != <span class="number">-1</span> &amp;&amp; fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    ret = <span class="built_in">read</span>(fds[i].fd, recv_buf, <span class="built_in">sizeof</span>(recv_buf));</span><br><span class="line">                    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recv_buf);</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, recv_buf, <span class="built_in">strlen</span>(recv_buf));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的思想和select一致，只不过是使用数组来存储标识。</p><p><strong>客户端</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERIP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 6789</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket（用于通信的套接字）</span></span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 连接服务器端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVERIP, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(connfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> *send_buf = <span class="string">&quot;client message&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(connfd, send_buf, <span class="built_in">strlen</span>(send_buf));</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        ret = <span class="built_in">read</span>(connfd, recv_buf, <span class="built_in">sizeof</span>(recv_buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recv_buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠的目的是为了更好的观察，放在此处可以解决read: Connection reset by peer问题</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>存在问题</strong></p></blockquote><ul><li>缺点同<code>select</code>第一点和第二点(如下)，即解决了第三点和第四点</li><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>简单理解</strong></p><ul><li>委托内核进行操作</li><li>会通知具体有哪几个任务可用</li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/19.png" alt=""></p><p><strong>主旨思想</strong></p><ul><li>直接在<strong>内核态</strong>创建<code>eventpoll实例</code>(结构体)，通过<code>epoll</code>提供的API操作该实例</li><li>结构体中有<code>红黑树</code>和<code>双链表</code>，分别用来<strong>存储需要检测的文件描述符</strong>和<strong>存储已经发生改变的文件描述符</strong></li></ul><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/18.png" alt=""></p><p><strong>函数说明</strong></p><ul><li><p>概览</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例</span></span><br><span class="line"><span class="comment">// 在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123; </span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span> </span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123; </span><br><span class="line">    <span class="type">void</span> *ptr; </span><br><span class="line">    <span class="type">int</span> fd; </span><br><span class="line">    <span class="type">uint32_t</span> u32; </span><br><span class="line">    <span class="type">uint64_t</span> u64; </span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>int epoll_create(int size);</code></p><ul><li>功能：创建一个新的epoll实例</li><li>参数：<code>size</code>，目前没有意义了(之前底层实现是哈希表，现在是红黑树)，随便写一个数，必须大于0</li><li>返回值<ul><li>-1：失败</li><li>>0：操作<code>epoll实例</code>的文件描述符</li></ul></li></ul></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></p><ul><li><p>功能：对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</p></li><li><p>参数：</p><ul><li><code>epfd</code>：epoll实例对应的文件描述符</li><li>op：要进行什么操作<ul><li>添加：<code>EPOLL_CTL_ADD</code></li><li>删除：<code>EPOLL_CTL_DEL</code></li><li>修改：<code>EPOLL_CTL_MOD</code></li></ul></li><li><code>fd</code>：要检测的文件描述符</li><li>event：检测文件描述符什么事情，通过设置epoll_event.events，常见操作<ul><li>读事件：<code>EPOLLIN</code></li><li>写事件：<code>EPOLLOUT</code></li><li>错误事件：<code>EPOLLERR</code></li><li>设置边沿触发：<code>EPOLLET</code>（默认水平触发）</li></ul></li></ul></li><li><p>返回值：成功0，失败-1</p></li></ul></li><li><p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></p><ul><li><p>功能：检测哪些文件描述符发生了改变</p></li><li><p>参数：</p><ul><li><code>epfd</code>：epoll实例对应的文件描述符</li></ul></li><li><code>events</code>：传出参数，保存了发生了变化的文件描述符的信息<ul><li><code>maxevents</code>：第二个参数结构体数组的大小</li></ul></li><li><p>timeout：阻塞时长</p><ul><li>0：不阻塞<ul><li>-1：阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</li></ul></li><li>>0：具体的阻塞时长(ms)</li></ul></li><li><p>返回值：</p><ul><li>> 0：成功，返回发送变化的文件描述符的个数</li><li>-1：失败</li></ul></li></ul></li></ul><blockquote><p> <strong>注意事项</strong></p></blockquote><ul><li><p><code>events</code>是封装了监听描述符信息的结构体，每一个新增文件都需要这个(可重用)</p></li><li><p>需要注意可能同时发生了多个监听（如监听读事件和写事件），那么代码逻辑需要做相应判断</p><blockquote><p>如本例中只检测读事件，排除了写事件</p></blockquote></li></ul><p><strong>服务端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERIP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 6789</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket（用于监听的套接字）</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    <span class="comment">// 点分十进制转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVERIP, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 服务端也可以绑定0.0.0.0即任意地址</span></span><br><span class="line">    <span class="comment">// server_addr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 将监听文件描述符加入实例</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listenfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listenfd, &amp;event);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此结构体用来保存内核态返回给用户态发生改变的文件描述符信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用epoll，设置为永久阻塞，有文件描述符变化才返回</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前无文件描述符有变化，执行下一次遍历</span></span><br><span class="line">            <span class="comment">// 在本次设置中无效（因为select被设置为永久阻塞）</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历发生改变的文件描述符集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                <span class="comment">// 判断监听文件描述符是否发生改变（即是否有客户端连接）</span></span><br><span class="line">                <span class="type">int</span> curfd = events[i].data.fd;</span><br><span class="line">                <span class="keyword">if</span> (curfd == listenfd) &#123;</span><br><span class="line">                    <span class="comment">// 4. 接收客户端连接</span></span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">                    <span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">                    <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">                    <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 输出客户端信息，IP组成至少16个字符（包含结束符）</span></span><br><span class="line">                    <span class="type">char</span> client_ip[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr.s_addr, client_ip, <span class="built_in">sizeof</span>(client_ip));</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">short</span> client_port = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s, port:%d\n&quot;</span>, client_ip, client_port);</span><br><span class="line">                    <span class="comment">// 将信息加入监听集合</span></span><br><span class="line">                    event.events = EPOLLIN;</span><br><span class="line">                    event.data.fd = connfd;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 只检测读事件</span></span><br><span class="line">                    <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 接收消息</span></span><br><span class="line">                    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    ret = <span class="built_in">read</span>(curfd, recv_buf, <span class="built_in">sizeof</span>(recv_buf));</span><br><span class="line">                    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recv_buf);</span><br><span class="line">                        <span class="built_in">write</span>(curfd, recv_buf, <span class="built_in">strlen</span>(recv_buf));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(curfd);</span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERIP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 6789</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket（用于通信的套接字）</span></span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 连接服务器端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVERIP, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(connfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> *send_buf = <span class="string">&quot;client message&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(connfd, send_buf, <span class="built_in">strlen</span>(send_buf));</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        ret = <span class="built_in">read</span>(connfd, recv_buf, <span class="built_in">sizeof</span>(recv_buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recv_buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠的目的是为了更好的观察，放在此处可以解决read: Connection reset by peer问题</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作模式-LT与ET"><a href="#工作模式-LT与ET" class="headerlink" title="工作模式(LT与ET)"></a>工作模式(LT与ET)</h3><h4 id="水平触发-level-triggered-LT"><a href="#水平触发-level-triggered-LT" class="headerlink" title="水平触发(level triggered, LT)"></a>水平触发(level triggered, LT)</h4><ul><li>epoll的缺省的工作方式，并且同时支持 block 和 non-block socket</li><li>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的</li></ul><h4 id="边沿触发-edge-triggered-ET"><a href="#边沿触发-edge-triggered-ET" class="headerlink" title="边沿触发(edge triggered, ET)"></a>边沿触发(edge triggered, ET)</h4><ul><li>是高速工作方式，只支持 non-block socket，需要对监听文件描述符设置才能实现</li><li>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）</li></ul><h4 id="区别与说明"><a href="#区别与说明" class="headerlink" title="区别与说明"></a>区别与说明</h4><ul><li>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高</li><li>epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死</li><li>所以如果使用ET且缓冲区内容不能一次性读完，<strong>需要写一个循环将内容全部读取，且需要将套接字设置为非阻塞</strong></li><li>说明：假设委托内核检测读事件，即检测fd的读缓冲区，那么如果读缓冲区有数据 ，epoll检测到了会给用户通知<ul><li>LT【只要缓冲区有数据，就会一直通知】<ul><li>用户不读数据，数据一直在缓冲区，epoll 会一直通知</li><li>用户只读了一部分数据，epoll会通知</li><li>缓冲区的数据读完了，不通知</li></ul></li><li>ET【缓冲区有数据，只会通知一次】<ul><li>用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</li><li>用户只读了一部分数据，epoll不通知</li><li>缓冲区的数据读完了，不通知</li></ul></li></ul></li></ul><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul><li><p><code>int socket(int domain, int type, int protocol);</code></p><ul><li>功能：创建一个套接字</li></ul></li><li><p>参数：</p><ul><li>domain：协议族(常用如下)</li><li><code>AF_INET</code> ：<code>ipv4</code><ul><li><code>AF_INET</code>6 ：<code>ipv6</code></li><li><code>AF_UNIX</code>, <code>AF_LOCAL</code>：本地套接字通信（进程间通信）</li></ul></li><li>type：通信过程中使用的协议类型<ul><li><code>SOCK_STREAM</code> : 流式协议<ul><li><code>SOCK_DGRAM</code> : 报式协议</li></ul></li><li>protocol：具体的一个协议，一般写0，用于指定type参数的默认协议类型</li><li><code>SOCK_STREAM</code> : 流式协议默认使用 TCP</li><li><code>SOCK_DGRAM</code> : 报式协议默认使用 UDP</li></ul></li><li><p>返回值</p><ul><li>成功：返回文件描述符，操作的就是内核缓冲区</li></ul></li><li>失败：-1</li></ul></li><li><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p><ul><li>功能：绑定，将fd 和本地的IP和端口进行绑定</li><li>参数：<ul><li><code>sockfd</code>：通过socket函数得到的文件描述符</li><li><code>addr</code>：需要绑定的socket地址，这个地址封装了<strong>本地的ip和端口号的信息</strong></li><li><code>addrlen</code>：第二个参数结构体占的内存大小</li></ul></li><li>返回值：成功：0，失败：-1</li></ul></li><li><p><code>int listen(int sockfd, int backlog);</code></p><ul><li>功能：监听这个socket上的连接</li><li>参数：<ul><li><code>sockfd</code>：通过socket()函数得到的文件描述符</li><li><code>backlog</code>：未连接的和已经连接的和的最大值，可用<code>cat /proc/sys/net/core/somaxconn</code>查看Linux设置值</li></ul></li><li>返回值：<ul><li>成功：0</li><li>失败：-1</li></ul></li></ul></li><li><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p><ul><li>功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</li><li>参数：<ul><li><code>sockfd</code> : 用于监听的文件描述符</li><li><code>addr</code> : 传出参数，记录了连接成功后<strong>客户端的地址信息</strong>（ip，port）</li><li><code>addrlen</code> : 指定第二个参数的对应的内存大小</li></ul></li><li>返回值：<ul><li>成功：用于通信的文件描述符</li><li>失败：-1</li></ul></li></ul></li><li><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p><ul><li>功能： 客户端连接服务器</li><li>参数：<ul><li><code>sockfd</code> : 用于<strong>通信的文件描述符 </strong></li><li><code>addr</code> : 客户端要连接的服务器的地址信息</li><li><code>addrlen</code> : 指定第二个参数的对应的内存大小</li></ul></li><li>返回值：成功 0， 失败 -1</li></ul></li><li><p>其他读写函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>; <span class="comment">// 写数据 </span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://blog.csdn.net/baidu_41553551/article/details/126807285">C++11重写muduo网络库——预备知识</a></p></li><li><p>牛客webserver</p></li></ul>]]></content>
    
    
    <summary type="html">Linux网络-I/O多路复用:select/poll/epoll</summary>
    
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="https://penge666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Linux/"/>
    
    
    <category term="计算机网络" scheme="https://penge666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="linux" scheme="https://penge666.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>More Effective Cpp</title>
    <link href="https://penge666.github.io/posts/e584d079.html"/>
    <id>https://penge666.github.io/posts/e584d079.html</id>
    <published>2024-04-11T06:56:34.000Z</published>
    <updated>2024-04-12T03:08:54.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basics-基础议题"><a href="#Basics-基础议题" class="headerlink" title="Basics 基础议题"></a>Basics 基础议题</h1><h2 id="条款-1：仔细区别pointers和references"><a href="#条款-1：仔细区别pointers和references" class="headerlink" title="条款 1：仔细区别pointers和references"></a>条款 1：仔细区别pointers和references</h2><ol><li><p>指针和引用都是间接使用其他对象。</p></li><li><p>没有null reference，引用必须有初值，而指针没有此限制。因此引用使用时不用判断其有效性，而指针通常需要。</p><p>ex1：<strong>任何情况下都不能使用指向空值的引用。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pc = <span class="number">0</span>;<span class="comment">// 设置指针为空值</span></span><br><span class="line"><span class="type">char</span>&amp; rc = *pc;<span class="comment">// 让引用指向空值</span></span><br></pre></td></tr></table></figure><p>好处：不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针要高，因为在使用引用之前不需要检查它的合法性。</p><p>ex2：引用必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; rs;      <span class="comment">// 错误，引用必须被初始化。</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;XYZ&quot;</span>)</span></span>;</span><br><span class="line">string&amp; rs = s;  <span class="comment">// rs 指向 s。</span></span><br><span class="line">string *ps;      <span class="comment">// 未初始化的指针，有效，但风险高。</span></span><br></pre></td></tr></table></figure></li><li><p>reference总是指向（代表）初始化的对象，而指针可以被重新赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Nancey&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;Clancy&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string&amp; rs = s1;   <span class="comment">// rs 指向 s1。</span></span><br><span class="line">string *ps = &amp;s2;  <span class="comment">// ps 指向 s1。</span></span><br><span class="line">rs = s2;          <span class="comment">// rs 仍然代表 s1, 但是现在其值被赋为 s2 的值。</span></span><br><span class="line">ps = &amp;s2;          <span class="comment">// ps 现在指向 s2，s1 没有变化。</span></span><br></pre></td></tr></table></figure></li><li><p>结论：当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由pointers 达成，你就应该选择 references。任何其他时候，请采用pointers。</p></li></ol><h2 id="条款-2：最好使用C-转型操作符"><a href="#条款-2：最好使用C-转型操作符" class="headerlink" title="条款 2：最好使用C++转型操作符"></a>条款 2：最好使用C++转型操作符</h2><ol><li><p>C++中的4个转型操作符：<code>static_cast</code>, <code>const_cast</code>, <code>dynamic_cast</code>和 <code>reinterpret_cast</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(type) expression;             <span class="comment">// 旧的转型</span></span><br><span class="line"><span class="type">int</span> firstNumber, secondNumber;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> result = ((<span class="type">double</span>)firstNumber) / secondNumber;</span><br><span class="line"><span class="built_in">static_cast</span>&lt;type&gt;(expression); <span class="comment">//新的转型</span></span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(firstNumber) / secondNumber;</span><br></pre></td></tr></table></figure></li><li><p><code>const_cast</code> 用来改变表达式中的常量性（constness）或变易性（volatileness）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>: <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">( SpecialWidget *psw )</span></span>;</span><br><span class="line">SpecialWidget sw;              <span class="comment">// sw 是一个 non-const 对象</span></span><br><span class="line"><span class="type">const</span> SpecialWidget&amp; csw = sw; <span class="comment">// csw 是一个代表 sw 的 const 引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">update</span>( &amp;csw ); <span class="comment">//错误！不能将 const SpecialWidget*传递给一个需要 SpecialWidget* 的函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">update</span>( <span class="built_in">const_cast</span>&lt;SpecialWidget*&gt;(&amp;csw) ); <span class="comment">// 可行，&amp;csw 的常量下性被去除了， 因此csw（亦即sw）在此函数中可被更改。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">update</span>( ( SpecialWidget* )&amp;csw );  <span class="comment">// 和第9行情况相同，但使用的是较难识别的 C 旧式转型语法。</span></span><br><span class="line"></span><br><span class="line">Widget *pw = <span class="keyword">new</span> SpecialWidget;</span><br><span class="line"><span class="built_in">update</span>(pw); <span class="comment">// 错误！pw类型是Widget*，但update（）需要的是SpecialWidget*。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">update</span>( <span class="built_in">const_cast</span>&lt;SpecialWidget*&gt;(pw) ); <span class="comment">// 错误！const 只能影响常量性或易变性。</span></span><br></pre></td></tr></table></figure></li><li><p><code>dynamic_cast</code>，用来执行继承体系中“安全的向下转型或跨系转型动作”。可以<strong>利用<code>dynamic_cast</code>将指向基类对象的指针或引用转型为指向其派生类或兄弟类的指针或引用</strong>。<strong>成功返回1，失败会议一个<code>null</code>指针或者异常（当转型对象是引用）表现出来。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget *pw;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">update</span>( <span class="built_in">dynamic_cast</span>&lt;SpecialWidget*&gt;(pw) ); <span class="comment">// 如果转型成功，将传给 updata（）一个指针，指向 pw 所指的 SpecialWidget， 否则传给updata（）一个 null 指针。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateViaRef</span><span class="params">( SpecialWidget&amp; rsw)</span></span>;</span><br><span class="line"><span class="built_in">updateViaRef</span>( <span class="built_in">dynamic_cast</span>&lt;SpecialWidget&amp;&gt;(*pw) ); <span class="comment">// 如果转型成功，将传给 updateViaRef（） pw 所指的 SpecialWidget， 否则抛出一个异常。</span></span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li>static_cast：在功能上和C风格类型转换一样强大，含义也一样，可以被用于强制隐形转换（例如，non-const对象转换为const对象，int转型为double，等等）。</li><li>const_cast： 去掉const或volatileness属性的操作。</li><li>dynamic_cast：用于安全的沿着类的继承关系向下进行类型转换，失败的转换将返回空指针（针对指针进行类型转换）或者抛出异常（针对引用进行类型转换）。</li><li>reinterpret_cast：主要是将数据从一种类型的转换为另一种类型，是特意用于底层的强制转型，导致实现依赖（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。</li></ul><h2 id="条款-3：绝对不要以多态方式处理数组"><a href="#条款-3：绝对不要以多态方式处理数组" class="headerlink" title="条款 3：绝对不要以多态方式处理数组"></a>条款 3：绝对不要以多态方式处理数组</h2><ol><li><p>继承的重要性质之一就是，可以通过指向基类对象的指针或引用，来操作派生类。</p></li><li><p>当将派生类类型的数组传递给需要基类类型的数组时，其会安基类类型的大小来操作数组指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BST BSTArray[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, BSTArray, <span class="number">10</span>);  <span class="comment">// 没问题</span></span><br><span class="line"></span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printBSTArray</span>( cout, bBSTArray, <span class="number">10</span>); <span class="comment">// 将以 BST 类型处理 bBSTAraay 函数指针，即指针操作的步长为 sizeof(BST) </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="条款-4：非必要不提供default-constructor"><a href="#条款-4：非必要不提供default-constructor" class="headerlink" title="条款 4：非必要不提供default constructor"></a>条款 4：非必要不提供default constructor</h2><p><strong>（1）</strong>default constructor：在没有任何外来信息的情况下将对象初始化.</p><p><strong>（2）</strong>但是有些对象如果没有外来信息，就没有办法完成初始化动作，那么这些对象，就没有必要提供default constructor.</p><p><strong>（3）</strong>如果一个类缺乏default constructor，那么使用这个类的时候会存在一定的限制.</p><blockquote><p><strong>限制1</strong></p></blockquote><p>限制1：产生数组的时候，没有任何一个方法可以为数组中的对象指定constructor自变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EquipmentPiece bestPieces[<span class="number">10</span>];<span class="comment">//错误！</span></span><br><span class="line">EquipmentPiece *bestPieces=<span class="keyword">new</span> EquipmentPiece[<span class="number">10</span>];<span class="comment">//错误！</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>限制2</strong></p></blockquote><p>限制2：不适用于某些模板类</p><p>对那些模板而言，被实例化的目标类型必须得有一个default constructor，这是一个普遍的共同需求，因为那些模板内几乎总是会产生一个以template作为类型而构架起来的数组，当然，如果谨慎设计模板，可以避免这个问题，但是很多模板的设计者独缺谨慎，这样会导致缺乏default constructor的类不兼容于许多模板。</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个没有默认构造函数的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDefaultConstructor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//NoDefaultConstructor() &#123;&#125; 没有这句话就报错 </span></span><br><span class="line">    <span class="built_in">NoDefaultConstructor</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>() &#123;</span><br><span class="line">        <span class="comment">// 在构造函数中尝试使用默认构造函数</span></span><br><span class="line">        <span class="comment">// 但这会导致编译错误，因为T可能没有默认构造函数</span></span><br><span class="line">        <span class="comment">// obj = T();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObject</span><span class="params">(<span class="type">const</span> T&amp; object)</span> </span>&#123;</span><br><span class="line">        obj = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试使用模板类Container，并传入没有默认构造函数的类NoDefaultConstructor作为模板参数</span></span><br><span class="line">    Container&lt;NoDefaultConstructor&gt; container; <span class="comment">// 这一行将导致编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：在这个示例中，<code>NoDefaultConstructor</code> 是一个没有默认构造函数的类。然后，我们尝试将它作为模板参数传递给模板类 <code>Container</code>。由于 <code>Container</code> 在默认构造函数中尝试使用默认构造函数来初始化成员变量 <code>obj</code>，但 <code>NoDefaultConstructor</code> 没有默认构造函数，因此编译器会报错。</p><p><strong>（4）</strong>避免限制1的三种方法</p><p><strong>方法1：在堆栈中创建数组，并且使用显示初始化列表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a[<span class="number">5</span>]=&#123;A(<span class="number">1</span>),A(<span class="number">2</span>),A(<span class="number">3</span>),A(<span class="number">4</span>),A(<span class="number">5</span>)&#125;;</span><br></pre></td></tr></table></figure><p>缺点：比较麻烦，如果数组元素有1W个，那么要写1w个构造函数，显然不可能</p><p>并且只适用于堆栈数组，堆中没有此语法(C++中堆栈指的是栈)</p><p><strong>方法2：使用指针数组，而非对象数组</strong></p><p>使用指针数组(<strong>指针不受构造函数的束缚</strong>)。如 A* ptr_A[10];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> EquipmentPiece* PEP;</span><br><span class="line">PEP a[<span class="number">10</span>];</span><br><span class="line">PEP *b=new PEP[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>理由：在大多数平台上，<strong>指针的大小通常是相同的</strong>。无论是指向对象的指针、指向函数的指针还是指向任何其他类型的指针，它们的大小通常是相同的。这是因为指针在内存中存储的是地址，而地址的大小在大多数现代计算机体系结构中都是相同的。</p><p>例子：</p><p>现在我们想要创建一个指针数组，其中存储的是指向 <code>Shape</code> 类对象的指针，但我们不想受到构造函数的束缚，也就是说，我们希望能够动态地创建 <code>Circle</code> 和 <code>Square</code> 对象，并将它们存储到指针数组中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">draw</span><span class="params">()</span> <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtual ~Shape() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">draw</span><span class="params">()</span> <span class="type">const</span> override &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">draw</span><span class="params">()</span> <span class="type">const</span> override &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drawing a square&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个指针数组，存储 Shape 类对象的指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">2</span>;</span><br><span class="line">    Shape* shapes[size];<span class="comment">// </span></span><br><span class="line">    <span class="comment">// 创建 Circle 和 Square 对象，并将它们的指针存储到指针数组中</span></span><br><span class="line">    shapes[<span class="number">0</span>] = new Circle();</span><br><span class="line">    shapes[<span class="number">1</span>] = new Square();</span><br><span class="line">    <span class="comment">// 遍历指针数组，调用 draw() 方法来绘制各种形状</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        shapes[i]-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放指针数组中的内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        delete shapes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组中的各个指针可以用来指向一个个不同的对象</p><p>缺点：</p><p>1.不再需要这些对象时必须将此数组所指向的对象删除，避免内存泄漏</p><p>2.存放指针数组，需要额外的空间</p><p><strong>方法3：使用内存池，使用operator new[]函数预先申请一块内存，要使用的时候再使用placement new(定位new)依次构造</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquipmentPiece</span>&#123;</span><span class="comment">//该类缺乏default constructor</span></span><br><span class="line">public:</span><br><span class="line">    EquipmentPiece(<span class="type">int</span> IDNumber)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//分配足够的raw memory，给一个预备容纳10个EquipmentPiece 对象的数组使用</span></span><br><span class="line">    <span class="type">void</span> *rawMemory=operator new[](<span class="number">10</span>*<span class="keyword">sizeof</span>(EquipmentPiece));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//让bestPieces指向此块内存，使得这块内存被视为一个EquipmentPiece数组</span></span><br><span class="line">    EquipmentPiece *bestPieces=static_cast&lt;EquipmentPiece*&gt;(rawMemory);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用placement new 构造这块内存中的EquipmentPiece对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        new (&amp;bestPieces[i]) EquipmentPiece(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以在堆中创建数组，并且不需要占用额外空间</p><p>缺点：</p><p>1）在数组内对象的生命周期结束时需要手动调用其析构函数，然后调用operator delete[]释放这块内存</p><p>2）如果采用一般的数组删除语法，程序行为将不可预期，因为删除一个不可以new operator获得的指针，其结果没有定义</p><p><strong>（5）</strong>总结</p><p>添加没有意义的default constructor，也会影响classes的效率，如果member function 必须测试字段是否真被初始化了，其调用者必须为测试行为付出时间代价，并且为测试代码付出空间代价，因为可执行文件和程序库都变大了，万一测试结果为否定，对应的测试程序又要付出一些空间代价，如果class constructors可以确保对象的所有字段都会被正确初始化，上述所有成本都可以免除，<strong>如果default constructor无法提供这种保证，那么最好避免让default constructor出现，虽然这可能会对classses的使用方式带来某种限制，但同时也带来一种保证</strong>，当你真的使用了这样的classes，你可以预期他们所产生的对象会被完全的初始化，实现上也富有效率</p><h1 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators 操作符"></a>Operators 操作符</h1><h2 id="条款-5：对定制的“类型转换函数”保持警觉"><a href="#条款-5：对定制的“类型转换函数”保持警觉" class="headerlink" title="条款 5：对定制的“类型转换函数”保持警觉"></a>条款 5：对定制的“类型转换函数”保持警觉</h2><hr><p>总结</p><ol><li>单变量(或其他变量有默认参数）构造函数ctor：可能触发不必要的隐式转换，所以尽量用explict修饰</li><li>隐式类型转换符最好只有bool类型，其他类型的用别名函数代替（asDouble）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line">    Rational(<span class="type">int</span> number, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 推荐：exlicit Rational(int number， int denominator = 1);</span></span><br><span class="line">    operator <span class="title function_">double</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">    <span class="comment">// 推荐： opeartor asDouble() const;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rational <span class="title function_">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>; <span class="comment">// 1/2</span></span><br><span class="line"><span class="comment">// 没有定义 opeartor&lt;&lt;，为了让&lt;&lt;调用成功而默认执行了 double()</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// r-&gt;double-&gt; 0.5;</span></span><br></pre></td></tr></table></figure><hr><ol><li><p>编译器允许使用单自变量构造函数（单一自变量成功调用的）和隐式类型转换操作符（关键词operator 之后加上一个类型名称）进行类型转换。</p></li><li><p>类型转换很可能在你未预期的情况下进行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Name</span>(<span class="type">const</span> string&amp; s); <span class="comment">// 将 string 转换为 Name  </span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>); <span class="comment">// 将 int 转换为 Rational</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 将 Rational 转换为 double</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下情况自动调用隐式类型转换操作符函数</span></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">0.5</span> * r; <span class="comment">// 将 r 转换为 double, 然后执行乘法运算</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; r; <span class="comment">// 若你并未为 Rational 定义 &lt;&lt; 操作符其也能通过编译并运行，因为 r 会隐式的转换为能和 &lt;&lt; 匹配的类型（ 此处为double ）类型输出</span></span><br></pre></td></tr></table></figure></li><li><p>解决第二点的方法是以功能对等的另一个函数取代类型转换操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">asDouble</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; r; <span class="comment">// 错误！ Rationals 没有 operator&lt;&lt;</span></span><br><span class="line">cout &lt;&lt; r.<span class="built_in">asDouble</span>(); <span class="comment">// 以 double 的形式输出 r</span></span><br></pre></td></tr></table></figure></li><li><p>将构造函数声明为 <code>explicit</code>，编译器便不能因隐式类型转换的需要而调用它们。</p></li><li><p>允许编译器执行隐式类型转换，害处将多过好处。所以不要提供转换函数，除非你确定你需要它们。</p></li></ol><h2 id="条款-6-区别-increment-decrement-操作符的前置和后置形式"><a href="#条款-6-区别-increment-decrement-操作符的前置和后置形式" class="headerlink" title="条款 6:区别 increment / decrement  操作符的前置和后置形式"></a>条款 6:区别 increment / decrement  操作符的前置和后置形式</h2><ol><li><p>重载函数是以其<strong>参数类型</strong>来区分彼此的，然而不论 increment 或 decrement 操作符的前置式或后置式，都没有参数。为了填平这个语言学上的漏洞，只好让后置式有一个 int 自变量，并且在它被调用时，<strong>编译器默默地为该 int 指定一个 0值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPInt</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>++(); <span class="comment">// prefix ++</span></span><br><span class="line">    <span class="type">const</span> UPInt <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// postfix ++</span></span><br><span class="line">    </span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>--(); <span class="comment">// prefix --</span></span><br><span class="line">    <span class="type">const</span> UPInt <span class="keyword">operator</span>--(<span class="type">int</span>); <span class="comment">// postfix -- </span></span><br><span class="line">    </span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>+=(<span class="type">int</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>increment 操作符的前置式意义“increment and fetch”（累加然后取出），后置式意义“fetch and increment”（取出然后累加）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;    <span class="comment">// increment</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// fetch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// fetch</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);              <span class="comment">// increment</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后置式 increment 和 decrement 操作符的实现应以其前置式兄弟为基础。如此一来你就只需维护前置式版本，因为后置式版本会自动调整为一致的行为。</p></li><li><p>后置累加或减操作返回<code>const</code>对象是防止 <code>i++++</code> 行为。</p></li></ol><h2 id="条款-7：千万不要重载-amp-amp-，-和-操作符"><a href="#条款-7：千万不要重载-amp-amp-，-和-操作符" class="headerlink" title="条款 7：千万不要重载 &amp;&amp;，|| 和 ,  操作符"></a>条款 7：千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code>  操作符</h2><ol><li><p>和 C 一样，C++对于“真假值表达式”采用所谓的“骤死式”评估方式。意思是一旦该表达式的真假值确定，即使表达式中还有部分尚未检验，整个评估工作仍告结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((p != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>)) <span class="comment">// 若 p 为 NULL 表达式直接为假， 不会调用后续 strlen()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但重载的 <code>&amp;&amp;</code> 和 <code>||</code>做不到“骤死式”。在下列示例中问题在于：1，<strong>函数调用被执行时所有的参数都已评估完成，所以 <code>&amp;&amp;</code> 两边的表达式都将运行</strong>；2，<strong>C++中没有规范函数调用中的参数的评估顺序，也就是我们不知道 <code>&amp;&amp;</code> 两边的表达式那个先运行</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) <span class="comment">// 假设 operator&amp;&amp; 是个成员函数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) <span class="comment">// 假设 operator&amp;&amp; 是个全局函数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作符重载的目的是要让程序更容易被阅读、被撰写、被理解，不是为了向别人夸耀你知道“逗号其实是个操作符”。如果你没有什么好理由将某个操作符重载，就不要去做。</p></li></ol><h2 id="条款-8：了解各种不同意义的-new-和-delete"><a href="#条款-8：了解各种不同意义的-new-和-delete" class="headerlink" title="条款 8：了解各种不同意义的 new 和 delete"></a>条款 8：了解各种不同意义的 <code>new</code> 和 <code>delete</code></h2><ol><li><p>new operator，第一，它分配足够的内存，用来放置某类型的对象。以上例而言，它分配足够放置一个string 对象的内存。第二，它调用一个 constructor，为刚才分配的内存中的那个对象设定初值。new operator 总是做这两件事，无论如何你不能够改变其行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>new operator调用某个函数，执行必要的内存分配动作，你可以重写或重载那个函数，改变其行为。这个函数的名称叫做 operator new。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *rawMemory = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(string)); <span class="comment">// 调用 operator new</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>new []</code> 时要匹配使用 <code>delete []</code>。【这个在effectivate C++中有详细说明】</p></li></ol><h1 id="Exceptions-异常处理"><a href="#Exceptions-异常处理" class="headerlink" title="Exceptions 异常处理"></a>Exceptions 异常处理</h1><h2 id="条款-9：利用析构函数避免资源泄漏"><a href="#条款-9：利用析构函数避免资源泄漏" class="headerlink" title="条款 9：利用析构函数避免资源泄漏"></a>条款 9：利用析构函数避免资源泄漏</h2><ol><li>以一个对象存放“必须自动释放的资源”，并依赖该对象的 destructor 释放——亦可对“以指针为本”以外的资源施行。</li><li>把资源封装在对象内，通常便可以在 exceptions出现时避免泄漏资源。</li></ol><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processAdoption</span><span class="params">(istream&amp; dataSource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(dataSource)</span><br><span class="line">    &#123;</span><br><span class="line">        ALA* pa = readALA(dataSource);</span><br><span class="line">        pa-&gt;processAdoption();</span><br><span class="line">        delete pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码如果pa-&gt;processAdoption()跑出异常，那么delete pa不会执行，导致内存泄露。</p><p><strong>解决方法之一</strong>，利用try-catch捕捉，不好之处就是程序流程被打乱：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processAdoption</span><span class="params">(istream&amp; dataSource)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(dataSource)</span><br><span class="line">    &#123;</span><br><span class="line">        ALA* pa = readALA(dataSource);</span><br><span class="line">        try&#123;</span><br><span class="line">            pa-&gt;processAdoption();</span><br><span class="line">        &#125;catch(...)&#123;</span><br><span class="line">            delete pa;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        delete pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法之二</strong>，就是智能指针（auto_ptr是C++98的，现在提倡使用unique_ptr）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoption</span><span class="params">(istream&amp; dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(dataSource)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">auto_ptr&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">        pa-&gt;<span class="built_in">processAdoption</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法之三</strong>，封装资源，令其constructor和destructor分别获取资源和释放资源（模仿智能指针）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此函数可能抛出异常之后发生资源泄露问题。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span><br><span class="line">&#123;</span><br><span class="line">    WINDOW_HANDLE <span class="title function_">w</span><span class="params">(createWindow())</span>;</span><br><span class="line">    display info in window corresponding to w;</span><br><span class="line">    destroyWindow(w);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//封装的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    WindowHandle(WINDOW_HANDLE handle):w(handle)&#123;&#125;</span><br><span class="line">    ~WindowHandle()&#123;destroyWindow(w);&#125;</span><br><span class="line">    operator <span class="title function_">WINDOW_HANDLE</span><span class="params">()</span>&#123;<span class="keyword">return</span> w;&#125;</span><br><span class="line">private:</span><br><span class="line">    WINDOW_HANDLE w;</span><br><span class="line">    WindowHandle(<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">    WindowHandle&amp; operator=(<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述看起来就像auto_ptr一样。</p><p>有了这个封装类，我们重写displayInfo函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">WindowHandlew</span>(<span class="built_in">createWindow</span>());</span><br><span class="line">    display info in window corresponding to w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在即使displayInfo跑出异常，createWindow产生的窗口还是会被销毁。</p><h2 id="条款-10：在构造函数内阻止资源泄漏"><a href="#条款-10：在构造函数内阻止资源泄漏" class="headerlink" title="条款 10：在构造函数内阻止资源泄漏"></a>条款 10：在构造函数内阻止资源泄漏</h2><p>用函数try语句块来确保构造函数不抛出异常、用智能指针来管理类中的指针资源避免手动释放。</p><blockquote><p>TITLE：在constructors内阻止资源泄露（resource leak)</p></blockquote><ol><li><p><strong>注意没有构造完成的对象，是无法被析构的（就是不会调用析构函数）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(<span class="built_in">initializer_list</span>&lt;T&gt; il) try: data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(il) &#123; </span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125; catch(<span class="type">const</span> <span class="built_in">std</span>::bad_alloc &amp;e) &#123; handle_out_of_memory(e); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：如果你用对用的auto_ptr对象【智能指针】代替指针成员变量，就可以防止构造函数存在异常时候导致资源泄露，你也不用手动析构函数中释放对象，并且你还能像以前使用非const指针一样使用const指针给其赋值。</strong></p><h2 id="条款-11：禁止异常流出析构函数之外"><a href="#条款-11：禁止异常流出析构函数之外" class="headerlink" title="条款 11：禁止异常流出析构函数之外"></a>条款 11：禁止异常流出析构函数之外</h2><ol><li><strong>两种情况下 destructor 会被调用</strong>。<ol><li>第一种情况是当对象在正常状态下被销毁，也就是当它<strong>离开了它的生存空间</strong>（scope）或是被明确地删除。</li><li>第二种情况是<strong>当对象被 exception 处理机制</strong>——也就是exception 传播过程中的 stack-unwinding（栈展开）机制—销毁。</li></ol></li><li>有两个好理由支持我们“全力阻止 exceptions传出 destructors 之外。<ol><li>第一，它可以避免 <strong>terminate函数</strong>【<a href="https://blog.csdn.net/wangyin159/article/details/46584257?ref=myread】在">https://blog.csdn.net/wangyin159/article/details/46584257?ref=myread】在</a> exception传播过程的栈展开（stack-unwinding）机制中被调用。</li><li>第二，它可以协助确保  destructors  完成其应该完成的所有事情。</li></ol></li></ol><h2 id="条款-12：了解“抛出一个-exception”与“传递一个参数”或“调用一个虚函数”之间的差异"><a href="#条款-12：了解“抛出一个-exception”与“传递一个参数”或“调用一个虚函数”之间的差异" class="headerlink" title="条款 12：了解“抛出一个 exception”与“传递一个参数”或“调用一个虚函数”之间的差异"></a>条款 12：了解“抛出一个 exception”与“传递一个参数”或“调用一个虚函数”之间的差异</h2><ol><li>原因是当你调用一个函数，控制权最终会回到调用端（除非函数失败以至于无法返回），但是当你抛出一个 exception，控制权不会再回到抛出端。</li><li>一个对象被抛出作为 exception时，总是会发生复制（copy）。</li><li>异常只关心静态类型。</li><li>exceptions 与 <code>catch</code>子句相匹配”的过程中，仅有两种转换可以发生。第一种是“继承架构中的类转换（inheritance-based conversions）”。第二个允许发生的转换是从一个“有型指针”转为“无型指针”，所以一个针对 <code>const void*</code>指针而设计的 catch子句，可捕捉任何指针类型的 exception。</li><li><code>catch</code>子句总是依出现顺序做匹配尝试。</li><li>虚函数遵循最佳吻合策略（best fit），异常处理机制遵循最先吻合策略（first fit）。 因此绝不要将“针对base class 而设计的 catch子句”放在“针对 derived class 而设计的catch 子句”之前。</li></ol><h2 id="条款-13：以-by-reference-的方式捕捉异常"><a href="#条款-13：以-by-reference-的方式捕捉异常" class="headerlink" title="条款 13：以 by reference 的方式捕捉异常"></a>条款 13：以 by reference 的方式捕捉异常</h2><ol><li><p>不要以指针的方式抛出异常，会有何时释放资源的难题，也无法捕捉标准异常。</p></li><li><p>使用传值的方式抛出异常时，每次有异常抛出，将发生复制两次。当派生类对象被接收基类异常的<code>catch</code>捕捉时，将发生对象切割，同时，当其虚函数在异常中调用时，将被解析为基类的虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">exception</span> <span class="comment">// 标准的 exception class</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">runtime_error</span>: <span class="keyword">public</span> exception &#123; ... &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validation_error</span>: <span class="keyword">public</span> runtime_error <span class="comment">// 新增的 class</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (a validation test fails)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Validation_error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">someFunction</span>();    <span class="comment">// 可能会抛出一个有效的 exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception ex)   <span class="comment">// 捕捉标准继承体系内的所以 exceptions （或其派生类）</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; ex.<span class="built_in">what</span>(); <span class="comment">// 调用的是 exception::what() </span></span><br><span class="line">        ...                <span class="comment">// 而不是 Validation_error::what()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ol><li>by reference捕捉异常的好处有3：①throw对象不会被切割、②标准库里exception 通常都throw对象（我们我们用by pointer类型不匹配），而refernce可以绑定对象、③约束了exception obj复制的次数（就throw时复制一次）</li><li>by pointer缺点：不符合上述②，标准库里都throw对象</li><li>by value缺点：不符合上述①，throw出的对象会被切割，无法调用虚函数。</li></ol><h2 id="条款-14：明智运用-exception-specifications"><a href="#条款-14：明智运用-exception-specifications" class="headerlink" title="条款 14：明智运用 exception specifications"></a>条款 14：明智运用 exception specifications</h2><h2 id="条款-15：了解异常处理"><a href="#条款-15：了解异常处理" class="headerlink" title="条款 15：了解异常处理"></a>条款 15：了解异常处理</h2><h1 id="Efficiency-效率"><a href="#Efficiency-效率" class="headerlink" title="Efficiency 效率"></a>Efficiency 效率</h1><h2 id="条款-16：谨记-80-20-法制"><a href="#条款-16：谨记-80-20-法制" class="headerlink" title="条款 16：谨记 80-20 法制"></a>条款 16：谨记 80-20 法制</h2><ol><li>软件中的80%的时间浪费在了20%的代码上。</li></ol><h2 id="条款-17：考虑使用-lazy-evaluation"><a href="#条款-17：考虑使用-lazy-evaluation" class="headerlink" title="条款 17：考虑使用 lazy evaluation"></a>条款 17：考虑使用 lazy evaluation</h2><ol><li><p>从效率的观点来看，最好的运算是从未被执行的运算。</p></li><li><p><strong>Reference Counting（引用计数）-  避免非必要的对象复制</strong>：在你真正需要之前，不必着急为某物做一个副本。取而代之的是，以拖延战术应付之——只要能够，就使用其他副本。在某些应用领域，你常有可能永远不需要提供那样一个副本。</p><ol><li><strong>比如string s2 = s1，但是后续的操作op1_s2, op2_s2，等等都是不改变s2的，所以只要让s2和s1共享即可，当真正要改变s2时才拷贝s1。</strong></li></ol></li><li><p><strong>区分读和写</strong>:读取操作往往代价低廉，写操作可能效率低，开销大。如果能延缓决定“究竟是读还是写，直到能确定为止”将提高效率。</p><ol><li><strong>对于一个refer但是此处法无法判定是否能区分，如果能够在operator[]里面区分读和写，就可以判定需不需要做额外的操作。s[3]作为左边的值是写，s[3]作为右边的值是读。</strong></li></ol></li><li><p>Lazy Fetching（缓式取出）：生产一个对象时，只产生该对象的“外壳”，不从磁盘读取任何字段数据。当对象内的某个字段被需要了，程序才取回对应的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LargeObject</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LargeObject</span>(ObjectID id);</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">field1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">field2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">field3</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">field4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ObjectID oid;</span><br><span class="line">    <span class="keyword">mutable</span> string *field1Value;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> *field2Value;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">double</span> *field3Value;</span><br><span class="line">    <span class="keyword">mutable</span> string *field4Value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LargeObject::<span class="built_in">LargeObject</span>(ObjectID id)</span><br><span class="line">    : <span class="built_in">oid</span>(id), <span class="built_in">field1Value</span>(<span class="number">0</span>), <span class="built_in">field2Value</span>(<span class="number">0</span>), <span class="built_in">field3Value</span>(<span class="number">0</span>), ...&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">LargeObject::field1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (field1Value == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//read the data for field 1 from the database and </span></span><br><span class="line">        <span class="comment">//meke field1Value point to it;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *field1Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Lazy Expression Evaluation（表达式缓评估）：将表达式的值暂存起来，需要时再计算它（往往需要只一部分，则只计算一部分）。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span>...&#125;;<span class="comment">//for homogeneous matrices</span></span><br><span class="line"> </span><br><span class="line">Matrix&lt;<span class="type">int</span>&gt; <span class="title function_">m1</span><span class="params">(<span class="number">1000</span>,<span class="number">1000</span>)</span>;<span class="comment">//一个1000*1000的矩阵</span></span><br><span class="line">Matrix&lt;<span class="type">int</span>&gt; <span class="title function_">m2</span><span class="params">(<span class="number">1000</span>,<span class="number">1000</span>)</span>;</span><br><span class="line">...</span><br><span class="line">Matrix&lt;<span class="type">int</span>&gt; m3 = m1 + m2;</span><br></pre></td></tr></table></figure><p>   过operator 的实现是eagar evaluation：在这种情况下，它会计算和返回m1 与 m2的和。这个计算量非常大（100000次加法运算），当然系统会分配内存来存储这个值。</p><p> lazy evaluation方法就是建立一个数据结构来表示m3的值是m1和m2的和，再用一个enum来表示它们之间的加法，这样数据结构要比m1和m2相加快许多，也能节约内存。</p></li></ol><h2 id="条款-18：分期摊还预期的计算成本"><a href="#条款-18：分期摊还预期的计算成本" class="headerlink" title="条款 18：分期摊还预期的计算成本"></a>条款 18：分期摊还预期的计算成本</h2><ol><li><p>Over-eager evaluation 背后的观念是，如果你预期程序常常会用到某个计算，你可以降低每次计算的平均成本，办法就是设计一份数据结构以便能够极有效率地处理需求。</p></li><li><p>将“已经计算好而有可能再被需要”的数值保留下来（所谓 caching）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCubicleNumber</span><span class="params">(<span class="type">const</span> string&amp; employeeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;string, <span class="type">int</span>&gt; CubicleMap;</span><br><span class="line">    <span class="type">static</span> CubicleMap cubes;   <span class="comment">// 局部缓存</span></span><br><span class="line">    </span><br><span class="line">    CubicleMap::iterator it = cubes.<span class="built_in">find</span>(employeeName);</span><br><span class="line">    <span class="keyword">if</span> (it == cubes.end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cubicle = <span class="comment">/* the result of looking up employeeName&#x27;s cubicle number</span></span><br><span class="line"><span class="comment">                         in the database */</span></span><br><span class="line">        cubes[employeeName] = cubicle;</span><br><span class="line">        <span class="keyword">return</span> cubicle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (*it).second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Prefetching（预先取出）</p></li><li><p>当你必须支持某些运算而其结果几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation 可以改善程序效率。</p></li></ol><h2 id="条款-19：了解临时对象的来源"><a href="#条款-19：了解临时对象的来源" class="headerlink" title="条款 19：了解临时对象的来源"></a>条款 19：了解临时对象的来源</h2><p>只要你产生一个no-heap-object而没有为它命名，便产生了一个临时对象。</p><p>临时对象的产生途径：</p><ul><li><p>当隐式型别转换被施行起来以求函数能够调用成功。</p></li><li><p>当函数返回对象的时候。</p></li></ul><p>1.<strong>当隐式型别转换被施行起来以求函数能够调用成功</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">countChar</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; str,<span class="type">char</span> ch)</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str;<span class="comment">//统计字符出现的个数，略掉</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;buffer;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;countChar(buffer,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><p>解释：利用char buffer[20]调用countChar(string&amp; str,char ch)需要做哪些事情呢？</p><p>重点：先转化，构造一个string类型的临时对象，以buffer为自变量，调用string constructor，<strong>str就会绑定在临时对象上面【在调用函数的时候存在调用栈上】</strong>。</p><p>【<strong>重点中的重点</strong>】<strong>请注意，这边str是const string &amp;类型，也就是不允许改变str的值，即绑定在该临时对象上面，读取临时对象的值，而没有改变临时对象的值，改变临时对象的值是没有意义的，临时对象会被销毁。</strong></p><p>只有当对象以 by value(传值)方式传递，或是当对象被传递给一个reference-to-const（常引用）参数时，转换才会发生。当对象传递给一个reference-to-non-const参数，并不会发生此种转换。</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">countChar</span><span class="params">( string&amp; str,<span class="type">char</span> ch)</span>&lt;/strong&gt;</span>&#123;</span><br><span class="line">cout&lt;&lt;str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> cin&gt;&gt;c&gt;&gt;buffer;</span><br><span class="line"> cout&lt;&lt;<span class="built_in">countChar</span>(buffer,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述的<code>size_t countChar(const string&amp; str,char ch)</code> 修改为<code>size_t countChar( string&amp; str,char ch)</code>，编译立刻出错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error </span>C2664: “countChar”: 不能将参数 1 从“char [20]”转换为“std::string &amp;”</span><br></pre></td></tr></table></figure><p>即无法进行类型转换。</p><p><strong>理由：string&amp; str 是 references-to-non-const ,如果编译器针对 references-to-non-const 对象进行隐式型别转换，会允许临时对象被改变。改变临时对象是没有意义的。references-to-const参数则不需要承担这一问题，因为此参数为const，无法改变其内容。</strong></p><p><strong>2.当函数返回对象的时候。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Number operator+(<span class="type">const</span> Number&amp; lhs, <span class="type">const</span> Number&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Obj(lhs)+=rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回可以用类似复合语句(+=, -=，…)来优化返回时临时对象的个数。</li><li>注意函数返回引用：是不产生临时对象的。</li></ul><h2 id="条款-20：协助完成”返回值优化（return-value-optimization）“"><a href="#条款-20：协助完成”返回值优化（return-value-optimization）“" class="headerlink" title="条款 20：协助完成”返回值优化（return value optimization）“"></a>条款 20：协助完成”返回值优化（return value optimization）“</h2><ol><li><p>尽量写出编译器可帮你消除临时对象+返回值对象的拷贝的代码</p></li><li><p>如果还可以将函数inline，编译器还消除了函数调用的成本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numberator</span>() * rhs.<span class="built_in">number</span>(), ...); </span><br><span class="line">    <span class="comment">// 这就是ctor arguments，直接一个return 没有临时对象的成本，就能够被编译器优化！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总共两个成本：</span></span><br><span class="line">    <span class="comment">//  1. 临时对象的成本：Rational(lhs.numberator() * rhs.number(), ...); </span></span><br><span class="line">    <span class="comment">//  2. ByValue返回值的成本：因为你const Rational&amp; 在这里无法办到</span></span><br><span class="line">&#125;</span><br><span class="line">Rational c = a * b;  <span class="comment">// 调用这个时能够被忽略！！</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="条款-21：利用重载技术避免隐式转换"><a href="#条款-21：利用重载技术避免隐式转换" class="headerlink" title="条款 21：利用重载技术避免隐式转换"></a>条款 21：利用重载技术避免隐式转换</h2><ol><li><strong>每个“重载操作符”必须获得至少一个“用户定制类型”的自变量。</strong></li></ol><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UPInt</span>();</span><br><span class="line"><span class="built_in">UPInt</span>(<span class="type">int</span> value);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt* lhs,<span class="type">const</span> UPInt* rhs);</span><br><span class="line"> </span><br><span class="line">UPInt upi1,upi2;</span><br><span class="line">...</span><br><span class="line">UPInt upi3 = upi1 +upi2;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upi3 = upi1 + <span class="number">10</span>;</span><br><span class="line">upi3 = <span class="number">10</span> + upi1;</span><br></pre></td></tr></table></figure><p>这里的10会建立临时对象把整型10转换成UPInt，经历转换会有开销。</p><p>为了避免开销，如果我们想把UPInt和int对象相加，通过声明函数来达到目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UPInt operator+(<span class="type">const</span> UPInt* lhs,<span class="type">const</span> UPInt* rhs);<span class="comment">//UPInt相加</span></span><br><span class="line"><span class="type">const</span> UPInt operator+(<span class="type">const</span> UPInt* lhs,<span class="type">int</span> rhs); <span class="comment">//UPInt和int相加</span></span><br><span class="line"><span class="type">const</span> UPInt operator+(<span class="type">int</span> lhs,<span class="type">const</span> UPInt* rhs); <span class="comment">//int和UPInt相加</span></span><br><span class="line">UPInt upi1,upi2;</span><br><span class="line">...</span><br><span class="line">UPInt upi3 = upi1 +upi2;<span class="comment">//UPInt相加</span></span><br><span class="line"> </span><br><span class="line">upi3 = upi1 + <span class="number">10</span>;<span class="comment">//不会生成临时对象</span></span><br><span class="line">upi3 = <span class="number">10</span> + upi1;<span class="comment">//不会生成临时对象</span></span><br></pre></td></tr></table></figure><p>请注意：</p><p><strong>C++规定：每一个重载的operator必须带有一个用户自定义类型</strong>。也在本条款的最前面给出。</p><p>错误代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">int</span> lhs,<span class="type">int</span> rhs);</span><br></pre></td></tr></table></figure><h2 id="条款-22：考虑以操作符复合形式取代其独身形式"><a href="#条款-22：考虑以操作符复合形式取代其独身形式" class="headerlink" title="条款 22：考虑以操作符复合形式取代其独身形式"></a>条款 22：考虑以操作符复合形式取代其独身形式</h2><p>对于下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + y ; x = x - y;</span><br></pre></td></tr></table></figure><p>也可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x += y;  x -= y;</span><br></pre></td></tr></table></figure><p>正如这个条款的题目所言：</p><p><strong>以操作符复合形式取代其独身形式</strong>。operator的复合形式与一个单独形式之间存在正常的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator+根据operator+=来实现</span></span><br><span class="line"><span class="type">const</span> Rational operator+(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Rational(lhs) += rhs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//operator-根据operator-=来实现</span></span><br><span class="line"><span class="type">const</span> Rational operator-(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Rational(lhs) -= rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：</p><p><strong>operator复合形式比单独形式效率高</strong>，<strong>因为单独形式要返回一个新的对象【因为要创建个新对象作为最终的值】</strong>，<strong>从而在临时对象的构造和释放有一些开销，operator复合形式把结果写到左边的参数里，因此不需要临时对象来容纳operator的返回值</strong>。</p><h2 id="条款-23：考虑使用其他程序库"><a href="#条款-23：考虑使用其他程序库" class="headerlink" title="条款 23：考虑使用其他程序库"></a>条款 23：考虑使用其他程序库</h2><p>iostream和stdio之间性能的对比。</p><p>我们需要有这样的意识，具有相同功能的不同的程序库在性能上采取不同的权衡措施，所以一旦找到程序的瓶颈，你应该知道是否可以通过替换程序库来消除瓶颈。比如如果你的程序的有I/O瓶颈，你考虑用stdio替换iostream，如果程序的在动态分配和释放上存在使用大量的时间，你可以想想是否有其他的operator new和operator delete的实现可用。因为不同的程序库在效率、可扩展性、移植性、类型安全和其他一些重要领域上蕴含着不用的设计理念，通过变更使用给予性能的更多考虑的程序库，你有时可以大幅度提高软件的效率。</p><h2 id="条款-24：了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification的成本"><a href="#条款-24：了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification的成本" class="headerlink" title="条款 24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本"></a>条款 24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本</h2><p>虚函数有4个成本需要注意：</p><ol><li>每个拥有虚函数的类，需要一个vtbl（其大小由虚函数个数决定)，用于保存其可调用虚函数的指针。</li><li>每个拥有虚函数的对象，需要一个vptr，用于指向vtbl</li><li>虚函数应当不写inline关键字。避免这样写，有些编译器能帮忙优化，有些编译器不会。<ol><li>vtbl放在那里呢？一般而言：<code>class&#39;s vtbl</code>通常放在其第一个<code>non-inline, non-pure</code>虚函数定义的目标文件中，比如<code>class C1</code>的vtbl可能放在定义<code>C1::~C1</code>的目标文件中。或者编译器会让你选择，vtbl放在那里。【在大多数情况下，虚函数表（vtable）是与拥有虚函数的类放在一起的，但并不总是这样。具体取决于编译器和平台的实现。（gpt的答案）】</li><li>因为虚函数如果可以inline（相当于define在header中），会导致<code>vtbl</code>需要拷贝到每一个使用了此<code>class&#39;s vtbl</code>的目标文件中。<ol><li><strong>如果你在类的声明中将虚函数定义为内联函数（inline），编译器会尝试在每个使用了这些虚函数的地方直接插入函数的代码</strong>，而不是通过调用虚函数表来调用函数。这样做会导致虚函数表的内容被复制到每个使用了这些虚函数的目标文件中，而不是集中放在一个地方。</li><li>如果<strong>将虚函数定义为内联函数</strong>，并且虚函数表的内容被复制到每个使用了这些虚函数的目标文件中，那么在<strong>调用这些虚函数时就不会发生多态</strong>。</li></ol></li></ol></li><li>每个class对应的vtbl，需要指向一个type_info对象，type_info对象用于保存其类型信息。.</li></ol><p>注意：</p><ul><li><p>class的vtble常见的位置，是在第一个【非inline，非纯虚函数】(non-inline, non-pure) 的定义文件中。</p></li><li><p>多重继承导致需要虚基类，而虚基类会让隐藏指针vptr变多，占用空间。</p><ul><li><p>A是BC的虚基类，D继承BC，所以对D来说，它的内存结果如下右图。BC要指向共同的A的pointer to virtual base部分，BCAD都有自己的vptr</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/3.png" alt=""></p></li></ul></li></ul><h1 id="Techniques-技术"><a href="#Techniques-技术" class="headerlink" title="Techniques 技术"></a>Techniques 技术</h1><h2 id="条款-25：将构造函数和非成员函数虚化"><a href="#条款-25：将构造函数和非成员函数虚化" class="headerlink" title="条款 25：将构造函数和非成员函数虚化"></a>条款 25：将构造函数和非成员函数虚化</h2><ol><li>所谓 virtual constructor 是某种函数，视其获得的输入，可产生不同类型的对象。</li><li>如果函数的返回类型是个指针（或reference），指向一个base class，那么 derived class 的函数可以返回一个指针（或reference），指向该 base class 的一个 derived class。</li><li>写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Expr_node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;</span><br><span class="line">    <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;, <span class="type">const</span> Expr &amp;);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream &amp;)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Int_node</span> : <span class="keyword">public</span> Expr_node</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream &amp;o)</span> <span class="type">const</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unary_node</span> : <span class="keyword">public</span> Expr_node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Expr</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream &amp;o)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;</span><br><span class="line">    <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;, <span class="type">const</span> Expr_node &amp;)</span><br><span class="line">&#123;</span><br><span class="line">    t.<span class="built_in">print</span>(o);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款-26：限制某个-class-所能产生的对象数量"><a href="#条款-26：限制某个-class-所能产生的对象数量" class="headerlink" title="条款 26：限制某个 class 所能产生的对象数量"></a>条款 26：限制某个 <code>class</code> 所能产生的对象数量</h2><h3 id="问题1：如何允许建立零个对象"><a href="#问题1：如何允许建立零个对象" class="headerlink" title="问题1：如何允许建立零个对象?"></a><strong>问题1：如何允许建立零个对象?</strong></h3><p>最容易的方法就是<strong>把该类的构造函数声明在类的private域</strong>。代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CantBeInstantiated</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CantBeInstantiated</span>();</span><br><span class="line">    <span class="built_in">CantBeInstantiated</span>(<span class="type">const</span> CantBeInstantiated&amp;);</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="问题2：如何允许建立一个对象？"><a href="#问题2：如何允许建立一个对象？" class="headerlink" title="问题2：如何允许建立一个对象？"></a><strong>问题2：如何允许建立一个对象？</strong></h3><p>将类的构造函数声明为private后，每个用户都没有权力建立对象，但实际应用的需求是我们需要建立一个对象，因此我们需要选择性地放松这个限制。</p><p>对于声明为private的构造函数，我们<strong>可以引入友元函数或成员函数来进行访问，并利用静态成员变量来保证对象的唯一</strong>，具体实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用友元函数来访问私有构造函数</span></span><br><span class="line"><span class="keyword">namespace</span> PrintingStuff</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PrintJob</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Printer</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">submitJob</span><span class="params">(<span class="type">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">rest</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Printer</span>();</span><br><span class="line">        <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Printer p;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> PrintingStuff::thePrinter;</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用静态成员函数来访问私有构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">Printer::thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Printer::<span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line">Printer::<span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure><p><strong>1)唯一的Printer对象是位于函数里的静态成员而不是在类中的静态成员。</strong>在类中的静态对象有两个缺点，一个总是被构造（和释放），即使不使用该对象；另一个缺点是它的初始化时间不确定。</p><p><strong>2)thePrinter()函数没有声明为内联函数</strong>，因为内联意味编译器用函数体代替对函数的每一个调用，这样会导致函数内的静态对象在程序内被复制，可能会使程序的静态对象的拷贝超过一个。</p><h3 id="问题3：如何限制允许建立多个对象？"><a href="#问题3：如何限制允许建立多个对象？" class="headerlink" title="问题3：如何限制允许建立多个对象？"></a><strong>问题3：如何限制允许建立多个对象？</strong></h3><p>我们可以换一种思路，不利用友元函数或成员函数来作为建立对象的中介，而<strong>引入计数器简单地计算对象的数目，一旦需要太多的对象，就抛出异常</strong>。具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;;        <span class="comment">//当需要的对象过多时，抛出的异常类</span></span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> numObjects;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> maxObjects;</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> Printer::maxObjects = <span class="number">10</span>;</span><br><span class="line">Printer::<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(numObjects &gt;= maxObjects)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line">Printer::~<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    --numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此法的核心思想就是使用numObjects跟踪Printer对象存在的数量。当构造对象时，它的值就增加，释放对象时，它的值就减少。如果试图构造过多的对象，就会抛出一个TooManyObjects类型的异常。通过maxObjects设置可允许建立对象的最大数目。</p><p> 　以上两种方法基本上可以满足，限制对象数目的要求。但是具体应用中，仍会出现问题，上述两种方法无法解决。如下面代码所示：</p><p>还是存在问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPrinter</span>:<span class="keyword">public</span> Printer&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Printer p;</span><br><span class="line">ColorPrinter cp;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPFMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer p;</span><br><span class="line">    FaxMachine f;</span><br><span class="line">    CopyMachine c;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">CPFMachine m1;</span><br><span class="line">CPFMachine m2;</span><br></pre></td></tr></table></figure><p>​       利用计数器的方法，上述代码中，都将会产生多个Printer对象，由Printer被作为基类或者被包含于其他类中，导致其他对象的构造时，隐藏构造Printer对象。这主要是计数器方法无法区分对象存在的三种不同环境：<strong>只有它们本身；作为其他派生类的基类；被嵌入在更大的对象中</strong>。</p><p>　　利用thePrinter()函数的方法，把Printer对象的数量限制为一个，这样做的同时也会让我们每一次运行程序时只能使用一个Printer对象。<strong>导致我们不能在程序的不同部分使用不同的Printer对象</strong>。如下面伪代码所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">建立Printer对象p1;</span><br><span class="line">使用p1;</span><br><span class="line">释放p1;</span><br><span class="line">建立Printer对象p2;</span><br><span class="line">使用p2;</span><br><span class="line">释放p2;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="问题4：解决问题3的问题"><a href="#问题4：解决问题3的问题" class="headerlink" title="问题4：解决问题3的问题"></a>问题4：解决问题3的问题</h3><p><strong>思路：将两种方法结合，将构造函数声明为private，限制其被继承和被包含于其他的类，解决计数器的问题，并提供伪构造函数作为访问对象的接口，并统计对象的个数，来解决限制构造多个对象和程序不同部分使用不同对象的问题。</strong>具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//伪构造函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Printer* <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Printer* <span class="title">makePrinter</span><span class="params">(<span class="type">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> numObjects;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> maxObjects;</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Printer::maxObjects = <span class="number">10</span>;</span><br><span class="line">Printer::<span class="built_in">Printer</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(numObjects &gt;= maxObjects)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Printer::<span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(numObjects &gt;= maxObjects)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Printer* Printer:<span class="built_in">makePrinter</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Printer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Printer* <span class="title">Printer::makePrinter</span><span class="params">(<span class="type">const</span> Printer&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Printer</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line">Printer *p1 = Printer::<span class="built_in">makePrinter</span>();</span><br></pre></td></tr></table></figure><p>到目前为止，对于限制对象数目的问题，应该是大功告成。但是仍不能满足工程性上的应用，例如我们有大量像Printer需要限制实例数量的类，就必须一遍又一遍地编写一样的代码，每个类编写一次。作为程序员，应该避免这种重复性的工作。</p><h3 id="一个具有对象计数功能的基类"><a href="#一个具有对象计数功能的基类" class="headerlink" title="一个具有对象计数功能的基类"></a><strong>一个具有对象计数功能的基类</strong></h3><p><strong>针对重复性工作的问题，解决思路是：构造一个具有实例计数功能的基类，让像Printer这样的类从该基类继承，利用派生类对象的构造，需要先构造基类对象的特点，通过隐藏的基类实现计数功能。</strong>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counted</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">objectCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numObjects;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Counted</span>();</span><br><span class="line">    <span class="built_in">Counted</span>(<span class="type">const</span> Counted&amp; rhs);</span><br><span class="line">    ~<span class="built_in">Counted</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        --numObjects;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> numObjects;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> maxObjects;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;BeingCounted&gt;</span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>(<span class="type">const</span> Counted&lt;BeingCounted&gt;&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line"><span class="type">void</span> Counted&lt;BeingCounted&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(numObjects &gt;= maxObjects)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>::<span class="keyword">private</span> Counted&lt;Printer&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Printer* <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Printer* <span class="title">makePrinter</span><span class="params">(<span class="type">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">submitJob</span><span class="params">(<span class="type">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款-27：要求（或禁止）对象产生于-heap-之中"><a href="#条款-27：要求（或禁止）对象产生于-heap-之中" class="headerlink" title="条款 27：要求（或禁止）对象产生于  heap 之中"></a>条款 27：要求（或禁止）对象产生于  heap 之中</h2><p>要求对象产生于heap中，意思是需要阻止clients不得使用new以外的方法产生对象。比较好的方法就是将destructor定义为private，因为constructor的类型太多，所以仍然将constructor定义为public。然后定义一个pseudo destructor来调用真正的destructor。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapBasedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HeapBasedObject</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125; <span class="comment">// pseudo destructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">HeapBasedObject</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//HeapBasedObject h;</span></span><br><span class="line">  HeapBasedObject *ph = <span class="keyword">new</span> HeapBasedObject;</span><br><span class="line">  <span class="comment">//delete ph;</span></span><br><span class="line">  ph-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>禁止对象产生于heap中，则是要让clients不能使用new方法来产生对象。方法就是将operator new和operator delete定义为private。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoHeapBasedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NoHeapBasedObject</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">NoHeapBasedObject</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NoHeapBasedObject nh;</span><br><span class="line">  <span class="type">static</span> NoHeapBasedObject snh;</span><br><span class="line">  <span class="comment">//NoHeapBasedObject *pnh = new NoHeapBasedObject;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例是实现的一个判断某个对象是否位于heap内的基类HeapTracked。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTracked</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MissingAddress</span>&#123;&#125;; <span class="comment">//地址异常</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">HeapTracked</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isOnHeap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> <span class="type">void</span>* RawAddress;</span><br><span class="line">  <span class="type">static</span> std::list&lt;RawAddress&gt; addresses;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::list&lt;HeapTracked::RawAddress&gt; HeapTracked::addresses;</span><br><span class="line"></span><br><span class="line">HeapTracked::~<span class="built_in">HeapTracked</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* HeapTracked::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span>* memPtr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size); <span class="comment">// 取得内存。</span></span><br><span class="line">  addresses.<span class="built_in">push_front</span>(memPtr); <span class="comment">// 将其地址置于list头部。</span></span><br><span class="line">  <span class="keyword">return</span> memPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> HeapTracked::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (it != addresses.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      addresses.<span class="built_in">erase</span>(it);</span><br><span class="line">      ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">MissingAddress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTracked::isOnHeap</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rawAddress = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), rawAddress);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> it != addresses.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span>: <span class="keyword">public</span> HeapTracked &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Object</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Object</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Object o1;</span><br><span class="line">  Object* o2 = <span class="keyword">new</span> Object;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;o1 isOnHeap = &quot;</span> &lt;&lt; o1.<span class="built_in">isOnHeap</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;o2 isOnHeap = &quot;</span> &lt;&lt; o2-&gt;<span class="built_in">isOnHeap</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款-28：Smart-Pointers（智能指针）"><a href="#条款-28：Smart-Pointers（智能指针）" class="headerlink" title="条款 28：Smart Pointers（智能指针）"></a>条款 28：Smart Pointers（智能指针）</h2><p>所谓 smart pointers 是那些看起来、用起来、感觉起来都像内建指针，但提供更多机能的一种对象。smart pointers 由 templates 产生出来，可以利用 templates 参数表明其所指对象的类型。</p><p><strong>Smart Pointers 的构造、赋值、析构</strong></p><p>Smart pointer 的构造通常非常简单：确定一个目标物（通常是利用 smart pointer 的 constructor 自变量），然后让 smart pointer 内部的 dumb pointer 指向它。如果尚未决定目标物，就将内部指针设为 0，或是发出一个错误信息。此外，如果一个 smart pointer 拥有它所指的对象，它就有责任在本身即将被销毁时删除该对象，前提是这个 smart pointer 所指对象系动态分配而得。</p><p>以 by value 方式传递 auto_ptrs 往往是个非常糟的做法，只有当你确定要讲对象拥有权移转给函数的某个参数时，才应该以 by value 方式传递 auto_ptrs.若一定要以 auto_ptrs 作为参数，应采用 pass-by-reference-to-const 方式。当 smart pointer 被复制，或是身为赋值动作的来源端时，它会被改变。</p><p>smart pointer 的 destructor 通常看起来如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">SmartPtr&lt;T&gt;::~<span class="built_in">SmartPtr</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span> owns *pointee) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pointee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现解析操作符</strong></p><p>operator* 返回所指对象，reference;operator-&gt; 返回 dumb pointer（指向某对象），或者一个 smart pointer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">    perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br><span class="line">T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">    perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">    <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试 Smart Pointers 是否为 Null</strong></p><p>smart pointer 不能直接进行测试是否为 Null，需要提供一个隐式类型转换符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"><span class="keyword">if</span>(ptn == <span class="number">0</span>)... <span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span>(ptn)... <span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span>(!ptn)... <span class="comment">//error</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/////////////////////////////修改/////////////////////////////////////    </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">void</span>*();</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"><span class="keyword">if</span>(ptn == <span class="number">0</span>) <span class="comment">//现在正确</span></span><br><span class="line"><span class="keyword">if</span>(ptn) <span class="comment">//现在正确</span></span><br><span class="line"><span class="keyword">if</span>(!ptn) <span class="comment">//现在正确</span></span><br></pre></td></tr></table></figure><p><strong>Smart Pointers 与继承有关的转换</strong></p><p>也需要添加一个隐式类型转换符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicProduct</span>&#123;....&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cassette</span>:<span class="keyword">public</span> MusicProduct&#123;....&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CD</span>:<span class="keyword">public</span> MusicProduct&#123;....&#125;;</span><br><span class="line"><span class="built_in">displayAndPlay</span>(<span class="type">const</span> SmartPtr&lt;MusicProduct&gt;&amp; pmp, <span class="type">int</span> numTimes);</span><br><span class="line"></span><br><span class="line"><span class="function">SmartPtr&lt;Cassette&gt; <span class="title">funMusic</span><span class="params">(<span class="keyword">new</span> Cassette(<span class="string">&quot;1234&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CD&gt; <span class="title">nightmareMusic</span><span class="params">(<span class="keyword">new</span> CD(<span class="string">&quot;143&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">displayAndPlay</span>(funMusic, <span class="number">10</span>); <span class="comment">// 错误!</span></span><br><span class="line"><span class="built_in">displayAndPlay</span>(nightmareMusic, <span class="number">0</span>); <span class="comment">// 错误!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////修改/////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&lt;Cassette&gt;&#123;<span class="comment">//或者用模板来代替</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">SmartPtr</span>&lt;MusicProduct&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SmartPtr</span>&lt;MusicProduct&gt;(pointee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Smart Pointer 和 const</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; p; <span class="comment">//non-const 对象 non-const 指针</span></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> CD&gt; p; <span class="comment">//const 对象 non-const 指针</span></span><br><span class="line"><span class="type">const</span> SmartPtr&lt;CD&gt; p = &amp;goodCD; <span class="comment">//non-const 对象 const 指针</span></span><br><span class="line"><span class="type">const</span> SmartPtr&lt;<span class="type">const</span> CD&gt; p = &amp;goodCD; <span class="comment">//const 对象 const 指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;      <span class="comment">// 指向const对象的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtrToConst</span>&#123; <span class="comment">//灵巧指针</span></span><br><span class="line">    ...                <span class="comment">// 灵巧指针通常的成员函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">const</span> T* constPointee; <span class="comment">// 让 SmartPtrToConst 访问</span></span><br><span class="line">        T* pointee; <span class="comment">// 让 SmartPtr 访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 指向 non-const 对象的灵巧指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>: <span class="keyword">public</span> SmartPtrToConst&lt;T&gt; &#123;</span><br><span class="line">    ... <span class="comment">// 没有数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款-29：Reference-counting（引用计数）"><a href="#条款-29：Reference-counting（引用计数）" class="headerlink" title="条款 29：Reference counting（引用计数）"></a>条款 29：Reference counting（引用计数）</h2><p>引用计数有两个好处：</p><ul><li>简化 heap objects 周边的记录工作：当对象使用了引用计数，它就拥有了自己，一旦不再有任何人使用它，便自动销毁自己。</li><li>允许多个等值对象共享同一实值，避免多次存储。</li><li><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/4.png" alt=""></li></ul><p><strong>引用计数的实现：</strong></p><p>产生一个 class 不仅存储引用计数，也存储它们追踪的对象值。</p><p><strong>技巧：</strong> 将一个 struct 嵌套放进一个 class 的 private 段落内，可以很方便地让该 class 的所有 members 有权处理这个 struct，而又能禁止任何其他人访问这个 struct。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 嵌套的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">InnerStruct</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">innerData</span>(&#123;val&#125;) &#123;&#125;</span><br><span class="line">    <span class="comment">// 成员函数可以访问内部结构体</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        innerData.value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerData.value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部数据结构体</span></span><br><span class="line">    InnerStruct innerData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 无法直接访问内部结构体</span></span><br><span class="line">    <span class="comment">// obj.innerData.value = 10; // 编译错误：&#x27;MyClass::InnerStruct MyClass::innerData&#x27; is private within this context</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能通过公共接口来访问内部数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial value: &quot;</span> &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用成员函数来修改内部数据</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">99</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Updated value: &quot;</span> &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款-30：Proxy-classes（替身类、代理类）"><a href="#条款-30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款 30：Proxy classes（替身类、代理类）"></a>条款 30：Proxy classes（替身类、代理类）</h2><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类模板如下：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Array2D</span>(<span class="type">int</span> dim1,<span class="type">int</span> dim2);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>将<code>operator[]</code>重载，令它返回一个Array1D对象；</li><li>对Array1D重载<code>operator[]</code>，令它返回原来二维数组中的一个元素：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array1D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line"><span class="type">const</span> Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function">Array2D&lt;<span class="type">float</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">cout &lt;&lt; data[<span class="number">3</span>][<span class="number">6</span>];<span class="comment">//ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>data[3]获得一个Array1D对象，对该对象再施行operator[]，获得原二维数组中(3, 6)位置的浮点数；Array2D类的用户不需要知道Array1D类的存在。</p><p><strong>凡“用来代表（象征）其他对象”的对象，常被称为proxy objects（替身对象）；</strong><br>用以表现proxy objects者，我们称为proxy classes。</p><h3 id="区分operator-的读写动作"><a href="#区分operator-的读写动作" class="headerlink" title="区分operator[] 的读写动作"></a>区分<code>operator[]</code> 的读写动作</h3><blockquote><p>对于一个proxy，你只有3件事情可做：</p><p>产生它，本例也就是指定它代表哪一个字符串中的哪一个字符；<br>以它作为赋值动作的目标（接受端），这种情况下你是对它所代表的字符串内的字符做赋值动作。如果这么使用，proxy代表的将是“调用operator[]函数”的那个字符串的左值运用；<br>以其他方式使用之。如果这么使用，proxy表现的是“调用operatorp[]函数”的那个字符串的右值运用。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个reference-counted String class，</span></span><br><span class="line"><span class="comment">//其中利用proxy class来区分operator[]的左值运用和右值运用：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="comment">//reference-counted strings见上一篇细节</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharProxy</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CharProxy</span>(String&amp; str,<span class="type">int</span> index);<span class="comment">//构造</span></span><br><span class="line">CharProxy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CharProxy&amp; rhs);<span class="comment">//左值运用</span></span><br><span class="line">CharProxy&amp; <span class="keyword">operator</span> = (<span class="type">char</span> c);<span class="comment">//右值运用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String&amp; theString;<span class="comment">//这个proxy附属的字符串</span></span><br><span class="line"><span class="type">int</span> charIndex;<span class="comment">//这个proxy所代表的字符串字符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> CharProxy <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>; <span class="comment">//针对const strings</span></span><br><span class="line">CharProxy <span class="keyword">operator</span>[](<span class="type">int</span> index); <span class="comment">//针对non-const strings</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CharProxy</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">String s1,s2;</span><br><span class="line">...</span><br><span class="line">cout &lt;&lt; s1[<span class="number">5</span>];    <span class="comment">//合法（右值运用）</span></span><br><span class="line">s2[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;  <span class="comment">//合法（左值运用）</span></span><br><span class="line">s1[<span class="number">3</span>] = s2[<span class="number">8</span>];    <span class="comment">//合法（左值、右值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String operator[]实现：</span></span><br><span class="line"><span class="type">const</span> String::CharProxy String::<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CharProxy</span>(<span class="built_in">const_cast</span>&lt;String&amp;&gt;(*<span class="keyword">this</span>), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在C++中，当你在一个成员函数中使用 const 修饰符时，这意味着该成员函数承诺不会修改对象的状态。因此，在 const 成员函数内部，*this 指针的类型是 const 类型的，即指向 const 对象的指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String::CharProxy String::<span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CharProxy</span>(*<span class="keyword">this</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个函数都只是产生并返回“被请求之字符”的一个替代品。没有任何动作施加于此字符身上：我们延缓此等行为，直到知道该行为是“读取”或者“写”。</p><p><code>operator[]</code>返回的每一个proxy都会记住它所附属的字符串，以及它所在的索引位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String::CharProxy::<span class="built_in">CharProxy</span>(String&amp; str,<span class="type">int</span> index)</span><br><span class="line">:<span class="built_in">theString</span>(str),<span class="built_in">charIndex</span>(index)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将proxy转换为右值：只需要返回该proxy所表现的字符串副本就行：</span></span><br><span class="line"> </span><br><span class="line">String::<span class="function">CharProxy::<span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> theString.value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CharProxy的赋值操作符：</span></span><br><span class="line">String::CharProxy&amp;</span><br><span class="line">String::CharProxy::<span class="keyword">operator</span> = (<span class="type">const</span> CharProxy&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果本字符串与其他String对象共享一个实值</span></span><br><span class="line"><span class="comment">//将实值复制一份，供本字符串单独使用</span></span><br><span class="line"><span class="keyword">if</span>(theString.value-&gt;<span class="built_in">isShared</span>())&#123;</span><br><span class="line">theString.value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(theString.value-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在进行赋值动作：将rhs所代表的字符值</span></span><br><span class="line"><span class="comment">//赋予*this所代表的字符</span></span><br><span class="line">theString.value-&gt;datap[charIndex] = </span><br><span class="line">rhs.theString.value-&gt;data[rhs.charIndex];</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个CharProxy赋值操作符和上述传统版本几乎雷同：</span></span><br><span class="line">CharProxy&amp; String::CharProxy::<span class="keyword">operator</span> = (<span class="type">char</span> c)&#123;</span><br><span class="line"><span class="keyword">if</span>(theString.value-&gt;<span class="built_in">isShared</span>())</span><br><span class="line">theString.value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(theString.value-&gt;data);</span><br><span class="line"></span><br><span class="line">theString.value-&gt;data[charIndex] = c;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上述两个赋值操作符的重复代码抽出来放进一个私有的CharProxy成员函数</span></span><br><span class="line"><span class="comment">//然后让两个操作符都去调用它</span></span><br></pre></td></tr></table></figure><h3 id="限制隐式类型转换"><a href="#限制隐式类型转换" class="headerlink" title="限制隐式类型转换"></a>限制隐式类型转换</h3><p>难点：“对proxy取址”所获取的指针类型和“对真实对象取址”获取的指针类型不同。</p><p>解决：需要在CharProxy类内将取址操作符加以重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharProxy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="type">char</span>* <span class="keyword">operator</span>&amp;();</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">operator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* String::CharProxy::<span class="built_in">operator</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span>* String::CharProxy::<span class="keyword">operator</span>&amp;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//确定“标的字符”所属的字符串实值不为任何其他任何String对象共享</span></span><br><span class="line"><span class="keyword">if</span>(theString.value-&gt;<span class="built_in">isShared</span>())&#123;</span><br><span class="line">theString.value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(theString.value-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们不知道clients会将本函数返回的指针保留多久，所以“目标字符”所属的字符串实值绝不可以被共享</span></span><br><span class="line">theString.value-&gt;<span class="built_in">markUnshanreable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条款-31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款-31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款 31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款 31：让函数根据一个以上的对象类型来决定如何虚化</h2><p>里指出了一个情况，例如我们有三种物体，且都继承<code>GameObject</code></p><ul><li><code>SpaceShip</code> 飞船</li><li><code>SpaceStation</code> 空间站</li><li><code>Asteroid</code> 陨石</li></ul><p>不同的物体会相撞，且会产生不同的结果。例如飞船和空间站相撞，飞船能进入到空间站内；飞船和陨石相撞，两者都会摧毁。<br>这个时候，我们需要一个方法，传入任意俩个<code>GameObject</code>都可以处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processCollision</span><span class="params">(GameObject&amp; object1, GameObject&amp; object2)</span></span></span><br></pre></td></tr></table></figure><p>书中讨论了一套方法，是一个不错的方法，但是感觉还不是很完美。目前就整理一下代码，记录下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">GameObject</span>() &#123;&#125; <span class="comment">//基类里面有虚函数，派生类继承后，使用typeid().name才能取得对应的class name</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShip</span> : <span class="keyword">public</span> GameObject &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceStation</span> : <span class="keyword">public</span> GameObject &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asteroid</span> : <span class="keyword">public</span> GameObject &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名namespace</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> std::string;</span><br><span class="line">    <span class="keyword">using</span> std::map;</span><br><span class="line">    <span class="keyword">using</span> std::make_pair;</span><br><span class="line">    <span class="keyword">using</span> std::pair;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject&amp; spaceShip, GameObject&amp; asteroid)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;spaceShip collide with asteroid&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shipStation</span><span class="params">(GameObject&amp; spaceShip, GameObject&amp; spaceStation)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;spaceShip collide with spaceStation&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asteroidStation</span><span class="params">(GameObject&amp; asteroid, GameObject&amp; spaceStation)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;asteroid collide with spaceStation&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asteroidShip</span><span class="params">(GameObject&amp; asteroid, GameObject&amp; spaceShip)</span> </span>&#123; <span class="built_in">shipAsteroid</span>(spaceShip, asteroid); &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stationShip</span><span class="params">(GameObject&amp; spaceStation, GameObject&amp; spaceShip)</span> </span>&#123; <span class="built_in">shipStation</span>(spaceShip, spaceStation); &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stationAsteroid</span><span class="params">(GameObject&amp; spaceStation, GameObject&amp; asteroid)</span> </span>&#123; <span class="built_in">asteroidStation</span>(asteroid, spaceStation); &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞map</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollisionMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这里使用单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> CollisionMap* <span class="title">theCollisionMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> CollisionMap CM;</span><br><span class="line">        <span class="keyword">return</span> &amp;CM;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里添加新的碰撞处理函数，成对处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEntry</span><span class="params">(<span class="type">const</span> string&amp; type1, <span class="type">const</span> string&amp; type2, HitFunctionPtr collisionFunction)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (collisionMap.<span class="built_in">find</span>(std::<span class="built_in">make_pair</span>(type1, type2)) != collisionMap.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//成对添加</span></span><br><span class="line">        collisionMap[std::<span class="built_in">make_pair</span>(type1, type2)] = collisionFunction;</span><br><span class="line">        collisionMap[std::<span class="built_in">make_pair</span>(type2, type1)] = collisionFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里移除碰撞函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEntry</span><span class="params">(<span class="type">const</span> string&amp; type1, <span class="type">const</span> string&amp; type2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (collisionMap.<span class="built_in">find</span>(std::<span class="built_in">make_pair</span>(type1, type2)) != collisionMap.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//成对移除</span></span><br><span class="line">        collisionMap.<span class="built_in">erase</span>(std::<span class="built_in">make_pair</span>(type1, type2));</span><br><span class="line">        collisionMap.<span class="built_in">erase</span>(std::<span class="built_in">make_pair</span>(type2, type1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找有没有对应的碰撞函数</span></span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="type">const</span> string&amp; class1, <span class="type">const</span> string&amp; class2)</span> </span>&#123;</span><br><span class="line">        HitMap::iterator it = collisionMap.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(class1, class2));</span><br><span class="line">        <span class="keyword">if</span> (it == collisionMap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (*it).second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;pair&lt;string, string&gt;, HitFunctionPtr&gt; HitMap;</span><br><span class="line">    HitMap collisionMap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CollisionMap</span>() &#123; <span class="built_in">initializeCollisionMap</span>(); &#125;;</span><br><span class="line">    <span class="built_in">CollisionMap</span>(<span class="type">const</span> CollisionMap&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以内部初始化，也可以改为一个函数，来注册一下函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initializeCollisionMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        collisionMap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">addEntry</span>(<span class="string">&quot;class SpaceShip&quot;</span>, <span class="string">&quot;class Asteroid&quot;</span>, &amp;shipAsteroid);</span><br><span class="line">        <span class="built_in">addEntry</span>(<span class="string">&quot;class SpaceShip&quot;</span>, <span class="string">&quot;class SpaceStation&quot;</span>, &amp;shipStation);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名namespace</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里处理碰撞，会查找碰撞map，如果有函数就执行，没有的话就抛出异常</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processCollision</span><span class="params">(GameObject&amp; object1, GameObject&amp; object2)</span> </span>&#123;  </span><br><span class="line">        CollisionMap* CM = CollisionMap::<span class="built_in">theCollisionMap</span>();</span><br><span class="line"> </span><br><span class="line">        CollisionMap::HitFunctionPtr phf = CM-&gt;<span class="built_in">lookup</span>(<span class="built_in">typeid</span>(object1).<span class="built_in">name</span>(), <span class="built_in">typeid</span>(object2).<span class="built_in">name</span>());</span><br><span class="line">        <span class="keyword">if</span> (phf) <span class="built_in">phf</span>(object1, object2);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;UnkowCollision! &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(object1).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(object2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpaceShip spaceShip;</span><br><span class="line">    Asteroid asteroid;</span><br><span class="line">    SpaceStation spaceStation;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processCollision</span>(spaceShip, asteroid);  <span class="comment">//spaceShip collide with asteroid</span></span><br><span class="line">    <span class="built_in">processCollision</span>(asteroid, spaceShip);  <span class="comment">//UnkowCollision! class Asteroid - class SpaceShip</span></span><br><span class="line">    <span class="built_in">processCollision</span>(spaceShip, spaceStation); <span class="comment">//spaceShip collide with spaceStation</span></span><br><span class="line">    <span class="built_in">processCollision</span>(asteroid, spaceStation); <span class="comment">//UnkowCollision! class Asteroid - class SpaceStation</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Miscellany-杂项讨论"><a href="#Miscellany-杂项讨论" class="headerlink" title="Miscellany 杂项讨论"></a>Miscellany 杂项讨论</h1><h2 id="条款-32：在未来时态下发展程序"><a href="#条款-32：在未来时态下发展程序" class="headerlink" title="条款 32：在未来时态下发展程序"></a>条款 32：在未来时态下发展程序</h2><p>未来式思维只不过是加上一些额外的考虑：</p><ol><li><p>提供完整的classes——即使某些部分目前用不到。当新的需求进来，你不太需要去回头修改那些classes；<br>比如：【C++ Efficiency】over-eager evaluation的两种做法：caching和prefetching</p></li><li><p>设计你的接口，使有利共同的操作行为，阻止共同的错误。让这些classes轻易地被正确运用，难以被错误运用；</p></li><li><p>尽量使你的代码一般化（泛化），除非有不良的巨大后果。</p></li></ol><h2 id="条款-33：将非尾端类（non～leaf-classes）设计为抽象类（abstract-classes）"><a href="#条款-33：将非尾端类（non～leaf-classes）设计为抽象类（abstract-classes）" class="headerlink" title="条款 33：将非尾端类（non～leaf classes）设计为抽象类（abstract classes）"></a>条款 33：将非尾端类（non～leaf classes）设计为抽象类（abstract classes）</h2><p>假设我们有一种这样的继承结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=( Animal&amp; rhs)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lizard</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=( Lizard&amp; rhs)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chicken</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=( Chicken&amp; rhs)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Lizard liz1;</span><br><span class="line">Lizard liz2;</span><br><span class="line">Chicken chick;</span><br><span class="line"></span><br><span class="line">Animal *pAnimal1 = &amp;liz1;</span><br><span class="line">Animal *pAnimal2 = &amp;liz2;</span><br><span class="line">Animal *pAnimal3 = &amp;chick;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*pAnimal1 = *pAnimal2;      //将一只蜥蜴赋值给另一只蜥蜴，需要合法，需要允许</span></span><br><span class="line">*pAnimal1 = *pAnimal3;      <span class="comment">//将一只鸡赋值给一只蜥蜴，emmm 不合法，需要禁止</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到继承关系，<code>Lizard</code> 类型的对象可以被视为 <code>Animal</code> 类型的对象，因为 <code>Lizard</code> 是 <code>Animal</code> 的派生类。因此，<code>*pAnimal1 = *pAnimal2;</code> 这种情况下是合法的，因为它将一个 <code>Lizard</code> 类型的对象赋值给了另一个 <code>Lizard</code> 类型的对象。</p><p><code>*pAnimal1 = *pAnimal3;</code> 这种情况下是不合法的。尽管 <code>pAnimal1</code> 和 <code>pAnimal3</code> 都是 <code>Animal</code> 类型的指针，但是它们指向的对象类型不同，一个是 <code>Lizard</code>，一个是 <code>Chicken</code>。在赋值操作中，编译器会尝试调用适当的赋值运算符重载函数，<strong>但是 <code>Animal</code> 类型的赋值运算符函数只能保证处理 <code>Animal</code> 类型的对象，而不能处理 <code>Lizard</code> 或 <code>Chicken</code> 类型的对象。因此，尝试将 <code>Chicken</code> 类型的对象赋值给 <code>Lizard</code> 类型的对象是不合法的，这是由于类型不匹配造成的。</strong></p><p>上边代码存在的两个问题：</p><ul><li>部分赋值：最后一句调用 Animal class 的赋值操作符只会修改 liz 的 Animal 成分</li><li>class 容易被误用，如果将 <code>Animal::operator=</code> 则会让上边的代码成为合法代码，这会带来异型赋值问题</li></ul><p>通过设计抽象类，可以实现通过指针进行的同型赋值而又可以禁止通过同样那些指针而进行的异型赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractAnimal</span>&#123;<span class="comment">//抽象类--必须内含至少一个纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractAnimal&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AbstractAnimal&amp; rhs);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractAnimal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>: <span class="keyword">public</span> AbstractAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lizard</span>:<span class="keyword">public</span> AbstractAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chicken</span>:<span class="keyword">public</span> AbstractAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Chicken&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果没有任何 member functions 可以很自然地被你声明为纯虚函数，传统做法是让 destructor 成为纯虚函数。</p><p>纯虚析构函数必须被实现出来，因为只要有一个 derived class destructor 被调用，它们便会被调用。此外，它们通常执行一些有用的工作，如释放资源或记录运转消息等等。</p><h2 id="条款-34：如何在同一个程序中结合-C-和-C"><a href="#条款-34：如何在同一个程序中结合-C-和-C" class="headerlink" title="条款 34：如何在同一个程序中结合 C++和 C"></a>条款 34：如何在同一个程序中结合 C++和 C</h2><ol><li>name mangling（名称重整）、statics（静态对象）初始化、动态内存分配、数据结构的兼容性。</li><li>如果你打算在同一个程序中混用 C++和 C，请记住以下几个简单守则：<ul><li>确定你的 C++和 C 编译器产出兼容的目标文件（object files）。</li><li>将双方都使用的函数声明为<code>extern ＂C＂</code>。</li><li>如果可能，尽量在 C++中撰写<code>main</code>。</li><li>总是以 delete删除 new返回的内存；总是以 <code>free</code>释放 <code>malloc</code> 返回的内存。</li><li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式；C++ structs 如果内含非虚函数，倒是不受此限。</li></ul></li></ol><h2 id="条款-35：让自己习惯于标准-C-语言"><a href="#条款-35：让自己习惯于标准-C-语言" class="headerlink" title="条款 35：让自己习惯于标准 C++语言"></a>条款 35：让自己习惯于标准 C++语言</h2><p>主要是了解不断发展的 C++ 标准的特性：RTTI、Templates、异常处理、STL等。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/lujiandong1/article/details/41799959">条款19 了解临时对象的来源</a></li><li><a href="https://blog.csdn.net/weixin_28712713/article/details/80995472">5 对定制的“类型转换函数”保存警觉</a></li><li><a href="https://blog.csdn.net/weixin_30457551/article/details/99191112">限制某个类所能产生的对象数量</a></li><li><a href="https://segmentfault.com/a/1190000040890556">要求（或禁止）对象产生于heap之中</a></li><li><a href="https://blog.csdn.net/weixin_49347928/article/details/133706022">利用Proxy classes（代理类）实现：多维数组、区分左/右值运用、限制隐式类型转换</a></li><li><a href="https://www.xhxha.one/post/moreeffectivec++_5/#%E6%9D%A1%E6%AC%BE-25%E5%B0%86-constructor-%E5%92%8C-non-member-functions-%E8%99%9A%E5%8C%96">More Effective C++ | 第 5 章 技术</a></li><li><a href="https://zhuanlan.zhihu.com/p/575971939">【《More Effective C++ (35个改善编程与设计的有效方法)》 读书笔记】条款31：让函数根据一个以上的对象类型来决定如何虚化</a></li></ul>]]></content>
    
    
    <summary type="html">《More Effective Cpp》</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/categories/Cpp/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effectivate Modern Cpp</title>
    <link href="https://penge666.github.io/posts/ccc0d0ac.html"/>
    <id>https://penge666.github.io/posts/ccc0d0ac.html</id>
    <published>2024-04-11T04:42:43.000Z</published>
    <updated>2024-04-11T06:44:16.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转载：<a href="https://joytsing.cn/posts/46568/">https://joytsing.cn/posts/46568/</a> </p><p>结合自己的学习内容进行补充</p><h2 id="第一章：类型推导"><a href="#第一章：类型推导" class="headerlink" title="第一章：类型推导"></a>第一章：类型推导</h2><h3 id="条款-1：理解模板类型推导"><a href="#条款-1：理解模板类型推导" class="headerlink" title="条款 1：理解模板类型推导"></a>条款 1：理解模板类型推导</h3><hr><p>重点：</p><blockquote><p><strong>模板类型推导</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure><p>在编译的时候，编译器通过 expr 来进行推导出两个类型：</p><ul><li>T </li><li>ParamType</li></ul><p>形式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr); <span class="comment">// 用一些表达式来调用f</span></span><br></pre></td></tr></table></figure><p><strong>对于 T 的类型推导不仅取决于 <code>expr</code> 的类型，还取决于 <code>ParamType</code> 的形式</strong>。</p><p>有三种情况：</p><ul><li><code>ParamType</code> 是指针或引用，但不是通用引用（通用引用在条款24中介绍）。 </li><li><code>ParamType</code> 是通用引用。</li><li><code>ParamType</code> 既不是指针也不是引用。<ul><li>按pass-by-value处理：<ul><li>如果 expr 的类型是个引用，将会忽略引用的部分。</li><li>如果expr 是 const 的，也要忽略掉 const 。如果是 volatile的，也要忽略掉。</li></ul></li></ul></li></ul><blockquote><p> <strong>数组参数</strong> </p></blockquote><p><strong>虽然通常情况下，一个数组会被退化成一个指向其第一个元素的指针，数组类型和指针类型是不一样的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// name的类型是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * ptrToName = name; <span class="comment">// 数组被退化成指针</span></span><br></pre></td></tr></table></figure><p>case1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(<span class="type">int</span> param[])</span>;   </span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(<span class="type">int</span>* param)</span>;    <span class="comment">// 和上面的函数是一样的</span></span><br><span class="line">f(name); <span class="comment">// name是个数组，但是T被推导成const char*</span></span><br></pre></td></tr></table></figure><p>case2:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// 引用参数的模板</span></span><br><span class="line"><span class="built_in">f</span>(name); <span class="comment">// 传递数组给f</span></span><br></pre></td></tr></table></figure><p><strong>T 被推导成了 const char [13] ，函数 f 的参数（数组的引用）被推导成了 const char(&amp;)[13]</strong> </p><blockquote><p><strong>函数参数</strong></p></blockquote><p>函数类型可以被退化成函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>， <span class="type">double</span>)</span></span>; <span class="comment">// someFunc是一个函数，类型是void(int, double)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>; <span class="comment">// 在f1中 参数直接按值传递</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// 在f2中 参数是按照传递</span></span><br><span class="line"><span class="built_in">f1</span>(someFunc); <span class="comment">// param被推导成函数指针，类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc); <span class="comment">// param被推导成函数引用，类型是void(&amp;)(int, double)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要点</p><ul><li><p>在模板类型推导期间，引用实参被视为非引用，即忽略其引用性质。</p></li><li><p>在推导通用引用形参的类型时，左值实参会得到特殊处理。 </p></li><li>在推导按值传递的形参类型时，const 和/或 volatile 参数被视为非 const 和非volatile的。 </li><li>在模板类型推导期间，数组或函数实参会退化为相应的指针，除非它们用于初始化引用。</li></ul><hr><p>函数模板大致形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure><p>在编译期，编译器会通过表达式推导出两个类型：一个是<code>T</code>的类型，另一个是<code>ParamType</code>的类型，这两个类型往往不一样，<code>ParamType</code>常包含一些饰词，如<code>const</code>或引用符号等限定词。</p><p><strong>情况 1：ParamType 是个指针或引用，但不是个万能引用</strong></p><ol><li>若表达式具有引用类型，则先将引用部分忽略。</li><li>对表达式的类型和<code>ParamType</code>进行匹配来决定<code>T</code>的类型。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 的类型为 int, paramType 为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 的类型为 const int, paramType 为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 的类型为 const int, paramType 为 const int&amp;</span></span><br></pre></td></tr></table></figure><p>若我们假定<code>param</code>具有常引用类型，则<code>T</code>的类型推导结果中也就没必要包含<code>const</code>了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 的类型为 int, paramType 为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 的类型为 int, paramType 为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 的类型为 int, paramType 为 const int&amp;</span></span><br></pre></td></tr></table></figure><p>如果<code>param</code>是个指针（或指向 const 对象的指针）而非引用，运作方式本质上并无不同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);   <span class="comment">// T 的类型为 int, paramType 为 int*</span></span><br><span class="line"><span class="built_in">f</span>(px);   <span class="comment">// T 的类型为 const int, paramType 为 const int*</span></span><br></pre></td></tr></table></figure><p><strong>情况 2：ParamType 是个万能引用</strong></p><blockquote><p>详细说明请参考<strong>条款 24</strong>。</p></blockquote><ol><li>如果表达式是个左值，则<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</li><li>如果表达式是个右值，则遵循情况 1 中的规则。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值的情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 的类型为 int&amp;, paramType 为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值的情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>)    <span class="comment">// T 的类型为 int, paramType 为 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p><strong>情况 3：ParamType 既非指针也非引用</strong></p><p>这种情况即为按值传递，无论传入的是什么，<code>param</code>都会是它的一个副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);    <span class="comment">// T 和 param 的类型均为 int</span></span><br><span class="line"><span class="built_in">f</span>(cx);   <span class="comment">// T 和 param 的类型均为 int</span></span><br><span class="line"><span class="built_in">f</span>(rx);   <span class="comment">// T 和 param 的类型均为 int</span></span><br></pre></td></tr></table></figure><p>需要注意的是对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr = <span class="string">&quot;Fun with pointers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(ptr);    <span class="comment">// T 和 param 的类型均为 const char*</span></span><br></pre></td></tr></table></figure><p><strong>数组实参：</strong></p><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);   <span class="comment">// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]</span></span><br></pre></td></tr></table></figure><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数实参：</strong></p><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);   <span class="comment">// param 被推导为函数指针，具体类型为 void (*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);   <span class="comment">// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure><h3 id="条款-2：理解-auto-类型推导"><a href="#条款-2：理解-auto-类型推导" class="headerlink" title="条款 2：理解 auto 类型推导"></a>条款 2：理解 auto 类型推导</h3><hr><p>重点：</p><p>auto类型推导几乎模板类型推导【因此，也分为3种情况】，除了特例。</p><p>case：对待花括号初始化的行为，是 auto 唯一和模板类型推导不一样的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;; <span class="comment">// x的类型是 std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 和x的声明等价的模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); <span class="comment">// 错误！没办法推导T的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); <span class="comment">// T被推导成int，initList的类型是std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>auto 和模板类型推导的<strong>本质区别</strong>就是 auto 假设花括号初始化代表的是std::initializer_list，但模板类型推导不是</p><p><strong>要点</strong></p><ul><li>auto类型推导通常与模板类型推导相同，但auto类型推导假定带花括号的初始化列表的类型表示为 std::initializer_list，而模板类型推导则不会这样假设。</li><li><strong>在函数返回类型或 lambda 参数中使用 auto 意味着模板类型推导，而不是auto类型推导。</strong></li></ul><hr><p><code>auto</code>类型推导除了在一个例外情况下，和模板类型推导的规则一模一样，同样可以分为三种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;        <span class="comment">// 类型为 int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;  <span class="comment">// 类型为 const int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x; <span class="comment">// 类型为 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;   <span class="comment">// 类型为 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx;  <span class="comment">// 类型为 const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;  <span class="comment">// 类型为 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>数组和函数实参的非引用退化规则也同样适用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// 类型为 const char[13]</span></span><br><span class="line"><span class="keyword">auto</span> arr1 = name;                   <span class="comment">// 类型为 const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name;                  <span class="comment">// 类型为 const char (&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">// 类型为 void(int, double)</span></span><br><span class="line"><span class="keyword">auto</span> func1= someFunc;               <span class="comment">// 类型为 void (*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2= someFunc;              <span class="comment">// 类型为 void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure><p>下面我们将讨论例外情况：<code>auto</code>会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>，但模板类型推导不会。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;   <span class="comment">// 类型为 std::initializer_list&lt;int&gt;，值为 &#123; 27 &#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;      <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;    <span class="comment">// 错误，类型不一致</span></span><br><span class="line">                            <span class="comment">// 无法推导出 std::initializer_list&lt;T&gt; 中的 T</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="built_in">f1</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);   <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(std::initializer_list&lt;T&gt; param)</span></span>;</span><br><span class="line"><span class="built_in">f2</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);   <span class="comment">// 正确，ParamType 为 std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要特别注意的是，2014 年 C++ 标准委员会通过了 <a href="https://link.zhihu.com/?target=https%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html">N3922 提案</a>，修改了<code>auto</code>对于大括号初始化的类型推断规则。上面所提及的<code>auto x4&#123; 27 &#125;</code>这行代码中，<code>x4</code>推导出的的类型已经不再是<code>std::initializer_list&lt;int&gt;</code>，而是<code>int</code>。</p></blockquote><p>在 C++14 中，允许使用<code>auto</code>来说明函数返回值需要推导，而且 lambda 表达式也会在形参声明中用到<code>auto</code>。然而这些<code>auto</code>用法使用的是模板类型推导而非<code>auto</code>类型推导，因此也不能使用大括号括起的初始化表达式。</p><h3 id="条款-3：理解-decltype"><a href="#条款-3：理解-decltype" class="headerlink" title="条款 3：理解 decltype"></a>条款 3：理解 decltype</h3><hr><p>重点：鹦鹉学舌</p><p><strong>要点</strong></p><ul><li>decltype 几乎总是返回变量或表达式的类型，而不会进行任何修改。</li><li><strong>对于类型为 T 的左值表达式（不是名称），decltype 总是报告 T&amp;类型。</strong></li><li>C++14 支持decltype(auto)，它像 auto 一样从初始化表达式中推断类型，但使用的是 decltype 规则</li></ul><hr><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的类型而不作任何修改。对于类型为<code>T</code>的左值表达式，除非该表达式仅有一个名字，否则<code>decltype</code>总是得出类型<code>T&amp;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x);    <span class="comment">// 推导结果为 int</span></span><br><span class="line"><span class="keyword">decltype</span>((x));  <span class="comment">// 推导结果为 int&amp;</span></span><br></pre></td></tr></table></figure><p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到<strong>返回值类型尾置语法（trailing return type syntax）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(c[i])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。</p><p>但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;            <span class="comment">// auto 推导出类型为 Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;  <span class="comment">// decltype 推导出类型为 const Widget&amp;</span></span><br></pre></td></tr></table></figure><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考<strong>条款 25</strong>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-4：掌握查看类型推导结果的方法"><a href="#条款-4：掌握查看类型推导结果的方法" class="headerlink" title="条款 4：掌握查看类型推导结果的方法"></a>条款 4：掌握查看类型推导结果的方法</h3><p><strong>1. IDE 编辑器</strong></p><p><strong>2. 编译器诊断信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 只声明 TD 而不定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;               <span class="comment">// TD 是 “类型显示类”（Type Displayer）的缩写</span></span><br><span class="line"></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;  <span class="comment">// 诱发包括 x 和 y 的类型的错误信息</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(y)&gt; yType;</span><br></pre></td></tr></table></figure><p><strong>3. 运行时输出</strong></p><p>针对某个对象调用<code>typeid</code>，可以得到一个<code>std::type_info</code>对象，其拥有一个成员函数<code>name</code>，该函数产生一个代表类型的 C-style 的字符串。</p><p>但遗憾的是，不同编译器对于<code>std::type_info::name</code>的实现各不相同，无法保证完全可靠。并且按照标准，<code>std::type_info::name</code>中处理类型的方式和向函数模板按值传参一样，因此类型的引用性以及<code>const</code>和<code>volatile</code>限定符也将被忽略。</p><p>原书中介绍了 Boost.TypeIndex 第三方库用于代替<code>typeid</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示 T 的类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T =          &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示 param 的类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param =          &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二章：auto"><a href="#第二章：auto" class="headerlink" title="第二章：auto"></a>第二章：auto</h2><h3 id="条款-5：优先选用-auto，而非显式类型声明"><a href="#条款-5：优先选用-auto，而非显式类型声明" class="headerlink" title="条款 5：优先选用 auto，而非显式类型声明"></a>条款 5：优先选用 auto，而非显式类型声明</h3><hr><p>速记：</p><p>auto好处：</p><ul><li>auto必须初始化</li><li>简化代码</li><li>std::function 方法通常体积比 auto 大，并且慢，还有可能导致内存不足的异常</li><li>在32位 Windows 系统上， unsigned 和 size_type 有同样的大小，但是在64位的 Windows 上， unsigned 是32bit的，而 size_type 是64bit的。</li><li>避免error</li></ul><p>问题代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="type">int</span>&gt;&amp; p : m)&#123;</span><br><span class="line">    ... <span class="comment">// 使用p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器的元素类型应该是：std::pair<const std::sting, int></p><p>正确写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m)&#123;</span><br><span class="line">    ... <span class="comment">// 和以前一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>auto</code>变量要求必须初始化，基本上可以避免会导致兼容性和效率问题的类型不匹配现象，还可以简化重构流程，通常也比显式指定类型要少打一些字，但在使用时需要注意<strong>条款 2</strong> 和<strong>条款 6</strong> 中提到的问题。</p><p>使用<code>auto</code>和<code>std::function</code>都可以存储闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14 允许在 lambda 表达式的形参中使用 auto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> derefLess = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1, <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)</span><br><span class="line">                  &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;,</span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt;</span><br><span class="line">    derefUPLess = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1,</span><br><span class="line">                     <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)</span><br><span class="line">                   &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure><p>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同；而使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。再有，编译器的细节一般都会限制内联，并会产生间接函数调用。</p><p>综上所述，<code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。</p><p>考虑以下代码的隐患：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : m) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::unordered_map</code>的键值部分是 const 的，所以哈希表中的<code>std::pair</code>类型应为<code>std::pair&lt;const std::string, int&gt;</code>而非<code>std::pair&lt;std::string, int&gt;</code>，类型的不匹配会导致额外的临时对象被复制出来，降低了运行效率。</p><p>使用<code>auto</code>就可以轻松避免这种问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法"><a href="#条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法" class="headerlink" title="条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法"></a>条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法</h3><hr><p>auto坏处：</p><p>当auto推导的类型不符合要求时，使用显式类型初始化语法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; <span class="title function_">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span>;</span><br><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="type">bool</span> highPriority = features(w)[<span class="number">5</span>]; <span class="comment">// 假设容器的第5位（bit）表示 Widget 是否具有高优先级</span></span><br><span class="line">processWidget(w, highPriority); <span class="comment">// 能正常工作，根据优先级进行处理</span></span><br><span class="line"><span class="keyword">auto</span> highPriority = features(w)[<span class="number">5</span>];<span class="comment">// 返回类型为 std::vector&lt;bool&gt;::referenceprocessWidget(w, highPriority); // 未定义的行为!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>std::vector::operator[] 通常返回元素的引用，bool元素类型除外</strong></p><ul><li>std::vector&lt; bool&gt; 被指定每个 bool 值占一个位</li><li>std::vector&lt; T&gt; 的 operator[] 应该返回一个 T&amp;，但 C++ 禁止对位的引用</li><li>std::vector&lt; bool&gt;::reference用于使其用起来像是bool&amp;，可以进行赋值、比较、条件等</li><li>为了让上述的设计能够正常工作，std::vector<bool>::reference 进行了一种隐式的转换，将其转换为 bool 类型</li><li>std::vector&lt; bool&gt;::reference 的一种可能实现方式是：包含一个指针（指向一个包含结果值的一个数据结构），和偏移量（结果值在数据结构中的位置）</li></ul><p>总结：auto推导没错，只需要显示声明or类型转化</p><hr><p>“隐形” 的代理类型可以导致<code>auto</code>根据初始化表达式推导出 “错误的” 类型，应该防止写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> someVar = <span class="string">&quot; 隐形 &quot;</span> 代理类型表达式;</span><br></pre></td></tr></table></figure><p>一个隐形代理类的典型例子是<code>std::vector&lt;bool&gt;</code>，它经过了特化，与一般的<code>std::vector</code>的行为不同，和<code>std::bitset</code>的行为相似，使用一种压缩形式表示其持有的<code>bool</code>元素，每个<code>bool</code>元素用一个比特来表示。因此，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>并不会直接返回一个<code>bool&amp;</code>，而是会返回一个具有类似行为的<code>std::vector&lt;bool&gt;::reference</code>类型的对象，并可以隐式转换为<code>bool</code>类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> highPriority1 = <span class="built_in">features</span>(w)[<span class="number">5</span>];    <span class="comment">// 得到正确的 bool 变量</span></span><br><span class="line"><span class="keyword">auto</span> highPriority2 = <span class="built_in">features</span>(w)[<span class="number">5</span>];    <span class="comment">// 错误地得到了 std::vector&lt;bool&gt;::reference 对象</span></span><br></pre></td></tr></table></figure><p>除了<code>std::vector&lt;bool&gt;</code>以外，标准库中的智能指针和另外一些 C++ 库中的类也使用了代理类的设计模式，例如为了提高数值计算代码效率的<strong>表达式模板</strong>技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix sum = m1 + m2 + m3 + m4; <span class="comment">// 通过使 operator+ 返回结果的代理来提高效率</span></span><br></pre></td></tr></table></figure><blockquote><p>在实际编写代码时，记得通过查看文档或头文件中的函数原型来确认手头上的类是否为代理类。</p></blockquote><p>解决代理类问题的做法是：使用带显式类型的初始值设定项来强制<code>auto</code>推导出你想要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>这种用法并不仅限于会产生代理类型的初始值设定项，它同样可以应用于你想要强调创建一个类型不同于初始化表达式类型的场合，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">calcEpsilon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ep1 = <span class="built_in">calcEpsilon</span>();                      <span class="comment">// 进行从 double 到 float 的隐式类型转换</span></span><br><span class="line"><span class="keyword">auto</span> ep2 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">calcEpsilon</span>());   <span class="comment">// 强调了类型转换的存在</span></span><br></pre></td></tr></table></figure><h2 id="第三章：转向现代-C"><a href="#第三章：转向现代-C" class="headerlink" title="第三章：转向现代 C++"></a>第三章：转向现代 C++</h2><h3 id="条款-7：在创建对象时注意区分-和"><a href="#条款-7：在创建对象时注意区分-和" class="headerlink" title="条款 7：在创建对象时注意区分 () 和 {}"></a>条款 7：在创建对象时注意区分 () 和 {}</h3><hr><p>重点：：</p><p>内置类型</p><p>可以使用（）、= 或 { } 来指定初始化值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">x</span><span class="params">(<span class="number">0</span>)</span>; </span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> z&#123; <span class="number">0</span> &#125;; </span><br><span class="line"><span class="type">int</span> z = &#123; <span class="number">0</span> &#125;; <span class="comment">// 等价于 int z&#123; 0 &#125;; </span></span><br></pre></td></tr></table></figure><p>用户定义类型</p><ul><li>对非静态数据成员进行初始化<ul><li>可以使用{ }, = 对非静态数据成员进行初始化，但( ) 不行</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    private:</span><br><span class="line">    <span class="type">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// 正确, x的默认值为0</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">// 同样正确</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">z</span><span class="params">(<span class="number">0</span>)</span>; <span class="comment">// 错误!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>不可复制的对象（例如，std::atomics）</p><ul><li>不可复制的对象（例如，std::atomics）可以使用{ }或（）进行初始化，但不能使用 = </li></ul></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; ai1&#123; <span class="number">0</span> &#125;; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">ai2</span><span class="params">(<span class="number">0</span>)</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">// 错误!</span></span><br></pre></td></tr></table></figure><ul><li><p>{ }初始化禁止内置类型之间的隐式窄化转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line">…</span><br><span class="line"><span class="type">int</span> sum1&#123; x + y + z &#125;; <span class="comment">// 错误! 双精度数的和可能无法表示为整数int sum2(x + y + z); // 可以 (表达式的值被截断为整数)</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z; <span class="comment">// 同上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>{ } 初始化不受 C++中令人烦恼的解析问题（任何可以被解析为声明的东西都必须被解释为声明）的影响</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget <span class="title function_">w1</span><span class="params">(<span class="number">10</span>)</span>; <span class="comment">// 调用 Widget 类的构造函数，并传入参数10</span></span><br><span class="line">Widget <span class="title function_">w2</span><span class="params">()</span>; <span class="comment">// 令人烦恼的解析！声明了名为 w2 的函数，它返回一个 Widget！</span></span><br><span class="line">Widget w3&#123;&#125;; <span class="comment">// 无参数，调用构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p>构造函数声明类型为std::initializer_list的参数</p></blockquote><p><strong>如果存在构造函数声明了类型为 std::initializer_list 的参数，那么使用{ }初始化语法的调用强烈倾向于采用接受 std::initializer_list 的重载。非常强烈！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// 和以前一样</span></span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// 和以前一样</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">long</span> <span class="type">double</span>&gt; il); <span class="comment">// 新加入</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget <span class="title function_">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span>; <span class="comment">// 调用第一个ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// 调用initializer_list ctor(10和true转换为long double)</span></span><br><span class="line">Widget <span class="title function_">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span>; <span class="comment">// 调用第二个ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// 调用initializer_list ctor(10和5.0转换为long double)</span></span><br></pre></td></tr></table></figure><p>报错情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// 和以前一样</span></span><br><span class="line">    Widget(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// 和以前一样</span></span><br><span class="line">    <span class="comment">//元素类型现在为bool</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">bool</span>&gt; il); </span><br><span class="line">&#125;; </span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// 错误! 需要窄化转换</span></span><br></pre></td></tr></table></figure><p>Widget想转换，但是{}不能支持窄转换~</p><hr><p>为了着手解除众多的初始化语法带来的困惑，也为了解决这些语法不能覆盖所有初始化场景的问题，C++11 引入了统一初始化，以<strong>大括号初始化（braced initialize）</strong> 的形式存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种写法等价</span></span><br><span class="line"><span class="type">int</span> x&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> y = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号可以用于指定容器的初始内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号和等号可以用于为非静态成员指定默认初始化值，而小括号不行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// 可行</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">// 可行</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;   <span class="comment">// 不可行！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不可复制的对象可以采用大括号和小括号进行初始化，而不能使用等号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123; <span class="number">0</span> &#125;;  <span class="comment">// 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>;    <span class="comment">// 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>;   <span class="comment">// 不可行！</span></span><br></pre></td></tr></table></figure><p>大括号初始化禁止内建类型之间进行<strong>隐式窄化类型转换（narrowing conversion）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum1&#123; x + y + z &#125;;  <span class="comment">// 错误！double 之和可能无法用 int 表达</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(x + y + z)</span></span>;    <span class="comment">// 正确，表达式的值被截断为 int</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z;   <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>大括号初始化可以避免<strong>最令人烦恼的解析语法（most vexing parse）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 调用 Widget 构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;    <span class="comment">// 声明了一个名为 w2，返回值为 Widget 对象的函数</span></span><br><span class="line">Widget w3&#123;&#125;;    <span class="comment">// 调用没有形参的 Widget 构造函数</span></span><br></pre></td></tr></table></figure><p>大括号初始化也有一些缺点，其中一个是<strong>条款 2</strong> 中提到的 auto 推导问题，另一个则产生于对带有<code>std::initializer_list</code>类型形参的重载版本的强烈偏向性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">int</span>&gt; f);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;        <span class="comment">// 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123; <span class="number">10</span>, <span class="literal">true</span> &#125;;      <span class="comment">// 调用带有 std::initializer_list 形参的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;         <span class="comment">// 调用第二个构造函数</span></span><br><span class="line">Widget w4&#123; <span class="number">10</span>, <span class="number">5.0</span> &#125;;       <span class="comment">// 错误！禁止窄化类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>;              <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Widget w6&#123; w4 &#125;;            <span class="comment">// 将 w4 强制转换为 int 后，调用带有 std::initializer_list 形参的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(std::move(w4))</span></span>;   <span class="comment">// 调用移动构造函数</span></span><br><span class="line">Widget w8&#123; std::<span class="built_in">move</span>(w4) &#125;; <span class="comment">// 情况和 w6 相同</span></span><br></pre></td></tr></table></figure><p>只有在找不到任何办法把大括号初始值设定项中的实参转换为<code>std::initializer_list</code>模板中的类型时，编译器才会退而检查普通的重载决议。</p><p>值得注意的是，一对空大括号代表的意义是 “没有实参”，而非 “空的<code>std::initializer_list</code>”，后者可以用套娃的括号来表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;      <span class="comment">// 调用默认构造函数</span></span><br><span class="line">Widget w2&#123;&#125;;    <span class="comment">// 仍然调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>;    <span class="comment">// 变成了函数声明语句</span></span><br><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">// 调用带有 std::initializer_list 形参的构造函数</span></span><br><span class="line">                <span class="comment">// 并传入空的 std::initializer_list</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>在使用模板进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。举例来说，如果你想以任意数量的实参来创建一个任意类型的对象，那么，一个可变参数模板将会是不错的选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用 params 创建 T 类型的局部对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>然而此时，在模板内部创建局部对象时，对小括号和大括号的选择将会影响实际创建出的内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个包含 10 个元素的 std::vector</span></span><br><span class="line"><span class="function">T <span class="title">localObject</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个包含 2 个元素的 std::vector</span></span><br><span class="line">T localObject&#123; std::forward&lt;Ts&gt;(params)... &#125;;</span><br></pre></td></tr></table></figure><p>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</p><h3 id="条款-8：优先选用-nullptr，而非-0-或-NULL"><a href="#条款-8：优先选用-nullptr，而非-0-或-NULL" class="headerlink" title="条款 8：优先选用 nullptr，而非 0 或 NULL"></a>条款 8：优先选用 nullptr，而非 0 或 NULL</h3><hr><p>重点：</p><p>在C++11中，nullptr是一个更好的选择，虽然它也不是指针类型，但好在它也不是整数类型。<br>nullptr的类型为std::nullptr_t，它可以隐式地转换为所有内置的指针类型。</p><hr><p><code>nullptr</code>的实际类型是<code>std::nullptr_t</code>，该类型可以隐式转换到所有的裸指针类型，因此<code>nullptr</code>可以扮演所有类型的指针。与<code>0</code>和<code>NULL</code>不同，<code>nullptr</code>不具备整数类型，因此不具有多义性。</p><p><code>0</code>和<code>NULL</code>导致的重载问题提醒我们应当尽量避免在整型和指针类型之间进行重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;  <span class="comment">// f 的三个重载版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);           <span class="comment">// 调用 f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);        <span class="comment">// 可能无法通过编译，但一般会调用 f(int)，绝不会调用 f(void*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);     <span class="comment">// 调用 f(void*)</span></span><br></pre></td></tr></table></figure><p><code>nullptr</code>在有模板的前提下表现最亮眼：模板类型推导会将<code>0</code>和<code>NULL</code>推导成 “错误” 类型（即它们的真实类型，而非空指针这个含义），而使用<code>nullptr</code>的话，模板就不会带来特殊的麻烦。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(std::unique_ptr&lt;Widget&gt; upw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> MuxType, <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">lockAndCall</span><span class="params">(FuncType func, MuxType&amp; mutex, PtrType ptr)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">std::mutex f1m, f2m, f3m;</span><br><span class="line"><span class="keyword">auto</span> result1 = <span class="built_in">lockAndCall</span>(f1, f1m, <span class="number">0</span>);         <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">lockAndCall</span>(f2, f2m, <span class="literal">NULL</span>);      <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result3 = <span class="built_in">lockAndCall</span>(f3, f3m, <span class="literal">nullptr</span>);   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="条款-9：优先选用别名声明，而非-typedef"><a href="#条款-9：优先选用别名声明，而非-typedef" class="headerlink" title="条款 9：优先选用别名声明，而非 typedef"></a>条款 9：优先选用别名声明，而非 typedef</h3><hr><p>重点：</p><p><strong>别名声明可以模板化(别名模板)，而typedef不能。</strong></p><p>要点：</p><ul><li>typedef不支持模板化，但别名声明支持。</li><li>别名模板避免使用“::type”后缀，以及在模板中的“typename”前缀（typedef所需要的）。</li><li>C++ 14为所有的C++ 11类型特征转换提供了别名模板。</li></ul><hr><p>很多人发现别名声明在处理涉及函数指针的类型时，比<code>typedef</code>更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> std::string&amp;)</span></span></span><br></pre></td></tr></table></figure><p>代替为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FP = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> std::string&amp;);</span><br></pre></td></tr></table></figure><p>但别名声明的压倒性优势在于<strong>别名模板（alias template）</strong>，它给予了 C++11 程序员一种直截了当的表达机制，用以表达 C++98 程序员不得不用嵌套在模板化的<code>struct</code>里面的<code>typedef</code>才能硬搞出来的东西。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用别名模板，就可以让整个写法更简洁，并且可以摆脱类型前的<code>typename</code>限定符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyAllocList&lt;T&gt; list;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++11 中，标准库的<code>&lt;type_traits&gt;</code>给出了一整套用于进行值类别转换的模板，它们是使用<code>typedef</code>实现的，对于给定待变换类型 T，其结果类型需要通过<code>std::transformation&lt;T&gt;::type</code>的方式获得。而在 C++14 中，所有的值类别转换都加上了对应的别名模板，通过<code>std::transformation_t&lt;T&gt;</code>的方式使用，这显然比<code>typedef</code>实现的版本更加好用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type          <span class="comment">// C++11: const T -&gt; T</span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;              <span class="comment">// C++14 中的等价物</span></span><br><span class="line"></span><br><span class="line">std::remove_reference&lt;T&gt;::type      <span class="comment">// C++11: T&amp;/T&amp;&amp; -&gt; T</span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt;          <span class="comment">// C++14 中的等价物</span></span><br><span class="line"></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type  <span class="comment">// C++11: T -&gt; T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt;      <span class="comment">// C++14 中的等价物</span></span><br></pre></td></tr></table></figure><h3 id="条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"><a href="#条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型" class="headerlink" title="条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"></a>条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><hr><p>重点：</p><p>C++11引入的限定作用域枚举是强类型枚举，使得枚举类型更加类型安全。</p><p>要点</p><ul><li>C++98 风格的枚举现在被称为不限作用域的枚举。</li><li>限定作用域的枚举值仅在枚举内部可见。它们只能通过强制类型转换转换为其他类型。</li><li>限定作用域的枚举和不限定作用域的枚举都支持指定基础类型。限定作用的枚举的默认基础类型是 int。不限定作用域的枚举没有默认基础类型。</li><li>限定作用域是枚举总是可以进行前置声明。不限定作用域的枚举只有在其声明指定了基础类型时才能进行前置声明。</li></ul><hr><p>C++98 中的枚举类型被称为不限作用域的枚举类型，与之相对的即是 C++11 中引入的限定作用域的枚举类型，即枚举类<code>enum class</code>，它的优点很明显：不会产生名称污染。</p><p>除此以外，枚举类还是强类型的，而不限范围的枚举类型中的枚举量可以隐式转换到整型（并由此更进一步转换到浮点型）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::<span class="type">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(std::<span class="type">size_t</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">Color c = red;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要用<code>enum class</code>代替<code>enum</code>，对其施以强制类型转换即可，但是无法确保转换的合法性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::<span class="type">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(std::<span class="type">size_t</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">Color c = Color::red;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(c));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不限范围的枚举类型，编译器为了节约使用内存，通常会为枚举类型选用足够表示枚举量取值的最小底层类型。即使在某些情况下，编译器会采取空间换时间的策略，导致放弃选择尺寸最小的类型，然而它仍然需要保留优化空间的能力。因此，在 C++98 中，<code>enum</code>只允许在声明处定义，没有提供对前置声明的支持。</p><p>而在 C++11 中，无论是<code>enum class</code>还是<code>enum</code>都可以进行前置声明，<code>enum class</code>的默认底层类型是<code>int</code>，而<code>enum</code>不具备默认底层类型，只有在指定了的前提下才可以进行前置声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>;                  <span class="comment">// 底层类型是 int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> : std::<span class="type">uint32_t</span>;  <span class="comment">// 底层类型是 std::uint32_t</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> : std::<span class="type">uint8_t</span>;          <span class="comment">// 底层类型是 std::uint8_t</span></span><br></pre></td></tr></table></figure><p>底层类型指定同样也可以在定义时进行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> : std::<span class="type">uint32_t</span> &#123;</span><br><span class="line">    good = <span class="number">0</span>,</span><br><span class="line">    failed = <span class="number">1</span>,</span><br><span class="line">    incomplete = <span class="number">100</span>,</span><br><span class="line">    corrupt = <span class="number">200</span>,</span><br><span class="line">    audited = <span class="number">500</span>,</span><br><span class="line">    indetermine = <span class="number">0xFFFFFFFF</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不限范围的枚举类型在你需要更便捷地为数字和名称建立联系时，还是比较好用的，例如在访问元组的元素时，你可以使用枚举量而非直接使用难懂的数字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = std::tuple&lt;std::string, std::string, std::<span class="type">size_t</span>&gt;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line"></span><br><span class="line">UserInfo uInfo;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo);</span><br></pre></td></tr></table></figure><p>而使用<code>enum class</code>就要啰嗦得多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><p>如果你实在无法忍受名称污染，执意打算使用<code>enum class</code>，那么可以考虑使用以下辅助类来简化书写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;    <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><h3 id="条款-11：优先选用删除函数，而非-private-未定义函数"><a href="#条款-11：优先选用删除函数，而非-private-未定义函数" class="headerlink" title="条款 11：优先选用删除函数，而非 private 未定义函数"></a>条款 11：优先选用删除函数，而非 private 未定义函数</h3><hr><p>重点：</p><p>已删除函数的一个重要优势是任何函数都可以被删除</p><p><strong>要点</strong></p><ul><li>优先选择已删除函数而不是私有未定义的函数。</li><li>任何函数都可以被删除，包括非成员函数和模板实例化。</li></ul><hr><p>删除函数和将函数声明为 private 看起来只是风格不同的选择，但其实有更多值得思考的微妙之处，例如：被删除的函数无法通过任何方法调用，对于成员和友元函数中的代码也是如此。</p><p>习惯上，删除函数会被声明为 public，而非 private，这样做的理由是：C++ 会先校验可访问性，后校验删除状态，当我们尝试调用某个 private 删除函数时，编译器可能只会提醒函数无法访问，而非更应关心的函数是否被删除。</p><p>以下是 C++11 中<code>std::basic_ios</code>阻止被复制的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>任何函数都能被删除，藉此我们可以过滤掉不想要的函数重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;       <span class="comment">// 原始版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">// 拒绝 char 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">// 拒绝 bool 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;  <span class="comment">// 拒绝 double 和 float 类型</span></span><br></pre></td></tr></table></figure><p><code>float</code>类型的参数会优先转换到<code>double</code>类型，因此传入<code>float</code>时会调用<code>double</code>类型的重载版本，但由于这个重载版本被删除了，所以编译会被阻止。</p><p>删除函数还可以阻止那些不应该进行的模板具现。举例来说，假设你需要一个和内建指针协作的模板，却不想要它对<code>void*</code>和<code>char*</code>指针进行处理，那么可以写出以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删去其它版本，如 volatile void* 和 volatile char*</span></span><br><span class="line"><span class="comment">// 与其它标准字符类型，如 std::wchar_t, std::char16_t 和 std::char32_t</span></span><br></pre></td></tr></table></figure><p>成员函数模板可以在类外被删除：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Widget::<span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="条款-12：为意在改写的函数添加-override-声明"><a href="#条款-12：为意在改写的函数添加-override-声明" class="headerlink" title="条款 12：为意在改写的函数添加 override 声明"></a>条款 12：为意在改写的函数添加 override 声明</h3><hr><blockquote><p><strong>引用限定符</strong></p></blockquote><p>引用限定符可以将成员函数的使用限制为只左值或只右值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    …</span><br><span class="line">    <span class="type">void</span> <span class="title function_">doWork</span><span class="params">()</span> &amp;; <span class="comment">// 只有当*this是左值时，这个版本的doWork才适用</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">doWork</span><span class="params">()</span> &amp;&amp; ; <span class="comment">// 只有当*this是右值时，这个版本的doWork才适用</span></span><br><span class="line">&#125;; </span><br><span class="line">…</span><br><span class="line">Widget <span class="title function_">makeWidget</span><span class="params">()</span>; <span class="comment">// 工厂函数(返回右值)</span></span><br><span class="line">Widget w; <span class="comment">// 普通对象(一个左值)</span></span><br><span class="line">…</span><br><span class="line">w.doWork(); <span class="comment">// 调用左值版本的 Widget::doWork (i.e., Widget::doWork &amp;)</span></span><br><span class="line">makeWidget().doWork(); <span class="comment">// 调用右值版本的 Widget::doWork (i.e., Widget::doWork &amp;&amp;)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>case</strong></p></blockquote><p>为什么这些派生类的函数不重写基类的同名函数?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf1</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf2</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf3</span><span class="params">()</span> &amp;;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mf4</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf1</span><span class="params">()</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span>;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf3</span><span class="params">()</span> &amp;&amp; ;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mf4</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>mf1在Base中声明为const，但在Derived中没有。</li><li>mf2在Base中接受一个int类型参数，但在Derived中接受一个unsigned int类型参数。</li><li>mf3在Base中是左值限定的，但在Derived中是右值限定的。</li><li>在Base中没有将f4声明为virtual。</li></ul><p>C++11中，可以将成员函数声明为override，<strong>编译器会抱怨所有与重写相关的问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf1</span><span class="params">()</span> override;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> override;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf3</span><span class="params">()</span> &amp;&amp; override;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">mf4</span><span class="params">()</span> <span class="type">const</span> override;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要点</p><ul><li>将重写函数声明为override。</li><li>成员函数引用限定符使得可以区别对待左值和右值对象(*this)。</li></ul><hr><p>如果要使虚函数重写发生，有一系列要求需要满足：</p><ol><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的<strong>函数名称</strong>必须完全相同（析构函数除外）。</li><li>基类和派生类中的<strong>函数形参类型</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数常量性</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数返回值</strong>和<strong>异常规格</strong>必须兼容。</li><li>基类和派生类的<strong>函数引用限定符</strong>必须完全相同。</li></ol><p>由于对声明派生类中的重写，保证正确性很重要，而出错又很容易，C++11 提供了<code>override</code>声明来显式地标明派生类中的函数是为了重写基类版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 加个 &quot;virtual&quot; 没问题，但也没必要</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样做的好处不仅在于让编译器提醒你想要重写的函数实际上并未重写，还可以让你在打算更改基类中虚函数的签名时，衡量一下其所造成的影响。</p><blockquote><p><code>override</code>和<code>final</code>是 C++11 中加入的<strong>语境关键字（contextual keyword）</strong>，它们的特点是仅会在特定语境下才发挥被保留的意义，因此如果你有一些遗留代码，其中已经用过<code>override</code>和<code>final</code>作为名称的话，并不需要为它们改名。</p></blockquote><p><strong>函数引用限定符（reference qualifier）：</strong> 限制成员函数仅用于左值对象或右值对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;    <span class="comment">// 仅在 *this 是左值时调用</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;   <span class="comment">// 仅在 *this 是右值时调用</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">doWork</span>();            <span class="comment">// 以左值调用 Widget::doWork &amp;</span></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>(); <span class="comment">// 以右值调用 Widget::doWork &amp;&amp;</span></span><br></pre></td></tr></table></figure><p>带引用限定符的成员函数并不常见，但有时也是需要的。举例来说，假设我们的<code>Widget</code>类中有个<code>std::vector</code>类型的数据成员，我们提供一个函数让用户能对这个数据成员直接访问，但对于左值对象和右值对象有不同的行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp;              <span class="comment">// 对于左值 Widget 类型，返回左值</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp;              <span class="comment">// 对于右值 Widget 类型，返回右值</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>();              <span class="comment">// 调用 Widget::data 的左值重载版本</span></span><br><span class="line">                                    <span class="comment">// vals1 采用拷贝构造完成初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();   <span class="comment">// 调用 Widget::data 的右值重载版本</span></span><br><span class="line">                                    <span class="comment">// vals2 采用移动构造完成初始化</span></span><br></pre></td></tr></table></figure><h3 id="条款-13：优先选用-const-iterator，而非-iterator"><a href="#条款-13：优先选用-const-iterator，而非-iterator" class="headerlink" title="条款 13：优先选用 const_iterator，而非 iterator"></a>条款 13：优先选用 const_iterator，而非 iterator</h3><hr><p>要点</p><ul><li>优先选用const_iterator,而非iterator。</li><li>在最泛型的代码中，优先使用begin、end、rbegin等的非成员版本，而不是对应的成员函数。</li></ul><hr><p><code>const_iterator</code>是 STL 中提供的与指向 const 的指针含义相同之物，它们指向不可被修改的值。任何时候只要你需要一个迭代器而其所指向的内容没有修改的必要，那就应该使用 const_iterator。</p><p>但在 C++98 中，<code>const_iterator</code>得到的支持不够全面，想要获取它们就很不容易，而获取到了以后使用它们的方法也很受限。例如在 C++98 中，我们会被迫写出以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::iterator IterT;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::const_iterator ConstIterT;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ConstIterT ci = </span><br><span class="line">    std::<span class="built_in">find</span>(<span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">begin</span>()),</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">end</span>()),</span><br><span class="line">              <span class="number">1983</span>);                            <span class="comment">// const_iterator 作为参数，返回 const_iterator</span></span><br><span class="line"></span><br><span class="line">values.<span class="built_in">insert</span>(<span class="built_in">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>);    <span class="comment">// C++98 中 insert 只能接受 iterator</span></span><br><span class="line">                                                <span class="comment">// 从 const_iterator 到 iterator 不存在可移植的类型转换</span></span><br><span class="line">                                                <span class="comment">// 可能无法通过编译</span></span><br></pre></td></tr></table></figure><p>而在 C++11 中，这些现象得到了彻底的改变，获取和使用<code>const_iterator</code>都变得容易了。要把原始的、使用<code>iterator</code>的 C++98 代码修改成使用<code>const_iterator</code>的 C++11 代码也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(values.<span class="built_in">cbegin</span>(), values.<span class="built_in">cend</span>(), <span class="number">1983</span>);</span><br><span class="line"></span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure><p>C++11 对于<code>const_iterator</code>支持的唯一缺陷是只为<code>begin</code>和<code>end</code>提供了对应的非成员函数版本，而没有为<code>cbegin</code>、<code>cend</code>、<code>rbegin</code>、<code>cend</code>、<code>crbegin</code>和<code>crend</code>这些返回<code>const_iterator</code>的函数提供对应的非成员函数版本，这个问题在 C++14 中得到了解决。想要自己实现它们也很简单，如下就是非成员函数版本的<code>cbegin</code>的一个实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span> -&gt; <span class="title">decltype</span><span class="params">(std::begin(container))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该模板在传入一个内建数组时也管用，此时<code>container</code>会成为一个 const 数组的引用。</p><blockquote><p>C++11 的非成员函数版本的<code>begin</code>为内建数组提供了一个特化版本，它返回一个指向数组首元素的指针。由于 const 数组的元素都为 const，所以若给<code>begin</code>传入一个 const 数组，则返回的指针是个指向 const 的指针，即数组意义下的 const_iterator。</p></blockquote><p>由于内建数组和第三方库的存在，最通用化的代码往往不会假定成员函数的存在，而是更多地采用非成员函数版本，例如以下<code>findAndInsert</code>模板的通用形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container, <span class="type">const</span> V&amp; targetVal, <span class="type">const</span> V&amp; insertVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cbegin;</span><br><span class="line">    <span class="keyword">using</span> std::cend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container), <span class="built_in">cend</span>(container), targetVal);</span><br><span class="line"></span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明"><a href="#条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明" class="headerlink" title="条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明"></a>条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明</h3><hr><p>noexcept含义：一个函数 f，它向调用者承诺永远不会抛出异常。noexcept使得编译器可以根据这个声明进行更深入的优化，避免不必要栈展开操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// C++98 风格</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// C++11 风格</span></span><br></pre></td></tr></table></figure><p>如果f 违反了异常规范。<br>C++98 风格：调用栈会展开，退回到 f 的调用者，进行一些操作后，程序执行就会终止<br>C++11 风格：程序终止之前，栈只是可能会被展开（就算异常被抛出，大不了终止程序，无需处理异常）</p><p>潜在问题：</p><p>假设你想通过移动来优化性能，但与拷贝不同，移动过程中如果发生异常，将很难回滚到之前的状态。这是一个严重的问题，因为遗留代码的行为可能依赖于push_back的强异常安全保证。因此移动操作必须做出noexcept保证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">…</span><br><span class="line">Widget w;</span><br><span class="line">… </span><br><span class="line">vw.<span class="built_in">push_back</span>(w); </span><br><span class="line">…</span><br></pre></td></tr></table></figure><hr><p>在 C++11 中，C++98 风格的异常规范已经被弃用，而转为为不会抛出异常的函数提供<code>noexcept</code>声明，函数是否要加上这个声明，事关接口声明。</p><p>调用方可以查询函数的<code>noexcept</code>状态，而查询结果可能会影响调用代码的异常安全性和运行效率。这么一来，函数是否带有<code>noexcept</code>声明就是和成员函数是否带有 const 声明同等重要的信息。当你明明知道一个函数不会抛出异常却未给它加上<code>noexcept</code>声明的话，就属于接口规格设计缺陷。</p><p>相当于不带<code>noexcept</code>声明的函数，带有<code>noexcept</code>声明的函数有更多机会得到优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 最优化</span></span><br><span class="line"></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">// 优化不足</span></span><br><span class="line"></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;           <span class="comment">// 优化不足</span></span><br></pre></td></tr></table></figure><p>在带有<code>noexcept</code>声明的函数中，优化器不需要在异常传出函数的前提下，将运行时栈保持在可展开状态；也不需要在异常逸出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以<code>throw()</code>异常规格声明的函数就享受不到这样的优化灵活性，和那些没有加上异常规格的函数一样。</p><p><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略，但这必须保证在使用移动操作代替复制操作后，函数依旧具备强异常安全性。为了得知移动操作会不会产生异常，就需要校验这个操作是否带有<code>noexcept</code>声明。</p><p><code>swap</code>函数是许多 STL 算法实现的核心组件，它的广泛使用昭示着针对其实施<code>noexcept</code>声明带来的收益是可观的。标准库中的<code>swap</code>是否带有<code>noexcept</code>声明，取决于用户定义的<code>swap</code>自身。例如，标准库为数组和<code>std::pair</code>准备的<code>swap</code>函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T (&amp;a)[N],</span></span></span><br><span class="line"><span class="params"><span class="function">          T (&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些函数带有条件式<code>noexcept</code>声明，它们到底是否具备<code>noexcept</code>属性，取决于它的<code>noexcept</code>分句中的表达式是否结果为<code>noexcept</code>。在此处，数组和<code>std::pair</code>的<code>swap</code>具备<code>noexcept</code>属性的前提是，其每一个元素的<code>swap</code>都具备<code>noexcept</code>属性。</p><p>对于某些函数来说，具备<code>noexcept</code>属性是如此之重要，所以它们默认就是如此。在 C++11 中，内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性。析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code>，即可能抛出异常。</p><blockquote><p>不具备<code>noexcept</code>属性的析构函数很少见，标准库里一个都没有，而如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</p></blockquote><p>大多数函数都是<strong>异常中立（exception-neutral）</strong> 的，不具备<code>noexcept</code>属性。此类函数自身并不抛出异常，但它们调用的函数可能会抛出异常，这些异常会经由异常中立函数传至调用栈的更深一层。</p><p>C++ 允许带有<code>noexcept</code>声明的函数依赖于缺乏<code>noexcept</code>保证的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，有些库的接口设计者会把函数区分为带有<strong>宽松规约（wide constract）</strong> 和带有<strong>狭隘规约（narrow constract）</strong> 的不同种类。带有宽松规约的函数是没有前置条件的，要调用这样的函数也无须关心程序状态；而对于带有狭隘规约的函数，如果前置条件被违反，则结果将成为未定义的。一般而言，我们只会把<code>noexcept</code>声明保留给那些带有宽松规约的函数。</p><h3 id="条款-15：只要有可能使用-constexpr，就使用它"><a href="#条款-15：只要有可能使用-constexpr，就使用它" class="headerlink" title="条款 15：只要有可能使用 constexpr，就使用它"></a>条款 15：只要有可能使用 constexpr，就使用它</h3><hr><p>constexpr本质上是const的增强形式。</p><p>从概念上讲，constexpr 表示不仅是常量，而且在编译时就已知的值。</p><p><strong>当用编译时常量调用constexpr函数时，会产生编译时常量。如果用运行时才知道的值来调用，则会产生运行时值。这意味着不需要两个函数来执行相同的操作，一个用于编译时常量，一个用于所有其他值。</strong></p><p>要点</p><ul><li>constexpr 对象是常量，并且使用在编译时已知的值进行初始化。</li><li>当使用编译时已知值作为参数调用时，constexpr 函数可以在编译时产生结果。</li><li>constexpr 对象和函数可能比非 constexpr 对象和函数在更广泛的上下文中使用。</li><li>constexpr 是对象或函数接口的一部分。</li></ul><hr><p><strong><code>constexpr</code>对象：</strong> 具备 const 属性，并由编译期已知的值完成初始化。</p><p>在编译阶段就已知的值拥有许多特权，它们可能被放置在只读内存里（对于嵌入式开发尤为重要）；在编译阶段就已知的常量整型值可以用在 C++ 要求整型常量表达式的语境中，包括数组的尺寸规格、整型模板实参、枚举量的值、对齐规格等，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;                             <span class="comment">// 非 constexpr 变量</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> arraySize = sz;          <span class="comment">// 正确，arraySize 是 sz 的一个 const 副本</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize&gt; data;    <span class="comment">// 错误！arraySize 的值非编译期可知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">// 错误！sz 的值在编译期未知</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, sz&gt; data1;          <span class="comment">// 错误！问题同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">// 正确，10 是编译期常量</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize2&gt; data2;  <span class="comment">// 正确，arraySize2 是编译期常量</span></span><br></pre></td></tr></table></figure><p><strong><code>constexpr</code>函数：</strong></p><ul><li><code>constexpr</code>函数可以用在要求编译期常量的语境中。在这种情况下，若传给一个<code>constexpr</code>函数的实参值是在编译期已知的，则结果也会在编译期计算出来；如果任何一个实参值在编译期未知，则代码将无法通过编译。</li><li><code>constexpr</code>函数也可以运用在非编译期常量的语境中，此时传入的值可以有一个或多个在编译期未知。它的运作方式和普通函数无异，同样在运行期完成结果的计算。</li><li>在 C++11 中，<code>constexpr</code>函数不得包含多于一个可执行语句，即一条<code>return</code>语句；而到了 C++14，就没有了这种限制。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span> </span>&#123;     <span class="comment">// C++11</span></span><br><span class="line">    <span class="keyword">return</span> (exp == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span> </span>&#123;     <span class="comment">// C++14</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp; ++i) result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numConds = <span class="number">5</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, pow(3, numConds)&gt; results;</span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数仅限于传入和返回<strong>字面类型（literal type）</strong>，这些类型能够持有编译期可以决议的值。在 C++11 中，除了<code>void</code>的所有内建类型都是字面类型；此外，我们也可以自定义字面类型，这需要将其构造函数和部分成员函数声明为<code>constexpr</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> :</span></span><br><span class="line"><span class="function">        x(xVal), y(yVal) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;  <span class="comment">// 在编译期执行 constexpr 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;  <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.<span class="built_in">xValue</span>() + p2.<span class="built_in">xValue</span>()) / <span class="number">2</span>,</span><br><span class="line">             (p1.<span class="built_in">yValue</span>() + p2.<span class="built_in">yValue</span>()) / <span class="number">2</span> &#125;; <span class="comment">// 调用 constexpr 成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);  <span class="comment">// 使用 constexpr 函数的返回值来初始化 constexpr 对象</span></span><br></pre></td></tr></table></figure><p>在 C++14 中，就连返回值类型为<code>void</code>的 setter 函数也可以声明为<code>constexpr</code>函数，这就使以下代码变为可能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    Point result;</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">setX</span>(-p.<span class="built_in">xValue</span>());</span><br><span class="line">    result.<span class="built_in">setY</span>(-p.<span class="built_in">yValue</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectionMid = <span class="built_in">reflection</span>(mid);</span><br></pre></td></tr></table></figure><p>需要注意的是，一旦你把一个对象或函数声明成了<code>constexpr</code>，而后来你又感觉对<code>constexpr</code>运用不当，然后进行了移除，那么这会导致非常多客户代码无法通过编译。因此，“只要有可能使用<code>constexpr</code>，就使用它” 这句话中的 “只要有可能” 的含义就是你是否有一个长期的承诺，将由<code>constexpr</code>带来的种种限制施加于相关的函数和对象上。</p><h3 id="条款-16：保证-const-成员函数的线程安全性"><a href="#条款-16：保证-const-成员函数的线程安全性" class="headerlink" title="条款 16：保证 const 成员函数的线程安全性"></a>条款 16：保证 const 成员函数的线程安全性</h3><hr><p>要点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    using RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    RootsType <span class="title function_">roots</span><span class="params">()</span> <span class="type">const</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">g</span><span class="params">(m)</span>; <span class="comment">// 锁定mutex</span></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123; <span class="comment">// 如果缓存无效</span></span><br><span class="line">            … <span class="comment">// 计算/存储 rootVals</span></span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125; <span class="comment">// 解锁mutex</span></span><br><span class="line">private:</span><br><span class="line">    mutable <span class="built_in">std</span>::mutex m;</span><br><span class="line">    mutable <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    mutable RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点1</strong>：业务逻辑认为可改，加mutable关键字。mutable关键字用于允许在常量函数（如roots）中修改类的某些成员变量。</p><p><strong>重点2</strong>：由于std::mutex是一种仅可移动类型，将m添加到Polynomial，将导致Polynomial失去了被复制的能力。【与std::mutex一样，std::atomic也是仅可移动类型，因此Point中存在callCount意味着Point也是仅可移动的。】</p><hr><p>对于 const 成员函数，我们通常认为它代表的是读操作，而多个线程在没有同步的情况下执行读操作应该是安全的。因此，我们需要保证 const 成员函数的线程安全性，除非可以确信它们不会在并发语境中被使用。</p><p>考虑如下情形，我们将计算出的多项式的根存入缓存中，以避免代价高昂的重复计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;       <span class="comment">// 如果缓存无效</span></span><br><span class="line">            ...</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;   <span class="comment">// 则计算根，并将其存入 rootVals</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 mutable 成员变量的存在，可能有不同的多个线程通过<code>roots</code>成员函数在没有同步的情况下读写同一块内存，造成<strong>数据竞争（data race）</strong>，这会导致未定义行为的出现。</p><p>有两种方法可以解决这个问题，最简单的方法也是最常见的，引入一个 mutex 互斥量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;   <span class="comment">// 互斥量加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;       <span class="comment">// 如果缓存无效</span></span><br><span class="line">            ...</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;   <span class="comment">// 则计算根，并将其存入 rootVals</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;                                       <span class="comment">// 互斥量解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;                   <span class="comment">// 添加 mutable 的互斥量</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种方法是使用<code>std::atomic</code>类型的变量，这会比使用互斥量提供更好的性能，但更适用于对单个变量或内存区域的操作。以下情况更适合使用<code>std::atomic</code>来确保线程安全性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ++callCount;                                <span class="comment">// 带原子性的自增操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;   <span class="comment">// 存储调用次数</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无论是<code>std::mutex</code>还是<code>std::atomic</code>都是只移类型，无法进行复制，因此加入它们都会使类失去可复制性，但仍然可以移动。</p><h3 id="条款-17：理解特殊成员函数的生成机制"><a href="#条款-17：理解特殊成员函数的生成机制" class="headerlink" title="条款 17：理解特殊成员函数的生成机制"></a>条款 17：理解特殊成员函数的生成机制</h3><hr><p><strong>要点</strong></p><ul><li>特殊成员函数是编译器可以自己生成的函数：默认构造函数、析构函数、拷贝操作和移动操作。</li><li>只有没有显式声明移动操作、拷贝操作和析构函数的类才会生成移动操作。</li><li>只有没有显式声明拷贝构造函数的类才会生成拷贝构造函数，如果声明了移动操作，就会删除拷贝构造函数。</li><li>只有没有显式声明拷贝赋值操作符的类才会生成拷贝赋值操作符，如果声明了移动操作符，就会删除它。不赞</li><li>成在显式声明析构函数的类中生成拷贝操作。</li><li>成员函数模板永远不会抑制特殊成员函数的生成。</li></ul><hr><p>在 C++11 中，支配特殊成员函数的机制如下（所有生成的默认特殊函数都是 inline 的，且具有 public 访问权限）：</p><ul><li><strong>默认构造函数：</strong> 与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。</li><li><strong>析构函数：</strong> 与 C++98 的机制基本相同，唯一的区别在于析构函数默认为 noexcept（参考<strong>条款 14</strong>）。仅当基类的析构函数为虚时，派生类的析构函数才为虚。</li><li><strong>拷贝构造函数：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝构造。仅当类中不包含用户声明的拷贝构造函数时才生成。如果该类声明了移动操作，则拷贝构造函数将被删除。在已经存在拷贝赋值运算符或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li><li><strong>拷贝赋值运算符：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝赋值。仅当类中不包含用户声明的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符将被删除。在已经存在拷贝构造函数或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li></ul><blockquote><p><strong>三者法则（Rule of Three）：</strong> 如果你声明了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，你就得同时声明所有这三个。<br>三者法则根植于这样的思想：如果有改写拷贝操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：<br>\1. 在一种拷贝操作中进行的任何资源管理，也极有可能在另一种拷贝操作中也需要进行。<br>\2. 该类的析构函数也会参与到该资源的管理中（通常是对资源进行释放）。<br>三者法则对移动操作也同样成立。</p></blockquote><ul><li><strong>移动构造函数和移动赋值运算符：</strong> 都<strong>按成员</strong>进行<strong>非静态</strong>数据成员的移动操作。仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成。声明一个移动构造函数会阻止编译器生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器生成移动构造函数。</li></ul><blockquote><p>声明拷贝操作（无论是拷贝构造还是拷贝赋值）的行为表明了对象的常规拷贝方式（按成员拷贝）对于该类并不适用，那么编译器就会认为按成员移动极有可能也不适用于移动操作。因此，一旦显式声明了拷贝操作，编译器就不再会为其生成移动操作，反之亦然。</p></blockquote><p>如果你有一些代码依赖于编译器自动生成的特殊函数，并且你确信这些函数会正确执行，那么可以用<code>=default</code>显式指定让它们生成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;              <span class="comment">// 使析构函数成为虚的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(Base&amp;&amp;) = <span class="keyword">default</span>;                 <span class="comment">// 提供移动操作的支持</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;            <span class="comment">// 提供拷贝操作的支持</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员函数模板在任何情况下都不会抑制特殊成员函数的生成，例如下面这个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Widget</span><span class="params">(<span class="type">const</span> T&amp; rhs)</span></span>;               <span class="comment">// 以任意类型构造 Widget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);    <span class="comment">// 以任意类型对 Widget 赋值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器会始终生成<code>Widget</code>的拷贝和移动操作，即使这些模板的具现化生成了拷贝构造函数和拷贝赋值运算符的函数签名。</p><h2 id="第四章：智能指针"><a href="#第四章：智能指针" class="headerlink" title="第四章：智能指针"></a>第四章：智能指针</h2><p>以下理由使得裸指针不受欢迎：</p><ol><li>裸指针没有在声明中指出，其指向的内容是单个对象还是数组。</li><li>裸指针没有在声明中指出，是否该在其指向的对象使用完后进行析构。</li><li>无法得知怎样析构裸指针才是适当的，是使用<code>delete</code>运算符，还是有专门用于析构的函数。</li><li>在已知使用<code>delete</code>的情况下，难以确定该用<code>delete</code>还是<code>delete[]</code>。</li><li>很难保证对指针所指向对象的析构，在所有代码路径上只执行一次。</li><li>没有正规的方式来检测指针是否空悬（dangle）。</li></ol><p>因此，在大多数时候，应该优先选用智能指针。<code>std::auto_ptr</code>是从 C++98 中残留下来的弃用特性，应该被 C++11 中的 <code>std::unique_ptr</code>所替代。</p><h3 id="条款-18：使用-std-unique-ptr-管理具备专属所有权的资源"><a href="#条款-18：使用-std-unique-ptr-管理具备专属所有权的资源" class="headerlink" title="条款 18：使用 std::unique_ptr 管理具备专属所有权的资源"></a>条款 18：使用 std::unique_ptr 管理具备专属所有权的资源</h3><hr><p>指针只能指向一个地方，并且指向的地方可以更改【通过移动操作】，对比auto_ptr.</p><p><strong>要点</strong>：</p><ul><li>默认情况下，std::unique_ptr与原始指针具有相同的大小，并且对于大多数操作（包括解引用），它们执行完全相同的指令。</li><li>std::unique_ptr 体现了独占所有权语义，总是拥有它所指向的对象</li><li>移动std::unique_ptr会将所有权从源指针转移到目标指针（源指针被设置为 null）</li><li>不允许拷贝std::unique_ptr，因此它是一种只移动类型</li><li><p>销毁时，非空std::unique_ptr会销毁其资源。默认通过对内部的原始指针应用delete来完成</p><p>使用默认删除器（即delete）使用时，std::unique_ptr 对象与原始指针大小相同。</p></li><li><p><strong>当使用自定义删除器时，函数指针类型的删除器通常会使 std::unique_ptr 的大小从一个字增长到两个字</strong></p></li><li><strong>对于函数对象类型的删除器，大小的变化取决于函数对象中存储的状态的数量</strong>。无状态的函数对象（例如，没有捕获的 lambda 表达式）没有而外的负担</li></ul><p>简单例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A *a = new A;</span></span><br><span class="line">    <span class="keyword">auto</span> fun = [](A *a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, <span class="title">decltype</span><span class="params">(fun)</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A, fun)</span></span>;<span class="comment">// 自定义删除器</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;A, void (*)(A *)&gt; p(new A, fun);</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>std::unique_ptr</code>是小巧、高速的、具备只移类型的智能指针，对于托管的指针实施专属所有权语义。它和裸指针所占大小相同，并且不允许被拷贝，在执行析构操作时，同时析构其所管理的资源。</p><p><code>std::unique_ptr</code>的一个常见用法是在继承体系中，作为工厂函数的返回值类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Investment</span>();  <span class="comment">// 必备的虚析构函数！</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> : <span class="keyword">public</span> Investment &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bond</span> : <span class="keyword">public</span> Investment &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealEstate</span> : <span class="keyword">public</span> Investment &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span>; <span class="comment">// 返回 std::unique_ptr</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">auto</span> pInvestment = <span class="built_in">makeInvestment</span>( arguments );</span><br><span class="line">    ...</span><br><span class="line">&#125;   <span class="comment">// *pInvestment 在此处析构</span></span><br></pre></td></tr></table></figure><p>默认地，资源析构采用<code>delete</code>运算符来完成，但也可以指定自定义删除器，并且删除器将会被视作<code>std::unique_ptr</code>类型的一部分。下面的例子中使用了 lambda 表达式作为自定义删除器，并在删除时写入一条日志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span>; <span class="comment">// 改进后的返回值类型</span></span><br></pre></td></tr></table></figure><p>在 C++14 中，由于有了函数返回值类型推导（参考<strong>条款 3</strong>），<code>makeInvestment</code>可以用更加简单的、封装性更好的方法实现，自定义删除器也可以放在函数内部，完整的代码演示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 现在自定义删除器位于函数内部</span></span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;</span><br><span class="line">        <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">        <span class="keyword">delete</span> pInvestment;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;    <span class="comment">// 待返回的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reset 来让 pInv 获取 new 产生的对象的所有权</span></span><br><span class="line">    <span class="comment">// 对每一次 new 的调用结果，都使用 std::forward 对实参进行完美转发（参考条款 25）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* 应创建一个 Stock 类型的对象 */</span> ) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* 应创建一个 Bond 类型的对象 */</span> ) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* 应创建一个 RealEstate 类型的对象 */</span> ) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用自定义删除器后，<code>std::unique_ptr</code>的大小可能不再和裸指针相同：有状态的删除器和采用函数指针的删除器会增加<code>std::unique_ptr</code>类型的对象尺寸大小。无状态的函数对象（例如无捕获的 lambda 表达式）不会浪费任何内存空间，而函数指针通常会使<code>std::unique_ptr</code>的大小增加一到两个字长（word），这意味着无捕获的 lambda 表达式往往是用作删除器的最佳选择。</p><p><code>std::unique_ptr</code>提供了两种形式，一种是单个对象（<code>std::unique_ptr&lt;T&gt;</code>），另一种是数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。为了避免二义性，单个对象形式不提供索引运算符（<code>operator[]</code>），而数组形式不提供解引用运算符（<code>operator*</code>和<code>operator-&gt;</code>）。但实际上，数组形式用到的场合非常少，唯一的应用场合大概是在使用 C 风格 API 时，它返回了存放在堆上的裸指针；大部分时候我们会优先考虑<code>std::array</code>、<code>std::vector</code>和<code>std::string</code>这些数据结构。</p><p><code>std::unique_ptr</code>可以方便高效地转换为<code>std::shared_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Investment&gt; sp = <span class="built_in">makeInvestment</span>( arguments );</span><br></pre></td></tr></table></figure><h3 id="条款-19：使用-std-shared-ptr-管理具备共享所有权的资源"><a href="#条款-19：使用-std-shared-ptr-管理具备共享所有权的资源" class="headerlink" title="条款 19：使用 std::shared_ptr 管理具备共享所有权的资源"></a>条款 19：使用 std::shared_ptr 管理具备共享所有权的资源</h3><hr><p>要点：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/1.png" alt=""></p><p>引用计数的存在对性能的影响：</p><ul><li><strong>std::shared_ptr 的大小是原始指针的两倍</strong>：因为内部包含一个指向资源的<strong>原始指针</strong>，以及一个指向资源<strong>引用计数的原始指针</strong>【我的理解是控制块指针】</li><li><strong>引用计数的内存必须动态分配</strong>：所指向的对象对引用计数一无所知，对象没有存储引用计数的地方</li><li><strong>引用计数的增加和减少必须是原子操作</strong>：例如，在一个线程中指向资源的 std::shared_ptr 可能正在执行其析构函数，而在另一个线程中，指向同一对象的 std::shared_ptr 可能正在被拷贝 </li></ul><p>简单例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A *a = new A;</span></span><br><span class="line">    <span class="keyword">auto</span> fun = [](A *a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A, <span class="title">decltype</span><span class="params">(fun)</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A, fun)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>不能从单个原始指针构造多个std::shared_ptr</strong>，否则指向的对象将有多个控制块，导致未定义的行为。</p><p><strong>std::shared_ptr的另一个局限性是无法处理数组</strong>。与std::unique_ptr不同，std::shared_ptr的 API 仅设计用于指向单个对象。没有std::shared_ptr<T[]>， 也没有提供operator[]。<strong>C++11 中有多种内置数组的替代方案</strong>（例如，std::array、std::vector、std::string），声明一个智能指针来指向愚蠢的数组几乎总是糟糕设计的标志。</p><hr><p><code>std::shared_ptr</code>提供了方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>所占大小通常是裸指针的两倍，它还会带来控制块的开销，并且要求成本高昂的原子化的引用计数操作。</p><p>默认的资源析构通过<code>delete</code>运算符来完成，但同时也支持自定义删除器。与<code>std::unique_ptr</code>不同的是，删除器的类型对<code>std::shared_ptr</code>的类型没有影响，也不会影响<code>std::shared_ptr</code>的尺寸大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget* pw) &#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pw);</span><br><span class="line">    <span class="keyword">delete</span> pw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(loggingDel)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt;                       <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure><p>这使得<code>std::shared_ptr</code>的设计更具弹性，拥有不同类型自定义删除器的<code>std::shared_ptr</code>也可以被放在同一个容器中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> customDeleter1 = [](Widget* pw) &#123;&#125;;    <span class="comment">// 自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> customDeleter2 = [](Widget* pw) &#123;&#125;;    <span class="comment">// 各有不同的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter1)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter2)</span></span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;</span><br></pre></td></tr></table></figure><p><strong>控制块（control block）：</strong> 每一个由<code>std::shared_ptr</code>管理的对象都拥有一个控制块，它的内存被动态分配在堆上，除了包含引用计数以外，还包含作用于<code>std::weak_ptr</code>的弱计数（参考<strong>条款 20</strong>），自定义删除器和分配器等内容。</p><p>一个对象的控制块应该在创建首个指向该对象的<code>std::shared_ptr</code>时确定，因此，控制块的创建遵循以下规则：</p><ol><li>使用<code>std::make_shared</code>（参考<strong>条款 21</strong>）总是会创建一个控制块。</li><li>从具备专属所有权的指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）出发构造一个<code>std::shared_ptr</code>时，会创建一个控制块。</li><li>用裸指针作为实参调用<code>std::shared_ptr</code>的构造函数时，会创建一个控制块。</li></ol><p>由以上规则我们可以得出，应该避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>。用同一个裸指针构造出不止一个<code>std::shared_ptr</code>将会使对象拥有多重的控制块，这会导致对资源的多次析构，从而产生未定义行为，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget; <span class="comment">// pw 是个裸指针</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, loggingDel)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(spw1)</span></span>;</span><br></pre></td></tr></table></figure><p>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全地由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，应该使该类继承自<code>std::enable_shared_from_this</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::enable_shared_from_this</code>定义了一个成员函数<code>std::shared_from_this</code>，它会创建一个<code>std::shared_ptr</code>指向当前对象，但不会重复创建控制块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidget;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理对象本身</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指向当前对象的 std::shared_ptr 加入 processedWidget</span></span><br><span class="line">    processedWidget.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免用户在<code>std::shared_ptr</code>指向该对象前就调用了<code>std::shared_from_this</code>（这会导致其无法查询到对象拥有的控制块，产生未定义行为），继承自<code>std::enable_shared_from_this</code>的类通常会将其构造函数声明为 private，并且只允许通过调用返回<code>std::shared_ptr</code>的工厂函数来创建对象。例如，以下是<code>Widget</code>类的一个可能实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将实参完美转发给 private 构造函数的工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::shared_ptr&lt;Widget&gt; <span class="title">create</span><span class="params">(Ts&amp;&amp;... params)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( ... );  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code>可以轻易转换为<code>std::shared_ptr</code>，反之却并不成立，一旦资源的生存期被托管给了<code>std::shared_ptr</code>，就不能回收该资源的所有权，并让一个<code>std::unique_ptr</code>来托管它。并且和<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>直到 C++17 才拥有处理数组的能力（<code>std::shared_ptr&lt;T[]&gt;</code>），在 C++11/14 中，它的 API 仅被设计用来处理指向单个对象的指针。</p><h3 id="条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr"><a href="#条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr" class="headerlink" title="条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr"></a>条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h3><hr><p>weak_ptr观察者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();  <span class="comment">// 引用计数=1</span></span><br><span class="line">…</span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;         <span class="comment">// 引用计数=1</span></span><br><span class="line">…</span><br><span class="line">spw = <span class="literal">nullptr</span>;                          <span class="comment">// 引用计数=0，spw变为空悬</span></span><br><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>()) …                    <span class="comment">// 如果 wpw 没有指向任何对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但通常你希望检查 std::weak_ptr是否有效，如果它不是悬挂的，则访问它指向的对象。</p><ul><li>因为 std::weak_ptr缺乏解引用操作，所以无法编写这样的代码。</li><li>需要原子操作，检查 std::weak_ptr是否有效， 有效则从 std::weak_ptr创建一个 std::shared_ptr来进行访问</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock(); <span class="comment">// 如果 wpw 无效, spw1 将会是空</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.lock(); <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>std::shared_ptr可以使用std::weak_ptr作为参数进行构造，如果std::weak_ptr已经无效，就会抛出一个异常:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title function_">spw3</span><span class="params">(wpw)</span>; <span class="comment">// 无果 wpw 无效, 则抛出 std::bad_weak_ptr</span></span><br></pre></td></tr></table></figure><p><strong>要点速记</strong></p><ul><li>对于类似std::shared_ptr的可能会悬挂的指针，请使用std::weak_ptr。</li><li>std::weak_ptr的潜在用例包括缓存、观察者列表以及防止std::shared_ptr循环。【Modern Cpp中已经讲述详细了的】</li></ul><hr><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充。它一般是通过<code>std::shared_ptr</code>来创建的，两者会指向相同位置，但<code>std::weak_ptr</code>并不影响所指向对象的引用计数，而是会影响控制块中的弱计数。</p><p>使用<code>expired</code>函数来检测<code>std::weak_ptr</code>的空悬：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">spw = <span class="literal">nullptr</span>;      <span class="comment">// Widget 对象被析构，wpw 空悬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>())  <span class="comment">// 若 wpw 不再指向任何对象</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>，可以在未失效情况下提供对资源的访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lock 函数时，若 wpw 失效，则 spw1 和 spw2 为空</span></span><br><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接构造时，若 wpw 失效，则抛出 std::bad_weak_ptr 类型的异常</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::weak_ptr</code>有以下可能的用武之地：</p><ul><li>创建带缓存的工厂函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="type">const</span> Widget&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>(); <span class="comment">// 如果对象不在缓存中，则返回空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;                  <span class="comment">// 加载并缓存对象</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);</span><br><span class="line">        cache[id] = objPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>观察者设计模式（Observer design pattern）：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li><li>避免<code>std::shared_ptr</code>循环引用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;B&gt; pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;A&gt; pa;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pa = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> pb = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">pa-&gt;pb = pb;</span><br><span class="line">pb-&gt;pa = pa;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>A</code>和<code>B</code>互相保存着指向对方的<code>std::shared_ptr</code>，产生了循环引用，两者会永久保持彼此的引用计数至少为一，这会阻止<code>A</code>和<code>B</code>被析构，实际上产生了内存泄漏。</p><p>将其中一者改为<code>std::weak_ptr</code>可以避免循环的产生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;B&gt; pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    std::weak_ptr&lt;A&gt; pa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new"><a href="#条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new" class="headerlink" title="条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new"></a>条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h3><hr><blockquote><p> <strong>好处1.原子性</strong></p></blockquote><p>1.原子性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">computePriority</span><span class="params">()</span>;</span><br><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(new Widget), computePriority()); <span class="comment">// 可能资源泄漏</span></span><br></pre></td></tr></table></figure><p>在运行时，函数的参数必须在调用函数之前进行求值：</p><ul><li>计算 new Widget 表达式，即必须在堆上创建一个 Widget</li><li>执行负责管理 new产生的指针的 std::shared_ptr&lt; Widget &gt;的构造函数</li><li>运行computePriority必须</li></ul><p><strong>编译器不需要生成按照这个顺序执行的代码</strong>。【编译器进行优化】new Widget必须在 std::shared_ptr`构造函数被调用之前执行即可。</p><p>编译器可能会生成按照以下顺序执行操作的代码：</p><p>1、执行 new Widget；</p><p>2、执行 computePriority；</p><p>3、运行 std::shared_ptr 构造函数。如果运行时，computePriority 产生异常，那么步骤 1 中动态分配的 Widget 将泄漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::make_shared&lt;Widget&gt;(), computePriority()); <span class="comment">// 不会发生内存泄露</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>好处2.内存分配次数</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure><p>这段代码执行了两次内存分配。直接使用 new，需要一次为 Widget 分配内存，第二次为控制块分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared&lt;Widget&gt;();</span><br></pre></td></tr></table></figure><p>std::make_shared分配了一个单独的内存块来容纳 Widget 对象和控制块，这种优化减少了程序的静态大小，因为代码中只包含一个内存分配调用，并且它提高了可执行代码的速度，因为只分配了一次内存。</p><blockquote><p><strong>坏处：不能自定义删除器</strong></p></blockquote><p>但没有任何make函数允许指定自定义删除器，而是 std::unique_ptr 和 std::shared_ptr 都有构造函数可以这样做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget, <span class="title function_">decltype</span><span class="params">(widgetDeleter)</span>&gt; <span class="title function_">upw</span><span class="params">(new Widget, widgetDeleter)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title function_">spw</span><span class="params">(new Widget, widgetDeleter)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>不建议使用make的情况</strong></p></blockquote><p>1、当类有自己的 operator new 和 operator delete 实现时，与 std::shared_ptr 的自定义分配和释放支持可能不兼容，因此使用 make 函数创建这些类的对象可能不合适。这可能会导致内存管理方面的问题。</p><p>2、std::shared_ptr 的控制块与管理对象放在同一块内存中。当该对象的引用计数为零时，该对象将被销毁（即，调用其析构函数）。但是，在控制块也被销毁之前，它所占用的内存不能被释放</p><ul><li>由 std::shared_ptr make 函数分配的内存只有在最后一个 std::shared_ptr 和最后一个引用它的 std::weak_ptr 被销毁后才能被释放。对象销毁和它占用的内存被释放之间可能会出现滞后</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReallyBigType</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">auto</span> pBigObj = <span class="built_in">std</span>::make_shared&lt;ReallyBigType&gt;(); <span class="comment">// 通过std::make_shared创建非常大的对象</span></span><br><span class="line">... <span class="comment">// 创建 std::shared_ptrs 和 std::weak_ptrs 到大对象，使用它们与之合作</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::shared_ptr，但对它的 std::weak_ptr 仍然存在</span></span><br><span class="line">... <span class="comment">// 在这段时间内，以前被大对象占用的内存仍然被分配</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::weak_ptr;</span></span><br><span class="line"><span class="comment">// 控制块和对象的内存被释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过直接使用 new，ReallyBigType 对象的内存可以在最后一个对它的 std::shared_ptr 被销毁后立即释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReallyBigType</span>&#123;</span>...&#125;; <span class="comment">// 与之前一样</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ReallyBigType&gt; <span class="title function_">pBigObj</span><span class="params">(new ReallyBigType)</span>;</span><br><span class="line"><span class="comment">// 通过 new 创建非常大的对象</span></span><br><span class="line">... <span class="comment">// 与之前一样，创建对象的 std::shared_ptrs 和 std::weak_ptrs，与之一起使用</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::shared_ptr，但对它的 std::weak_ptrs 仍然存在;</span></span><br><span class="line"><span class="comment">// 对象的内存已被释放</span></span><br><span class="line">... <span class="comment">// 在这段时间内，只有控制块的内存仍然有效</span></span><br><span class="line">... <span class="comment">// 此处销毁对象的最后一个 std::weak_ptr;</span></span><br><span class="line"><span class="comment">// 控制块的内存被释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果不适合使用 std::make_shared ，又希望免受异常安全问题的影响。最好的方法是确保当直接使用 new 时，立即将结果传递给智能指针构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="type">int</span> priority)</span>;<span class="comment">// 像以前一样void cusDel(Widget *ptr); // 自定义删除器</span></span><br><span class="line"><span class="comment">// 潜在的资源泄漏processWidget( std::shared_ptr&lt;Widget&gt;(new Widget, cusDel), computePriority() );</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title function_">spw</span><span class="params">(new Widget, cusDel)</span>;</span><br><span class="line">processWidget(spw, computePriority()); <span class="comment">// 正确，但不是最佳的，参数变为了左值</span></span><br><span class="line">processWidget(<span class="built_in">std</span>::move(spw), computePriority());<span class="comment">// 既高效又异常安全</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li>与使用 new 相比，make 函数消除了源代码重复，提高了异常安全性，并且对于 std::make_shared 和 std::allocate_shared，生成的代码更小、更快。</li><li>不适合使用 make 函数的情况包括，需要指定自定义删除器和希望传递花括号初始化器。</li><li>对于 std::shared_ptr，不建议使用 make 函数的其他情况包括（1）具有自定义内存管理的类；（2）注重内存效率的系统，具有非常大的对象以及比相应的 std::shared_ptr 存活时间更长的 std::weak_ptr </li></ul><hr><p><code>std::make_shared</code>是 C++11 的一部分，但<code>std::make_unique</code>到了 C++14 才被加入标准库，不过要写出一个基础版本的<code>std::make_unique</code>非常容易：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于直接使用<code>new</code>运算符，make 函数有以下优势：</p><ul><li>消除重复代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;      <span class="comment">// 使用 make 函数</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// 不使用 make 函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;      <span class="comment">// 使用 make 函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// 不使用 make 函数</span></span><br></pre></td></tr></table></figure><ul><li>改进了异常安全性：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>());  <span class="comment">// 有潜在的内存泄漏风险</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), <span class="built_in">computePriority</span>());           <span class="comment">// 不具有潜在的内存泄漏风险</span></span><br></pre></td></tr></table></figure><p>在直接使用<code>new</code>运算符的情况下，由于分配<code>Widget</code>对象、执行<code>std::shared_ptr</code>构造函数、执行<code>computePriority</code>函数三者并不存在固定顺序，<code>computePriority</code>函数可能会晚于<code>Widget</code>对象的分配，先于<code>std::shared_ptr</code>的构造函数执行，此时若<code>computePriority</code>产生异常，那么分配的<code>Widget</code>内存就会发生泄漏。使用<code>std::make_shared</code>则不会产生这个问题。</p><ul><li>使用<code>std::make_shared</code>和<code>std::allocate_shared</code>有助于生成的尺寸更小、速度更快的目标代码。</li></ul><blockquote><p><code>std::make_shared</code>会将指向的对象和与其相关联的控制块分配在单块内存中，这种优化减少了程序的静态尺寸，并且因为只进行一次内存分配，还可以加块代码的运行速度。使用<code>std::make_shared</code>还可以减少对控制块一些簿记信息（bookkeeping information）的需要，潜在地减少了程序的内存占用量（memory footprint）。<code>std::allocate_shared</code>也是同理。</p></blockquote><p>虽然有着如此多的优势，但还是有一些情形下，不能或者不应该使用 make 函数：</p><ul><li>使用 make 函数无法自定义删除器，以及直接传递大括号内的初始值设定项：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想要自定义删除器，就只能使用 new 运算符</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(widgetDeleter)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt;                          <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能间接传递初始化列表给 make 函数</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure><ul><li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。因此，使用 make 函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象，通常并不是个好主意。</li><li>当处于特别关注内存的系统中时，若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数：这会导致对象的析构和内存的释放之间产生延迟，而若直接使用<code>new</code>运算符，内存的释放就不必等待<code>std::weak_ptr</code>的析构。</li></ul><p>如果你发现自己处于不应该使用<code>std::make_shared</code>的情形下，又不想受到之前所述异常安全问题的影响。最好的方法是确保在直接使用<code>new</code>时，立即将结果传递给智能指针的构造函数，并且在这条语句中不做其它任何事：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">move</span>(spw), <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure><h3 id="条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h3><p>Pimpl 惯用法的第一部分，是声明一个指针类型的数据成员，指向一个非完整类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    Impl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二部分是动态分配和回收持有原始类中数据成员的对象，而分配和回收的代码被放在实现文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;                   <span class="comment">// Widget::Impl 的实现</span></span><br><span class="line">    std::string name;                   <span class="comment">// 包含在原始 Widget 类中的数据成员</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(<span class="keyword">new</span> Impl) &#123;&#125;   <span class="comment">// 为 Widget 对象分配数据成员所需内存</span></span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123; <span class="keyword">delete</span> pImpl; &#125;     <span class="comment">// 为 Widget 对象析构数据成员</span></span><br></pre></td></tr></table></figure><p>上面展示的是 C++98 的写法，使用了裸指针、裸<code>new</code>运算符和裸<code>delete</code>运算符。而到了 C++11，使用<code>std::unique_ptr</code>替代指向<code>Impl</code>的裸指针成为了首选：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;   <span class="comment">// 同前</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>遗憾的是，这段代码本身能通过编译，但在创建对象时却会报错。因为编译器自动生成的析构函数默认是<code>inline</code>的，而<code>std::unique_ptr</code>的默认删除器要求其指向完整类型，所以即使默认特殊函数的实现有着正确行为，我们仍必须将其声明和实现分离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123;&#125;    <span class="comment">// 写成 Widget::~Widget() = default; 效果相同</span></span><br></pre></td></tr></table></figure><p>在<strong>条款 17</strong> 中我们提到，声明析构函数会阻止编译器生成移动操作，所以假如你需要支持移动操作，也必须采用声明和实现分离的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><p>编译器不会为带有<code>std::unique_ptr</code>这种只移类型的类生成拷贝操作，假如你需要支持拷贝操作，则需要自行编写执行深拷贝的函数实现，并且同样需要遵守前面所说的规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明代码位于头文件 widget.h 内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现代码位于实现文件 widget.cpp 内</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;(*rhs.pImpl)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    *pImpl = *rhs.pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述建议仅仅适用于<code>std::unique_ptr</code>，而不适用于<code>std::shared_ptr</code>。对于<code>std::shared_ptr</code>而言，删除器类型并非智能指针类型的一部分，这就会导致更大的运行时数据结构以及更慢的目标代码，但在使用编译器生成的特殊函数时，并不要求其指向完整类型。以下代码并不会产生问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ...         <span class="comment">// 不再需要析构函数或移动操作的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::shared_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就 Pimpl 惯用法而言，并不需要在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间作出权衡，因为<code>Widget</code>和<code>Impl</code>之间的关系是专属所有权，所以在此处<code>std::unique_ptr</code>就是完成任务的合适工具。</p><h2 id="第五章：右值引用、移动语义和完美转发"><a href="#第五章：右值引用、移动语义和完美转发" class="headerlink" title="第五章：右值引用、移动语义和完美转发"></a>第五章：右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，需要铭记一点：形参总是左值，即使其类型是右值引用。例如给定函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; w)</span></span>;</span><br></pre></td></tr></table></figure><p>尽管形参<code>w</code>的类型是指向<code>Widget</code>对象的右值引用，可以传入绑定到右值的实参，但它仍然是个左值。</p><h3 id="条款-23：理解-std-move-和-std-forward"><a href="#条款-23：理解-std-move-和-std-forward" class="headerlink" title="条款 23：理解 std::move 和 std::forward"></a>条款 23：理解 std::move 和 std::forward</h3><hr><p>重点：</p><p><strong>std::move 和 std::forward 仅仅是执行类型转换的函数（实际上是函数模板）</strong></p><p>std::move 无条件地将其参数转换为右值，而 std::forward 只有在满足特定条件时才执行此转换。</p><p>右值只是移动的候选者。</p><blockquote><p> 来看个case:</p></blockquote><p>结论：如果希望进行移动操作，不要声明对象为const。对常量对象的移动请求会默默地转换为拷贝操作。</p><p>string构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="built_in">string</span>&amp; rhs);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);       <span class="comment">// 移动构造函数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    explicit <span class="title function_">Annotation</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span>:<span class="title function_">value</span><span class="params">(<span class="built_in">std</span>::move(text))</span><span class="comment">//并不像看上去这样！</span></span><br><span class="line">    &#123;... &#125;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>text 是一个左值 const std::string，转换的结果是一个右值 const std::string，但始终保持常量性</strong>。</p><p>结果就是，text 没有被移动到 value 中，而是被拷贝了。</p><p><strong>简单来说</strong>：一个右值引用，编译器先找有没有匹配的fun(A &amp;&amp;)，如果没有，则找fun(const A&amp;a)</p><blockquote><p><strong>std::move 和 std::forward</strong> </p></blockquote><p>既然 std::move 和 std::forward 都归结为转换，唯一的区别是 std::move 总是进行转换，而 std::forward 只是有时进行转换</p><p><strong>要点</strong></p><ul><li>std::move执行无条件转换为右值。就其本身而言，它不会移动任何东西 </li><li>只有当参数绑定到右值时，std::forward 才会将其参数转换为右值</li><li>std::move 和 std::forward 在运行时都不会做任何事情</li></ul><hr><p><code>std::move</code>执行的是向右值的无条件强制类型转换，就其自身而言，它不会移动任何东西。它的基本实现大致是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::move</code>并不改变常量性，也不保证经过其强制类型转换后的对象可被移动，针对常量对象执行的移动操作可能会悄无声息地转化为拷贝操作，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span></span></span><br><span class="line"><span class="function">        : value(std::move(text)) &#123;</span> ... &#125;    <span class="comment">// 想要将 text “移动入” value</span></span><br><span class="line">    ...                                     <span class="comment">// 但实际上执行了 std::string 的拷贝构造函数</span></span><br><span class="line">                                            <span class="comment">// 而非移动构造函数 string(string&amp;&amp;)</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量。</p><p>与<code>std::move</code>不同，<code>std::forward</code>是有条件的。仅当传入的实参被绑定到右值时，<code>std::forward</code>才会针对该实参执行向右值的强制类型转换，它同样不会转发任何东西。</p><p><code>std::forward</code>的一个典型应用场景，是某个函数模板使用万能引用作为形参，随后将其传递给另一个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;    <span class="comment">// 处理左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;         <span class="comment">// 处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;         <span class="comment">// 使用万能引用作为实参</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若在调用<code>logAndProcess</code>时传入左值，那么该左值自然会传递给处理左值版本的<code>process</code>函数；若在调用<code>logAndProcess</code>时传入右值，由于函数形参皆为左值，必须要通过<code>std::forward</code>将<code>param</code>强制转换为右值类型，才能得以正确调用处理右值版本的<code>process</code>函数。<code>std::forward</code>会通过模板类型<code>T</code>来判断是否该对<code>param</code>进行强制类型转换，具体的原理细节参考<strong>条款 28</strong>。</p><p>尽管<code>std::move</code>和<code>std::forward</code>归根结底都是强制类型转换，但两者的行为具有本质上的不同：前者用于为移动操作进行铺垫，而后者仅仅用于转发一个对象到另一个函数，在此过程中该对象仍保持原来的左值性或右值性。</p><blockquote><p>需要注意的是，在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p></blockquote><h3 id="条款-24：区分万能引用和右值引用"><a href="#条款-24：区分万能引用和右值引用" class="headerlink" title="条款 24：区分万能引用和右值引用"></a>条款 24：区分万能引用和右值引用</h3><hr><p><strong>通用引用2个条件：</strong></p><p>1：T&amp;&amp; / auto &amp;&amp;</p><p>2.存在类型推导</p><p><strong>右值引用</strong>，不是通用引用就是右值引用。</p><hr><p>如果函数模板形参的类型为<code>T&amp;&amp;</code>，并且 T 的类型需要推导得到，或一个对象使用<code>auto&amp;&amp;</code>声明其类型，则此处的<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>表示<strong>万能引用（universal reference）</strong>；如果类型声明不是标准的<code>type&amp;&amp;</code>形式，或者并未发生类型推导，则此处的<code>type&amp;&amp;</code>表示右值引用。</p><p>符合万能引用的情形如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> timeFuncInvocation = [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params) &#123;   <span class="comment">// C++14</span></span><br><span class="line">    std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(                         <span class="comment">// 调用 func</span></span><br><span class="line">        std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...               <span class="comment">// 取用 params</span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类型声明不是标准<code>type&amp;&amp;</code>的情形如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// param 是右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;        <span class="comment">// param 是右值引用</span></span><br></pre></td></tr></table></figure><p>类型是<code>T&amp;&amp;</code>，但并未发生类型推导的情形如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);  <span class="comment">// x 是右值引用</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若使用右值来初始化万能引用，就会得到一个右值引用；同理，若使用左值来初始化万能引用，就会得到一个左值引用。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">// param 是万能引用</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="built_in">f</span>(w);               <span class="comment">// 左值被传递给 f，param 的类型为 Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(w));    <span class="comment">// 右值被传递给 f，param 的类型为 Widget&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward"><a href="#条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward" class="headerlink" title="条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward"></a>条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward</h3><hr><p>右值引用 std::move，万能引用 std::forward。</p><blockquote><p><strong>ex1</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="comment">// 按值返回</span></span><br><span class="line">operator+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::move(lhs); <span class="comment">// 将 lhs 移动到返回值中</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过在返回语句中（通过 std::move）将 lhs 强制转换为右值，lhs 将被移动到函数的返回值位置</p><p>如果省略了对 std::move 的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix </span><br><span class="line">operator+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> lhs; <span class="comment">// 将 lhs 拷贝到返回值</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事实上，lhs是一个左值，这会迫使编译器将它拷贝到返回值的位置</p><blockquote><p> <strong>ex2</strong></p></blockquote><p>RVO 只能在返回的是局部对象的情况下执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::move(w);<span class="comment">//返回的不是局部对象 w，而是 w 的引用</span></span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li>对于右值引用使用 std::move，对于通用引用使用 std::forward，且都在最后一次使用时进行</li><li>对于按值返回的函数，返回的右值引用和通用引用，也执行相同的操作</li><li>如果局部对象本来可以进行返回值优化，就不要对它们应用 std::move 或 std::forward</li></ul><hr><p>右值引用一定会被绑定到右值，因此当转发右值引用给其他函数时，应当通过<code>std::move</code>对其实施向右值的无条件强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)),</span><br><span class="line">          <span class="built_in">p</span>(std::<span class="built_in">move</span>(rhs.p)) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而万能引用不一定会被绑定到右值，因此当转发万能引用时，应当通过<code>std::forward</code>对其实施向右值的有条件强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然针对右值引用实施<code>std::forward</code>也能硬弄出正确行为，但代码啰嗦、易错，且不符合习惯用法；而针对万能引用实施<code>std::move</code>会造成更加严重的后果，这会导致某些左值遭受意外的改动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;    <span class="comment">// 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>();</span><br><span class="line">w.<span class="built_in">setName</span>(n);               <span class="comment">// 将 n 移入 w</span></span><br><span class="line">...                         <span class="comment">// n 的值变为未知</span></span><br></pre></td></tr></table></figure><p>一种手法是将万能引用的版本改成对左值和右值分别进行重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种手法虽然看似可以解决问题，但是拥有更大的缺点：第一，需要编写和维护更多源码；第二，效率会大打折扣（产生额外的临时对象）；第三，可扩展性太差。因此，正确地使用万能引用才是问题的唯一解决之道。</p><p>在有些情况下，你可能想在函数内将某个对象不止一次地绑定到右值引用或万能引用，并且想保证在完成对该对象地其它所有操作之前，其值不会发生移动，那么就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; text)</span> </span>&#123;</span><br><span class="line">    sign.<span class="built_in">setText</span>(text);                         <span class="comment">// 使用 text，但不修改其值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    signHistory.<span class="built_in">add</span>(now, std::forward&lt;T&gt;(now)); <span class="comment">// 有条件地将 text 强制转换为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在极少数的情况下，你需要用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。</p><blockquote><p><code>std::move_if_noexcept</code>是<code>std::move</code>的一个变体，它是否会将对象强制转换为右值，取决于其类型的移动构造函数是否带有 noexcept 声明。</p></blockquote><p>在按值返回的函数中，如果返回的是绑定到右值引用或万能引用的对象，则当你返回该引用时，应当对其实施<code>std::move</code>或<code>std::forward</code>，这样可以避免编译器将其视作左值，从而消除拷贝左值进入返回值存储位置的额外开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值返回右值引用形参</span></span><br><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(lhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值返回万能引用形参</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduceAndCopy</span><span class="params">(T&amp;&amp; frac)</span> </span>&#123;</span><br><span class="line">    frac.<span class="built_in">reduce</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;T&gt;(frac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是若局部对象可能适用于<strong>返回值优化（return value optimization，RVO）</strong>，则请勿对其实施<code>std::move</code>或<code>std::forward</code>。这是因为当 RVO 的前提条件得到满足时，要么发生<strong>拷贝省略（copy elision）</strong>，要么<code>std::move</code>会隐式地被实施于返回的局部对象上；而人为地添加<code>std::move</code>或<code>std::forward</code>，会导致编译器失去执行 RVO 的能力。</p><p>下面的<code>makeWidget</code>函数满足 RVO 的两个前提条件：局部对象类型和函数返回值类型相同，且返回的就是局部对象本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于函数形参不适合实施拷贝省略，所以编译器必须处理以上代码，使其与以下代码等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-26：避免对万能引用类型进行重载"><a href="#条款-26：避免对万能引用类型进行重载" class="headerlink" title="条款 26：避免对万能引用类型进行重载"></a>条款 26：避免对万能引用类型进行重载</h3><hr><p>重点：</p><p><strong>接受通用引用的函数是 C++ 中最贪婪的函数。</strong>它们实例化以创建几乎任何类型的参数的精确匹配，结合重载和通用引用几乎总是一个坏主意。</p><p><strong>要点</strong></p><ul><li>对通用引用进行重载，几乎总是导致它的过度使用</li><li>完美转发构造函数尤其成问题，因为对于非const 左值，它们通常比拷贝构造函数更匹配，并且它们可以劫持</li><li>派生类对基类拷贝和移动构造函数的调用</li></ul><hr><p>形参为万能引用的函数是 C++ 中最贪婪的，它们会在具现过程中和几乎所有实参类型产生精确匹配（极少的不适用实参将在<strong>条款 30</strong> 中介绍），这就是为何把重载和万能引用两者结合通常不会达到预期效果。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> nameIdx;      <span class="comment">// 用 short 类型持有索引值</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(nameIdx); <span class="comment">// 调用的却是万能引用版本</span></span><br></pre></td></tr></table></figure><p><code>logAndAdd</code>有两个重载版本，形参类型为万能引用的版本可以将<code>T</code>推导为<code>short</code>，从而产生精确匹配；而形参类型为<code>int</code>的版本却只能在类型提升后才可以匹配到<code>short</code>类型的实参。因此，形参类型为万能引用的版本才是被优先调用的版本。</p><p>当完美转发出现在类的构造函数中时，情况会变得更加复杂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">// 完美转发构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span></span></span><br><span class="line"><span class="function">        : name(std::forward&lt;T&gt;(n)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span></span>;   <span class="comment">// 形参为 int 的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);  <span class="comment">// 拷贝构造函数（由编译器生成）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; rhs);       <span class="comment">// 移动构造函数（由编译器生成）</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于非常量的左值类型，完美转发构造函数一般都会优先于拷贝构造函数形成匹配；而对于常量左值类型，完美转发构造函数和拷贝构造函数具有相等的匹配程度，此时由于非函数模板会优先于函数模板被匹配，编译器才会转向调用拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;           <span class="comment">// 调用完美转发构造函数，无法通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Person <span class="title">cp</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;   <span class="comment">// 对象成为了常量</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfCp</span><span class="params">(cp)</span></span>;         <span class="comment">// 会正确调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>完美转发构造函数还会劫持派生类中对基类的拷贝和移动构造函数的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        : <span class="built_in">Person</span>(rhs) &#123;&#125;                    <span class="comment">// 调用的是基类的完美转发构造函数！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs)      <span class="comment">// 移动构造函数</span></span><br><span class="line">        : <span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs)) &#123;&#125;         <span class="comment">// 调用的是基类的完美转发构造函数！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-27：熟悉对万能引用类型进行重载的替代方案"><a href="#条款-27：熟悉对万能引用类型进行重载的替代方案" class="headerlink" title="条款 27：熟悉对万能引用类型进行重载的替代方案"></a>条款 27：熟悉对万能引用类型进行重载的替代方案</h3><p><strong>1. 放弃重载</strong></p><p><strong>2. 传递<code>const T&amp;</code>类型的形参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法可以避免重载万能引用带来的不良影响，但会舍弃一些性能。</p><p><strong>3. 传值</strong></p><p>把传递的形参从引用类型换成值类型，是一种经常能够提升性能，却不会增加任何复杂性的方法，尽管这有些反直觉。这种设计遵循了<strong>条款 41</strong> 的建议——当你知道肯定需要复制形参时，考虑按值传递对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string n)</span>  <span class="comment">// 替换掉 T&amp;&amp; 类型的构造函数</span></span></span><br><span class="line"><span class="function">        : name(std::move(n)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span>        <span class="comment">// 同前</span></span></span><br><span class="line"><span class="function">        : name(nameFromIdx(idx)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4. 使用标签分派（tag dispatch）</strong></p><p>在这个方案中，我们将实际重载和实现功能的函数改为<code>logAndAddImpl</code>，而<code>logAndAdd</code>仅仅用于执行完美转发和标签分派：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name),</span><br><span class="line">        std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;());    <span class="comment">// C++14 可以使用 std::remove_reference_t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对<code>std::is_integral</code>产生的布尔值，我们可以写出两个<code>logAndAddImpl</code>重载版本，用于区分它们的类型<code>std::false_type</code>和<code>std::true_type</code>就是所谓 “标签”。具体实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span> </span>&#123; <span class="comment">// 非整型实参</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span> </span>&#123;   <span class="comment">// 整型实参</span></span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 对接受万能引用的模板施加限制</strong></p><p>通过 SFINAE 技术和<code>std::enable_if</code>，我们可以让一些模板在满足了指定条件的情况下才被启用，它的使用方式大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">             <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;condition&gt;::type&gt;    <span class="comment">// C++14 可以使用 std::enable_if_t</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处我们想要<code>T</code>是<code>Person</code>以外的类型时，才启用该模板构造函数，则我们可以写下面这样的条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!std::is_same&lt;Person, <span class="keyword">typename</span> std::decay&lt;T&gt;::type&gt;::value  <span class="comment">// C++17 可以使用 std::is_same_v</span></span><br></pre></td></tr></table></figure><p><code>std::decay</code>用于使类型完全退化，在此处用来移除<code>T</code>的引用和 cv 限定符（即<code>const</code>或<code>volatile</code>限定符），使我们可以更加纯粹地关注类型本身。<code>std::decay</code>还可以用于把数组和函数类型强制转换为指针类型（参考<strong>条款 1</strong>），它当然也拥有更易用的 C++14 版本，即<code>std::decay_t</code>。</p><p>写出这个条件并不意味着完成，<strong>条款 26</strong> 中还提到了在派生类中调用基类的拷贝和移动构造函数时，错误调用完美转发构造函数的问题。因此，我们想要的是为<code>Person</code>和继承自<code>Person</code>的类型都不一样的实参类型启用模板构造函数。标准库中的<code>std::is_base_of</code>用于判断一个类型是否由另一个类型派生而来，用它代替<code>std::is_same</code>就可以得到我们想要的东西（C++17 可以使用<code>std::is_base_of_v</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                       !std::is_base_of&lt;Person, </span><br><span class="line">                                        <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                                       &gt;::value</span><br><span class="line">                   &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再加上处理整型实参的构造函数重载版本，并进一步限制模板构造函数，禁止其接受整型实参，我们得到的完美的<code>Person</code>类代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">            !std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n)              <span class="comment">// 接受 std::string 类型以及可以强制转换为 </span></span><br><span class="line">    : <span class="built_in">name</span>(std::forward&lt;T&gt;(n)) &#123; ... &#125;  <span class="comment">// std::string 类型的实参的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(<span class="type">int</span> idx)            <span class="comment">// 接受整型实参的构造函数</span></span><br><span class="line">    : <span class="built_in">name</span>(<span class="built_in">nameFromIdx</span>(idx)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    ...                                 <span class="comment">// 拷贝和移动构造函数等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>权衡</strong></p><p>本条款讨论的前三种方案（舍弃重载，传递<code>const T&amp;</code>类型的形参和传值）都需要对待调用的函数形参逐一指定类型，而后两种方案（使用标签分派和对接受万能引用的模板施加限制）则使用了完美转发，因此无需指定形参类型。</p><p>按照常理，完美转发的效率更高，因为它将类型保持和形参声明时完全一致，所以会避免创建临时对象。但完美转发也有一些不足：首先是针对某些类型无法实现完美转发（参考<strong>条款 30</strong>），其次是完美转发会使得在传递非法形参时，出现更难理解的错误信息。</p><p><code>std::is_constructible</code>这个类型特征（type trait）可以在编译期判断某个类型的对象是否可以用另一类型的对象（或不同类型的多个对象）来构造，我们可以用它来验证转发函数的万能引用形参是否合法。下面是增加了<code>static_assert</code>后的<code>Person</code>类，它可以产生更明确的报错信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;...&gt;&gt;  <span class="comment">// 同前</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n)</span><br><span class="line">        : <span class="built_in">name</span>(std::forward&lt;T&gt;(n)) &#123;</span><br><span class="line">        <span class="comment">// 断言可以用 T 类型的对象构造 std::string</span></span><br><span class="line">        <span class="built_in">static_assert</span>(</span><br><span class="line">            std::is_constructible&lt;std::string, T&gt;::value,   <span class="comment">// C++17 可以使用 std::is_constructible_v</span></span><br><span class="line">            <span class="string">&quot;Parameter n can&#x27;t be used to construct a std::string&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 构造函数通常要完成的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-28：理解引用折叠"><a href="#条款-28：理解引用折叠" class="headerlink" title="条款 28：理解引用折叠"></a>条款 28：理解引用折叠</h3><hr><p>根据以下规则将引用折叠为单个引用：</p><ul><li>如果两个都是右值引用，结果是一个右值引用（右值-右值）</li><li>否则结果为左值引用（左值-左值、左值-右值、右值-左值）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget <span class="title function_">widgetFactory</span><span class="params">()</span>; <span class="comment">// 返回右值的函数</span></span><br><span class="line">Widget w; <span class="comment">// 变量（左值）</span></span><br><span class="line">func(w); <span class="comment">// 用左值调用 func; T 推导为 Widget&amp;</span></span><br><span class="line">func(widgetFactory()); <span class="comment">// 用右值调用 func; T 推导为 Widget</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用折叠是 std::forward 工作的关键</p><p><strong>std::forward原理</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 在命名空间std</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li>引用折叠发生在四个上下文中：模板实例化、auto类型生成、typedef别名声明的创建和使用以及decltype</li><li>当编译器在引用折叠上下文中生成对引用的引用时，结果变成单个引用。如果原始引用中的任何一个是左值引用，则结果是左值引用。否则，它是右值引用</li><li>通用引用是在类型推导区分左值和右值以及发生引用折叠的上下文中的右值引用</li></ul><hr><p>在<strong>条款 24</strong> 中我们了解了万能引用和右值引用的区别，但实际上万能引用并非一种新的引用类型，其实它就是在满足下面两个条件的语境中的右值引用：</p><ol><li>类型推导的过程中会区分左值和右值；</li><li>会发生<strong>引用折叠（reference collapsing）</strong>。</li></ol><p>C++ 标准禁止直接声明 “引用的引用” ，但引用折叠不受此限制。当左值被传递给接受万能引用的函数模板时，会发生下面这样的状况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(w);    <span class="comment">// 调用 func 并传入左值，T 推导出的类型为 Widget&amp;</span></span><br></pre></td></tr></table></figure><p>代入<code>T</code>的推导类型，我们可以得到下面这样的具现化模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; &amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>出现了引用的引用！然而这并不违规，引用折叠的规则会把双重引用折叠成单个引用，规则如下：</p><blockquote><p>如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用。</p></blockquote><p>所以实际上的函数签名为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>引用折叠是使<code>std::forward</code>得以运作的关键，也是将左值或右值信息编码到万能引用形参<code>T</code>中的实现途径。<code>std::forward</code>的任务是，当且仅当编码在<code>T</code>中的信息表明传递的实参是右值，即<code>T</code>推导出的类型是个非引用类型时，对左值形参实施到右值的强制类型转换。它的基本实现大致是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设传递给函数<code>forward</code>的实参类型是左值<code>Widget</code>，则模板的具现化结果可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&amp;&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发生引用折叠后，生成的最终结果如下，可以看出左值类型并不会发生改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设传递给函数<code>forward</code>的实参类型是右值<code>Widget</code>，则模板的具现化结果可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发生引用折叠后，生成的最终结果如下，显然左值类型的形参会被强制转换为右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用折叠会在四种语境中出现：模板具现化，<code>auto</code>类型推断，创建和使用<code>typedef</code>和别名声明，以及<code>decltype</code>。</p><p><code>auto</code>类型推断中发生的引用折叠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;                       <span class="comment">// 变量（左值）</span></span><br><span class="line"><span class="function">Widget <span class="title">widgetFunction</span><span class="params">()</span></span>;        <span class="comment">// 返回右值的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;                  <span class="comment">// 推导出 Widget&amp; &amp;&amp; w1，引用折叠后为 Widget&amp; w1</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">widgetFunction</span>();   <span class="comment">// 推导出 Widget&amp;&amp; w1，不会发生引用折叠</span></span><br></pre></td></tr></table></figure><p>创建和使用<code>typedef</code>中发生的引用折叠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&lt;<span class="type">int</span>&amp;&gt; w; <span class="comment">// 用左值引用类型来具现化 Widget 模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具现化后得到 typedef int&amp; &amp;&amp; RvalueRefToT</span></span><br><span class="line"><span class="comment">// 引用折叠后为 typedef int&amp; RvalueRefToT</span></span><br></pre></td></tr></table></figure><p>最后一种会发生引用折叠的语境在<code>decltype</code>的运用中：如果在分析一个涉及<code>decltype</code>的类型时出现了引用的引用，则引用折叠会介入并将其消灭。</p><h3 id="条款-29：假定移动操作不存在、成本高、未被使用"><a href="#条款-29：假定移动操作不存在、成本高、未被使用" class="headerlink" title="条款 29：假定移动操作不存在、成本高、未被使用"></a>条款 29：假定移动操作不存在、成本高、未被使用</h3><p>在下面几个情形下，C++11 的移动语义不会给你带来什么好处：</p><ul><li><strong>没有移动操作：</strong> 待移动的对象未能提供移动操作。因此，移动请求就变成了拷贝请求。</li><li><strong>移动未能更快：</strong> 待移动的对象虽然有移动操作，但并不比其拷贝操作更快。</li></ul><blockquote><p>移动操作不比拷贝操作更快的例子：<code>std::array</code>将数据直接存储在对象内，移动<code>std::array</code>需要逐个移动容器内的每个元素；开启了<strong>短字符串优化（small string optimization，SSO）</strong> 的<code>std::string</code>，它会将字符串存储在<code>std::string</code>对象的某个缓冲区内，而非使用堆上的内存。</p></blockquote><ul><li><strong>移动不可用：</strong> 移动本可以发生的情况下，要求移动操作不会抛出异常，但该操作未加上<code>noexcept</code>声明。</li><li><strong>源对象是左值：</strong> 只有右值可以作为移动操作的源。</li></ul><p>因此，我们应该为通用的代码假定移动操作不存在、成本高且未被使用。然而，对于已知的类型或支持移动语义的代码中，就不需要作上述假定，在你知道移动操作成本低廉的情况下，可以放心大胆地将拷贝操作替换为相对不那么昂贵的移动操作。</p><h3 id="条款-30：熟悉完美转发的失败情形"><a href="#条款-30：熟悉完美转发的失败情形" class="headerlink" title="条款 30：熟悉完美转发的失败情形"></a>条款 30：熟悉完美转发的失败情形</h3><p>完美转发的含义是我们不仅转发对象，还转发其特征：类型，是左值还是右值，以及是否带有<code>const</code>和<code>volatile</code>限定符。出于此目的，我们会运用万能引用来将左、右值信息编码到类型中，而用于转发的函数自然也该是泛型的，它的标准形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使转发函数能接受任意数量的形参，使用可变参数模板也在我们的考虑范围内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;Ts&gt;(param)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若用相同实参调用<code>f</code>和<code>fwd</code>会执行不同的操作，则称<code>fwd</code>将实参完美转发到<code>f</code>失败。完美转发的失败情形源于模板类型推导失败，或推导出错误的类型。下面我们将了解会造成完美转发失败的典型例子。</p><p><strong>大括号初始值设定项（Braced initializers）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);         <span class="comment">// “&#123; 1, 2, 3 &#125;” 会隐式转换为 std::vector&lt;int&gt;</span></span><br><span class="line"><span class="built_in">fwd</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);       <span class="comment">// 无法通过编译！</span></span><br></pre></td></tr></table></figure><p>由于<code>fwd</code>的形参为被声明为<code>std::initializer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>&#123; 1, 2, 3 &#125;</code>出发来推导类型。既然无法推导出形参的类型，那么编译器也只能拒绝对<code>fwd</code>的调用。</p><p>我们可以通过先用<code>auto</code>声明一个局部变量，再传递给<code>fwd</code>来避免这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// il 的类型被推导为 std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">fwd</span>(il);                <span class="comment">// 没问题，将 il 完美转发给 f</span></span><br></pre></td></tr></table></figure><p><strong>0 和 NULL 作空指针</strong></p><p><strong>条款 8</strong> 中曾经说明过，当你试图将<code>0</code>或<code>NULL</code>作为空指针传递给模板时，类型推导就会发生错误，将实参推导为一个整型而非指针类型，结果不管是<code>0</code>还是<code>NULL</code>都不会作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或<code>NULL</code>。</p><p><strong>仅有声明的整型<code>static const</code>成员变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;  <span class="comment">// 仅提供 MinVals 的声明</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;                                          <span class="comment">// 未给出 MinVals 的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Widget::MinVals);                         <span class="comment">// 没问题，当作 “f(28)” 处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals);                       <span class="comment">// 可能无法通过链接</span></span><br></pre></td></tr></table></figure><p>一般而言，编译器会绕过<code>MinVals</code>缺少定义的事实，并用其值替换所有涉及到<code>MinVals</code>的地方，但并不会为其实际分配存储空间。这就导致如果我们尝试对<code>MinVals</code>实施取地址或对它进行引用，就会导致链接无法通过，这也就是为何不能将<code>Widget::MinVals</code>作为实参传递给<code>fwd</code>。</p><p>按照标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义。然而并不是所有实现都遵循了这个规定，对于一些编译器和链接器，你会发现将<code>MinVals</code>用于完美转发并不会产生错误，甚至对它取地址也不会。但为了代码的可移植性，还是应当重视此处所讲的规则，为<code>static const</code>成员变量提供定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::<span class="type">size_t</span> Widget::MinVals;  <span class="comment">// 在 Widget 的 .cpp 文件中</span></span><br></pre></td></tr></table></figure><p><strong>重载函数的名称和模板名称</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">// 或者 void f(int pf(int))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(processVal);          <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(processVal);        <span class="comment">// 错误！无法确定是哪个重载版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">workOnVal</span><span class="params">(T param)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(workOnVal);         <span class="comment">// 错误！无法确定是 workOnVal 的哪个实例</span></span><br></pre></td></tr></table></figure><p>当我们将<code>processVal</code>传递给<code>f</code>时，由于<code>f</code>的形参类型是已知的，编译器自然也知道它需要的是<code>processVal</code>的哪个重载版本；但纯粹的函数名称<code>processVal</code>并不包含类型信息，类型推导更是无从谈起，将它传递给<code>fwd</code>只会造成完美转发失败而已。</p><p>要让<code>fwd</code>接受重载函数的名称或模板名称，只能手动指定需要转发的哪个重载版本或模板实例。例如下面的做法就是合理的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ProcessFuncType = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line">ProcessFuncType processValPtr = processVal;     <span class="comment">// 指定了需要的 processVal 签名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(processValPtr);                             <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(<span class="built_in">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));   <span class="comment">// 也没问题</span></span><br></pre></td></tr></table></figure><p><strong>位域</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPv4Header</span> &#123;                 <span class="comment">// 用于表示 IPv4 头部的模型</span></span><br><span class="line">    std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">                  IHL:<span class="number">4</span>,</span><br><span class="line">                  DSCP:<span class="number">6</span>,</span><br><span class="line">                  ECN:<span class="number">2</span>,</span><br><span class="line">                  totalLength:<span class="number">16</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line">IPv4Header h;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength);                   <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength);                 <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure><p>C++ 标准规定：非常引用不得绑定到位域。位域是由机器字的若干任意部分组成的，但这样的实体是无法对其直接取地址的，无法将指针指向它，因此也无法对其进行引用。</p><blockquote><p>实际上常引用也不可能绑定到位域，它们绑定到的是 “常规” 对象（某种标准整型，例如<code>int</code>），其中拷贝了位域的值。</p></blockquote><p>将位域传递给转发函数的可能途径是制作一个副本，并以该副本调用转发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝位域值，使用的初始化形式参考条款 6</span></span><br><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(length);    <span class="comment">// 转发该副本</span></span><br></pre></td></tr></table></figure><h2 id="第六章：lambda-表达式"><a href="#第六章：lambda-表达式" class="headerlink" title="第六章：lambda 表达式"></a>第六章：lambda 表达式</h2><hr><p>重点</p><p><strong>闭包：</strong>能够访问其他·函数内部变量的函数</p><p><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数【operator()】中的可执行指令。</p><p>闭包可以拷贝</p><hr><p>在开始本章之前，需要理解几个基本的概念：</p><ul><li><strong>lambda 表达式（lambda expression）：</strong> 表达式的一种，它的基本写法如下所示：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> val)&#123; <span class="keyword">return</span> <span class="number">0</span> &lt; val &amp;&amp; val &lt; <span class="number">10</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>闭包（closure）：</strong> lambda 所创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。</li><li><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数中的可执行指令。</li></ul><blockquote><p><strong>lambda 表达式和闭包类存在于编译期，而闭包存在于运行期。</strong></p></blockquote><h3 id="条款-31：避免默认捕获模式"><a href="#条款-31：避免默认捕获模式" class="headerlink" title="条款 31：避免默认捕获模式"></a>条款 31：避免默认捕获模式</h3><hr><p>按引用：可能导致空悬指针</p><p>按值：捕获指针也会导致相同的情况</p><p>静态对象，可以在lamdba表达式中使用，不能捕获。</p><p>捕获只能针对在创建 lambda 表达式的作用域内可见的非静态局部变量（包括形参）。</p><p><strong>要点</strong></p><ul><li>默认的按引用捕获可能导致悬空引用</li><li>默认的按值捕获也可能出现悬空指针（尤其是this指针的情况），并且它会产生误导，让人以为 lambda 是独立的</li></ul><hr><p><strong>C++11 中有两种默认捕获模式：按引用或按值。按引用捕获会导致闭包内包含指向局部变量的引用，或指向定义 lambda 的作用域内形参的引用，一旦由 lambda 所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会发生空悬：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;                                <span class="comment">// 元素为筛选函数的容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [&amp;](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; <span class="comment">// 危险！指向 divisor 的引用可能空悬</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换作用显式方式按引用捕获<code>divisor</code>，问题依旧会发生，但更容易看出 lambda 依赖于<code>divisor</code>的生命周期这一问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">    [&amp;divisor](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一种权宜之计是不使用容器来存放筛选函数，转而使用 C++11 的<code>std::all_of</code>对每个元素逐一进行判断。但如果将该 lambda 拷贝到其它闭包比<code>divisor</code>生命周期更长的语境中，则空悬引用的问题仍会发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithContainer</span><span class="params">(<span class="type">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ContElemT = <span class="keyword">typename</span> C::value_type;           <span class="comment">// 取得容器中的元素类型（参考条款 13）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> std::begin;</span><br><span class="line">    <span class="keyword">using</span> std::end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),   <span class="comment">// 判断是否所有元素都是 divisor 的倍数</span></span><br><span class="line">        [&amp;](<span class="type">const</span> ContElemT&amp; value)                     <span class="comment">// C++14 可以直接写成 const auto&amp; value</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，使用默认的按值捕获模式就足以解决问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">    [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但是默认的按值捕获模式也有其问题：默认的按值捕获极易受到空悬指针的影响（尤其是<code>this</code>指针），并且会误导人们认为 lambda 是独立的。考虑如下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> divisor;    <span class="comment">// 用于 Widget 的 filters</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此处的 lambda 而言，<code>divisor</code>既不是局部变量，也不是形参，按理来讲是压根无法被捕获的。事实也确实如此，被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是<code>divisor</code>。对于编译器来说，<code>addFilter</code>的代码相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> currentObjectPtr = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [currentObjectPtr](<span class="type">int</span> value)</span><br><span class="line">        &#123; <span class="keyword">return</span> value % currentObjectPtr-&gt;divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了这一点，也就能理解 lambda 闭包的存活依赖于它含有的<code>this</code>指针副本所指向的<code>Widget</code>对象的生命周期。假如面临以下代码，空悬指针的问题将出现在我们的眼前：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;                    <span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();   <span class="comment">// 创建 Widget，std::make_unique 的使用参考条款 21</span></span><br><span class="line"></span><br><span class="line">    pw-&gt;<span class="built_in">addFilter</span>();                        <span class="comment">// 添加使用了 Widget::divisor 的筛选函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;                                           <span class="comment">// Widget 被销毁，filters 现在持有空悬指针！</span></span><br></pre></td></tr></table></figure><p>一种解决方法是将你想捕获的成员变量拷贝至局部变量中，之后再捕获该副本局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [divisorCopy](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++14 中，捕获成员变量的一种更好的方法是使用<strong>广义 lambda 捕获（generalized lambda capture，参考条款 32）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [divisor = divisor](<span class="type">int</span> value)  <span class="comment">// C++14: 将 divisor 拷贝入闭包并使用副本</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的按值捕获模式的另一个缺点是，它会使人们误认为闭包是独立的，与闭包外的数据变化相隔绝。但实际上并非如此，lambda 可能不仅依赖于局部变量和形参，还会依赖于<strong>静态存储期（static storage duration）对象</strong>，这样的对象可以在 lambda 中使用，但却无法被捕获。下面这个例子足以体现这一点会造成的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value)                      <span class="comment">// 未捕获任何东西！</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;    <span class="comment">// 引用上面的 static 对象</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ++divisor;                              <span class="comment">// 意外修改了 divisor</span></span><br><span class="line">                                            <span class="comment">// 导致每个 lambda 都出现新的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-32：使用初始化捕获将对象移入闭包"><a href="#条款-32：使用初始化捕获将对象移入闭包" class="headerlink" title="条款 32：使用初始化捕获将对象移入闭包"></a>条款 32：使用初始化捕获将对象移入闭包</h3><hr><p>要点</p><ul><li>可以使用 C++14 的初始化捕获将对象移动到闭包中</li><li>在 C++11 中，可以通过自定义类或 std::bind 来模拟初始化捕获。</li></ul><hr><p>C++14 中新增的<strong>初始化捕获（init capture，又称广义 lambda 捕获）</strong>，可以让你指定：</p><ol><li>由 lambda 生成的闭包类中成员变量的名字。</li><li>一个用于初始化该成员变量的表达式。</li></ol><p>下面演示了如何使用初始化捕获将<code>std::unique_ptr</code>移入闭包内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidated</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isProcessed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isArchived</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();   <span class="comment">// 创建 Widget，std::make_unique 的使用参考条款 21</span></span><br><span class="line"></span><br><span class="line">...                                     <span class="comment">// 配置 *pw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">move</span>(pw)]        <span class="comment">// 使用 std::move(pw) 初始化闭包类的数据成员</span></span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;;</span><br></pre></td></tr></table></figure><p>如果经由<code>std::make_unique</code>创建的对象已具备被 lambda 捕获的合适状态，则闭包类成原对象可以直接由<code>std::make_unique</code>完成初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]</span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;;</span><br></pre></td></tr></table></figure><p>在初始化捕获的代码中，位于<code>=</code>左侧的是所指定的闭包类成员变量的名称，右侧的则是其初始化表达式。值得一提的是，<code>=</code>的左右两侧位于不同的作用域，左侧作用域就是闭包的作用域，而右侧作用域则与 lambda 定义所在的作用域相同。</p><p>在 C++11 中，我们虽然无法使用初始化捕获，但是可以依靠原理相同的手写类达到目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsValAndArch</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::unique_ptr&lt;Widget&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IsValAndArch</span><span class="params">(DataType&amp;&amp; ptr)</span>   <span class="comment">// std::move 的使用参考条款 25</span></span></span><br><span class="line"><span class="function">        : pw(std::move(ptr)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;               <span class="comment">// 编写仿函数</span></span><br><span class="line">        <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType pw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">IsValAndArch</span>(std::<span class="built_in">make_unique</span>&lt;Widget&gt;());</span><br></pre></td></tr></table></figure><p>如果你非要使用 lambda，按移动捕获也可以通过以下方法模拟：</p><ol><li>将需要捕获的对象移至<code>std::bind</code>所产生的函数对象中。</li><li>给予 lambda 一个指向想要 “捕获” 的对象的引用。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func =</span><br><span class="line">    std::<span class="built_in">bind</span>([](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data)   <span class="comment">// C++11 模拟初始化捕获</span></span><br><span class="line">              &#123; <span class="comment">/* 使用 data */</span> &#125;,</span><br><span class="line">              std::<span class="built_in">move</span>(data));</span><br></pre></td></tr></table></figure><p><code>std::bind</code>的第一个实参是个可调用对象，接下来的所有实参表示传给该对象的值。和 lambda 表达式类似，<code>std::bind</code>也会生成函数对象（原书中称其为<strong>绑定对象，bind object</strong>），其中含有传递给<code>std::bind</code>的所有实参的副本，其中左值实参执行的是拷贝构造，而右值实参执行的则是移动构造。因此，在此处用<code>std::move(data)</code>作为实参可以让<code>data</code>被移入绑定对象中，被 lambda 的左值引用形参所接受。</p><p>默认情况下，lambda 生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>限定符，它会导致是闭包类里的所有成员变量在 lambda 的函数体内都会带有<code>const</code>限定符。但是，绑定对象里通过移动构造得到的<code>data</code>副本却并不带有<code>const</code>限定符。因此，为了防止该<code>data</code>副本在 lambda 中被意外修改，我们会将其形参声明为常引用。但如果 lambda 在声明时带有<code>mutable</code>限定符，则闭包里的<code>operator()</code>就不再会带有<code>const</code>限定符，也不必再将形参声明为常引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func =</span><br><span class="line">    std::<span class="built_in">bind</span>([](std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="keyword">mutable</span></span><br><span class="line">              &#123; <span class="comment">/* 使用 data */</span> &#125;,</span><br><span class="line">              std::<span class="built_in">move</span>(data));</span><br></pre></td></tr></table></figure><p>回到之前的例子，使用 C++14 在闭包内创建<code>std::unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]</span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;;</span><br></pre></td></tr></table></figure><p>它在 C++11 中的模拟代码可以这样编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>([](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; pw)</span><br><span class="line">                      &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); &#125;,</span><br><span class="line">                      std::<span class="built_in">make_unique</span>&lt;Widget&gt;());</span><br></pre></td></tr></table></figure><h3 id="条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward"><a href="#条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward" class="headerlink" title="条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward"></a>条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</h3><hr><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">auto</span> f =[](auto&amp;&amp; param)&#123;returnfunc(normalize(std::forward&lt;decl<span class="keyword">type</span>(param)&gt;(param)));&#125;;</span><br></pre></td></tr></table></figure><p><strong>要点</strong><br>对 auto&amp;&amp; 参数使用 decltype 来进行 std::forward</p><hr><p>C++14 支持<strong>泛型 lambda（generic lambda）</strong>，可以在声明形参时使用<code>auto</code>，即闭包类中的<code>operator()</code>可以用模板实现。例如，给定以下 lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x)); &#125;;</span><br></pre></td></tr></table></figure><p>则闭包类的<code>operator()</code>实现大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCompilerGeneratedClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="type">const</span> </span>&#123;    <span class="comment">// auto 类型的返回值，参考条款 3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此处，lambda 总会传递左值给<code>normalize</code>，这对于一个会区别对待左、右值的<code>normalize</code>显然是不行的。如果想要保留实参的左、右值性，就需要将形参声明为万能引用（参考<strong>条款 24</strong>），并使用<code>std::forward</code>将其转发给<code>normalize</code>（参考<strong>条款 25</strong>）。这样的改造十分简单，唯一的问题是在 lambda 中，我们并没有可用的模板形参<code>T</code>，只能对要转发的形参使用<code>decltype</code>，以取得其类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; param) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>条款 28</strong> 说明了，使用<code>std::forward</code>的惯例是：用左值引用类型的模板形参来表明想要返回左值，用非引用类型的模板形参来表明想要返回右值。而在此处，如果<code>param</code>是左值，则<code>decltype(param)</code>会产生左值引用类型，这符合惯例；但如果<code>param</code>是右值，则<code>decltype(param)</code>会产生右值引用类型，不符合惯例的非引用，在这种情况下，<code>std::forward</code>将被具现化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&amp;&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于引用折叠的存在，<code>Widget&amp;&amp; &amp;&amp;</code>将被折叠为<code>Widget&amp;&amp;</code>，所以实际上生成的代码和使用非引用类型作为模板形参生成的版本并没有什么区别。综上所述，在此处使用<code>decltype(param)</code>并不会产生任何问题，这是个非常不错的结果。</p><p>C++14 的 lambda 也支持可变参数，只需稍加改动，就可以得到能接受多个参数的完美转发 lambda 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-34：优先选用-lambda，而非-std-bind"><a href="#条款-34：优先选用-lambda，而非-std-bind" class="headerlink" title="条款 34：优先选用 lambda，而非 std::bind"></a>条款 34：优先选用 lambda，而非 std::bind</h3><p>之所以优先选用 lambda 而非 std::bind，最主要的原因是 lambda 具有更高的可读性。举个例子，假设我们有个函数用来设置警报声：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示时刻的类型</span></span><br><span class="line"><span class="keyword">using</span> Time = std::chrono::steady_clock::time_point;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Sound</span> &#123; Beep, Siren, Whistle &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示时长的类型</span></span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::steady_clock::duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在时刻 t，发出声音 s，持续时长 d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以编写一个 lambda，设置在一小时后发出警报并持续 30 秒，同时提供接口，以指定发出的声音：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;              <span class="comment">// 引入 C++14 中的字面量后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, s, <span class="number">30</span>s); <span class="comment">// C++11 需要用 hours 和 seconds 代替后缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们将尝试使用<code>std::bind</code>来编写相应的代码。下面的这段代码并不正确，但足以让我们发现<code>std::bind</code>的难用之处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;  <span class="comment">// 引入占位符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>占位符<code>_1</code>表示它在<code>std::bind</code>形参列表中的映射位置，在此处表示调用<code>setSoundB</code>时传入的第一个实参，会作为第二个实参传递给<code>setAlarm</code>。这显然已经不如 lambda 直观。</p><p>更重要的是上述代码所隐含的问题：调用时间的错误。在<code>std::bind</code>的调用中，<code>steady_clock::now() + 1h</code>作为实参被传递给了<code>std::bind</code>，而非<code>setAlarm</code>，这意味着该表达式会在调用<code>std::bind</code>的时刻计算出具体值，而非调用<code>setAlarm</code>的时刻，这与我们的意图显然不符。想要解决这个问题，就要嵌套第二层<code>std::bind</code>的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), <span class="comment">// C++11 无法省略 std::plus&lt;steady_clock::time_point&gt;()</span></span><br><span class="line">                                     steady_clock::<span class="built_in">now</span>(),</span><br><span class="line">                                     <span class="number">1</span>h),</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>另一个<code>std::bind</code>不如 lambda 的例子是重载。假如有个重载版本会接受第四个形参，用于指定警报的音量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Volume</span> &#123; Normal, Loud, LoudPlusPlus &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d, Volume v)</span></span>;</span><br></pre></td></tr></table></figure><p>原来的 lambda 仍会正常运作，而<code>std::bind</code>会立刻发生错误，因为它只有函数名，并不知道要调用哪个重载版本的函数。为使得<code>std::bind</code>的调用能通过编译，必须将<code>setAlarm</code>强制转换到适当的函数指针类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SetAlarm3ParamType = <span class="built_in">void</span> (*)(Time t, Sound s, Duration d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(<span class="built_in">static_cast</span>&lt;SetAlarm3ParamType&gt;(setAlarm),</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>下面是一个更极端的例子，演示了<code>std::bind</code>到底有多晦涩：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 版本（C++14）</span></span><br><span class="line"><span class="keyword">auto</span> betweenL = [lowVal, highVal](<span class="type">const</span> <span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">    <span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::bind 版本（C++14）</span></span><br><span class="line"><span class="keyword">auto</span> betweenB = std::<span class="built_in">bind</span>(std::logical_and&lt;&gt;(),</span><br><span class="line">                          std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), lowVal, std::placeholders::_1),</span><br><span class="line">                          std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), std::placeholders::_1, highVal),)</span><br></pre></td></tr></table></figure><p><code>std::bind</code>总是拷贝其实参，调用时需要借助<code>std::ref</code>来达到按引用存储实参的目的，这一点同样也不如 lambda 来得明确：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compressRateL = [&amp;w](CompLevel lev) &#123; <span class="keyword">return</span> <span class="built_in">compress</span>(w, lev); &#125;;</span><br><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, std::<span class="built_in">ref</span>(w), std::placeholders::_1);</span><br></pre></td></tr></table></figure><p>除了可读性以外，编译器通常能更好地以内联优化 lambda 所调用的函数，而对于使用函数指针的<code>std::bind</code>则很难做到，这会导致使用 lambda 有可能会生成比使用<code>std::bind</code>运行得更快的代码。</p><p>在 C++11 中，<code>std::bind</code>仅在两个受限的场合还有使用的理由：</p><ol><li>移动捕获（参考<strong>条款 32</strong>）；</li><li>多态函数对象（这在 C++14 中可以被泛型 lambda 轻易实现）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PolyWidget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PolyWidget pw;</span><br><span class="line"><span class="keyword">auto</span> boundPW = std::<span class="built_in">bind</span>(pw, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用不同类型的实参调用 PolyWidget::operator()</span></span><br><span class="line"><span class="built_in">boundPW</span>(<span class="number">1930</span>);</span><br><span class="line"><span class="built_in">boundPW</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">boundPW</span>(<span class="string">&quot;Rosebud&quot;</span>); <span class="comment">// 原书作者玩的《公民凯恩》梗（应该是吧）</span></span><br></pre></td></tr></table></figure><h2 id="第七章：并发-API"><a href="#第七章：并发-API" class="headerlink" title="第七章：并发 API"></a>第七章：并发 API</h2><h3 id="条款-35：优先选用基于任务而非基于线程的程序设计"><a href="#条款-35：优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款 35：优先选用基于任务而非基于线程的程序设计"></a>条款 35：优先选用基于任务而非基于线程的程序设计</h3><p>如果你想以异步方式执行函数<code>doAsyncWork</code>，你可以选择<strong>基于线程（thread-based）</strong> 的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;</span><br></pre></td></tr></table></figure><p>也可以将<code>doAsyncWork</code>传递给<code>std::async</code>，这是<strong>基于任务（task-based）</strong> 的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork); <span class="comment">// 需要 #include &lt;future&gt;</span></span><br></pre></td></tr></table></figure><p>“线程” 在带有并发的 C++ 软件中有三重含义：</p><ul><li><strong>硬件线程（hardware threads）</strong> 是实际执行计算的线程。现代计算机架构会为每个 CPU 内核提供一个或多个硬件线程。</li><li><strong>软件线程（software threads，也称系统线程）</strong> 是操作系统（或嵌入式系统）用于实现跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程比硬件线程要多，因为当一个软件线程被阻塞时，运行其它未阻塞线程能够提高吞吐率。</li><li><strong><code>std::thread</code></strong> 是 C++ 进程中的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表现为 “null” 句柄，表示其无软件线程，可能的原因有：处于默认构造状态（没有要执行的函数），被移动了（被移动的目标对象成为了该软件线程的句柄），被联结（join）了（函数已执行结束），被分离（detach）了（与其软件线程的连接被切断）。</li></ul><p>软件线程和硬件线程都是有限的。如果你试图创建多于系统能提供的数量的线程，就会抛出<code>std::system_error</code>异常，即使待执行的函数带有<code>noexcept</code>限定符也一样。如果非阻塞的软件线程数量超过了硬件线程数量，就会产生<strong>资源超额（oversubscription）</strong> 问题，此时线程调度器会将软件线程的 CPU 时间切片，分配到硬件线程之上。当一个软件线程的时间片执行结束，就会让给另一个软件线程，并产生上下文切换。在这种情况下，新的软件线程几乎不能命中 CPU 缓存，同时还会污染为旧线程所准备的数据（旧线程很可能还会再被调度到同一内核上运行），这会造成高昂的线程管理开销。</p><blockquote><p>避免资源超额很困难，因为软件线程和硬件线程的最佳比例取决于软件线程的执行频率，那是动态改变的，例如一个程序从 IO 密集型变成计算密集型，会使执行频率发生改变。而且该比例还依赖于上下文切换的开销以及软件线程对于 CPU 缓存的使用效率。计算机本身的架构也会对其具体细节产生很大的影响。</p></blockquote><p>比起基于线程，基于任务的设计能够减轻手动管理线程的艰难，而且它提供了一种很自然的方式（藉由<code>get</code>函数），让你检查异步执行函数的结果（即返回值或异常）。</p><p>虽然说了这么多，但仍有以下几种情况，直接使用线程会更合适：</p><ul><li><strong>你需要访问非常底层的线程 API。</strong> C++ 并发 API 通常会采用特定平台的低级 API 来实现，例如 pthread 和 Windows 线程库，它们提高的 API 比 C++ 更丰富。为了访问底层的线程 API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::async</code>的返回值<code>std::future</code>则没有该功能。</li><li><strong>你需要且有能力为你的应用优化线程的使用。</strong> 例如在完成性能分析的情况下为专一硬件平台开发应用。</li><li><strong>你需要实现实现超越 C++ 并发 API 的线程技术。</strong> 例如为 C++ 未提供线程池的平台实现线程池。</li></ul><h3 id="条款-36：如果异步是必要的，则指定-std-launch-async"><a href="#条款-36：如果异步是必要的，则指定-std-launch-async" class="headerlink" title="条款 36：如果异步是必要的，则指定 std::launch::async"></a>条款 36：如果异步是必要的，则指定 std::launch::async</h3><p>在调用<code>std::async</code>时，有以下两种启动策略可以选择：</p><ul><li><code>std::launch::async</code>启动策略意味着函数必须以异步方式在另一条线程上执行。</li><li><code>std::launch::deferred</code>启动策略意味着函数会被推迟到<code>std::async</code>所返回的<code>std::future</code>的<code>get</code>或<code>wait</code>函数得到调用时才执行（这是个简化说法，关键点其实是<code>std::future</code>引用的共享状态，参考<strong>条款 38</strong>）。在那之后，调用<code>get</code>或<code>wait</code>的线程将会被阻塞，直至函数执行结束为止。如果<code>get</code>或<code>wait</code>都没得到调用，则函数将不会被执行。</li></ul><p><code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行，即下面两个调用是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut2 = std::<span class="built_in">async</span>(std::launch::async | std::launch::deferred,</span><br><span class="line">                       f);</span><br></pre></td></tr></table></figure><p>这种弹性使得<code>std::async</code>和标准库的线程管理组件能够承担起线程的创建和销毁，避免资源超额，以及负载均衡的责任。但也会带来一些意料之外的问题：</p><ul><li>无法预知<code>f</code>是否会与调用<code>std::async</code>的线程并发执行，它也可能会被推迟执行。</li><li>无法预知<code>f</code>是否会在与调用<code>get</code>和<code>wait</code>函数的线程不同的线程上执行。</li><li>无法预知<code>f</code>在读或写此<strong>线程本地存储（thread-local，TLS）</strong> 时，会在哪个线程的本地存储上完成操作，这会影响到<code>thread_local</code>变量的使用。</li><li>就连<code>f</code>是否会被执行这种基本的事情都无法预知。</li></ul><p>延迟启动策略还会影响以超时为条件的基于 wait 的循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready) &#123;  <span class="comment">// 循环至 f 完成执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 若 f 被推迟执行，则 fut.wait_for 返回 std::future_status::deferred</span></span><br><span class="line">    <span class="comment">// 循环永远不会被终止！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这个问题的方法很简单，只需要确认任务是否被推迟，可以通过调用一个基于超时的函数（例如<code>wait_for</code>）并检查其返回值来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fut.<span class="built_in">wait_for</span>(<span class="number">0</span>s) == std::future_status::deferred) &#123; <span class="comment">// 如果任务被推迟了</span></span><br><span class="line">    ... <span class="comment">// 调用 fut 的 wait 或 get，以同步方式执行 f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                                  <span class="comment">// 如果任务未被推迟</span></span><br><span class="line">    <span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready) &#123;</span><br><span class="line">        ... <span class="comment">// 不断去做并发任务，直至 f 完成执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// fut 已经就绪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，如果需要执行的任务满足以下条件，就可以使用<code>std::async</code>的默认启动策略：</p><ol><li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li><li>读或写哪个线程的<code>thread_local</code>变量并无影响。</li><li>保证在<code>std::async</code>返回的<code>std::future</code>对象上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li><li>使用<code>wait_for</code>或<code>wait_until</code>的代码会考虑到任务被推迟的可能性。</li></ol><p>如果其中任何一个条件不满足，就需要确保任务以异步方式执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, f);</span><br></pre></td></tr></table></figure><p>也可以编写一个辅助函数来自动执行<code>std::async</code>的异步启动策略：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span> std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Ts...)&gt;::type&gt; <span class="comment">// C++14 可以直接用 auto 推导返回值类型</span></span><br><span class="line"><span class="built_in">reallyAsync</span>(F&amp;&amp; f, Ts&amp;&amp;... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                      std::forward&lt;F&gt;(f),</span><br><span class="line">                      std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用于获取可调用对象返回值类型的<code>std::result_of</code>在 C++17 后被弃用，其替代品为<code>std::invoke_result</code>。</p></blockquote><h3 id="条款-37：使-std-thread-对象在所有路径皆不可联结"><a href="#条款-37：使-std-thread-对象在所有路径皆不可联结" class="headerlink" title="条款 37：使 std::thread 对象在所有路径皆不可联结"></a>条款 37：使 std::thread 对象在所有路径皆不可联结</h3><p>当<code>std::thread</code>处于可联结的状态时，它对应于正在运行或可能将要运行的底层执行线程，这包括正在等待调度的或者被阻塞的线程，以及运行结束的线程。</p><p>以下几种<code>std::thread</code>对象处于不可联结的状态：</p><ul><li>默认构造的<code>std::thread</code>。</li><li>已移动的<code>std::thread</code>。</li><li>已联结（join）的<code>std::thread</code>。</li><li>已分离（detach）的<code>std::thread</code>。</li></ul><p>当<code>std::thread</code>执行析构时，若其处于可联结状态，就会导致程序终止运行（通常会调用<code>std::abort</code>）。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10&#x27;000&#x27;000</span>;             <span class="comment">// C++14 的单引号数字分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter, <span class="type">int</span> maxVal = tenMillion)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;filter, maxVal, &amp;goodVals] &#123;    <span class="comment">// 遍历 goodVals</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">                      &#123; <span class="keyword">if</span> (filter(i)) goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">native_handle</span>();                    <span class="comment">// 使用 t 的原生句柄来设定线程的优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">conditionAreSatisfied</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();                                   <span class="comment">// 让 t 结束运行</span></span><br><span class="line">        <span class="built_in">performComputation</span>(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                                <span class="comment">// 计算已实施</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                                   <span class="comment">// 计算未实施</span></span><br><span class="line">&#125;                                                   <span class="comment">// 此处析构 std::thread 会导致程序终止</span></span><br></pre></td></tr></table></figure><p>标准委员会并没有选择让<code>std::thread</code>在销毁时，隐式执行<code>join</code>或<code>detach</code>，因为这带来的问题会比直接让程序终止运行还要严重：</p><ul><li><strong>隐式<code>join</code></strong> 会使<code>std::thread</code>的析构函数等待底层异步线程执行完毕。这听上去很合理，但却可能导致难以追踪的性能异常。例如，即使<code>conditionAreSatisfied</code>已经返回<code>false</code>了，<code>doWork</code>仍然会继续执行遍历操作，这是违反直觉的。</li><li><strong>隐式<code>detach</code></strong> 会使<code>std::thread</code>的析构函数分离<code>std::thread</code>对象和底层执行线程之间的连接，而该底层执行线程会继续运行。这会导致更要命的调试问题。假如<code>conditionAreSatisfied</code>返回了<code>false</code>，则<code>doWork</code>也会直接返回，同时销毁局部变量并弹出栈帧。但线程仍然在<code>doWork</code>的调用点继续运行，并导致栈帧上的内存被意外修改，</li></ul><p>我们可以编写一个 RAII 类，并让调用者自行选择在销毁时为<code>std::thread</code>调用<code>join</code>还是<code>detach</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">DtorAction</span> &#123; join, detach &#125;;     <span class="comment">// 关于枚举类，参考条款 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a)   <span class="comment">// 对 t 执行操作 a</span></span><br><span class="line">        : <span class="built_in">action</span>(action), <span class="built_in">t</span>(std::<span class="built_in">move</span>(t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>() &#123;</span><br><span class="line">        <span class="comment">// 先校验 t 是否处于可联结状态</span></span><br><span class="line">        <span class="comment">// 对不可联结的 std::thread 调用 join 或 detach 是未定义行为</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">                t.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;         <span class="comment">// 支持移动操作</span></span><br><span class="line">    ThreadRAII&amp; <span class="keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;            <span class="comment">// 返回底层的 std::thread 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DtorAction action;</span><br><span class="line">    std::thread t;                              <span class="comment">// 使 t 最后被初始化，确保它可以安全访问其它成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>不需要担心在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，有另一个线程会让<code>t</code>变得不可联结。因为<code>std::thread</code>对象只能通过调用成员函数来从可联结状态转换为不可联结状态，而当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其它线程调用该对象的成员函数。一般地，若要在一个对象上同时调用两个成员函数，只有当所有这些函数都带有<code>const</code>限定符时才安全（参考<strong>条款 16</strong>）。</p></blockquote><p>在<code>doWork</code>函数的代码中，可以这样使用<code>ThreadRAII</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter, <span class="type">int</span> maxVal = tenMillion)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t</span><span class="params">(std::thread([&amp;filter, maxVal, &amp;goodVals] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">                                 &#123; <span class="keyword">if</span> (filter(i)) goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                             &#125;),</span></span></span><br><span class="line"><span class="params"><span class="function">                 ThreadRAII::DtorAction::join)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">get</span>().<span class="built_in">native_handle</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">conditionAreSatisfied</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">get</span>().<span class="built_in">join</span>();</span><br><span class="line">        <span class="built_in">performComputation</span>(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-38：注意不同线程句柄的析构行为"><a href="#条款-38：注意不同线程句柄的析构行为" class="headerlink" title="条款 38：注意不同线程句柄的析构行为"></a>条款 38：注意不同线程句柄的析构行为</h3><p>future 位于通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常以异步方式运行）将其计算所得的结果写入信道（通常经过<code>std::promise</code>对象），而调用者则使用 future 来读取该结果。</p><p>但被调用者的结果要存储在哪里呢？既不能存储在被调用者的<code>std::promise</code>对象中，因为它是个局部对象，在被调用者执行结束后会被销毁；也不能存储在调用者的 future 中，因为<code>std::future</code>可能会被用来创建<code>std::shared_future</code>，而后者会导致原始<code>std::future</code>析构之后被多次拷贝，但被调用者的结果并不能保证一定可以被拷贝，很难做到使它与最后一个指向它的 future 生命周期一样长。</p><p>因此该结果会被存储在位于两者外部的某个位置，这个位置称为<strong>共享状态（shared state）</strong>，通常用堆上的对象来表示，但是其类型、接口和实现皆未在标准中指定。我们可以把调用者，被调用者以及共享状态之间的关系用下图来表示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/2.png" alt=""></p><p>共享状态的存在非常重要，因为 future 对象的析构行为取决于与其关联的共享状态。具体来说就是：</p><ul><li>常规的 future 对象在析构时仅会析构该 future 的成员变量。这相当于对底层执行线程执行了隐式<code>detach</code>。</li><li>引用了共享状态（使用<code>std::async</code>启动未延迟任务时创建的）的最后一个 future 对象的析构函数将会被阻塞住，直至该任务结束。这相当于对正在运行<code>std::async</code>所创建任务的线程执行了隐式<code>join</code>。</li></ul><p>也就是说，只有在满足下列条件时，future 的非常规析构行为才会被触发：</p><ol><li>future 所引用的共享状态是在调用<code>std::async</code>时创建的；</li><li>该任务执行异步启动策略，即<code>std::launch::async</code>（参考<strong>条款 36</strong>）；</li><li>该 future 是最后一个引用了该共享状态的 future。</li></ol><p>future 的 API 没有提供任何办法判断它引用的共享状态是否诞生于<code>std::async</code>的调用，因此任意给定一个 future 对象，我们没有办法判断它是否会在析构函数中阻塞。这可能会导致一些意外的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该容器的析构函数可能会发生阻塞</span></span><br><span class="line"><span class="comment">// 因为它持有 future 可能会有一个或多个</span></span><br><span class="line"><span class="comment">// 满足触发非常规析构行为的条件</span></span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futs;    <span class="comment">// 关于 std::future&lt;void&gt;，参考条款 39</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                          <span class="comment">// Widget 对象的析构函数可能会发生阻塞</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_future&lt;<span class="type">double</span>&gt; fut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>std::packaged_task</code>也能创建出共享对象，但是其衍生的 future 都会执行常规的析构行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in">int</span>()&gt;       <span class="comment">// 给 calcValue 加上包装</span></span><br><span class="line">    <span class="built_in">pt</span>(calcValue);                  <span class="comment">// 使之能以异步方式执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>();     <span class="comment">// 取得 pt 的 future</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>;   <span class="comment">// std::packaged_task 是只移类型</span></span><br><span class="line"></span><br><span class="line">    ...                             <span class="comment">// 析构 std::thread（参考条款 37）</span></span><br><span class="line">&#125;                                   <span class="comment">// 以常规方式析构 future 对象 fut</span></span><br></pre></td></tr></table></figure><h3 id="条款-39：考虑对一次性事件通信使用-void-的-futures"><a href="#条款-39：考虑对一次性事件通信使用-void-的-futures" class="headerlink" title="条款 39：考虑对一次性事件通信使用 void 的 futures"></a>条款 39：考虑对一次性事件通信使用 void 的 futures</h3><p>有的时候，让一个任务能够在发生了特定事件后，通知另一个异步运行的任务，会是很有用的。为了实现这种简单的事件通信，使用条件变量会是一个显而易见的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;             <span class="comment">// 事件的条件变量</span></span><br><span class="line">std::mutex m;                           <span class="comment">// 配合 cv 使用的互斥量</span></span><br><span class="line"></span><br><span class="line">...                                     <span class="comment">// 检测事件</span></span><br><span class="line">cv.<span class="built_in">notify_one</span>();                        <span class="comment">// 通知反应任务，对多个任务使用 notify_all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                                     <span class="comment">// 准备作出反应</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// 为互斥量加锁</span></span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk);                        <span class="comment">// 等待通知到来</span></span><br><span class="line">    ...                                 <span class="comment">// 针对事件作出反应</span></span><br><span class="line">&#125;                                       <span class="comment">// 通过 lk 的析构函数为 m 解锁</span></span><br><span class="line">...                                     <span class="comment">// 继续等待反应</span></span><br></pre></td></tr></table></figure><p>这种途径会导致以下几个问题：</p><ul><li><strong>代码异味（code smell）：</strong> 虽然代码能够运行，但总感觉哪里不太对劲。此处对互斥量的使用似乎有些多余，互斥量是用于控制共享数据访问的，但检测和反应任务之间大可以根本不需要这种介质。</li><li>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量，则反应任务将会失去响应。</li><li>反应任务的<code>wait</code>语句无法应对<strong>虚假唤醒（spurious wakeups）</strong>，即使条件变量没有得到通知，针对该条件变量等待的代码也有可能被唤醒。如果反应线程可以确认它所等待的事件是否已经发生，那么我们可以通过将 lambda 传递给<code>wait</code>来处理这种情况：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.<span class="built_in">wait</span>(lk, [] &#123; <span class="keyword">return</span> 事件是否真的已经发生; &#125;);</span><br></pre></td></tr></table></figure><p>基于 flag 的设计可以避免上述问题，但这一设计基于轮询而非阻塞，会对 CPU 核心产生额外的性能消耗：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">// 共享的 bool flag</span></span><br><span class="line">                                <span class="comment">// 关于 std::atomic，参考条款 40</span></span><br><span class="line">...                             <span class="comment">// 检测事件</span></span><br><span class="line">flag = <span class="literal">true</span>;                    <span class="comment">// 通知反应任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                             <span class="comment">// 准备作出反应</span></span><br><span class="line"><span class="keyword">while</span> (!flag);                  <span class="comment">// 等待事件</span></span><br><span class="line">...                             <span class="comment">// 针对事件作出反应</span></span><br></pre></td></tr></table></figure><p>条件变量可以和 flag 一起使用，但这样的通信机制设计看起来不太自然：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;                 <span class="comment">// 同前</span></span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;                           <span class="comment">// 非 std::atomic 对象</span></span><br><span class="line"></span><br><span class="line">...                                         <span class="comment">// 检测事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;       <span class="comment">// 为 m 加锁</span></span><br><span class="line">    flag = <span class="literal">true</span>;                            <span class="comment">// 通知反应任务（第一部分）</span></span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();                            <span class="comment">// 通知反应任务（第二部分）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                                         <span class="comment">// 准备作出反应</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;     <span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, [&amp;flag] &#123; <span class="keyword">return</span> flag; &#125;);  <span class="comment">// 使用 lambda 应对虚假唤醒</span></span><br><span class="line">    ...                                     <span class="comment">// 针对事件作出反应</span></span><br><span class="line">&#125;</span><br><span class="line">...                                         <span class="comment">// 继续等待反应</span></span><br></pre></td></tr></table></figure><p>另外一种方法是摆脱条件变量，互斥量和 flag，让反应任务去等待检测任务设置的 future。这种设计简单易行，检测任务有一个<code>std::promise</code>对象，反应任务有对应的 future。当检测任务发现它查找的事件已经发生时，它会设置<code>std::promise</code>对象；与此同时，反应任务调用<code>wait</code>以等待它的 future。由于在此处我们并不会真正向信道发送任何数据，所以对于<code>std::promise</code>、<code>std::future</code>和<code>std::shared_future</code>的模板类型形参，都只需使用<code>void</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line">...                     <span class="comment">// 检测事件</span></span><br><span class="line">p.<span class="built_in">set_value</span>();          <span class="comment">// 通知反应任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反应任务的代码</span></span><br><span class="line">...                     <span class="comment">// 准备作出反应</span></span><br><span class="line">p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();  <span class="comment">// 等待 p 对应的 future</span></span><br><span class="line">...                     <span class="comment">// 针对事件作出反应</span></span><br></pre></td></tr></table></figure><p>这种手法有两个最大的局限性：</p><ul><li><code>std::promise</code>和 future 之间依赖共享状态，而共享状态会带来在堆上分配和回收空间的成本。</li><li><code>std::promise</code>对象只能设置一次，这意味着该手法只能应用于一次性通信的情况。</li></ul><p>假如你想创建多个能暂停一次的线程，使用<code>void</code> future 手法就是合理的选择。代码演示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sf = p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();                   <span class="comment">// sf 的类型是 std::shared_future&lt;void&gt;</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; vt;                        <span class="comment">// 反应任务的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadsToRun; ++i) &#123;</span><br><span class="line">        vt.<span class="built_in">emplace_back</span>([sf] &#123; sf.<span class="built_in">wait</span>(); <span class="built_in">react</span>(); &#125;);  <span class="comment">// sf 局部副本之上的 wait</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...                                                 <span class="comment">// 若在此处抛出异常，则 detect 会失去响应！</span></span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">set_value</span>();                                      <span class="comment">// 让所有线程取消暂停</span></span><br><span class="line"></span><br><span class="line">    ...                                                 <span class="comment">// 完成其它工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;                                <span class="comment">// 把所有线程设为不可联结的状态</span></span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-40：对并发使用-std-atomic，对特殊内存使用-volatile"><a href="#条款-40：对并发使用-std-atomic，对特殊内存使用-volatile" class="headerlink" title="条款 40：对并发使用 std::atomic，对特殊内存使用 volatile"></a>条款 40：对并发使用 std::atomic，对特殊内存使用 volatile</h3><p><code>std::atomic</code>可以保证它提供的操作被其它线程视为具有原子性，它产生的效果和受到互斥锁保护的操作类似，但是通常<code>std::atomic</code>的原子操作是通过特定的机器指令实现的，这比锁的实现更高效。考虑以下应用了<code>std::atomic</code>的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 将 ai 初始化为 0</span></span><br><span class="line">ai = <span class="number">10</span>;                <span class="comment">// 原子地将 ai 设为 10</span></span><br><span class="line">std::cout &lt;&lt; ai;        <span class="comment">// 原子地读取 ai 地值</span></span><br><span class="line">++ai;                   <span class="comment">// 原子地将 ai 自增为 11</span></span><br><span class="line">--ai;                   <span class="comment">// 原子地将 ai 自减为 10</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在<code>std::cout &lt;&lt; ai</code>语句中，<code>std::atomic</code>仅能保证对于<code>ai</code>的读取操作具有原子性，而不能保证整条语句都具有原子性，在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>之间，可能会有别的线程修改了<code>ai</code>的值，但这对使用按值传参的<code>operator&lt;&lt;</code>并没有什么影响。</p><p><code>ai</code>的自增和自减操作是<strong>读取-修改-写入（read-modify-write，RWM）</strong> 操作，<code>std::atomic</code>能确保它们整体以原子方式执行。这是<code>std::atomic</code>最重要的特性之一：<code>std::atomic</code>对象之上的所有成员函数都能被其它线程视为原子性的。</p><p><code>std::atomic</code>在 RWM 上具有的优势与<code>volatile</code>相比十分明显：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ac</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// atomic counter</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">vc</span><span class="params">(<span class="number">0</span>)</span></span>;     <span class="comment">// volatile counter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在两个同时运行的线程中各自执行自增操作 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 1</span></span><br><span class="line">++ac;</span><br><span class="line">++vc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line">++ac;</span><br><span class="line">++vc;</span><br></pre></td></tr></table></figure><p>在两个执行结束后，<code>ac</code>的值一定为 2，而<code>vc</code>却不一定，数据竞争导致它的最终结果实际上是无法预测的，下面是一种可能的情况：</p><ol><li>线程 1 读取<code>vc</code>的值为 0；</li><li>线程 2 读取<code>vc</code>的值仍为 0；</li><li>线程 1 将读取的值 0 自增为 1，写入<code>vc</code>；</li><li>线程 2 也将读取的值 0 自增为 1，写入<code>vc</code>；</li><li><code>vc</code>最终的值为 1。</li></ol><p>除了 RWM 以外，<code>std::atomic</code>还在确保<strong>顺序一致性（sequential consistency）</strong> 上具有优势，这种一致性是它默认采用的（尽管 C++ 还支持其它的一致性模型，但它们的安全性无法得到保证），它规定：在源代码中，<strong>任何位于<code>std::atomic</code>变量的写入操作之前的代码不得发生于写入操作之后</strong>。使用<code>std::atomic</code>可以保证以下代码中的赋值语句不会进行重新排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();   <span class="comment">// 计算出值</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;                        <span class="comment">// 通知其它任务，值已可用</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>std::atomic</code>，语句的顺序可能会被编译器或底层硬件重新排列，以使得代码运行得更快：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新排序后的结果</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();</span><br></pre></td></tr></table></figure><p><code>std::atomic</code>是只移类型，因此以下代码无法通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line">y = x;</span><br></pre></td></tr></table></figure><p>正确的方式是调用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>来以原子方式读取和写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">y</span><span class="params">(x.load())</span></span>;</span><br><span class="line">y.<span class="built_in">store</span>(x.<span class="built_in">load</span>());</span><br></pre></td></tr></table></figure><p>尽管在很多时候<code>load</code>和<code>store</code>并不是必要的，但是有些开发者还是很喜欢使用它们，因为这样做可以在代码中明确强调所使用的变量并非常规。这在很大程度上是一个代码风格的问题。</p><p><code>volatile</code>是用来处理特殊内存的工具，它会被用在读写操作不应该被优化的内存上。一般来讲，编译器会为常规内存的冗余读取和写入自动执行优化，例如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 读取 x</span></span><br><span class="line">y = x;      <span class="comment">// 再次读取 x</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;     <span class="comment">// 写入 x</span></span><br><span class="line">x = <span class="number">20</span>;     <span class="comment">// 再次写入 x</span></span><br></pre></td></tr></table></figure><p>在经过优化后就能变成十分精简的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 读取 x</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;     <span class="comment">// 写入 x</span></span><br></pre></td></tr></table></figure><p>但对于特殊内存，我们可能不想要编译器去执行这种优化。例如用于内存映射 I/O 的内存，这种内存的位置实际上会被用于与外部设备通信，而非用于读取或写入常规内存。这时，<code>volatile</code>就能派上用场：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x; <span class="comment">// 以 volatile 声明 x</span></span><br><span class="line">...             <span class="comment">// 初始化 x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">// 读取 x</span></span><br><span class="line">y = x;          <span class="comment">// 再次读取 x（不会被优化掉）</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;         <span class="comment">// 写入 x（不会被优化掉）</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">// 再次写入 x</span></span><br></pre></td></tr></table></figure><p><code>std::atomic</code>和<code>volatile</code>用于不同的目的，它们甚至可以一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> std::atomic&lt;<span class="type">int</span>&gt; vai;  <span class="comment">// 针对 vai 的操作具有原子性</span></span><br><span class="line">                                <span class="comment">// 并且不会被优化掉</span></span><br></pre></td></tr></table></figure><h2 id="第八章：微调"><a href="#第八章：微调" class="headerlink" title="第八章：微调"></a>第八章：微调</h2><h3 id="条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"><a href="#条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递" class="headerlink" title="条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"></a>条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</h3><p>为了实现对传入函数的左值实参执行拷贝，对右值实参执行移动，我们一共有以下三种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">// 对左值和右值分别重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">// 使用万能引用</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">// 方法三：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">// 按值传递参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++98 中，按值传递的形参总会通过拷贝构造函数创建，但在 C++11 后，形参仅在传入左值时才会被拷贝构造，而如果传入的是个右值，它会被移动构造。</p><p>对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码。</p><p>对于不可拷贝的形参，由于它的拷贝构造函数已被禁用，我们也不需要为其左值类型的实参提供支持，只需要编写一个接受右值引用的版本就行了。考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和对应的 setter，而<code>std::unique_ptr</code>是个只移类型，所以我们只需要编写单个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPtr</span><span class="params">(std::unique_ptr&lt;std::string&gt;&amp;&amp; ptr)</span> </span>&#123;</span><br><span class="line">        p = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;std::string&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w.<span class="built_in">setPtr</span>(std::<span class="built_in">make_unique</span>&lt;std::string&gt;(<span class="string">&quot;Modern C++&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用按值传参的前提是形参移动的成本足够低廉，因为按值传参会比按引用传参多一次额外的移动操作，如果这个前提不成立，那么执行不必要的移动就与执行不必要的拷贝没有什么区别。另外，你应当只对一定会被拷贝的形参考虑使用按值传参，以下代码就是一个反例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newName.<span class="built_in">length</span>() &gt;= minLen) &amp;&amp;</span><br><span class="line">            (newName.<span class="built_in">length</span>() &lt;= maxLen)) &#123;</span><br><span class="line">            names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即使没有向<code>names</code>添加任何内容，该函数也会造成构造和析构<code>newName</code>的开销，而如果使用按引用传参，就可以避免这笔开销。</p><p>通过构造拷贝形参的开销可能会比通过赋值拷贝形参要大得多。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Password</span><span class="params">(std::string pwd)</span>  <span class="comment">// 按值传参</span></span></span><br><span class="line"><span class="function">        : text(std::move(pwd)) &#123;</span>&#125;       <span class="comment">// 对 text 进行构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string newPwd)</span> </span>&#123; <span class="comment">// 按值传参</span></span><br><span class="line">        text = std::<span class="built_in">move</span>(newPwd);       <span class="comment">// 对 text 进行赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;                   <span class="comment">// 表示密码</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">initPwd</span><span class="params">(<span class="string">&quot;Supercalifragilisticexpialidocious&quot;</span>)</span></span>;  <span class="comment">// 旧密码</span></span><br><span class="line"><span class="function">Password <span class="title">p</span><span class="params">(initPwd)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">std::string newPassword = <span class="string">&quot;Beware the Jabberwock&quot;</span>;          <span class="comment">// 新密码</span></span><br><span class="line">p.<span class="built_in">changeTo</span>(newPassword);</span><br></pre></td></tr></table></figure><p>在此处，旧密码比新密码更长，因此不需要进行任何内存分配和回收。如果采用重载的方式，可能就不会发生任何动态内存管理操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string&amp; newPwd)</span> </span>&#123;    <span class="comment">// 对左值的重载</span></span><br><span class="line">        text = newPwd;                      <span class="comment">// 若 text.capacity() &gt;= newPwd.size()</span></span><br><span class="line">                                            <span class="comment">// 则可以复用 text 的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此情形下，使用按值传参就会造成额外的内存分配和回收的开销，这可能会比移动<code>std::string</code>的开销高出几个数量级。</p><p>综上所述，通过赋值拷贝一个形参进行按值传参所造成的额外开销，取决于传参的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标所占的内存是否至少和赋值源所占的内存一样大。对于<code>std::string</code>来说，开销还取决于实现是否使用了 SSO（参考<strong>条款 29</strong>），如果是，那么要赋的值是否匹配 SSO 缓冲区。</p><p>最后要注意的一点是，按值传参肯定会导致<strong>对象切片（object slicing）</strong> 的问题，所以基类类型不适合用于按值传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;                           <span class="comment">//基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span> : <span class="keyword">public</span> Widget &#123; ... &#125;;    <span class="comment">//派生类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(Widget w)</span></span>;                   <span class="comment">// 针对任意类型的 Widget 的函数</span></span><br><span class="line">                                                <span class="comment">// 包括派生类型</span></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">SpecialWidget sw;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(sw);                              <span class="comment">// 发生对象切片，processWidget 只能看到 Widget</span></span><br><span class="line">                                                <span class="comment">// 而非 SpecialWidget</span></span><br></pre></td></tr></table></figure><h3 id="条款-42：考虑置入而非插入"><a href="#条款-42：考虑置入而非插入" class="headerlink" title="条款 42：考虑置入而非插入"></a>条款 42：考虑置入而非插入</h3><p>假如你想向 STL 容器中添加新元素，<strong>插入函数（insertion function）</strong> 通常是合乎逻辑的选择，但对于性能狂人而言，其背后所隐含的临时对象带来的开销是难以忍受的。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;    <span class="comment">// 持有 std::string 对象的容器</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);          <span class="comment">// 添加字符串字面量</span></span><br></pre></td></tr></table></figure><p>此处添加的字符串字面量和<code>std::string</code>类型并不匹配，因此需要先创建一个<code>std::string</code>类型的临时对象，然后再将其绑定到<code>push_back</code>函数的右值引用形参。换句话说，你可以把这句调用看作下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyzzy&quot;</span>));</span><br></pre></td></tr></table></figure><p>在这之后，<code>push_back</code>会在<code>std::vector</code>中构造出一个形参的副本，这个过程是通过调用移动构造函数来完成的（这已经是第二次调用构造函数了）。在<code>push_back</code>返回后，临时对象将立刻被销毁，这又调用了<code>std::string</code>的析构函数。</p><p>从原理上来说，<strong>置入函数（emplacement function）</strong> 在大部分时候应该比插入函数更高效，而且不会有更低效的可能性。<code>emplace_back</code>函数使用了完美转发，因此调用它不会带来任何的临时对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure><p>但令人遗憾的是，插入函数还是有可能比置入函数更快的，这取决于传递的实参类型，使用的容器种类，置入或插入到容器中的位置，容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>和<code>set::unordered_map</code>）而言，要添加的值是否已经在容器中。不过在以下这些情况，置入函数很有可能会运行得更快：</p><ul><li>待添加的值是通过构造而非赋值方式加入容器。一个反例是向<code>std::vector</code>中已经被占据的位置置入对象：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line">...                                 <span class="comment">// 向 vs 中添加元素</span></span><br><span class="line"></span><br><span class="line">vs.<span class="built_in">emplace</span>(vs.<span class="built_in">begin</span>(), <span class="string">&quot;xyzzy&quot;</span>);    <span class="comment">// 向 vs 的开头添加元素，该位置已经存在对象</span></span><br><span class="line">                                    <span class="comment">// 使用的是赋值而非构造方式</span></span><br></pre></td></tr></table></figure><blockquote><p>基于节点的容器一般都使用构造来添加新元素，而大多数标准库容器都是基于节点的，除了<code>std::vector</code>，<code>std::deque</code>和<code>std::string</code>等（<code>std::array</code>也不是基于节点的，但是它不支持置入和插入，所以和我们的讨论无关）。在不是基于节点的容器中，你可以确信<code>emplace_back</code>是使用构造来向容器添加元素的，这对于<code>std::deque</code>的<code>emplace_front</code>也同样成立。</p></blockquote><ul><li>传递的实参类型和容器所持有的类型不同。</li><li>容器不会因为存在重复值而拒绝待添加的值。</li></ul><p>在面对<code>new Widget</code>这样的表达式时，置入函数也没有什么优势。考虑以下两种向<code>std::shared_ptr</code>容器中添加新元素的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">killWidget</span><span class="params">(Widget* pWidget)</span></span>;   <span class="comment">// 自定义删除器</span></span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, killWidget));</span><br><span class="line"><span class="comment">// 和 ptrs.push_back(&#123; new Widget, killWidget &#125;) 等价</span></span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> Widget, killWidget);</span><br></pre></td></tr></table></figure><p>此处使用<code>push_back</code>仍然会创建出<code>std::shared_ptr</code>类型的临时对象，但该临时对象却拥有了正面意义，如果在为链表节点分配内存时抛出了内存不足的异常，那么该<code>std::shared_ptr</code>临时对象可以自动调用<code>killWidget</code>来释放<code>Widget</code>的内存；但在使用<code>emplace_back</code>的情况下，起到保障作用的<code>std::shared_ptr</code>临时对象将不再存在，如果发生同样的异常，那么<code>Widget</code>的内存将不可避免地被泄漏。</p><p>如果你参考<strong>条款 21</strong> 所述，使用独立语句将<code>new Widget</code>产生的指针转交给资源管理对象，那么使用置入函数和插入函数的效果也是差不多的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(spw));</span><br><span class="line"><span class="comment">// 或 ptrs.emplace_back(std::move(spw))</span></span><br></pre></td></tr></table></figure><p>最后需要注意的一点是，置入函数可能会执行在插入函数中会被拒绝的类型转换。这是因为置入函数使用的是直接初始化，而插入函数使用的是拷贝初始化，只有直接初始化会将带有<code>explicit</code>限定符的构造函数纳入考虑范围。因此在使用置入函数时，要特别关注是否传递了正确的实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt; regexes;    <span class="comment">// C++11 提供了对正则表达式的支持</span></span><br><span class="line"></span><br><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);         <span class="comment">// 无法通过编译！</span></span><br><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);      <span class="comment">// 能通过编译，但会产生未定义行为</span></span><br><span class="line">                                    <span class="comment">// 相当于执行 std::regex(nullptr)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">《Effective Modern C++》</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/categories/Cpp/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Cpp</title>
    <link href="https://penge666.github.io/posts/bf4dced7.html"/>
    <id>https://penge666.github.io/posts/bf4dced7.html</id>
    <published>2024-04-10T09:53:53.000Z</published>
    <updated>2024-04-11T06:52:02.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《Effectivate C++》，非常好的一本进一步理解C++的书。</p><p>转载自：<a href="https://joytsing.cn/posts/22113/">https://joytsing.cn/posts/22113/</a></p><p>并在其中添加了自己学习的内容。</p><h2 id="第一章：让自己习惯-C"><a href="#第一章：让自己习惯-C" class="headerlink" title="第一章：让自己习惯 C++"></a>第一章：让自己习惯 C++</h2><h3 id="条款-1：视-C-为一个语言联邦"><a href="#条款-1：视-C-为一个语言联邦" class="headerlink" title="条款 1：视 C++ 为一个语言联邦"></a>条款 1：视 C++ 为一个语言联邦</h3><p>C++ 拥有多种不同的编程范式，而这些范式集成在一个语言中，使得 C++ 是一门即灵活又复杂的语言：</p><ol><li>传统的面向过程 C：区块，语句，预处理器，内置数据类型，数组，指针。</li><li>面向对象的 C with Classes：类，封装，继承，多态，动态绑定。</li><li>模板编程 Template C++ 和堪称黑魔法的模板元编程（TMP）。</li><li>C++ 标准库 STL。</li></ol><p>C++ 高效编程守则视情况而变化，程序设计没有银弹。</p><h3 id="条款-2：尽量以-const-enum-inline-替换-define"><a href="#条款-2：尽量以-const-enum-inline-替换-define" class="headerlink" title="条款 2：尽量以 const, enum, inline 替换 #define"></a>条款 2：尽量以 const, enum, inline 替换 #define</h3><p>通俗来说，#define在预处理展开直接替换到代码中，不好排查错误~</p><p>在原书写成时 C++11 中的<code>constexpr</code>还未诞生，现在一般认为应当用<code>constexpr</code>定义编译期常量来替代大部分的<code>#define</code>宏常量定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><p>我们也可以将编译期常量定义为类的静态成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> numTurns = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>enum</code>可以用于替代整型的常量，并且在模板元编程中应用广泛（见条款 48）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; numTurns = <span class="number">5</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大部分<code>#define</code>宏常量应当用内联模板函数替代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CallWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，宏和函数的行为本身并不完全一致，宏只是简单的替换，并不涉及传参和复制。</p><h3 id="条款-3：尽可能使用-const"><a href="#条款-3：尽可能使用-const" class="headerlink" title="条款 3：尽可能使用 const"></a>条款 3：尽可能使用 const</h3><p><strong>const</strong></p><p>const 修饰的变量不能够再作为左值！！初始化完成后，值不能被修改！！</p><p><strong>C和C++中const的区别？</strong></p><p>C中，const就是当作一个变量来编译生成指令的。</p><p>C++中，所有出现const常量名字的地方，都被常量的初始化替换了！！！</p><p><strong>C++中的const必须初始化</strong></p><hr><p><strong>const和一级、多级指针的结合</strong><br>const修饰的量常出现的错误是：</p><p>常量不能再作为左值 = 直接修改常量的值</p><p>不能把常量的地址泄露给—个普通的指针或者普通的引用变量 = 间接修改常量的</p><p>const和一级指针的结合</p><p>c++的语言规范：<strong>const修饰的是离它最近的类型</strong></p><p>const int <em>p = &a; </em>p = 20 p = &amp;b<br>可以任意指向不同的int类型的内存，但是不能通过指针间接修改指向的内存的值</p><hr><p>若你想让一个常量只读，那你应该明确说出它是const常量，对于指针来说，更是如此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting;                <span class="comment">// 指针可修改，数据可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;          <span class="comment">// 指针可修改，数据不可修改</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span>* p = greeting;          <span class="comment">// 指针可修改，数据不可修改</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;          <span class="comment">// 指针不可修改，数据可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;    <span class="comment">// 指针不可修改，数据不可修改</span></span><br></pre></td></tr></table></figure><p>对于 STL 迭代器，分清使用<code>const</code>还是<code>const_iterator</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// 迭代器不可修改，数据可修改</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// 迭代器可修改，数据不可修改</span></span><br></pre></td></tr></table></figure><p>面对函数声明时，如果你不想让一个函数的结果被无意义地当作左值，请使用const返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><p><strong>const成员函数：</strong></p><p>const成员函数允许我们操控const对象，这在传递常引用时显得尤为重要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;    <span class="comment">// const对象使用的重载</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;                <span class="comment">// non-const对象使用的重载</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，const和non-const对象都有其各自的重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Textblock&amp; ctb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ctb[<span class="number">0</span>];            <span class="comment">// 调用 const TextBlock::operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器对待const对象的态度通常是 bitwise constness，而我们在编写程序时通常采用 logical constness，这就意味着，在确保客户端不会察觉的情况下，我们认为const对象中的某些成员变量应当是允许被改变的，使用关键字<code>mutable</code>来标记这些成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">Length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="type">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">CTextBlock::Length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = std::<span class="built_in">strlen</span>(pText);    <span class="comment">// 可以修改mutable成员变量</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;               <span class="comment">// 可以修改mutable成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重载const和non-const成员函数时，需要尽可能避免书写重复的内容，这促使我们去进行常量性转除。在大部分情况下，我们应当避免转型的出现，但在此处为了减少重复代码，转型是适当的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设这里有非常多的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，反向做法：令const版本调用non-const版本以避免重复——并不被建议，一般而言const版本的限制比non-const版本的限制更多，因此这样做会带来风险。</p><h3 id="条款-4：确定对象在使用前已被初始化"><a href="#条款-4：确定对象在使用前已被初始化" class="headerlink" title="条款 4：确定对象在使用前已被初始化"></a>条款 4：确定对象在使用前已被初始化</h3><p>无初值对象在 C/C++ 中广泛存在，因此这一条款就尤为重要。在定义完一个对象后需要尽快为它赋初值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;A C-style string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">std::cin &gt;&gt; d;</span><br></pre></td></tr></table></figure><p>对于类中的成员变量而言，我们有两种建议的方法完成初始化工作，一种是直接在定义处赋初值（since C++11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> textLength&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">bool</span> lengthIsValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种是使用构造函数成员初始化列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">                 <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : <span class="built_in">theName</span>(name),</span><br><span class="line">      <span class="built_in">theAddress</span>(address),</span><br><span class="line">      <span class="built_in">thePhones</span>(phones),</span><br><span class="line">      <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>成员初始化列表也可以留空用来执行默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>()</span><br><span class="line">    : <span class="built_in">theName</span>(),</span><br><span class="line">      <span class="built_in">theAddress</span>(),</span><br><span class="line">      <span class="built_in">thePhones</span>(),</span><br><span class="line">      <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类中成员的初始化具有次序性，而这次序与成员变量的声明次序一致，与成员初始化列表的次序无关。</p><blockquote><p>类中成员的初始化是可选的，但是引用类型必须初始化。</p></blockquote><p><strong>静态对象的初始化：</strong></p><p>C++ 对于定义于不同编译单元内的全局静态对象的初始化相对次序并无明确定义，因此，以下代码可能会出现使用未初始化静态对象的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File 1</span></span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>() &#123;</span><br><span class="line">        FileSystem disk = tfs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Directory tempDir;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，你无法确保位于不同编译单元内的<code>tfs</code>一定在<code>tempDir</code>之前初始化完成。</p><p>这个问题的一个有效解决方案是采用 <strong>Meyers’ singleton</strong>，将全局静态对象转化为局部静态对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个手法的基础在于：C++ 保证，函数内的局部静态对象会在<strong>该函数被调用期间</strong>和<strong>首次遇上该对象之定义式</strong>时被初始化。</p><p>当然，这种做法对于多线程来说并不具有优势，最好还是在单线程启动阶段手动调用函数完成初始化。</p><h2 id="第二章：构造-析构-赋值运算"><a href="#第二章：构造-析构-赋值运算" class="headerlink" title="第二章：构造/析构/赋值运算"></a>第二章：构造/析构/赋值运算</h2><h3 id="条款-5：了解-C-默默编写并调用哪些函数"><a href="#条款-5：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 5：了解 C++ 默默编写并调用哪些函数"></a>条款 5：了解 C++ 默默编写并调用哪些函数</h3><p>这个条款我将会在对象模型中详细解释。</p><p>C++ 中的空类并不是真正意义上的空类，编译器会为它预留以下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>() &#123; ... &#125;                           <span class="comment">// 默认构造函数（没有任何构造函数时）</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;) &#123; ... &#125;               <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(Empty&amp;&amp;) &#123; ... &#125;                    <span class="comment">// 移动构造函数 (since C++11)</span></span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123; ... &#125;                          <span class="comment">// 析构函数</span></span><br><span class="line">    </span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;) &#123; ... &#125;    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(Empty&amp;&amp;) &#123; ... &#125;         <span class="comment">// 移动赋值运算符 (since C++11)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>唯有当这些函数被调用时，它们才会真正被编译器创建出来，下面代码将造成上述每一个函数被创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Empty e1;                   <span class="comment">// 默认构造函数 &amp; 析构函数</span></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;               <span class="comment">// 拷贝构造函数</span></span><br><span class="line">Empty e3 = std::<span class="built_in">move</span>(e2);   <span class="comment">// 移动构造函数 (since C++11)</span></span><br><span class="line">e2 = e1;                    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">e3 = std::<span class="built_in">move</span>(e1);         <span class="comment">// 移动赋值运算符 (since C++11)</span></span><br></pre></td></tr></table></figure><p>需要注意的是，拷贝赋值运算符只有在允许存在时才会自动创建，比如以下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string&amp; nameValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在该类中，我们有一个string引用类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p><p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p><ol><li>类中含有const成员。</li><li>基类中含有private的拷贝赋值运算符。</li></ol><h3 id="条款-6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 6：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>muduo网络库中noncopyable类的设计，可以学习。</p><p>原书中使用的做法是将不想使用的函数声明为private，但在 C++11 后我们有了更好的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-7：为多态基类声明虚析构函数"><a href="#条款-7：为多态基类声明虚析构函数" class="headerlink" title="条款 7：为多态基类声明虚析构函数"></a>条款 7：为多态基类声明虚析构函数</h3><p><strong>重点</strong>：基类指针指向堆上new出来的派生类对象的时候,delete pb基类指针，它调用析构函数的时候，必须发生动态绑定，要不然子类的析构无法调用。</p><p>当派生类对象经由一个基类指针被删除，而该基类指针带着一个非虚析构函数，其结果是未定义的，可能会无法完全销毁派生类的成员，造成内存泄漏。消除这个问题的方法就是对基类使用虚析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你不想让一个类成为基类，那么在类中声明虚函数是是一个坏主意，因为额外存储的虚表指针会使类的体积变大。</p><blockquote><p>只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数。</p></blockquote><p>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。</p><p>如果你想将基类作为抽象类使用，但手头上又没有别的虚函数，那么将它的析构函数设为纯虚函数是一个不错的想法。考虑以下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但若此时从该基类中派生出新的类，会发生报错，这是因为编译器无法找到基类的析构函数的实现。因此，即使是纯虚析构函数，也需要一个函数体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base::~<span class="built_in">Base</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者以下写法也被允许：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-8：别让异常逃离析构函数"><a href="#条款-8：别让异常逃离析构函数" class="headerlink" title="条款 8：别让异常逃离析构函数"></a>条款 8：别让异常逃离析构函数</h3><p>在析构函数中吐出异常并不被禁止，但为了程序的可靠性，应当极力避免这种行为。</p><p>为了实现 RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        db.<span class="built_in">close</span>();    <span class="comment">// 该函数可能会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p><p>第一种：杀死程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 记录运行日志，以便调试</span></span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p><p>第三种：重新设计接口，将异常的处理交给客户端完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个新设计的接口中，我们提供了<code>close</code>函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用<code>close</code>函数。</p><p>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</p><h3 id="条款-9：绝不在构造和析构过程中调用虚函数"><a href="#条款-9：绝不在构造和析构过程中调用虚函数" class="headerlink" title="条款 9：绝不在构造和析构过程中调用虚函数"></a>条款 9：绝不在构造和析构过程中调用虚函数</h3><p><strong>重点</strong>：</p><p>1.构造调用：</p><p>构造调用虚函数，静态调用（从所在类往根类回溯，找到虚函数，就调用哪一个）【问题：父调用子出问题，因为子还没构造出来】</p><p>非构造调用虚函数，通过虚表</p><p>2.析构调用</p><p>析构的顺序：子到父</p><p>在父类中的析构调用虚函数，那么子类可能销毁~</p><hr><p>在创建派生类对象时，基类的构造函数永远会早于派生类的构造函数被调用，而基类的析构函数永远会晚于派生类的析构函数被调用。</p><p>在派生类对象的基类构造和析构期间，对象的类型是基类而非派生类，因此此时调用虚函数会被编译器解析至基类的虚函数版本，通常不会得到我们想要的结果。</p><p>间接调用虚函数是一个比较难以发现的危险行为，需要尽量避免：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>() &#123; <span class="built_in">Init</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">LogTransaction</span>();      <span class="comment">// 此处间接调用了虚函数！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LogTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo) &#123;</span><br><span class="line">    <span class="built_in">LogTransaction</span>(logInfo);                           <span class="comment">// 更改为了非虚函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span> : <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(...)</span><br><span class="line">        : <span class="built_in">Transaction</span>(<span class="built_in">CreateLogString</span>(...)) &#123; ... &#125;    <span class="comment">// 将信息传递给基类构造函数</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">CreateLogString</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此处的<code>CreateLogString</code>是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p><h3 id="条款-10：令-operator-返回一个指向-this-的引用"><a href="#条款-10：令-operator-返回一个指向-this-的引用" class="headerlink" title="条款 10：令 operator= 返回一个指向 *this 的引用"></a>条款 10：令 operator= 返回一个指向 *this 的引用</h3><p>重点：</p><p>a=b=c</p><p>this是地址，*this是对象，解引用。</p><hr><blockquote><p>引用知识</p></blockquote><p>引用和指针区别</p><ul><li><p>引用是一种更安全的指针。</p></li><li><p>引用是必须初始化的，而指针可以不初始化</p></li><li><p>引用只有一级引用，没有多级引用；指针可以一级指针，也可以多级指针</p></li><li><p>定义一个引用变量和定义一个指针变量，其汇编指令是一模一样的；通过引用变量修改所引用内存的值，和过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的</p></li></ul><ul><li><p>右值引用</p></li><li><p>int &amp;&amp;c = 20; 专门用来引用右值类型，指令上，可以自动产生临时量然后直接引用临时量 c = 40;</p></li><li>右值引用变量本身是一个左值，只能用左值引用来引用它</li><li>不能用一个右值引用变量来引用一个左值。</li></ul><hr><p>虽然并不强制执行此条款，但为了实现连锁赋值，大部分时候应该这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs) &#123;    <span class="comment">// 这个条款适用于</span></span><br><span class="line">        ...                                    <span class="comment">// +=, -=, *= 等等运算符</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs) &#123;               <span class="comment">// 即使参数类型不是 Widget&amp; 也适用</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-11：在-operator-中处理“自我赋值”"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator= 中处理“自我赋值”"></a>条款 11：在 operator= 中处理“自我赋值”</h3><p>重点：特判，减小开销</p><hr><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pRes;                          <span class="comment">// 删除当前持有的资源</span></span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);       <span class="comment">// 复制传入的资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但若<code>rhs</code>和<code>*this</code>指向的是相同的对象，就会导致访问到已删除的数据。</p><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">// 若是自我赋值，则不做任何事</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pRes;</span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Resource* pOrigin = pRes;             <span class="comment">// 先记住原来的pRes指针</span></span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);       <span class="comment">// 复制传入的资源</span></span><br><span class="line">    <span class="keyword">delete</span> pOrigin;                       <span class="comment">// 删除原来的资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p><p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(Widget rhs) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>这个条款正如其字面意思，当你决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><p>当使用继承时，继承自基类的成员往往容易忘记在派生类中完成复制，如果你的基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span> : <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),                <span class="comment">// 调用基类的拷贝构造函数</span></span><br><span class="line">      <span class="built_in">priority</span>(rhs.priority) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);       <span class="comment">// 调用基类的拷贝赋值运算符</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不要尝试在拷贝构造函数中调用拷贝赋值运算符，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><h2 id="第三章：资源管理"><a href="#第三章：资源管理" class="headerlink" title="第三章：资源管理"></a>第三章：资源管理</h2><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄露。因此，我们应尽可能以对象管理资源，并采用RAII（Resource Acquisition Is Initialize，资源取得时机便是初始化时机），让析构函数负责资源的释放。</p><p>原书此处关于智能指针的内容已经过时，在 C++11 中，通过专一所有权来管理RAII对象可以使用<code>std::unique_ptr</code>，通过引用计数来管理RAII对象可以使用<code>std::shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Investment* CreateInvestment();</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pUniqueInv1</span><span class="params">(CreateInvestment())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pUniqueInv2</span><span class="params">(std::move(pUniqueInv1))</span></span>;    <span class="comment">// 转移资源所有权</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv1</span><span class="params">(CreateInvestment())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv2</span><span class="params">(pSharedInv1)</span></span>;               <span class="comment">// 引用计数+1</span></span><br></pre></td></tr></table></figure><p>智能指针默认会自动delete所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void GetRidOfInvestment(Investment*) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(GetRidOfInvestment)</span>*&gt; <span class="title">pUniqueInv</span><span class="params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv</span><span class="params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条款-14：在资源管理类中小心拷贝行为"><a href="#条款-14：在资源管理类中小心拷贝行为" class="headerlink" title="条款 14：在资源管理类中小心拷贝行为"></a>条款 14：在资源管理类中小心拷贝行为</h3><p>我们应该永远保持这样的思考：当一个RAII对象被复制，会发生什么事？</p><p><strong>选择一：禁止复制</strong></p><p>许多时候允许RAII对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款 6 已经阐述了怎么做这件事。</p><p><strong>选择二：对底层资源祭出“引用计数法”</strong></p><p>正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><p><strong>选择三：复制底层资源</strong></p><p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p><p><strong>选择四：转移底层资源的所有权</strong></p><p>和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p><h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL 中的智能指针也提供了对原始资源的隐式访问和显式访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Investment* pRaw = pSharedInv.<span class="built_in">get</span>();    <span class="comment">// 显式访问原始资源</span></span><br><span class="line">Investment raw = *pSharedInv;           <span class="comment">// 隐式访问原始资源</span></span><br></pre></td></tr></table></figure><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FontHandle <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> handle; &#125;       <span class="comment">// 显式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> handle; &#125;  <span class="comment">// 隐式转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同形式"></a>条款 16：成对使用 new 和 delete 时要采用相同形式</h3><blockquote><p>new和delete</p></blockquote><p>malloc 和 free，称作 c 的库函数</p><p>new 和 delete，称作运算符</p><p>new不仅可以做内存开辟，还可以做内存初始化操作</p><p>malloc开辟内存失败，是通过返回值和nullptr做比较：而new开辟内存失败，是通过抛出bad_alloc类型的异常来判断的。</p><p>new 可以认为是 malloc + 构造函数， delete 可以认为是 free + 析构函数</p><hr><p><strong>重点</strong>：不成对出现是针对对象来说，内置类型没有问题。</p><p>因为[]的时候，内存会多开辟一段空间保存对象信息，比如个数</p><p>new和delete[]的例子：会导致内存多delete</p><p>new[]和delete的例子：delete只删除掉第一对象，即调用第一个对象的构造函数，但是对象有多个，因此会存在问题。</p><hr><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>* object = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"><span class="keyword">delete</span> object;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>typedef</code>定义数组类型会带来额外的风险：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;    <span class="comment">// pal 是一个对象数组，而非单一对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;                             <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;                           <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h3><p><strong>重点</strong>:这个条款结合effectivae modern c++学习</p><p>原书此处所讲已过时，现在更好的做法是使用<code>std::make_unique</code>和<code>std::make_shared</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pUniqueInv = std::<span class="built_in">make_unique</span>&lt;Investment&gt;();    <span class="comment">// since C++14</span></span><br><span class="line"><span class="keyword">auto</span> pSharedInv = std::<span class="built_in">make_shared</span>&lt;Investment&gt;();    <span class="comment">// since C++11</span></span><br></pre></td></tr></table></figure><h2 id="第四章：设计与声明"><a href="#第四章：设计与声明" class="headerlink" title="第四章：设计与声明"></a>第四章：设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不易被误用。你应在在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个参数类型相同的函数容易造成误用</span></span><br><span class="line">Data::<span class="built_in">Data</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过适当定义新的类型加以限制，降低误用的可能性</span></span><br><span class="line">Data::<span class="built_in">Data</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol><li>尽量使用智能指针，避免跨DLL的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</li></ol><h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>几乎在设计每一个 class 时，都要面对如下问题：</p><p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p><p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p><p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p><p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p><p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为<code>final</code>）。</p><p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p><p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为<code>= delete</code>。</p><p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p><p><strong>什么是新 type 的“未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p><p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p><h3 id="条款-20：宁以按常引用传参替换按值传参"><a href="#条款-20：宁以按常引用传参替换按值传参" class="headerlink" title="条款 20：宁以按常引用传参替换按值传参"></a>条款 20：宁以按常引用传参替换按值传参</h3><p>当使用按值传参时，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销可能会较为昂贵。对于任何用户自定义类型，使用按常引用传参是较为推荐的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ValidateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure><p>因为没有任何新对象被创建，这种传参方式不会调用任何构造函数或析构函数，所以效率比按值传参高得多。</p><p>使用按引用传参也可以避免<strong>对象切片（Object slicing）</strong> 的问题，参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处一个<code>WindowWithScrollBars</code>类继承自<code>Window</code>基类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintNameAndDisplay</span><span class="params">(Window w)</span> </span>&#123;    <span class="comment">// 按值传参，会发生对象切片</span></span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">GetName</span>();</span><br><span class="line">    w.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处在传参时，调用了基类<code>Window</code>的拷贝构造函数而非派生类的拷贝构造函数，因此在函数种使用的是一个<code>Window</code>对象，调用虚函数时也只能调用到基类的虚函数<code>Window::Display</code>。</p><p>由于按引用传递不会创建新对象，这个问题就能得到避免：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span> </span>&#123; <span class="comment">// 参数不会被切片</span></span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">GetName</span>();</span><br><span class="line">    w.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也并非永远都使用按引用传参，对于内置类型、STL的迭代器和函数对象，我们认为使用按值传参是比较合适的。</p><h3 id="条款-21：必须返回对象时，别妄想返回其引用"><a href="#条款-21：必须返回对象时，别妄想返回其引用" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其引用"></a>条款 21：必须返回对象时，别妄想返回其引用</h3><p><strong>返回一个指向函数内部局部变量的引用是严重的错误，因为局部变量在离开函数时就被销毁了，除此之外，返回一个指向局部静态变量的引用也是不被推荐的</strong>。</p><p>尽管返回对象会调用拷贝构造函数产生开销，但这开销比起出错而言微不足道。</p><h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>出于对封装性的考虑，应该尽可能地隐藏类中的成员变量，并通过对外暴露函数接口来实现对成员变量的访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetReadOnly</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; readWrite = value; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetReadWrite</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetWriteOnly</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; writeOnly = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> noAccess;</span><br><span class="line">    <span class="type">int</span> readOnly;</span><br><span class="line">    <span class="type">int</span> readWrite;</span><br><span class="line">    <span class="type">int</span> writeOnly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过为成员变量提供 getter 和 setter 函数，我们就能避免客户做出写入只读变量或读取只写变量这样不被允许的操作。</p><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可使得在成员变量被读或写时轻松通知其它对象，可以验证类的约束条件以及函数的提前和事后状态，可以在多线程环境中执行同步控制……</p><p><code>protected</code>和<code>public</code>一样，都不该被优先考虑。假设我们有一个public成员变量，最终取消了它，那么所有使用它的客户代码都将被破坏；假设我们有一个protected成员变量，最终取消了它，那么所有使用它的派生类都将被破坏。</p><p>综合以上讨论，在类中应当将成员变量优先声明为 private。</p><h3 id="条款-23：宁以非成员、非友元函数替换成员函数"><a href="#条款-23：宁以非成员、非友元函数替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元函数替换成员函数"></a>条款 23：宁以非成员、非友元函数替换成员函数</h3><p>假设有这样一个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要一次性调用这三个函数，那么需要额外提供一个新的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearEverything</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">    wb.<span class="built_in">ClearCache</span>();</span><br><span class="line">    wb.<span class="built_in">ClearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">RemoveCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，虽然成员函数和非成员函数都可以完成我们的目标，但此处更建议使用非成员函数，这是为了遵守一个原则：<strong>越少的代码可以访问数据，数据的封装性就越强</strong>。此处的<code>ClearEverything</code>函数仅仅是调用了<code>WebBrowser</code>的三个public成员函数，而并没有使用到<code>WebBrowser</code>内部的private成员，因此没有必要让其也拥有访问类中private成员的能力。</p><p>这个原则对于友元函数也是相同的，因为友元函数和成员函数拥有相同的权力，所以在能使用非成员函数完成任务的情况下，就不要使用友元函数和成员函数。</p><p>如果你觉得一个全局函数并不自然，也可以考虑将<code>ClearEverything</code>函数放在工具类中充当静态成员函数，或与<code>WebBrowser</code>放在同一个命名空间中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearEverything</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><p>现在我们手头上拥有一个<code>Rational</code>类，并且它可以和<code>int</code>隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们需要重载乘法运算符来实现<code>Rational</code>对象之间的乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将运算符重载放在类中是行得通的，至少对于<code>Rational</code>对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf / oneEight;</span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>;    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>在调用<code>operator*</code>时，<code>int</code>类型的变量会隐式转换为<code>Rational</code>对象，因此用<code>Rational</code>对象乘以<code>int</code>对象是合法的，但反过来则不是如此。</p><p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><h3 id="条款-25：考虑写出一个不抛异常的swap函数"><a href="#条款-25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的swap函数"></a>条款 25：考虑写出一个不抛异常的swap函数</h3><p>由于<code>std::swap</code>函数在 C++11 后改为了用<code>std::move</code>实现，因此几乎已经没有性能的缺陷，也不再有像原书中所说的为自定义类型去自己实现的必要。不过原书中透露的思想还是值得一学的。</p><p>如果想为自定义类型实现自己的swap方法，可以考虑使用模板全特化，并且这种做法是被 STL 允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，由于外部函数并不能直接访问<code>Widget</code>的private成员变量，因此我们先是在类中定义了一个 public 成员函数，再由<code>std::swap</code>去调用这个成员函数。</p><p>然而若<code>Widget</code>和<code>WidgetImpl</code>是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的swap函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="number">3</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望在对自定义对象进行操作时找到正确的swap函数重载版本，这时候如果再写成<code>std::swap</code>，就会强制使用 STL 中的swap函数，无法满足我们的需求，因此需要改写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="built_in">swap</span>(obj1, obj2);</span><br></pre></td></tr></table></figure><p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的swap函数而非 STL 中的swap函数。</p><blockquote><p>C++ 名称查找法则：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。 函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p></blockquote><h2 id="第五章：实现"><a href="#第五章：实现" class="headerlink" title="第五章：实现"></a>第五章：实现</h2><h3 id="条款-26：尽可能延后变量定义式出现的时间"><a href="#条款-26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款 26：尽可能延后变量定义式出现的时间"></a>条款 26：尽可能延后变量定义式出现的时间</h3><p><strong>重点</strong>： 对象优化部分</p><p>当变量定义出现时，程序需要承受其构造成本；当变量离开其作用域时，程序需要承受其析构成本。因此，避免不必要的变量定义，以及延后变量定义式直到你确实需要它。</p><p>延后变量定义式还有一个意义，即“默认构造+赋值”效率低于“直接构造”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 效率低</span></span><br><span class="line">std::string encrypted;</span><br><span class="line">encrypted = password;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效率高</span></span><br><span class="line"><span class="function">std::string <span class="title">encrypted</span><span class="params">(password)</span></span>;</span><br></pre></td></tr></table></figure><p>对于循环中变量的定义，我们一般有两种做法：</p><p>A. 定义于循环外，在循环中赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于 i 的某个值;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法产生的开销：1 个构造函数 + 1 个析构函数 + n 个赋值操作</p><p>B. 定义于循环内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于 i 的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法产生的开销：n 个构造函数 + n 个析构函数</p><p>由于做法A会将变量的作用域扩大，因此除非知道该变量的赋值成本比“构造+析构”成本低，或者对这段程序的效率要求非常高，否则建议使用做法B。</p><h3 id="条款-27：少做转型动作"><a href="#条款-27：少做转型动作" class="headerlink" title="条款 27：少做转型动作"></a>条款 27：少做转型动作</h3><p>C 式转型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span></span></span><br></pre></td></tr></table></figure><p>C++ 式转型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><code>const_cast</code>用于常量性转除，这也是唯一一个有这个能力的 C++ 式转型。</li><li><code>dynamic_cast</code>用于安全地向下转型，这也是唯一一个 C 式转型无法代替的转型操作，它会执行对继承体系的检查，因此会带来额外的开销。只有拥有虚函数的基类指针能进行<code>dynamic_cast</code>。</li><li><code>reinterpret_cast</code>用于在任意两个类型间进行低级转型，执行该转型可能会带来风险，也可能不具备移植性。</li><li><code>static_cast</code>用于进行强制隐式转换，也是最常用的转型操作，可以将内置数据类型互相转换，也可以将<code>void*</code>和typed指针，基类指针和派生类指针互相转换。</li></ul><p>尽量在 C++ 程序中使用 C++ 式转型，因为 C++ 式转型操作功能更明确，可以避免不必要的错误。</p><p>唯一使用 C 式转型的时机可能是在调用 explicit 构造函数时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">DoSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="comment">// 等价于 DoSomeWork(static_cast&lt;Widget&gt;(15));</span></span><br></pre></td></tr></table></figure><p>需要注意的是，转型并非什么都没有做，而是可能会更改数据的底层表述，或者为指针附加偏移值，这和具体平台有关，因此不要妄图去揣测转型后对象的具体布局方式。</p><p>避免对<code>*this</code>进行转型，参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">OnResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码试图通过转型<code>*this</code>来调用基类的虚函数，然而这是严重错误的，这样做会得到一个新的<code>Window</code>副本并在该副本上调用函数，而非在原本的对象上调用函数。</p><p>正确的做法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Window::<span class="built_in">OnResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你想知道一个基类指针是否指向一个派生类对象时，你需要用到<code>dynamic_cast</code>，如果不满足，则会产生报错。但是对于继承体系的检查可能是非常慢的，所以在注重效率的程序中应当避免使用<code>dynamic_cast</code>，改用<code>static_cast</code>或别的代替方法。</p><h3 id="条款-28：避免返回-handles-指向对象的内部成分"><a href="#条款-28：避免返回-handles-指向对象的内部成分" class="headerlink" title="条款 28：避免返回 handles 指向对象的内部成分"></a>条款 28：避免返回 handles 指向对象的内部成分</h3><p>考虑以下<code>Rectangle</code>类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;</span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point&amp; <span class="title">UpperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">LowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码看起来没有任何问题，但其实是在做自我矛盾的事情：我们通过const成员函数返回了一个指向成员变量的引用，这使得成员变量可以在外部被修改，而这是违反 logical constness 的原则的。换句话说，你<strong>绝对不应该令成员函数返回一个指针指向“访问级别较低”的成员函数</strong>。</p><p>改成返回常引用可以避免对成员变量的修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">UpperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">LowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br></pre></td></tr></table></figure><p>但是这样依然会带来一个称作 <strong>dangling handles（空悬句柄）</strong> 的问题，当对象不复存在时，你将无法通过引用获取到返回的数据。</p><p>采用最保守的做法，返回一个成员变量的副本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">UpperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function">Point <span class="title">LowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br></pre></td></tr></table></figure><p>避免返回 handles（包括引用、指针、迭代器）指向对象内部。遵循这个条款可增加封装性，使得const成员函数的行为符合常量性，并将发生 “空悬句柄” 的可能性降到最低。</p><h3 id="条款-29：为“异常安全”而努力是值得的"><a href="#条款-29：为“异常安全”而努力是值得的" class="headerlink" title="条款 29：为“异常安全”而努力是值得的"></a>条款 29：为“异常安全”而努力是值得的</h3><p>异常安全函数提供以下三个保证之一：</p><p><strong>基本承诺：</strong> 如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构会因此败坏，所有对象都处于一种内部前后一致的状态，然而程序的真实状态是不可知的，也就是说客户需要额外检查程序处于哪种状态并作出对应的处理。</p><p><strong>强烈保证：</strong> 如果异常被抛出，程序状态完全不改变，换句话说，程序会回复到“调用函数之前”的状态。</p><p><strong>不抛掷（nothrow）保证：</strong> 承诺绝不抛出异常，因为程序总是能完成原先承诺的功能。作用于内置类型身上的所有操作都提供 nothrow 保证。</p><p>原书中实现 nothrow 的方法是<code>throw()</code>，不过这套异常规范在 C++11 中已经被弃用，取而代之的是<code>noexcept</code>关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>注意，使用<code>noexcept</code>并不代表函数绝对不会抛出异常，而是在抛出异常时，将代表出现严重错误，会有意想不到的函数被调用（可以通过<code>set_unexpected</code>设置），接着程序会直接崩溃。</p><p>当异常被抛出时，带有异常安全性的函数会：</p><ol><li>不泄漏任何资源。</li><li>不允许数据败坏。</li></ol><p>考虑以下<code>PrettyMenu</code>的<code>ChangeBackground</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;        <span class="comment">// 互斥锁</span></span><br><span class="line">    Image* bgImage;     <span class="comment">// 目前的背景图像</span></span><br><span class="line">    <span class="type">int</span> imageChanges;   <span class="comment">// 背景图像被改变的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这个函数不满足我们所说的具有异常安全性的任何一个条件，若在函数中抛出异常，<code>mutex</code>会发生资源泄漏，<code>bgImage</code>和<code>imageChanges</code>也会发生数据败坏。</p><p>通过以对象管理资源，使用智能指针和调换代码顺序，我们能将其变成一个具有强烈保证的异常安全函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(std::<span class="built_in">make_shared</span>&lt;Image&gt;(imgSrc));</span><br><span class="line"></span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个常用于提供强烈保证的方法是我们所提到过的 copy and swap，为你打算修改的对象做出一份副本，对副本执行修改，并在所有修改都成功执行后，用一个不会抛出异常的swap方法将原件和副本交换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::ChangeBackground</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pNew = std::<span class="built_in">make_shared</span>&lt;PMImpl&gt;(*pImpl);    <span class="comment">// 获取副本</span></span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(std::<span class="built_in">make_shared</span>&lt;Image&gt;(imgSrc));</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">swap</span>(pImpl, pNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个函数调用其它函数时，函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p><p>强烈保证并非永远都是可实现的，特别是当函数在操控非局部对象时，这时就只能退而求其次选择不那么美好的基本承诺，并将该决定写入文档，让其他人维护时不至于毫无心理准备。</p><h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><p><strong>重点</strong>：</p><p>inline函数没有函数调用开销，直接把函数的代码进行展开</p><p>inline函数不再生成相应的函数符号</p><p>递归的函数inline不会展开</p><p>谷歌风格中介绍到最好控制在10行inline函数</p><hr><p>将函数声明为内联一共有两种方法，一种是为其显式指定<code>inline</code>关键字，另一种是直接将成员函数的定义式写在类中，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125;  <span class="comment">// 隐式声明为 inline</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>inline</code>诞生之初，它被当作是一种对编译器的优化建议，即将“对此函数的每一个调用”都以函数本体替换之。但在编译器的具体实现中，该行为完全被优化等级所控制，与函数是否内联无关。</p><p>在现在的 C++ 标准中，<code>inline</code>作为优化建议的含义已经被完全抛弃，取而代之的是“允许函数在不同编译单元中多重定义”，使得可以在头文件中直接给出函数的实现。</p><p>在 C++17 中，引入了一个新的<code>inline</code>用法，使静态成员变量可以在类中直接定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> theAge = <span class="number">0</span>;  <span class="comment">// since C++17</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>C++ 坚持将类的实现细节放置于类的定义式中，这就意味着，即使你只改变类的实现而不改变类的接口，在构建程序时依然需要重新编译。这个问题的根源出在编译器必须在编译期间知道对象的大小，如果看不到类的定义式，就没有办法为对象分配内存。也就是说，C++ 并没有把“将接口从实现中分离”这件事做得很好。</p><p><strong>用“声明的依存性”替换“定义的依存性”：</strong></p><p>我们可以玩一个“将对象实现细目隐藏于一个指针背后”的游戏，称作 <strong>pimpl idiom（pimpl 是 pointer to implemention 的缩写）</strong>：将原来的一个类分割为两个类，一个只提供接口，另一个负责实现该接口，称作<strong>句柄类（handle class）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.hpp 负责声明类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.cpp 负责实现类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>() &#123;</span><br><span class="line">    pImpl = std::<span class="built_in">make_shared</span>&lt;PersonImpl&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; pImpl-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，假如我们要修改<code>Person</code>的private成员，就只需要修改<code>PersonImpl</code>中的内容，而<code>PersonImpl</code>的具体实现是被隐藏起来的，对它的任何修改都不会使得<code>Person</code>客户端重新编译，真正实现了“类的接口和实现分离”。</p><p><strong>如果使用对象引用或对象指针可以完成任务，就不要使用对象本身：</strong></p><p>你可以只靠一个类型声明式就定义出指向该类型的引用和指针；但如果定义某类型的对象，就需要用到该类型的定义式。</p><p><strong>如果能够，尽量以类声明式替换类定义式：</strong></p><p>当你在声明一个函数而它用到某个类时，你不需要该类的定义；但当你触及到该函数的定义式后，就必须也知道类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                     <span class="comment">// 类的声明式</span></span><br><span class="line"><span class="function">Date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(Date d)</span></span>; <span class="comment">// 此处并不需要得知类的定义</span></span><br></pre></td></tr></table></figure><p><strong>为声明式和定义式提供不同的头文件：</strong></p><p>为了避免频繁地添加声明，我们应该为所有要用的类声明提供一个头文件，这种做法对 template 也适用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span>            <span class="comment">// 这个头文件内声明 class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure><p>此处的头文件命名方式<code>&quot;datefwd.h&quot;</code>取自标准库中的<code>&lt;iosfwd&gt;</code>。</p><p>上面我们讲述了接口与实现分离的其中一个方法——提供句柄类，另一个方法就是将句柄类定义为抽象基类，称作<strong>接口类（interface class）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了将<code>Person</code>对象实际创建出来，我们一般采用工厂模式。可以尝试在类中塞入一个静态成员函数<code>Create</code>用于创建对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但此时<code>Create</code>函数还无法使用，需要在派生类中给出<code>Person</code>类中的函数的具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(...) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成<code>Create</code>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;RealPerson&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问的是，句柄类和接口类都需要额外的开销：句柄类需要通过 pimpl 取得对象数据，增加一层间接访问、指针大小和动态分配内存带来的开销；而接口类会增加存储虚表指针和实现虚函数跳转带来的开销。</p><p>而当这些开销过于重大以至于类之间的耦合度在相形之下不成为关键时，就以具象类（concrete class）替换句柄类和接口类。</p><h2 id="第六章：继承与面向对象设计"><a href="#第六章：继承与面向对象设计" class="headerlink" title="第六章：继承与面向对象设计"></a>第六章：继承与面向对象设计</h2><h3 id="条款-32：确定你的public继承塑模出-is-a-关系"><a href="#条款-32：确定你的public继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的public继承塑模出 is-a 关系"></a>条款 32：确定你的public继承塑模出 is-a 关系</h3><p>“public继承”意味着 is-a，所谓 is-a，就是指适用于基类身上的每一件事情一定也适用于继承类身上，因为我们可以认为每一个派生类对象也都是一个基类对象。</p><p>这看似很自然，但在面对自然语言的表述时，往往会产生歧义。</p><p>考虑<code>Bird</code>类和<code>Penguin</code>类的继承关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Penguin</code>类会获得来自<code>Bird</code>类的飞行方法，这就造成了误解，因为企鹅恰恰是不会飞的鸟类。一种解决方法是当调用<code>Penguin</code>类中的<code>Fly</code>函数时，抛出一个运行期错误，但这种做法通常不够直观；另一个解决方法是使用双继承，区分会飞和不会飞的鸟类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> FlyingBird &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但若要处理鸟类的多钟不同属性时，双继承模式就不太管用了，因此我们总是说程序设计没有银弹。</p><p>另一个常见的例子是用<code>Square</code>类继承自<code>Rectangle</code>类，从几何学的角度来讲这很自然，然而正方形的长宽是相等的，矩形却不是如此，因此<code>Square</code>类和<code>Rectangle</code>类也无法满足严格的 is-a 关系。</p><h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><p><strong>重点</strong>：简单来说，父类方法就会被隐藏</p><p>在继承结构中，派生类的同名成员把基类的同名成员给隐藏了，也就是调用的时候调用的是派生类的成员函数。要调用基类那就加作用域，（比如 Base::show）</p><hr><p>之前我们了解过 C++ 名称查找法则，这在继承体系中也是类似的，当我们在派生类中使用到一个名字时，编译器会优先查找派生类覆盖的作用域，如果没找到，再去查找基类的作用域，最后再查找全局作用域。</p><p>考虑以下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样会导致派生类无法使用来自基类的重载函数，因为派生类中的名称<code>mf</code>掩盖了来自基类的名称<code>mf</code>。</p><p>对于名称掩盖问题的一种方法是使用<code>using</code>关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>using</code>关键字会将基类中所有使用到名称<code>mf</code>的函数全部包含在派生类中，包括其重载版本。</p><p>若有时我们不想要一个函数的全部版本，只想要单一版本（特别是在private继承时），可以考虑使用<strong>转发函数（forwarding function）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">mf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><ol><li>接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。</li><li>声明一个纯虚函数的目的，是为了让派生类只继承函数接口。</li><li>声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。</li><li>声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。</li></ol><p>通常而言，我们不会为纯虚函数提供具体实现，然而这样做是被允许的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p><p>用非纯虚函数提供缺省的默认实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p><p>使用纯虚函数并提供默认实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DefaultFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DefaultFly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述写法可以替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::Fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Airplane::<span class="built_in">Fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-35：考虑虚函数以外的其它选择"><a href="#条款-35：考虑虚函数以外的其它选择" class="headerlink" title="条款 35：考虑虚函数以外的其它选择"></a>条款 35：考虑虚函数以外的其它选择</h3><p><strong>藉由非虚接口手法实现 template method：</strong></p><p><strong>非虚接口（non-virtual interface，NVI）</strong> 设计手法的核心就是用一个非虚函数作为 wrapper，将虚函数隐藏在封装之下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...    <span class="comment">// 做一些前置工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">DoHealthValue</span>();</span><br><span class="line">        ...    <span class="comment">// 做一些后置工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">DoHealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...    <span class="comment">// 缺省算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NVI手法的一个优点就是在 wrapper 中做一些前置和后置工作，确保得以在一个虚函数被调用之前设定好适当场景，并在调用结束之后清理场景。如果你让客户直接调用虚函数，就没有任何好办法可以做这些事。</p><p>NVI手法允许派生类重新定义虚函数，从而赋予它们“如何实现机能”的控制能力，但基类保留诉说“函数何时被调用”的权利。</p><p>在NVI手法中虚函数除了可以是private，也可以是protected，例如要求在派生类的虚函数实现内调用其基类的对应虚函数时，就必须得这么做。</p><p><strong>藉由函数指针实现 Strategy 模式：</strong></p><p>参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DefaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;        <span class="comment">// 缺省算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> HealthCalcFunc = <span class="built_in">int</span>(*)(<span class="type">const</span> GameCharacter&amp;);    <span class="comment">// 定义函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = DefaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同一个人物类型的不同实体可以有不同的健康计算函数，并且该计算函数可以在运行期变更。</p><p>这间接表明健康计算函数不再是<code>GameCharacter</code>继承体系内的成员函数，它也无权使用非public成员。为了填补这个缺陷，我们唯一的做法是弱化类的封装，引入友元或提供public访问函数。</p><p><strong>藉由 std::function 完成 Strategy 模式</strong></p><p><code>std::function</code>是 C++11 中引入的函数包装器，使用它能提供比函数指针更强的灵活度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DefaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;        <span class="comment">// 缺省算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> HealthCalcFunc = std::function&lt;<span class="built_in">int</span>(<span class="type">const</span> GameCharacter&amp;)&gt;;    <span class="comment">// 定义函数包装器类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = DefaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来并没有很大的改变，但当我们需要时，<code>std::function</code>就能展现出惊人的弹性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用返回值不同的函数</span></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">CalcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">chara1</span><span class="params">(CalcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数对象（仿函数）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">chara2</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用某个成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line"><span class="function">GameCharacter <span class="title">chara2</span><span class="params">(std::bind(&amp;GameLevel::Health, currentLevel, std::placeholders::_1))</span></span>;</span><br></pre></td></tr></table></figure><p><strong>古典的 Strategy 模式：</strong></p><p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自<code>HealthCalcFunc</code>继承体系的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">Calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为<code>HealthCalcFunc</code>基类添加一个派生类即可。</p><h3 id="条款-36：绝不重新定义继承而来的非虚函数"><a href="#条款-36：绝不重新定义继承而来的非虚函数" class="headerlink" title="条款 36：绝不重新定义继承而来的非虚函数"></a>条款 36：绝不重新定义继承而来的非虚函数</h3><p>非虚函数和虚函数具有本质上的不同：非虚函数执行的是静态绑定（statically bound，又称前期绑定，early binding），由对象类型本身（称之静态类型）决定要调用的函数；而虚函数执行的是动态绑定（dynamically bound，又称后期绑定，late binding），决定因素不在对象本身，而在于“指向该对象之指针”当初的声明类型（称之动态类型）。</p><p>前面我们已经说过，public继承意味着 is-a 关系，而在基类中声明一个非虚函数将会为该类建立起一种不变性（invariant），凌驾其特异性（specialization）。而若在派生类中重新定义该非虚函数，则会使人开始质疑是否该使用public继承的形式；如果必须使用，则又打破了基类“不变性凌驾特异性”的性质，就此产生了设计上的矛盾。</p><p>综上所述，在任何情况下都不该重新定义一个继承而来的非虚函数。</p><h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><p>重点：<strong>缺省参数值却是静态绑定</strong></p><p><strong>什么是多态？</strong></p><p>静态：编译时期的多态。（多种多样的形态）。如 函数重载</p><p>动态：运行时期的多态</p><hr><p>在条款 36 中我们已经否定了重新定义非虚函数的可能性，因此此处我们只讨论带有缺省参数值的虚函数。</p><p>虚函数是动态绑定而来，意思是调用一个虚函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。但与之不同的是，<strong>缺省参数值却是静态绑定</strong>，意思是你可能会在“调用一个定义于派生类的虚函数”的同时，却使用基类为它所指定的缺省参数值。考虑以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时若对派生类对象调用<code>Draw</code>函数，则会发现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">pr-&gt;<span class="built_in">Draw</span>(Shape::ShapeColor::Green);    <span class="comment">// 调用 Rectangle::Draw(Shape::Green)</span></span><br><span class="line">pr-&gt;<span class="built_in">Draw</span>();                            <span class="comment">// 调用 Rectangle::Draw(Shape::Red)</span></span><br><span class="line">pc-&gt;<span class="built_in">Draw</span>();                            <span class="comment">// 调用 Rectangle::Draw(Shape::Red)</span></span><br></pre></td></tr></table></figure><p>这就迫使我们在指定虚函数时使用相同的缺省参数值，为了避免不必要的麻烦和错误，可以考虑条款 35 中列出的虚函数的替代设计，例如NVI手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="type">const</span> </span>&#123; <span class="built_in">DoDraw</span>(color); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-38：通过复合塑模出-has-a-或“根据某物实现出”"><a href="#条款-38：通过复合塑模出-has-a-或“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出 has-a 或“根据某物实现出”"></a>条款 38：通过复合塑模出 has-a 或“根据某物实现出”</h3><p>所谓<strong>复合（composition）</strong>，指的是某种类型的对象内含它种类型的对象。复合通常意味着 <strong>has-a</strong> 或<strong>根据某物实现出（is-implemented-in-terms-of）</strong> 的关系，当复合发生于应用域（application domain）内的对象之间，表现出 has-a 的关系；当它发生于实现域（implementation domain）内则是表现出“根据某物实现出”的关系。</p><p>下面是一个 has-a 关系的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;           <span class="comment">// 合成成分物（composed object）</span></span><br><span class="line">    Address address;            <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber voiceNumber;    <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber faxNumber;      <span class="comment">// 同上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个“根据某物实现出”关系的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 list 应用于 Set</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;           <span class="comment">// 用来表述 Set 的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-39：明智而审慎地使用private继承"><a href="#条款-39：明智而审慎地使用private继承" class="headerlink" title="条款 39：明智而审慎地使用private继承"></a>条款 39：明智而审慎地使用private继承</h3><p>private继承的特点：</p><ol><li>如果类之间是private继承关系，那么编译器不会自动将一个派生类对象转换为一个基类对象。</li><li>由private继承来的所有成员，在派生类中都会变为private属性，换句话说，private继承只继承实现，不继承接口。</li></ol><p>private继承的意义是“根据某物实现出”，如果你读过条款 38，就会发现private继承和复合具有相同的意义，事实上也确实如此，绝大部分private继承的使用场合都可以被“public继承+复合”完美解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span> : <span class="keyword">public</span> Timer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用后者比前者好的原因有以下几点：</p><ol><li>private继承无法阻止派生类重新定义虚函数，但若使用public继承定义<code>WidgetTimer</code>类并复合在<code>Widget</code>类中，就能防止在<code>Widget</code>类中重新定义虚函数。</li><li>可以仅提供<code>WidgetTimer</code>类的声明，并将<code>WidgetTimer</code>类的具体定义移至实现文件中，从而降低<code>Widget</code>的编译依存性。</li></ol><p>然而private继承并非完全一无是处，一个适用于它的极端情况是<strong>空白基类最优化（empty base optimization，EBO）</strong>，参考以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个没有非静态成员变量、虚函数的类，看似不需要任何存储空间，但实际上 C++ 规定凡是独立对象都必须有非零大小，因此此处<code>sizeof(HoldsAnInt)</code>必然大于<code>sizeof(int)</code>，通常会多出一字节大小，但有时考虑到内存对齐之类的要求，可能会多出更多的空间。</p><p>使用private继承可以避免产生额外存储空间，将上面的代码替代为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span> : <span class="keyword">private</span> Empty &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><p>多重继承是一个可能会造成很多歧义和误解的设计，因此反对它的声音此起彼伏，下面我们来接触几个使用多重继承的场景。</p><p>最先需要认清的一件事是，程序有可能从一个以上的基类继承相同名称，那会导致较多的歧义机会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheckOut</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheckOut</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span> : <span class="keyword">public</span> BorrowableItem, <span class="keyword">public</span> ElectronicGadget &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">CheckOut</span>();          <span class="comment">// MP3Player::CheckOut 不明确！</span></span><br></pre></td></tr></table></figure><p>如果真遇到这种情况，必须明确地指出要调用哪一个基类中的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.BorrowableItem::<span class="built_in">CheckOut</span>();      <span class="comment">// 使用 BorrowableItem::CheckOut</span></span><br></pre></td></tr></table></figure><p>在使用多重继承时，我们可能会遇到要命的“钻石型继承（菱形继承）”：</p><p><img src="https://pic3.zhimg.com/80/v2-882fec69eb599914ab430741992742ca_720w.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span> : <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这时候必须面对这样一个问题：是否打算让基类内的成员变量经由每一条路径被复制？如果不想要这样，应当使用虚继承，指出其愿意共享基类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span> : <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>然而由于虚继承会在派生类中额外存储信息来确认成员来自于哪个基类，虚继承通常会付出更多空间和速度的代价，并且由于虚基类的初始化责任是由继承体系中最底层的派生类负责，就导致了虚基类必须认知其虚基类并且承担虚基类的初始化责任。因此我们应当遵循以下两个建议：</p><ol><li>非必要不使用虚继承。</li><li>如果必须使用虚继承，尽可能避免在虚基类中放置数据。</li></ol><p>多重继承可用于结合public继承和private继承，public继承用于提供接口，private继承用于提供实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPerson 类指出要实现的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">BirthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseID</span> &#123;  ...  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PersonInfo 类有若干已实现的函数</span></span><br><span class="line"><span class="comment">// 可用以实现 IPerson 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">TheName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">TheBirthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimOpen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPerson 类使用多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPerson</span>: <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CPerson</span><span class="params">(DatabaseID pid)</span>: PersonInfo(pid) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;       <span class="comment">// 实现必要的 IPerson 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">TheName</span>();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">BirthDate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 实现必要的 IPerson 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">TheBirthDate</span>();  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重新定义继承而来的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimOpen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimClose</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第七章：模板与泛型编程"><a href="#第七章：模板与泛型编程" class="headerlink" title="第七章：模板与泛型编程"></a>第七章：模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><p>类与模板都支持接口和多态。对于类而言接口是显式的，以函数签名为中心，多态则是通过虚函数发生于运行期；而对模板参数而言，接口是隐式的，奠基于有效表达式，多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</p><p>考虑以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>以上代码中，<code>T</code>类型的隐式接口要求：</p><ol><li>提供一个名为<code>size</code>的成员函数，该函数的返回值可与<code>int</code>（10 的类型）执行<code>operator&gt;</code>，或经过隐式转换后可执行<code>operator&gt;</code>。</li><li>必须支持一个<code>operator!=</code>函数，接受<code>T</code>类型和<code>someNastyWidget</code>的类型，或其隐式转换后得到的类型。</li></ol><blockquote><p>此处没有考虑<code>operator&amp;&amp;</code>被重载的可能性。</p></blockquote><p>加诸于模板参数身上的隐式接口，就像加诸于类对象身上的显式接口“一样真实”，两者都在编译期完成检查，你无法在模板中使用“不支持模板所要求之隐式接口”的对象（代码无法通过编译）。</p><h3 id="条款-42：了解-typename-的双重含义"><a href="#条款-42：了解-typename-的双重含义" class="headerlink" title="条款 42：了解 typename 的双重含义"></a>条款 42：了解 typename 的双重含义</h3><p>在模板声明式中，使用<code>class</code>和<code>typename</code>关键字并没有什么不同，但在模板内部，<code>typename</code>拥有更多的一重含义。</p><p>理解：为了方便解释，我们首先需要引入一个模板相关的概念：模板内出现的名称如果相依于某个模板参数，我们称之为<strong>从属名称（dependent names）</strong>；如果从属名称在类内呈嵌套状，我们称之为<strong>嵌套从属名称（nested dependent name）</strong>；如果一个名称并不倚赖任何模板参数的名称，我们称之为<strong>非从属名称（non-dependent names）</strong>。</p><p>考虑以下模板代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="type">int</span> value = *iter;</span><br><span class="line">        std::cout &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来没有任何问题，但实际编译时却会报错，这一切的罪魁祸首便是<code>C::const_iterator</code>。此处的<code>C::const_iterator</code>是一个指向某类型的<strong>嵌套从属类型名称（nested dependent type name）</strong>，而嵌套从属名称可能会导致解析困难，因为在编译器知道<code>C</code>是什么之前，没有任何办法知道<code>C::const_iterator</code>是否为一个类型，这就导致出现了歧义状态，而 C++ 默认假设嵌套从属名称不是类型名称。</p><p>显式指明嵌套从属类型名称的方法就是将<code>typename</code>关键字作为其前缀词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br></pre></td></tr></table></figure><p>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2nd</span><span class="params">(<span class="type">const</span> C&amp; container, <span class="type">const</span> <span class="keyword">typename</span> C::iterator iter)</span></span>;</span><br></pre></td></tr></table></figure><p>这一规则的例外是，<code>typename</code>不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;    <span class="comment">// 基类列表中不允许使用 typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x) &#123;</span>                 <span class="comment">// 成员初始化列表中不允许使用 typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类型名称过于复杂时，可以使用<code>using</code>或<code>typedef</code>来进行简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> value_type = <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type;</span><br></pre></td></tr></table></figure><h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p>在模板编程中，模板类的继承并不像普通类那么自然，考虑以下情形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SendClear</span>(info);        <span class="comment">// 调用基类函数，这段代码无法通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显，由于直到模板类被真正实例化之前，编译器并不知道<code>MsgSender&lt;Company&gt;</code>具体长什么样，有可能它是一个全特化的版本，而在这个版本中不存在<code>SendClear</code>函数。由于 C++ 的设计策略是宁愿较早进行诊断，所以编译器会拒绝承认在基类中存在一个<code>SendClear</code>函数。</p><p>为了解决这个问题，我们需要令 C++“进入模板基类观察”的行为生效，有三种办法达成这个目标：</p><p>第一种：在基类函数调用动作之前加上<code>this-&gt;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">SendClear</span>(info);</span><br></pre></td></tr></table></figure><p>第二种：使用<code>using</code>声明式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MsgSender&lt;Company&gt;::SendClear;</span><br><span class="line"><span class="built_in">SendClear</span>(info);</span><br></pre></td></tr></table></figure><p>第三种：明白指出被调用的函数位于基类内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MsgSender&lt;Company&gt;::<span class="built_in">SendClear</span>(info);</span><br></pre></td></tr></table></figure><p>第三种做法是最不令人满意的，如果被调用的是虚函数，上述的明确资格修饰（explicit qualification）会使“虚函数绑定行为”失效。</p><h3 id="条款-44：将与参数无关的代码抽离模板"><a href="#条款-44：将与参数无关的代码抽离模板" class="headerlink" title="条款 44：将与参数无关的代码抽离模板"></a>条款 44：将与参数无关的代码抽离模板</h3><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（code bloat），生成浮夸的二进制目标码。</p><p>基于<strong>共性和变性分析（commonality and variability analysis）</strong> 的方法，我们需要分析模板中重复使用的部分，将其抽离出模板，以减轻模板具现化带来的代码量。</p><ul><li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li><li>因类型模板参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的具现类型共享实现代码。</li></ul><p>参考以下矩阵类的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;  <span class="comment">// private 继承实现，见条款 39</span></span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::Invert;              <span class="comment">// 避免掩盖基类函数，见条款 33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">Invert</span>(n); &#125;              <span class="comment">// 调用模板基类函数，见条款 43</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Invert</code>并不是我们唯一要使用的矩阵操作函数，而且每次都往基类传递矩阵尺寸显得太过繁琐，我们可以考虑将数据放在派生类中，在基类中储存指针和矩阵尺寸。修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T* pMem)</span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data.<span class="built_in">data</span>()) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而这种做法并非永远能取得优势，硬是绑着矩阵尺寸的那个版本，有可能生成比共享版本更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化；而在共享版本中，不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小，也就因此降低程序的 working set（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（locality of reference），这些都可能使程序执行得更快速。究竟哪个版本更佳，只能经由具体的测试后决定。</p><p>同样地，上面的代码也使用到了牺牲封装性的<code>protected</code>，可能会导致资源管理上的混乱和复杂，考虑到这些，也许一点点模板代码的重复并非不可接受。</p><h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><p>C++ 视模板类的不同具现体为完全不同的的类型，但在泛型编程中，我们可能需要一个模板类的不同具现体能够相互类型转换。</p><p>考虑设计一个智能指针类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。很显然，我们需要的是模板拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">        : heldPtr(other.get()) &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(U* p)</span></span></span><br><span class="line"><span class="function">        : heldPtr(p) &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>get</code>获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</p><p>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r);                <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;             <span class="comment">// 泛化拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r);     <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);  <span class="comment">// 泛化拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>该条款与条款 24 一脉相承，还是使用原先的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;     <span class="comment">// 无法通过编译！</span></span><br></pre></td></tr></table></figure><p>上述失败启示我们：模板实参在推导过程中，从不将隐式类型转换纳入考虑。虽然以<code>oneHalf</code>推导出<code>Rational&lt;int&gt;</code>类型是可行的，但是试图将<code>int</code>类型隐式转换为<code>Rational&lt;T&gt;</code>是绝对会失败的。</p><p>由于模板类并不依赖模板实参推导，所以编译器总能够在<code>Rational&lt;T&gt;</code>具现化时得知<code>T</code>，因此我们可以使用友元声明式在模板类内指涉特定函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在模板类内，模板名称可被用来作为“模板及其参数”的简略表达形式，因此下面的写法也是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>时，<code>Rational&lt;int&gt;</code>类于是被具现化出来，而作为过程的一部分，友元函数<code>operator*</code>也就被自动声明出来，其为一个普通函数而非模板函数，因此在接受参数时可以正常执行隐式转换。</p><p>为了使程序能正常链接，我们需要为其提供对应的定义式，最简单有效的方法就是直接合并至声明式处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使<code>operator*</code>调用类外的辅助模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">DoMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DoMultiply</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>traits classes 可以使我们在编译期就能获取某些类型信息，它被广泛运用于 C++ 标准库中。traits 并不是 C++ 关键字或一个预先定义好的构件：它们是一种技术，也是 C++ 程序员所共同遵守的协议，并要求对用户自定义类型和内置类型表现得一样好。</p><p>设计并实现一个 trait class 的步骤如下：</p><ol><li>确认若干你希望将来可取得的类型相关信息。</li><li>为该类型选择一个名称。</li><li>提供一个模板和一组特化版本，内含你希望支持的类型相关信息。</li></ol><p>以迭代器为例，标准库中拥有多种不同的迭代器种类，它们各自拥有不同的功用和限制：</p><ol><li><code>input_iterator_tag</code>：单向输入迭代器，只能向前移动，一次一步，客户只可读取它所指的东西。</li><li><code>output_iterator_tag</code>：单向输出迭代器，只能向前移动，一次一步，客户只可写入它所指的东西。</li><li><code>forward_iterator_tag</code>：单向访问迭代器，只能向前移动，一次一步，读写均允许。</li><li><code>bidirectional_iterator_tag</code>：双向访问迭代器，去除了只能向前移动的限制。</li><li><code>random_access_iterator_tag</code>：随机访问迭代器，没有一次一步的限制，允许随意移动，可以执行“迭代器算术”。</li></ol><p>标准库为这些迭代器种类提供的卷标结构体（tag struct）的继承关系如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : input_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : forward_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>将<code>iterator_category</code>作为迭代器种类的名称，嵌入容器的迭代器中，并且确认使用适当的卷标结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = random_access_iterator;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = bidirectional_iterator;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了做到类型的 traits 信息可以在类型自身之外获得，标准技术是把它放进一个模板及其一个或多个特化版本中。这样的模板在标准库中有若干个，其中针对迭代器的是<code>iterator_traits</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">IterT</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = IterT::iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了支持指针迭代器，<code>iterator_traits</code>特别针对指针类型提供一个偏特化版本，而指针的类型和随机访问迭代器类似，所以可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">IterT</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们需要为不同的迭代器种类应用不同的代码时，traits classes 就派上用场了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DisT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(std::iterator_traits&lt;IterT&gt;::iterator_category)</span><br><span class="line">        == <span class="built_in">typeid</span>(std::random_access_iterator_tag)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这些代码实际上是错误的，我们希望类型的判断能在编译期完成。<code>iterator_category</code>是在编译期决定的，然而<code>if</code>却是在运行期运作的，无法达成我们的目标。</p><p>在 C++17 之前，解决这个问题的主流做法是利用函数重载（也是原书中介绍的做法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DisT d, std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DisT d, std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DisT d, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);       <span class="comment">// 单向迭代器不允许负距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DisT d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++17 之后，我们有了更简单有效的做法——使用<code>if constexpr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Advance</span><span class="params">(IterT&amp; iter, DisT d)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">typeid</span>(std::iterator_traits&lt;IterT&gt;::iterator_category)</span></span></span><br><span class="line"><span class="params"><span class="function">        == <span class="keyword">typeid</span>(std::random_access_iterator_tag))</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款-48：认识模板元编程"><a href="#条款-48：认识模板元编程" class="headerlink" title="条款 48：认识模板元编程"></a>条款 48：认识模板元编程</h3><p>模板元编程（Template metaprogramming，TMP）是编写基于模板的 C++ 程序并执行于编译期的过程，它并不是刻意被设计出来的，而是当初 C++ 引入模板带来的副产品，事实证明模板元编程具有强大的作用，并且现在已经成为 C++ 标准的一部分。实际上，在条款 47 中编写 traits classes 时，我们就已经在进行模板元编程了。</p><p>由于模板元程序执行于 C++ 编译期，因此可以将一些工作从运行期转移至编译期，这可以帮助我们在编译期时发现一些原本要在运行期时才能察觉的错误，以及得到较小的可执行文件、较短的运行期、较少的内存需求。当然，副作用就是会使编译时间变长。</p><p>模板元编程已被证明是“图灵完备”的，并且以“函数式语言”的形式发挥作用，因此在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由 <strong>“递归模板具现化（recursive template instantiation）”</strong> 实现的。</p><p>常用于引入模板元编程的例子是在编译期计算阶乘：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;            <span class="comment">// Factorial&lt;n&gt; = n * Factorial&lt;n-1&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;           <span class="comment">// 处理特殊情况：Factorial&lt;0&gt; = 1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;</span><br></pre></td></tr></table></figure><p>模板元编程很酷，但对其进行调试可能是灾难性的，因此在实际应用中并不常见。我们可能会在下面几种情形中见到它的出场：</p><ol><li>确保量度单位正确。</li><li>优化矩阵计算。</li><li>可以生成客户定制之设计模式（custom design pattern）实现品。</li></ol><h2 id="第八章：定制-new-和-delete"><a href="#第八章：定制-new-和-delete" class="headerlink" title="第八章：定制 new 和 delete"></a>第八章：定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的 <strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">using</span> new_handler = <span class="built_in">void</span>(*)();</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="keyword">noexcept</span></span>;    <span class="comment">// 返回值为原来持有的 new-handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个设计良好的 new-handler 函数必须做以下事情之一：</p><p><strong>让更多的内存可被使用：</strong> 可以让程序一开始执行就分配一大块内存，而后当 new-handler 第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p><p><strong>安装另一个 new-handler：</strong> 如果目前这个 new-handler 无法取得更多内存，可以调换为另一个可以完成目标的 new-handler（令 new-handler 修改“会影响 new-handler 行为”的静态或全局数据）。</p><p><strong>卸除 new-handler：</strong> 将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p><p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong> 这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p><p><strong>不返回：</strong> 通常调用<code>std::abort</code>或<code>std::exit</code>。</p><p>有的时候我们或许会希望在为不同的类分配对象时，使用不同的方式处理内存分配失败情况。这时候使用静态成员是不错的选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做和 std::set_new_handler 相同的事情</span></span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> globalHandler = std::<span class="built_in">set_new_handler</span>(currentHandler);  <span class="comment">// 切换至 Widget 的专属 new-handler</span></span><br><span class="line">    <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);                           <span class="comment">// 分配内存或抛出异常</span></span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(globalHandler);                        <span class="comment">// 切换回全局的 new-handler</span></span><br><span class="line">    <span class="keyword">return</span> globalHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutOfMem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(OutOfMem);</span><br><span class="line"><span class="keyword">auto</span> pw1 = <span class="keyword">new</span> Widget;              <span class="comment">// 若分配失败，则调用 OutOfMem</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> pw2 = <span class="keyword">new</span> Widget;              <span class="comment">// 若分配失败，则抛出异常</span></span><br></pre></td></tr></table></figure><p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;       <span class="comment">// “mixin”风格的基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    ...                         <span class="comment">// 其它的 operator new 版本，见条款 52</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> globalHandler = std::<span class="built_in">set_new_handler</span>(currentHandler);</span><br><span class="line">    <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line">    <span class="keyword">return</span> globalHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...                         <span class="comment">// 不必再声明 set_new_handler 和 operator new</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的<code>currentHandler</code>。</p><p>这个做法用到了所谓的 <strong>CRTP（curious recurring template pattern，奇异递归模板模式）</strong> ，除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Implementation</span>();      <span class="comment">// 在基类中暴露接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Implementation</span><span class="params">()</span></span>;                                  <span class="comment">// 在派生类中提供实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了会调用 new-handler 的<code>operator new</code>以外，C++ 还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为 nothrow new，通过<code>std::nothrow</code>对象来使用它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;                   <span class="comment">// 如果分配失败，抛出 bad_alloc</span></span><br><span class="line"><span class="keyword">if</span> (pw1 == <span class="literal">nullptr</span>) ...                     <span class="comment">// 这个测试一定失败</span></span><br><span class="line"></span><br><span class="line">Widget* pw2 = <span class="built_in">new</span> (std::nothrow) Widget;    <span class="comment">// 如果分配失败，返回空指针</span></span><br><span class="line"><span class="keyword">if</span> (pw2 == <span class="literal">nullptr</span>) ...                     <span class="comment">// 这个测试可能成功</span></span><br></pre></td></tr></table></figure><p>nothrow new 对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此实际上并没有使用 nothrow new 的必要。</p><h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p><p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete 掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete 则会导致未定义行为。如果令<code>operator new</code>持有一串动态分配所得地址，而<code>operator delete</code>将地址从中移除，就很容易检测出上述错误用法。此外各式各样的编程错误可能导致 <strong>“overruns”（写入点在分配区块尾端之后）</strong> 和 <strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的 byte pattern 签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> signature = <span class="number">0xDEADBEEF</span>;              <span class="comment">// 调试“魔数”</span></span><br><span class="line"><span class="keyword">using</span> Byte = <span class="type">unsigned</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">size_t</span> realSize = size + <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>);         <span class="comment">// 分配额外空间以塞入两个签名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* pMem = <span class="built_in">malloc</span>(realSize);                    <span class="comment">// 调用 malloc 取得内存</span></span><br><span class="line">    <span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将签名写入内存的起点和尾端</span></span><br><span class="line">    *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">    *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="built_in">sizeof</span>(<span class="type">int</span>))) = signature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="built_in">sizeof</span>(<span class="type">int</span>);    <span class="comment">// 返回指针指向第一个签名后的内存位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这段代码不能保证内存对齐，并且有许多地方不遵守 C++ 规范，我们将在条款 51 中进行详细讨论。</p><p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete 动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p><p><strong>为了增加分配和归还的速度：</strong> 泛用型分配器往往（虽然并非总是）比定制型分配器慢，特别是当定制型分配器专门针对某特定类型之对象设计时。类专属的分配器可以做到“区块尺寸固定”，例如 Boost 提供的 Pool 程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p><p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong> 泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上招引某些额外开销。针对小型对象而开发的分配器（例如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p><p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimal alignment）：</strong> 许多计算机体系架构要求特定的类型必须放在特定的内存地址上，如果没有奉行这个约束条件，可能导致运行期硬件异常，或者访问速度变低。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。</p><p>在 C++11 中，提供了以下内存对齐相关方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alignas 用于指定栈上数据的内存对齐要求</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) testStruct &#123; <span class="type">double</span> data; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(std::<span class="type">max_align_t</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::alignment_of&lt;std::<span class="type">max_align_t</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span></span><br><span class="line"><span class="type">char</span> buffer[] = <span class="string">&quot;memory alignment&quot;</span>;</span><br><span class="line"><span class="type">void</span>* ptr = buffer;</span><br><span class="line">std::<span class="type">size_t</span> space = <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">align</span>(<span class="built_in">alignof</span>(<span class="type">int</span>), <span class="built_in">sizeof</span>(<span class="type">char</span>), ptr, space);</span><br></pre></td></tr></table></figure><p>在 C++17 后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> count, std::<span class="type">align_val_t</span> al)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>为了将相关对象成簇集中：</strong> 如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（page faults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用 placement new 达成这个目标（见条款 52）。</p><p><strong>为了获得非传统的行为：</strong> 有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（shared memory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++ 的外壳里，写在定制的 new 和 delete 中。</p><h3 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 new 和 delete 时需固守常规</h3><p>我们在条款 49 中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用 new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++ 还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p><p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)      <span class="comment">// 处理0字节申请</span></span><br><span class="line">        size = <span class="number">1</span>;       <span class="comment">// 将其视为1字节申请</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...)        <span class="comment">// 如果分配成功</span></span><br><span class="line">            <span class="keyword">return</span> ...; <span class="comment">// 返回指针指向分配得到的内存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果分配失败，调用目前的 new-handler</span></span><br><span class="line">        <span class="keyword">auto</span> globalHandler = <span class="built_in">get_new_handler</span>(); <span class="comment">// since C++11</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类可以使用其基类的 new 分配方式，但派生类和基类的大小很多时候是不同的。</p><p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);    <span class="comment">// 转交给标准的 operator new 进行处理</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款 39 中我们提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p><p>如果你打算实现<code>operator new[]</code>，即所谓的 array new，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对 array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个 array 将含有多少元素对象。</p><p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是 C++ 保证 <strong>“删除空指针永远安全”</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还 rawMemory 所指的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;    <span class="comment">// 转交给标准的 operator delete 进行处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还 rawMemory 所指的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么 C++ 传给<code>operator delete</code>的<code>size</code>大小可能不正确，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款 7 的补充。</p><h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a>条款 52：写了 placement new 也要写 placement delete</h3><p>placement new 最初的含义指的是“接受一个指针指向对象该被构造之处”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在 vector 的未使用空间上创建对象，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* pMemory)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>我们此处要讨论的是广义上的 placement new，即带有附加参数的<code>operator new</code>，例如下面这种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, std::ostream&amp; logStream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pw = <span class="built_in">new</span> (std::cerr) Widget;</span><br></pre></td></tr></table></figure><p>当我们在使用 new 表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由 C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p><p>这一切的前提是 C++ runtime 能够找到<code>operator new</code>对应的<code>operator delete</code>，如果我们使用的是自定义的 placement new，而没有为其准备对应的 placement delete 的话，就无法避免发生内存泄漏。因此，合格的代码应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span>;   <span class="comment">// placement new</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span></span>;                             <span class="comment">// delete 时调用的正常 operator delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, std::ostream&amp; logStream)</span></span>;    <span class="comment">// placement delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款 33），所以提供 placement new 会导致无法使用正常版本的<code>operator new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pb = <span class="keyword">new</span> Base;             <span class="comment">// 无法通过编译！</span></span><br><span class="line"><span class="keyword">auto</span> pb = <span class="built_in">new</span> (std::cerr) Base; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pd = <span class="built_in">new</span> (std::clog) Derived;  <span class="comment">// 无法通过编译！</span></span><br><span class="line"><span class="keyword">auto</span> pd = <span class="keyword">new</span> Derived;              <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用，除非你的意图就是阻止客户使用它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">operator</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;           <span class="comment">// normal new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">operator</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>*)</span> <span class="keyword">noexcept</span></span>;                 <span class="comment">// placement new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">operator</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// nothrow new</span></span><br></pre></td></tr></table></figure><p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和 delete：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StadardNewDeleteForms</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// placement new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory, ptr)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; nt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size,nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款 33）取得标准形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> StandardNewDeleteForms&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">detele</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第九章：杂项讨论"><a href="#第九章：杂项讨论" class="headerlink" title="第九章：杂项讨论"></a>第九章：杂项讨论</h2><h3 id="条款-53：不要轻忽编译器的警告"><a href="#条款-53：不要轻忽编译器的警告" class="headerlink" title="条款 53：不要轻忽编译器的警告"></a>条款 53：不要轻忽编译器的警告</h3><ol><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li><li>不要过度依赖编译器的警告能力，因为不同的编译器对待事情的态度不同。一旦移植到另一个编译器上，你原本依赖的警告信息可能会消失。</li></ol><h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款-54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款 54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><p>如今 TR1 草案已完全融入 C++ 标准当中，没有再过多了解 TR1 标准库的必要。</p><h3 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h3><p>Boost 是若干个程序库的集合，并且当中的许多库已经被 C++ 吸纳为标准库的一部分。不过在现在的 Modern C++ 时代，是否该在项目中使用 Boost 仍然有一定的争议，一些 Boost 组件并无法做到像 C++ 标准库那样高性能，零开销抽象，但毫无疑问的是，Boost 的参考价值是无法忽视的，你可以在 Boost 中找到许多非常值得学习和借鉴的实现。</p>]]></content>
    
    
    <summary type="html">《Effectivate C++》</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/categories/Cpp/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Modern Cpp</title>
    <link href="https://penge666.github.io/posts/af408df9.html"/>
    <id>https://penge666.github.io/posts/af408df9.html</id>
    <published>2024-04-10T07:58:11.000Z</published>
    <updated>2024-04-11T07:02:38.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链接地址：<a href="https://changkun.de/modern-cpp/">https://changkun.de/modern-cpp/</a></p><p>一本非常好上手的现代cpp教材，早在去年的时候在参加OceanBase比赛的时候室友推荐的学习资料。</p><h1 id="第-1-章-迈向现代-C"><a href="#第-1-章-迈向现代-C" class="headerlink" title="第 1 章 迈向现代 C++"></a>第 1 章 迈向现代 C++</h1><p><strong>编译环境</strong>：本书将使用 <code>clang++</code> 作为唯一使用的编译器，同时总是在代码中使用 <code>-std=c++2a</code> 编译标志。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&gt;</span> <span class="string">clang++ -v</span></span><br><span class="line"><span class="attribute">Apple LLVM version 10.0.1 (clang-1001.0.46.4)</span></span><br><span class="line"><span class="attribute">Target</span><span class="punctuation">:</span> <span class="string">x86_64-apple-darwin18.6.0</span></span><br><span class="line"><span class="attribute">Thread model</span><span class="punctuation">:</span> <span class="string">posix</span></span><br><span class="line"><span class="attribute">InstalledDir</span><span class="punctuation">:</span> <span class="string">/Library/Developer/CommandLineTools/usr/bin</span></span><br></pre></td></tr></table></figure><h2 id="1-1-被弃用的特性"><a href="#1-1-被弃用的特性" class="headerlink" title="1.1 被弃用的特性"></a>1.1 被弃用的特性</h2><p>在学习现代 C++ 之前，我们先了解一下从 C++11 开始，被弃用的主要特性：</p><blockquote><p><strong>注意</strong>：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。</p></blockquote><ul><li><p><strong>不再允许字符串字面值常量赋值给一个 <code>char \*</code>。如果需要用字符串字面值常量赋值和初始化一个 <code>char \*</code>，应该使用 <code>const char \*</code> 或者 <code>auto</code>。</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> *<span class="built_in">str</span> = <span class="string">&quot;hello world!&quot;</span>; <span class="comment">// 将出现弃用警告</span></span><br></pre></td></tr></table></figure></li><li><p><strong>C++98 异常说明、 <code>unexpected_handler</code>、<code>set_unexpected()</code> 等相关特性被弃用，应该使用 <code>noexcept</code>。</strong></p></li><li><p><strong><code>auto_ptr</code> 被弃用，应使用 <code>unique_ptr</code>。</strong></p></li><li><p><strong><code>register</code> 关键字被弃用，可以使用但不再具备任何实际含义。</strong></p></li><li><p><strong><code>bool</code> 类型的 <code>++</code> 操作被弃用。</strong></p></li><li><p><strong>如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。</strong></p></li><li><p><strong>C 语言风格的类型转换被弃用（即在变量前使用 <code>(convert_type)</code>），应该使用 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 来进行类型转换。</strong></p></li><li><p><strong>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>、<code>&lt;cstdalign&gt;</code>、<code>&lt;cstdbool&gt;</code> 与 <code>&lt;ctgmath&gt;</code> 等</strong></p></li><li><p>……等等</p></li></ul><p>还有一些其他诸如参数绑定（C++11 提供了 <code>std::bind</code> 和 <code>std::function</code>）、<code>export</code> 等特性也均被弃用。前面提到的这些特性<strong>如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠拢</strong>，直接学习新特性。毕竟，技术是向前发展的。</p><h2 id="1-2-与-C-的兼容性"><a href="#1-2-与-C-的兼容性" class="headerlink" title="1.2 与 C 的兼容性"></a>1.2 与 C 的兼容性</h2><p>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码（甚至古老的 C 语言代码），例如 Linux 系统调用。在现代 C++ 出现之前，大部分人当谈及『C 与 C++ 的区别是什么』时，普遍除了回答面向对象的类特性、泛型编程的模板特性外，就没有其他的看法了，甚至直接回答『差不多』，也是大有人在。图 1.2 中的韦恩图大致上回答了 C 和 C++ 相关的兼容情况。</p><p><img src="https://changkun.de/modern-cpp/assets/figures/comparison.png" alt="图 1.2: C 和 C++ 互相兼容情况"></p><p>和 C++ 互相兼容情况</p><p>从现在开始，你的脑子里应该树立『<strong>C++ 不是 C 的一个超集</strong>』这个观念（而且从一开始就不是，后面的<a href="https://changkun.de/modern-cpp/zh-cn/01-intro/#进一步阅读的参考文献">进一步阅读的参考文献</a>中给出了 C++98 和 C99 之间的区别）。在编写 C++ 时，也应该尽可能的避免使用诸如 <code>void*</code> 之类的程序风格。而在不得不使用 C 时，应该注意使用 <code>extern &quot;C&quot;</code> 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    [out = std::<span class="built_in">ref</span>(std::cout &lt;&lt; <span class="string">&quot;Result from C code: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>))]()&#123;</span><br><span class="line">        out.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应先使用 <code>gcc</code> 编译 C 语言的代码：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> foo.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>编译出 <code>foo.o</code> 文件，再使用 <code>clang++</code> 将 C++ 代码和 <code>.o</code> 文件链接起来（或者都编译为 <code>.o</code> 再统一链接）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clang</span>++ <span class="number">1</span>.<span class="number">1</span>.cpp foo.o -std=c++<span class="number">2</span>a -o <span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>当然，你可以使用 <code>Makefile</code> 来编译上面的代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C = gcc</span><br><span class="line">CXX = clang++</span><br><span class="line"></span><br><span class="line">SOURCE_C = foo.c</span><br><span class="line">OBJECTS_C = foo.o</span><br><span class="line"></span><br><span class="line">SOURCE_CXX = 1.1.cpp</span><br><span class="line"></span><br><span class="line">TARGET = 1.1</span><br><span class="line">LDFLAGS_COMMON = -std=c++2a</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="variable">$(C)</span> -c <span class="variable">$(SOURCE_C)</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(SOURCE_CXX)</span> <span class="variable">$(OBJECTS_C)</span> <span class="variable">$(LDFLAGS_COMMON)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Makefile</code> 中的缩进是制表符而不是空格符，如果你直接复制这段代码到你的编辑器中，制表符可能会被自动替换掉，请自行确保在 <code>Makefile</code> 中的缩进是由制表符完成的。</p><p>如果你还不知道 <code>Makefile</code> 的使用也没有关系，本教程中不会构建过于复杂的代码，简单的在命令行中使用 <code>clang++ -std=c++2a</code> 也可以阅读本书。</p></blockquote><p>如果你是首次接触现代 C++，那么你很可能还看不懂上面的那一小段代码，即：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">out</span> = <span class="keyword">std</span>::ref(<span class="keyword">std</span>::cout &lt;&lt; <span class="string">&quot;Result from C code: &quot;</span> &lt;&lt; <span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>))]()&#123;</span><br><span class="line">    <span class="keyword">out</span>.get() &lt;&lt; <span class="string">&quot;.\n&quot;</span><span class="comment">;</span></span><br><span class="line">&#125;()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>不必担心，本书的后续章节将为你介绍这一切。</p><h1 id="第-2-章-语言可用性的强化"><a href="#第-2-章-语言可用性的强化" class="headerlink" title="第 2 章 语言可用性的强化"></a>第 2 章 语言可用性的强化</h1><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及<strong>语言可用性</strong>，是指那些发生在运行时之前的语言行为。</p><h2 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h2><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code> 出现的目的是为了替代 <code>NULL</code>。在某种意义上来说，传统 C++ 会把 <code>NULL</code>、<code>0</code> 视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将 <code>NULL</code> 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 <code>0</code>。</p><p>C++ <strong>不允许</strong>直接将 <code>void *</code> 隐式转换到其他类型。但如果编译器尝试把 <code>NULL</code> 定义为 <code>((void*)0)</code>，那么在下面这句代码中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *ch <span class="operator">=</span> NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>没有了 <code>void *</code> 隐式转换的 C++ 只好将 <code>NULL</code> 定义为 <code>0</code>。而这依然会产生新的问题，将 <code>NULL</code> 定义成 <code>0</code> 将导致 <code>C++</code> 中重载特性发生混乱。考虑下面这两个 <code>foo</code> 函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直觉。</p><p>为了解决这个问题，C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。而 <code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>你可以尝试使用 <code>clang++</code> 编译下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="type">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), std::<span class="type">nullptr_t</span>&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>);          <span class="comment">// 调用 foo(int)</span></span><br><span class="line">    <span class="comment">// foo(NULL);    // 该行不能通过编译</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);    <span class="comment">// 调用 foo(char*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(char*) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="type">int</span>) <span class="keyword">is</span> <span class="keyword">called</span></span><br><span class="line">foo(<span class="type">char</span>*) <span class="keyword">is</span> <span class="keyword">called</span></span><br></pre></td></tr></table></figure><p>从输出中我们可以看出，<code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p><p>此外，在上面的代码中，我们使用了 <code>decltype</code> 和 <code>std::is_same</code> 这两个属于现代 C++ 的语法，简单来说，<code>decltype</code> 用于类型推导，而 <code>std::is_same</code> 用于比较两个类型是否相同，我们会在后面 <a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#decltype">decltype</a> 一节中详细讨论。</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr_1[<span class="number">10</span>];                      <span class="comment">// 合法</span></span><br><span class="line">    <span class="type">char</span> arr_2[LEN];                     <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// char arr_3[len];                  // 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// char arr_4[len_2];                // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_4[len_2_constexpr];         <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char arr_5[len_foo()+5];          // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_6[<span class="built_in">len_foo_constexpr</span>() + <span class="number">1</span>]; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p><blockquote><p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p></blockquote><p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p><p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="built_in">int</span> fibonacci(const <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">    return <span class="built_in">n</span> == <span class="number">1</span> || <span class="built_in">n</span> == <span class="number">2</span> ? <span class="number">1</span> <span class="symbol">:</span> fibonacci(<span class="built_in">n</span>-<span class="number">1</span>)+fibonacci(<span class="built_in">n</span>-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 C++14 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr int <span class="built_in">fibonacci</span>(const int n) &#123;</span><br><span class="line">    <span class="built_in">if</span>(n == <span class="number">1</span>) return <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span>(n == <span class="number">2</span>) return <span class="number">1</span>;</span><br><span class="line">    return <span class="built_in">fibonacci</span>(n-<span class="number">1</span>) + <span class="built_in">fibonacci</span>(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="built_in">int</span> fibonacci(const <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">    return <span class="built_in">n</span> == <span class="number">1</span> || <span class="built_in">n</span> == <span class="number">2</span> ? <span class="number">1</span> <span class="symbol">:</span> fibonacci(<span class="built_in">n</span>-<span class="number">1</span>) + fibonacci(<span class="built_in">n</span>-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h2><h3 id="if-switch-变量声明强化"><a href="#if-switch-变量声明强化" class="headerlink" title="if/switch 变量声明强化"></a>if/switch 变量声明强化</h3><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 <code>for</code> 语句内能够声明一个临时变量 <code>int</code>，但始终没有办法在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 c++17 之前</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要重新定义一个新的变量</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr2 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr2 != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出 1, 4, 3, 4</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator element = vec.<span class="built_in">begin</span>(); element != vec.<span class="built_in">end</span>(); </span><br><span class="line">        ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们可以看到 <code>itr</code> 这一变量是定义在整个 <code>main()</code> 的作用域内的，这导致当我们需要再次遍历整个 <code>std::vector</code> 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可以在 <code>if</code>（或 <code>switch</code>）中完成这一操作：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="symbol">if</span> (const std::vector&lt;int&gt;::iterator <span class="keyword">itr</span> = std::find(vec.begin(), vec<span class="meta">.end</span>(), <span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">itr</span> != vec<span class="meta">.end</span>()) &#123;</span><br><span class="line">    *<span class="keyword">itr</span> = <span class="number">4</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，是不是和 Go 语言很像？</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。 在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 <code>&#123;&#125;</code> 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。 这些不同方法都针对各自对象，不能通用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value_a;</span><br><span class="line">    <span class="type">int</span> value_b;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">value_a</span>(a), <span class="built_in">value_b</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before C++11</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0]: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo:&quot;</span> &lt;&lt; foo.value_a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; foo.value_b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">             it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after C++11</span></span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = magicFoo.vec.<span class="built_in">begin</span>(); </span><br><span class="line">        it != magicFoo.vec.<span class="built_in">end</span>(); ++it) </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p><p>初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">            it != list.<span class="built_in">end</span>(); ++it) vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.<span class="built_in">foo</span>(&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure><p>其次，C++11 还提供了统一的语法来初始化任意的对象，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Foo</span> foo2 &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>auto</code> 类型推导会在 <a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#auto">auto 类型推导</a>一节中进行介绍。</p><h2 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h2><p>在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长。</p><p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto</code> 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 <code>register</code> 并存。在传统 C++ 中，如果一个变量没有声明为 <code>register</code> 变量，将自动被视为一个 <code>auto</code> 变量。而随着 <code>register</code> 被弃用（在 C++17 中作为保留关键字，以后使用，目前不具备实际意义），对 <code>auto</code> 的语义变更也就非常自然了。</p><p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到了传统 C++ 中冗长的迭代写法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 之前</span></span><br><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// 所以 it 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;int&gt;::const_iterator it = <span class="built_in">vec</span>.<span class="built_in">cbegin</span>(); it != <span class="built_in">vec</span>.<span class="built_in">cend</span>(); ++it)</span><br></pre></td></tr></table></figure><p>而有了 <code>auto</code> 之后可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="comment">// 从 C++11 起, 使用 auto 关键字进行类型推导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些其他的常见用法：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;              <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">10</span>); <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure><p>从 C++ 20 起，<code>auto</code> 甚至能用于函数传参，考虑下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto auto_arr2[10] = &#123;arr&#125;; // 错误, 无法推导数组元素类型</span><br><span class="line"></span><br><span class="line">2.6.auto.cpp:30:19: error: &#x27;auto_arr2&#x27; declared as<span class="built_in"> array </span>of &#x27;auto&#x27;</span><br><span class="line"> auto auto_arr2[10] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(表达式)</span></span></span><br></pre></td></tr></table></figure><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure><p>你已经在前面的例子中看到 <code>decltype</code> 用于推断类型的用法，下面这个例子就是判断上面的变量 <code>x, y, z</code> 是否是同一类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="variable constant_">is_same</span>&lt;<span class="title function_ invoke__">decltype</span>(x), <span class="keyword">int</span>&gt;::<span class="variable constant_">value</span>)</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="variable constant_">is_same</span>&lt;<span class="title function_ invoke__">decltype</span>(x), <span class="keyword">float</span>&gt;::<span class="variable constant_">value</span>)</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;type x == float&quot;</span> &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="variable constant_">is_same</span>&lt;<span class="title function_ invoke__">decltype</span>(x), <span class="title function_ invoke__">decltype</span>(z)&gt;::<span class="variable constant_">value</span>)</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;type z == type x&quot;</span> &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>std::is_same&lt;T, U&gt;</code> 用于判断 <code>T</code> 和 <code>U</code> 这两个类型是否相等。输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">x </span>== int</span><br><span class="line"><span class="keyword">type</span> <span class="type">z </span>== <span class="keyword">type</span> <span class="type">x</span></span><br></pre></td></tr></table></figure><h3 id="尾返回类型推导"><a href="#尾返回类型推导" class="headerlink" title="尾返回类型推导"></a>尾返回类型推导</h3><p>你可能会思考，在介绍 <code>auto</code> 时，我们已经提过 <code>auto</code> 不能用于函数形参进行类型推导，那么 <code>auto</code> 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有<a href="https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names">嵌套依赖类型</a>的变量时，需要用 typename 消除歧义</p></blockquote><p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 <code>add()</code> 这个函数会做什么样的操作，以及获得一个什么样的返回类型。</p><p>在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 <code>decltype</code> 推导 <code>x+y</code> 的类型，写出这样的代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，<code>x</code> 和 <code>y</code> 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 <code>auto</code> 关键字将返回类型后置：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">template</span>&lt;typename <span class="type">T</span>, typename <span class="type">U</span>&gt;</span><br><span class="line"><span class="title">auto</span> add2(<span class="type">T</span> x, <span class="type">U</span> y) -&gt; decl<span class="keyword">type</span>(x+y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以检查一下类型推导是否正确：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after c++11</span></span><br><span class="line"><span class="keyword">auto</span> w = <span class="built_in">add2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(w), <span class="type">double</span>&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w is double: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after c++14</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">add3</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。</p><blockquote><p>要理解它你需要知道 C++ 中参数转发的概念，我们会在<a href="https://changkun.de/modern-cpp/zh-cn/03-runtime/index.html">语言运行时强化</a>一章中详细介绍，你可以到时再回来看这一小节的内容。</p></blockquote><p>简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string  <span class="built_in">lookup1</span>();</span><br><span class="line">std::string&amp; <span class="built_in">lookup2</span>();</span><br></pre></td></tr></table></figure><p>在 C++11 中，封装实现是如下形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">std</span>::<span class="built_in">string</span> <span class="title function_">look_up_a_string_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">std</span>::<span class="built_in">string</span>&amp; <span class="title function_">look_up_a_string_2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decltype</span>(auto) <span class="built_in">look_up_a_string_1</span>() &#123;</span><br><span class="line">    return <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">decltype</span>(auto) <span class="built_in">look_up_a_string_2</span>() &#123;</span><br><span class="line">    return <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h2><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p>正如本章开头出，我们知道了 C++11 引入了 <code>constexpr</code> 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 <code>constexpr</code> 这个关键字引入到 <code>if</code> 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，实际代码就会表现为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间-for-迭代"><a href="#区间-for-迭代" class="headerlink" title="区间 for 迭代"></a>区间 for 迭代</h3><p>终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>); itr != vec.<span class="built_in">end</span>()) *itr = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p><h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">bool</span>&gt;;          <span class="comment">// 强行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">double</span>&gt;; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure><h3 id="尖括号-“-gt-”"><a href="#尖括号-“-gt-”" class="headerlink" title="尖括号 “&gt;”"></a>尖括号 “&gt;”</h3><p>在传统 C++ 的编译器中，<code>&gt;&gt;</code>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br></pre></td></tr></table></figure><p>这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。甚至于像下面这种写法都能够通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line">    <span class="type">bool</span> magic = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main function:</span></span><br><span class="line">std::vector&lt;MagicType&lt;(1&gt;<span class="number">2</span>)&gt;&gt; magic; <span class="comment">// 合法, 但不建议写出这样的代码</span></span><br></pre></td></tr></table></figure><h3 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h3><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的。</strong>在传统 C++ 中，<code>typedef</code> 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T dark;</span><br><span class="line">    U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure><p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：</p><blockquote><p>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</p></blockquote><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int <span class="comment">(*process)(void *)</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">using</span> NewProcess = int<span class="comment">(*)(void *)</span><span class="punctuation">;</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;<span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">int main() <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    TrueDarkMagic&lt;bool&gt; you;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><p>模板一直是 C++ 所独有的<strong>黑魔法</strong>（一起念：<strong>Dark Magic</strong>）之一。 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure><p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span>&lt;<span class="type">int</span>,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">            std::map&lt;std::string,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; darkMagic;</span><br></pre></td></tr></table></figure><p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。</p><p>如果不希望产生的模板参数个数为 <code>0</code>，可以手动的定义至少一个模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure><p>变长参数模板也能被直接调整到到模板函数上。传统 C 中的 <code>printf</code> 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 <code>printf</code> 的函数能自然地处理非自带类别的对象。 除了在模板参数中能使用 <code>...</code> 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> std::string &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure><p>那么我们定义了变长的模板参数，如何对参数进行解包呢？</p><p>首先，我们可以使用 <code>sizeof...</code> 来计算参数的个数，：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以传递任意个参数给 <code>magic</code> 函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">magic</span>(); <span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>); <span class="comment">// 输出1</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>, &quot;&quot;); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p><p><strong>1. 递归模板函数</strong></p><p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 变参模板展开</strong></p><p>你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 <code>printf</code> 的编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t0 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 <code>std::bind</code> 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</p></blockquote><p><strong>3. 初始化列表展开</strong></p><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p><p>这里介绍一种使用初始化列表展开的黑魔法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    (<span class="type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">        std::cout &lt;&lt; args &lt;&lt; std::endl;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到）。</p><p>通过初始化列表，<code>(lambda 表达式, value)...</code> 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。 为了避免编译器警告，我们可以将 <code>std::initializer_list</code> 显式的转为 <code>void</code>。</p><h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数推导"><a href="#非类型模板参数推导" class="headerlink" title="非类型模板参数推导"></a>非类型模板参数推导</h3><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中模板的参数 <code>T</code> 和 <code>U</code> 为具体的类型。 但还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> BufSize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buffer_t</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">buffer_t</span>&lt;<span class="type">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br></pre></td></tr></table></figure><p>在这种模板参数形式下，我们可以将 <code>100</code> 作为模板的参数进行传递。 在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 <code>auto</code> 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 <code>auto</code> 关键字，让编译器辅助完成具体类型的推导， 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="number">10</span>&gt;();  <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 <code>using</code> 引入了继承构造函数的概念：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h3><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span>()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> SubClass: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span>()</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的其函数签名一致的虚函数，否则将无法通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass1</span> <span class="keyword">final</span>: Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass2</span> : SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass3</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h3><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。 当程序员有需要时，可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。 例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 <code>private</code>。 尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Magic</span>() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">    Magic&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">    <span class="built_in">Magic</span>(<span class="type">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 <code>enum class</code> 的语法进行声明：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="symbol">new_enum</span> : <span class="symbol">unsigned</span> <span class="symbol">int</span> &#123;</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    value3 = <span class="number">100</span>,</span><br><span class="line">    value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (new_enum<span class="number">::</span>value3 == new_enum<span class="number">::</span>value4) &#123;</span><br><span class="line">    // 会输出</span><br><span class="line">    st<span class="number">d::</span>cout &lt;&lt; &quot;new_enum<span class="number">::</span>value3 == new_enum<span class="number">::</span>value4&quot; &lt;&lt; st<span class="number">d::</span>endl<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 <code>int</code>）。</p><p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出，可以收藏下面这个代码段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">        std::ostream&gt;::type&amp; stream, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，下面的代码将能够被编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都需要了解并熟练使用的：</p><ol><li><code>auto</code> 类型推导</li><li>范围 <code>for</code> 迭代</li><li>初始化列表</li><li>变参模板</li></ol><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol><li><p>使用结构化绑定，仅用一行函数内代码实现如下函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(std::map&lt;Key, Value&gt;&amp; m, F foo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt; m &#123;</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;c&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">update</span>(m, [](std::string key) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::hash&lt;std::string&gt;&#123;&#125;(key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [key, value] : m)</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尝试用<a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#折叠表达式">折叠表达式</a>实现用于计算均值的函数，传入允许任意参数</p></li></ol><h1 id="第-3-章-语言运行期的强化"><a href="#第-3-章-语言运行期的强化" class="headerlink" title="第 3 章 语言运行期的强化"></a>第 3 章 语言运行期的强化</h1><h2 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h2><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[捕获列表]</span>(参数列表) <span class="built_in">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h4 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1. 值捕获"></a>1. 值捕获</h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2. 引用捕获"></a>2. 引用捕获</h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3. 隐式捕获"></a>3. 隐式捕获</h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;] 引用捕获, 让编译器自行推导引用列表</li><li>[=] 值捕获, 让编译器自行推导值捕获列表</li></ul><h4 id="4-表达式捕获"><a href="#4-表达式捕获" class="headerlink" title="4. 表达式捕获"></a>4. 表达式捕获</h4><blockquote><p>这部分内容需要了解后面马上要提到的右值引用以及智能指针</p></blockquote><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p><h3 id="泛型-Lambda"><a href="#泛型-Lambda" class="headerlink" title="泛型 Lambda"></a>泛型 Lambda</h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto <span class="built_in">add</span> = [](auto x, auto y) &#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(1, 2);</span><br><span class="line"><span class="built_in">add</span>(1.1, 2.2);</span><br></pre></td></tr></table></figure><h2 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h2><p>这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力， 这部分内容也相当重要，所以放到这里来进行介绍。</p><h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h3><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>); <span class="comment">// 定义函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p><p>C++11 <code>std::function</code> 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = [&amp;](<span class="type">int</span> value) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a><code>std::bind</code> 和 <code>std::placeholder</code></h3><p>而 <code>std::bind</code> 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数1,2绑定到函数 foo 上，</span></span><br><span class="line">    <span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong>注意 <code>auto</code> 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 <code>auto</code> 的使用来规避这一问题的出现。</p></blockquote><h2 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h2><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题， 消除了诸如 <code>std::vector</code>、<code>std::string</code> 之类的额外开销， 也才使得函数对象容器 <code>std::function</code> 成为了可能。</p><h3 id="左值、右值的纯右值、将亡值、右值"><a href="#左值、右值的纯右值、将亡值、右值" class="headerlink" title="左值、右值的纯右值、将亡值、右值"></a>左值、右值的纯右值、将亡值、右值</h3><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p><p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p><p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p><p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 <code>10</code>, <code>true</code>； 要么是求值结果相当于字面量或匿名临时对象，例如 <code>1+2</code>。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。</p><p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 <code>const char</code> 数组。例如：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;type_traits&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    // 正确，<span class="string">&quot;01234&quot;</span> 类型为 <span class="keyword">const</span> <span class="type">char</span> [<span class="number">6</span>]，因此是左值</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> (&amp;left)[<span class="number">6</span>] = <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    // 断言正确，确实是 <span class="keyword">const</span> <span class="type">char</span> [<span class="number">6</span>] 类型，注意 decltype(<span class="type">expr</span>) 在 <span class="type">expr</span> 是左值</span><br><span class="line">    // 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span><br><span class="line">    static_assert(std::is_same&lt;decltype(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="type">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    // 错误，<span class="string">&quot;01234&quot;</span> 是左值，不可被右值引用</span><br><span class="line">    // <span class="keyword">const</span> <span class="type">char</span> (&amp;&amp;right)[<span class="number">6</span>] = <span class="string">&quot;01234&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）。例如：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span>*   p   = <span class="string">&quot;01234&quot;</span>;  // 正确，<span class="string">&quot;01234&quot;</span> 被隐式转换为 <span class="keyword">const</span> <span class="type">char</span>*</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span>*&amp;&amp; pr  = <span class="string">&quot;01234&quot;</span>;  // 正确，<span class="string">&quot;01234&quot;</span> 被隐式转换为 <span class="keyword">const</span> <span class="type">char</span>*，该转换的结果是纯右值</span><br><span class="line">// <span class="keyword">const</span> <span class="type">char</span>*&amp; pl = <span class="string">&quot;01234&quot;</span>; // 错误，此处不存在 <span class="keyword">const</span> <span class="type">char</span>* 类型的左值</span><br></pre></td></tr></table></figure><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><p>将亡值可能稍有些难以理解，我们来看这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure><p>在这样的代码中，就传统的理解而言，函数 <code>foo</code> 的返回值 <code>temp</code> 在内部创建然后被赋值给 <code>v</code>， 然而 <code>v</code> 获得这个对象时，会将整个 <code>temp</code> 拷贝一份，然后把 <code>temp</code> 销毁，如果这个 <code>temp</code> 非常大， 这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，<code>v</code> 是左值、 <code>foo()</code> 返回的值就是右值（也是纯右值）。但是，<code>v</code> 可以被别的变量捕获到， 而 <code>foo()</code> 产生的那个返回值作为一个临时值，一旦被 <code>v</code> 复制后，将立即被销毁，无法获取、也不能修改。 而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。</p><p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 <code>temp</code> 会被进行此隐式右值转换， 等价于 <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>，进而此处的 <code>v</code> 会将 <code>foo</code> 局部返回的值进行移动。 也就是后面我们将会提到的移动语义。</p><h3 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h3><p>要拿到一个将亡值，就需要用到右值引用：<code>T &amp;&amp;</code>，其中 <code>T</code> 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// 合法, std::move可以将左值转移为右值</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl; <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl; <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">    rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rv2</code> 虽然引用了一个右值，但由于它是一个引用，所以 <code>rv2</code> 依然是一个左值。</p><p>注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int &amp;a = std::move(1);    // 不合法，非常量左引用无法引用右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// 合法, 常量左引用允许引用右值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span>(<span class="params"><span class="built_in">int</span> &amp; v</span>)</span> &#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">double</span> s = <span class="number">1</span>;</span><br><span class="line">    increase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>int&amp;</code> 不能引用 <code>double</code> 类型的参数，因此必须产生一个临时值来保存 <code>s</code> 的值， 从而当 <code>increase()</code> 修改这个临时值时，调用完成后 <code>s</code> 本身并没有被修改。</p><p>第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要。</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</p><p>传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *pointer;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.pointer)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123;</span><br><span class="line">        a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="type">bool</span> test)</span> </span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    <span class="keyword">if</span>(test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;     <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ol><li>首先会在 <code>return_rvalue</code> 内部构造两个 <code>A</code> 对象，于是获得两个构造函数的输出；</li><li>函数返回后，产生一个将亡值，被 <code>A</code> 的移动构造（<code>A(A&amp;&amp;)</code>）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 <code>obj</code> 中，而将亡值的指针被设置为 <code>nullptr</code>，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span></span><br><span class="line">    <span class="comment">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span></span><br><span class="line">    <span class="comment">// 这步操作后, str 中的值会变为空</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: &quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通传参:&quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>); <span class="comment">// 1是右值, 但输出是左值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>pass(1)</code> 来说，虽然传递的是右值，但由于 <code>v</code> 是一个引用，所以同时也是左值。 因此 <code>reference(v)</code> 会调用 <code>reference(int&amp;)</code>，输出『左值』。 而对于<code>pass(l)</code>而言，<code>l</code>是一个左值，为什么会成功传递给 <code>pass(T&amp;&amp;)</code> 呢？</p><p>这是基于<strong>引用坍缩规则</strong>的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数形参类型</th><th style="text-align:left">实参参数类型</th><th style="text-align:left">推导后函数形参类型</th></tr></thead><tbody><tr><td style="text-align:left">T&amp;</td><td style="text-align:left">左引用</td><td style="text-align:left">T&amp;</td></tr><tr><td style="text-align:left">T&amp;</td><td style="text-align:left">右引用</td><td style="text-align:left">T&amp;</td></tr><tr><td style="text-align:left">T&amp;&amp;</td><td style="text-align:left">左引用</td><td style="text-align:left">T&amp;</td></tr><tr><td style="text-align:left">T&amp;&amp;</td><td style="text-align:left">右引用</td><td style="text-align:left">T&amp;&amp;</td></tr></tbody></table></div><p>因此，模板函数中使用 <code>T&amp;&amp;</code> 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。 更准确的讲，<strong>无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型</strong>。 这才使得 <code>v</code> 作为左值的成功传递。</p><p>完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 <code>std::forward</code> 来进行参数的转发（传递）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;              普通传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;       std::move 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;    std::forward 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传递右值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 右值引用</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt; 传参: 右值引用</span><br><span class="line">传递左值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 左值引用</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt; 传参: 左值引用</span><br></pre></td></tr></table></figure><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，<code>std::move</code> 总会接受到一个左值，从而转发调用了<code>reference(int&amp;&amp;)</code> 输出右值引用。</p><p>唯独 <code>std::forward</code> 即没有造成任何多余的拷贝，同时<strong>完美转发</strong>(传递)了函数的实参给了内部调用的其他函数。</p><p><code>std::forward</code> 和 <code>std::move</code> 一样，没有做任何事情，<code>std::move</code> 单纯的将左值转化为右值， <code>std::forward</code> 也只是单纯的将参数做了一个类型的转换，从现象上来看， <code>std::forward&lt;T&gt;(v)</code> 和 <code>static_cast&lt;T&amp;&amp;&gt;(v)</code> 是完全一样的。</p><p>读者可能会好奇，为何一条语句能够针对两种类型的返回对应的值， 我们再简单看一看 <code>std::forward</code> 的具体实现机制，<code>std::forward</code> 包含两个重载：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_Tp</span>&gt;</span><br><span class="line">constexpr <span class="variable">_Tp</span>&amp;&amp; forward(<span class="built_in">typename</span> std::remove_reference&lt;<span class="variable">_Tp</span>&gt;::<span class="built_in">type</span>&amp; <span class="variable">__t</span>) noexcept</span><br><span class="line">&#123; return static_cast&lt;<span class="variable">_Tp</span>&amp;&amp;&gt;(<span class="variable">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="built_in">typename</span> <span class="variable">_Tp</span>&gt;</span><br><span class="line">constexpr <span class="variable">_Tp</span>&amp;&amp; forward(<span class="built_in">typename</span> std::remove_reference&lt;<span class="variable">_Tp</span>&gt;::<span class="built_in">type</span>&amp;&amp; <span class="variable">__t</span>) noexcept</span><br><span class="line">&#123;</span><br><span class="line">    static_assert(!std::is_lvalue_reference&lt;<span class="variable">_Tp</span>&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    return static_cast&lt;<span class="variable">_Tp</span>&amp;&amp;&gt;(<span class="variable">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份实现中，<code>std::remove_reference</code> 的功能是消除类型中的引用， <code>std::is_lvalue_reference</code> 则用于检查类型推导是否正确，在 <code>std::forward</code> 的第二个实现中 检查了接收到的值确实是一个左值，进而体现了坍缩规则。</p><p>当 <code>std::forward</code> 接受左值时，<code>_Tp</code> 被推导为左值，所以返回值为左值；而当其接受右值时， <code>_Tp</code> 被推导为 右值引用，则基于坍缩规则，返回值便成为了 <code>&amp;&amp; + &amp;&amp;</code> 的右值。 可见 <code>std::forward</code> 的原理在于巧妙的利用了模板类型推导中产生的差异。</p><p>这时我们能回答这样一个问题：为什么在使用循环语句的过程中，<code>auto&amp;&amp;</code> 是最安全的方式？ 因为当 <code>auto</code> 被推导为不同的左右引用时，与 <code>&amp;&amp;</code> 的坍缩组合是完美转发。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性都是值得掌握的：</p><ol><li>Lambda 表达式</li><li>函数对象容器 std::function</li><li>右值引用</li></ol><h1 id="第-4-章-容器"><a href="#第-4-章-容器" class="headerlink" title="第 4 章 容器"></a>第 4 章 容器</h1><h2 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h2><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h3><p>看到这个容器的时候肯定会出现这样的问题：</p><ol><li>为什么要引入 <code>std::array</code> 而不是直接使用 <code>std::vector</code>？</li><li>已经有了传统数组，为什么要用 <code>std::array</code>?</li></ol><p>先回答第一个问题，与 <code>std::vector</code> 不同，<code>std::array</code> 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 <code>std::array</code> 容器。 另外由于 <code>std::vector</code> 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 <code>shrink_to_fit()</code> 释放这部分内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下可看出 std::vector 的存储是自动管理的，按需自动扩张</span></span><br><span class="line"><span class="comment">// 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的自动扩张逻辑与 Golang 的 slice 很像</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还</span></span><br><span class="line">v.<span class="built_in">clear</span>();                                             </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外内存可通过 shrink_to_fit() 调用返回给系统</span></span><br><span class="line">v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure><p>而第二个问题就更加简单，使用 <code>std::array</code> 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 <code>std::sort</code>。</p><p>使用 <code>std::array</code> 很简单，只需指定其类型和大小即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="built_in">empty</span>(); <span class="comment">// 检查容器是否为空</span></span><br><span class="line">arr.<span class="built_in">size</span>();  <span class="comment">// 返回容纳的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 lambda 表达式排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组大小参数必须是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法,不同于 C 风格数组，std::array 不会自动退化成 T*</span></span><br><span class="line"><span class="comment">// int *arr_p = arr;</span></span><br></pre></td></tr></table></figure><p>当我们开始用上了 <code>std::array</code> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">foo</span>(int *p, int len) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;int, <span class="number">4</span>&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 风格接口传参</span></span><br><span class="line"><span class="comment">// foo(arr, arr.size()); // 非法, 无法隐式转换</span></span><br><span class="line"><span class="built_in">foo</span>(&amp;arr[<span class="number">0</span>], arr.size());</span><br><span class="line"><span class="built_in">foo</span>(arr.data(), arr<span class="selector-class">.size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `std::sort`</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a><code>std::forward_list</code></h3><p><code>std::forward_list</code> 是一个列表容器，使用方法和 <code>std::list</code> 基本类似，因此我们就不花费篇幅进行介绍了。</p><p>需要知道的是，和 <code>std::list</code> 的双向链表的实现不同，<code>std::forward_list</code> 使用单向链表进行实现， 提供了 <code>O(1)</code> 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 <code>size()</code> 方法的容器。当不需要双向迭代时，具有比 <code>std::list</code> 更高的空间利用率。</p><h2 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h2><p>我们已经熟知了传统 C++ 中的有序容器 <code>std::map</code>/<code>std::set</code>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 <code>O(log(size))</code>。在插入元素时候，会根据 <code>&lt;</code> 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 <code>&lt;</code> 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>， 在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：<code>std::unordered_map</code>/<code>std::unordered_multimap</code> 和 <code>std::unordered_set</code>/<code>std::unordered_multiset</code>。</p><p>它们的用法和原有的 <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code> 基本类似， 由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下<code>std::map</code>和<code>std::unordered_map</code>：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两组结构按同样的顺序初始化</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; u = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; v = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别对两组结构进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unordered_map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> <span class="keyword">auto</span> &amp; n : u)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> <span class="keyword">auto</span> &amp; n : v)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">std</span>::unordered_map</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">2</span>] Value:[<span class="number">2</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">3</span>] Value:[<span class="number">3</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">1</span>] Value:[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="attribute">std</span>::map</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">1</span>] Value:[<span class="number">1</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">2</span>] Value:[<span class="number">2</span>]</span><br><span class="line"><span class="attribute">Key</span>:[<span class="number">3</span>] Value:[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h2><p>了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 <code>std::pair</code> 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 <code>std::pair</code> 的缺陷是显而易见的，只能保存两个元素。</p><h3 id="元组基本操作"><a href="#元组基本操作" class="headerlink" title="元组基本操作"></a>元组基本操作</h3><p>关于元组的使用有三个核心的函数：</p><ol><li><code>std::make_tuple</code>: 构造元组</li><li><code>std::get</code>: 获得元组某个位置的值</li><li><code>std::tie</code>: 元组拆包</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">3.8</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">2.9</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1.7</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0.0</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> student = <span class="built_in">get_student</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(student) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> gpa;</span><br><span class="line">    <span class="type">char</span> grade;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组进行拆包</span></span><br><span class="line">    std::<span class="built_in">tie</span>(gpa, grade, name) = <span class="built_in">get_student</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::get</code> 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">double</span>, <span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;123&quot;</span>, <span class="number">4.5</span>, <span class="number">6.7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(t) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(t) &lt;&lt; std::endl; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(t) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="运行期索引"><a href="#运行期索引" class="headerlink" title="运行期索引"></a>运行期索引</h3><p>如果你仔细思考一下可能就会发现上面代码的问题，<code>std::get&lt;&gt;</code> 依赖一个编译期的常量，所以下面的方式是不合法的：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">index</span> = <span class="number">1</span>;</span><br><span class="line">s<span class="symbol">td:</span><span class="symbol">:ge</span><span class="built_in">t</span>&lt;<span class="built_in">index</span>&gt;(<span class="built_in">t</span>);</span><br></pre></td></tr></table></figure><p>那么要怎么处理？答案是，使用 <code>std::variant&lt;&gt;</code>（C++ 17 引入），提供给 <code>variant&lt;&gt;</code> 的类型模板参数 可以让一个 <code>variant&lt;&gt;</code> 从而容纳提供的几种类型的变量（在其他语言，例如 Python/JavaScript 等，表现为动态类型）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> n, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; _tuple_index(<span class="type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(n &gt;= <span class="keyword">sizeof</span>...(T))</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throw</span> <span class="title">std::out_of_range</span><span class="params">(<span class="string">&quot;越界.&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> std::variant&lt;T...&gt;&#123; std::in_place_index&lt;n&gt;, std::<span class="built_in">get</span>&lt;n&gt;(tpl) &#125;;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;(n &lt; <span class="keyword">sizeof</span>...(T)<span class="number">-1</span> ? n+<span class="number">1</span> : <span class="number">0</span>)&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; <span class="title">tuple_index</span><span class="params">(<span class="type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;<span class="number">0</span>&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream &amp; s, std::variant&lt;T0, Ts...&gt; <span class="type">const</span> &amp; v) &#123; </span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span> &amp;&amp; x)&#123; s &lt;&lt; x;&#125;, v); </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">tuple_index</span>(t, i) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="元组合并与遍历"><a href="#元组合并与遍历" class="headerlink" title="元组合并与遍历"></a>元组合并与遍历</h3><p>还有一个常见的需求就是合并两个元组，这可以通过 <code>std::tuple_cat</code> 来实现：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">auto</span> new_tuple = <span class="title function_">std::tuple_cat</span>(get_student(<span class="number">1</span>), <span class="title function_">std::move</span>(t))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 <code>tuple</code> 那么遍历就变得简单了， 首先我们需要知道一个元组的长度，可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tuple_size&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能够对元组进行迭代了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i != tuple_len(<span class="keyword">new</span><span class="type">_tuple</span>); ++i)</span><br><span class="line">    <span class="comment">// 运行期索引</span></span><br><span class="line">    std:<span class="type"></span>:cout &lt;&lt; tuple_index(<span class="keyword">new</span><span class="type">_tuple</span>, i) &lt;&lt; std:<span class="type"></span>:endl;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本章简单介绍了现代 C++ 中新增的容器，它们的用法和传统 C++ 中已有的容器类似，相对简单，可以根据实际场景丰富的选择需要使用的容器，从而获得更好的性能。</p><p><code>std::tuple</code> 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他的方法可以自行实现。</p><h1 id="第-5-章-智能指针与内存管理"><a href="#第-5-章-智能指针与内存管理" class="headerlink" title="第 5 章 智能指针与内存管理"></a>第 5 章 智能指针与内存管理</h1><h2 id="5-1-RAII-与引用计数"><a href="#5-1-RAII-与引用计数" class="headerlink" title="5.1 RAII 与引用计数"></a>5.1 RAII 与引用计数</h2><p>了解 <code>Objective-C</code>/<code>Swift</code> 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。</p><p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。</p><p>凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p><blockquote><p>注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。</p></blockquote><h2 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 <code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p><p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。</p><p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">    (*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line">    <span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    <span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">foo</span>(pointer);</span><br><span class="line">    std::cout &lt;&lt; *pointer &lt;&lt; std::endl; <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数， 并通过<code>use_count()</code>来查看一个对象的引用计数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="type">int</span> *p = pointer.<span class="built_in">get</span>();  <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">pointer2.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer2 已 reset; 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">pointer3.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer3:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer3 已 reset; 0</span></span><br></pre></td></tr></table></figure><h2 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 <code>std::unique_ptr</code></h2><p><code>std::unique_ptr</code> 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; pointer = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><blockquote><p><code>make_unique</code> 并不复杂，C++11 没有提供 <code>std::make_unique</code>，可以自行实现：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename <span class="params">...</span>Args&gt;</span><br><span class="line">std<span class="type">::unique_ptr</span>&lt;T&gt; make_unique( Args&amp;&amp; <span class="params">...</span>args ) &#123;</span><br><span class="line"><span class="keyword">return</span> std<span class="type">::unique_ptr</span>&lt;T&gt;( <span class="literal">new</span> T( std<span class="type">::forward</span>&lt;Args&gt;(args)<span class="params">...</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的<a href="https://herbsutter.com/gotw/_102/">博客</a>中提到原因是因为『被他们忘记了』。</p></blockquote><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code>，例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::~Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Foo::foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Foo &amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f(const Foo&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p1</span><span class="params">(std::make_unique&lt;Foo&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="built_in">f</span>(*p2);</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        <span class="comment">// p1 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        p1 = std::<span class="built_in">move</span>(p2);</span><br><span class="line">        <span class="comment">// p2 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p2 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">// Foo 的实例会在离开作用域时被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-std-weak-ptr"><a href="#5-4-std-weak-ptr" class="headerlink" title="5.4 std::weak_ptr"></a>5.4 <code>std::weak_ptr</code></h2><p>如果你仔细思考 <code>std::shared_ptr</code> 就会发现依然存在着资源无法释放的问题。看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;pointer = b;</span><br><span class="line">    b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露，如图 5.1：</p><p><img src="https://changkun.de/modern-cpp/assets/figures/pointers1.png" alt="图 5.1">图 5.1</p><p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图 5.2 所示：</p><p><img src="https://changkun.de/modern-cpp/assets/figures/pointers2.png" alt="图 5.2">图 5.2</p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。</p><p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在一定程度上消除了 <code>new</code>/<code>delete</code> 的滥用，是一种更加成熟的编程范式。</p><h1 id="第-6-章-正则表达式"><a href="#第-6-章-正则表达式" class="headerlink" title="第 6 章 正则表达式"></a>第 6 章 正则表达式</h1><h2 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h2><p>正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。</p><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ol><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换；</li><li>从某个串中取出符合条件的子串。</li></ol><p>正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">匹配输入字符串的结尾位置。</td></tr><tr><td style="text-align:left"><code>(</code>,<code>)</code></td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式零次或多次。</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式一次或多次。</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符。</td></tr><tr><td style="text-align:left"><code>[</code></td><td style="text-align:left">标记一个中括号表达式的开始。</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td style="text-align:left"><code>\</code></td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>&#39;\&#39;</code> 字符，而 <code>\(</code> 则匹配 <code>&#39;(&#39;</code> 字符。</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td></tr><tr><td style="text-align:left"><code>&#123;</code></td><td style="text-align:left">标记限定符表达式的开始。</td></tr><tr><td style="text-align:left">`</td><td style="text-align:left">`</td><td>指明两项之间的一个选择。</td></tr></tbody></table></div><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，<code>foo*</code> 能匹配 <code>fo</code> 以及 <code>foooo</code>。<code>*</code> 等价于<code>&#123;0,&#125;</code>。</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，<code>foo+</code> 能匹配 <code>foo</code> 以及 <code>foooo</code>，但不能匹配 <code>fo</code>。<code>+</code> 等价于 <code>&#123;1,&#125;</code>。</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，<code>Your(s)?</code> 可以匹配 <code>Your</code> 或 <code>Yours</code> 中的<code>Your</code> 。<code>?</code> 等价于 <code>&#123;0,1&#125;</code>。</td></tr><tr><td style="text-align:left"><code>&#123;n&#125;</code></td><td style="text-align:left"><code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。例如，<code>o&#123;2&#125;</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但是能匹配 <code>foo</code> 中的两个 <code>o</code>。</td></tr><tr><td style="text-align:left"><code>&#123;n,&#125;</code></td><td style="text-align:left"><code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但能匹配 <code>foooooo</code> 中的所有 <code>o</code>。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td></tr><tr><td style="text-align:left"><code>&#123;n,m&#125;</code></td><td style="text-align:left"><code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n</code> 小于等于 <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。例如，<code>o&#123;1,3&#125;</code> 将匹配 <code>foooooo</code> 中的前三个 <code>o</code>。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。注意，在逗号和两个数之间不能有空格。</td></tr></tbody></table></div><p>有了这两张表，我们通常就能够读懂几乎所有的正则表达式了。</p><h2 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h2><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。 可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库， 而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时， 使用正则表达式也是工业界最为成熟的普遍做法。</p><p>一般的解决方案就是使用 <code>boost</code> 的正则表达式库。 而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持， 不再依赖第三方。</p><p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象， 模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化， 通过 <code>std::regex_match</code> 进行匹配， 从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）。</p><p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式:</p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, <code>[a-z]</code> 表示匹配一个小写字母, <code>+</code> 可以使前面的表达式匹配多次， 因此 <code>[a-z]+</code> 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 <code>.</code> 表示匹配任意字符，而 <code>\.</code> 则表示匹配字符 <code>.</code>， 最后的 <code>txt</code> 表示严格匹配 <code>txt</code> 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。</li></ul><p><code>std::regex_match</code> 用于匹配字符串和正则表达式，有很多不同的重载形式。 最简单的一个形式就是传入 <code>std::string</code> 以及一个 <code>std::regex</code> 进行匹配， 当匹配成功时，会返回 <code>true</code>，否则返回 <code>false</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line">    <span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line">    <span class="function">std::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line">        std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">regex_match</span>(fname, txt_regex) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种常用的形式就是依次传入 <code>std::string</code>/<code>std::smatch</code>/<code>std::regex</code> 三个参数， 其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。 故而在标准库的实现中， <code>std::smatch</code> 被定义为了 <code>std::match_results&lt;std::string::const_iterator&gt;</code>， 也就是一个子串迭代器类型的 <code>match_results</code>。 使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::regex <span class="built_in">base_regex</span>(<span class="string">&quot;([a-z]+)\\.txt&quot;</span>);</span><br><span class="line">std::smatch base_match;</span><br><span class="line">for(const auto &amp;fname: fnames) &#123;</span><br><span class="line">    if (std::<span class="built_in">regex_match</span>(fname, base_match, base_regex)) &#123;</span><br><span class="line">        // std::smatch 的第一个元素匹配整个字符串</span><br><span class="line">        // std::smatch 的第二个元素匹配了第一个括号表达式</span><br><span class="line">        if (base_match.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            std::string base = base_match[<span class="number">1</span>].<span class="built_in">str</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;sub-match[0]: &quot;</span> &lt;&lt; base_match[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot; sub-match[1]: &quot;</span> &lt;&lt; base &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个代码段的输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo<span class="selector-class">.txt</span>: <span class="number">1</span></span><br><span class="line">bar<span class="selector-class">.txt</span>: <span class="number">1</span></span><br><span class="line">test: <span class="number">0</span></span><br><span class="line">a0<span class="selector-class">.txt</span>: <span class="number">0</span></span><br><span class="line">AAA<span class="selector-class">.txt</span>: <span class="number">0</span></span><br><span class="line">sub-match<span class="selector-attr">[0]</span>: foo<span class="selector-class">.txt</span></span><br><span class="line">foo<span class="selector-class">.txt</span> sub-match<span class="selector-attr">[1]</span>: foo</span><br><span class="line">sub-match<span class="selector-attr">[0]</span>: bar<span class="selector-class">.txt</span></span><br><span class="line">bar<span class="selector-class">.txt</span> sub-match<span class="selector-attr">[1]</span>: bar</span><br></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本节简单介绍了正则表达式本身，然后根据使用正则表达式的主要需求，通过一个实际的例子介绍了正则表达式库的使用。</p><h1 id="第-7-章-并行与并发"><a href="#第-7-章-并行与并发" class="headerlink" title="第 7 章 并行与并发"></a>第 7 章 并行与并发</h1><h2 id="7-1-并行基础"><a href="#7-1-并行基础" class="headerlink" title="7.1 并行基础"></a>7.1 并行基础</h2><p><code>std::thread</code> 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 <code>&lt;thread&gt;</code> 头文件， 它提供了很多基本的线程操作，例如 <code>get_id()</code> 来获取所创建线程的线程 ID，使用 <code>join()</code> 来等待一个线程结束（与该线程汇合）等等，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;hello world.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-互斥量与临界区"><a href="#7-2-互斥量与临界区" class="headerlink" title="7.2 互斥量与临界区"></a>7.2 互斥量与临界区</h2><p>我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，<code>mutex</code> 就是其中的核心之一。 C++11 引入了 <code>mutex</code> 相关的类，其所有相关的函数都放在 <code>&lt;mutex&gt;</code> 头文件中。</p><p><code>std::mutex</code> 是 C++11 中最基本的 <code>mutex</code> 类，通过实例化 <code>std::mutex</code> 可以创建互斥量， 而通过其成员函数 <code>lock()</code> 可以进行上锁，<code>unlock()</code> 可以进行解锁。 但是在实际编写代码的过程中，最好不去直接调用成员函数， 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code>，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>。 RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。</p><p>在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> change_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行竞争操作</span></span><br><span class="line">    v = change_v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开此作用域后 mtx 会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。 无论 <code>critical_section()</code> 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 <code>unlock()</code>。</p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的，<code>std::unique_lock</code> 更加灵活， <code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权） 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 <code>std::unique_lock</code>。</p><p><code>std::lock_guard</code> 不能显式的调用 <code>lock</code> 和 <code>unlock</code>， 而 <code>std::unique_lock</code> 可以在声明后的任意位置调用， 可以缩小锁的作用范围，提供更高的并发度。</p><p>如果你用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> change_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 执行竞争操作</span></span><br><span class="line">    v = change_v;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 将锁进行释放</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此期间，任何人都可以抢夺 v 的持有权</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始另一组竞争操作，再次加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    v += <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-期物"><a href="#7-3-期物" class="headerlink" title="7.3 期物"></a>7.3 期物</h2><p>期物（Future）表现为 <code>std::future</code>，它提供了一个访问异步操作结果的途径，这句话很不好理解。 为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。</p><p>试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。 而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果， 所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。</p><p>在 C++11 的 <code>std::future</code> 被引入之前，通常的做法是： 创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。 而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程，可以用来获取异步任务的结果。 自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。</p><p>为了看一个例子，我们这里额外使用 <code>std::packaged_task</code>，它可以用来封装任何可以调用的目标，从而用于实现异步的调用。 举例来说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个返回值为7的 lambda 表达式封装到 task 中</span></span><br><span class="line">    <span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 获得 task 的期物</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">    result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障，阻塞到期物的完成</span></span><br><span class="line">    <span class="comment">// 输出执行结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span></span><br><span class="line">              &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装好要调用的目标后，可以使用 <code>get_future()</code> 来获得一个 <code>std::future</code> 对象，以便之后实施线程同步。</p><h2 id="7-4-条件变量"><a href="#7-4-条件变量" class="headerlink" title="7.4 条件变量"></a>7.4 条件变量</h2><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。 所以，<code>condition_variable</code> 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。 <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程。下面是一个生产者和消费者模型的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; produced_nums;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    <span class="type">bool</span> notified = <span class="literal">false</span>;  <span class="comment">// 通知信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">auto</span> producer = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">900</span>));</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;producing &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            produced_nums.<span class="built_in">push</span>(i);</span><br><span class="line">            notified = <span class="literal">true</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>(); <span class="comment">// 此处也可以使用 notify_one</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">auto</span> consumer = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">            <span class="keyword">while</span> (!notified) &#123;  <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// 消费者慢于生产者</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">            lock.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">while</span> (!produced_nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;consuming &quot;</span> &lt;&lt; produced_nums.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">                produced_nums.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            notified = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别在不同的线程中运行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">p</span><span class="params">(producer)</span></span>;</span><br><span class="line">    std::thread cs[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        cs[i] = std::<span class="built_in">thread</span>(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        cs[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，在生产者中我们虽然可以使用 <code>notify_one()</code>，但实际上并不建议在此处使用， 因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者 争夺此锁，从而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 <code>std::mutex</code> 的排他性， 我们根本无法期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。</p><h2 id="7-5-原子操作与内存模型"><a href="#7-5-原子操作与内存模型" class="headerlink" title="7.5 原子操作与内存模型"></a>7.5 原子操作与内存模型</h2><p>细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况产生疑惑。 例如，布尔值 <code>notified</code> 没有被 <code>volatile</code> 修饰，编译器可能对此变量存在优化，例如将其作为一个寄存器的值， 从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚这个问题，我们需要进一步讨论 从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面这段代码输出结果是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag != <span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> b = a;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        a = <span class="number">5</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        flag = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从直观上看，<code>t2</code> 中 <code>a = 5;</code> 这一条语句似乎总在 <code>flag = 1;</code> 之前得到执行，而 <code>t1</code> 中 <code>while (flag != 1)</code> 似乎保证了 <code>std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;</code> 不会再标记被改变前执行。从逻辑上看，似乎 <code>b</code> 的值应该等于 5。 但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 <code>a</code> 和 <code>flag</code> 而言，他们在两个并行的线程中被读写， 出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响， 导致 <code>a = 5</code> 发生在 <code>flag = 1</code> 之后。从而 <code>b</code> 可能输出 0。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p><code>std::mutex</code> 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能， 这是因为一个互斥锁的实现通常包含两条基本原理：</p><ol><li>提供线程间自动的状态转换，即『锁住』这个状态</li><li>保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离</li></ol><p>这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令（我们之后再来看如何实现一个简单的互斥锁）。 这对于一个仅需原子级操作（没有中间态）的变量，似乎太苛刻了。</p><p>关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，现代 CPU 体系结构提供了 CPU 指令级的原子操作， 因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 <code>std::atomic</code> 模板，使得我们实例化一个原子类型，将一个 原子类型读写操作从一组指令，最小化到单个 CPU 指令。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter;</span><br></pre></td></tr></table></figure><p>并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说， 包括 <code>fetch_add</code>, <code>fetch_sub</code> 等，同时通过重载方便的提供了对应的 <code>+</code>，<code>-</code> 版本。 比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        count.fetch_add(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        count++;        <span class="comment">// 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">        count += <span class="number">1</span>;     <span class="comment">// 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐 条件的要求，因而我们总是可以通过 <code>std::atomic&lt;T&gt;::is_lock_free</code> 来检查该原子类型是否需支持原子操作，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;A&gt; a;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; a.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。 在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。</p><p>如果我们强行将一个变量 <code>v</code> 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 <code>v</code> 后， 其他线程均能<strong>同步</strong>感知到 <code>v</code> 的变化，则对于变量 <code>v</code> 而言，表现为顺序执行的程序，它并没有由于引入多线程 而得到任何效率上的收益。对此有什么办法能够适当的加速呢？答案便是削弱原子操作的在进程间的同步条件。</p><p>从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。 削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型：</p><ol><li><p>线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">1</span>)      <span class="keyword">x</span>.<span class="keyword">load</span>()</span><br><span class="line">T<span class="number">1</span> ---------+----------------+------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T<span class="number">2</span> -------------------+-------------&gt;</span><br><span class="line">                <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在这种情况下线程 <code>T1</code>, <code>T2</code> 对 <code>x</code> 的两次写操作是原子的，且 <code>x.store(1)</code> 是严格的发生在 <code>x.store(2)</code> 之前，<code>x.store(2)</code> 严格的发生在 <code>x.load()</code> 之前。 值得一提的是，线性一致性对全局时钟的要求是难以实现的，这也是人们不断研究比这个一致性更弱条件下其他一致性的算法的原因。</p></li><li><p>顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">1</span>)  <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">3</span>)   <span class="keyword">x</span>.<span class="keyword">load</span>()</span><br><span class="line">T<span class="number">1</span> ---------+-----------+----------+-----&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T<span class="number">2</span> ---------------+----------------------&gt;</span><br><span class="line">              <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">        <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">1</span>)  <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">3</span>)   <span class="keyword">x</span>.<span class="keyword">load</span>()</span><br><span class="line">T<span class="number">1</span> ---------+-----------+----------+-----&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T<span class="number">2</span> ------+-------------------------------&gt;</span><br><span class="line">      <span class="keyword">x</span>.<span class="keyword">store</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在顺序一致性的要求下，<code>x.load()</code> 必须读到最近一次写入的数据，因此 <code>x.store(2)</code> 与 <code>x.store(1)</code> 并无任何先后保障，即 只要 <code>T2</code> 的 <code>x.store(2)</code> 发生在 <code>x.store(3)</code> 之前即可。</p></li><li><p>因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      a = <span class="number">1</span>      b = <span class="number">2</span></span><br><span class="line"><span class="type">T1</span> ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ------+--------------------+--------+--------&gt;</span><br><span class="line">      x.store(<span class="number">3</span>)         c = a + b    y.load()</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">      a = <span class="number">1</span>      b = <span class="number">2</span></span><br><span class="line"><span class="type">T1</span> ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ------+--------------------+--------+--------&gt;</span><br><span class="line">      x.store(<span class="number">3</span>)          y.load()   c = a + b</span><br><span class="line"></span><br><span class="line">亦或者</span><br><span class="line"></span><br><span class="line">     b = <span class="number">2</span>       a = <span class="number">1</span></span><br><span class="line"><span class="type">T1</span> ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ------+--------------------+--------+--------&gt;</span><br><span class="line">      y.load()            c = a + b  x.store(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 <code>c</code> 对 <code>a</code> 和 <code>b</code> 产生依赖，而 <code>x</code> 和 <code>y</code> 在此例子中表现为没有关系（但实际情况中我们需要更详细的信息才能确定 <code>x</code> 与 <code>y</code> 确实无关）</p></li><li><p>最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。当然这已经不在我们的讨论范围之内了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    x.store(<span class="number">3</span>)  x.store(<span class="number">4</span>)</span><br><span class="line"><span class="type">T1</span> ----+-----------+--------------------------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">T2</span> ---------+------------+--------------------+--------+--------&gt;</span><br><span class="line">         x.read      x.read()           x.read()   x.read()</span><br></pre></td></tr></table></figure><p>在上面的情况中，如果我们假设 x 的初始值为 0，则 <code>T2</code> 中四次 <code>x.read()</code> 结果可能但不限于以下情况：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3<span class="number"> 4 </span>4<span class="number"> 4 </span>// x 的写操作被很快观察到</span><br><span class="line">0<span class="number"> 3 </span>3<span class="number"> 4 </span>// x 的写操作被观察到的时间存在一定延迟</span><br><span class="line">0<span class="number"> 0 </span>0<span class="number"> 4 </span>// 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到</span><br><span class="line">0<span class="number"> 0 </span>0<span class="number"> 0 </span>// 在当前时间段内 x 的写操作均未被观察到，</span><br><span class="line">        // 但未来某个时间点上一定能观察到 x 为<span class="number"> 4 </span>的情况</span><br></pre></td></tr></table></figure></li></ol><h3 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h3><p>为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 <code>std::memory_order</code> 的选项，表达了四种多线程间的同步模型：</p><ol><li><p>宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过 <code>std::memory_order_relaxed</code> 指定。我们来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;std::thread&gt; vt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    vt.<span class="built_in">emplace_back</span>([&amp;]()&#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;current counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li><p>释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 <code>x</code> 的写操作，线程 <code>B</code> 仅依赖其中第三次 <code>x</code> 的写操作，与 <code>x</code> 的前两次写行为无关，则当 <code>A</code> 主动 <code>x.release()</code> 时候（即使用 <code>std::memory_order_release</code>），选项 <code>std::memory_order_consume</code> 能够确保 <code>B</code> 在调用 <code>x.load()</code> 时候观察到 <code>A</code> 中第三次对 <code>x</code> 的写操作。我们来看一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化为 nullptr 防止 consumer 线程从野指针进行读取</span></span><br><span class="line">std::<span class="variable constant_">atomic</span>&lt;<span class="keyword">int</span>*&gt; <span class="title function_ invoke__">ptr</span>(nullptr);</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line">std::<span class="variable constant_">thread</span> <span class="title function_ invoke__">producer</span>([&amp;]() &#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</span><br><span class="line">    v = <span class="number">1024</span>;</span><br><span class="line">    ptr.<span class="title function_ invoke__">store</span>(p, std::<span class="variable constant_">memory_order_release</span>);</span><br><span class="line">&#125;);</span><br><span class="line">std::<span class="variable constant_">thread</span> <span class="title function_ invoke__">consumer</span>([&amp;]() &#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">while</span>(!(p = ptr.<span class="title function_ invoke__">load</span>(std::<span class="variable constant_">memory_order_consume</span>)));</span><br><span class="line"></span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::<span class="variable constant_">endl</span>;</span><br><span class="line">&#125;);</span><br><span class="line">producer.<span class="title function_ invoke__">join</span>();</span><br><span class="line">consumer.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure></li><li><p>释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 <code>std::memory_order_release</code> 和获取 <code>std::memory_order_acquire</code> 之间规定时序，即发生在释放（release）操作之前的<strong>所有</strong>写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。</p><p>可以看到，<code>std::memory_order_release</code> 确保了它之前的写操作不会发生在释放操作之后，是一个向后的屏障（backward），而 <code>std::memory_order_acquire</code> 确保了它之前的写行为不会发生在该获取操作之后，是一个向前的屏障（forward）。对于选项 <code>std::memory_order_acq_rel</code> 而言，则结合了这两者的特点，唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排并越过此操作的前后：</p><p>我们来看一个例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::thread <span class="title">release</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    v.push_back(<span class="number">42</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    flag.store(<span class="number">1</span>, std::memory_order_release);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">acqrel</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> expected = <span class="number">1</span>; <span class="comment">// must before compare_exchange_strong</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_acq_rel))</span></span></span><br><span class="line"><span class="params"><span class="function">        expected = <span class="number">1</span>; <span class="comment">// must after compare_exchange_strong</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// flag has changed to 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">acquire</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; v.at(<span class="number">0</span>) &lt;&lt; std::endl; <span class="comment">// must be 42</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">release.<span class="built_in">join</span>();</span><br><span class="line">acqrel.<span class="built_in">join</span>();</span><br><span class="line">acquire.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>在此例中我们使用了 <code>compare_exchange_strong</code> 比较交换原语（Compare-and-swap primitive），它有一个更弱的版本，即 <code>compare_exchange_weak</code>，它允许即便交换成功，也仍然返回 <code>false</code> 失败。其原因是因为在某些平台上虚假故障导致的，具体而言，当 CPU 进行上下文切换时，另一线程加载同一地址产生的不一致。除此之外，<code>compare_exchange_strong</code> 的性能可能稍差于 <code>compare_exchange_weak</code>，但大部分情况下，鉴于其使用的复杂度而言，<code>compare_exchange_weak</code> 应该被有限考虑。</p></li><li><p>顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 <code>std::memory_order_seq_cst</code> 进行指定。最后来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;std::thread&gt; vt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    vt.<span class="built_in">emplace_back</span>([&amp;]()&#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;current counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这个例子与第一个宽松模型的例子本质上没有区别，仅仅只是将原子操作的内存顺序修改为了 <code>memory_order_seq_cst</code>，有兴趣的读者可以自行编写程序测量这两种不同内存顺序导致的性能差异。</p></li></ol><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>C++11 语言层提供了并发编程的相关支持，本节简单的介绍了 <code>std::thread</code>, <code>std::mutex</code>, <code>std::future</code> 这些并发编程中不可回避的重要工具。 除此之外，我们还介绍了 C++11 最重要的几个特性之一的『内存模型』， 它们为 C++ 在标准化高性能计算中提供了重要的基础。</p><ol><li><p>请编写一个简单的线程池，提供如下功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadPool <span class="title">p</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 指定四个工作线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务在池中入队，并返回一个 std::future</span></span><br><span class="line"><span class="keyword">auto</span> f = pool.<span class="built_in">enqueue</span>([](<span class="type">int</span> life) &#123;</span><br><span class="line">    <span class="keyword">return</span> meaning;</span><br><span class="line">&#125;, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 future 中获得执行结果</span></span><br><span class="line">std::cout &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li><p>请使用 <code>std::atomic&lt;bool&gt;</code> 实现一个互斥锁。</p></li></ol><h1 id="第-8-章-文件系统"><a href="#第-8-章-文件系统" class="headerlink" title="第 8 章 文件系统"></a>第 8 章 文件系统</h1><p>文件系统库提供了文件系统、路径、常规文件、目录等等相关组件进行操作的相关功能。和正则表达式库类似，他也是最先由 boost 发起，并最终被合并为 C++ 标准的众多库之一。</p><h1 id="第-9-章-其他杂项"><a href="#第-9-章-其他杂项" class="headerlink" title="第 9 章 其他杂项"></a>第 9 章 其他杂项</h1><h2 id="9-1-新类型"><a href="#9-1-新类型" class="headerlink" title="9.1 新类型"></a>9.1 新类型</h2><h3 id="long-long-int"><a href="#long-long-int" class="headerlink" title="long long int"></a><code>long long int</code></h3><p><code>long long int</code> 并不是 C++11 最先引入的，其实早在 C99， <code>long long int</code> 就已经被纳入 C 标准中，所以大部分的编译器早已支持。 C++11 的工作则是正式把它纳入标准库， 规定了一个 <code>long long int</code> 类型至少具备 64 位的比特数。</p><h2 id="9-2-noexcept-的修饰和操作"><a href="#9-2-noexcept-的修饰和操作" class="headerlink" title="9.2 noexcept 的修饰和操作"></a>9.2 noexcept 的修饰和操作</h2><p>C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。 然而在 C++11 之前，几乎没有人去使用在函数名后书写异常声明表达式， 从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用， 你更不应该主动去了解它。</p><p>C++11 将异常的声明简化为以下两种情况：</p><ol><li>函数可能抛出任何异常</li><li>函数不能抛出任何异常</li></ol><p>并使用 <code>noexcept</code> 对这两种行为进行限制，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">may_throw</span>()</span>; <span class="comment">// 可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_throw</span>() noexcept</span>; <span class="comment">// 不可能抛出异常</span></span><br></pre></td></tr></table></figure><p>使用 <code>noexcept</code> 修饰过的函数如果抛出异常，编译器会使用 <code>std::terminate()</code> 来立即终止程序运行。</p><p><code>noexcept</code> 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> non_block_throw = []&#123;</span><br><span class="line">    <span class="built_in">may_throw</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> block_throw = []() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">no_throw</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha</span><br><span class="line">        &lt;&lt; <span class="string">&quot;may_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">may_throw</span>()) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;no_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">no_throw</span>()) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;lmay_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">non_block_throw</span>()) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;lno_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">block_throw</span>()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>noexcept</code> 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。例如：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    may_throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;捕获异常, 来自 may_throw()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    non_block_throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;捕获异常, 来自 non_block_throw()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    block_throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;捕获异常, 来自 block_throw()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获异常, 来自 <span class="built_in">may_throw</span>()</span><br><span class="line">捕获异常, 来自 <span class="built_in">non_block_throw</span>()</span><br></pre></td></tr></table></figure><h2 id="9-3-字面量"><a href="#9-3-字面量" class="headerlink" title="9.3 字面量"></a>9.3 字面量</h2><h3 id="原始字符串字面量"><a href="#原始字符串字面量" class="headerlink" title="原始字符串字面量"></a>原始字符串字面量</h3><p>传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情， 比如一个包含 HTML 本体的字符串需要添加大量的转义符， 例如一个Windows 上的文件路径经常会：<code>C:\\File\\To\\Path</code>。</p><p>C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 <code>R</code> 来修饰这个字符串， 同时，将原始字符串使用括号包裹，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    std::string <span class="built_in">str</span> = <span class="string">R&quot;(C:\File\To\Path)&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">str</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义字面量"><a href="#自定义字面量" class="headerlink" title="自定义字面量"></a>自定义字面量</h3><p>C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 字符串字面量自定义必须设置如下的参数列表</span><br><span class="line">std::string operato<span class="string">r&quot;&quot;</span> _wow1(const char *wow1, size_t <span class="built_in">len</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::string(wow1)+<span class="string">&quot;woooooooooow, amazing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string operato<span class="string">r&quot;&quot;</span> _wow2 (unsigned long long i) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::to_string(i)+<span class="string">&quot;woooooooooow, amazing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    auto <span class="built_in">str</span> = <span class="string">&quot;abc&quot;</span>_wow1;</span><br><span class="line">    auto num = 1_wow2;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">str</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义字面量支持四种字面量：</p><ol><li>整型字面量：重载时必须使用 <code>unsigned long long</code>、<code>const char *</code>、模板字面量算符参数，在上面的代码中使用的是前者；</li><li>浮点型字面量：重载时必须使用 <code>long double</code>、<code>const char *</code>、模板字面量算符；</li><li>字符串字面量：必须使用 <code>(const char *, size_t)</code> 形式的参数表；</li><li>字符字面量：参数只能是 <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code> 这几种类型。</li></ol><h2 id="9-4-内存对齐"><a href="#9-4-内存对齐" class="headerlink" title="9.4 内存对齐"></a>9.4 内存对齐</h2><p>C++ 11 引入了两个新的关键字 <code>alignof</code> 和 <code>alignas</code> 来支持对内存对齐进行控制。 <code>alignof</code> 关键字能够获得一个与平台相关的 <code>std::size_t</code> 类型的值，用于查询该平台的对齐方式。 当然我们有时候并不满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 <code>alignas</code> 来重新修饰某个结构的对齐方式。我们来看两个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="type">char</span>      a;</span><br><span class="line">    <span class="type">int</span>       b;</span><br><span class="line">    <span class="type">double</span>    c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(std::<span class="type">max_align_t</span>) AlignasStorage &#123;</span><br><span class="line">    <span class="type">char</span>      a;</span><br><span class="line">    <span class="type">int</span>       b;</span><br><span class="line">    <span class="type">double</span>    c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(Storage) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(AlignasStorage) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>std::max_align_t</code> 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 <code>long double</code>，因此我们这里得到的 <code>AlignasStorage</code> 的对齐要求是 8 或 16。</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>本节介绍的几个特性是从仍未介绍的现代 C++ 新特性里使用频次较靠前的特性了，<code>noexcept</code> 是最为重要的特性，它的一个功能在于能够阻止异常的扩散传播，有效的让编译器最大限度的优化我们的代码。</p>]]></content>
    
    
    <summary type="html">现代 C++ 教程，高速上手 C++ 11/14/17/20</summary>
    
    
    
    <category term="Cpp" scheme="https://penge666.github.io/categories/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/categories/Cpp/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://penge666.github.io/tags/Cpp/"/>
    
    <category term="读书笔记" scheme="https://penge666.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
